/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-cose-bilkent";
exports.ids = ["vendor-chunks/cytoscape-cose-bilkent"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/./node_modules/cose-base/cose-base.js\"));\n    else {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_691__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_691__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_691__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_691__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_691__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_691__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_691__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_691__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_691__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_691__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_691__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_691__(__nested_webpack_require_691__.s = 1);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_3704__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_3704__(0).layoutBase.LayoutConstants;\n            var FDLayoutConstants = __nested_webpack_require_3704__(0).layoutBase.FDLayoutConstants;\n            var CoSEConstants = __nested_webpack_require_3704__(0).CoSEConstants;\n            var CoSELayout = __nested_webpack_require_3704__(0).CoSELayout;\n            var CoSENode = __nested_webpack_require_3704__(0).CoSENode;\n            var PointD = __nested_webpack_require_3704__(0).layoutBase.PointD;\n            var DimensionD = __nested_webpack_require_3704__(0).layoutBase.DimensionD;\n            var defaults = {\n                // Called on `layoutready`\n                ready: function ready() {},\n                // Called on `layoutstop`\n                stop: function stop() {},\n                // 'draft', 'default' or 'proof\" \n                // - 'draft' fast cooling rate \n                // - 'default' moderate cooling rate \n                // - \"proof\" slow cooling rate\n                quality: \"default\",\n                // include labels in node dimensions\n                nodeDimensionsIncludeLabels: false,\n                // number of ticks per frame; higher is faster but more jerky\n                refresh: 30,\n                // Whether to fit the network view after when done\n                fit: true,\n                // Padding on fit\n                padding: 10,\n                // Whether to enable incremental mode\n                randomize: true,\n                // Node repulsion (non overlapping) multiplier\n                nodeRepulsion: 4500,\n                // Ideal edge (non nested) length\n                idealEdgeLength: 50,\n                // Divisor to compute edge forces\n                edgeElasticity: 0.45,\n                // Nesting factor (multiplier) to compute ideal edge length for nested edges\n                nestingFactor: 0.1,\n                // Gravity force (constant)\n                gravity: 0.25,\n                // Maximum number of iterations to perform\n                numIter: 2500,\n                // For enabling tiling\n                tile: true,\n                // Type of layout animation. The option set is {'during', 'end', false}\n                animate: \"end\",\n                // Duration for animate:end\n                animationDuration: 500,\n                // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n                tilingPaddingVertical: 10,\n                // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n                tilingPaddingHorizontal: 10,\n                // Gravity range (constant) for compounds\n                gravityRangeCompound: 1.5,\n                // Gravity force (constant) for compounds\n                gravityCompound: 1.0,\n                // Gravity range (constant)\n                gravityRange: 3.8,\n                // Initial cooling factor for incremental layout\n                initialEnergyOnIncremental: 0.5\n            };\n            function extend(defaults, options) {\n                var obj = {};\n                for(var i in defaults){\n                    obj[i] = defaults[i];\n                }\n                for(var i in options){\n                    obj[i] = options[i];\n                }\n                return obj;\n            }\n            ;\n            function _CoSELayout(_options) {\n                this.options = extend(defaults, _options);\n                getUserOptions(this.options);\n            }\n            var getUserOptions = function getUserOptions(options) {\n                if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n                if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n                if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n                if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n                if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n                if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n                if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n                if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n                if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n                if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n                if (options.quality == \"draft\") LayoutConstants.QUALITY = 0;\n                else if (options.quality == \"proof\") LayoutConstants.QUALITY = 2;\n                else LayoutConstants.QUALITY = 1;\n                CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n                CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n                CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n                CoSEConstants.TILE = options.tile;\n                CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \"function\" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n                CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \"function\" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n            };\n            _CoSELayout.prototype.run = function() {\n                var ready;\n                var frameId;\n                var options = this.options;\n                var idToLNode = this.idToLNode = {};\n                var layout = this.layout = new CoSELayout();\n                var self = this;\n                self.stopped = false;\n                this.cy = this.options.cy;\n                this.cy.trigger({\n                    type: \"layoutstart\",\n                    layout: this\n                });\n                var gm = layout.newGraphManager();\n                this.gm = gm;\n                var nodes = this.options.eles.nodes();\n                var edges = this.options.eles.edges();\n                this.root = gm.addRoot();\n                this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n                for(var i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    var sourceNode = this.idToLNode[edge.data(\"source\")];\n                    var targetNode = this.idToLNode[edge.data(\"target\")];\n                    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                        e1.id = edge.id();\n                    }\n                }\n                var getPositions = function getPositions(ele, i) {\n                    if (typeof ele === \"number\") {\n                        ele = i;\n                    }\n                    var theId = ele.data(\"id\");\n                    var lNode = self.idToLNode[theId];\n                    return {\n                        x: lNode.getRect().getCenterX(),\n                        y: lNode.getRect().getCenterY()\n                    };\n                };\n                /*\n   * Reposition nodes in iterations animatedly\n   */ var iterateAnimated = function iterateAnimated() {\n                    // Thigs to perform after nodes are repositioned on screen\n                    var afterReposition = function afterReposition() {\n                        if (options.fit) {\n                            options.cy.fit(options.eles, options.padding);\n                        }\n                        if (!ready) {\n                            ready = true;\n                            self.cy.one(\"layoutready\", options.ready);\n                            self.cy.trigger({\n                                type: \"layoutready\",\n                                layout: self\n                            });\n                        }\n                    };\n                    var ticksPerFrame = self.options.refresh;\n                    var isDone;\n                    for(var i = 0; i < ticksPerFrame && !isDone; i++){\n                        isDone = self.stopped || self.layout.tick();\n                    }\n                    // If layout is done\n                    if (isDone) {\n                        // If the layout is not a sublayout and it is successful perform post layout.\n                        if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n                            layout.doPostLayout();\n                        }\n                        // If layout has a tilingPostLayout function property call it.\n                        if (layout.tilingPostLayout) {\n                            layout.tilingPostLayout();\n                        }\n                        layout.isLayoutFinished = true;\n                        self.options.eles.nodes().positions(getPositions);\n                        afterReposition();\n                        // trigger layoutstop when the layout stops (e.g. finishes)\n                        self.cy.one(\"layoutstop\", self.options.stop);\n                        self.cy.trigger({\n                            type: \"layoutstop\",\n                            layout: self\n                        });\n                        if (frameId) {\n                            cancelAnimationFrame(frameId);\n                        }\n                        ready = false;\n                        return;\n                    }\n                    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n                    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n                    // use position of their ancestors or dummy ancestors\n                    options.eles.nodes().positions(function(ele, i) {\n                        if (typeof ele === \"number\") {\n                            ele = i;\n                        }\n                        // If ele is a compound node, then its position will be defined by its children\n                        if (!ele.isParent()) {\n                            var theId = ele.id();\n                            var pNode = animationData[theId];\n                            var temp = ele;\n                            // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n                            while(pNode == null){\n                                pNode = animationData[temp.data(\"parent\")] || animationData[\"DummyCompound_\" + temp.data(\"parent\")];\n                                animationData[theId] = pNode;\n                                temp = temp.parent()[0];\n                                if (temp == undefined) {\n                                    break;\n                                }\n                            }\n                            if (pNode != null) {\n                                return {\n                                    x: pNode.x,\n                                    y: pNode.y\n                                };\n                            } else {\n                                return {\n                                    x: ele.position(\"x\"),\n                                    y: ele.position(\"y\")\n                                };\n                            }\n                        }\n                    });\n                    afterReposition();\n                    frameId = requestAnimationFrame(iterateAnimated);\n                };\n                /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */ layout.addListener(\"layoutstarted\", function() {\n                    if (self.options.animate === \"during\") {\n                        frameId = requestAnimationFrame(iterateAnimated);\n                    }\n                });\n                layout.runLayout(); // Run cose layout\n                /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */ if (this.options.animate !== \"during\") {\n                    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n                    ready = false;\n                }\n                return this; // chaining\n            };\n            //Get the top most ones of a list of nodes\n            _CoSELayout.prototype.getTopMostNodes = function(nodes) {\n                var nodesMap = {};\n                for(var i = 0; i < nodes.length; i++){\n                    nodesMap[nodes[i].id()] = true;\n                }\n                var roots = nodes.filter(function(ele, i) {\n                    if (typeof ele === \"number\") {\n                        ele = i;\n                    }\n                    var parent = ele.parent()[0];\n                    while(parent != null){\n                        if (nodesMap[parent.id()]) {\n                            return false;\n                        }\n                        parent = parent.parent()[0];\n                    }\n                    return true;\n                });\n                return roots;\n            };\n            _CoSELayout.prototype.processChildrenList = function(parent, children, layout) {\n                var size = children.length;\n                for(var i = 0; i < size; i++){\n                    var theChild = children[i];\n                    var children_of_children = theChild.children();\n                    var theNode;\n                    var dimensions = theChild.layoutDimensions({\n                        nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n                    });\n                    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\"x\") - dimensions.w / 2, theChild.position(\"y\") - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                    } else {\n                        theNode = parent.add(new CoSENode(this.graphManager));\n                    }\n                    // Attach id to the layout node\n                    theNode.id = theChild.data(\"id\");\n                    // Attach the paddings of cy node to layout node\n                    theNode.paddingLeft = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingTop = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingRight = parseInt(theChild.css(\"padding\"));\n                    theNode.paddingBottom = parseInt(theChild.css(\"padding\"));\n                    //Attach the label properties to compound if labels will be included in node dimensions  \n                    if (this.options.nodeDimensionsIncludeLabels) {\n                        if (theChild.isParent()) {\n                            var labelWidth = theChild.boundingBox({\n                                includeLabels: true,\n                                includeNodes: false\n                            }).w;\n                            var labelHeight = theChild.boundingBox({\n                                includeLabels: true,\n                                includeNodes: false\n                            }).h;\n                            var labelPos = theChild.css(\"text-halign\");\n                            theNode.labelWidth = labelWidth;\n                            theNode.labelHeight = labelHeight;\n                            theNode.labelPos = labelPos;\n                        }\n                    }\n                    // Map the layout node\n                    this.idToLNode[theChild.data(\"id\")] = theNode;\n                    if (isNaN(theNode.rect.x)) {\n                        theNode.rect.x = 0;\n                    }\n                    if (isNaN(theNode.rect.y)) {\n                        theNode.rect.y = 0;\n                    }\n                    if (children_of_children != null && children_of_children.length > 0) {\n                        var theNewGraph;\n                        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                        this.processChildrenList(theNewGraph, children_of_children, layout);\n                    }\n                }\n            };\n            /**\n * @brief : called on continuous layouts to stop them before they finish\n */ _CoSELayout.prototype.stop = function() {\n                this.stopped = true;\n                return this; // chaining\n            };\n            var register = function register(cytoscape1) {\n                //  var Layout = getLayout( cytoscape );\n                cytoscape1(\"layout\", \"cose-bilkent\", _CoSELayout);\n            };\n            // auto reg for globals\n            if (typeof cytoscape !== \"undefined\") {\n                register(cytoscape);\n            }\n            module1.exports = register;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzIiwibWFwcGluZ3MiOiJBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsOERBQVc7U0FDeEMsRUFLcUQ7QUFDM0QsR0FBRyxJQUFJLEVBQUUsU0FBU0csNkJBQTZCO0lBQy9DLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDVCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNNLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVgsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtNLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNYLFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFUSw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS1AsUUFBT1UsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1BQU0sR0FBSyxPQUFPVixRQUFPRCxPQUFPO1FBQ2hDLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTixNQUFNLEdBQ04sTUFBTSxHQUFJLGtEQUFrRDtRQUM1RCxNQUFNLEdBQUlRLDhCQUFtQkEsQ0FBQ0ssQ0FBQyxHQUFHUDtRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLDBCQUEwQjtRQUNwQyxNQUFNLEdBQUlFLDhCQUFtQkEsQ0FBQ00sQ0FBQyxHQUFHUDtRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHlFQUF5RTtRQUNuRixNQUFNLEdBQUlDLDhCQUFtQkEsQ0FBQ0UsQ0FBQyxHQUFHLFNBQVNLLEtBQUs7WUFBSSxPQUFPQTtRQUFPO1FBQ2xFLE1BQU0sR0FDTixNQUFNLEdBQUksNkNBQTZDO1FBQ3ZELE1BQU0sR0FBSVAsOEJBQW1CQSxDQUFDUSxDQUFDLEdBQUcsU0FBU2hCLFFBQU8sRUFBRWlCLElBQUksRUFBRUMsTUFBTTtZQUNoRSxNQUFNLEdBQUssSUFBRyxDQUFDViw4QkFBbUJBLENBQUNXLENBQUMsQ0FBQ25CLFVBQVNpQixPQUFPO2dCQUNyRCxNQUFNLEdBQU1HLE9BQU9DLGNBQWMsQ0FBQ3JCLFVBQVNpQixNQUFNO29CQUNqRCxNQUFNLEdBQU9LLGNBQWM7b0JBQzNCLE1BQU0sR0FBT0MsWUFBWTtvQkFDekIsTUFBTSxHQUFPQyxLQUFLTjtnQkFDTjtZQUNaLE1BQU0sR0FBSztRQUNYLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTixNQUFNLEdBQUksdUVBQXVFO1FBQ2pGLE1BQU0sR0FBSVYsOEJBQW1CQSxDQUFDaUIsQ0FBQyxHQUFHLFNBQVN4QixPQUFNO1lBQ2pELE1BQU0sR0FBSyxJQUFJaUIsU0FBU2pCLFdBQVVBLFFBQU95QixVQUFVLEdBQ25ELE1BQU0sR0FBTSxTQUFTQztnQkFBZSxPQUFPMUIsT0FBTSxDQUFDLFVBQVU7WUFBRSxJQUM5RCxNQUFNLEdBQU0sU0FBUzJCO2dCQUFxQixPQUFPM0I7WUFBUTtZQUN6RCxNQUFNLEdBQUtPLDhCQUFtQkEsQ0FBQ1EsQ0FBQyxDQUFDRSxRQUFRLEtBQUtBO1lBQzlDLE1BQU0sR0FBSyxPQUFPQTtRQUNsQixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUlWLDhCQUFtQkEsQ0FBQ1csQ0FBQyxHQUFHLFNBQVNVLE1BQU0sRUFBRUMsUUFBUTtZQUFJLE9BQU9WLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDcEIsSUFBSSxDQUFDaUIsUUFBUUM7UUFBVztRQUM5SCxNQUFNLEdBQ04sTUFBTSxHQUFJLDBCQUEwQjtRQUNwQyxNQUFNLEdBQUl0Qiw4QkFBbUJBLENBQUN5QixDQUFDLEdBQUc7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1Q0FBdUM7UUFDakQsTUFBTSxHQUFJLE9BQU96Qiw4QkFBbUJBLENBQUNBLDhCQUFtQkEsQ0FBQzBCLENBQUMsR0FBRztJQUM3RCxNQUFNLEdBQUcsRUFFQztRQUNWLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU2pDLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHSztRQUVqQixHQUFHLEdBQUc7UUFDTixLQUFLLEdBQ0wsR0FBRyxHQUFJLFNBQVNKLE9BQU0sRUFBRUQsUUFBTyxFQUFFUSwrQkFBbUI7WUFFcEQ7WUFHQSxJQUFJMkIsa0JBQWtCM0IsK0JBQW1CQSxDQUFDLEdBQUc0QixVQUFVLENBQUNELGVBQWU7WUFDdkUsSUFBSUUsb0JBQW9CN0IsK0JBQW1CQSxDQUFDLEdBQUc0QixVQUFVLENBQUNDLGlCQUFpQjtZQUMzRSxJQUFJQyxnQkFBZ0I5QiwrQkFBbUJBLENBQUMsR0FBRzhCLGFBQWE7WUFDeEQsSUFBSUMsYUFBYS9CLCtCQUFtQkEsQ0FBQyxHQUFHK0IsVUFBVTtZQUNsRCxJQUFJQyxXQUFXaEMsK0JBQW1CQSxDQUFDLEdBQUdnQyxRQUFRO1lBQzlDLElBQUlDLFNBQVNqQywrQkFBbUJBLENBQUMsR0FBRzRCLFVBQVUsQ0FBQ0ssTUFBTTtZQUNyRCxJQUFJQyxhQUFhbEMsK0JBQW1CQSxDQUFDLEdBQUc0QixVQUFVLENBQUNNLFVBQVU7WUFFN0QsSUFBSUMsV0FBVztnQkFDYiwwQkFBMEI7Z0JBQzFCQyxPQUFPLFNBQVNBLFNBQVM7Z0JBQ3pCLHlCQUF5QjtnQkFDekJDLE1BQU0sU0FBU0EsUUFBUTtnQkFDdkIsaUNBQWlDO2dCQUNqQywrQkFBK0I7Z0JBQy9CLHFDQUFxQztnQkFDckMsOEJBQThCO2dCQUM5QkMsU0FBUztnQkFDVCxvQ0FBb0M7Z0JBQ3BDQyw2QkFBNkI7Z0JBQzdCLDZEQUE2RDtnQkFDN0RDLFNBQVM7Z0JBQ1Qsa0RBQWtEO2dCQUNsREMsS0FBSztnQkFDTCxpQkFBaUI7Z0JBQ2pCQyxTQUFTO2dCQUNULHFDQUFxQztnQkFDckNDLFdBQVc7Z0JBQ1gsOENBQThDO2dCQUM5Q0MsZUFBZTtnQkFDZixpQ0FBaUM7Z0JBQ2pDQyxpQkFBaUI7Z0JBQ2pCLGlDQUFpQztnQkFDakNDLGdCQUFnQjtnQkFDaEIsNEVBQTRFO2dCQUM1RUMsZUFBZTtnQkFDZiwyQkFBMkI7Z0JBQzNCQyxTQUFTO2dCQUNULDBDQUEwQztnQkFDMUNDLFNBQVM7Z0JBQ1Qsc0JBQXNCO2dCQUN0QkMsTUFBTTtnQkFDTix1RUFBdUU7Z0JBQ3ZFQyxTQUFTO2dCQUNULDJCQUEyQjtnQkFDM0JDLG1CQUFtQjtnQkFDbkIseUlBQXlJO2dCQUN6SUMsdUJBQXVCO2dCQUN2QiwySUFBMkk7Z0JBQzNJQyx5QkFBeUI7Z0JBQ3pCLHlDQUF5QztnQkFDekNDLHNCQUFzQjtnQkFDdEIseUNBQXlDO2dCQUN6Q0MsaUJBQWlCO2dCQUNqQiwyQkFBMkI7Z0JBQzNCQyxjQUFjO2dCQUNkLGdEQUFnRDtnQkFDaERDLDRCQUE0QjtZQUM5QjtZQUVBLFNBQVNDLE9BQU94QixRQUFRLEVBQUV5QixPQUFPO2dCQUMvQixJQUFJQyxNQUFNLENBQUM7Z0JBRVgsSUFBSyxJQUFJM0QsS0FBS2lDLFNBQVU7b0JBQ3RCMEIsR0FBRyxDQUFDM0QsRUFBRSxHQUFHaUMsUUFBUSxDQUFDakMsRUFBRTtnQkFDdEI7Z0JBRUEsSUFBSyxJQUFJQSxLQUFLMEQsUUFBUztvQkFDckJDLEdBQUcsQ0FBQzNELEVBQUUsR0FBRzBELE9BQU8sQ0FBQzFELEVBQUU7Z0JBQ3JCO2dCQUVBLE9BQU8yRDtZQUNUOztZQUVBLFNBQVNDLFlBQVlDLFFBQVE7Z0JBQzNCLElBQUksQ0FBQ0gsT0FBTyxHQUFHRCxPQUFPeEIsVUFBVTRCO2dCQUNoQ0MsZUFBZSxJQUFJLENBQUNKLE9BQU87WUFDN0I7WUFFQSxJQUFJSSxpQkFBaUIsU0FBU0EsZUFBZUosT0FBTztnQkFDbEQsSUFBSUEsUUFBUWhCLGFBQWEsSUFBSSxNQUFNZCxjQUFjbUMsMEJBQTBCLEdBQUdwQyxrQkFBa0JvQywwQkFBMEIsR0FBR0wsUUFBUWhCLGFBQWE7Z0JBQ2xKLElBQUlnQixRQUFRZixlQUFlLElBQUksTUFBTWYsY0FBY29DLG1CQUFtQixHQUFHckMsa0JBQWtCcUMsbUJBQW1CLEdBQUdOLFFBQVFmLGVBQWU7Z0JBQ3hJLElBQUllLFFBQVFkLGNBQWMsSUFBSSxNQUFNaEIsY0FBY3FDLHVCQUF1QixHQUFHdEMsa0JBQWtCc0MsdUJBQXVCLEdBQUdQLFFBQVFkLGNBQWM7Z0JBQzlJLElBQUljLFFBQVFiLGFBQWEsSUFBSSxNQUFNakIsY0FBY3NDLGtDQUFrQyxHQUFHdkMsa0JBQWtCdUMsa0NBQWtDLEdBQUdSLFFBQVFiLGFBQWE7Z0JBQ2xLLElBQUlhLFFBQVFaLE9BQU8sSUFBSSxNQUFNbEIsY0FBY3VDLHdCQUF3QixHQUFHeEMsa0JBQWtCd0Msd0JBQXdCLEdBQUdULFFBQVFaLE9BQU87Z0JBQ2xJLElBQUlZLFFBQVFYLE9BQU8sSUFBSSxNQUFNbkIsY0FBY3dDLGNBQWMsR0FBR3pDLGtCQUFrQnlDLGNBQWMsR0FBR1YsUUFBUVgsT0FBTztnQkFDOUcsSUFBSVcsUUFBUUgsWUFBWSxJQUFJLE1BQU0zQixjQUFjeUMsNEJBQTRCLEdBQUcxQyxrQkFBa0IwQyw0QkFBNEIsR0FBR1gsUUFBUUgsWUFBWTtnQkFDcEosSUFBSUcsUUFBUUosZUFBZSxJQUFJLE1BQU0xQixjQUFjMEMsaUNBQWlDLEdBQUczQyxrQkFBa0IyQyxpQ0FBaUMsR0FBR1osUUFBUUosZUFBZTtnQkFDcEssSUFBSUksUUFBUUwsb0JBQW9CLElBQUksTUFBTXpCLGNBQWMyQyxxQ0FBcUMsR0FBRzVDLGtCQUFrQjRDLHFDQUFxQyxHQUFHYixRQUFRTCxvQkFBb0I7Z0JBQ3RMLElBQUlLLFFBQVFGLDBCQUEwQixJQUFJLE1BQU01QixjQUFjNEMsa0NBQWtDLEdBQUc3QyxrQkFBa0I2QyxrQ0FBa0MsR0FBR2QsUUFBUUYsMEJBQTBCO2dCQUU1TCxJQUFJRSxRQUFRdEIsT0FBTyxJQUFJLFNBQVNYLGdCQUFnQmdELE9BQU8sR0FBRztxQkFBTyxJQUFJZixRQUFRdEIsT0FBTyxJQUFJLFNBQVNYLGdCQUFnQmdELE9BQU8sR0FBRztxQkFBT2hELGdCQUFnQmdELE9BQU8sR0FBRztnQkFFNUo3QyxjQUFjOEMsOEJBQThCLEdBQUcvQyxrQkFBa0IrQyw4QkFBOEIsR0FBR2pELGdCQUFnQmlELDhCQUE4QixHQUFHaEIsUUFBUXJCLDJCQUEyQjtnQkFDdExULGNBQWMrQyxtQkFBbUIsR0FBR2hELGtCQUFrQmdELG1CQUFtQixHQUFHbEQsZ0JBQWdCa0QsbUJBQW1CLEdBQUcsQ0FBQ2pCLFFBQVFqQixTQUFTO2dCQUNwSWIsY0FBY2dELE9BQU8sR0FBR2pELGtCQUFrQmlELE9BQU8sR0FBR25ELGdCQUFnQm1ELE9BQU8sR0FBR2xCLFFBQVFULE9BQU87Z0JBQzdGckIsY0FBY2lELElBQUksR0FBR25CLFFBQVFWLElBQUk7Z0JBQ2pDcEIsY0FBY2tELHVCQUF1QixHQUFHLE9BQU9wQixRQUFRUCxxQkFBcUIsS0FBSyxhQUFhTyxRQUFRUCxxQkFBcUIsQ0FBQ2pELElBQUksS0FBS3dELFFBQVFQLHFCQUFxQjtnQkFDbEt2QixjQUFjbUQseUJBQXlCLEdBQUcsT0FBT3JCLFFBQVFOLHVCQUF1QixLQUFLLGFBQWFNLFFBQVFOLHVCQUF1QixDQUFDbEQsSUFBSSxLQUFLd0QsUUFBUU4sdUJBQXVCO1lBQzVLO1lBRUFRLFlBQVl2QyxTQUFTLENBQUMyRCxHQUFHLEdBQUc7Z0JBQzFCLElBQUk5QztnQkFDSixJQUFJK0M7Z0JBQ0osSUFBSXZCLFVBQVUsSUFBSSxDQUFDQSxPQUFPO2dCQUMxQixJQUFJd0IsWUFBWSxJQUFJLENBQUNBLFNBQVMsR0FBRyxDQUFDO2dCQUNsQyxJQUFJQyxTQUFTLElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUl0RDtnQkFDL0IsSUFBSXVELE9BQU8sSUFBSTtnQkFFZkEsS0FBS0MsT0FBTyxHQUFHO2dCQUVmLElBQUksQ0FBQ0MsRUFBRSxHQUFHLElBQUksQ0FBQzVCLE9BQU8sQ0FBQzRCLEVBQUU7Z0JBRXpCLElBQUksQ0FBQ0EsRUFBRSxDQUFDQyxPQUFPLENBQUM7b0JBQUVDLE1BQU07b0JBQWVMLFFBQVEsSUFBSTtnQkFBQztnQkFFcEQsSUFBSU0sS0FBS04sT0FBT08sZUFBZTtnQkFDL0IsSUFBSSxDQUFDRCxFQUFFLEdBQUdBO2dCQUVWLElBQUlFLFFBQVEsSUFBSSxDQUFDakMsT0FBTyxDQUFDa0MsSUFBSSxDQUFDRCxLQUFLO2dCQUNuQyxJQUFJRSxRQUFRLElBQUksQ0FBQ25DLE9BQU8sQ0FBQ2tDLElBQUksQ0FBQ0MsS0FBSztnQkFFbkMsSUFBSSxDQUFDekcsSUFBSSxHQUFHcUcsR0FBR0ssT0FBTztnQkFDdEIsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMzRyxJQUFJLEVBQUUsSUFBSSxDQUFDNEcsZUFBZSxDQUFDTCxRQUFRUjtnQkFFakUsSUFBSyxJQUFJbkYsSUFBSSxHQUFHQSxJQUFJNkYsTUFBTUksTUFBTSxFQUFFakcsSUFBSztvQkFDckMsSUFBSWtHLE9BQU9MLEtBQUssQ0FBQzdGLEVBQUU7b0JBQ25CLElBQUltRyxhQUFhLElBQUksQ0FBQ2pCLFNBQVMsQ0FBQ2dCLEtBQUtFLElBQUksQ0FBQyxVQUFVO29CQUNwRCxJQUFJQyxhQUFhLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ2dCLEtBQUtFLElBQUksQ0FBQyxVQUFVO29CQUNwRCxJQUFJRCxlQUFlRSxjQUFjRixXQUFXRyxlQUFlLENBQUNELFlBQVlKLE1BQU0sSUFBSSxHQUFHO3dCQUNuRixJQUFJTSxLQUFLZCxHQUFHZSxHQUFHLENBQUNyQixPQUFPc0IsT0FBTyxJQUFJTixZQUFZRTt3QkFDOUNFLEdBQUdHLEVBQUUsR0FBR1IsS0FBS1EsRUFBRTtvQkFDakI7Z0JBQ0Y7Z0JBRUEsSUFBSUMsZUFBZSxTQUFTQSxhQUFhQyxHQUFHLEVBQUU1RyxDQUFDO29CQUM3QyxJQUFJLE9BQU80RyxRQUFRLFVBQVU7d0JBQzNCQSxNQUFNNUc7b0JBQ1I7b0JBQ0EsSUFBSTZHLFFBQVFELElBQUlSLElBQUksQ0FBQztvQkFDckIsSUFBSVUsUUFBUTFCLEtBQUtGLFNBQVMsQ0FBQzJCLE1BQU07b0JBRWpDLE9BQU87d0JBQ0xFLEdBQUdELE1BQU1FLE9BQU8sR0FBR0MsVUFBVTt3QkFDN0JDLEdBQUdKLE1BQU1FLE9BQU8sR0FBR0csVUFBVTtvQkFDL0I7Z0JBQ0Y7Z0JBRUE7O0dBRUMsR0FDRCxJQUFJQyxrQkFBa0IsU0FBU0E7b0JBQzdCLDBEQUEwRDtvQkFDMUQsSUFBSUMsa0JBQWtCLFNBQVNBO3dCQUM3QixJQUFJM0QsUUFBUW5CLEdBQUcsRUFBRTs0QkFDZm1CLFFBQVE0QixFQUFFLENBQUMvQyxHQUFHLENBQUNtQixRQUFRa0MsSUFBSSxFQUFFbEMsUUFBUWxCLE9BQU87d0JBQzlDO3dCQUVBLElBQUksQ0FBQ04sT0FBTzs0QkFDVkEsUUFBUTs0QkFDUmtELEtBQUtFLEVBQUUsQ0FBQ2dDLEdBQUcsQ0FBQyxlQUFlNUQsUUFBUXhCLEtBQUs7NEJBQ3hDa0QsS0FBS0UsRUFBRSxDQUFDQyxPQUFPLENBQUM7Z0NBQUVDLE1BQU07Z0NBQWVMLFFBQVFDOzRCQUFLO3dCQUN0RDtvQkFDRjtvQkFFQSxJQUFJbUMsZ0JBQWdCbkMsS0FBSzFCLE9BQU8sQ0FBQ3BCLE9BQU87b0JBQ3hDLElBQUlrRjtvQkFFSixJQUFLLElBQUl4SCxJQUFJLEdBQUdBLElBQUl1SCxpQkFBaUIsQ0FBQ0MsUUFBUXhILElBQUs7d0JBQ2pEd0gsU0FBU3BDLEtBQUtDLE9BQU8sSUFBSUQsS0FBS0QsTUFBTSxDQUFDc0MsSUFBSTtvQkFDM0M7b0JBRUEsb0JBQW9CO29CQUNwQixJQUFJRCxRQUFRO3dCQUNWLDZFQUE2RTt3QkFDN0UsSUFBSXJDLE9BQU91QyxrQkFBa0IsTUFBTSxDQUFDdkMsT0FBT3dDLFdBQVcsRUFBRTs0QkFDdER4QyxPQUFPeUMsWUFBWTt3QkFDckI7d0JBRUEsOERBQThEO3dCQUM5RCxJQUFJekMsT0FBTzBDLGdCQUFnQixFQUFFOzRCQUMzQjFDLE9BQU8wQyxnQkFBZ0I7d0JBQ3pCO3dCQUVBMUMsT0FBTzJDLGdCQUFnQixHQUFHO3dCQUUxQjFDLEtBQUsxQixPQUFPLENBQUNrQyxJQUFJLENBQUNELEtBQUssR0FBR29DLFNBQVMsQ0FBQ3BCO3dCQUVwQ1U7d0JBRUEsMkRBQTJEO3dCQUMzRGpDLEtBQUtFLEVBQUUsQ0FBQ2dDLEdBQUcsQ0FBQyxjQUFjbEMsS0FBSzFCLE9BQU8sQ0FBQ3ZCLElBQUk7d0JBQzNDaUQsS0FBS0UsRUFBRSxDQUFDQyxPQUFPLENBQUM7NEJBQUVDLE1BQU07NEJBQWNMLFFBQVFDO3dCQUFLO3dCQUVuRCxJQUFJSCxTQUFTOzRCQUNYK0MscUJBQXFCL0M7d0JBQ3ZCO3dCQUVBL0MsUUFBUTt3QkFDUjtvQkFDRjtvQkFFQSxJQUFJK0YsZ0JBQWdCN0MsS0FBS0QsTUFBTSxDQUFDK0MsZ0JBQWdCLElBQUksOEZBQThGO29CQUVsSixpSkFBaUo7b0JBQ2pKLHFEQUFxRDtvQkFDckR4RSxRQUFRa0MsSUFBSSxDQUFDRCxLQUFLLEdBQUdvQyxTQUFTLENBQUMsU0FBVW5CLEdBQUcsRUFBRTVHLENBQUM7d0JBQzdDLElBQUksT0FBTzRHLFFBQVEsVUFBVTs0QkFDM0JBLE1BQU01Rzt3QkFDUjt3QkFDQSwrRUFBK0U7d0JBQy9FLElBQUksQ0FBQzRHLElBQUl1QixRQUFRLElBQUk7NEJBQ25CLElBQUl0QixRQUFRRCxJQUFJRixFQUFFOzRCQUNsQixJQUFJMEIsUUFBUUgsYUFBYSxDQUFDcEIsTUFBTTs0QkFDaEMsSUFBSXdCLE9BQU96Qjs0QkFDWCwyR0FBMkc7NEJBQzNHLE1BQU93QixTQUFTLEtBQU07Z0NBQ3BCQSxRQUFRSCxhQUFhLENBQUNJLEtBQUtqQyxJQUFJLENBQUMsVUFBVSxJQUFJNkIsYUFBYSxDQUFDLG1CQUFtQkksS0FBS2pDLElBQUksQ0FBQyxVQUFVO2dDQUNuRzZCLGFBQWEsQ0FBQ3BCLE1BQU0sR0FBR3VCO2dDQUN2QkMsT0FBT0EsS0FBS0MsTUFBTSxFQUFFLENBQUMsRUFBRTtnQ0FDdkIsSUFBSUQsUUFBUUUsV0FBVztvQ0FDckI7Z0NBQ0Y7NEJBQ0Y7NEJBQ0EsSUFBSUgsU0FBUyxNQUFNO2dDQUNqQixPQUFPO29DQUNMckIsR0FBR3FCLE1BQU1yQixDQUFDO29DQUNWRyxHQUFHa0IsTUFBTWxCLENBQUM7Z0NBQ1o7NEJBQ0YsT0FBTztnQ0FDTCxPQUFPO29DQUNMSCxHQUFHSCxJQUFJNEIsUUFBUSxDQUFDO29DQUNoQnRCLEdBQUdOLElBQUk0QixRQUFRLENBQUM7Z0NBQ2xCOzRCQUNGO3dCQUNGO29CQUNGO29CQUVBbkI7b0JBRUFwQyxVQUFVd0Qsc0JBQXNCckI7Z0JBQ2xDO2dCQUVBOztFQUVBLEdBQ0FqQyxPQUFPdUQsV0FBVyxDQUFDLGlCQUFpQjtvQkFDbEMsSUFBSXRELEtBQUsxQixPQUFPLENBQUNULE9BQU8sS0FBSyxVQUFVO3dCQUNyQ2dDLFVBQVV3RCxzQkFBc0JyQjtvQkFDbEM7Z0JBQ0Y7Z0JBRUFqQyxPQUFPd0QsU0FBUyxJQUFJLGtCQUFrQjtnQkFFdEM7O0dBRUMsR0FDRCxJQUFJLElBQUksQ0FBQ2pGLE9BQU8sQ0FBQ1QsT0FBTyxLQUFLLFVBQVU7b0JBQ3JDbUMsS0FBSzFCLE9BQU8sQ0FBQ2tDLElBQUksQ0FBQ0QsS0FBSyxHQUFHaUQsR0FBRyxDQUFDLFdBQVdDLGVBQWUsQ0FBQ3pELE1BQU1BLEtBQUsxQixPQUFPLEVBQUVpRCxlQUFlLGtGQUFrRjtvQkFDOUt6RSxRQUFRO2dCQUNWO2dCQUVBLE9BQU8sSUFBSSxFQUFFLFdBQVc7WUFDMUI7WUFFQSwwQ0FBMEM7WUFDMUMwQixZQUFZdkMsU0FBUyxDQUFDMkUsZUFBZSxHQUFHLFNBQVVMLEtBQUs7Z0JBQ3JELElBQUltRCxXQUFXLENBQUM7Z0JBQ2hCLElBQUssSUFBSTlJLElBQUksR0FBR0EsSUFBSTJGLE1BQU1NLE1BQU0sRUFBRWpHLElBQUs7b0JBQ3JDOEksUUFBUSxDQUFDbkQsS0FBSyxDQUFDM0YsRUFBRSxDQUFDMEcsRUFBRSxHQUFHLEdBQUc7Z0JBQzVCO2dCQUNBLElBQUlxQyxRQUFRcEQsTUFBTXFELE1BQU0sQ0FBQyxTQUFVcEMsR0FBRyxFQUFFNUcsQ0FBQztvQkFDdkMsSUFBSSxPQUFPNEcsUUFBUSxVQUFVO3dCQUMzQkEsTUFBTTVHO29CQUNSO29CQUNBLElBQUlzSSxTQUFTMUIsSUFBSTBCLE1BQU0sRUFBRSxDQUFDLEVBQUU7b0JBQzVCLE1BQU9BLFVBQVUsS0FBTTt3QkFDckIsSUFBSVEsUUFBUSxDQUFDUixPQUFPNUIsRUFBRSxHQUFHLEVBQUU7NEJBQ3pCLE9BQU87d0JBQ1Q7d0JBQ0E0QixTQUFTQSxPQUFPQSxNQUFNLEVBQUUsQ0FBQyxFQUFFO29CQUM3QjtvQkFDQSxPQUFPO2dCQUNUO2dCQUVBLE9BQU9TO1lBQ1Q7WUFFQW5GLFlBQVl2QyxTQUFTLENBQUMwRSxtQkFBbUIsR0FBRyxTQUFVdUMsTUFBTSxFQUFFVyxRQUFRLEVBQUU5RCxNQUFNO2dCQUM1RSxJQUFJK0QsT0FBT0QsU0FBU2hELE1BQU07Z0JBQzFCLElBQUssSUFBSWpHLElBQUksR0FBR0EsSUFBSWtKLE1BQU1sSixJQUFLO29CQUM3QixJQUFJbUosV0FBV0YsUUFBUSxDQUFDakosRUFBRTtvQkFDMUIsSUFBSW9KLHVCQUF1QkQsU0FBU0YsUUFBUTtvQkFDNUMsSUFBSUk7b0JBRUosSUFBSUMsYUFBYUgsU0FBU0ksZ0JBQWdCLENBQUM7d0JBQ3pDbEgsNkJBQTZCLElBQUksQ0FBQ3FCLE9BQU8sQ0FBQ3JCLDJCQUEyQjtvQkFDdkU7b0JBRUEsSUFBSThHLFNBQVNLLFVBQVUsTUFBTSxRQUFRTCxTQUFTTSxXQUFXLE1BQU0sTUFBTTt3QkFDbkVKLFVBQVVmLE9BQU85QixHQUFHLENBQUMsSUFBSTFFLFNBQVNxRCxPQUFPdUUsWUFBWSxFQUFFLElBQUkzSCxPQUFPb0gsU0FBU1gsUUFBUSxDQUFDLE9BQU9jLFdBQVdLLENBQUMsR0FBRyxHQUFHUixTQUFTWCxRQUFRLENBQUMsT0FBT2MsV0FBV00sQ0FBQyxHQUFHLElBQUksSUFBSTVILFdBQVc2SCxXQUFXUCxXQUFXSyxDQUFDLEdBQUdFLFdBQVdQLFdBQVdNLENBQUM7b0JBQzNOLE9BQU87d0JBQ0xQLFVBQVVmLE9BQU85QixHQUFHLENBQUMsSUFBSTFFLFNBQVMsSUFBSSxDQUFDNEgsWUFBWTtvQkFDckQ7b0JBQ0EsK0JBQStCO29CQUMvQkwsUUFBUTNDLEVBQUUsR0FBR3lDLFNBQVMvQyxJQUFJLENBQUM7b0JBQzNCLGdEQUFnRDtvQkFDaERpRCxRQUFRUyxXQUFXLEdBQUdDLFNBQVNaLFNBQVNhLEdBQUcsQ0FBQztvQkFDNUNYLFFBQVFZLFVBQVUsR0FBR0YsU0FBU1osU0FBU2EsR0FBRyxDQUFDO29CQUMzQ1gsUUFBUWEsWUFBWSxHQUFHSCxTQUFTWixTQUFTYSxHQUFHLENBQUM7b0JBQzdDWCxRQUFRYyxhQUFhLEdBQUdKLFNBQVNaLFNBQVNhLEdBQUcsQ0FBQztvQkFFOUMseUZBQXlGO29CQUN6RixJQUFJLElBQUksQ0FBQ3RHLE9BQU8sQ0FBQ3JCLDJCQUEyQixFQUFFO3dCQUM1QyxJQUFJOEcsU0FBU2hCLFFBQVEsSUFBSTs0QkFDdkIsSUFBSWlDLGFBQWFqQixTQUFTa0IsV0FBVyxDQUFDO2dDQUFFQyxlQUFlO2dDQUFNQyxjQUFjOzRCQUFNLEdBQUdaLENBQUM7NEJBQ3JGLElBQUlhLGNBQWNyQixTQUFTa0IsV0FBVyxDQUFDO2dDQUFFQyxlQUFlO2dDQUFNQyxjQUFjOzRCQUFNLEdBQUdYLENBQUM7NEJBQ3RGLElBQUlhLFdBQVd0QixTQUFTYSxHQUFHLENBQUM7NEJBQzVCWCxRQUFRZSxVQUFVLEdBQUdBOzRCQUNyQmYsUUFBUW1CLFdBQVcsR0FBR0E7NEJBQ3RCbkIsUUFBUW9CLFFBQVEsR0FBR0E7d0JBQ3JCO29CQUNGO29CQUVBLHNCQUFzQjtvQkFDdEIsSUFBSSxDQUFDdkYsU0FBUyxDQUFDaUUsU0FBUy9DLElBQUksQ0FBQyxNQUFNLEdBQUdpRDtvQkFFdEMsSUFBSXFCLE1BQU1yQixRQUFRc0IsSUFBSSxDQUFDNUQsQ0FBQyxHQUFHO3dCQUN6QnNDLFFBQVFzQixJQUFJLENBQUM1RCxDQUFDLEdBQUc7b0JBQ25CO29CQUVBLElBQUkyRCxNQUFNckIsUUFBUXNCLElBQUksQ0FBQ3pELENBQUMsR0FBRzt3QkFDekJtQyxRQUFRc0IsSUFBSSxDQUFDekQsQ0FBQyxHQUFHO29CQUNuQjtvQkFFQSxJQUFJa0Msd0JBQXdCLFFBQVFBLHFCQUFxQm5ELE1BQU0sR0FBRyxHQUFHO3dCQUNuRSxJQUFJMkU7d0JBQ0pBLGNBQWN6RixPQUFPMEYsZUFBZSxHQUFHckUsR0FBRyxDQUFDckIsT0FBTzJGLFFBQVEsSUFBSXpCO3dCQUM5RCxJQUFJLENBQUN0RCxtQkFBbUIsQ0FBQzZFLGFBQWF4QixzQkFBc0JqRTtvQkFDOUQ7Z0JBQ0Y7WUFDRjtZQUVBOztDQUVDLEdBQ0R2QixZQUFZdkMsU0FBUyxDQUFDYyxJQUFJLEdBQUc7Z0JBQzNCLElBQUksQ0FBQ2tELE9BQU8sR0FBRztnQkFFZixPQUFPLElBQUksRUFBRSxXQUFXO1lBQzFCO1lBRUEsSUFBSTBGLFdBQVcsU0FBU0EsU0FBU0MsVUFBUztnQkFDeEMsd0NBQXdDO2dCQUV4Q0EsV0FBVSxVQUFVLGdCQUFnQnBIO1lBQ3RDO1lBRUEsdUJBQXVCO1lBQ3ZCLElBQUksT0FBT29ILGNBQWMsYUFBYTtnQkFDcENELFNBQVNDO1lBQ1g7WUFFQXpMLFFBQU9ELE9BQU8sR0FBR3lMO1FBRWpCLEdBQUcsR0FBRztLQUNJO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5lcmdleC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1jb3NlLWJpbGtlbnQvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC5qcz8wYTE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJjb3NlLWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY3l0b3NjYXBlQ29zZUJpbGtlbnRcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImN5dG9zY2FwZUNvc2VCaWxrZW50XCJdID0gZmFjdG9yeShyb290W1wiY29zZUJhc2VcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkNvU0VDb25zdGFudHM7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRUxheW91dDtcbnZhciBDb1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRU5vZGU7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkRpbWVuc2lvbkQ7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAvLyAnZHJhZnQnLCAnZGVmYXVsdCcgb3IgJ3Byb29mXCIgXG4gIC8vIC0gJ2RyYWZ0JyBmYXN0IGNvb2xpbmcgcmF0ZSBcbiAgLy8gLSAnZGVmYXVsdCcgbW9kZXJhdGUgY29vbGluZyByYXRlIFxuICAvLyAtIFwicHJvb2ZcIiBzbG93IGNvb2xpbmcgcmF0ZVxuICBxdWFsaXR5OiAnZGVmYXVsdCcsXG4gIC8vIGluY2x1ZGUgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9uc1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBudW1iZXIgb2YgdGlja3MgcGVyIGZyYW1lOyBoaWdoZXIgaXMgZmFzdGVyIGJ1dCBtb3JlIGplcmt5XG4gIHJlZnJlc2g6IDMwLFxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDEwLFxuICAvLyBXaGV0aGVyIHRvIGVuYWJsZSBpbmNyZW1lbnRhbCBtb2RlXG4gIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiA0NTAwLFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiA1MCxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiAwLjQ1LFxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDAuMSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDAuMjUsXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAyNTAwLFxuICAvLyBGb3IgZW5hYmxpbmcgdGlsaW5nXG4gIHRpbGU6IHRydWUsXG4gIC8vIFR5cGUgb2YgbGF5b3V0IGFuaW1hdGlvbi4gVGhlIG9wdGlvbiBzZXQgaXMgeydkdXJpbmcnLCAnZW5kJywgZmFsc2V9XG4gIGFuaW1hdGU6ICdlbmQnLFxuICAvLyBEdXJhdGlvbiBmb3IgYW5pbWF0ZTplbmRcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsOiAxMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSBob3Jpem9udGFsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogMTAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlSYW5nZUNvbXBvdW5kOiAxLjUsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlDb21wb3VuZDogMS4wLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudClcbiAgZ3Jhdml0eVJhbmdlOiAzLjgsXG4gIC8vIEluaXRpYWwgY29vbGluZyBmYWN0b3IgZm9yIGluY3JlbWVudGFsIGxheW91dFxuICBpbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDogMC41XG59O1xuXG5mdW5jdGlvbiBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gZGVmYXVsdHMpIHtcbiAgICBvYmpbaV0gPSBkZWZhdWx0c1tpXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIG9ialtpXSA9IG9wdGlvbnNbaV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gX0NvU0VMYXlvdXQoX29wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBfb3B0aW9ucyk7XG4gIGdldFVzZXJPcHRpb25zKHRoaXMub3B0aW9ucyk7XG59XG5cbnZhciBnZXRVc2VyT3B0aW9ucyA9IGZ1bmN0aW9uIGdldFVzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubm9kZVJlcHVsc2lvbiAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSBvcHRpb25zLm5vZGVSZXB1bHNpb247XG4gIGlmIChvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gIGlmIChvcHRpb25zLmVkZ2VFbGFzdGljaXR5ICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7XG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSAnZHJhZnQnKSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDA7ZWxzZSBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcbn07XG5cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZWFkeTtcbiAgdmFyIGZyYW1lSWQ7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgaWRUb0xOb2RlID0gdGhpcy5pZFRvTE5vZGUgPSB7fTtcbiAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0ID0gbmV3IENvU0VMYXlvdXQoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuc3RvcHBlZCA9IGZhbHNlO1xuXG4gIHRoaXMuY3kgPSB0aGlzLm9wdGlvbnMuY3k7XG5cbiAgdGhpcy5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiB0aGlzIH0pO1xuXG4gIHZhciBnbSA9IGxheW91dC5uZXdHcmFwaE1hbmFnZXIoKTtcbiAgdGhpcy5nbSA9IGdtO1xuXG4gIHZhciBub2RlcyA9IHRoaXMub3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMub3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG5cbiAgdGhpcy5yb290ID0gZ20uYWRkUm9vdCgpO1xuICB0aGlzLnByb2Nlc3NDaGlsZHJlbkxpc3QodGhpcy5yb290LCB0aGlzLmdldFRvcE1vc3ROb2Rlcyhub2RlcyksIGxheW91dCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZU5vZGUgPSB0aGlzLmlkVG9MTm9kZVtlZGdlLmRhdGEoXCJzb3VyY2VcIildO1xuICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5pZFRvTE5vZGVbZWRnZS5kYXRhKFwidGFyZ2V0XCIpXTtcbiAgICBpZiAoc291cmNlTm9kZSAhPT0gdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlLmdldEVkZ2VzQmV0d2Vlbih0YXJnZXROb2RlKS5sZW5ndGggPT0gMCkge1xuICAgICAgdmFyIGUxID0gZ20uYWRkKGxheW91dC5uZXdFZGdlKCksIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgdmFyIGxOb2RlID0gc2VsZi5pZFRvTE5vZGVbdGhlSWRdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGxOb2RlLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksXG4gICAgICB5OiBsTm9kZS5nZXRSZWN0KCkuZ2V0Q2VudGVyWSgpXG4gICAgfTtcbiAgfTtcblxuICAvKlxuICAgKiBSZXBvc2l0aW9uIG5vZGVzIGluIGl0ZXJhdGlvbnMgYW5pbWF0ZWRseVxuICAgKi9cbiAgdmFyIGl0ZXJhdGVBbmltYXRlZCA9IGZ1bmN0aW9uIGl0ZXJhdGVBbmltYXRlZCgpIHtcbiAgICAvLyBUaGlncyB0byBwZXJmb3JtIGFmdGVyIG5vZGVzIGFyZSByZXBvc2l0aW9uZWQgb24gc2NyZWVuXG4gICAgdmFyIGFmdGVyUmVwb3NpdGlvbiA9IGZ1bmN0aW9uIGFmdGVyUmVwb3NpdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICBvcHRpb25zLmN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVhZHkpIHtcbiAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmN5Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgc2VsZi5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBzZWxmIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGlja3NQZXJGcmFtZSA9IHNlbGYub3B0aW9ucy5yZWZyZXNoO1xuICAgIHZhciBpc0RvbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzUGVyRnJhbWUgJiYgIWlzRG9uZTsgaSsrKSB7XG4gICAgICBpc0RvbmUgPSBzZWxmLnN0b3BwZWQgfHwgc2VsZi5sYXlvdXQudGljaygpO1xuICAgIH1cblxuICAgIC8vIElmIGxheW91dCBpcyBkb25lXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBub3QgYSBzdWJsYXlvdXQgYW5kIGl0IGlzIHN1Y2Nlc3NmdWwgcGVyZm9ybSBwb3N0IGxheW91dC5cbiAgICAgIGlmIChsYXlvdXQuY2hlY2tMYXlvdXRTdWNjZXNzKCkgJiYgIWxheW91dC5pc1N1YkxheW91dCkge1xuICAgICAgICBsYXlvdXQuZG9Qb3N0TGF5b3V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGxheW91dCBoYXMgYSB0aWxpbmdQb3N0TGF5b3V0IGZ1bmN0aW9uIHByb3BlcnR5IGNhbGwgaXQuXG4gICAgICBpZiAobGF5b3V0LnRpbGluZ1Bvc3RMYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0LnRpbGluZ1Bvc3RMYXlvdXQoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBzZWxmLm9wdGlvbnMuZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhnZXRQb3NpdGlvbnMpO1xuXG4gICAgICBhZnRlclJlcG9zaXRpb24oKTtcblxuICAgICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICAgIHNlbGYuY3kub25lKCdsYXlvdXRzdG9wJywgc2VsZi5vcHRpb25zLnN0b3ApO1xuICAgICAgc2VsZi5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IHNlbGYgfSk7XG5cbiAgICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgfVxuXG4gICAgICByZWFkeSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRpb25EYXRhID0gc2VsZi5sYXlvdXQuZ2V0UG9zaXRpb25zRGF0YSgpOyAvLyBHZXQgcG9zaXRpb25zIG9mIGxheW91dCBub2RlcyBub3RlIHRoYXQgYWxsIG5vZGVzIG1heSBub3QgYmUgbGF5b3V0IG5vZGVzIGJlY2F1c2Ugb2YgdGlsaW5nXG5cbiAgICAvLyBQb3NpdGlvbiBub2RlcywgZm9yIHRoZSBub2RlcyB3aG9zZSBpZCBkb2VzIG5vdCBpbmNsdWRlZCBpbiBkYXRhIChiZWNhdXNlIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBwYXJlbnRzIGFuZCBpbmNsdWRlZCBpbiBkdW1teSBjb21wb3VuZHMpXG4gICAgLy8gdXNlIHBvc2l0aW9uIG9mIHRoZWlyIGFuY2VzdG9ycyBvciBkdW1teSBhbmNlc3RvcnNcbiAgICBvcHRpb25zLmVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZWxlID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGVsZSBpcyBhIGNvbXBvdW5kIG5vZGUsIHRoZW4gaXRzIHBvc2l0aW9uIHdpbGwgYmUgZGVmaW5lZCBieSBpdHMgY2hpbGRyZW5cbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgdmFyIHRoZUlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBwTm9kZSA9IGFuaW1hdGlvbkRhdGFbdGhlSWRdO1xuICAgICAgICB2YXIgdGVtcCA9IGVsZTtcbiAgICAgICAgLy8gSWYgcE5vZGUgaXMgdW5kZWZpbmVkIHNlYXJjaCB1bnRpbCBmaW5kaW5nIHBvc2l0aW9uIGRhdGEgb2YgaXRzIGZpcnN0IGFuY2VzdG9yIChJdCBtYXkgYmUgZHVtbXkgYXMgd2VsbClcbiAgICAgICAgd2hpbGUgKHBOb2RlID09IG51bGwpIHtcbiAgICAgICAgICBwTm9kZSA9IGFuaW1hdGlvbkRhdGFbdGVtcC5kYXRhKCdwYXJlbnQnKV0gfHwgYW5pbWF0aW9uRGF0YVsnRHVtbXlDb21wb3VuZF8nICsgdGVtcC5kYXRhKCdwYXJlbnQnKV07XG4gICAgICAgICAgYW5pbWF0aW9uRGF0YVt0aGVJZF0gPSBwTm9kZTtcbiAgICAgICAgICB0ZW1wID0gdGVtcC5wYXJlbnQoKVswXTtcbiAgICAgICAgICBpZiAodGVtcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwTm9kZS54LFxuICAgICAgICAgICAgeTogcE5vZGUueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGVsZS5wb3NpdGlvbigneCcpLFxuICAgICAgICAgICAgeTogZWxlLnBvc2l0aW9uKCd5JylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZnRlclJlcG9zaXRpb24oKTtcblxuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaXRlcmF0ZUFuaW1hdGVkKTtcbiAgfTtcblxuICAvKlxuICAqIExpc3RlbiAnbGF5b3V0c3RhcnRlZCcgZXZlbnQgYW5kIHN0YXJ0IGFuaW1hdGVkIGl0ZXJhdGlvbiBpZiBhbmltYXRlIG9wdGlvbiBpcyAnZHVyaW5nJ1xuICAqL1xuICBsYXlvdXQuYWRkTGlzdGVuZXIoJ2xheW91dHN0YXJ0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYub3B0aW9ucy5hbmltYXRlID09PSAnZHVyaW5nJykge1xuICAgICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpdGVyYXRlQW5pbWF0ZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGF5b3V0LnJ1bkxheW91dCgpOyAvLyBSdW4gY29zZSBsYXlvdXRcblxuICAvKlxuICAgKiBJZiBhbmltYXRlIG9wdGlvbiBpcyBub3QgJ2R1cmluZycgKCdlbmQnIG9yIGZhbHNlKSBwZXJmb3JtIHRoZXNlIGhlcmUgKElmIGl0IGlzICdkdXJpbmcnIHNpbWlsYXIgdGhpbmdzIGFyZSBhbHJlYWR5IHBlcmZvcm1lZClcbiAgICovXG4gIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gXCJkdXJpbmdcIikge1xuICAgIHNlbGYub3B0aW9ucy5lbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5sYXlvdXRQb3NpdGlvbnMoc2VsZiwgc2VsZi5vcHRpb25zLCBnZXRQb3NpdGlvbnMpOyAvLyBVc2UgbGF5b3V0IHBvc2l0aW9ucyB0byByZXBvc2l0aW9uIHRoZSBub2RlcyBpdCBjb25zaWRlcnMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgcmVhZHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy9HZXQgdGhlIHRvcCBtb3N0IG9uZXMgb2YgYSBsaXN0IG9mIG5vZGVzXG5fQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0VG9wTW9zdE5vZGVzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBub2Rlc01hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZXNNYXBbbm9kZXNbaV0uaWQoKV0gPSB0cnVlO1xuICB9XG4gIHZhciByb290cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGVsZSA9IGk7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KClbMF07XG4gICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobm9kZXNNYXBbcGFyZW50LmlkKCldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiByb290cztcbn07XG5cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5wcm9jZXNzQ2hpbGRyZW5MaXN0ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCkge1xuICB2YXIgc2l6ZSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgY2hpbGRyZW5fb2ZfY2hpbGRyZW4gPSB0aGVDaGlsZC5jaGlsZHJlbigpO1xuICAgIHZhciB0aGVOb2RlO1xuXG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGVDaGlsZC5sYXlvdXREaW1lbnNpb25zKHtcbiAgICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogdGhpcy5vcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsc1xuICAgIH0pO1xuXG4gICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQodGhlQ2hpbGQucG9zaXRpb24oJ3gnKSAtIGRpbWVuc2lvbnMudyAvIDIsIHRoZUNoaWxkLnBvc2l0aW9uKCd5JykgLSBkaW1lbnNpb25zLmggLyAyKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlcikpO1xuICAgIH1cbiAgICAvLyBBdHRhY2ggaWQgdG8gdGhlIGxheW91dCBub2RlXG4gICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAvLyBBdHRhY2ggdGhlIHBhZGRpbmdzIG9mIGN5IG5vZGUgdG8gbGF5b3V0IG5vZGVcbiAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ1RvcCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAvL0F0dGFjaCB0aGUgbGFiZWwgcHJvcGVydGllcyB0byBjb21wb3VuZCBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnMgIFxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAodGhlQ2hpbGQuaXNQYXJlbnQoKSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSB9KS53O1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UgfSkuaDtcbiAgICAgICAgdmFyIGxhYmVsUG9zID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxXaWR0aCA9IGxhYmVsV2lkdGg7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSBsYWJlbEhlaWdodDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvcyA9IGxhYmVsUG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICB0aGlzLmlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueCkpIHtcbiAgICAgIHRoZU5vZGUucmVjdC54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LnkpKSB7XG4gICAgICB0aGVOb2RlLnJlY3QueSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuX29mX2NoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW5fb2ZfY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRoZU5ld0dyYXBoO1xuICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgIHRoaXMucHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5fQ29TRUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGN5dG9zY2FwZSkge1xuICAvLyAgdmFyIExheW91dCA9IGdldExheW91dCggY3l0b3NjYXBlICk7XG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnY29zZS1iaWxrZW50JywgX0NvU0VMYXlvdXQpO1xufTtcblxuLy8gYXV0byByZWcgZm9yIGdsb2JhbHNcbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwidmFsdWUiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiTGF5b3V0Q29uc3RhbnRzIiwibGF5b3V0QmFzZSIsIkZETGF5b3V0Q29uc3RhbnRzIiwiQ29TRUNvbnN0YW50cyIsIkNvU0VMYXlvdXQiLCJDb1NFTm9kZSIsIlBvaW50RCIsIkRpbWVuc2lvbkQiLCJkZWZhdWx0cyIsInJlYWR5Iiwic3RvcCIsInF1YWxpdHkiLCJub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMiLCJyZWZyZXNoIiwiZml0IiwicGFkZGluZyIsInJhbmRvbWl6ZSIsIm5vZGVSZXB1bHNpb24iLCJpZGVhbEVkZ2VMZW5ndGgiLCJlZGdlRWxhc3RpY2l0eSIsIm5lc3RpbmdGYWN0b3IiLCJncmF2aXR5IiwibnVtSXRlciIsInRpbGUiLCJhbmltYXRlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0aWxpbmdQYWRkaW5nVmVydGljYWwiLCJ0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCIsImdyYXZpdHlSYW5nZUNvbXBvdW5kIiwiZ3Jhdml0eUNvbXBvdW5kIiwiZ3Jhdml0eVJhbmdlIiwiaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwiLCJleHRlbmQiLCJvcHRpb25zIiwib2JqIiwiX0NvU0VMYXlvdXQiLCJfb3B0aW9ucyIsImdldFVzZXJPcHRpb25zIiwiREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEgiLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiREVGQVVMVF9TUFJJTkdfU1RSRU5HVEgiLCJQRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SIiwiREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIIiwiTUFYX0lURVJBVElPTlMiLCJERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsIkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwiLCJRVUFMSVRZIiwiTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTIiwiREVGQVVMVF9JTkNSRU1FTlRBTCIsIkFOSU1BVEUiLCJUSUxFIiwiVElMSU5HX1BBRERJTkdfVkVSVElDQUwiLCJUSUxJTkdfUEFERElOR19IT1JJWk9OVEFMIiwicnVuIiwiZnJhbWVJZCIsImlkVG9MTm9kZSIsImxheW91dCIsInNlbGYiLCJzdG9wcGVkIiwiY3kiLCJ0cmlnZ2VyIiwidHlwZSIsImdtIiwibmV3R3JhcGhNYW5hZ2VyIiwibm9kZXMiLCJlbGVzIiwiZWRnZXMiLCJhZGRSb290IiwicHJvY2Vzc0NoaWxkcmVuTGlzdCIsImdldFRvcE1vc3ROb2RlcyIsImxlbmd0aCIsImVkZ2UiLCJzb3VyY2VOb2RlIiwiZGF0YSIsInRhcmdldE5vZGUiLCJnZXRFZGdlc0JldHdlZW4iLCJlMSIsImFkZCIsIm5ld0VkZ2UiLCJpZCIsImdldFBvc2l0aW9ucyIsImVsZSIsInRoZUlkIiwibE5vZGUiLCJ4IiwiZ2V0UmVjdCIsImdldENlbnRlclgiLCJ5IiwiZ2V0Q2VudGVyWSIsIml0ZXJhdGVBbmltYXRlZCIsImFmdGVyUmVwb3NpdGlvbiIsIm9uZSIsInRpY2tzUGVyRnJhbWUiLCJpc0RvbmUiLCJ0aWNrIiwiY2hlY2tMYXlvdXRTdWNjZXNzIiwiaXNTdWJMYXlvdXQiLCJkb1Bvc3RMYXlvdXQiLCJ0aWxpbmdQb3N0TGF5b3V0IiwiaXNMYXlvdXRGaW5pc2hlZCIsInBvc2l0aW9ucyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0aW9uRGF0YSIsImdldFBvc2l0aW9uc0RhdGEiLCJpc1BhcmVudCIsInBOb2RlIiwidGVtcCIsInBhcmVudCIsInVuZGVmaW5lZCIsInBvc2l0aW9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWRkTGlzdGVuZXIiLCJydW5MYXlvdXQiLCJub3QiLCJsYXlvdXRQb3NpdGlvbnMiLCJub2Rlc01hcCIsInJvb3RzIiwiZmlsdGVyIiwiY2hpbGRyZW4iLCJzaXplIiwidGhlQ2hpbGQiLCJjaGlsZHJlbl9vZl9jaGlsZHJlbiIsInRoZU5vZGUiLCJkaW1lbnNpb25zIiwibGF5b3V0RGltZW5zaW9ucyIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsImdyYXBoTWFuYWdlciIsInciLCJoIiwicGFyc2VGbG9hdCIsInBhZGRpbmdMZWZ0IiwicGFyc2VJbnQiLCJjc3MiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsImxhYmVsV2lkdGgiLCJib3VuZGluZ0JveCIsImluY2x1ZGVMYWJlbHMiLCJpbmNsdWRlTm9kZXMiLCJsYWJlbEhlaWdodCIsImxhYmVsUG9zIiwiaXNOYU4iLCJyZWN0IiwidGhlTmV3R3JhcGgiLCJnZXRHcmFwaE1hbmFnZXIiLCJuZXdHcmFwaCIsInJlZ2lzdGVyIiwiY3l0b3NjYXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\n");

/***/ })

};
;