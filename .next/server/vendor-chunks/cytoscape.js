"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape";
exports.ids = ["vendor-chunks/cytoscape"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape/dist/cytoscape.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cytoscape)\n/* harmony export */ });\n/**\n * Copyright (c) 2016-2025, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the “Software”), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n        writable: false\n    }), e;\n}\nfunction _createForOfIteratorHelper(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (!t) {\n        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n            t && (r = t);\n            var n = 0, F = function() {};\n            return {\n                s: F,\n                n: function() {\n                    return n >= r.length ? {\n                        done: true\n                    } : {\n                        done: false,\n                        value: r[n++]\n                    };\n                },\n                e: function(r) {\n                    throw r;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o, a = true, u = false;\n    return {\n        s: function() {\n            t = t.call(r);\n        },\n        n: function() {\n            var r = t.next();\n            return a = r.done, r;\n        },\n        e: function(r) {\n            u = true, o = r;\n        },\n        f: function() {\n            try {\n                a || null == t.return || t.return();\n            } finally{\n                if (u) throw o;\n            }\n        }\n    };\n}\nfunction _defineProperty$1(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = true, o = false;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = true, n = r;\n        } finally{\n            try {\n                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (undefined !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return String(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n    }\n}\nvar _window =  true ? null : 0; // eslint-disable-line no-undef\nvar navigator = _window ? _window.navigator : null;\n_window ? _window.document : null;\nvar typeofstr = _typeof(\"\");\nvar typeofobj = _typeof({});\nvar typeoffn = _typeof(function() {});\nvar typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\nvar instanceStr = function instanceStr(obj) {\n    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n};\nvar string = function string(obj) {\n    return obj != null && _typeof(obj) == typeofstr;\n};\nvar fn$6 = function fn(obj) {\n    return obj != null && _typeof(obj) === typeoffn;\n};\nvar array = function array(obj) {\n    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n};\nvar plainObject = function plainObject(obj) {\n    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n};\nvar object = function object(obj) {\n    return obj != null && _typeof(obj) === typeofobj;\n};\nvar number$1 = function number(obj) {\n    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n};\nvar integer = function integer(obj) {\n    return number$1(obj) && Math.floor(obj) === obj;\n};\nvar htmlElement = function htmlElement(obj) {\n    if (\"undefined\" === typeofhtmlele) {\n        return undefined;\n    } else {\n        return null != obj && obj instanceof HTMLElement;\n    }\n};\nvar elementOrCollection = function elementOrCollection(obj) {\n    return element(obj) || collection(obj);\n};\nvar element = function element(obj) {\n    return instanceStr(obj) === \"collection\" && obj._private.single;\n};\nvar collection = function collection(obj) {\n    return instanceStr(obj) === \"collection\" && !obj._private.single;\n};\nvar core = function core(obj) {\n    return instanceStr(obj) === \"core\";\n};\nvar stylesheet = function stylesheet(obj) {\n    return instanceStr(obj) === \"stylesheet\";\n};\nvar event = function event(obj) {\n    return instanceStr(obj) === \"event\";\n};\nvar emptyString = function emptyString(obj) {\n    if (obj === undefined || obj === null) {\n        // null is empty\n        return true;\n    } else if (obj === \"\" || obj.match(/^\\s+$/)) {\n        return true; // empty string is empty\n    }\n    return false; // otherwise, we don't know what we've got\n};\nvar domElement = function domElement(obj) {\n    if (typeof HTMLElement === \"undefined\") {\n        return false; // we're not in a browser so it doesn't matter\n    } else {\n        return obj instanceof HTMLElement;\n    }\n};\nvar boundingBox = function boundingBox(obj) {\n    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n};\nvar promise = function promise(obj) {\n    return object(obj) && fn$6(obj.then);\n};\nvar ms = function ms() {\n    return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n}; // probably a better way to detect this...\nvar memoize = function memoize(fn, keyFn) {\n    if (!keyFn) {\n        keyFn = function keyFn() {\n            if (arguments.length === 1) {\n                return arguments[0];\n            } else if (arguments.length === 0) {\n                return \"undefined\";\n            }\n            var args = [];\n            for(var i = 0; i < arguments.length; i++){\n                args.push(arguments[i]);\n            }\n            return args.join(\"$\");\n        };\n    }\n    var _memoizedFn = function memoizedFn() {\n        var self1 = this;\n        var args = arguments;\n        var ret;\n        var k = keyFn.apply(self1, args);\n        var cache = _memoizedFn.cache;\n        if (!(ret = cache[k])) {\n            ret = cache[k] = fn.apply(self1, args);\n        }\n        return ret;\n    };\n    _memoizedFn.cache = {};\n    return _memoizedFn;\n};\nvar camel2dash = memoize(function(str) {\n    return str.replace(/([A-Z])/g, function(v) {\n        return \"-\" + v.toLowerCase();\n    });\n});\nvar dash2camel = memoize(function(str) {\n    return str.replace(/(-\\w)/g, function(v) {\n        return v[1].toUpperCase();\n    });\n});\nvar prependCamel = memoize(function(prefix, str) {\n    return prefix + str[0].toUpperCase() + str.substring(1);\n}, function(prefix, str) {\n    return prefix + \"$\" + str;\n});\nvar capitalize = function capitalize(str) {\n    if (emptyString(str)) {\n        return str;\n    }\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar endsWith = function endsWith(string, suffix) {\n    return string.slice(-1 * suffix.length) === suffix;\n};\nvar number = \"(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))\";\nvar rgba = \"rgb[a]?\\\\((\" + number + \"[%]?)\\\\s*,\\\\s*(\" + number + \"[%]?)\\\\s*,\\\\s*(\" + number + \"[%]?)(?:\\\\s*,\\\\s*(\" + number + \"))?\\\\)\";\nvar rgbaNoBackRefs = \"rgb[a]?\\\\((?:\" + number + \"[%]?)\\\\s*,\\\\s*(?:\" + number + \"[%]?)\\\\s*,\\\\s*(?:\" + number + \"[%]?)(?:\\\\s*,\\\\s*(?:\" + number + \"))?\\\\)\";\nvar hsla = \"hsl[a]?\\\\((\" + number + \")\\\\s*,\\\\s*(\" + number + \"[%])\\\\s*,\\\\s*(\" + number + \"[%])(?:\\\\s*,\\\\s*(\" + number + \"))?\\\\)\";\nvar hslaNoBackRefs = \"hsl[a]?\\\\((?:\" + number + \")\\\\s*,\\\\s*(?:\" + number + \"[%])\\\\s*,\\\\s*(?:\" + number + \"[%])(?:\\\\s*,\\\\s*(?:\" + number + \"))?\\\\)\";\nvar hex3 = \"\\\\#[0-9a-fA-F]{3}\";\nvar hex6 = \"\\\\#[0-9a-fA-F]{6}\";\nvar ascending = function ascending(a, b) {\n    if (a < b) {\n        return -1;\n    } else if (a > b) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\nvar descending = function descending(a, b) {\n    return -1 * ascending(a, b);\n};\nvar extend = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n    var args = arguments;\n    for(var i = 1; i < args.length; i++){\n        var obj = args[i];\n        if (obj == null) {\n            continue;\n        }\n        var keys = Object.keys(obj);\n        for(var j = 0; j < keys.length; j++){\n            var k = keys[j];\n            tgt[k] = obj[k];\n        }\n    }\n    return tgt;\n};\n// get [r, g, b] from #abc or #aabbcc\nvar hex2tuple = function hex2tuple(hex) {\n    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== \"#\") {\n        return;\n    }\n    var shortHex = hex.length === 4;\n    var r, g, b;\n    var base = 16;\n    if (shortHex) {\n        r = parseInt(hex[1] + hex[1], base);\n        g = parseInt(hex[2] + hex[2], base);\n        b = parseInt(hex[3] + hex[3], base);\n    } else {\n        r = parseInt(hex[1] + hex[2], base);\n        g = parseInt(hex[3] + hex[4], base);\n        b = parseInt(hex[5] + hex[6], base);\n    }\n    return [\n        r,\n        g,\n        b\n    ];\n};\n// get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\nvar hsl2tuple = function hsl2tuple(hsl) {\n    var ret;\n    var h, s, l, a, r, g, b;\n    function hue2rgb(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n    }\n    var m1 = new RegExp(\"^\" + hsla + \"$\").exec(hsl);\n    if (m1) {\n        // get hue\n        h = parseInt(m1[1]);\n        if (h < 0) {\n            h = (360 - -1 * h % 360) % 360;\n        } else if (h > 360) {\n            h = h % 360;\n        }\n        h /= 360; // normalise on [0, 1]\n        s = parseFloat(m1[2]);\n        if (s < 0 || s > 100) {\n            return;\n        } // saturation is [0, 100]\n        s = s / 100; // normalise on [0, 1]\n        l = parseFloat(m1[3]);\n        if (l < 0 || l > 100) {\n            return;\n        } // lightness is [0, 100]\n        l = l / 100; // normalise on [0, 1]\n        a = m1[4];\n        if (a !== undefined) {\n            a = parseFloat(a);\n            if (a < 0 || a > 1) {\n                return;\n            } // alpha is [0, 1]\n        }\n        // now, convert to rgb\n        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n        if (s === 0) {\n            r = g = b = Math.round(l * 255); // achromatic\n        } else {\n            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            var p = 2 * l - q;\n            r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n            g = Math.round(255 * hue2rgb(p, q, h));\n            b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n        }\n        ret = [\n            r,\n            g,\n            b,\n            a\n        ];\n    }\n    return ret;\n};\n// get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\nvar rgb2tuple = function rgb2tuple(rgb) {\n    var ret;\n    var m1 = new RegExp(\"^\" + rgba + \"$\").exec(rgb);\n    if (m1) {\n        ret = [];\n        var isPct = [];\n        for(var i = 1; i <= 3; i++){\n            var channel = m1[i];\n            if (channel[channel.length - 1] === \"%\") {\n                isPct[i] = true;\n            }\n            channel = parseFloat(channel);\n            if (isPct[i]) {\n                channel = channel / 100 * 255; // normalise to [0, 255]\n            }\n            if (channel < 0 || channel > 255) {\n                return;\n            } // invalid channel value\n            ret.push(Math.floor(channel));\n        }\n        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n        var allArePct = isPct[1] && isPct[2] && isPct[3];\n        if (atLeastOneIsPct && !allArePct) {\n            return;\n        } // must all be percent values if one is\n        var alpha = m1[4];\n        if (alpha !== undefined) {\n            alpha = parseFloat(alpha);\n            if (alpha < 0 || alpha > 1) {\n                return;\n            } // invalid alpha value\n            ret.push(alpha);\n        }\n    }\n    return ret;\n};\nvar colorname2tuple = function colorname2tuple(color) {\n    return colors[color.toLowerCase()];\n};\nvar color2tuple = function color2tuple(color) {\n    return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n};\nvar colors = {\n    // special colour names\n    transparent: [\n        0,\n        0,\n        0,\n        0\n    ],\n    // NB alpha === 0\n    // regular colours\n    aliceblue: [\n        240,\n        248,\n        255\n    ],\n    antiquewhite: [\n        250,\n        235,\n        215\n    ],\n    aqua: [\n        0,\n        255,\n        255\n    ],\n    aquamarine: [\n        127,\n        255,\n        212\n    ],\n    azure: [\n        240,\n        255,\n        255\n    ],\n    beige: [\n        245,\n        245,\n        220\n    ],\n    bisque: [\n        255,\n        228,\n        196\n    ],\n    black: [\n        0,\n        0,\n        0\n    ],\n    blanchedalmond: [\n        255,\n        235,\n        205\n    ],\n    blue: [\n        0,\n        0,\n        255\n    ],\n    blueviolet: [\n        138,\n        43,\n        226\n    ],\n    brown: [\n        165,\n        42,\n        42\n    ],\n    burlywood: [\n        222,\n        184,\n        135\n    ],\n    cadetblue: [\n        95,\n        158,\n        160\n    ],\n    chartreuse: [\n        127,\n        255,\n        0\n    ],\n    chocolate: [\n        210,\n        105,\n        30\n    ],\n    coral: [\n        255,\n        127,\n        80\n    ],\n    cornflowerblue: [\n        100,\n        149,\n        237\n    ],\n    cornsilk: [\n        255,\n        248,\n        220\n    ],\n    crimson: [\n        220,\n        20,\n        60\n    ],\n    cyan: [\n        0,\n        255,\n        255\n    ],\n    darkblue: [\n        0,\n        0,\n        139\n    ],\n    darkcyan: [\n        0,\n        139,\n        139\n    ],\n    darkgoldenrod: [\n        184,\n        134,\n        11\n    ],\n    darkgray: [\n        169,\n        169,\n        169\n    ],\n    darkgreen: [\n        0,\n        100,\n        0\n    ],\n    darkgrey: [\n        169,\n        169,\n        169\n    ],\n    darkkhaki: [\n        189,\n        183,\n        107\n    ],\n    darkmagenta: [\n        139,\n        0,\n        139\n    ],\n    darkolivegreen: [\n        85,\n        107,\n        47\n    ],\n    darkorange: [\n        255,\n        140,\n        0\n    ],\n    darkorchid: [\n        153,\n        50,\n        204\n    ],\n    darkred: [\n        139,\n        0,\n        0\n    ],\n    darksalmon: [\n        233,\n        150,\n        122\n    ],\n    darkseagreen: [\n        143,\n        188,\n        143\n    ],\n    darkslateblue: [\n        72,\n        61,\n        139\n    ],\n    darkslategray: [\n        47,\n        79,\n        79\n    ],\n    darkslategrey: [\n        47,\n        79,\n        79\n    ],\n    darkturquoise: [\n        0,\n        206,\n        209\n    ],\n    darkviolet: [\n        148,\n        0,\n        211\n    ],\n    deeppink: [\n        255,\n        20,\n        147\n    ],\n    deepskyblue: [\n        0,\n        191,\n        255\n    ],\n    dimgray: [\n        105,\n        105,\n        105\n    ],\n    dimgrey: [\n        105,\n        105,\n        105\n    ],\n    dodgerblue: [\n        30,\n        144,\n        255\n    ],\n    firebrick: [\n        178,\n        34,\n        34\n    ],\n    floralwhite: [\n        255,\n        250,\n        240\n    ],\n    forestgreen: [\n        34,\n        139,\n        34\n    ],\n    fuchsia: [\n        255,\n        0,\n        255\n    ],\n    gainsboro: [\n        220,\n        220,\n        220\n    ],\n    ghostwhite: [\n        248,\n        248,\n        255\n    ],\n    gold: [\n        255,\n        215,\n        0\n    ],\n    goldenrod: [\n        218,\n        165,\n        32\n    ],\n    gray: [\n        128,\n        128,\n        128\n    ],\n    grey: [\n        128,\n        128,\n        128\n    ],\n    green: [\n        0,\n        128,\n        0\n    ],\n    greenyellow: [\n        173,\n        255,\n        47\n    ],\n    honeydew: [\n        240,\n        255,\n        240\n    ],\n    hotpink: [\n        255,\n        105,\n        180\n    ],\n    indianred: [\n        205,\n        92,\n        92\n    ],\n    indigo: [\n        75,\n        0,\n        130\n    ],\n    ivory: [\n        255,\n        255,\n        240\n    ],\n    khaki: [\n        240,\n        230,\n        140\n    ],\n    lavender: [\n        230,\n        230,\n        250\n    ],\n    lavenderblush: [\n        255,\n        240,\n        245\n    ],\n    lawngreen: [\n        124,\n        252,\n        0\n    ],\n    lemonchiffon: [\n        255,\n        250,\n        205\n    ],\n    lightblue: [\n        173,\n        216,\n        230\n    ],\n    lightcoral: [\n        240,\n        128,\n        128\n    ],\n    lightcyan: [\n        224,\n        255,\n        255\n    ],\n    lightgoldenrodyellow: [\n        250,\n        250,\n        210\n    ],\n    lightgray: [\n        211,\n        211,\n        211\n    ],\n    lightgreen: [\n        144,\n        238,\n        144\n    ],\n    lightgrey: [\n        211,\n        211,\n        211\n    ],\n    lightpink: [\n        255,\n        182,\n        193\n    ],\n    lightsalmon: [\n        255,\n        160,\n        122\n    ],\n    lightseagreen: [\n        32,\n        178,\n        170\n    ],\n    lightskyblue: [\n        135,\n        206,\n        250\n    ],\n    lightslategray: [\n        119,\n        136,\n        153\n    ],\n    lightslategrey: [\n        119,\n        136,\n        153\n    ],\n    lightsteelblue: [\n        176,\n        196,\n        222\n    ],\n    lightyellow: [\n        255,\n        255,\n        224\n    ],\n    lime: [\n        0,\n        255,\n        0\n    ],\n    limegreen: [\n        50,\n        205,\n        50\n    ],\n    linen: [\n        250,\n        240,\n        230\n    ],\n    magenta: [\n        255,\n        0,\n        255\n    ],\n    maroon: [\n        128,\n        0,\n        0\n    ],\n    mediumaquamarine: [\n        102,\n        205,\n        170\n    ],\n    mediumblue: [\n        0,\n        0,\n        205\n    ],\n    mediumorchid: [\n        186,\n        85,\n        211\n    ],\n    mediumpurple: [\n        147,\n        112,\n        219\n    ],\n    mediumseagreen: [\n        60,\n        179,\n        113\n    ],\n    mediumslateblue: [\n        123,\n        104,\n        238\n    ],\n    mediumspringgreen: [\n        0,\n        250,\n        154\n    ],\n    mediumturquoise: [\n        72,\n        209,\n        204\n    ],\n    mediumvioletred: [\n        199,\n        21,\n        133\n    ],\n    midnightblue: [\n        25,\n        25,\n        112\n    ],\n    mintcream: [\n        245,\n        255,\n        250\n    ],\n    mistyrose: [\n        255,\n        228,\n        225\n    ],\n    moccasin: [\n        255,\n        228,\n        181\n    ],\n    navajowhite: [\n        255,\n        222,\n        173\n    ],\n    navy: [\n        0,\n        0,\n        128\n    ],\n    oldlace: [\n        253,\n        245,\n        230\n    ],\n    olive: [\n        128,\n        128,\n        0\n    ],\n    olivedrab: [\n        107,\n        142,\n        35\n    ],\n    orange: [\n        255,\n        165,\n        0\n    ],\n    orangered: [\n        255,\n        69,\n        0\n    ],\n    orchid: [\n        218,\n        112,\n        214\n    ],\n    palegoldenrod: [\n        238,\n        232,\n        170\n    ],\n    palegreen: [\n        152,\n        251,\n        152\n    ],\n    paleturquoise: [\n        175,\n        238,\n        238\n    ],\n    palevioletred: [\n        219,\n        112,\n        147\n    ],\n    papayawhip: [\n        255,\n        239,\n        213\n    ],\n    peachpuff: [\n        255,\n        218,\n        185\n    ],\n    peru: [\n        205,\n        133,\n        63\n    ],\n    pink: [\n        255,\n        192,\n        203\n    ],\n    plum: [\n        221,\n        160,\n        221\n    ],\n    powderblue: [\n        176,\n        224,\n        230\n    ],\n    purple: [\n        128,\n        0,\n        128\n    ],\n    red: [\n        255,\n        0,\n        0\n    ],\n    rosybrown: [\n        188,\n        143,\n        143\n    ],\n    royalblue: [\n        65,\n        105,\n        225\n    ],\n    saddlebrown: [\n        139,\n        69,\n        19\n    ],\n    salmon: [\n        250,\n        128,\n        114\n    ],\n    sandybrown: [\n        244,\n        164,\n        96\n    ],\n    seagreen: [\n        46,\n        139,\n        87\n    ],\n    seashell: [\n        255,\n        245,\n        238\n    ],\n    sienna: [\n        160,\n        82,\n        45\n    ],\n    silver: [\n        192,\n        192,\n        192\n    ],\n    skyblue: [\n        135,\n        206,\n        235\n    ],\n    slateblue: [\n        106,\n        90,\n        205\n    ],\n    slategray: [\n        112,\n        128,\n        144\n    ],\n    slategrey: [\n        112,\n        128,\n        144\n    ],\n    snow: [\n        255,\n        250,\n        250\n    ],\n    springgreen: [\n        0,\n        255,\n        127\n    ],\n    steelblue: [\n        70,\n        130,\n        180\n    ],\n    tan: [\n        210,\n        180,\n        140\n    ],\n    teal: [\n        0,\n        128,\n        128\n    ],\n    thistle: [\n        216,\n        191,\n        216\n    ],\n    tomato: [\n        255,\n        99,\n        71\n    ],\n    turquoise: [\n        64,\n        224,\n        208\n    ],\n    violet: [\n        238,\n        130,\n        238\n    ],\n    wheat: [\n        245,\n        222,\n        179\n    ],\n    white: [\n        255,\n        255,\n        255\n    ],\n    whitesmoke: [\n        245,\n        245,\n        245\n    ],\n    yellow: [\n        255,\n        255,\n        0\n    ],\n    yellowgreen: [\n        154,\n        205,\n        50\n    ]\n};\n// sets the value in a map (map may not be built)\nvar setMap = function setMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    for(var i = 0; i < l; i++){\n        var key = keys[i];\n        if (plainObject(key)) {\n            throw Error(\"Tried to set map with object key\");\n        }\n        if (i < keys.length - 1) {\n            // extend the map if necessary\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        } else {\n            // set the value\n            obj[key] = options.value;\n        }\n    }\n};\n// gets the value in a map even if it's not built in places\nvar getMap = function getMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    for(var i = 0; i < l; i++){\n        var key = keys[i];\n        if (plainObject(key)) {\n            throw Error(\"Tried to get map with object key\");\n        }\n        obj = obj[key];\n        if (obj == null) {\n            return obj;\n        }\n    }\n    return obj;\n};\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ var isObject_1;\nvar hasRequiredIsObject;\nfunction requireIsObject() {\n    if (hasRequiredIsObject) return isObject_1;\n    hasRequiredIsObject = 1;\n    function isObject(value) {\n        var type = typeof value;\n        return value != null && (type == \"object\" || type == \"function\");\n    }\n    isObject_1 = isObject;\n    return isObject_1;\n}\n/** Detect free variable `global` from Node.js. */ var _freeGlobal;\nvar hasRequired_freeGlobal;\nfunction require_freeGlobal() {\n    if (hasRequired_freeGlobal) return _freeGlobal;\n    hasRequired_freeGlobal = 1;\n    var freeGlobal = typeof commonjsGlobal == \"object\" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n    _freeGlobal = freeGlobal;\n    return _freeGlobal;\n}\nvar _root;\nvar hasRequired_root;\nfunction require_root() {\n    if (hasRequired_root) return _root;\n    hasRequired_root = 1;\n    var freeGlobal = require_freeGlobal();\n    /** Detect free variable `self`. */ var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function(\"return this\")();\n    _root = root;\n    return _root;\n}\nvar now_1;\nvar hasRequiredNow;\nfunction requireNow() {\n    if (hasRequiredNow) return now_1;\n    hasRequiredNow = 1;\n    var root = require_root();\n    /**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => Logs the number of milliseconds it took for the deferred invocation.\n\t */ var now = function() {\n        return root.Date.now();\n    };\n    now_1 = now;\n    return now_1;\n}\n/** Used to match a single whitespace character. */ var _trimmedEndIndex;\nvar hasRequired_trimmedEndIndex;\nfunction require_trimmedEndIndex() {\n    if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;\n    hasRequired_trimmedEndIndex = 1;\n    var reWhitespace = /\\s/;\n    /**\n\t * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n\t * character of `string`.\n\t *\n\t * @private\n\t * @param {string} string The string to inspect.\n\t * @returns {number} Returns the index of the last non-whitespace character.\n\t */ function trimmedEndIndex(string) {\n        var index = string.length;\n        while(index-- && reWhitespace.test(string.charAt(index))){}\n        return index;\n    }\n    _trimmedEndIndex = trimmedEndIndex;\n    return _trimmedEndIndex;\n}\nvar _baseTrim;\nvar hasRequired_baseTrim;\nfunction require_baseTrim() {\n    if (hasRequired_baseTrim) return _baseTrim;\n    hasRequired_baseTrim = 1;\n    var trimmedEndIndex = require_trimmedEndIndex();\n    /** Used to match leading whitespace. */ var reTrimStart = /^\\s+/;\n    /**\n\t * The base implementation of `_.trim`.\n\t *\n\t * @private\n\t * @param {string} string The string to trim.\n\t * @returns {string} Returns the trimmed string.\n\t */ function baseTrim(string) {\n        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n    }\n    _baseTrim = baseTrim;\n    return _baseTrim;\n}\nvar _Symbol;\nvar hasRequired_Symbol;\nfunction require_Symbol() {\n    if (hasRequired_Symbol) return _Symbol;\n    hasRequired_Symbol = 1;\n    var root = require_root();\n    /** Built-in value references. */ var Symbol1 = root.Symbol;\n    _Symbol = Symbol1;\n    return _Symbol;\n}\nvar _getRawTag;\nvar hasRequired_getRawTag;\nfunction require_getRawTag() {\n    if (hasRequired_getRawTag) return _getRawTag;\n    hasRequired_getRawTag = 1;\n    var Symbol1 = require_Symbol();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */ var nativeObjectToString = objectProto.toString;\n    /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n    /**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */ function getRawTag(value) {\n        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n        try {\n            value[symToStringTag] = undefined;\n            var unmasked = true;\n        } catch (e) {}\n        var result = nativeObjectToString.call(value);\n        if (unmasked) {\n            if (isOwn) {\n                value[symToStringTag] = tag;\n            } else {\n                delete value[symToStringTag];\n            }\n        }\n        return result;\n    }\n    _getRawTag = getRawTag;\n    return _getRawTag;\n}\n/** Used for built-in method references. */ var _objectToString;\nvar hasRequired_objectToString;\nfunction require_objectToString() {\n    if (hasRequired_objectToString) return _objectToString;\n    hasRequired_objectToString = 1;\n    var objectProto = Object.prototype;\n    /**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */ var nativeObjectToString = objectProto.toString;\n    /**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */ function objectToString(value) {\n        return nativeObjectToString.call(value);\n    }\n    _objectToString = objectToString;\n    return _objectToString;\n}\nvar _baseGetTag;\nvar hasRequired_baseGetTag;\nfunction require_baseGetTag() {\n    if (hasRequired_baseGetTag) return _baseGetTag;\n    hasRequired_baseGetTag = 1;\n    var Symbol1 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();\n    /** `Object#toString` result references. */ var nullTag = \"[object Null]\", undefinedTag = \"[object Undefined]\";\n    /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n    /**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */ function baseGetTag(value) {\n        if (value == null) {\n            return value === undefined ? undefinedTag : nullTag;\n        }\n        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    _baseGetTag = baseGetTag;\n    return _baseGetTag;\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ var isObjectLike_1;\nvar hasRequiredIsObjectLike;\nfunction requireIsObjectLike() {\n    if (hasRequiredIsObjectLike) return isObjectLike_1;\n    hasRequiredIsObjectLike = 1;\n    function isObjectLike(value) {\n        return value != null && typeof value == \"object\";\n    }\n    isObjectLike_1 = isObjectLike;\n    return isObjectLike_1;\n}\nvar isSymbol_1;\nvar hasRequiredIsSymbol;\nfunction requireIsSymbol() {\n    if (hasRequiredIsSymbol) return isSymbol_1;\n    hasRequiredIsSymbol = 1;\n    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();\n    /** `Object#toString` result references. */ var symbolTag = \"[object Symbol]\";\n    /**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */ function isSymbol(value) {\n        return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n    }\n    isSymbol_1 = isSymbol;\n    return isSymbol_1;\n}\nvar toNumber_1;\nvar hasRequiredToNumber;\nfunction requireToNumber() {\n    if (hasRequiredToNumber) return toNumber_1;\n    hasRequiredToNumber = 1;\n    var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();\n    /** Used as references for various `Number` constants. */ var NAN = 0 / 0;\n    /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;\n    /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;\n    /** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;\n    /**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */ function toNumber(value) {\n        if (typeof value == \"number\") {\n            return value;\n        }\n        if (isSymbol(value)) {\n            return NAN;\n        }\n        if (isObject(value)) {\n            var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n            value = isObject(other) ? other + \"\" : other;\n        }\n        if (typeof value != \"string\") {\n            return value === 0 ? value : +value;\n        }\n        value = baseTrim(value);\n        var isBinary = reIsBinary.test(value);\n        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    toNumber_1 = toNumber;\n    return toNumber_1;\n}\nvar debounce_1;\nvar hasRequiredDebounce;\nfunction requireDebounce() {\n    if (hasRequiredDebounce) return debounce_1;\n    hasRequiredDebounce = 1;\n    var isObject = requireIsObject(), now = requireNow(), toNumber = requireToNumber();\n    /** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;\n    /**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide `options` to indicate whether `func` should be invoked on the\n\t * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent\n\t * calls to the debounced function return the result of the last `func`\n\t * invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the debounced function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=false]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {number} [options.maxWait]\n\t *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */ function debounce(func, wait, options) {\n        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n        if (typeof func != \"function\") {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        wait = toNumber(wait) || 0;\n        if (isObject(options)) {\n            leading = !!options.leading;\n            maxing = \"maxWait\" in options;\n            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n            trailing = \"trailing\" in options ? !!options.trailing : trailing;\n        }\n        function invokeFunc(time) {\n            var args = lastArgs, thisArg = lastThis;\n            lastArgs = lastThis = undefined;\n            lastInvokeTime = time;\n            result = func.apply(thisArg, args);\n            return result;\n        }\n        function leadingEdge(time) {\n            // Reset any `maxWait` timer.\n            lastInvokeTime = time;\n            // Start the timer for the trailing edge.\n            timerId = setTimeout(timerExpired, wait);\n            // Invoke the leading edge.\n            return leading ? invokeFunc(time) : result;\n        }\n        function remainingWait(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n        }\n        function shouldInvoke(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n            // Either this is the first call, activity has stopped and we're at the\n            // trailing edge, the system time has gone backwards and we're treating\n            // it as the trailing edge, or we've hit the `maxWait` limit.\n            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n        }\n        function timerExpired() {\n            var time = now();\n            if (shouldInvoke(time)) {\n                return trailingEdge(time);\n            }\n            // Restart the timer.\n            timerId = setTimeout(timerExpired, remainingWait(time));\n        }\n        function trailingEdge(time) {\n            timerId = undefined;\n            // Only invoke if we have `lastArgs` which means `func` has been\n            // debounced at least once.\n            if (trailing && lastArgs) {\n                return invokeFunc(time);\n            }\n            lastArgs = lastThis = undefined;\n            return result;\n        }\n        function cancel() {\n            if (timerId !== undefined) {\n                clearTimeout(timerId);\n            }\n            lastInvokeTime = 0;\n            lastArgs = lastCallTime = lastThis = timerId = undefined;\n        }\n        function flush() {\n            return timerId === undefined ? result : trailingEdge(now());\n        }\n        function debounced() {\n            var time = now(), isInvoking = shouldInvoke(time);\n            lastArgs = arguments;\n            lastThis = this;\n            lastCallTime = time;\n            if (isInvoking) {\n                if (timerId === undefined) {\n                    return leadingEdge(lastCallTime);\n                }\n                if (maxing) {\n                    // Handle invocations in a tight loop.\n                    clearTimeout(timerId);\n                    timerId = setTimeout(timerExpired, wait);\n                    return invokeFunc(lastCallTime);\n                }\n            }\n            if (timerId === undefined) {\n                timerId = setTimeout(timerExpired, wait);\n            }\n            return result;\n        }\n        debounced.cancel = cancel;\n        debounced.flush = flush;\n        return debounced;\n    }\n    debounce_1 = debounce;\n    return debounce_1;\n}\nvar debounceExports = requireDebounce();\nvar debounce = /*@__PURE__*/ getDefaultExportFromCjs(debounceExports);\nvar performance$1 = _window ? _window.performance : null;\nvar pnow = performance$1 && performance$1.now ? function() {\n    return performance$1.now();\n} : function() {\n    return Date.now();\n};\nvar raf = function() {\n    if (_window) {\n        if (_window.requestAnimationFrame) {\n            return function(fn) {\n                _window.requestAnimationFrame(fn);\n            };\n        } else if (_window.mozRequestAnimationFrame) {\n            return function(fn) {\n                _window.mozRequestAnimationFrame(fn);\n            };\n        } else if (_window.webkitRequestAnimationFrame) {\n            return function(fn) {\n                _window.webkitRequestAnimationFrame(fn);\n            };\n        } else if (_window.msRequestAnimationFrame) {\n            return function(fn) {\n                _window.msRequestAnimationFrame(fn);\n            };\n        }\n    }\n    return function(fn) {\n        if (fn) {\n            setTimeout(function() {\n                fn(pnow());\n            }, 1000 / 60);\n        }\n    };\n}();\nvar requestAnimationFrame = function requestAnimationFrame(fn) {\n    return raf(fn);\n};\nvar performanceNow = pnow;\nvar DEFAULT_HASH_SEED = 9261;\nvar K = 65599; // 37 also works pretty well\nvar DEFAULT_HASH_SEED_ALT = 5381;\nvar hashIterableInts = function hashIterableInts(iterator) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    var hash = seed;\n    var entry;\n    for(;;){\n        entry = iterator.next();\n        if (entry.done) {\n            break;\n        }\n        hash = hash * K + entry.value | 0;\n    }\n    return hash;\n};\nvar hashInt = function hashInt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    return seed * K + num | 0;\n};\nvar hashIntAlt = function hashIntAlt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n    // djb2/string-hash\n    return (seed << 5) + seed + num | 0;\n};\nvar combineHashes = function combineHashes(hash1, hash2) {\n    return hash1 * 0x200000 + hash2;\n};\nvar combineHashesArray = function combineHashesArray(hashes) {\n    return hashes[0] * 0x200000 + hashes[1];\n};\nvar hashArrays = function hashArrays(hashes1, hashes2) {\n    return [\n        hashInt(hashes1[0], hashes2[0]),\n        hashIntAlt(hashes1[1], hashes2[1])\n    ];\n};\nvar hashIntsArray = function hashIntsArray(ints, seed) {\n    var entry = {\n        value: 0,\n        done: false\n    };\n    var i = 0;\n    var length = ints.length;\n    var iterator = {\n        next: function next() {\n            if (i < length) {\n                entry.value = ints[i++];\n            } else {\n                entry.done = true;\n            }\n            return entry;\n        }\n    };\n    return hashIterableInts(iterator, seed);\n};\nvar hashString = function hashString(str, seed) {\n    var entry = {\n        value: 0,\n        done: false\n    };\n    var i = 0;\n    var length = str.length;\n    var iterator = {\n        next: function next() {\n            if (i < length) {\n                entry.value = str.charCodeAt(i++);\n            } else {\n                entry.done = true;\n            }\n            return entry;\n        }\n    };\n    return hashIterableInts(iterator, seed);\n};\nvar hashStrings = function hashStrings() {\n    return hashStringsArray(arguments);\n};\nvar hashStringsArray = function hashStringsArray(strs) {\n    var hash;\n    for(var i = 0; i < strs.length; i++){\n        var str = strs[i];\n        if (i === 0) {\n            hash = hashString(str);\n        } else {\n            hash = hashString(str, hash);\n        }\n    }\n    return hash;\n};\nfunction rotatePoint(x, y, centerX, centerY, angleDegrees) {\n    var angleRadians = angleDegrees * Math.PI / 180;\n    var rotatedX = Math.cos(angleRadians) * (x - centerX) - Math.sin(angleRadians) * (y - centerY) + centerX;\n    var rotatedY = Math.sin(angleRadians) * (x - centerX) + Math.cos(angleRadians) * (y - centerY) + centerY;\n    return {\n        x: rotatedX,\n        y: rotatedY\n    };\n}\nvar movePointByBoxAspect = function movePointByBoxAspect(x, y, boxX, boxY, skewX, skewY) {\n    return {\n        x: (x - boxX) * skewX + boxX,\n        y: (y - boxY) * skewY + boxY\n    };\n};\nfunction rotatePosAndSkewByBox(pos, box, angleDegrees) {\n    if (angleDegrees === 0) return pos;\n    var centerX = (box.x1 + box.x2) / 2;\n    var centerY = (box.y1 + box.y2) / 2;\n    var skewX = box.w / box.h;\n    var skewY = 1 / skewX;\n    var rotated = rotatePoint(pos.x, pos.y, centerX, centerY, angleDegrees);\n    var skewed = movePointByBoxAspect(rotated.x, rotated.y, centerX, centerY, skewX, skewY);\n    return {\n        x: skewed.x,\n        y: skewed.y\n    };\n}\nvar warningsEnabled = true;\nvar warnSupported = console.warn != null;\nvar traceSupported = console.trace != null;\nvar MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar trueify = function trueify() {\n    return true;\n};\nvar falsify = function falsify() {\n    return false;\n};\nvar zeroify = function zeroify() {\n    return 0;\n};\nvar noop$1 = function noop() {};\nvar error = function error(msg) {\n    throw new Error(msg);\n};\nvar warnings = function warnings(enabled) {\n    if (enabled !== undefined) {\n        warningsEnabled = !!enabled;\n    } else {\n        return warningsEnabled;\n    }\n};\nvar warn = function warn(msg) {\n    if (!warnings()) {\n        return;\n    }\n    if (warnSupported) {\n        console.warn(msg);\n    } else {\n        console.log(msg);\n        if (traceSupported) {\n            console.trace();\n        }\n    }\n};\nvar clone = function clone(obj) {\n    return extend({}, obj);\n};\n// gets a shallow copy of the argument\nvar copy = function copy(obj) {\n    if (obj == null) {\n        return obj;\n    }\n    if (array(obj)) {\n        return obj.slice();\n    } else if (plainObject(obj)) {\n        return clone(obj);\n    } else {\n        return obj;\n    }\n};\nvar copyArray = function copyArray(arr) {\n    return arr.slice();\n};\nvar uuid = function uuid(a, b /* placeholders */ ) {\n    for(// loop :)\n    b = a = \"\"; // b - result , a - numeric letiable\n    a++ < 36; //\n    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n     ? //  return a random number or 4\n    (a ^ 15 // if \"a\" is not 15\n     ? // generate a random number from 0 to 15\n    8 ^ Math.random() * (a ^ 20 ? 16 : 4 // unless \"a\" is 20, in which case a random number from 8 to 11\n    ) : 4 //  otherwise 4\n    ).toString(16) : \"-\" //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n    );\n    return b;\n};\nvar _staticEmptyObject = {};\nvar staticEmptyObject = function staticEmptyObject() {\n    return _staticEmptyObject;\n};\nvar defaults$g = function defaults(_defaults) {\n    var keys = Object.keys(_defaults);\n    return function(opts) {\n        var filledOpts = {};\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            var optVal = opts == null ? undefined : opts[key];\n            filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n        }\n        return filledOpts;\n    };\n};\nvar removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n    for(var i = arr.length - 1; i >= 0; i--){\n        if (arr[i] === ele) {\n            arr.splice(i, 1);\n        }\n    }\n};\nvar clearArray = function clearArray(arr) {\n    arr.splice(0, arr.length);\n};\nvar push = function push(arr, otherArr) {\n    for(var i = 0; i < otherArr.length; i++){\n        var el = otherArr[i];\n        arr.push(el);\n    }\n};\nvar getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n    if (prefix) {\n        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n    return obj[propName];\n};\nvar setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n    if (prefix) {\n        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n    obj[propName] = value;\n};\n/* global Map */ var ObjectMap = /*#__PURE__*/ function() {\n    function ObjectMap() {\n        _classCallCheck(this, ObjectMap);\n        this._obj = {};\n    }\n    return _createClass(ObjectMap, [\n        {\n            key: \"set\",\n            value: function set(key, val) {\n                this._obj[key] = val;\n                return this;\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(key) {\n                this._obj[key] = undefined;\n                return this;\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this._obj = {};\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(key) {\n                return this._obj[key] !== undefined;\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(key) {\n                return this._obj[key];\n            }\n        }\n    ]);\n}();\nvar Map$1 = typeof Map !== \"undefined\" ? Map : ObjectMap;\n/* global Set */ var undef = \"undefined\";\nvar ObjectSet = /*#__PURE__*/ function() {\n    function ObjectSet(arrayOrObjectSet) {\n        _classCallCheck(this, ObjectSet);\n        this._obj = Object.create(null);\n        this.size = 0;\n        if (arrayOrObjectSet != null) {\n            var arr;\n            if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n                arr = arrayOrObjectSet.toArray();\n            } else {\n                arr = arrayOrObjectSet;\n            }\n            for(var i = 0; i < arr.length; i++){\n                this.add(arr[i]);\n            }\n        }\n    }\n    return _createClass(ObjectSet, [\n        {\n            key: \"instanceString\",\n            value: function instanceString() {\n                return \"set\";\n            }\n        },\n        {\n            key: \"add\",\n            value: function add(val) {\n                var o = this._obj;\n                if (o[val] !== 1) {\n                    o[val] = 1;\n                    this.size++;\n                }\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(val) {\n                var o = this._obj;\n                if (o[val] === 1) {\n                    o[val] = 0;\n                    this.size--;\n                }\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this._obj = Object.create(null);\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(val) {\n                return this._obj[val] === 1;\n            }\n        },\n        {\n            key: \"toArray\",\n            value: function toArray() {\n                var _this = this;\n                return Object.keys(this._obj).filter(function(key) {\n                    return _this.has(key);\n                });\n            }\n        },\n        {\n            key: \"forEach\",\n            value: function forEach(callback, thisArg) {\n                return this.toArray().forEach(callback, thisArg);\n            }\n        }\n    ]);\n}();\nvar Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n// represents a node or an edge\nvar Element = function Element(cy, params) {\n    var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (cy === undefined || params === undefined || !core(cy)) {\n        error(\"An element must have a core reference and parameters set\");\n        return;\n    }\n    var group = params.group;\n    // try to automatically infer the group if unspecified\n    if (group == null) {\n        if (params.data && params.data.source != null && params.data.target != null) {\n            group = \"edges\";\n        } else {\n            group = \"nodes\";\n        }\n    }\n    // validate group\n    if (group !== \"nodes\" && group !== \"edges\") {\n        error(\"An element must be of type `nodes` or `edges`; you specified `\" + group + \"`\");\n        return;\n    }\n    // make the element array-like, just like a collection\n    this.length = 1;\n    this[0] = this;\n    // NOTE: when something is added here, add also to ele.json()\n    var _p = this._private = {\n        cy: cy,\n        single: true,\n        // indicates this is an element\n        data: params.data || {},\n        // data object\n        position: params.position || {\n            x: 0,\n            y: 0\n        },\n        // (x, y) position pair\n        autoWidth: undefined,\n        // width and height of nodes calculated by the renderer when set to special 'auto' value\n        autoHeight: undefined,\n        autoPadding: undefined,\n        compoundBoundsClean: false,\n        // whether the compound dimensions need to be recalculated the next time dimensions are read\n        listeners: [],\n        // array of bound listeners\n        group: group,\n        // string; 'nodes' or 'edges'\n        style: {},\n        // properties as set by the style\n        rstyle: {},\n        // properties for style sent from the renderer to the core\n        styleCxts: [],\n        // applied style contexts from the styler\n        styleKeys: {},\n        // per-group keys of style property values\n        removed: true,\n        // whether it's inside the vis; true if removed (set true here since we call restore)\n        selected: params.selected ? true : false,\n        // whether it's selected\n        selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n        // whether it's selectable\n        locked: params.locked ? true : false,\n        // whether the element is locked (cannot be moved)\n        grabbed: false,\n        // whether the element is grabbed by the mouse; renderer sets this privately\n        grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n        // whether the element can be grabbed\n        pannable: params.pannable === undefined ? group === \"edges\" ? true : false : params.pannable ? true : false,\n        // whether the element has passthrough panning enabled\n        active: false,\n        // whether the element is active from user interaction\n        classes: new Set$1(),\n        // map ( className => true )\n        animation: {\n            // object for currently-running animations\n            current: [],\n            queue: []\n        },\n        rscratch: {},\n        // object in which the renderer can store information\n        scratch: params.scratch || {},\n        // scratch objects\n        edges: [],\n        // array of connected edges\n        children: [],\n        // array of children\n        parent: params.parent && params.parent.isNode() ? params.parent : null,\n        // parent ref\n        traversalCache: {},\n        // cache of output of traversal functions\n        backgrounding: false,\n        // whether background images are loading\n        bbCache: null,\n        // cache of the current bounding box\n        bbCacheShift: {\n            x: 0,\n            y: 0\n        },\n        // shift applied to cached bb to be applied on next get\n        bodyBounds: null,\n        // bounds cache of element body, w/o overlay\n        overlayBounds: null,\n        // bounds cache of element body, including overlay\n        labelBounds: {\n            // bounds cache of labels\n            all: null,\n            source: null,\n            target: null,\n            main: null\n        },\n        arrowBounds: {\n            // bounds cache of edge arrows\n            source: null,\n            target: null,\n            \"mid-source\": null,\n            \"mid-target\": null\n        }\n    };\n    if (_p.position.x == null) {\n        _p.position.x = 0;\n    }\n    if (_p.position.y == null) {\n        _p.position.y = 0;\n    }\n    // renderedPosition overrides if specified\n    if (params.renderedPosition) {\n        var rpos = params.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        _p.position = {\n            x: (rpos.x - pan.x) / zoom,\n            y: (rpos.y - pan.y) / zoom\n        };\n    }\n    var classes = [];\n    if (array(params.classes)) {\n        classes = params.classes;\n    } else if (string(params.classes)) {\n        classes = params.classes.split(/\\s+/);\n    }\n    for(var i = 0, l = classes.length; i < l; i++){\n        var cls = classes[i];\n        if (!cls || cls === \"\") {\n            continue;\n        }\n        _p.classes.add(cls);\n    }\n    this.createEmitter();\n    if (restore === undefined || restore) {\n        this.restore();\n    }\n    var bypass = params.style || params.css;\n    if (bypass) {\n        warn(\"Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.\");\n        this.style(bypass);\n    }\n};\nvar defineSearch = function defineSearch(params) {\n    params = {\n        bfs: params.bfs || !params.dfs,\n        dfs: params.dfs || !params.bfs\n    };\n    // from pseudocode on wikipedia\n    return function searchFn(roots, fn, directed) {\n        var options;\n        if (plainObject(roots) && !elementOrCollection(roots)) {\n            options = roots;\n            roots = options.roots || options.root;\n            fn = options.visit;\n            directed = options.directed;\n        }\n        directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n        fn = fn$6(fn) ? fn : function() {};\n        var cy = this._private.cy;\n        var v = roots = string(roots) ? this.filter(roots) : roots;\n        var Q = [];\n        var connectedNodes = [];\n        var connectedBy = {};\n        var id2depth = {};\n        var V = {};\n        var j = 0;\n        var found;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        // enqueue v\n        for(var i = 0; i < v.length; i++){\n            var vi = v[i];\n            var viId = vi.id();\n            if (vi.isNode()) {\n                Q.unshift(vi);\n                if (params.bfs) {\n                    V[viId] = true;\n                    connectedNodes.push(vi);\n                }\n                id2depth[viId] = 0;\n            }\n        }\n        var _loop = function _loop() {\n            var v = params.bfs ? Q.shift() : Q.pop();\n            var vId = v.id();\n            if (params.dfs) {\n                if (V[vId]) {\n                    return 0; // continue\n                }\n                V[vId] = true;\n                connectedNodes.push(v);\n            }\n            var depth = id2depth[vId];\n            var prevEdge = connectedBy[vId];\n            var src = prevEdge != null ? prevEdge.source() : null;\n            var tgt = prevEdge != null ? prevEdge.target() : null;\n            var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n            var ret;\n            ret = fn(v, prevEdge, prevNode, j++, depth);\n            if (ret === true) {\n                found = v;\n                return 1; // break\n            }\n            if (ret === false) {\n                return 1; // break\n            }\n            var vwEdges = v.connectedEdges().filter(function(e) {\n                return (!directed || e.source().same(v)) && edges.has(e);\n            });\n            for(var _i2 = 0; _i2 < vwEdges.length; _i2++){\n                var e = vwEdges[_i2];\n                var w = e.connectedNodes().filter(function(n) {\n                    return !n.same(v) && nodes.has(n);\n                });\n                var wId = w.id();\n                if (w.length !== 0 && !V[wId]) {\n                    w = w[0];\n                    Q.push(w);\n                    if (params.bfs) {\n                        V[wId] = true;\n                        connectedNodes.push(w);\n                    }\n                    connectedBy[wId] = e;\n                    id2depth[wId] = id2depth[vId] + 1;\n                }\n            }\n        }, _ret;\n        while(Q.length !== 0){\n            _ret = _loop();\n            if (_ret === 0) continue;\n            if (_ret === 1) break;\n        }\n        var connectedEles = cy.collection();\n        for(var _i = 0; _i < connectedNodes.length; _i++){\n            var node = connectedNodes[_i];\n            var edge = connectedBy[node.id()];\n            if (edge != null) {\n                connectedEles.push(edge);\n            }\n            connectedEles.push(node);\n        }\n        return {\n            path: cy.collection(connectedEles),\n            found: cy.collection(found)\n        };\n    };\n};\n// search, spanning trees, etc\nvar elesfn$v = {\n    breadthFirstSearch: defineSearch({\n        bfs: true\n    }),\n    depthFirstSearch: defineSearch({\n        dfs: true\n    })\n};\n// nice, short mathematical alias\nelesfn$v.bfs = elesfn$v.breadthFirstSearch;\nelesfn$v.dfs = elesfn$v.depthFirstSearch;\nvar heap$2 = {\n    exports: {}\n};\nvar heap$1 = heap$2.exports;\nvar hasRequiredHeap$1;\nfunction requireHeap$1() {\n    if (hasRequiredHeap$1) return heap$2.exports;\n    hasRequiredHeap$1 = 1;\n    (function(module, exports) {\n        // Generated by CoffeeScript 1.8.0\n        (function() {\n            var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n            floor = Math.floor, min = Math.min;\n            /*\n\t\t  Default comparison function to be used\n\t\t   */ defaultCmp = function(x, y) {\n                if (x < y) {\n                    return -1;\n                }\n                if (x > y) {\n                    return 1;\n                }\n                return 0;\n            };\n            /*\n\t\t  Insert item x in list a, and keep it sorted assuming a is sorted.\n\t\t  \n\t\t  If x is already in a, insert it to the right of the rightmost x.\n\t\t  \n\t\t  Optional args lo (default 0) and hi (default a.length) bound the slice\n\t\t  of a to be searched.\n\t\t   */ insort = function(a, x, lo, hi, cmp) {\n                var mid;\n                if (lo == null) {\n                    lo = 0;\n                }\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (lo < 0) {\n                    throw new Error(\"lo must be non-negative\");\n                }\n                if (hi == null) {\n                    hi = a.length;\n                }\n                while(lo < hi){\n                    mid = floor((lo + hi) / 2);\n                    if (cmp(x, a[mid]) < 0) {\n                        hi = mid;\n                    } else {\n                        lo = mid + 1;\n                    }\n                }\n                return [].splice.apply(a, [\n                    lo,\n                    lo - lo\n                ].concat(x)), x;\n            };\n            /*\n\t\t  Push item onto heap, maintaining the heap invariant.\n\t\t   */ heappush = function(array, item, cmp) {\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                array.push(item);\n                return _siftdown(array, 0, array.length - 1, cmp);\n            };\n            /*\n\t\t  Pop the smallest item off the heap, maintaining the heap invariant.\n\t\t   */ heappop = function(array, cmp) {\n                var lastelt, returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                lastelt = array.pop();\n                if (array.length) {\n                    returnitem = array[0];\n                    array[0] = lastelt;\n                    _siftup(array, 0, cmp);\n                } else {\n                    returnitem = lastelt;\n                }\n                return returnitem;\n            };\n            /*\n\t\t  Pop and return the current smallest value, and add the new item.\n\t\t  \n\t\t  This is more efficient than heappop() followed by heappush(), and can be\n\t\t  more appropriate when using a fixed size heap. Note that the value\n\t\t  returned may be larger than item! That constrains reasonable use of\n\t\t  this routine unless written as part of a conditional replacement:\n\t\t      if item > array[0]\n\t\t        item = heapreplace(array, item)\n\t\t   */ heapreplace = function(array, item, cmp) {\n                var returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                returnitem = array[0];\n                array[0] = item;\n                _siftup(array, 0, cmp);\n                return returnitem;\n            };\n            /*\n\t\t  Fast version of a heappush followed by a heappop.\n\t\t   */ heappushpop = function(array, item, cmp) {\n                var _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (array.length && cmp(array[0], item) < 0) {\n                    _ref = [\n                        array[0],\n                        item\n                    ], item = _ref[0], array[0] = _ref[1];\n                    _siftup(array, 0, cmp);\n                }\n                return item;\n            };\n            /*\n\t\t  Transform list into a heap, in-place, in O(array.length) time.\n\t\t   */ heapify = function(array, cmp) {\n                var i, _i, _len, _ref1, _results, _results1;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                _ref1 = (function() {\n                    _results1 = [];\n                    for(var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){\n                        _results1.push(_j);\n                    }\n                    return _results1;\n                }).apply(this).reverse();\n                _results = [];\n                for(_i = 0, _len = _ref1.length; _i < _len; _i++){\n                    i = _ref1[_i];\n                    _results.push(_siftup(array, i, cmp));\n                }\n                return _results;\n            };\n            /*\n\t\t  Update the position of the given item in the heap.\n\t\t  This function should be called every time the item is being modified.\n\t\t   */ updateItem = function(array, item, cmp) {\n                var pos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                pos = array.indexOf(item);\n                if (pos === -1) {\n                    return;\n                }\n                _siftdown(array, 0, pos, cmp);\n                return _siftup(array, pos, cmp);\n            };\n            /*\n\t\t  Find the n largest elements in a dataset.\n\t\t   */ nlargest = function(array, n, cmp) {\n                var elem, result, _i, _len, _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                result = array.slice(0, n);\n                if (!result.length) {\n                    return result;\n                }\n                heapify(result, cmp);\n                _ref = array.slice(n);\n                for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                    elem = _ref[_i];\n                    heappushpop(result, elem, cmp);\n                }\n                return result.sort(cmp).reverse();\n            };\n            /*\n\t\t  Find the n smallest elements in a dataset.\n\t\t   */ nsmallest = function(array, n, cmp) {\n                var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (n * 10 <= array.length) {\n                    result = array.slice(0, n).sort(cmp);\n                    if (!result.length) {\n                        return result;\n                    }\n                    los = result[result.length - 1];\n                    _ref = array.slice(n);\n                    for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                        elem = _ref[_i];\n                        if (cmp(elem, los) < 0) {\n                            insort(result, elem, 0, null, cmp);\n                            result.pop();\n                            los = result[result.length - 1];\n                        }\n                    }\n                    return result;\n                }\n                heapify(array, cmp);\n                _results = [];\n                for(_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j){\n                    _results.push(heappop(array, cmp));\n                }\n                return _results;\n            };\n            _siftdown = function(array, startpos, pos, cmp) {\n                var newitem, parent, parentpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                newitem = array[pos];\n                while(pos > startpos){\n                    parentpos = pos - 1 >> 1;\n                    parent = array[parentpos];\n                    if (cmp(newitem, parent) < 0) {\n                        array[pos] = parent;\n                        pos = parentpos;\n                        continue;\n                    }\n                    break;\n                }\n                return array[pos] = newitem;\n            };\n            _siftup = function(array, pos, cmp) {\n                var childpos, endpos, newitem, rightpos, startpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                endpos = array.length;\n                startpos = pos;\n                newitem = array[pos];\n                childpos = 2 * pos + 1;\n                while(childpos < endpos){\n                    rightpos = childpos + 1;\n                    if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n                        childpos = rightpos;\n                    }\n                    array[pos] = array[childpos];\n                    pos = childpos;\n                    childpos = 2 * pos + 1;\n                }\n                array[pos] = newitem;\n                return _siftdown(array, startpos, pos, cmp);\n            };\n            Heap = function() {\n                Heap.push = heappush;\n                Heap.pop = heappop;\n                Heap.replace = heapreplace;\n                Heap.pushpop = heappushpop;\n                Heap.heapify = heapify;\n                Heap.updateItem = updateItem;\n                Heap.nlargest = nlargest;\n                Heap.nsmallest = nsmallest;\n                function Heap(cmp) {\n                    this.cmp = cmp != null ? cmp : defaultCmp;\n                    this.nodes = [];\n                }\n                Heap.prototype.push = function(x) {\n                    return heappush(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pop = function() {\n                    return heappop(this.nodes, this.cmp);\n                };\n                Heap.prototype.peek = function() {\n                    return this.nodes[0];\n                };\n                Heap.prototype.contains = function(x) {\n                    return this.nodes.indexOf(x) !== -1;\n                };\n                Heap.prototype.replace = function(x) {\n                    return heapreplace(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pushpop = function(x) {\n                    return heappushpop(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.heapify = function() {\n                    return heapify(this.nodes, this.cmp);\n                };\n                Heap.prototype.updateItem = function(x) {\n                    return updateItem(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.clear = function() {\n                    return this.nodes = [];\n                };\n                Heap.prototype.empty = function() {\n                    return this.nodes.length === 0;\n                };\n                Heap.prototype.size = function() {\n                    return this.nodes.length;\n                };\n                Heap.prototype.clone = function() {\n                    var heap;\n                    heap = new Heap();\n                    heap.nodes = this.nodes.slice(0);\n                    return heap;\n                };\n                Heap.prototype.toArray = function() {\n                    return this.nodes.slice(0);\n                };\n                Heap.prototype.insert = Heap.prototype.push;\n                Heap.prototype.top = Heap.prototype.peek;\n                Heap.prototype.front = Heap.prototype.peek;\n                Heap.prototype.has = Heap.prototype.contains;\n                Heap.prototype.copy = Heap.prototype.clone;\n                return Heap;\n            }();\n            (function(root, factory) {\n                {\n                    return module.exports = factory();\n                }\n            })(this, function() {\n                return Heap;\n            });\n        }).call(heap$1);\n    })(heap$2);\n    return heap$2.exports;\n}\nvar heap;\nvar hasRequiredHeap;\nfunction requireHeap() {\n    if (hasRequiredHeap) return heap;\n    hasRequiredHeap = 1;\n    heap = requireHeap$1();\n    return heap;\n}\nvar heapExports = requireHeap();\nvar Heap = /*@__PURE__*/ getDefaultExportFromCjs(heapExports);\nvar dijkstraDefaults = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false\n});\nvar elesfn$u = {\n    dijkstra: function dijkstra(options) {\n        if (!plainObject(options)) {\n            var args = arguments;\n            options = {\n                root: args[0],\n                weight: args[1],\n                directed: args[2]\n            };\n        }\n        var _dijkstraDefaults = dijkstraDefaults(options), root = _dijkstraDefaults.root, weight = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;\n        var eles = this;\n        var weightFn = weight;\n        var source = string(root) ? this.filter(root)[0] : root[0];\n        var dist = {};\n        var prev = {};\n        var knownDist = {};\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        edges.unmergeBy(function(ele) {\n            return ele.isLoop();\n        });\n        var getDist = function getDist(node) {\n            return dist[node.id()];\n        };\n        var setDist = function setDist(node, d) {\n            dist[node.id()] = d;\n            Q.updateItem(node);\n        };\n        var Q = new Heap(function(a, b) {\n            return getDist(a) - getDist(b);\n        });\n        for(var i = 0; i < nodes.length; i++){\n            var node = nodes[i];\n            dist[node.id()] = node.same(source) ? 0 : Infinity;\n            Q.push(node);\n        }\n        var distBetween = function distBetween(u, v) {\n            var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n            var smallestDistance = Infinity;\n            var smallestEdge;\n            for(var _i = 0; _i < uvs.length; _i++){\n                var edge = uvs[_i];\n                var _weight = weightFn(edge);\n                if (_weight < smallestDistance || !smallestEdge) {\n                    smallestDistance = _weight;\n                    smallestEdge = edge;\n                }\n            }\n            return {\n                edge: smallestEdge,\n                dist: smallestDistance\n            };\n        };\n        while(Q.size() > 0){\n            var u = Q.pop();\n            var smalletsDist = getDist(u);\n            var uid = u.id();\n            knownDist[uid] = smalletsDist;\n            if (smalletsDist === Infinity) {\n                continue;\n            }\n            var neighbors = u.neighborhood().intersect(nodes);\n            for(var _i2 = 0; _i2 < neighbors.length; _i2++){\n                var v = neighbors[_i2];\n                var vid = v.id();\n                var vDist = distBetween(u, v);\n                var alt = smalletsDist + vDist.dist;\n                if (alt < getDist(v)) {\n                    setDist(v, alt);\n                    prev[vid] = {\n                        node: u,\n                        edge: vDist.edge\n                    };\n                }\n            } // for\n        } // while\n        return {\n            distanceTo: function distanceTo(node) {\n                var target = string(node) ? nodes.filter(node)[0] : node[0];\n                return knownDist[target.id()];\n            },\n            pathTo: function pathTo(node) {\n                var target = string(node) ? nodes.filter(node)[0] : node[0];\n                var S = [];\n                var u = target;\n                var uid = u.id();\n                if (target.length > 0) {\n                    S.unshift(target);\n                    while(prev[uid]){\n                        var p = prev[uid];\n                        S.unshift(p.edge);\n                        S.unshift(p.node);\n                        u = p.node;\n                        uid = u.id();\n                    }\n                }\n                return eles.spawn(S);\n            }\n        };\n    }\n};\nvar elesfn$t = {\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function kruskal(weightFn) {\n        weightFn = weightFn || function(edge) {\n            return 1;\n        };\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var numNodes = nodes.length;\n        var forest = new Array(numNodes);\n        var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n        var findSetIndex = function findSetIndex(ele) {\n            for(var i = 0; i < forest.length; i++){\n                var eles = forest[i];\n                if (eles.has(ele)) {\n                    return i;\n                }\n            }\n        };\n        // start with one forest per node\n        for(var i = 0; i < numNodes; i++){\n            forest[i] = this.spawn(nodes[i]);\n        }\n        var S = edges.sort(function(a, b) {\n            return weightFn(a) - weightFn(b);\n        });\n        for(var _i = 0; _i < S.length; _i++){\n            var edge = S[_i];\n            var u = edge.source()[0];\n            var v = edge.target()[0];\n            var setUIndex = findSetIndex(u);\n            var setVIndex = findSetIndex(v);\n            var setU = forest[setUIndex];\n            var setV = forest[setVIndex];\n            if (setUIndex !== setVIndex) {\n                A.merge(edge);\n                // combine forests for u and v\n                setU.merge(setV);\n                forest.splice(setVIndex, 1);\n            }\n        }\n        return A;\n    }\n};\nvar aStarDefaults = defaults$g({\n    root: null,\n    goal: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    heuristic: function heuristic(edge) {\n        return 0;\n    },\n    directed: false\n});\nvar elesfn$s = {\n    // Implemented from pseudocode from wikipedia\n    aStar: function aStar(options) {\n        var cy = this.cy();\n        var _aStarDefaults = aStarDefaults(options), root = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight = _aStarDefaults.weight;\n        root = cy.collection(root)[0];\n        goal = cy.collection(goal)[0];\n        var sid = root.id();\n        var tid = goal.id();\n        var gScore = {};\n        var fScore = {};\n        var closedSetIds = {};\n        var openSet = new Heap(function(a, b) {\n            return fScore[a.id()] - fScore[b.id()];\n        });\n        var openSetIds = new Set$1();\n        var cameFrom = {};\n        var cameFromEdge = {};\n        var addToOpenSet = function addToOpenSet(ele, id) {\n            openSet.push(ele);\n            openSetIds.add(id);\n        };\n        var cMin, cMinId;\n        var popFromOpenSet = function popFromOpenSet() {\n            cMin = openSet.pop();\n            cMinId = cMin.id();\n            openSetIds[\"delete\"](cMinId);\n        };\n        var isInOpenSet = function isInOpenSet(id) {\n            return openSetIds.has(id);\n        };\n        addToOpenSet(root, sid);\n        gScore[sid] = 0;\n        fScore[sid] = heuristic(root);\n        // Counter\n        var steps = 0;\n        // Main loop\n        while(openSet.size() > 0){\n            popFromOpenSet();\n            steps++;\n            // If we've found our goal, then we are done\n            if (cMinId === tid) {\n                var path = [];\n                var pathNode = goal;\n                var pathNodeId = tid;\n                var pathEdge = cameFromEdge[pathNodeId];\n                for(;;){\n                    path.unshift(pathNode);\n                    if (pathEdge != null) {\n                        path.unshift(pathEdge);\n                    }\n                    pathNode = cameFrom[pathNodeId];\n                    if (pathNode == null) {\n                        break;\n                    }\n                    pathNodeId = pathNode.id();\n                    pathEdge = cameFromEdge[pathNodeId];\n                }\n                return {\n                    found: true,\n                    distance: gScore[cMinId],\n                    path: this.spawn(path),\n                    steps: steps\n                };\n            }\n            // Add cMin to processed nodes\n            closedSetIds[cMinId] = true;\n            // Update scores for neighbors of cMin\n            // Take into account if graph is directed or not\n            var vwEdges = cMin._private.edges;\n            for(var i = 0; i < vwEdges.length; i++){\n                var e = vwEdges[i];\n                // edge must be in set of calling eles\n                if (!this.hasElementWithId(e.id())) {\n                    continue;\n                }\n                // cMin must be the source of edge if directed\n                if (directed && e.data(\"source\") !== cMinId) {\n                    continue;\n                }\n                var wSrc = e.source();\n                var wTgt = e.target();\n                var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n                var wid = w.id();\n                // node must be in set of calling eles\n                if (!this.hasElementWithId(wid)) {\n                    continue;\n                }\n                // if node is in closedSet, ignore it\n                if (closedSetIds[wid]) {\n                    continue;\n                }\n                // New tentative score for node w\n                var tempScore = gScore[cMinId] + weight(e);\n                // Update gScore for node w if:\n                //   w not present in openSet\n                // OR\n                //   tentative gScore is less than previous value\n                // w not in openSet\n                if (!isInOpenSet(wid)) {\n                    gScore[wid] = tempScore;\n                    fScore[wid] = tempScore + heuristic(w);\n                    addToOpenSet(w, wid);\n                    cameFrom[wid] = cMin;\n                    cameFromEdge[wid] = e;\n                    continue;\n                }\n                // w already in openSet, but with greater gScore\n                if (tempScore < gScore[wid]) {\n                    gScore[wid] = tempScore;\n                    fScore[wid] = tempScore + heuristic(w);\n                    cameFrom[wid] = cMin;\n                    cameFromEdge[wid] = e;\n                }\n            } // End of neighbors update\n        } // End of main loop\n        // If we've reached here, then we've not reached our goal\n        return {\n            found: false,\n            distance: undefined,\n            path: undefined,\n            steps: steps\n        };\n    }\n}; // elesfn\nvar floydWarshallDefaults = defaults$g({\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false\n});\nvar elesfn$r = {\n    // Implemented from pseudocode from wikipedia\n    floydWarshall: function floydWarshall(options) {\n        var cy = this.cy();\n        var _floydWarshallDefault = floydWarshallDefaults(options), weight = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;\n        var weightFn = weight;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var N = nodes.length;\n        var Nsq = N * N;\n        var indexOf = function indexOf(node) {\n            return nodes.indexOf(node);\n        };\n        var atIndex = function atIndex(i) {\n            return nodes[i];\n        };\n        // Initialize distance matrix\n        var dist = new Array(Nsq);\n        for(var n = 0; n < Nsq; n++){\n            var j = n % N;\n            var i = (n - j) / N;\n            if (i === j) {\n                dist[n] = 0;\n            } else {\n                dist[n] = Infinity;\n            }\n        }\n        // Initialize matrix used for path reconstruction\n        // Initialize distance matrix\n        var next = new Array(Nsq);\n        var edgeNext = new Array(Nsq);\n        // Process edges\n        for(var _i = 0; _i < edges.length; _i++){\n            var edge = edges[_i];\n            var src = edge.source()[0];\n            var tgt = edge.target()[0];\n            if (src === tgt) {\n                continue;\n            } // exclude loops\n            var s = indexOf(src);\n            var t = indexOf(tgt);\n            var st = s * N + t; // source to target index\n            var _weight = weightFn(edge);\n            // Check if already process another edge between same 2 nodes\n            if (dist[st] > _weight) {\n                dist[st] = _weight;\n                next[st] = t;\n                edgeNext[st] = edge;\n            }\n            // If undirected graph, process 'reversed' edge\n            if (!directed) {\n                var ts = t * N + s; // target to source index\n                if (!directed && dist[ts] > _weight) {\n                    dist[ts] = _weight;\n                    next[ts] = s;\n                    edgeNext[ts] = edge;\n                }\n            }\n        }\n        // Main loop\n        for(var k = 0; k < N; k++){\n            for(var _i2 = 0; _i2 < N; _i2++){\n                var ik = _i2 * N + k;\n                for(var _j = 0; _j < N; _j++){\n                    var ij = _i2 * N + _j;\n                    var kj = k * N + _j;\n                    if (dist[ik] + dist[kj] < dist[ij]) {\n                        dist[ij] = dist[ik] + dist[kj];\n                        next[ij] = next[ik];\n                    }\n                }\n            }\n        }\n        var getArgEle = function getArgEle(ele) {\n            return (string(ele) ? cy.filter(ele) : ele)[0];\n        };\n        var indexOfArgEle = function indexOfArgEle(ele) {\n            return indexOf(getArgEle(ele));\n        };\n        var res = {\n            distance: function distance(from, to) {\n                var i = indexOfArgEle(from);\n                var j = indexOfArgEle(to);\n                return dist[i * N + j];\n            },\n            path: function path(from, to) {\n                var i = indexOfArgEle(from);\n                var j = indexOfArgEle(to);\n                var fromNode = atIndex(i);\n                if (i === j) {\n                    return fromNode.collection();\n                }\n                if (next[i * N + j] == null) {\n                    return cy.collection();\n                }\n                var path = cy.collection();\n                var prev = i;\n                var edge;\n                path.merge(fromNode);\n                while(i !== j){\n                    prev = i;\n                    i = next[i * N + j];\n                    edge = edgeNext[prev * N + i];\n                    path.merge(edge);\n                    path.merge(atIndex(i));\n                }\n                return path;\n            }\n        };\n        return res;\n    } // floydWarshall\n}; // elesfn\nvar bellmanFordDefaults = defaults$g({\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false,\n    root: null\n});\nvar elesfn$q = {\n    // Implemented from pseudocode from wikipedia\n    bellmanFord: function bellmanFord(options) {\n        var _this = this;\n        var _bellmanFordDefaults = bellmanFordDefaults(options), weight = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root = _bellmanFordDefaults.root;\n        var weightFn = weight;\n        var eles = this;\n        var cy = this.cy();\n        var _this$byGroup = this.byGroup(), edges = _this$byGroup.edges, nodes = _this$byGroup.nodes;\n        var numNodes = nodes.length;\n        var infoMap = new Map$1();\n        var hasNegativeWeightCycle = false;\n        var negativeWeightCycles = [];\n        root = cy.collection(root)[0]; // in case selector passed\n        edges.unmergeBy(function(edge) {\n            return edge.isLoop();\n        });\n        var numEdges = edges.length;\n        var getInfo = function getInfo(node) {\n            var obj = infoMap.get(node.id());\n            if (!obj) {\n                obj = {};\n                infoMap.set(node.id(), obj);\n            }\n            return obj;\n        };\n        var getNodeFromTo = function getNodeFromTo(to) {\n            return (string(to) ? cy.$(to) : to)[0];\n        };\n        var distanceTo = function distanceTo(to) {\n            return getInfo(getNodeFromTo(to)).dist;\n        };\n        var pathTo = function pathTo(to) {\n            var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n            var end = getNodeFromTo(to);\n            var path = [];\n            var node = end;\n            for(;;){\n                if (node == null) {\n                    return _this.spawn();\n                }\n                var _getInfo = getInfo(node), edge = _getInfo.edge, pred = _getInfo.pred;\n                path.unshift(node[0]);\n                if (node.same(thisStart) && path.length > 0) {\n                    break;\n                }\n                if (edge != null) {\n                    path.unshift(edge);\n                }\n                node = pred;\n            }\n            return eles.spawn(path);\n        };\n        // Initializations { dist, pred, edge }\n        for(var i = 0; i < numNodes; i++){\n            var node = nodes[i];\n            var info = getInfo(node);\n            if (node.same(root)) {\n                info.dist = 0;\n            } else {\n                info.dist = Infinity;\n            }\n            info.pred = null;\n            info.edge = null;\n        }\n        // Edges relaxation\n        var replacedEdge = false;\n        var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n            var dist = info1.dist + weight;\n            if (dist < info2.dist && !edge.same(info1.edge)) {\n                info2.dist = dist;\n                info2.pred = node1;\n                info2.edge = edge;\n                replacedEdge = true;\n            }\n        };\n        for(var _i = 1; _i < numNodes; _i++){\n            replacedEdge = false;\n            for(var e = 0; e < numEdges; e++){\n                var edge = edges[e];\n                var src = edge.source();\n                var tgt = edge.target();\n                var _weight = weightFn(edge);\n                var srcInfo = getInfo(src);\n                var tgtInfo = getInfo(tgt);\n                checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);\n                // If undirected graph, we need to take into account the 'reverse' edge\n                if (!directed) {\n                    checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n                }\n            }\n            if (!replacedEdge) {\n                break;\n            }\n        }\n        if (replacedEdge) {\n            // Check for negative weight cycles\n            var negativeWeightCycleIds = [];\n            for(var _e = 0; _e < numEdges; _e++){\n                var _edge = edges[_e];\n                var _src = _edge.source();\n                var _tgt = _edge.target();\n                var _weight2 = weightFn(_edge);\n                var srcDist = getInfo(_src).dist;\n                var tgtDist = getInfo(_tgt).dist;\n                if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n                    if (!hasNegativeWeightCycle) {\n                        warn(\"Graph contains a negative weight cycle for Bellman-Ford\");\n                        hasNegativeWeightCycle = true;\n                    }\n                    if (options.findNegativeWeightCycles !== false) {\n                        var negativeNodes = [];\n                        if (srcDist + _weight2 < tgtDist) {\n                            negativeNodes.push(_src);\n                        }\n                        if (!directed && tgtDist + _weight2 < srcDist) {\n                            negativeNodes.push(_tgt);\n                        }\n                        var numNegativeNodes = negativeNodes.length;\n                        for(var n = 0; n < numNegativeNodes; n++){\n                            var start = negativeNodes[n];\n                            var cycle = [\n                                start\n                            ];\n                            cycle.push(getInfo(start).edge);\n                            var _node = getInfo(start).pred;\n                            while(cycle.indexOf(_node) === -1){\n                                cycle.push(_node);\n                                cycle.push(getInfo(_node).edge);\n                                _node = getInfo(_node).pred;\n                            }\n                            cycle = cycle.slice(cycle.indexOf(_node));\n                            var smallestId = cycle[0].id();\n                            var smallestIndex = 0;\n                            for(var c = 2; c < cycle.length; c += 2){\n                                if (cycle[c].id() < smallestId) {\n                                    smallestId = cycle[c].id();\n                                    smallestIndex = c;\n                                }\n                            }\n                            cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n                            cycle.push(cycle[0]);\n                            var cycleId = cycle.map(function(el) {\n                                return el.id();\n                            }).join(\",\");\n                            if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                                negativeWeightCycles.push(eles.spawn(cycle));\n                                negativeWeightCycleIds.push(cycleId);\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        return {\n            distanceTo: distanceTo,\n            pathTo: pathTo,\n            hasNegativeWeightCycle: hasNegativeWeightCycle,\n            negativeWeightCycles: negativeWeightCycles\n        };\n    } // bellmanFord\n}; // elesfn\nvar sqrt2 = Math.sqrt(2);\n// Function which colapses 2 (meta) nodes into one\n// Updates the remaining edge lists\n// Receives as a paramater the edge which causes the collapse\nvar collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n    if (remainingEdges.length === 0) {\n        error(\"Karger-Stein must be run on a connected (sub)graph\");\n    }\n    var edgeInfo = remainingEdges[edgeIndex];\n    var sourceIn = edgeInfo[1];\n    var targetIn = edgeInfo[2];\n    var partition1 = nodeMap[sourceIn];\n    var partition2 = nodeMap[targetIn];\n    var newEdges = remainingEdges; // re-use array\n    // Delete all edges between partition1 and partition2\n    for(var i = newEdges.length - 1; i >= 0; i--){\n        var edge = newEdges[i];\n        var src = edge[1];\n        var tgt = edge[2];\n        if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n            newEdges.splice(i, 1);\n        }\n    }\n    // All edges pointing to partition2 should now point to partition1\n    for(var _i = 0; _i < newEdges.length; _i++){\n        var _edge = newEdges[_i];\n        if (_edge[1] === partition2) {\n            // Check source\n            newEdges[_i] = _edge.slice(); // copy\n            newEdges[_i][1] = partition1;\n        } else if (_edge[2] === partition2) {\n            // Check target\n            newEdges[_i] = _edge.slice(); // copy\n            newEdges[_i][2] = partition1;\n        }\n    }\n    // Move all nodes from partition2 to partition1\n    for(var _i2 = 0; _i2 < nodeMap.length; _i2++){\n        if (nodeMap[_i2] === partition2) {\n            nodeMap[_i2] = partition1;\n        }\n    }\n    return newEdges;\n};\n// Contracts a graph until we reach a certain number of meta nodes\nvar contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n    while(size > sizeLimit){\n        // Choose an edge randomly\n        var edgeIndex = Math.floor(Math.random() * remainingEdges.length);\n        // Collapse graph based on edge\n        remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n        size--;\n    }\n    return remainingEdges;\n};\nvar elesfn$p = {\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    kargerStein: function kargerStein() {\n        var _this = this;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        edges.unmergeBy(function(edge) {\n            return edge.isLoop();\n        });\n        var numNodes = nodes.length;\n        var numEdges = edges.length;\n        var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n        var stopSize = Math.floor(numNodes / sqrt2);\n        if (numNodes < 2) {\n            error(\"At least 2 nodes are required for Karger-Stein algorithm\");\n            return undefined;\n        }\n        // Now store edge destination as indexes\n        // Format for each edge (edge index, source node index, target node index)\n        var edgeIndexes = [];\n        for(var i = 0; i < numEdges; i++){\n            var e = edges[i];\n            edgeIndexes.push([\n                i,\n                nodes.indexOf(e.source()),\n                nodes.indexOf(e.target())\n            ]);\n        }\n        // We will store the best cut found here\n        var minCutSize = Infinity;\n        var minCutEdgeIndexes = [];\n        var minCutNodeMap = new Array(numNodes);\n        // Initial meta node partition\n        var metaNodeMap = new Array(numNodes);\n        var metaNodeMap2 = new Array(numNodes);\n        var copyNodesMap = function copyNodesMap(from, to) {\n            for(var _i3 = 0; _i3 < numNodes; _i3++){\n                to[_i3] = from[_i3];\n            }\n        };\n        // Main loop\n        for(var iter = 0; iter <= numIter; iter++){\n            // Reset meta node partition\n            for(var _i4 = 0; _i4 < numNodes; _i4++){\n                metaNodeMap[_i4] = _i4;\n            }\n            // Contract until stop point (stopSize nodes)\n            var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n            var edgesState2 = edgesState.slice(); // copy\n            // Create a copy of the colapsed nodes state\n            copyNodesMap(metaNodeMap, metaNodeMap2);\n            // Run 2 iterations starting in the stop state\n            var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n            var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);\n            // Is any of the 2 results the best cut so far?\n            if (res1.length <= res2.length && res1.length < minCutSize) {\n                minCutSize = res1.length;\n                minCutEdgeIndexes = res1;\n                copyNodesMap(metaNodeMap, minCutNodeMap);\n            } else if (res2.length <= res1.length && res2.length < minCutSize) {\n                minCutSize = res2.length;\n                minCutEdgeIndexes = res2;\n                copyNodesMap(metaNodeMap2, minCutNodeMap);\n            }\n        } // end of main loop\n        // Construct result\n        var cut = this.spawn(minCutEdgeIndexes.map(function(e) {\n            return edges[e[0]];\n        }));\n        var partition1 = this.spawn();\n        var partition2 = this.spawn();\n        // traverse metaNodeMap for best cut\n        var witnessNodePartition = minCutNodeMap[0];\n        for(var _i5 = 0; _i5 < minCutNodeMap.length; _i5++){\n            var partitionId = minCutNodeMap[_i5];\n            var node = nodes[_i5];\n            if (partitionId === witnessNodePartition) {\n                partition1.merge(node);\n            } else {\n                partition2.merge(node);\n            }\n        }\n        // construct components corresponding to each disjoint subset of nodes\n        var constructComponent = function constructComponent(subset) {\n            var component = _this.spawn();\n            subset.forEach(function(node) {\n                component.merge(node);\n                node.connectedEdges().forEach(function(edge) {\n                    // ensure edge is within calling collection and edge is not in cut\n                    if (_this.contains(edge) && !cut.contains(edge)) {\n                        component.merge(edge);\n                    }\n                });\n            });\n            return component;\n        };\n        var components = [\n            constructComponent(partition1),\n            constructComponent(partition2)\n        ];\n        var ret = {\n            cut: cut,\n            components: components,\n            // n.b. partitions are included to be compatible with the old api spec\n            // (could be removed in a future major version)\n            partition1: partition1,\n            partition2: partition2\n        };\n        return ret;\n    }\n}; // elesfn\nvar _Math$hypot;\nvar copyPosition = function copyPosition(p) {\n    return {\n        x: p.x,\n        y: p.y\n    };\n};\nvar modelToRenderedPosition$1 = function modelToRenderedPosition(p, zoom, pan) {\n    return {\n        x: p.x * zoom + pan.x,\n        y: p.y * zoom + pan.y\n    };\n};\nvar renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n    return {\n        x: (p.x - pan.x) / zoom,\n        y: (p.y - pan.y) / zoom\n    };\n};\nvar array2point = function array2point(arr) {\n    return {\n        x: arr[0],\n        y: arr[1]\n    };\n};\nvar min = function min(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var min = Infinity;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            min = Math.min(val, min);\n        }\n    }\n    return min;\n};\nvar max = function max(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var max = -Infinity;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            max = Math.max(val, max);\n        }\n    }\n    return max;\n};\nvar mean = function mean(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var total = 0;\n    var n = 0;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            total += val;\n            n++;\n        }\n    }\n    return total / n;\n};\nvar median = function median(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (copy) {\n        arr = arr.slice(begin, end);\n    } else {\n        if (end < arr.length) {\n            arr.splice(end, arr.length - end);\n        }\n        if (begin > 0) {\n            arr.splice(0, begin);\n        }\n    }\n    // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n    var off = 0; // offset from non-finite values\n    for(var i = arr.length - 1; i >= 0; i--){\n        var v = arr[i];\n        if (includeHoles) {\n            if (!isFinite(v)) {\n                arr[i] = -Infinity;\n                off++;\n            }\n        } else {\n            // just remove it if we don't want to consider holes\n            arr.splice(i, 1);\n        }\n    }\n    if (sort) {\n        arr.sort(function(a, b) {\n            return a - b;\n        }); // requires copy = true if you don't want to change the orig\n    }\n    var len = arr.length;\n    var mid = Math.floor(len / 2);\n    if (len % 2 !== 0) {\n        return arr[mid + 1 + off];\n    } else {\n        return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n    }\n};\nvar deg2rad = function deg2rad(deg) {\n    return Math.PI * deg / 180;\n};\nvar getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n    return Math.atan2(dispY, dispX) - Math.PI / 2;\n};\nvar log2 = Math.log2 || function(n) {\n    return Math.log(n) / Math.log(2);\n};\nvar signum = function signum(x) {\n    if (x > 0) {\n        return 1;\n    } else if (x < 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n};\nvar dist = function dist(p1, p2) {\n    return Math.sqrt(sqdist(p1, p2));\n};\nvar sqdist = function sqdist(p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n};\nvar inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n    var length = v.length;\n    // First, get sum of all elements\n    var total = 0;\n    for(var i = 0; i < length; i++){\n        total += v[i];\n    }\n    // Now, divide each by the sum of all elements\n    for(var _i = 0; _i < length; _i++){\n        v[_i] = v[_i] / total;\n    }\n    return v;\n};\n// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\nvar qbezierAt = function qbezierAt(p0, p1, p2, t) {\n    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\nvar qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n    return {\n        x: qbezierAt(p0.x, p1.x, p2.x, t),\n        y: qbezierAt(p0.y, p1.y, p2.y, t)\n    };\n};\nvar lineAt = function lineAt(p0, p1, t, d) {\n    var vec = {\n        x: p1.x - p0.x,\n        y: p1.y - p0.y\n    };\n    var vecDist = dist(p0, p1);\n    var normVec = {\n        x: vec.x / vecDist,\n        y: vec.y / vecDist\n    };\n    t = t == null ? 0 : t;\n    d = d != null ? d : t * vecDist;\n    return {\n        x: p0.x + normVec.x * d,\n        y: p0.y + normVec.y * d\n    };\n};\nvar bound = function bound(min, val, max) {\n    return Math.max(min, Math.min(max, val));\n};\n// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\nvar makeBoundingBox = function makeBoundingBox(bb) {\n    if (bb == null) {\n        return {\n            x1: Infinity,\n            y1: Infinity,\n            x2: -Infinity,\n            y2: -Infinity,\n            w: 0,\n            h: 0\n        };\n    } else if (bb.x1 != null && bb.y1 != null) {\n        if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n            return {\n                x1: bb.x1,\n                y1: bb.y1,\n                x2: bb.x2,\n                y2: bb.y2,\n                w: bb.x2 - bb.x1,\n                h: bb.y2 - bb.y1\n            };\n        } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n            return {\n                x1: bb.x1,\n                y1: bb.y1,\n                x2: bb.x1 + bb.w,\n                y2: bb.y1 + bb.h,\n                w: bb.w,\n                h: bb.h\n            };\n        }\n    }\n};\nvar copyBoundingBox = function copyBoundingBox(bb) {\n    return {\n        x1: bb.x1,\n        x2: bb.x2,\n        w: bb.w,\n        y1: bb.y1,\n        y2: bb.y2,\n        h: bb.h\n    };\n};\nvar clearBoundingBox = function clearBoundingBox(bb) {\n    bb.x1 = Infinity;\n    bb.y1 = Infinity;\n    bb.x2 = -Infinity;\n    bb.y2 = -Infinity;\n    bb.w = 0;\n    bb.h = 0;\n};\nvar updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n    // update bb1 with bb2 bounds\n    bb1.x1 = Math.min(bb1.x1, bb2.x1);\n    bb1.x2 = Math.max(bb1.x2, bb2.x2);\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.y1 = Math.min(bb1.y1, bb2.y1);\n    bb1.y2 = Math.max(bb1.y2, bb2.y2);\n    bb1.h = bb1.y2 - bb1.y1;\n};\nvar expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n    bb.x1 = Math.min(bb.x1, x);\n    bb.x2 = Math.max(bb.x2, x);\n    bb.w = bb.x2 - bb.x1;\n    bb.y1 = Math.min(bb.y1, y);\n    bb.y2 = Math.max(bb.y2, y);\n    bb.h = bb.y2 - bb.y1;\n};\nvar expandBoundingBox = function expandBoundingBox(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    bb.x1 -= padding;\n    bb.x2 += padding;\n    bb.y1 -= padding;\n    bb.y2 += padding;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n};\nvar expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\n        0\n    ];\n    var top, right, bottom, left;\n    if (padding.length === 1) {\n        top = right = bottom = left = padding[0];\n    } else if (padding.length === 2) {\n        top = bottom = padding[0];\n        left = right = padding[1];\n    } else if (padding.length === 4) {\n        var _padding = _slicedToArray(padding, 4);\n        top = _padding[0];\n        right = _padding[1];\n        bottom = _padding[2];\n        left = _padding[3];\n    }\n    bb.x1 -= left;\n    bb.x2 += right;\n    bb.y1 -= top;\n    bb.y2 += bottom;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n};\n// assign the values of bb2 into bb1\nvar assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n    bb1.x1 = bb2.x1;\n    bb1.y1 = bb2.y1;\n    bb1.x2 = bb2.x2;\n    bb1.y2 = bb2.y2;\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.h = bb1.y2 - bb1.y1;\n};\nvar boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n    // case: one bb to right of other\n    if (bb1.x1 > bb2.x2) {\n        return false;\n    }\n    if (bb2.x1 > bb1.x2) {\n        return false;\n    }\n    // case: one bb to left of other\n    if (bb1.x2 < bb2.x1) {\n        return false;\n    }\n    if (bb2.x2 < bb1.x1) {\n        return false;\n    }\n    // case: one bb above other\n    if (bb1.y2 < bb2.y1) {\n        return false;\n    }\n    if (bb2.y2 < bb1.y1) {\n        return false;\n    }\n    // case: one bb below other\n    if (bb1.y1 > bb2.y2) {\n        return false;\n    }\n    if (bb2.y1 > bb1.y2) {\n        return false;\n    }\n    // otherwise, must have some overlap\n    return true;\n};\nvar inBoundingBox = function inBoundingBox(bb, x, y) {\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\nvar pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n    return inBoundingBox(bb, pt.x, pt.y);\n};\nvar boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n};\nvar hypot = (_Math$hypot = Math.hypot) !== null && _Math$hypot !== undefined ? _Math$hypot : function(x, y) {\n    return Math.sqrt(x * x + y * y);\n};\nfunction inflatePolygon(polygon, d) {\n    if (polygon.length < 3) {\n        throw new Error(\"Need at least 3 vertices\");\n    }\n    // Helpers\n    var add = function add(a, b) {\n        return {\n            x: a.x + b.x,\n            y: a.y + b.y\n        };\n    };\n    var sub = function sub(a, b) {\n        return {\n            x: a.x - b.x,\n            y: a.y - b.y\n        };\n    };\n    var scale = function scale(v, s) {\n        return {\n            x: v.x * s,\n            y: v.y * s\n        };\n    };\n    var cross = function cross(u, v) {\n        return u.x * v.y - u.y * v.x;\n    };\n    var normalize = function normalize(v) {\n        var len = hypot(v.x, v.y);\n        return len === 0 ? {\n            x: 0,\n            y: 0\n        } : {\n            x: v.x / len,\n            y: v.y / len\n        };\n    };\n    // Signed area (positive = CCW)\n    var signedArea = function signedArea(pts) {\n        var A = 0;\n        for(var i = 0; i < pts.length; i++){\n            var p = pts[i], q = pts[(i + 1) % pts.length];\n            A += p.x * q.y - q.x * p.y;\n        }\n        return A / 2;\n    };\n    // Line–line intersection (infinite lines)\n    var intersectLines = function intersectLines(p1, p2, p3, p4) {\n        var r = sub(p2, p1);\n        var s = sub(p4, p3);\n        var denom = cross(r, s);\n        if (Math.abs(denom) < 1e-9) {\n            // Parallel or nearly so — fallback to midpoint\n            return add(p1, scale(r, 0.5));\n        }\n        var t = cross(sub(p3, p1), s) / denom;\n        return add(p1, scale(r, t));\n    };\n    // Make a shallow copy and enforce CCW\n    var pts = polygon.map(function(p) {\n        return {\n            x: p.x,\n            y: p.y\n        };\n    });\n    if (signedArea(pts) < 0) pts.reverse();\n    var n = pts.length;\n    // Compute outward normals for each edge\n    var normals = [];\n    for(var i = 0; i < n; i++){\n        var p = pts[i], q = pts[(i + 1) % n];\n        var edge = sub(q, p);\n        // For CCW polygon, inward normal = (-edge.y, edge.x)\n        // so outward normal = (edge.y, -edge.x)\n        var out = normalize({\n            x: edge.y,\n            y: -edge.x\n        });\n        normals.push(out);\n    }\n    // Build offset edges\n    var offsetEdges = normals.map(function(nrm, i) {\n        var p1 = add(pts[i], scale(nrm, d));\n        var p2 = add(pts[(i + 1) % n], scale(nrm, d));\n        return {\n            p1: p1,\n            p2: p2\n        };\n    });\n    // Intersect consecutive offset edges\n    var inflated = [];\n    for(var _i2 = 0; _i2 < n; _i2++){\n        var prevEdge = offsetEdges[(_i2 - 1 + n) % n];\n        var currEdge = offsetEdges[_i2];\n        var ip = intersectLines(prevEdge.p1, prevEdge.p2, currEdge.p1, currEdge.p2);\n        inflated.push(ip);\n    }\n    return inflated;\n}\nfunction miterBox(pts, centerX, centerY, width, height, strokeWidth) {\n    var tpts = transformPoints(pts, centerX, centerY, width, height);\n    var offsetPoints = inflatePolygon(tpts, strokeWidth);\n    var bb = makeBoundingBox();\n    offsetPoints.forEach(function(pt) {\n        return expandBoundingBoxByPoint(bb, pt.x, pt.y);\n    });\n    return bb;\n}\nvar roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n    var radius = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : \"auto\";\n    var cornerRadius = radius === \"auto\" ? getRoundRectangleRadius(width, height) : radius;\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    cornerRadius = Math.min(cornerRadius, halfWidth, halfHeight);\n    var doWidth = cornerRadius !== halfWidth, doHeight = cornerRadius !== halfHeight;\n    // Check intersections with straight line segments\n    var straightLineIntersections;\n    // Top segment, left to right\n    if (doWidth) {\n        var topStartX = nodeX - halfWidth + cornerRadius - padding;\n        var topStartY = nodeY - halfHeight - padding;\n        var topEndX = nodeX + halfWidth - cornerRadius + padding;\n        var topEndY = topStartY;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Right segment, top to bottom\n    if (doHeight) {\n        var rightStartX = nodeX + halfWidth + padding;\n        var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n        var rightEndX = rightStartX;\n        var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Bottom segment, left to right\n    if (doWidth) {\n        var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n        var bottomStartY = nodeY + halfHeight + padding;\n        var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n        var bottomEndY = bottomStartY;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Left segment, top to bottom\n    if (doHeight) {\n        var leftStartX = nodeX - halfWidth - padding;\n        var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n        var leftEndX = leftStartX;\n        var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Check intersections with arc segments\n    var arcIntersections;\n    // Top Left\n    {\n        var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n        var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Top Right\n    {\n        var topRightCenterX = nodeX + halfWidth - cornerRadius;\n        var topRightCenterY = nodeY - halfHeight + cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Bottom Right\n    {\n        var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n        var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Bottom Left\n    {\n        var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n        var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    return []; // if nothing\n};\nvar inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n    var t = tolerance;\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n};\nvar inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n    var bb = {\n        x1: Math.min(x1, x3, x2) - tolerance,\n        x2: Math.max(x1, x3, x2) + tolerance,\n        y1: Math.min(y1, y3, y2) - tolerance,\n        y2: Math.max(y1, y3, y2) + tolerance\n    };\n    // if outside the rough bounding box for the bezier, then it can't be a hit\n    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n        // console.log('bezier out of rough bb')\n        return false;\n    } else {\n        // console.log('do more expensive check');\n        return true;\n    }\n};\nvar solveQuadratic = function solveQuadratic(a, b, c, val) {\n    c -= val;\n    var r = b * b - 4 * a * c;\n    if (r < 0) {\n        return [];\n    }\n    var sqrtR = Math.sqrt(r);\n    var denom = 2 * a;\n    var root1 = (-b + sqrtR) / denom;\n    var root2 = (-b - sqrtR) / denom;\n    return [\n        root1,\n        root2\n    ];\n};\nvar solveCubic = function solveCubic(a, b, c, d, result) {\n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n    var epsilon = 0.00001;\n    // avoid division by zero while keeping the overall expression close in value\n    if (a === 0) {\n        a = epsilon;\n    }\n    b /= a;\n    c /= a;\n    d /= a;\n    var discriminant, q, r, dum1, s, t, term1, r13;\n    q = (3.0 * c - b * b) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = b / 3.0;\n    if (discriminant > 0) {\n        s = r + Math.sqrt(discriminant);\n        s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n        t = r - Math.sqrt(discriminant);\n        t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n        result[0] = -term1 + s + t;\n        term1 += (s + t) / 2.0;\n        result[4] = result[2] = -term1;\n        term1 = Math.sqrt(3.0) * (-t + s) / 2;\n        result[3] = term1;\n        result[5] = -term1;\n        return;\n    }\n    result[5] = result[3] = 0;\n    if (discriminant === 0) {\n        r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n        result[0] = -term1 + 2.0 * r13;\n        result[4] = result[2] = -(r13 + term1);\n        return;\n    }\n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    return;\n};\nvar sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n    // Find minimum distance by using the minimum of the distance\n    // function between the given point and the curve\n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n    var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n    var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n    var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n    // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n    var roots = [];\n    // Use the cubic solving algorithm\n    solveCubic(a, b, c, d, roots);\n    var zeroThreshold = 0.0000001;\n    var params = [];\n    for(var index = 0; index < 6; index += 2){\n        if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n            params.push(roots[index]);\n        }\n    }\n    params.push(1.0);\n    params.push(0.0);\n    var minDistanceSquared = -1;\n    var curX, curY, distSquared;\n    for(var i = 0; i < params.length; i++){\n        curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n        curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n        distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n        // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n        if (minDistanceSquared >= 0) {\n            if (distSquared < minDistanceSquared) {\n                minDistanceSquared = distSquared;\n            }\n        } else {\n            minDistanceSquared = distSquared;\n        }\n    }\n    return minDistanceSquared;\n};\nvar sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n    var offset = [\n        x - x1,\n        y - y1\n    ];\n    var line = [\n        x2 - x1,\n        y2 - y1\n    ];\n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n    if (dotProduct < 0) {\n        return hypSq;\n    }\n    if (adjSq > lineSq) {\n        return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n    return hypSq - adjSq;\n};\nvar pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n    var x1, y1, x2, y2;\n    var y3;\n    // Intersect with vertical line through (x, y)\n    var up = 0;\n    // let down = 0;\n    for(var i = 0; i < points.length / 2; i++){\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        if (i + 1 < points.length / 2) {\n            x2 = points[(i + 1) * 2];\n            y2 = points[(i + 1) * 2 + 1];\n        } else {\n            x2 = points[(i + 1 - points.length / 2) * 2];\n            y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n        }\n        if (x1 == x && x2 == x) ;\n        else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n            if (y3 > y) {\n                up++;\n            }\n        // if( y3 < y ){\n        // down++;\n        // }\n        } else {\n            continue;\n        }\n    }\n    if (up % 2 === 0) {\n        return false;\n    } else {\n        return true;\n    }\n};\nvar pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n    var transformedPoints = new Array(basePoints.length);\n    // Gives negative angle\n    var angle;\n    if (direction[0] != null) {\n        angle = Math.atan(direction[1] / direction[0]);\n        if (direction[0] < 0) {\n            angle = angle + Math.PI / 2;\n        } else {\n            angle = -angle - Math.PI / 2;\n        }\n    } else {\n        angle = direction;\n    }\n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    //    console.log(\"base: \" + basePoints);\n    for(var i = 0; i < transformedPoints.length / 2; i++){\n        transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n        transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n        transformedPoints[i * 2] += centerX;\n        transformedPoints[i * 2 + 1] += centerY;\n    }\n    var points;\n    if (padding > 0) {\n        var expandedLineSet = expandPolygon(transformedPoints, -padding);\n        points = joinLines(expandedLineSet);\n    } else {\n        points = transformedPoints;\n    }\n    return pointInsidePolygonPoints(x, y, points);\n};\nvar pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height, corners) {\n    var cutPolygonPoints = new Array(basePoints.length * 2);\n    for(var i = 0; i < corners.length; i++){\n        var corner = corners[i];\n        cutPolygonPoints[i * 4 + 0] = corner.startX;\n        cutPolygonPoints[i * 4 + 1] = corner.startY;\n        cutPolygonPoints[i * 4 + 2] = corner.stopX;\n        cutPolygonPoints[i * 4 + 3] = corner.stopY;\n        var squaredDistance = Math.pow(corner.cx - x, 2) + Math.pow(corner.cy - y, 2);\n        if (squaredDistance <= Math.pow(corner.radius, 2)) {\n            return true;\n        }\n    }\n    return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n};\nvar joinLines = function joinLines(lineSet) {\n    var vertices = new Array(lineSet.length / 2);\n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n    for(var i = 0; i < lineSet.length / 4; i++){\n        currentLineStartX = lineSet[i * 4];\n        currentLineStartY = lineSet[i * 4 + 1];\n        currentLineEndX = lineSet[i * 4 + 2];\n        currentLineEndY = lineSet[i * 4 + 3];\n        if (i < lineSet.length / 4 - 1) {\n            nextLineStartX = lineSet[(i + 1) * 4];\n            nextLineStartY = lineSet[(i + 1) * 4 + 1];\n            nextLineEndX = lineSet[(i + 1) * 4 + 2];\n            nextLineEndY = lineSet[(i + 1) * 4 + 3];\n        } else {\n            nextLineStartX = lineSet[0];\n            nextLineStartY = lineSet[1];\n            nextLineEndX = lineSet[2];\n            nextLineEndY = lineSet[3];\n        }\n        var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n        vertices[i * 2] = intersection[0];\n        vertices[i * 2 + 1] = intersection[1];\n    }\n    return vertices;\n};\nvar expandPolygon = function expandPolygon(points, pad) {\n    var expandedLineSet = new Array(points.length * 2);\n    var currentPointX, currentPointY, nextPointX, nextPointY;\n    for(var i = 0; i < points.length / 2; i++){\n        currentPointX = points[i * 2];\n        currentPointY = points[i * 2 + 1];\n        if (i < points.length / 2 - 1) {\n            nextPointX = points[(i + 1) * 2];\n            nextPointY = points[(i + 1) * 2 + 1];\n        } else {\n            nextPointX = points[0];\n            nextPointY = points[1];\n        }\n        // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n        // Assume CCW polygon winding\n        var offsetX = nextPointY - currentPointY;\n        var offsetY = -(nextPointX - currentPointX);\n        // Normalize\n        var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n        var normalizedOffsetX = offsetX / offsetLength;\n        var normalizedOffsetY = offsetY / offsetLength;\n        expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n        expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n        expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n        expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n    return expandedLineSet;\n};\nvar intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    var newLength = len - 1;\n    if (newLength < 0) {\n        return [];\n    }\n    var lenProportion = newLength / len;\n    return [\n        (centerX - x) * lenProportion + x,\n        (centerY - y) * lenProportion + y\n    ];\n};\nvar checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n    x -= centerX;\n    y -= centerY;\n    x /= width / 2 + padding;\n    y /= height / 2 + padding;\n    return x * x + y * y <= 1;\n};\n// Returns intersections of increasing distance from line's start point\nvar intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n    // Calculate d, direction vector of line\n    var d = [\n        x2 - x1,\n        y2 - y1\n    ]; // Direction vector of line\n    var f = [\n        x1 - centerX,\n        y1 - centerY\n    ];\n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n    var discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return [];\n    }\n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n    if (tMin >= 0 && tMin <= 1) {\n        inRangeParams.push(tMin);\n    }\n    if (tMax >= 0 && tMax <= 1) {\n        inRangeParams.push(tMax);\n    }\n    if (inRangeParams.length === 0) {\n        return [];\n    }\n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n    if (inRangeParams.length > 1) {\n        if (inRangeParams[0] == inRangeParams[1]) {\n            return [\n                nearIntersectionX,\n                nearIntersectionY\n            ];\n        } else {\n            var farIntersectionX = inRangeParams[1] * d[0] + x1;\n            var farIntersectionY = inRangeParams[1] * d[1] + y1;\n            return [\n                nearIntersectionX,\n                nearIntersectionY,\n                farIntersectionX,\n                farIntersectionY\n            ];\n        }\n    } else {\n        return [\n            nearIntersectionX,\n            nearIntersectionY\n        ];\n    }\n};\nvar midOfThree = function midOfThree(a, b, c) {\n    if (b <= a && a <= c || c <= a && a <= b) {\n        return a;\n    } else if (a <= b && b <= c || c <= b && b <= a) {\n        return b;\n    } else {\n        return c;\n    }\n};\n// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\nvar finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    var dx13 = x1 - x3;\n    var dx21 = x2 - x1;\n    var dx43 = x4 - x3;\n    var dy13 = y1 - y3;\n    var dy21 = y2 - y1;\n    var dy43 = y4 - y3;\n    var ua_t = dx43 * dy13 - dy43 * dx13;\n    var ub_t = dx21 * dy13 - dy21 * dx13;\n    var u_b = dy43 * dx21 - dx43 * dy21;\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        var flptThreshold = 0.001;\n        var _min = 0 - flptThreshold;\n        var _max = 1 + flptThreshold;\n        if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n            return [\n                x1 + ua * dx21,\n                y1 + ua * dy21\n            ];\n        } else {\n            if (!infiniteLines) {\n                return [];\n            } else {\n                return [\n                    x1 + ua * dx21,\n                    y1 + ua * dy21\n                ];\n            }\n        }\n    } else {\n        if (ua_t === 0 || ub_t === 0) {\n            // Parallel, coincident lines. Check if overlap\n            // Check endpoint of second line\n            if (midOfThree(x1, x2, x4) === x4) {\n                return [\n                    x4,\n                    y4\n                ];\n            }\n            // Check start point of second line\n            if (midOfThree(x1, x2, x3) === x3) {\n                return [\n                    x3,\n                    y3\n                ];\n            }\n            // Endpoint of first line\n            if (midOfThree(x3, x4, x2) === x2) {\n                return [\n                    x2,\n                    y2\n                ];\n            }\n            return [];\n        } else {\n            // Parallel, non-coincident\n            return [];\n        }\n    }\n};\nvar transformPoints = function transformPoints(points, centerX, centerY, width, height) {\n    var ret = [];\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var x = centerX;\n    var y = centerY;\n    ret.push({\n        x: x + halfW * points[0],\n        y: y + halfH * points[1]\n    });\n    for(var i = 1; i < points.length / 2; i++){\n        ret.push({\n            x: x + halfW * points[i * 2],\n            y: y + halfH * points[i * 2 + 1]\n        });\n    }\n    return ret;\n};\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n// intersect a node polygon (pts transformed)\n//\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n// intersect the points (no transform)\nvar polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var transformedPoints = new Array(basePoints.length);\n    var doTransform = true;\n    if (width == null) {\n        doTransform = false;\n    }\n    var points;\n    if (doTransform) {\n        for(var i = 0; i < transformedPoints.length / 2; i++){\n            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n        }\n        if (padding > 0) {\n            var expandedLineSet = expandPolygon(transformedPoints, -padding);\n            points = joinLines(expandedLineSet);\n        } else {\n            points = transformedPoints;\n        }\n    } else {\n        points = basePoints;\n    }\n    var currentX, currentY, nextX, nextY;\n    for(var _i3 = 0; _i3 < points.length / 2; _i3++){\n        currentX = points[_i3 * 2];\n        currentY = points[_i3 * 2 + 1];\n        if (_i3 < points.length / 2 - 1) {\n            nextX = points[(_i3 + 1) * 2];\n            nextY = points[(_i3 + 1) * 2 + 1];\n        } else {\n            nextX = points[0];\n            nextY = points[1];\n        }\n        intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    }\n    return intersections;\n};\nvar roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding, corners) {\n    var intersections = [];\n    var intersection;\n    var lines = new Array(basePoints.length * 2);\n    corners.forEach(function(corner, i) {\n        if (i === 0) {\n            lines[lines.length - 2] = corner.startX;\n            lines[lines.length - 1] = corner.startY;\n        } else {\n            lines[i * 4 - 2] = corner.startX;\n            lines[i * 4 - 1] = corner.startY;\n        }\n        lines[i * 4] = corner.stopX;\n        lines[i * 4 + 1] = corner.stopY;\n        intersection = intersectLineCircle(x, y, centerX, centerY, corner.cx, corner.cy, corner.radius);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    });\n    for(var i = 0; i < lines.length / 4; i++){\n        intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[i * 4], lines[i * 4 + 1], lines[i * 4 + 2], lines[i * 4 + 3], false);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    }\n    if (intersections.length > 2) {\n        var lowestIntersection = [\n            intersections[0],\n            intersections[1]\n        ];\n        var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n        for(var _i4 = 1; _i4 < intersections.length / 2; _i4++){\n            var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n            if (squaredDistance <= lowestSquaredDistance) {\n                lowestIntersection[0] = intersections[_i4 * 2];\n                lowestIntersection[1] = intersections[_i4 * 2 + 1];\n                lowestSquaredDistance = squaredDistance;\n            }\n        }\n        return lowestIntersection;\n    }\n    return intersections;\n};\nvar shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n    var disp = [\n        intersection[0] - offset[0],\n        intersection[1] - offset[1]\n    ];\n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    var lenRatio = (length - amount) / length;\n    if (lenRatio < 0) {\n        lenRatio = 0.00001;\n    }\n    return [\n        offset[0] + lenRatio * disp[0],\n        offset[1] + lenRatio * disp[1]\n    ];\n};\nvar generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n    var points = generateUnitNgonPoints(sides, rotationRadians);\n    points = fitPolygonToSquare(points);\n    return points;\n};\nvar fitPolygonToSquare = function fitPolygonToSquare(points) {\n    var x, y;\n    var sides = points.length / 2;\n    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for(var i = 0; i < sides; i++){\n        x = points[2 * i];\n        y = points[2 * i + 1];\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n    // stretch factors\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n    for(var _i5 = 0; _i5 < sides; _i5++){\n        x = points[2 * _i5] = points[2 * _i5] * sx;\n        y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n    if (minY < -1) {\n        for(var _i6 = 0; _i6 < sides; _i6++){\n            y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n        }\n    }\n    return points;\n};\nvar generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n    startAngle += rotationRadians;\n    var points = new Array(sides * 2);\n    var currentAngle;\n    for(var i = 0; i < sides; i++){\n        currentAngle = i * increment + startAngle;\n        points[2 * i] = Math.cos(currentAngle); // x\n        points[2 * i + 1] = Math.sin(-currentAngle); // y\n    }\n    return points;\n};\n// Set the default radius, unless half of width or height is smaller than default\nvar getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n    return Math.min(width / 4, height / 4, 8);\n};\n// Set the default radius\nvar getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n    return Math.min(width / 10, height / 10, 8);\n};\nvar getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n    return 8;\n};\nvar bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n    return [\n        p0 - 2 * p1 + p2,\n        2 * (p1 - p0),\n        p0\n    ];\n};\n// get curve width, height, and control point position offsets as a percentage of node height / width\nvar getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n    return {\n        heightOffset: Math.min(15, 0.05 * height),\n        widthOffset: Math.min(100, 0.25 * width),\n        ctrlPtOffsetPct: 0.05\n    };\n};\n// Separating Axis Theorem (SAT) to determine if two polygons intersect. \n// The function takes two polygons as input and returns a boolean value indicating \n// whether the two polygons intersect.\nfunction satPolygonIntersection(poly1, poly2) {\n    function getAxes(polygon) {\n        var axes = [];\n        for(var i = 0; i < polygon.length; i++){\n            var p1 = polygon[i];\n            var p2 = polygon[(i + 1) % polygon.length];\n            var edge = {\n                x: p2.x - p1.x,\n                y: p2.y - p1.y\n            };\n            var normal = {\n                x: -edge.y,\n                y: edge.x\n            };\n            var length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);\n            axes.push({\n                x: normal.x / length,\n                y: normal.y / length\n            });\n        }\n        return axes;\n    }\n    function project(polygon, axis) {\n        var min = Infinity;\n        var max = -Infinity;\n        var _iterator = _createForOfIteratorHelper(polygon), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var point = _step.value;\n                var projection = point.x * axis.x + point.y * axis.y;\n                min = Math.min(min, projection);\n                max = Math.max(max, projection);\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return {\n            min: min,\n            max: max\n        };\n    }\n    function overlaps(proj1, proj2) {\n        return !(proj1.max < proj2.min || proj2.max < proj1.min);\n    }\n    var axes = [].concat(_toConsumableArray(getAxes(poly1)), _toConsumableArray(getAxes(poly2)));\n    var _iterator2 = _createForOfIteratorHelper(axes), _step2;\n    try {\n        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n            var axis = _step2.value;\n            var proj1 = project(poly1, axis);\n            var proj2 = project(poly2, axis);\n            if (!overlaps(proj1, proj2)) {\n                return false; // No overlap, so the polygons do not intersect\n            }\n        }\n    } catch (err) {\n        _iterator2.e(err);\n    } finally{\n        _iterator2.f();\n    }\n    return true; // polygons intersect\n}\nvar pageRankDefaults = defaults$g({\n    dampingFactor: 0.8,\n    precision: 0.000001,\n    iterations: 200,\n    weight: function weight(edge) {\n        return 1;\n    }\n});\nvar elesfn$o = {\n    pageRank: function pageRank(options) {\n        var _pageRankDefaults = pageRankDefaults(options), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight = _pageRankDefaults.weight;\n        var cy = this._private.cy;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var numNodes = nodes.length;\n        var numNodesSqd = numNodes * numNodes;\n        var numEdges = edges.length;\n        // Construct transposed adjacency matrix\n        // First lets have a zeroed matrix of the right size\n        // We'll also keep track of the sum of each column\n        var matrix = new Array(numNodesSqd);\n        var columnSum = new Array(numNodes);\n        var additionalProb = (1 - dampingFactor) / numNodes;\n        // Create null matrix\n        for(var i = 0; i < numNodes; i++){\n            for(var j = 0; j < numNodes; j++){\n                var n = i * numNodes + j;\n                matrix[n] = 0;\n            }\n            columnSum[i] = 0;\n        }\n        // Now, process edges\n        for(var _i = 0; _i < numEdges; _i++){\n            var edge = edges[_i];\n            var srcId = edge.data(\"source\");\n            var tgtId = edge.data(\"target\");\n            // Don't include loops in the matrix\n            if (srcId === tgtId) {\n                continue;\n            }\n            var s = nodes.indexOfId(srcId);\n            var t = nodes.indexOfId(tgtId);\n            var w = weight(edge);\n            var _n = t * numNodes + s;\n            // Update matrix\n            matrix[_n] += w;\n            // Update column sum\n            columnSum[s] += w;\n        }\n        // Add additional probability based on damping factor\n        // Also, take into account columns that have sum = 0\n        var p = 1.0 / numNodes + additionalProb; // Shorthand\n        // Traverse matrix, column by column\n        for(var _j = 0; _j < numNodes; _j++){\n            if (columnSum[_j] === 0) {\n                // No 'links' out from node jth, assume equal probability for each possible node\n                for(var _i2 = 0; _i2 < numNodes; _i2++){\n                    var _n2 = _i2 * numNodes + _j;\n                    matrix[_n2] = p;\n                }\n            } else {\n                // Node jth has outgoing link, compute normalized probabilities\n                for(var _i3 = 0; _i3 < numNodes; _i3++){\n                    var _n3 = _i3 * numNodes + _j;\n                    matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n                }\n            }\n        }\n        // Compute dominant eigenvector using power method\n        var eigenvector = new Array(numNodes);\n        var temp = new Array(numNodes);\n        var previous;\n        // Start with a vector of all 1's\n        // Also, initialize a null vector which will be used as shorthand\n        for(var _i4 = 0; _i4 < numNodes; _i4++){\n            eigenvector[_i4] = 1;\n        }\n        for(var iter = 0; iter < iterations; iter++){\n            // Temp array with all 0's\n            for(var _i5 = 0; _i5 < numNodes; _i5++){\n                temp[_i5] = 0;\n            }\n            // Multiply matrix with previous result\n            for(var _i6 = 0; _i6 < numNodes; _i6++){\n                for(var _j2 = 0; _j2 < numNodes; _j2++){\n                    var _n4 = _i6 * numNodes + _j2;\n                    temp[_i6] += matrix[_n4] * eigenvector[_j2];\n                }\n            }\n            inPlaceSumNormalize(temp);\n            previous = eigenvector;\n            eigenvector = temp;\n            temp = previous;\n            var diff = 0;\n            // Compute difference (squared module) of both vectors\n            for(var _i7 = 0; _i7 < numNodes; _i7++){\n                var delta = previous[_i7] - eigenvector[_i7];\n                diff += delta * delta;\n            }\n            // If difference is less than the desired threshold, stop iterating\n            if (diff < precision) {\n                break;\n            }\n        }\n        // Construct result\n        var res = {\n            rank: function rank(node) {\n                node = cy.collection(node)[0];\n                return eigenvector[nodes.indexOf(node)];\n            }\n        };\n        return res;\n    } // pageRank\n}; // elesfn\nvar defaults$f = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false,\n    alpha: 0\n});\nvar elesfn$n = {\n    degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n        options = defaults$f(options);\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var numNodes = nodes.length;\n        if (!options.directed) {\n            var degrees = {};\n            var maxDegree = 0;\n            for(var i = 0; i < numNodes; i++){\n                var node = nodes[i];\n                // add current node to the current options object and call degreeCentrality\n                options.root = node;\n                var currDegree = this.degreeCentrality(options);\n                if (maxDegree < currDegree.degree) {\n                    maxDegree = currDegree.degree;\n                }\n                degrees[node.id()] = currDegree.degree;\n            }\n            return {\n                degree: function degree(node) {\n                    if (maxDegree === 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return degrees[node.id()] / maxDegree;\n                }\n            };\n        } else {\n            var indegrees = {};\n            var outdegrees = {};\n            var maxIndegree = 0;\n            var maxOutdegree = 0;\n            for(var _i = 0; _i < numNodes; _i++){\n                var _node = nodes[_i];\n                var id = _node.id();\n                // add current node to the current options object and call degreeCentrality\n                options.root = _node;\n                var _currDegree = this.degreeCentrality(options);\n                if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n                if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n                indegrees[id] = _currDegree.indegree;\n                outdegrees[id] = _currDegree.outdegree;\n            }\n            return {\n                indegree: function indegree(node) {\n                    if (maxIndegree == 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return indegrees[node.id()] / maxIndegree;\n                },\n                outdegree: function outdegree(node) {\n                    if (maxOutdegree === 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return outdegrees[node.id()] / maxOutdegree;\n                }\n            };\n        }\n    },\n    // degreeCentralityNormalized\n    // Implemented from the algorithm in Opsahl's paper\n    // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n    // check the heading 2 \"Degree\"\n    degreeCentrality: function degreeCentrality(options) {\n        options = defaults$f(options);\n        var cy = this.cy();\n        var callingEles = this;\n        var _options = options, root = _options.root, weight = _options.weight, directed = _options.directed, alpha = _options.alpha;\n        root = cy.collection(root)[0];\n        if (!directed) {\n            var connEdges = root.connectedEdges().intersection(callingEles);\n            var k = connEdges.length;\n            var s = 0;\n            // Now, sum edge weights\n            for(var i = 0; i < connEdges.length; i++){\n                s += weight(connEdges[i]);\n            }\n            return {\n                degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n            };\n        } else {\n            var edges = root.connectedEdges();\n            var incoming = edges.filter(function(edge) {\n                return edge.target().same(root) && callingEles.has(edge);\n            });\n            var outgoing = edges.filter(function(edge) {\n                return edge.source().same(root) && callingEles.has(edge);\n            });\n            var k_in = incoming.length;\n            var k_out = outgoing.length;\n            var s_in = 0;\n            var s_out = 0;\n            // Now, sum incoming edge weights\n            for(var _i2 = 0; _i2 < incoming.length; _i2++){\n                s_in += weight(incoming[_i2]);\n            }\n            // Now, sum outgoing edge weights\n            for(var _i3 = 0; _i3 < outgoing.length; _i3++){\n                s_out += weight(outgoing[_i3]);\n            }\n            return {\n                indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n                outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n            };\n        }\n    } // degreeCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$n.dc = elesfn$n.degreeCentrality;\nelesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\nvar defaults$e = defaults$g({\n    harmonic: true,\n    weight: function weight() {\n        return 1;\n    },\n    directed: false,\n    root: null\n});\nvar elesfn$m = {\n    closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n        var _defaults = defaults$e(options), harmonic = _defaults.harmonic, weight = _defaults.weight, directed = _defaults.directed;\n        var cy = this.cy();\n        var closenesses = {};\n        var maxCloseness = 0;\n        var nodes = this.nodes();\n        var fw = this.floydWarshall({\n            weight: weight,\n            directed: directed\n        });\n        // Compute closeness for every node and find the maximum closeness\n        for(var i = 0; i < nodes.length; i++){\n            var currCloseness = 0;\n            var node_i = nodes[i];\n            for(var j = 0; j < nodes.length; j++){\n                if (i !== j) {\n                    var d = fw.distance(node_i, nodes[j]);\n                    if (harmonic) {\n                        currCloseness += 1 / d;\n                    } else {\n                        currCloseness += d;\n                    }\n                }\n            }\n            if (!harmonic) {\n                currCloseness = 1 / currCloseness;\n            }\n            if (maxCloseness < currCloseness) {\n                maxCloseness = currCloseness;\n            }\n            closenesses[node_i.id()] = currCloseness;\n        }\n        return {\n            closeness: function closeness(node) {\n                if (maxCloseness == 0) {\n                    return 0;\n                }\n                if (string(node)) {\n                    // from is a selector string\n                    node = cy.filter(node)[0].id();\n                } else {\n                    // from is a node\n                    node = node.id();\n                }\n                return closenesses[node] / maxCloseness;\n            }\n        };\n    },\n    // Implemented from pseudocode from wikipedia\n    closenessCentrality: function closenessCentrality(options) {\n        var _defaults2 = defaults$e(options), root = _defaults2.root, weight = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;\n        root = this.filter(root)[0];\n        // we need distance from this node to every other node\n        var dijkstra = this.dijkstra({\n            root: root,\n            weight: weight,\n            directed: directed\n        });\n        var totalDistance = 0;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            var n = nodes[i];\n            if (!n.same(root)) {\n                var d = dijkstra.distanceTo(n);\n                if (harmonic) {\n                    totalDistance += 1 / d;\n                } else {\n                    totalDistance += d;\n                }\n            }\n        }\n        return harmonic ? totalDistance : 1 / totalDistance;\n    } // closenessCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$m.cc = elesfn$m.closenessCentrality;\nelesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\nvar defaults$d = defaults$g({\n    weight: null,\n    directed: false\n});\nvar elesfn$l = {\n    // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n    betweennessCentrality: function betweennessCentrality(options) {\n        var _defaults = defaults$d(options), directed = _defaults.directed, weight = _defaults.weight;\n        var weighted = weight != null;\n        var cy = this.cy();\n        // starting\n        var V = this.nodes();\n        var A = {};\n        var _C = {};\n        var max = 0;\n        var C = {\n            set: function set(key, val) {\n                _C[key] = val;\n                if (val > max) {\n                    max = val;\n                }\n            },\n            get: function get(key) {\n                return _C[key];\n            }\n        };\n        // A contains the neighborhoods of every node\n        for(var i = 0; i < V.length; i++){\n            var v = V[i];\n            var vid = v.id();\n            if (directed) {\n                A[vid] = v.outgoers().nodes(); // get outgoers of every node\n            } else {\n                A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n            }\n            C.set(vid, 0);\n        }\n        var _loop = function _loop() {\n            var sid = V[s].id();\n            var S = []; // stack\n            var P = {};\n            var g = {};\n            var d = {};\n            var Q = new Heap(function(a, b) {\n                return d[a] - d[b];\n            }); // queue\n            // init dictionaries\n            for(var _i = 0; _i < V.length; _i++){\n                var _vid = V[_i].id();\n                P[_vid] = [];\n                g[_vid] = 0;\n                d[_vid] = Infinity;\n            }\n            g[sid] = 1; // sigma\n            d[sid] = 0; // distance to s\n            Q.push(sid);\n            while(!Q.empty()){\n                var _v = Q.pop();\n                S.push(_v);\n                if (weighted) {\n                    for(var j = 0; j < A[_v].length; j++){\n                        var w = A[_v][j];\n                        var vEle = cy.getElementById(_v);\n                        var edge = undefined;\n                        if (vEle.edgesTo(w).length > 0) {\n                            edge = vEle.edgesTo(w)[0];\n                        } else {\n                            edge = w.edgesTo(vEle)[0];\n                        }\n                        var edgeWeight = weight(edge);\n                        w = w.id();\n                        if (d[w] > d[_v] + edgeWeight) {\n                            d[w] = d[_v] + edgeWeight;\n                            if (Q.nodes.indexOf(w) < 0) {\n                                //if w is not in Q\n                                Q.push(w);\n                            } else {\n                                // update position if w is in Q\n                                Q.updateItem(w);\n                            }\n                            g[w] = 0;\n                            P[w] = [];\n                        }\n                        if (d[w] == d[_v] + edgeWeight) {\n                            g[w] = g[w] + g[_v];\n                            P[w].push(_v);\n                        }\n                    }\n                } else {\n                    for(var _j = 0; _j < A[_v].length; _j++){\n                        var _w = A[_v][_j].id();\n                        if (d[_w] == Infinity) {\n                            Q.push(_w);\n                            d[_w] = d[_v] + 1;\n                        }\n                        if (d[_w] == d[_v] + 1) {\n                            g[_w] = g[_w] + g[_v];\n                            P[_w].push(_v);\n                        }\n                    }\n                }\n            }\n            var e = {};\n            for(var _i2 = 0; _i2 < V.length; _i2++){\n                e[V[_i2].id()] = 0;\n            }\n            while(S.length > 0){\n                var _w2 = S.pop();\n                for(var _j2 = 0; _j2 < P[_w2].length; _j2++){\n                    var _v2 = P[_w2][_j2];\n                    e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n                }\n                if (_w2 != V[s].id()) {\n                    C.set(_w2, C.get(_w2) + e[_w2]);\n                }\n            }\n        };\n        for(var s = 0; s < V.length; s++){\n            _loop();\n        }\n        var ret = {\n            betweenness: function betweenness(node) {\n                var id = cy.collection(node).id();\n                return C.get(id);\n            },\n            betweennessNormalized: function betweennessNormalized(node) {\n                if (max == 0) {\n                    return 0;\n                }\n                var id = cy.collection(node).id();\n                return C.get(id) / max;\n            }\n        };\n        // alias\n        ret.betweennessNormalised = ret.betweennessNormalized;\n        return ret;\n    } // betweennessCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$l.bc = elesfn$l.betweennessCentrality;\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-markov-cluster\n/* eslint-disable no-unused-vars */ var defaults$c = defaults$g({\n    expandFactor: 2,\n    // affects time of computation and cluster granularity to some extent: M * M\n    inflateFactor: 2,\n    // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n    multFactor: 1,\n    // optional self loops for each node. Use a neutral value to improve cluster computations.\n    maxIterations: 20,\n    // maximum number of iterations of the MCL algorithm in a single run\n    attributes: [\n        // attributes/features used to group nodes, ie. similarity values between nodes\n        function(edge) {\n            return 1;\n        }\n    ]\n});\n/* eslint-enable */ var setOptions$3 = function setOptions(options) {\n    return defaults$c(options);\n};\n/* eslint-enable */ var getSimilarity$1 = function getSimilarity(edge, attributes) {\n    var total = 0;\n    for(var i = 0; i < attributes.length; i++){\n        total += attributes[i](edge);\n    }\n    return total;\n};\nvar addLoops = function addLoops(M, n, val) {\n    for(var i = 0; i < n; i++){\n        M[i * n + i] = val;\n    }\n};\nvar normalize = function normalize(M, n) {\n    var sum;\n    for(var col = 0; col < n; col++){\n        sum = 0;\n        for(var row = 0; row < n; row++){\n            sum += M[row * n + col];\n        }\n        for(var _row = 0; _row < n; _row++){\n            M[_row * n + col] = M[_row * n + col] / sum;\n        }\n    }\n};\n// TODO: blocked matrix multiplication?\nvar mmult = function mmult(A, B, n) {\n    var C = new Array(n * n);\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j < n; j++){\n            C[i * n + j] = 0;\n        }\n        for(var k = 0; k < n; k++){\n            for(var _j = 0; _j < n; _j++){\n                C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n            }\n        }\n    }\n    return C;\n};\nvar expand = function expand(M, n, expandFactor /** power **/ ) {\n    var _M = M.slice(0);\n    for(var p = 1; p < expandFactor; p++){\n        M = mmult(M, _M, n);\n    }\n    return M;\n};\nvar inflate = function inflate(M, n, inflateFactor /** r **/ ) {\n    var _M = new Array(n * n);\n    // M(i,j) ^ inflatePower\n    for(var i = 0; i < n * n; i++){\n        _M[i] = Math.pow(M[i], inflateFactor);\n    }\n    normalize(_M, n);\n    return _M;\n};\nvar hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n    // Check that both matrices have the same elements (i,j)\n    for(var i = 0; i < n2; i++){\n        var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n        var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n        if (v1 !== v2) {\n            return false;\n        }\n    }\n    return true;\n};\nvar assign$2 = function assign(M, n, nodes, cy) {\n    var clusters = [];\n    for(var i = 0; i < n; i++){\n        var cluster = [];\n        for(var j = 0; j < n; j++){\n            // Row-wise attractors and elements that they attract belong in same cluster\n            if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n                cluster.push(nodes[j]);\n            }\n        }\n        if (cluster.length !== 0) {\n            clusters.push(cy.collection(cluster));\n        }\n    }\n    return clusters;\n};\nvar isDuplicate = function isDuplicate(c1, c2) {\n    for(var i = 0; i < c1.length; i++){\n        if (!c2[i] || c1[i].id() !== c2[i].id()) {\n            return false;\n        }\n    }\n    return true;\n};\nvar removeDuplicates = function removeDuplicates(clusters) {\n    for(var i = 0; i < clusters.length; i++){\n        for(var j = 0; j < clusters.length; j++){\n            if (i != j && isDuplicate(clusters[i], clusters[j])) {\n                clusters.splice(j, 1);\n            }\n        }\n    }\n    return clusters;\n};\nvar markovClustering = function markovClustering(options) {\n    var nodes = this.nodes();\n    var edges = this.edges();\n    var cy = this.cy();\n    // Set parameters of algorithm:\n    var opts = setOptions$3(options);\n    // Map each node to its position in node array\n    var id2position = {};\n    for(var i = 0; i < nodes.length; i++){\n        id2position[nodes[i].id()] = i;\n    }\n    // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n    var n = nodes.length, n2 = n * n;\n    var M = new Array(n2), _M;\n    for(var _i = 0; _i < n2; _i++){\n        M[_i] = 0;\n    }\n    for(var e = 0; e < edges.length; e++){\n        var edge = edges[e];\n        var _i2 = id2position[edge.source().id()];\n        var j = id2position[edge.target().id()];\n        var sim = getSimilarity$1(edge, opts.attributes);\n        M[_i2 * n + j] += sim; // G should be symmetric and undirected\n        M[j * n + _i2] += sim;\n    }\n    // Begin Markov cluster algorithm\n    // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n    addLoops(M, n, opts.multFactor);\n    // Step 2: M = normalize( M );\n    normalize(M, n);\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        isStillMoving = false;\n        // Step 3:\n        _M = expand(M, n, opts.expandFactor);\n        // Step 4:\n        M = inflate(_M, n, opts.inflateFactor);\n        // Step 5: check to see if ~steady state has been reached\n        if (!hasConverged(M, _M, n2, 4)) {\n            isStillMoving = true;\n        }\n        iterations++;\n    }\n    // Build clusters from matrix\n    var clusters = assign$2(M, n, nodes, cy);\n    // Remove duplicate clusters due to symmetry of graph and M matrix\n    clusters = removeDuplicates(clusters);\n    return clusters;\n};\nvar markovClustering$1 = {\n    markovClustering: markovClustering,\n    mcl: markovClustering\n};\n// Common distance metrics for clustering algorithms\n// https://en.wikipedia.org/wiki/Hierarchical_clustering#Metric\nvar identity$1 = function identity(x) {\n    return x;\n};\nvar absDiff = function absDiff(p, q) {\n    return Math.abs(q - p);\n};\nvar addAbsDiff = function addAbsDiff(total, p, q) {\n    return total + absDiff(p, q);\n};\nvar addSquaredDiff = function addSquaredDiff(total, p, q) {\n    return total + Math.pow(q - p, 2);\n};\nvar sqrt = function sqrt(x) {\n    return Math.sqrt(x);\n};\nvar maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n    return Math.max(currentMax, absDiff(p, q));\n};\nvar getDistance = function getDistance(length, getP, getQ, init, visit) {\n    var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity$1;\n    var ret = init;\n    var p, q;\n    for(var dim = 0; dim < length; dim++){\n        p = getP(dim);\n        q = getQ(dim);\n        ret = visit(ret, p, q);\n    }\n    return post(ret);\n};\nvar distances = {\n    euclidean: function euclidean(length, getP, getQ) {\n        if (length >= 2) {\n            return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n        } else {\n            // for single attr case, more efficient to avoid sqrt\n            return getDistance(length, getP, getQ, 0, addAbsDiff);\n        }\n    },\n    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n        return getDistance(length, getP, getQ, 0, addSquaredDiff);\n    },\n    manhattan: function manhattan(length, getP, getQ) {\n        return getDistance(length, getP, getQ, 0, addAbsDiff);\n    },\n    max: function max(length, getP, getQ) {\n        return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n    }\n};\n// in case the user accidentally doesn't use camel case\ndistances[\"squared-euclidean\"] = distances[\"squaredEuclidean\"];\ndistances[\"squaredeuclidean\"] = distances[\"squaredEuclidean\"];\nfunction clusteringDistance(method, length, getP, getQ, nodeP, nodeQ) {\n    var impl;\n    if (fn$6(method)) {\n        impl = method;\n    } else {\n        impl = distances[method] || distances.euclidean;\n    }\n    if (length === 0 && fn$6(method)) {\n        return impl(nodeP, nodeQ);\n    } else {\n        return impl(length, getP, getQ, nodeP, nodeQ);\n    }\n}\nvar defaults$b = defaults$g({\n    k: 2,\n    m: 2,\n    sensitivityThreshold: 0.0001,\n    distance: \"euclidean\",\n    maxIterations: 10,\n    attributes: [],\n    testMode: false,\n    testCentroids: null\n});\nvar setOptions$2 = function setOptions(options) {\n    return defaults$b(options);\n};\nvar getDist = function getDist(type, node, centroid, attributes, mode) {\n    var noNodeP = mode !== \"kMedoids\";\n    var getP = noNodeP ? function(i) {\n        return centroid[i];\n    } : function(i) {\n        return attributes[i](centroid);\n    };\n    var getQ = function getQ(i) {\n        return attributes[i](node);\n    };\n    var nodeP = centroid;\n    var nodeQ = node;\n    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n};\nvar randomCentroids = function randomCentroids(nodes, k, attributes) {\n    var ndim = attributes.length;\n    var min = new Array(ndim);\n    var max = new Array(ndim);\n    var centroids = new Array(k);\n    var centroid = null;\n    // Find min, max values for each attribute dimension\n    for(var i = 0; i < ndim; i++){\n        min[i] = nodes.min(attributes[i]).value;\n        max[i] = nodes.max(attributes[i]).value;\n    }\n    // Build k centroids, each represented as an n-dim feature vector\n    for(var c = 0; c < k; c++){\n        centroid = [];\n        for(var _i = 0; _i < ndim; _i++){\n            centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n        }\n        centroids[c] = centroid;\n    }\n    return centroids;\n};\nvar classify = function classify(node, centroids, distance, attributes, type) {\n    var min = Infinity;\n    var index = 0;\n    for(var i = 0; i < centroids.length; i++){\n        var dist = getDist(distance, node, centroids[i], attributes, type);\n        if (dist < min) {\n            min = dist;\n            index = i;\n        }\n    }\n    return index;\n};\nvar buildCluster = function buildCluster(centroid, nodes, assignment) {\n    var cluster = [];\n    var node = null;\n    for(var n = 0; n < nodes.length; n++){\n        node = nodes[n];\n        if (assignment[node.id()] === centroid) {\n            //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n            cluster.push(node);\n        }\n    }\n    return cluster;\n};\nvar haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n    return Math.abs(v2 - v1) <= sensitivityThreshold;\n};\nvar haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n    for(var i = 0; i < v1.length; i++){\n        for(var j = 0; j < v1[i].length; j++){\n            var diff = Math.abs(v1[i][j] - v2[i][j]);\n            if (diff > sensitivityThreshold) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nvar seenBefore = function seenBefore(node, medoids, n) {\n    for(var i = 0; i < n; i++){\n        if (node === medoids[i]) return true;\n    }\n    return false;\n};\nvar randomMedoids = function randomMedoids(nodes, k) {\n    var medoids = new Array(k);\n    // For small data sets, the probability of medoid conflict is greater,\n    // so we need to check to see if we've already seen or chose this node before.\n    if (nodes.length < 50) {\n        // Randomly select k medoids from the n nodes\n        for(var i = 0; i < k; i++){\n            var node = nodes[Math.floor(Math.random() * nodes.length)];\n            // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n            // Instead choose a different random node.\n            while(seenBefore(node, medoids, i)){\n                node = nodes[Math.floor(Math.random() * nodes.length)];\n            }\n            medoids[i] = node;\n        }\n    } else {\n        // Relatively large data set, so pretty safe to not check and just select random nodes\n        for(var _i2 = 0; _i2 < k; _i2++){\n            medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n        }\n    }\n    return medoids;\n};\nvar findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n    var cost = 0;\n    for(var n = 0; n < cluster.length; n++){\n        cost += getDist(\"manhattan\", cluster[n], potentialNewMedoid, attributes, \"kMedoids\");\n    }\n    return cost;\n};\nvar kMeans = function kMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    // Set parameters of algorithm: # of clusters, distance metric, etc.\n    var opts = setOptions$2(options);\n    // Begin k-means algorithm\n    var clusters = new Array(opts.k);\n    var assignment = {};\n    var centroids;\n    // Step 1: Initialize centroid positions\n    if (opts.testMode) {\n        if (typeof opts.testCentroids === \"number\") {\n            // TODO: implement a seeded random number generator.\n            opts.testCentroids;\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        } else if (_typeof(opts.testCentroids) === \"object\") {\n            centroids = opts.testCentroids;\n        } else {\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        }\n    } else {\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        // Step 2: Assign nodes to the nearest centroid\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            // Determine which cluster this node belongs to: node id => cluster #\n            assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, \"kMeans\");\n        }\n        // Step 3: For each of the k clusters, update its centroid\n        isStillMoving = false;\n        for(var c = 0; c < opts.k; c++){\n            // Get all nodes that belong to this cluster\n            var cluster = buildCluster(c, nodes, assignment);\n            if (cluster.length === 0) {\n                continue;\n            }\n            // Update centroids by calculating avg of all nodes within the cluster.\n            var ndim = opts.attributes.length;\n            var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n            var newCentroid = new Array(ndim);\n            var sum = new Array(ndim);\n            for(var d = 0; d < ndim; d++){\n                sum[d] = 0.0;\n                for(var i = 0; i < cluster.length; i++){\n                    node = cluster[i];\n                    sum[d] += opts.attributes[d](node);\n                }\n                newCentroid[d] = sum[d] / cluster.length;\n                // Check to see if algorithm has converged, i.e. when centroids no longer change\n                if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n                    isStillMoving = true;\n                }\n            }\n            centroids[c] = newCentroid;\n            clusters[c] = cy.collection(cluster);\n        }\n        iterations++;\n    }\n    return clusters;\n};\nvar kMedoids = function kMedoids(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    var opts = setOptions$2(options);\n    // Begin k-medoids algorithm\n    var clusters = new Array(opts.k);\n    var medoids;\n    var assignment = {};\n    var curCost;\n    var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n    // Step 1: Initialize k medoids\n    if (opts.testMode) {\n        if (typeof opts.testCentroids === \"number\") ;\n        else if (_typeof(opts.testCentroids) === \"object\") {\n            medoids = opts.testCentroids;\n        } else {\n            medoids = randomMedoids(nodes, opts.k);\n        }\n    } else {\n        medoids = randomMedoids(nodes, opts.k);\n    }\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        // Step 2: Assign nodes to the nearest medoid\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            // Determine which cluster this node belongs to: node id => cluster #\n            assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, \"kMedoids\");\n        }\n        isStillMoving = false;\n        // Step 3: For each medoid m, and for each node associated with mediod m,\n        // select the node with the lowest configuration cost as new medoid.\n        for(var m1 = 0; m1 < medoids.length; m1++){\n            // Get all nodes that belong to this medoid\n            var cluster = buildCluster(m1, nodes, assignment);\n            if (cluster.length === 0) {\n                continue;\n            }\n            minCosts[m1] = findCost(medoids[m1], cluster, opts.attributes); // original cost\n            // Select different medoid if its configuration has the lowest cost\n            for(var _n = 0; _n < cluster.length; _n++){\n                curCost = findCost(cluster[_n], cluster, opts.attributes);\n                if (curCost < minCosts[m1]) {\n                    minCosts[m1] = curCost;\n                    medoids[m1] = cluster[_n];\n                    isStillMoving = true;\n                }\n            }\n            clusters[m1] = cy.collection(cluster);\n        }\n        iterations++;\n    }\n    return clusters;\n};\nvar updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n    var numerator, denominator;\n    for(var n = 0; n < nodes.length; n++){\n        for(var c = 0; c < centroids.length; c++){\n            weight[n][c] = Math.pow(U[n][c], opts.m);\n        }\n    }\n    for(var _c = 0; _c < centroids.length; _c++){\n        for(var dim = 0; dim < opts.attributes.length; dim++){\n            numerator = 0;\n            denominator = 0;\n            for(var _n2 = 0; _n2 < nodes.length; _n2++){\n                numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n                denominator += weight[_n2][_c];\n            }\n            centroids[_c][dim] = numerator / denominator;\n        }\n    }\n};\nvar updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n    // Save previous step\n    for(var i = 0; i < U.length; i++){\n        _U[i] = U[i].slice();\n    }\n    var sum, numerator, denominator;\n    var pow = 2 / (opts.m - 1);\n    for(var c = 0; c < centroids.length; c++){\n        for(var n = 0; n < nodes.length; n++){\n            sum = 0;\n            for(var k = 0; k < centroids.length; k++){\n                // against all other centroids\n                numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, \"cmeans\");\n                denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, \"cmeans\");\n                sum += Math.pow(numerator / denominator, pow);\n            }\n            U[n][c] = 1 / sum;\n        }\n    }\n};\nvar assign$1 = function assign(nodes, U, opts, cy) {\n    var clusters = new Array(opts.k);\n    for(var c = 0; c < clusters.length; c++){\n        clusters[c] = [];\n    }\n    var max;\n    var index;\n    for(var n = 0; n < U.length; n++){\n        // for each node (U is N x C matrix)\n        max = -Infinity;\n        index = -1;\n        // Determine which cluster the node is most likely to belong in\n        for(var _c2 = 0; _c2 < U[0].length; _c2++){\n            if (U[n][_c2] > max) {\n                max = U[n][_c2];\n                index = _c2;\n            }\n        }\n        clusters[index].push(nodes[n]);\n    }\n    // Turn every array into a collection of nodes\n    for(var _c3 = 0; _c3 < clusters.length; _c3++){\n        clusters[_c3] = cy.collection(clusters[_c3]);\n    }\n    return clusters;\n};\nvar fuzzyCMeans = function fuzzyCMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions$2(options);\n    // Begin fuzzy c-means algorithm\n    var clusters;\n    var centroids;\n    var U;\n    var _U;\n    var weight;\n    // Step 1: Initialize letiables.\n    _U = new Array(nodes.length);\n    for(var i = 0; i < nodes.length; i++){\n        // N x C matrix\n        _U[i] = new Array(opts.k);\n    }\n    U = new Array(nodes.length);\n    for(var _i3 = 0; _i3 < nodes.length; _i3++){\n        // N x C matrix\n        U[_i3] = new Array(opts.k);\n    }\n    for(var _i4 = 0; _i4 < nodes.length; _i4++){\n        var total = 0;\n        for(var j = 0; j < opts.k; j++){\n            U[_i4][j] = Math.random();\n            total += U[_i4][j];\n        }\n        for(var _j = 0; _j < opts.k; _j++){\n            U[_i4][_j] = U[_i4][_j] / total;\n        }\n    }\n    centroids = new Array(opts.k);\n    for(var _i5 = 0; _i5 < opts.k; _i5++){\n        centroids[_i5] = new Array(opts.attributes.length);\n    }\n    weight = new Array(nodes.length);\n    for(var _i6 = 0; _i6 < nodes.length; _i6++){\n        // N x C matrix\n        weight[_i6] = new Array(opts.k);\n    }\n    // end init FCM\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        isStillMoving = false;\n        // Step 2: Calculate the centroids for each step.\n        updateCentroids(centroids, nodes, U, weight, opts);\n        // Step 3: Update the partition matrix U.\n        updateMembership(U, _U, centroids, nodes, opts);\n        // Step 4: Check for convergence.\n        if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n            isStillMoving = true;\n        }\n        iterations++;\n    }\n    // Assign nodes to clusters with highest probability.\n    clusters = assign$1(nodes, U, opts, cy);\n    return {\n        clusters: clusters,\n        degreeOfMembership: U\n    };\n};\nvar kClustering = {\n    kMeans: kMeans,\n    kMedoids: kMedoids,\n    fuzzyCMeans: fuzzyCMeans,\n    fcm: fuzzyCMeans\n};\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-hierarchical\nvar defaults$a = defaults$g({\n    distance: \"euclidean\",\n    // distance metric to compare nodes\n    linkage: \"min\",\n    // linkage criterion : how to determine the distance between clusters of nodes\n    mode: \"threshold\",\n    // mode:'threshold' => clusters must be threshold distance apart\n    threshold: Infinity,\n    // the distance threshold\n    // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n    addDendrogram: false,\n    // whether to add the dendrogram to the graph for viz\n    dendrogramDepth: 0,\n    // depth at which dendrogram branches are merged into the returned clusters\n    attributes: [] // array of attr functions\n});\nvar linkageAliases = {\n    \"single\": \"min\",\n    \"complete\": \"max\"\n};\nvar setOptions$1 = function setOptions(options) {\n    var opts = defaults$a(options);\n    var preferredAlias = linkageAliases[opts.linkage];\n    if (preferredAlias != null) {\n        opts.linkage = preferredAlias;\n    }\n    return opts;\n};\nvar mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n    // Find two closest clusters from cached mins\n    var minKey = 0;\n    var min = Infinity;\n    var dist;\n    var attrs = opts.attributes;\n    var getDist = function getDist(n1, n2) {\n        return clusteringDistance(opts.distance, attrs.length, function(i) {\n            return attrs[i](n1);\n        }, function(i) {\n            return attrs[i](n2);\n        }, n1, n2);\n    };\n    for(var i = 0; i < clusters.length; i++){\n        var key = clusters[i].key;\n        var _dist = dists[key][mins[key]];\n        if (_dist < min) {\n            minKey = key;\n            min = _dist;\n        }\n    }\n    if (opts.mode === \"threshold\" && min >= opts.threshold || opts.mode === \"dendrogram\" && clusters.length === 1) {\n        return false;\n    }\n    var c1 = index[minKey];\n    var c2 = index[mins[minKey]];\n    var merged;\n    // Merge two closest clusters\n    if (opts.mode === \"dendrogram\") {\n        merged = {\n            left: c1,\n            right: c2,\n            key: c1.key\n        };\n    } else {\n        merged = {\n            value: c1.value.concat(c2.value),\n            key: c1.key\n        };\n    }\n    clusters[c1.index] = merged;\n    clusters.splice(c2.index, 1);\n    index[c1.key] = merged;\n    // Update distances with new merged cluster\n    for(var _i = 0; _i < clusters.length; _i++){\n        var cur = clusters[_i];\n        if (c1.key === cur.key) {\n            dist = Infinity;\n        } else if (opts.linkage === \"min\") {\n            dist = dists[c1.key][cur.key];\n            if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n                dist = dists[c2.key][cur.key];\n            }\n        } else if (opts.linkage === \"max\") {\n            dist = dists[c1.key][cur.key];\n            if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n                dist = dists[c2.key][cur.key];\n            }\n        } else if (opts.linkage === \"mean\") {\n            dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n        } else {\n            if (opts.mode === \"dendrogram\") dist = getDist(cur.value, c1.value);\n            else dist = getDist(cur.value[0], c1.value[0]);\n        }\n        dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n    }\n    // Update cached mins\n    for(var _i2 = 0; _i2 < clusters.length; _i2++){\n        var key1 = clusters[_i2].key;\n        if (mins[key1] === c1.key || mins[key1] === c2.key) {\n            var _min = key1;\n            for(var j = 0; j < clusters.length; j++){\n                var key2 = clusters[j].key;\n                if (dists[key1][key2] < dists[key1][_min]) {\n                    _min = key2;\n                }\n            }\n            mins[key1] = _min;\n        }\n        clusters[_i2].index = _i2;\n    }\n    // Clean up meta data used for clustering\n    c1.key = c2.key = c1.index = c2.index = null;\n    return true;\n};\nvar _getAllChildren = function getAllChildren(root, arr, cy) {\n    if (!root) return;\n    if (root.value) {\n        arr.push(root.value);\n    } else {\n        if (root.left) _getAllChildren(root.left, arr);\n        if (root.right) _getAllChildren(root.right, arr);\n    }\n};\nvar _buildDendrogram = function buildDendrogram(root, cy) {\n    if (!root) return \"\";\n    if (root.left && root.right) {\n        var leftStr = _buildDendrogram(root.left, cy);\n        var rightStr = _buildDendrogram(root.right, cy);\n        var node = cy.add({\n            group: \"nodes\",\n            data: {\n                id: leftStr + \",\" + rightStr\n            }\n        });\n        cy.add({\n            group: \"edges\",\n            data: {\n                source: leftStr,\n                target: node.id()\n            }\n        });\n        cy.add({\n            group: \"edges\",\n            data: {\n                source: rightStr,\n                target: node.id()\n            }\n        });\n        return node.id();\n    } else if (root.value) {\n        return root.value.id();\n    }\n};\nvar _buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n    if (!root) return [];\n    var left = [], right = [], leaves = [];\n    if (k === 0) {\n        // don't cut tree, simply return all nodes as 1 single cluster\n        if (root.left) _getAllChildren(root.left, left);\n        if (root.right) _getAllChildren(root.right, right);\n        leaves = left.concat(right);\n        return [\n            cy.collection(leaves)\n        ];\n    } else if (k === 1) {\n        // cut at root\n        if (root.value) {\n            // leaf node\n            return [\n                cy.collection(root.value)\n            ];\n        } else {\n            if (root.left) _getAllChildren(root.left, left);\n            if (root.right) _getAllChildren(root.right, right);\n            return [\n                cy.collection(left),\n                cy.collection(right)\n            ];\n        }\n    } else {\n        if (root.value) {\n            return [\n                cy.collection(root.value)\n            ];\n        } else {\n            if (root.left) left = _buildClustersFromTree(root.left, k - 1, cy);\n            if (root.right) right = _buildClustersFromTree(root.right, k - 1, cy);\n            return left.concat(right);\n        }\n    }\n};\nvar hierarchicalClustering = function hierarchicalClustering(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    // Set parameters of algorithm: linkage type, distance metric, etc.\n    var opts = setOptions$1(options);\n    var attrs = opts.attributes;\n    var getDist = function getDist(n1, n2) {\n        return clusteringDistance(opts.distance, attrs.length, function(i) {\n            return attrs[i](n1);\n        }, function(i) {\n            return attrs[i](n2);\n        }, n1, n2);\n    };\n    // Begin hierarchical algorithm\n    var clusters = [];\n    var dists = []; // distances between each pair of clusters\n    var mins = []; // closest cluster for each cluster\n    var index = []; // hash of all clusters by key\n    // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n    for(var n = 0; n < nodes.length; n++){\n        var cluster = {\n            value: opts.mode === \"dendrogram\" ? nodes[n] : [\n                nodes[n]\n            ],\n            key: n,\n            index: n\n        };\n        clusters[n] = cluster;\n        index[n] = cluster;\n        dists[n] = [];\n        mins[n] = 0;\n    }\n    // Calculate the distance between each pair of clusters\n    for(var i = 0; i < clusters.length; i++){\n        for(var j = 0; j <= i; j++){\n            var dist = undefined;\n            if (opts.mode === \"dendrogram\") {\n                // modes store cluster values differently\n                dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n            } else {\n                dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n            }\n            dists[i][j] = dist;\n            dists[j][i] = dist;\n            if (dist < dists[i][mins[i]]) {\n                mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n            }\n        }\n    }\n    // Find the closest pair of clusters and merge them into a single cluster.\n    // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n    var merged = mergeClosest(clusters, index, dists, mins, opts);\n    while(merged){\n        merged = mergeClosest(clusters, index, dists, mins, opts);\n    }\n    var retClusters;\n    // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n    // in addition to returning the clusters.\n    if (opts.mode === \"dendrogram\") {\n        retClusters = _buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n        if (opts.addDendrogram) _buildDendrogram(clusters[0], cy);\n    } else {\n        // Regular mode simply returns the clusters\n        retClusters = new Array(clusters.length);\n        clusters.forEach(function(cluster, i) {\n            // Clean up meta data used for clustering\n            cluster.key = cluster.index = null;\n            retClusters[i] = cy.collection(cluster.value);\n        });\n    }\n    return retClusters;\n};\nvar hierarchicalClustering$1 = {\n    hierarchicalClustering: hierarchicalClustering,\n    hca: hierarchicalClustering\n};\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-affinity-propagation\nvar defaults$9 = defaults$g({\n    distance: \"euclidean\",\n    // distance metric to compare attributes between two nodes\n    preference: \"median\",\n    // suitability of a data point to serve as an exemplar\n    damping: 0.8,\n    // damping factor between [0.5, 1)\n    maxIterations: 1000,\n    // max number of iterations to run\n    minIterations: 100,\n    // min number of iterations to run in order for clustering to stop\n    attributes: []\n});\nvar setOptions = function setOptions(options) {\n    var dmp = options.damping;\n    var pref = options.preference;\n    if (!(0.5 <= dmp && dmp < 1)) {\n        error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n    }\n    var validPrefs = [\n        \"median\",\n        \"mean\",\n        \"min\",\n        \"max\"\n    ];\n    if (!(validPrefs.some(function(v) {\n        return v === pref;\n    }) || number$1(pref))) {\n        error(\"Preference must be one of [\".concat(validPrefs.map(function(p) {\n            return \"'\".concat(p, \"'\");\n        }).join(\", \"), \"] or a number.  Got: \").concat(pref));\n    }\n    return defaults$9(options);\n};\nvar getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n    var attr = function attr(n, i) {\n        return attributes[i](n);\n    };\n    // nb negative because similarity should have an inverse relationship to distance\n    return -clusteringDistance(type, attributes.length, function(i) {\n        return attr(n1, i);\n    }, function(i) {\n        return attr(n2, i);\n    }, n1, n2);\n};\nvar getPreference = function getPreference(S, preference) {\n    // larger preference = greater # of clusters\n    var p = null;\n    if (preference === \"median\") {\n        p = median(S);\n    } else if (preference === \"mean\") {\n        p = mean(S);\n    } else if (preference === \"min\") {\n        p = min(S);\n    } else if (preference === \"max\") {\n        p = max(S);\n    } else {\n        // Custom preference number, as set by user\n        p = preference;\n    }\n    return p;\n};\nvar findExemplars = function findExemplars(n, R, A) {\n    var indices = [];\n    for(var i = 0; i < n; i++){\n        if (R[i * n + i] + A[i * n + i] > 0) {\n            indices.push(i);\n        }\n    }\n    return indices;\n};\nvar assignClusters = function assignClusters(n, S, exemplars) {\n    var clusters = [];\n    for(var i = 0; i < n; i++){\n        var index = -1;\n        var max = -Infinity;\n        for(var ei = 0; ei < exemplars.length; ei++){\n            var e = exemplars[ei];\n            if (S[i * n + e] > max) {\n                index = e;\n                max = S[i * n + e];\n            }\n        }\n        if (index > 0) {\n            clusters.push(index);\n        }\n    }\n    for(var _ei = 0; _ei < exemplars.length; _ei++){\n        clusters[exemplars[_ei]] = exemplars[_ei];\n    }\n    return clusters;\n};\nvar assign = function assign(n, S, exemplars) {\n    var clusters = assignClusters(n, S, exemplars);\n    for(var ei = 0; ei < exemplars.length; ei++){\n        var ii = [];\n        for(var c = 0; c < clusters.length; c++){\n            if (clusters[c] === exemplars[ei]) {\n                ii.push(c);\n            }\n        }\n        var maxI = -1;\n        var maxSum = -Infinity;\n        for(var i = 0; i < ii.length; i++){\n            var sum = 0;\n            for(var j = 0; j < ii.length; j++){\n                sum += S[ii[j] * n + ii[i]];\n            }\n            if (sum > maxSum) {\n                maxI = i;\n                maxSum = sum;\n            }\n        }\n        exemplars[ei] = ii[maxI];\n    }\n    clusters = assignClusters(n, S, exemplars);\n    return clusters;\n};\nvar affinityPropagation = function affinityPropagation(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions(options);\n    // Map each node to its position in node array\n    var id2position = {};\n    for(var i = 0; i < nodes.length; i++){\n        id2position[nodes[i].id()] = i;\n    }\n    // Begin affinity propagation algorithm\n    var n; // number of data points\n    var n2; // size of matrices\n    var S; // similarity matrix (1D array)\n    var p; // preference/suitability of a data point to serve as an exemplar\n    var R; // responsibility matrix (1D array)\n    var A; // availability matrix (1D array)\n    n = nodes.length;\n    n2 = n * n;\n    // Initialize and build S similarity matrix\n    S = new Array(n2);\n    for(var _i = 0; _i < n2; _i++){\n        S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n    }\n    for(var _i2 = 0; _i2 < n; _i2++){\n        for(var j = 0; j < n; j++){\n            if (_i2 !== j) {\n                S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n            }\n        }\n    }\n    // Place preferences on the diagonal of S\n    p = getPreference(S, opts.preference);\n    for(var _i3 = 0; _i3 < n; _i3++){\n        S[_i3 * n + _i3] = p;\n    }\n    // Initialize R responsibility matrix\n    R = new Array(n2);\n    for(var _i4 = 0; _i4 < n2; _i4++){\n        R[_i4] = 0.0;\n    }\n    // Initialize A availability matrix\n    A = new Array(n2);\n    for(var _i5 = 0; _i5 < n2; _i5++){\n        A[_i5] = 0.0;\n    }\n    var old = new Array(n);\n    var Rp = new Array(n);\n    var se = new Array(n);\n    for(var _i6 = 0; _i6 < n; _i6++){\n        old[_i6] = 0.0;\n        Rp[_i6] = 0.0;\n        se[_i6] = 0;\n    }\n    var e = new Array(n * opts.minIterations);\n    for(var _i7 = 0; _i7 < e.length; _i7++){\n        e[_i7] = 0;\n    }\n    var iter;\n    for(iter = 0; iter < opts.maxIterations; iter++){\n        // main algorithmic loop\n        // Update R responsibility matrix\n        for(var _i8 = 0; _i8 < n; _i8++){\n            var max = -Infinity, max2 = -Infinity, maxI = -1, AS = 0.0;\n            for(var _j = 0; _j < n; _j++){\n                old[_j] = R[_i8 * n + _j];\n                AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n                if (AS >= max) {\n                    max2 = max;\n                    max = AS;\n                    maxI = _j;\n                } else if (AS > max2) {\n                    max2 = AS;\n                }\n            }\n            for(var _j2 = 0; _j2 < n; _j2++){\n                R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n            }\n            R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n        }\n        // Update A availability matrix\n        for(var _i9 = 0; _i9 < n; _i9++){\n            var sum = 0;\n            for(var _j3 = 0; _j3 < n; _j3++){\n                old[_j3] = A[_j3 * n + _i9];\n                Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n                sum += Rp[_j3];\n            }\n            sum -= Rp[_i9];\n            Rp[_i9] = R[_i9 * n + _i9];\n            sum += Rp[_i9];\n            for(var _j4 = 0; _j4 < n; _j4++){\n                A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n            }\n            A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n        }\n        // Check for convergence\n        var K = 0;\n        for(var _i10 = 0; _i10 < n; _i10++){\n            var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n            e[iter % opts.minIterations * n + _i10] = E;\n            K += E;\n        }\n        if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n            var _sum = 0;\n            for(var _i11 = 0; _i11 < n; _i11++){\n                se[_i11] = 0;\n                for(var _j5 = 0; _j5 < opts.minIterations; _j5++){\n                    se[_i11] += e[_j5 * n + _i11];\n                }\n                if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n                    _sum++;\n                }\n            }\n            if (_sum === n) {\n                break;\n            }\n        }\n    }\n    // Identify exemplars (cluster centers)\n    var exemplarsIndices = findExemplars(n, R, A);\n    // Assign nodes to clusters\n    var clusterIndices = assign(n, S, exemplarsIndices);\n    var clusters = {};\n    for(var c = 0; c < exemplarsIndices.length; c++){\n        clusters[exemplarsIndices[c]] = [];\n    }\n    for(var _i12 = 0; _i12 < nodes.length; _i12++){\n        var pos = id2position[nodes[_i12].id()];\n        var clusterIndex = clusterIndices[pos];\n        if (clusterIndex != null) {\n            // the node may have not been assigned a cluster if no valid attributes were specified\n            clusters[clusterIndex].push(nodes[_i12]);\n        }\n    }\n    var retClusters = new Array(exemplarsIndices.length);\n    for(var _c = 0; _c < exemplarsIndices.length; _c++){\n        retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n    }\n    return retClusters;\n};\nvar affinityPropagation$1 = {\n    affinityPropagation: affinityPropagation,\n    ap: affinityPropagation\n};\nvar hierholzerDefaults = defaults$g({\n    root: undefined,\n    directed: false\n});\nvar elesfn$k = {\n    hierholzer: function hierholzer(options) {\n        if (!plainObject(options)) {\n            var args = arguments;\n            options = {\n                root: args[0],\n                directed: args[1]\n            };\n        }\n        var _hierholzerDefaults = hierholzerDefaults(options), root = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;\n        var eles = this;\n        var dflag = false;\n        var oddIn;\n        var oddOut;\n        var startVertex;\n        if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n        var nodes = {};\n        var edges = {};\n        if (directed) {\n            eles.forEach(function(ele) {\n                var id = ele.id();\n                if (ele.isNode()) {\n                    var ind = ele.indegree(true);\n                    var outd = ele.outdegree(true);\n                    var d1 = ind - outd;\n                    var d2 = outd - ind;\n                    if (d1 == 1) {\n                        if (oddIn) dflag = true;\n                        else oddIn = id;\n                    } else if (d2 == 1) {\n                        if (oddOut) dflag = true;\n                        else oddOut = id;\n                    } else if (d2 > 1 || d1 > 1) {\n                        dflag = true;\n                    }\n                    nodes[id] = [];\n                    ele.outgoers().forEach(function(e) {\n                        if (e.isEdge()) nodes[id].push(e.id());\n                    });\n                } else {\n                    edges[id] = [\n                        undefined,\n                        ele.target().id()\n                    ];\n                }\n            });\n        } else {\n            eles.forEach(function(ele) {\n                var id = ele.id();\n                if (ele.isNode()) {\n                    var d = ele.degree(true);\n                    if (d % 2) {\n                        if (!oddIn) oddIn = id;\n                        else if (!oddOut) oddOut = id;\n                        else dflag = true;\n                    }\n                    nodes[id] = [];\n                    ele.connectedEdges().forEach(function(e) {\n                        return nodes[id].push(e.id());\n                    });\n                } else {\n                    edges[id] = [\n                        ele.source().id(),\n                        ele.target().id()\n                    ];\n                }\n            });\n        }\n        var result = {\n            found: false,\n            trail: undefined\n        };\n        if (dflag) return result;\n        else if (oddOut && oddIn) {\n            if (directed) {\n                if (startVertex && oddOut != startVertex) {\n                    return result;\n                }\n                startVertex = oddOut;\n            } else {\n                if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n                    return result;\n                } else if (!startVertex) {\n                    startVertex = oddOut;\n                }\n            }\n        } else {\n            if (!startVertex) startVertex = eles[0].id();\n        }\n        var walk = function walk(v) {\n            var currentNode = v;\n            var subtour = [\n                v\n            ];\n            var adj, adjTail, adjHead;\n            while(nodes[currentNode].length){\n                adj = nodes[currentNode].shift();\n                adjTail = edges[adj][0];\n                adjHead = edges[adj][1];\n                if (currentNode != adjHead) {\n                    nodes[adjHead] = nodes[adjHead].filter(function(e) {\n                        return e != adj;\n                    });\n                    currentNode = adjHead;\n                } else if (!directed && currentNode != adjTail) {\n                    nodes[adjTail] = nodes[adjTail].filter(function(e) {\n                        return e != adj;\n                    });\n                    currentNode = adjTail;\n                }\n                subtour.unshift(adj);\n                subtour.unshift(currentNode);\n            }\n            return subtour;\n        };\n        var trail = [];\n        var subtour = [];\n        subtour = walk(startVertex);\n        while(subtour.length != 1){\n            if (nodes[subtour[0]].length == 0) {\n                trail.unshift(eles.getElementById(subtour.shift()));\n                trail.unshift(eles.getElementById(subtour.shift()));\n            } else {\n                subtour = walk(subtour.shift()).concat(subtour);\n            }\n        }\n        trail.unshift(eles.getElementById(subtour.shift())); // final node\n        for(var d in nodes){\n            if (nodes[d].length) {\n                return result;\n            }\n        }\n        result.found = true;\n        result.trail = this.spawn(trail, true);\n        return result;\n    }\n};\nvar hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n    var eles = this;\n    var nodes = {};\n    var id = 0;\n    var edgeCount = 0;\n    var components = [];\n    var stack = [];\n    var visitedEdges = {};\n    var buildComponent = function buildComponent(x, y) {\n        var i = stack.length - 1;\n        var cutset = [];\n        var component = eles.spawn();\n        while(stack[i].x != x || stack[i].y != y){\n            cutset.push(stack.pop().edge);\n            i--;\n        }\n        cutset.push(stack.pop().edge);\n        cutset.forEach(function(edge) {\n            var connectedNodes = edge.connectedNodes().intersection(eles);\n            component.merge(edge);\n            connectedNodes.forEach(function(node) {\n                var nodeId = node.id();\n                var connectedEdges = node.connectedEdges().intersection(eles);\n                component.merge(node);\n                if (!nodes[nodeId].cutVertex) {\n                    component.merge(connectedEdges);\n                } else {\n                    component.merge(connectedEdges.filter(function(edge) {\n                        return edge.isLoop();\n                    }));\n                }\n            });\n        });\n        components.push(component);\n    };\n    var _biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n        if (root === parent) edgeCount += 1;\n        nodes[currentNode] = {\n            id: id,\n            low: id++,\n            cutVertex: false\n        };\n        var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n        if (edges.size() === 0) {\n            components.push(eles.spawn(eles.getElementById(currentNode)));\n        } else {\n            var sourceId, targetId, otherNodeId, edgeId;\n            edges.forEach(function(edge) {\n                sourceId = edge.source().id();\n                targetId = edge.target().id();\n                otherNodeId = sourceId === currentNode ? targetId : sourceId;\n                if (otherNodeId !== parent) {\n                    edgeId = edge.id();\n                    if (!visitedEdges[edgeId]) {\n                        visitedEdges[edgeId] = true;\n                        stack.push({\n                            x: currentNode,\n                            y: otherNodeId,\n                            edge: edge\n                        });\n                    }\n                    if (!(otherNodeId in nodes)) {\n                        _biconnectedSearch(root, otherNodeId, currentNode);\n                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n                        if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n                            nodes[currentNode].cutVertex = true;\n                            buildComponent(currentNode, otherNodeId);\n                        }\n                    } else {\n                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n                    }\n                }\n            });\n        }\n    };\n    eles.forEach(function(ele) {\n        if (ele.isNode()) {\n            var nodeId = ele.id();\n            if (!(nodeId in nodes)) {\n                edgeCount = 0;\n                _biconnectedSearch(nodeId, nodeId);\n                nodes[nodeId].cutVertex = edgeCount > 1;\n            }\n        }\n    });\n    var cutVertices = Object.keys(nodes).filter(function(id) {\n        return nodes[id].cutVertex;\n    }).map(function(id) {\n        return eles.getElementById(id);\n    });\n    return {\n        cut: eles.spawn(cutVertices),\n        components: components\n    };\n};\nvar hopcroftTarjanBiconnected$1 = {\n    hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n    htbc: hopcroftTarjanBiconnected,\n    htb: hopcroftTarjanBiconnected,\n    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n};\nvar tarjanStronglyConnected = function tarjanStronglyConnected() {\n    var eles = this;\n    var nodes = {};\n    var index = 0;\n    var components = [];\n    var stack = [];\n    var cut = eles.spawn(eles);\n    var _stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n        stack.push(sourceNodeId);\n        nodes[sourceNodeId] = {\n            index: index,\n            low: index++,\n            explored: false\n        };\n        var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n        connectedEdges.forEach(function(edge) {\n            var targetNodeId = edge.target().id();\n            if (targetNodeId !== sourceNodeId) {\n                if (!(targetNodeId in nodes)) {\n                    _stronglyConnectedSearch(targetNodeId);\n                }\n                if (!nodes[targetNodeId].explored) {\n                    nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n                }\n            }\n        });\n        if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n            var componentNodes = eles.spawn();\n            for(;;){\n                var nodeId = stack.pop();\n                componentNodes.merge(eles.getElementById(nodeId));\n                nodes[nodeId].low = nodes[sourceNodeId].index;\n                nodes[nodeId].explored = true;\n                if (nodeId === sourceNodeId) {\n                    break;\n                }\n            }\n            var componentEdges = componentNodes.edgesWith(componentNodes);\n            var component = componentNodes.merge(componentEdges);\n            components.push(component);\n            cut = cut.difference(component);\n        }\n    };\n    eles.forEach(function(ele) {\n        if (ele.isNode()) {\n            var nodeId = ele.id();\n            if (!(nodeId in nodes)) {\n                _stronglyConnectedSearch(nodeId);\n            }\n        }\n    });\n    return {\n        cut: cut,\n        components: components\n    };\n};\nvar tarjanStronglyConnected$1 = {\n    tarjanStronglyConnected: tarjanStronglyConnected,\n    tsc: tarjanStronglyConnected,\n    tscc: tarjanStronglyConnected,\n    tarjanStronglyConnectedComponents: tarjanStronglyConnected\n};\nvar elesfn$j = {};\n[\n    elesfn$v,\n    elesfn$u,\n    elesfn$t,\n    elesfn$s,\n    elesfn$r,\n    elesfn$q,\n    elesfn$p,\n    elesfn$o,\n    elesfn$n,\n    elesfn$m,\n    elesfn$l,\n    markovClustering$1,\n    kClustering,\n    hierarchicalClustering$1,\n    affinityPropagation$1,\n    elesfn$k,\n    hopcroftTarjanBiconnected$1,\n    tarjanStronglyConnected$1\n].forEach(function(props) {\n    extend(elesfn$j, props);\n});\n/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/ /*  promise states [Promises/A+ 2.1]  */ var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */ \nvar STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */ \nvar STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */ \n/*  promise object constructor  */ var _api = function api(executor) {\n    /*  optionally support non-constructor/plain-function call  */ if (!(this instanceof _api)) return new _api(executor);\n    /*  initialize object  */ this.id = \"Thenable/1.0.7\";\n    this.state = STATE_PENDING; /*  initial state  */ \n    this.fulfillValue = undefined; /*  initial value  */  /*  [Promises/A+ 1.3, 2.1.2.2]  */ \n    this.rejectReason = undefined; /*  initial reason */  /*  [Promises/A+ 1.5, 2.1.3.2]  */ \n    this.onFulfilled = []; /*  initial handlers  */ \n    this.onRejected = []; /*  initial handlers  */ \n    /*  provide optional information-hiding proxy  */ this.proxy = {\n        then: this.then.bind(this)\n    };\n    /*  support optional executor function  */ if (typeof executor === \"function\") executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n/*  promise API methods  */ _api.prototype = {\n    /*  promise resolving methods  */ fulfill: function fulfill(value) {\n        return deliver(this, STATE_FULFILLED, \"fulfillValue\", value);\n    },\n    reject: function reject(value) {\n        return deliver(this, STATE_REJECTED, \"rejectReason\", value);\n    },\n    /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */ then: function then(onFulfilled, onRejected) {\n        var curr = this;\n        var next = new _api(); /*  [Promises/A+ 2.2.7]  */ \n        curr.onFulfilled.push(resolver(onFulfilled, next, \"fulfill\")); /*  [Promises/A+ 2.2.2/2.2.6]  */ \n        curr.onRejected.push(resolver(onRejected, next, \"reject\")); /*  [Promises/A+ 2.2.3/2.2.6]  */ \n        execute(curr);\n        return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */ \n    }\n};\n/*  deliver an action  */ var deliver = function deliver(curr, state, name, value) {\n    if (curr.state === STATE_PENDING) {\n        curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */ \n        curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */ \n        execute(curr);\n    }\n    return curr;\n};\n/*  execute all handlers  */ var execute = function execute(curr) {\n    if (curr.state === STATE_FULFILLED) execute_handlers(curr, \"onFulfilled\", curr.fulfillValue);\n    else if (curr.state === STATE_REJECTED) execute_handlers(curr, \"onRejected\", curr.rejectReason);\n};\n/*  execute particular set of handlers  */ var execute_handlers = function execute_handlers(curr, name, value) {\n    /* global setImmediate: true */ /* global setTimeout: true */ /*  short-circuit processing  */ if (curr[name].length === 0) return;\n    /*  iterate over all handlers, exactly once  */ var handlers = curr[name];\n    curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */ \n    var func = function func() {\n        for(var i = 0; i < handlers.length; i++)handlers[i](value); /*  [Promises/A+ 2.2.5]  */ \n    };\n    /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */ if (typeof setImmediate === \"function\") setImmediate(func);\n    else setTimeout(func, 0);\n};\n/*  generate a resolver function  */ var resolver = function resolver(cb, next, method) {\n    return function(value) {\n        if (typeof cb !== \"function\") /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */ next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */ \n        else {\n            var result;\n            try {\n                result = cb(value);\n            } catch (e) {\n                next.reject(e); /*  [Promises/A+ 2.2.7.2]  */ \n                return;\n            }\n            _resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */ \n        }\n    };\n};\n/*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */ var _resolve = function resolve(promise, x) {\n    /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */ if (promise === x || promise.proxy === x) {\n        promise.reject(new TypeError(\"cannot resolve promise with itself\"));\n        return;\n    }\n    /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */ var then;\n    if (_typeof(x) === \"object\" && x !== null || typeof x === \"function\") {\n        try {\n            then = x.then;\n        } catch (e) {\n            promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */ \n            return;\n        }\n    }\n    /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */ if (typeof then === \"function\") {\n        var resolved = false;\n        try {\n            /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */ then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */ function(y) {\n                if (resolved) return;\n                resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */ \n                if (y === x) /*  [Promises/A+ 3.6]  */ promise.reject(new TypeError(\"circular thenable chain\"));\n                else _resolve(promise, y);\n            }, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */ function(r) {\n                if (resolved) return;\n                resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */ \n                promise.reject(r);\n            });\n        } catch (e) {\n            if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */ \n        }\n        return;\n    }\n    /*  handle other values  */ promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */ \n};\n// so we always have Promise.all()\n_api.all = function(ps) {\n    return new _api(function(resolveAll, rejectAll) {\n        var vals = new Array(ps.length);\n        var doneCount = 0;\n        var fulfill = function fulfill(i, val) {\n            vals[i] = val;\n            doneCount++;\n            if (doneCount === ps.length) {\n                resolveAll(vals);\n            }\n        };\n        for(var i = 0; i < ps.length; i++){\n            (function(i) {\n                var p = ps[i];\n                var isPromise = p != null && p.then != null;\n                if (isPromise) {\n                    p.then(function(val) {\n                        fulfill(i, val);\n                    }, function(err) {\n                        rejectAll(err);\n                    });\n                } else {\n                    var val = p;\n                    fulfill(i, val);\n                }\n            })(i);\n        }\n    });\n};\n_api.resolve = function(val) {\n    return new _api(function(resolve, reject) {\n        resolve(val);\n    });\n};\n_api.reject = function(val) {\n    return new _api(function(resolve, reject) {\n        reject(val);\n    });\n};\nvar Promise$1 = typeof Promise !== \"undefined\" ? Promise : _api; // eslint-disable-line no-undef\nvar Animation = function Animation(target, opts, opts2) {\n    var isCore = core(target);\n    var isEle = !isCore;\n    var _p = this._private = extend({\n        duration: 1000\n    }, opts, opts2);\n    _p.target = target;\n    _p.style = _p.style || _p.css;\n    _p.started = false;\n    _p.playing = false;\n    _p.hooked = false;\n    _p.applying = false;\n    _p.progress = 0;\n    _p.completes = [];\n    _p.frames = [];\n    if (_p.complete && fn$6(_p.complete)) {\n        _p.completes.push(_p.complete);\n    }\n    if (isEle) {\n        var pos = target.position();\n        _p.startPosition = _p.startPosition || {\n            x: pos.x,\n            y: pos.y\n        };\n        _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n    }\n    if (isCore) {\n        var pan = target.pan();\n        _p.startPan = {\n            x: pan.x,\n            y: pan.y\n        };\n        _p.startZoom = target.zoom();\n    }\n    // for future timeline/animations impl\n    this.length = 1;\n    this[0] = this;\n};\nvar anifn = Animation.prototype;\nextend(anifn, {\n    instanceString: function instanceString() {\n        return \"animation\";\n    },\n    hook: function hook() {\n        var _p = this._private;\n        if (!_p.hooked) {\n            // add to target's animation queue\n            var q;\n            var tAni = _p.target._private.animation;\n            if (_p.queue) {\n                q = tAni.queue;\n            } else {\n                q = tAni.current;\n            }\n            q.push(this);\n            // add to the animation loop pool\n            if (elementOrCollection(_p.target)) {\n                _p.target.cy().addToAnimationPool(_p.target);\n            }\n            _p.hooked = true;\n        }\n        return this;\n    },\n    play: function play() {\n        var _p = this._private;\n        // autorewind\n        if (_p.progress === 1) {\n            _p.progress = 0;\n        }\n        _p.playing = true;\n        _p.started = false; // needs to be started by animation loop\n        _p.stopped = false;\n        this.hook();\n        // the animation loop will start the animation...\n        return this;\n    },\n    playing: function playing() {\n        return this._private.playing;\n    },\n    apply: function apply() {\n        var _p = this._private;\n        _p.applying = true;\n        _p.started = false; // needs to be started by animation loop\n        _p.stopped = false;\n        this.hook();\n        // the animation loop will apply the animation at this progress\n        return this;\n    },\n    applying: function applying() {\n        return this._private.applying;\n    },\n    pause: function pause() {\n        var _p = this._private;\n        _p.playing = false;\n        _p.started = false;\n        return this;\n    },\n    stop: function stop() {\n        var _p = this._private;\n        _p.playing = false;\n        _p.started = false;\n        _p.stopped = true; // to be removed from animation queues\n        return this;\n    },\n    rewind: function rewind() {\n        return this.progress(0);\n    },\n    fastforward: function fastforward() {\n        return this.progress(1);\n    },\n    time: function time(t) {\n        var _p = this._private;\n        if (t === undefined) {\n            return _p.progress * _p.duration;\n        } else {\n            return this.progress(t / _p.duration);\n        }\n    },\n    progress: function progress(p) {\n        var _p = this._private;\n        var wasPlaying = _p.playing;\n        if (p === undefined) {\n            return _p.progress;\n        } else {\n            if (wasPlaying) {\n                this.pause();\n            }\n            _p.progress = p;\n            _p.started = false;\n            if (wasPlaying) {\n                this.play();\n            }\n        }\n        return this;\n    },\n    completed: function completed() {\n        return this._private.progress === 1;\n    },\n    reverse: function reverse() {\n        var _p = this._private;\n        var wasPlaying = _p.playing;\n        if (wasPlaying) {\n            this.pause();\n        }\n        _p.progress = 1 - _p.progress;\n        _p.started = false;\n        var swap = function swap(a, b) {\n            var _pa = _p[a];\n            if (_pa == null) {\n                return;\n            }\n            _p[a] = _p[b];\n            _p[b] = _pa;\n        };\n        swap(\"zoom\", \"startZoom\");\n        swap(\"pan\", \"startPan\");\n        swap(\"position\", \"startPosition\");\n        // swap styles\n        if (_p.style) {\n            for(var i = 0; i < _p.style.length; i++){\n                var prop = _p.style[i];\n                var name = prop.name;\n                var startStyleProp = _p.startStyle[name];\n                _p.startStyle[name] = prop;\n                _p.style[i] = startStyleProp;\n            }\n        }\n        if (wasPlaying) {\n            this.play();\n        }\n        return this;\n    },\n    promise: function promise(type) {\n        var _p = this._private;\n        var arr;\n        switch(type){\n            case \"frame\":\n                arr = _p.frames;\n                break;\n            default:\n            case \"complete\":\n            case \"completed\":\n                arr = _p.completes;\n        }\n        return new Promise$1(function(resolve, reject) {\n            arr.push(function() {\n                resolve();\n            });\n        });\n    }\n});\nanifn.complete = anifn.completed;\nanifn.run = anifn.play;\nanifn.running = anifn.playing;\nvar define$3 = {\n    animated: function animated() {\n        return function animatedImpl() {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return false;\n            }\n            var ele = all[0];\n            if (ele) {\n                return ele._private.animation.current.length > 0;\n            }\n        };\n    },\n    // animated\n    clearQueue: function clearQueue() {\n        return function clearQueueImpl() {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                ele._private.animation.queue = [];\n            }\n            return this;\n        };\n    },\n    // clearQueue\n    delay: function delay() {\n        return function delayImpl(time, complete) {\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            return this.animate({\n                delay: time,\n                duration: time,\n                complete: complete\n            });\n        };\n    },\n    // delay\n    delayAnimation: function delayAnimation() {\n        return function delayAnimationImpl(time, complete) {\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            return this.animation({\n                delay: time,\n                duration: time,\n                complete: complete\n            });\n        };\n    },\n    // delay\n    animation: function animation() {\n        return function animationImpl(properties, params) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            var isCore = !selfIsArrayLike;\n            var isEles = !isCore;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            var style = cy.style();\n            properties = extend({}, properties, params);\n            var propertiesEmpty = Object.keys(properties).length === 0;\n            if (propertiesEmpty) {\n                return new Animation(all[0], properties); // nothing to animate\n            }\n            if (properties.duration === undefined) {\n                properties.duration = 400;\n            }\n            switch(properties.duration){\n                case \"slow\":\n                    properties.duration = 600;\n                    break;\n                case \"fast\":\n                    properties.duration = 200;\n                    break;\n            }\n            if (isEles) {\n                properties.style = style.getPropsList(properties.style || properties.css);\n                properties.css = undefined;\n            }\n            if (isEles && properties.renderedPosition != null) {\n                var rpos = properties.renderedPosition;\n                var pan = cy.pan();\n                var zoom = cy.zoom();\n                properties.position = renderedToModelPosition(rpos, zoom, pan);\n            }\n            // override pan w/ panBy if set\n            if (isCore && properties.panBy != null) {\n                var panBy = properties.panBy;\n                var cyPan = cy.pan();\n                properties.pan = {\n                    x: cyPan.x + panBy.x,\n                    y: cyPan.y + panBy.y\n                };\n            }\n            // override pan w/ center if set\n            var center = properties.center || properties.centre;\n            if (isCore && center != null) {\n                var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n                if (centerPan != null) {\n                    properties.pan = centerPan;\n                }\n            }\n            // override pan & zoom w/ fit if set\n            if (isCore && properties.fit != null) {\n                var fit = properties.fit;\n                var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n                if (fitVp != null) {\n                    properties.pan = fitVp.pan;\n                    properties.zoom = fitVp.zoom;\n                }\n            }\n            // override zoom (& potentially pan) w/ zoom obj if set\n            if (isCore && plainObject(properties.zoom)) {\n                var vp = cy.getZoomedViewport(properties.zoom);\n                if (vp != null) {\n                    if (vp.zoomed) {\n                        properties.zoom = vp.zoom;\n                    }\n                    if (vp.panned) {\n                        properties.pan = vp.pan;\n                    }\n                } else {\n                    properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n                }\n            }\n            return new Animation(all[0], properties);\n        };\n    },\n    // animate\n    animate: function animate() {\n        return function animateImpl(properties, params) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            if (params) {\n                properties = extend({}, properties, params);\n            }\n            // manually hook and run the animation\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n                var ani = ele.animation(properties, queue ? {\n                    queue: true\n                } : undefined);\n                ani.play();\n            }\n            return this; // chaining\n        };\n    },\n    // animate\n    stop: function stop() {\n        return function stopImpl(clearQueue, jumpToEnd) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                var _p = ele._private;\n                var anis = _p.animation.current;\n                for(var j = 0; j < anis.length; j++){\n                    var ani = anis[j];\n                    var ani_p = ani._private;\n                    if (jumpToEnd) {\n                        // next iteration of the animation loop, the animation\n                        // will go straight to the end and be removed\n                        ani_p.duration = 0;\n                    }\n                }\n                // clear the queue of future animations\n                if (clearQueue) {\n                    _p.animation.queue = [];\n                }\n                if (!jumpToEnd) {\n                    _p.animation.current = [];\n                }\n            }\n            // we have to notify (the animation loop doesn't do it for us on `stop`)\n            cy.notify(\"draw\");\n            return this;\n        };\n    } // stop\n}; // define\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray_1;\nvar hasRequiredIsArray;\nfunction requireIsArray() {\n    if (hasRequiredIsArray) return isArray_1;\n    hasRequiredIsArray = 1;\n    var isArray = Array.isArray;\n    isArray_1 = isArray;\n    return isArray_1;\n}\nvar _isKey;\nvar hasRequired_isKey;\nfunction require_isKey() {\n    if (hasRequired_isKey) return _isKey;\n    hasRequired_isKey = 1;\n    var isArray = requireIsArray(), isSymbol = requireIsSymbol();\n    /** Used to match property names within property paths. */ var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\n    /**\n\t * Checks if `value` is a property name and not a property path.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t */ function isKey(value, object) {\n        if (isArray(value)) {\n            return false;\n        }\n        var type = typeof value;\n        if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n            return true;\n        }\n        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    _isKey = isKey;\n    return _isKey;\n}\nvar isFunction_1;\nvar hasRequiredIsFunction;\nfunction requireIsFunction() {\n    if (hasRequiredIsFunction) return isFunction_1;\n    hasRequiredIsFunction = 1;\n    var baseGetTag = require_baseGetTag(), isObject = requireIsObject();\n    /** `Object#toString` result references. */ var asyncTag = \"[object AsyncFunction]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", proxyTag = \"[object Proxy]\";\n    /**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */ function isFunction(value) {\n        if (!isObject(value)) {\n            return false;\n        }\n        // The use of `Object#toString` avoids issues with the `typeof` operator\n        // in Safari 9 which returns 'object' for typed arrays and other constructors.\n        var tag = baseGetTag(value);\n        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n    isFunction_1 = isFunction;\n    return isFunction_1;\n}\nvar _coreJsData;\nvar hasRequired_coreJsData;\nfunction require_coreJsData() {\n    if (hasRequired_coreJsData) return _coreJsData;\n    hasRequired_coreJsData = 1;\n    var root = require_root();\n    /** Used to detect overreaching core-js shims. */ var coreJsData = root[\"__core-js_shared__\"];\n    _coreJsData = coreJsData;\n    return _coreJsData;\n}\nvar _isMasked;\nvar hasRequired_isMasked;\nfunction require_isMasked() {\n    if (hasRequired_isMasked) return _isMasked;\n    hasRequired_isMasked = 1;\n    var coreJsData = require_coreJsData();\n    /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n        return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    /**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */ function isMasked(func) {\n        return !!maskSrcKey && maskSrcKey in func;\n    }\n    _isMasked = isMasked;\n    return _isMasked;\n}\n/** Used for built-in method references. */ var _toSource;\nvar hasRequired_toSource;\nfunction require_toSource() {\n    if (hasRequired_toSource) return _toSource;\n    hasRequired_toSource = 1;\n    var funcProto = Function.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to convert.\n\t * @returns {string} Returns the source code.\n\t */ function toSource(func) {\n        if (func != null) {\n            try {\n                return funcToString.call(func);\n            } catch (e) {}\n            try {\n                return func + \"\";\n            } catch (e) {}\n        }\n        return \"\";\n    }\n    _toSource = toSource;\n    return _toSource;\n}\nvar _baseIsNative;\nvar hasRequired_baseIsNative;\nfunction require_baseIsNative() {\n    if (hasRequired_baseIsNative) return _baseIsNative;\n    hasRequired_baseIsNative = 1;\n    var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();\n    /**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /** Used to detect if a method is native. */ var reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n    /**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */ function baseIsNative(value) {\n        if (!isObject(value) || isMasked(value)) {\n            return false;\n        }\n        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n        return pattern.test(toSource(value));\n    }\n    _baseIsNative = baseIsNative;\n    return _baseIsNative;\n}\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ var _getValue;\nvar hasRequired_getValue;\nfunction require_getValue() {\n    if (hasRequired_getValue) return _getValue;\n    hasRequired_getValue = 1;\n    function getValue(object, key) {\n        return object == null ? undefined : object[key];\n    }\n    _getValue = getValue;\n    return _getValue;\n}\nvar _getNative;\nvar hasRequired_getNative;\nfunction require_getNative() {\n    if (hasRequired_getNative) return _getNative;\n    hasRequired_getNative = 1;\n    var baseIsNative = require_baseIsNative(), getValue = require_getValue();\n    /**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */ function getNative(object, key) {\n        var value = getValue(object, key);\n        return baseIsNative(value) ? value : undefined;\n    }\n    _getNative = getNative;\n    return _getNative;\n}\nvar _nativeCreate;\nvar hasRequired_nativeCreate;\nfunction require_nativeCreate() {\n    if (hasRequired_nativeCreate) return _nativeCreate;\n    hasRequired_nativeCreate = 1;\n    var getNative = require_getNative();\n    /* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, \"create\");\n    _nativeCreate = nativeCreate;\n    return _nativeCreate;\n}\nvar _hashClear;\nvar hasRequired_hashClear;\nfunction require_hashClear() {\n    if (hasRequired_hashClear) return _hashClear;\n    hasRequired_hashClear = 1;\n    var nativeCreate = require_nativeCreate();\n    /**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */ function hashClear() {\n        this.__data__ = nativeCreate ? nativeCreate(null) : {};\n        this.size = 0;\n    }\n    _hashClear = hashClear;\n    return _hashClear;\n}\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ var _hashDelete;\nvar hasRequired_hashDelete;\nfunction require_hashDelete() {\n    if (hasRequired_hashDelete) return _hashDelete;\n    hasRequired_hashDelete = 1;\n    function hashDelete(key) {\n        var result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    _hashDelete = hashDelete;\n    return _hashDelete;\n}\nvar _hashGet;\nvar hasRequired_hashGet;\nfunction require_hashGet() {\n    if (hasRequired_hashGet) return _hashGet;\n    hasRequired_hashGet = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function hashGet(key) {\n        var data = this.__data__;\n        if (nativeCreate) {\n            var result = data[key];\n            return result === HASH_UNDEFINED ? undefined : result;\n        }\n        return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n    _hashGet = hashGet;\n    return _hashGet;\n}\nvar _hashHas;\nvar hasRequired_hashHas;\nfunction require_hashHas() {\n    if (hasRequired_hashHas) return _hashHas;\n    hasRequired_hashHas = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function hashHas(key) {\n        var data = this.__data__;\n        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n    }\n    _hashHas = hashHas;\n    return _hashHas;\n}\nvar _hashSet;\nvar hasRequired_hashSet;\nfunction require_hashSet() {\n    if (hasRequired_hashSet) return _hashSet;\n    hasRequired_hashSet = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    /**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */ function hashSet(key, value) {\n        var data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n    _hashSet = hashSet;\n    return _hashSet;\n}\nvar _Hash;\nvar hasRequired_Hash;\nfunction require_Hash() {\n    if (hasRequired_Hash) return _Hash;\n    hasRequired_Hash = 1;\n    var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();\n    /**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function Hash(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype[\"delete\"] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    _Hash = Hash;\n    return _Hash;\n}\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ var _listCacheClear;\nvar hasRequired_listCacheClear;\nfunction require_listCacheClear() {\n    if (hasRequired_listCacheClear) return _listCacheClear;\n    hasRequired_listCacheClear = 1;\n    function listCacheClear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n    _listCacheClear = listCacheClear;\n    return _listCacheClear;\n}\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ var eq_1;\nvar hasRequiredEq;\nfunction requireEq() {\n    if (hasRequiredEq) return eq_1;\n    hasRequiredEq = 1;\n    function eq(value, other) {\n        return value === other || value !== value && other !== other;\n    }\n    eq_1 = eq;\n    return eq_1;\n}\nvar _assocIndexOf;\nvar hasRequired_assocIndexOf;\nfunction require_assocIndexOf() {\n    if (hasRequired_assocIndexOf) return _assocIndexOf;\n    hasRequired_assocIndexOf = 1;\n    var eq = requireEq();\n    /**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */ function assocIndexOf(array, key) {\n        var length = array.length;\n        while(length--){\n            if (eq(array[length][0], key)) {\n                return length;\n            }\n        }\n        return -1;\n    }\n    _assocIndexOf = assocIndexOf;\n    return _assocIndexOf;\n}\nvar _listCacheDelete;\nvar hasRequired_listCacheDelete;\nfunction require_listCacheDelete() {\n    if (hasRequired_listCacheDelete) return _listCacheDelete;\n    hasRequired_listCacheDelete = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /** Used for built-in method references. */ var arrayProto = Array.prototype;\n    /** Built-in value references. */ var splice = arrayProto.splice;\n    /**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */ function listCacheDelete(key) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        if (index < 0) {\n            return false;\n        }\n        var lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            splice.call(data, index, 1);\n        }\n        --this.size;\n        return true;\n    }\n    _listCacheDelete = listCacheDelete;\n    return _listCacheDelete;\n}\nvar _listCacheGet;\nvar hasRequired_listCacheGet;\nfunction require_listCacheGet() {\n    if (hasRequired_listCacheGet) return _listCacheGet;\n    hasRequired_listCacheGet = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function listCacheGet(key) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n    _listCacheGet = listCacheGet;\n    return _listCacheGet;\n}\nvar _listCacheHas;\nvar hasRequired_listCacheHas;\nfunction require_listCacheHas() {\n    if (hasRequired_listCacheHas) return _listCacheHas;\n    hasRequired_listCacheHas = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function listCacheHas(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n    _listCacheHas = listCacheHas;\n    return _listCacheHas;\n}\nvar _listCacheSet;\nvar hasRequired_listCacheSet;\nfunction require_listCacheSet() {\n    if (hasRequired_listCacheSet) return _listCacheSet;\n    hasRequired_listCacheSet = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */ function listCacheSet(key, value) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        if (index < 0) {\n            ++this.size;\n            data.push([\n                key,\n                value\n            ]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n    _listCacheSet = listCacheSet;\n    return _listCacheSet;\n}\nvar _ListCache;\nvar hasRequired_ListCache;\nfunction require_ListCache() {\n    if (hasRequired_ListCache) return _ListCache;\n    hasRequired_ListCache = 1;\n    var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();\n    /**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function ListCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype[\"delete\"] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    _ListCache = ListCache;\n    return _ListCache;\n}\nvar _Map;\nvar hasRequired_Map;\nfunction require_Map() {\n    if (hasRequired_Map) return _Map;\n    hasRequired_Map = 1;\n    var getNative = require_getNative(), root = require_root();\n    /* Built-in method references that are verified to be native. */ var Map1 = getNative(root, \"Map\");\n    _Map = Map1;\n    return _Map;\n}\nvar _mapCacheClear;\nvar hasRequired_mapCacheClear;\nfunction require_mapCacheClear() {\n    if (hasRequired_mapCacheClear) return _mapCacheClear;\n    hasRequired_mapCacheClear = 1;\n    var Hash = require_Hash(), ListCache = require_ListCache(), Map1 = require_Map();\n    /**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */ function mapCacheClear() {\n        this.size = 0;\n        this.__data__ = {\n            \"hash\": new Hash,\n            \"map\": new (Map1 || ListCache),\n            \"string\": new Hash\n        };\n    }\n    _mapCacheClear = mapCacheClear;\n    return _mapCacheClear;\n}\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ var _isKeyable;\nvar hasRequired_isKeyable;\nfunction require_isKeyable() {\n    if (hasRequired_isKeyable) return _isKeyable;\n    hasRequired_isKeyable = 1;\n    function isKeyable(value) {\n        var type = typeof value;\n        return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    _isKeyable = isKeyable;\n    return _isKeyable;\n}\nvar _getMapData;\nvar hasRequired_getMapData;\nfunction require_getMapData() {\n    if (hasRequired_getMapData) return _getMapData;\n    hasRequired_getMapData = 1;\n    var isKeyable = require_isKeyable();\n    /**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */ function getMapData(map, key) {\n        var data = map.__data__;\n        return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    _getMapData = getMapData;\n    return _getMapData;\n}\nvar _mapCacheDelete;\nvar hasRequired_mapCacheDelete;\nfunction require_mapCacheDelete() {\n    if (hasRequired_mapCacheDelete) return _mapCacheDelete;\n    hasRequired_mapCacheDelete = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */ function mapCacheDelete(key) {\n        var result = getMapData(this, key)[\"delete\"](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    _mapCacheDelete = mapCacheDelete;\n    return _mapCacheDelete;\n}\nvar _mapCacheGet;\nvar hasRequired_mapCacheGet;\nfunction require_mapCacheGet() {\n    if (hasRequired_mapCacheGet) return _mapCacheGet;\n    hasRequired_mapCacheGet = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function mapCacheGet(key) {\n        return getMapData(this, key).get(key);\n    }\n    _mapCacheGet = mapCacheGet;\n    return _mapCacheGet;\n}\nvar _mapCacheHas;\nvar hasRequired_mapCacheHas;\nfunction require_mapCacheHas() {\n    if (hasRequired_mapCacheHas) return _mapCacheHas;\n    hasRequired_mapCacheHas = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function mapCacheHas(key) {\n        return getMapData(this, key).has(key);\n    }\n    _mapCacheHas = mapCacheHas;\n    return _mapCacheHas;\n}\nvar _mapCacheSet;\nvar hasRequired_mapCacheSet;\nfunction require_mapCacheSet() {\n    if (hasRequired_mapCacheSet) return _mapCacheSet;\n    hasRequired_mapCacheSet = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */ function mapCacheSet(key, value) {\n        var data = getMapData(this, key), size = data.size;\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n    _mapCacheSet = mapCacheSet;\n    return _mapCacheSet;\n}\nvar _MapCache;\nvar hasRequired_MapCache;\nfunction require_MapCache() {\n    if (hasRequired_MapCache) return _MapCache;\n    hasRequired_MapCache = 1;\n    var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();\n    /**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function MapCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype[\"delete\"] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    _MapCache = MapCache;\n    return _MapCache;\n}\nvar memoize_1;\nvar hasRequiredMemoize;\nfunction requireMemoize() {\n    if (hasRequiredMemoize) return memoize_1;\n    hasRequiredMemoize = 1;\n    var MapCache = require_MapCache();\n    /** Error message constants. */ var FUNC_ERROR_TEXT = \"Expected a function\";\n    /**\n\t * Creates a function that memoizes the result of `func`. If `resolver` is\n\t * provided, it determines the cache key for storing the result based on the\n\t * arguments provided to the memoized function. By default, the first argument\n\t * provided to the memoized function is used as the map cache key. The `func`\n\t * is invoked with the `this` binding of the memoized function.\n\t *\n\t * **Note:** The cache is exposed as the `cache` property on the memoized\n\t * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t * constructor with one whose instances implement the\n\t * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to have its output memoized.\n\t * @param {Function} [resolver] The function to resolve the cache key.\n\t * @returns {Function} Returns the new memoized function.\n\t * @example\n\t *\n\t * var object = { 'a': 1, 'b': 2 };\n\t * var other = { 'c': 3, 'd': 4 };\n\t *\n\t * var values = _.memoize(_.values);\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * values(other);\n\t * // => [3, 4]\n\t *\n\t * object.a = 2;\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * // Modify the result cache.\n\t * values.cache.set(object, ['a', 'b']);\n\t * values(object);\n\t * // => ['a', 'b']\n\t *\n\t * // Replace `_.memoize.Cache`.\n\t * _.memoize.Cache = WeakMap;\n\t */ function memoize(func, resolver) {\n        if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        var memoized = function() {\n            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            var result = func.apply(this, args);\n            memoized.cache = cache.set(key, result) || cache;\n            return result;\n        };\n        memoized.cache = new (memoize.Cache || MapCache);\n        return memoized;\n    }\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n    memoize_1 = memoize;\n    return memoize_1;\n}\nvar _memoizeCapped;\nvar hasRequired_memoizeCapped;\nfunction require_memoizeCapped() {\n    if (hasRequired_memoizeCapped) return _memoizeCapped;\n    hasRequired_memoizeCapped = 1;\n    var memoize = requireMemoize();\n    /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n    /**\n\t * A specialized version of `_.memoize` which clears the memoized function's\n\t * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n\t *\n\t * @private\n\t * @param {Function} func The function to have its output memoized.\n\t * @returns {Function} Returns the new memoized function.\n\t */ function memoizeCapped(func) {\n        var result = memoize(func, function(key) {\n            if (cache.size === MAX_MEMOIZE_SIZE) {\n                cache.clear();\n            }\n            return key;\n        });\n        var cache = result.cache;\n        return result;\n    }\n    _memoizeCapped = memoizeCapped;\n    return _memoizeCapped;\n}\nvar _stringToPath;\nvar hasRequired_stringToPath;\nfunction require_stringToPath() {\n    if (hasRequired_stringToPath) return _stringToPath;\n    hasRequired_stringToPath = 1;\n    var memoizeCapped = require_memoizeCapped();\n    /** Used to match property names within property paths. */ var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    /** Used to match backslashes in property paths. */ var reEscapeChar = /\\\\(\\\\)?/g;\n    /**\n\t * Converts `string` to a property path array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the property path array.\n\t */ var stringToPath = memoizeCapped(function(string) {\n        var result = [];\n        if (string.charCodeAt(0) === 46 /* . */ ) {\n            result.push(\"\");\n        }\n        string.replace(rePropName, function(match, number, quote, subString) {\n            result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n        });\n        return result;\n    });\n    _stringToPath = stringToPath;\n    return _stringToPath;\n}\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ var _arrayMap;\nvar hasRequired_arrayMap;\nfunction require_arrayMap() {\n    if (hasRequired_arrayMap) return _arrayMap;\n    hasRequired_arrayMap = 1;\n    function arrayMap(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n        while(++index < length){\n            result[index] = iteratee(array[index], index, array);\n        }\n        return result;\n    }\n    _arrayMap = arrayMap;\n    return _arrayMap;\n}\nvar _baseToString;\nvar hasRequired_baseToString;\nfunction require_baseToString() {\n    if (hasRequired_baseToString) return _baseToString;\n    hasRequired_baseToString = 1;\n    var Symbol1 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();\n    /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol1 ? Symbol1.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n    /**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */ function baseToString(value) {\n        // Exit early for strings to avoid a performance hit in some environments.\n        if (typeof value == \"string\") {\n            return value;\n        }\n        if (isArray(value)) {\n            // Recursively convert values (susceptible to call stack limits).\n            return arrayMap(value, baseToString) + \"\";\n        }\n        if (isSymbol(value)) {\n            return symbolToString ? symbolToString.call(value) : \"\";\n        }\n        var result = value + \"\";\n        return result == \"0\" && 1 / value == -Infinity ? \"-0\" : result;\n    }\n    _baseToString = baseToString;\n    return _baseToString;\n}\nvar toString_1;\nvar hasRequiredToString;\nfunction requireToString() {\n    if (hasRequiredToString) return toString_1;\n    hasRequiredToString = 1;\n    var baseToString = require_baseToString();\n    /**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */ function toString(value) {\n        return value == null ? \"\" : baseToString(value);\n    }\n    toString_1 = toString;\n    return toString_1;\n}\nvar _castPath;\nvar hasRequired_castPath;\nfunction require_castPath() {\n    if (hasRequired_castPath) return _castPath;\n    hasRequired_castPath = 1;\n    var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();\n    /**\n\t * Casts `value` to a path array if it's not one.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {Array} Returns the cast property path array.\n\t */ function castPath(value, object) {\n        if (isArray(value)) {\n            return value;\n        }\n        return isKey(value, object) ? [\n            value\n        ] : stringToPath(toString(value));\n    }\n    _castPath = castPath;\n    return _castPath;\n}\nvar _toKey;\nvar hasRequired_toKey;\nfunction require_toKey() {\n    if (hasRequired_toKey) return _toKey;\n    hasRequired_toKey = 1;\n    var isSymbol = requireIsSymbol();\n    /**\n\t * Converts `value` to a string key if it's not a string or symbol.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @returns {string|symbol} Returns the key.\n\t */ function toKey(value) {\n        if (typeof value == \"string\" || isSymbol(value)) {\n            return value;\n        }\n        var result = value + \"\";\n        return result == \"0\" && 1 / value == -Infinity ? \"-0\" : result;\n    }\n    _toKey = toKey;\n    return _toKey;\n}\nvar _baseGet;\nvar hasRequired_baseGet;\nfunction require_baseGet() {\n    if (hasRequired_baseGet) return _baseGet;\n    hasRequired_baseGet = 1;\n    var castPath = require_castPath(), toKey = require_toKey();\n    /**\n\t * The base implementation of `_.get` without support for default values.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {*} Returns the resolved value.\n\t */ function baseGet(object, path) {\n        path = castPath(path, object);\n        var index = 0, length = path.length;\n        while(object != null && index < length){\n            object = object[toKey(path[index++])];\n        }\n        return index && index == length ? object : undefined;\n    }\n    _baseGet = baseGet;\n    return _baseGet;\n}\nvar get_1;\nvar hasRequiredGet;\nfunction requireGet() {\n    if (hasRequiredGet) return get_1;\n    hasRequiredGet = 1;\n    var baseGet = require_baseGet();\n    /**\n\t * Gets the value at `path` of `object`. If the resolved value is\n\t * `undefined`, the `defaultValue` is returned in its place.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t * @returns {*} Returns the resolved value.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.get(object, 'a[0].b.c');\n\t * // => 3\n\t *\n\t * _.get(object, ['a', '0', 'b', 'c']);\n\t * // => 3\n\t *\n\t * _.get(object, 'a.b.c', 'default');\n\t * // => 'default'\n\t */ function get(object, path, defaultValue) {\n        var result = object == null ? undefined : baseGet(object, path);\n        return result === undefined ? defaultValue : result;\n    }\n    get_1 = get;\n    return get_1;\n}\nvar getExports = requireGet();\nvar get = /*@__PURE__*/ getDefaultExportFromCjs(getExports);\nvar _defineProperty;\nvar hasRequired_defineProperty;\nfunction require_defineProperty() {\n    if (hasRequired_defineProperty) return _defineProperty;\n    hasRequired_defineProperty = 1;\n    var getNative = require_getNative();\n    var defineProperty = function() {\n        try {\n            var func = getNative(Object, \"defineProperty\");\n            func({}, \"\", {});\n            return func;\n        } catch (e) {}\n    }();\n    _defineProperty = defineProperty;\n    return _defineProperty;\n}\nvar _baseAssignValue;\nvar hasRequired_baseAssignValue;\nfunction require_baseAssignValue() {\n    if (hasRequired_baseAssignValue) return _baseAssignValue;\n    hasRequired_baseAssignValue = 1;\n    var defineProperty = require_defineProperty();\n    /**\n\t * The base implementation of `assignValue` and `assignMergeValue` without\n\t * value checks.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */ function baseAssignValue(object, key, value) {\n        if (key == \"__proto__\" && defineProperty) {\n            defineProperty(object, key, {\n                \"configurable\": true,\n                \"enumerable\": true,\n                \"value\": value,\n                \"writable\": true\n            });\n        } else {\n            object[key] = value;\n        }\n    }\n    _baseAssignValue = baseAssignValue;\n    return _baseAssignValue;\n}\nvar _assignValue;\nvar hasRequired_assignValue;\nfunction require_assignValue() {\n    if (hasRequired_assignValue) return _assignValue;\n    hasRequired_assignValue = 1;\n    var baseAssignValue = require_baseAssignValue(), eq = requireEq();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * for equality comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */ function assignValue(object, key, value) {\n        var objValue = object[key];\n        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n            baseAssignValue(object, key, value);\n        }\n    }\n    _assignValue = assignValue;\n    return _assignValue;\n}\n/** Used as references for various `Number` constants. */ var _isIndex;\nvar hasRequired_isIndex;\nfunction require_isIndex() {\n    if (hasRequired_isIndex) return _isIndex;\n    hasRequired_isIndex = 1;\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    /**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */ function isIndex(value, length) {\n        var type = typeof value;\n        length = length == null ? MAX_SAFE_INTEGER : length;\n        return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    _isIndex = isIndex;\n    return _isIndex;\n}\nvar _baseSet;\nvar hasRequired_baseSet;\nfunction require_baseSet() {\n    if (hasRequired_baseSet) return _baseSet;\n    hasRequired_baseSet = 1;\n    var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject = requireIsObject(), toKey = require_toKey();\n    /**\n\t * The base implementation of `_.set`.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @param {Function} [customizer] The function to customize path creation.\n\t * @returns {Object} Returns `object`.\n\t */ function baseSet(object, path, value, customizer) {\n        if (!isObject(object)) {\n            return object;\n        }\n        path = castPath(path, object);\n        var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n        while(nested != null && ++index < length){\n            var key = toKey(path[index]), newValue = value;\n            if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n                return object;\n            }\n            if (index != lastIndex) {\n                var objValue = nested[key];\n                newValue = customizer ? customizer(objValue, key, nested) : undefined;\n                if (newValue === undefined) {\n                    newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n                }\n            }\n            assignValue(nested, key, newValue);\n            nested = nested[key];\n        }\n        return object;\n    }\n    _baseSet = baseSet;\n    return _baseSet;\n}\nvar set_1;\nvar hasRequiredSet;\nfunction requireSet() {\n    if (hasRequiredSet) return set_1;\n    hasRequiredSet = 1;\n    var baseSet = require_baseSet();\n    /**\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n\t * it's created. Arrays are created for missing index properties while objects\n\t * are created for all other missing properties. Use `_.setWith` to customize\n\t * `path` creation.\n\t *\n\t * **Note:** This method mutates `object`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns `object`.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.set(object, 'a[0].b.c', 4);\n\t * console.log(object.a[0].b.c);\n\t * // => 4\n\t *\n\t * _.set(object, ['x', '0', 'y', 'z'], 5);\n\t * console.log(object.x[0].y.z);\n\t * // => 5\n\t */ function set(object, path, value) {\n        return object == null ? object : baseSet(object, path, value);\n    }\n    set_1 = set;\n    return set_1;\n}\nvar setExports = requireSet();\nvar set = /*@__PURE__*/ getDefaultExportFromCjs(setExports);\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ var _copyArray;\nvar hasRequired_copyArray;\nfunction require_copyArray() {\n    if (hasRequired_copyArray) return _copyArray;\n    hasRequired_copyArray = 1;\n    function copyArray(source, array) {\n        var index = -1, length = source.length;\n        array || (array = Array(length));\n        while(++index < length){\n            array[index] = source[index];\n        }\n        return array;\n    }\n    _copyArray = copyArray;\n    return _copyArray;\n}\nvar toPath_1;\nvar hasRequiredToPath;\nfunction requireToPath() {\n    if (hasRequiredToPath) return toPath_1;\n    hasRequiredToPath = 1;\n    var arrayMap = require_arrayMap(), copyArray = require_copyArray(), isArray = requireIsArray(), isSymbol = requireIsSymbol(), stringToPath = require_stringToPath(), toKey = require_toKey(), toString = requireToString();\n    /**\n\t * Converts `value` to a property path array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Util\n\t * @param {*} value The value to convert.\n\t * @returns {Array} Returns the new property path array.\n\t * @example\n\t *\n\t * _.toPath('a.b.c');\n\t * // => ['a', 'b', 'c']\n\t *\n\t * _.toPath('a[0].b.c');\n\t * // => ['a', '0', 'b', 'c']\n\t */ function toPath(value) {\n        if (isArray(value)) {\n            return arrayMap(value, toKey);\n        }\n        return isSymbol(value) ? [\n            value\n        ] : copyArray(stringToPath(toString(value)));\n    }\n    toPath_1 = toPath;\n    return toPath_1;\n}\nvar toPathExports = requireToPath();\nvar toPath = /*@__PURE__*/ getDefaultExportFromCjs(toPathExports);\nvar define$2 = {\n    // access data field\n    data: function data(params) {\n        var defaults = {\n            field: \"data\",\n            bindingEvent: \"data\",\n            allowBinding: false,\n            allowSetting: false,\n            allowGetting: false,\n            settingEvent: \"data\",\n            settingTriggersEvent: false,\n            triggerFnName: \"trigger\",\n            immutableKeys: {},\n            // key => true if immutable\n            updateStyle: false,\n            beforeGet: function beforeGet(self1) {},\n            beforeSet: function beforeSet(self1, obj) {},\n            onSet: function onSet(self1) {},\n            canSet: function canSet(self1) {\n                return true;\n            }\n        };\n        params = extend({}, defaults, params);\n        return function dataImpl(name, value) {\n            var p = params;\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var single = selfIsArrayLike ? self1[0] : self1;\n            // .data('foo', ...)\n            if (string(name)) {\n                // set or get property\n                var isPathLike = name.indexOf(\".\") !== -1; // there might be a normal field with a dot \n                var path = isPathLike && toPath(name);\n                // .data('foo')\n                if (p.allowGetting && value === undefined) {\n                    // get\n                    var ret;\n                    if (single) {\n                        p.beforeGet(single);\n                        // check if it's path and a field with the same name doesn't exist\n                        if (path && single._private[p.field][name] === undefined) {\n                            ret = get(single._private[p.field], path);\n                        } else {\n                            ret = single._private[p.field][name];\n                        }\n                    }\n                    return ret;\n                // .data('foo', 'bar')\n                } else if (p.allowSetting && value !== undefined) {\n                    // set\n                    var valid = !p.immutableKeys[name];\n                    if (valid) {\n                        var change = _defineProperty$1({}, name, value);\n                        p.beforeSet(self1, change);\n                        for(var i = 0, l = all.length; i < l; i++){\n                            var ele = all[i];\n                            if (p.canSet(ele)) {\n                                if (path && single._private[p.field][name] === undefined) {\n                                    set(ele._private[p.field], path, value);\n                                } else {\n                                    ele._private[p.field][name] = value;\n                                }\n                            }\n                        }\n                        // update mappers if asked\n                        if (p.updateStyle) {\n                            self1.updateStyle();\n                        }\n                        // call onSet callback\n                        p.onSet(self1);\n                        if (p.settingTriggersEvent) {\n                            self1[p.triggerFnName](p.settingEvent);\n                        }\n                    }\n                }\n            // .data({ 'foo': 'bar' })\n            } else if (p.allowSetting && plainObject(name)) {\n                // extend\n                var obj = name;\n                var k, v;\n                var keys = Object.keys(obj);\n                p.beforeSet(self1, obj);\n                for(var _i = 0; _i < keys.length; _i++){\n                    k = keys[_i];\n                    v = obj[k];\n                    var _valid = !p.immutableKeys[k];\n                    if (_valid) {\n                        for(var j = 0; j < all.length; j++){\n                            var _ele = all[j];\n                            if (p.canSet(_ele)) {\n                                _ele._private[p.field][k] = v;\n                            }\n                        }\n                    }\n                }\n                // update mappers if asked\n                if (p.updateStyle) {\n                    self1.updateStyle();\n                }\n                // call onSet callback\n                p.onSet(self1);\n                if (p.settingTriggersEvent) {\n                    self1[p.triggerFnName](p.settingEvent);\n                }\n            // .data(function(){ ... })\n            } else if (p.allowBinding && fn$6(name)) {\n                // bind to event\n                var fn = name;\n                self1.on(p.bindingEvent, fn);\n            // .data()\n            } else if (p.allowGetting && name === undefined) {\n                // get whole object\n                var _ret;\n                if (single) {\n                    p.beforeGet(single);\n                    _ret = single._private[p.field];\n                }\n                return _ret;\n            }\n            return self1; // maintain chainability\n        }; // function\n    },\n    // data\n    // remove data field\n    removeData: function removeData(params) {\n        var defaults = {\n            field: \"data\",\n            event: \"data\",\n            triggerFnName: \"trigger\",\n            triggerEvent: false,\n            immutableKeys: {} // key => true if immutable\n        };\n        params = extend({}, defaults, params);\n        return function removeDataImpl(names) {\n            var p = params;\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            // .removeData('foo bar')\n            if (string(names)) {\n                // then get the list of keys, and delete them\n                var keys = names.split(/\\s+/);\n                var l = keys.length;\n                for(var i = 0; i < l; i++){\n                    // delete each non-empty key\n                    var key = keys[i];\n                    if (emptyString(key)) {\n                        continue;\n                    }\n                    var valid = !p.immutableKeys[key]; // not valid if immutable\n                    if (valid) {\n                        for(var i_a = 0, l_a = all.length; i_a < l_a; i_a++){\n                            all[i_a]._private[p.field][key] = undefined;\n                        }\n                    }\n                }\n                if (p.triggerEvent) {\n                    self1[p.triggerFnName](p.event);\n                }\n            // .removeData()\n            } else if (names === undefined) {\n                // then delete all keys\n                for(var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++){\n                    var _privateFields = all[_i_a]._private[p.field];\n                    var _keys = Object.keys(_privateFields);\n                    for(var _i2 = 0; _i2 < _keys.length; _i2++){\n                        var _key = _keys[_i2];\n                        var validKeyToDelete = !p.immutableKeys[_key];\n                        if (validKeyToDelete) {\n                            _privateFields[_key] = undefined;\n                        }\n                    }\n                }\n                if (p.triggerEvent) {\n                    self1[p.triggerFnName](p.event);\n                }\n            }\n            return self1; // maintain chaining\n        }; // function\n    } // removeData\n}; // define\nvar define$1 = {\n    eventAliasesOn: function eventAliasesOn(proto) {\n        var p = proto;\n        p.addListener = p.listen = p.bind = p.on;\n        p.unlisten = p.unbind = p.off = p.removeListener;\n        p.trigger = p.emit;\n        // this is just a wrapper alias of .on()\n        p.pon = p.promiseOn = function(events, selector) {\n            var self1 = this;\n            var args = Array.prototype.slice.call(arguments, 0);\n            return new Promise$1(function(resolve, reject) {\n                var callback = function callback(e) {\n                    self1.off.apply(self1, offArgs);\n                    resolve(e);\n                };\n                var onArgs = args.concat([\n                    callback\n                ]);\n                var offArgs = onArgs.concat([]);\n                self1.on.apply(self1, onArgs);\n            });\n        };\n    }\n}; // define\n// use this module to cherry pick functions into your prototype\n// (useful for functions shared between the core and collections, for example)\nvar define = {};\n[\n    define$3,\n    define$2,\n    define$1\n].forEach(function(m1) {\n    extend(define, m1);\n});\nvar elesfn$i = {\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop()\n};\nvar elesfn$h = {\n    classes: function classes(_classes) {\n        var self1 = this;\n        if (_classes === undefined) {\n            var ret = [];\n            self1[0]._private.classes.forEach(function(cls) {\n                return ret.push(cls);\n            });\n            return ret;\n        } else if (!array(_classes)) {\n            // extract classes from string\n            _classes = (_classes || \"\").match(/\\S+/g) || [];\n        }\n        var changed = [];\n        var classesSet = new Set$1(_classes);\n        // check and update each ele\n        for(var j = 0; j < self1.length; j++){\n            var ele = self1[j];\n            var _p = ele._private;\n            var eleClasses = _p.classes;\n            var changedEle = false;\n            // check if ele has all of the passed classes\n            for(var i = 0; i < _classes.length; i++){\n                var cls = _classes[i];\n                var eleHasClass = eleClasses.has(cls);\n                if (!eleHasClass) {\n                    changedEle = true;\n                    break;\n                }\n            }\n            // check if ele has classes outside of those passed\n            if (!changedEle) {\n                changedEle = eleClasses.size !== _classes.length;\n            }\n            if (changedEle) {\n                _p.classes = classesSet;\n                changed.push(ele);\n            }\n        }\n        // trigger update style on those eles that had class changes\n        if (changed.length > 0) {\n            this.spawn(changed).updateStyle().emit(\"class\");\n        }\n        return self1;\n    },\n    addClass: function addClass(classes) {\n        return this.toggleClass(classes, true);\n    },\n    hasClass: function hasClass(className) {\n        var ele = this[0];\n        return ele != null && ele._private.classes.has(className);\n    },\n    toggleClass: function toggleClass(classes, toggle) {\n        if (!array(classes)) {\n            // extract classes from string\n            classes = classes.match(/\\S+/g) || [];\n        }\n        var self1 = this;\n        var toggleUndefd = toggle === undefined;\n        var changed = []; // eles who had classes changed\n        for(var i = 0, il = self1.length; i < il; i++){\n            var ele = self1[i];\n            var eleClasses = ele._private.classes;\n            var changedEle = false;\n            for(var j = 0; j < classes.length; j++){\n                var cls = classes[j];\n                var hasClass = eleClasses.has(cls);\n                var changedNow = false;\n                if (toggle || toggleUndefd && !hasClass) {\n                    eleClasses.add(cls);\n                    changedNow = true;\n                } else if (!toggle || toggleUndefd && hasClass) {\n                    eleClasses[\"delete\"](cls);\n                    changedNow = true;\n                }\n                if (!changedEle && changedNow) {\n                    changed.push(ele);\n                    changedEle = true;\n                }\n            } // for j classes\n        } // for i eles\n        // trigger update style on those eles that had class changes\n        if (changed.length > 0) {\n            this.spawn(changed).updateStyle().emit(\"class\");\n        }\n        return self1;\n    },\n    removeClass: function removeClass(classes) {\n        return this.toggleClass(classes, false);\n    },\n    flashClass: function flashClass(classes, duration) {\n        var self1 = this;\n        if (duration == null) {\n            duration = 250;\n        } else if (duration === 0) {\n            return self1; // nothing to do really\n        }\n        self1.addClass(classes);\n        setTimeout(function() {\n            self1.removeClass(classes);\n        }, duration);\n        return self1;\n    }\n};\nelesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n// tokens in the query language\nvar tokens = {\n    metaChar: \"[\\\\!\\\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]\",\n    // chars we need to escape in let names, etc\n    comparatorOp: \"=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=\",\n    // binary comparison op (used in data selectors)\n    boolOp: \"\\\\?|\\\\!|\\\\^\",\n    // boolean (unary) operators (used in data selectors)\n    string: '\"(?:\\\\\\\\\"|[^\"])*\"' + \"|\" + \"'(?:\\\\\\\\'|[^'])*'\",\n    // string literals (used in data selectors) -- doublequotes | singlequotes\n    number: number,\n    // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n    meta: \"degree|indegree|outdegree\",\n    // allowed metadata fields (i.e. allowed functions to use from Collection)\n    separator: \"\\\\s*,\\\\s*\",\n    // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n    descendant: \"\\\\s+\",\n    child: \"\\\\s+>\\\\s+\",\n    subject: \"\\\\$\",\n    group: \"node|edge|\\\\*\",\n    directedEdge: \"\\\\s+->\\\\s+\",\n    undirectedEdge: \"\\\\s+<->\\\\s+\"\n};\ntokens.variable = \"(?:[\\\\w-.]|(?:\\\\\\\\\" + tokens.metaChar + \"))+\"; // a variable name can have letters, numbers, dashes, and periods\ntokens.className = \"(?:[\\\\w-]|(?:\\\\\\\\\" + tokens.metaChar + \"))+\"; // a class name has the same rules as a variable except it can't have a '.' in the name\ntokens.value = tokens.string + \"|\" + tokens.number; // a value literal, either a string or number\ntokens.id = tokens.variable; // an element id (follows variable conventions)\n(function() {\n    var ops, op, i;\n    // add @ variants to comparatorOp\n    ops = tokens.comparatorOp.split(\"|\");\n    for(i = 0; i < ops.length; i++){\n        op = ops[i];\n        tokens.comparatorOp += \"|@\" + op;\n    }\n    // add ! variants to comparatorOp\n    ops = tokens.comparatorOp.split(\"|\");\n    for(i = 0; i < ops.length; i++){\n        op = ops[i];\n        if (op.indexOf(\"!\") >= 0) {\n            continue;\n        } // skip ops that explicitly contain !\n        if (op === \"=\") {\n            continue;\n        } // skip = b/c != is explicitly defined\n        tokens.comparatorOp += \"|\\\\!\" + op;\n    }\n})();\n/**\n * Make a new query object\n *\n * @prop type {Type} The type enum (int) of the query\n * @prop checks List of checks to make against an ele to test for a match\n */ var newQuery = function newQuery() {\n    return {\n        checks: []\n    };\n};\n/**\n * A check type enum-like object.  Uses integer values for fast match() lookup.\n * The ordering does not matter as long as the ints are unique.\n */ var Type = {\n    /** E.g. node */ GROUP: 0,\n    /** A collection of elements */ COLLECTION: 1,\n    /** A filter(ele) function */ FILTER: 2,\n    /** E.g. [foo > 1] */ DATA_COMPARE: 3,\n    /** E.g. [foo] */ DATA_EXIST: 4,\n    /** E.g. [?foo] */ DATA_BOOL: 5,\n    /** E.g. [[degree > 2]] */ META_COMPARE: 6,\n    /** E.g. :selected */ STATE: 7,\n    /** E.g. #foo */ ID: 8,\n    /** E.g. .foo */ CLASS: 9,\n    /** E.g. #foo <-> #bar */ UNDIRECTED_EDGE: 10,\n    /** E.g. #foo -> #bar */ DIRECTED_EDGE: 11,\n    /** E.g. $#foo -> #bar */ NODE_SOURCE: 12,\n    /** E.g. #foo -> $#bar */ NODE_TARGET: 13,\n    /** E.g. $#foo <-> #bar */ NODE_NEIGHBOR: 14,\n    /** E.g. #foo > #bar */ CHILD: 15,\n    /** E.g. #foo #bar */ DESCENDANT: 16,\n    /** E.g. $#foo > #bar */ PARENT: 17,\n    /** E.g. $#foo #bar */ ANCESTOR: 18,\n    /** E.g. #foo > $bar > #baz */ COMPOUND_SPLIT: 19,\n    /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */ TRUE: 20\n};\nvar stateSelectors = [\n    {\n        selector: \":selected\",\n        matches: function matches(ele) {\n            return ele.selected();\n        }\n    },\n    {\n        selector: \":unselected\",\n        matches: function matches(ele) {\n            return !ele.selected();\n        }\n    },\n    {\n        selector: \":selectable\",\n        matches: function matches(ele) {\n            return ele.selectable();\n        }\n    },\n    {\n        selector: \":unselectable\",\n        matches: function matches(ele) {\n            return !ele.selectable();\n        }\n    },\n    {\n        selector: \":locked\",\n        matches: function matches(ele) {\n            return ele.locked();\n        }\n    },\n    {\n        selector: \":unlocked\",\n        matches: function matches(ele) {\n            return !ele.locked();\n        }\n    },\n    {\n        selector: \":visible\",\n        matches: function matches(ele) {\n            return ele.visible();\n        }\n    },\n    {\n        selector: \":hidden\",\n        matches: function matches(ele) {\n            return !ele.visible();\n        }\n    },\n    {\n        selector: \":transparent\",\n        matches: function matches(ele) {\n            return ele.transparent();\n        }\n    },\n    {\n        selector: \":grabbed\",\n        matches: function matches(ele) {\n            return ele.grabbed();\n        }\n    },\n    {\n        selector: \":free\",\n        matches: function matches(ele) {\n            return !ele.grabbed();\n        }\n    },\n    {\n        selector: \":removed\",\n        matches: function matches(ele) {\n            return ele.removed();\n        }\n    },\n    {\n        selector: \":inside\",\n        matches: function matches(ele) {\n            return !ele.removed();\n        }\n    },\n    {\n        selector: \":grabbable\",\n        matches: function matches(ele) {\n            return ele.grabbable();\n        }\n    },\n    {\n        selector: \":ungrabbable\",\n        matches: function matches(ele) {\n            return !ele.grabbable();\n        }\n    },\n    {\n        selector: \":animated\",\n        matches: function matches(ele) {\n            return ele.animated();\n        }\n    },\n    {\n        selector: \":unanimated\",\n        matches: function matches(ele) {\n            return !ele.animated();\n        }\n    },\n    {\n        selector: \":parent\",\n        matches: function matches(ele) {\n            return ele.isParent();\n        }\n    },\n    {\n        selector: \":childless\",\n        matches: function matches(ele) {\n            return ele.isChildless();\n        }\n    },\n    {\n        selector: \":child\",\n        matches: function matches(ele) {\n            return ele.isChild();\n        }\n    },\n    {\n        selector: \":orphan\",\n        matches: function matches(ele) {\n            return ele.isOrphan();\n        }\n    },\n    {\n        selector: \":nonorphan\",\n        matches: function matches(ele) {\n            return ele.isChild();\n        }\n    },\n    {\n        selector: \":compound\",\n        matches: function matches(ele) {\n            if (ele.isNode()) {\n                return ele.isParent();\n            } else {\n                return ele.source().isParent() || ele.target().isParent();\n            }\n        }\n    },\n    {\n        selector: \":loop\",\n        matches: function matches(ele) {\n            return ele.isLoop();\n        }\n    },\n    {\n        selector: \":simple\",\n        matches: function matches(ele) {\n            return ele.isSimple();\n        }\n    },\n    {\n        selector: \":active\",\n        matches: function matches(ele) {\n            return ele.active();\n        }\n    },\n    {\n        selector: \":inactive\",\n        matches: function matches(ele) {\n            return !ele.active();\n        }\n    },\n    {\n        selector: \":backgrounding\",\n        matches: function matches(ele) {\n            return ele.backgrounding();\n        }\n    },\n    {\n        selector: \":nonbackgrounding\",\n        matches: function matches(ele) {\n            return !ele.backgrounding();\n        }\n    }\n].sort(function(a, b) {\n    // n.b. selectors that are starting substrings of others must have the longer ones first\n    return descending(a.selector, b.selector);\n});\nvar lookup = function() {\n    var selToFn = {};\n    var s;\n    for(var i = 0; i < stateSelectors.length; i++){\n        s = stateSelectors[i];\n        selToFn[s.selector] = s.matches;\n    }\n    return selToFn;\n}();\nvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n    return lookup[sel](ele);\n};\nvar stateSelectorRegex = \"(\" + stateSelectors.map(function(s) {\n    return s.selector;\n}).join(\"|\") + \")\";\n// when a token like a variable has escaped meta characters, we need to clean the backslashes out\n// so that values get compared properly in Selector.filter()\nvar cleanMetaChars = function cleanMetaChars(str) {\n    return str.replace(new RegExp(\"\\\\\\\\(\" + tokens.metaChar + \")\", \"g\"), function(match, $1) {\n        return $1;\n    });\n};\nvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n    selector[selector.length - 1] = replacementQuery;\n};\n// NOTE: add new expression syntax here to have it recognised by the parser;\n// - a query contains all adjacent (i.e. no separator in between) expressions;\n// - the current query is stored in selector[i]\n// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\nvar exprs = [\n    {\n        name: \"group\",\n        // just used for identifying when debugging\n        query: true,\n        regex: \"(\" + tokens.group + \")\",\n        populate: function populate(selector, query, _ref) {\n            var _ref2 = _slicedToArray(_ref, 1), group = _ref2[0];\n            query.checks.push({\n                type: Type.GROUP,\n                value: group === \"*\" ? group : group + \"s\"\n            });\n        }\n    },\n    {\n        name: \"state\",\n        query: true,\n        regex: stateSelectorRegex,\n        populate: function populate(selector, query, _ref3) {\n            var _ref4 = _slicedToArray(_ref3, 1), state = _ref4[0];\n            query.checks.push({\n                type: Type.STATE,\n                value: state\n            });\n        }\n    },\n    {\n        name: \"id\",\n        query: true,\n        regex: \"\\\\#(\" + tokens.id + \")\",\n        populate: function populate(selector, query, _ref5) {\n            var _ref6 = _slicedToArray(_ref5, 1), id = _ref6[0];\n            query.checks.push({\n                type: Type.ID,\n                value: cleanMetaChars(id)\n            });\n        }\n    },\n    {\n        name: \"className\",\n        query: true,\n        regex: \"\\\\.(\" + tokens.className + \")\",\n        populate: function populate(selector, query, _ref7) {\n            var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];\n            query.checks.push({\n                type: Type.CLASS,\n                value: cleanMetaChars(className)\n            });\n        }\n    },\n    {\n        name: \"dataExists\",\n        query: true,\n        regex: \"\\\\[\\\\s*(\" + tokens.variable + \")\\\\s*\\\\]\",\n        populate: function populate(selector, query, _ref9) {\n            var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];\n            query.checks.push({\n                type: Type.DATA_EXIST,\n                field: cleanMetaChars(variable)\n            });\n        }\n    },\n    {\n        name: \"dataCompare\",\n        query: true,\n        regex: \"\\\\[\\\\s*(\" + tokens.variable + \")\\\\s*(\" + tokens.comparatorOp + \")\\\\s*(\" + tokens.value + \")\\\\s*\\\\]\",\n        populate: function populate(selector, query, _ref11) {\n            var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value = _ref12[2];\n            var valueIsString = new RegExp(\"^\" + tokens.string + \"$\").exec(value) != null;\n            if (valueIsString) {\n                value = value.substring(1, value.length - 1);\n            } else {\n                value = parseFloat(value);\n            }\n            query.checks.push({\n                type: Type.DATA_COMPARE,\n                field: cleanMetaChars(variable),\n                operator: comparatorOp,\n                value: value\n            });\n        }\n    },\n    {\n        name: \"dataBool\",\n        query: true,\n        regex: \"\\\\[\\\\s*(\" + tokens.boolOp + \")\\\\s*(\" + tokens.variable + \")\\\\s*\\\\]\",\n        populate: function populate(selector, query, _ref13) {\n            var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];\n            query.checks.push({\n                type: Type.DATA_BOOL,\n                field: cleanMetaChars(variable),\n                operator: boolOp\n            });\n        }\n    },\n    {\n        name: \"metaCompare\",\n        query: true,\n        regex: \"\\\\[\\\\[\\\\s*(\" + tokens.meta + \")\\\\s*(\" + tokens.comparatorOp + \")\\\\s*(\" + tokens.number + \")\\\\s*\\\\]\\\\]\",\n        populate: function populate(selector, query, _ref15) {\n            var _ref16 = _slicedToArray(_ref15, 3), meta = _ref16[0], comparatorOp = _ref16[1], number = _ref16[2];\n            query.checks.push({\n                type: Type.META_COMPARE,\n                field: cleanMetaChars(meta),\n                operator: comparatorOp,\n                value: parseFloat(number)\n            });\n        }\n    },\n    {\n        name: \"nextQuery\",\n        separator: true,\n        regex: tokens.separator,\n        populate: function populate(selector, query) {\n            var currentSubject = selector.currentSubject;\n            var edgeCount = selector.edgeCount;\n            var compoundCount = selector.compoundCount;\n            var lastQ = selector[selector.length - 1];\n            if (currentSubject != null) {\n                lastQ.subject = currentSubject;\n                selector.currentSubject = null;\n            }\n            lastQ.edgeCount = edgeCount;\n            lastQ.compoundCount = compoundCount;\n            selector.edgeCount = 0;\n            selector.compoundCount = 0;\n            // go on to next query\n            var nextQuery = selector[selector.length++] = newQuery();\n            return nextQuery; // this is the new query to be filled by the following exprs\n        }\n    },\n    {\n        name: \"directedEdge\",\n        separator: true,\n        regex: tokens.directedEdge,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // undirected edge\n                var edgeQuery = newQuery();\n                var source = query;\n                var target = newQuery();\n                edgeQuery.checks.push({\n                    type: Type.DIRECTED_EDGE,\n                    source: source,\n                    target: target\n                });\n                // the query in the selector should be the edge rather than the source\n                replaceLastQuery(selector, query, edgeQuery);\n                selector.edgeCount++;\n                // we're now populating the target query with expressions that follow\n                return target;\n            } else {\n                // source/target\n                var srcTgtQ = newQuery();\n                var _source = query;\n                var _target = newQuery();\n                srcTgtQ.checks.push({\n                    type: Type.NODE_SOURCE,\n                    source: _source,\n                    target: _target\n                });\n                // the query in the selector should be the neighbourhood rather than the node\n                replaceLastQuery(selector, query, srcTgtQ);\n                selector.edgeCount++;\n                return _target; // now populating the target with the following expressions\n            }\n        }\n    },\n    {\n        name: \"undirectedEdge\",\n        separator: true,\n        regex: tokens.undirectedEdge,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // undirected edge\n                var edgeQuery = newQuery();\n                var source = query;\n                var target = newQuery();\n                edgeQuery.checks.push({\n                    type: Type.UNDIRECTED_EDGE,\n                    nodes: [\n                        source,\n                        target\n                    ]\n                });\n                // the query in the selector should be the edge rather than the source\n                replaceLastQuery(selector, query, edgeQuery);\n                selector.edgeCount++;\n                // we're now populating the target query with expressions that follow\n                return target;\n            } else {\n                // neighbourhood\n                var nhoodQ = newQuery();\n                var node = query;\n                var neighbor = newQuery();\n                nhoodQ.checks.push({\n                    type: Type.NODE_NEIGHBOR,\n                    node: node,\n                    neighbor: neighbor\n                });\n                // the query in the selector should be the neighbourhood rather than the node\n                replaceLastQuery(selector, query, nhoodQ);\n                return neighbor; // now populating the neighbor with following expressions\n            }\n        }\n    },\n    {\n        name: \"child\",\n        separator: true,\n        regex: tokens.child,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // default: child query\n                var parentChildQuery = newQuery();\n                var child = newQuery();\n                var parent = selector[selector.length - 1];\n                parentChildQuery.checks.push({\n                    type: Type.CHILD,\n                    parent: parent,\n                    child: child\n                });\n                // the query in the selector should be the '>' itself\n                replaceLastQuery(selector, query, parentChildQuery);\n                selector.compoundCount++;\n                // we're now populating the child query with expressions that follow\n                return child;\n            } else if (selector.currentSubject === query) {\n                // compound split query\n                var compound = newQuery();\n                var left = selector[selector.length - 1];\n                var right = newQuery();\n                var subject = newQuery();\n                var _child = newQuery();\n                var _parent = newQuery();\n                // set up the root compound q\n                compound.checks.push({\n                    type: Type.COMPOUND_SPLIT,\n                    left: left,\n                    right: right,\n                    subject: subject\n                });\n                // populate the subject and replace the q at the old spot (within left) with TRUE\n                subject.checks = query.checks; // take the checks from the left\n                query.checks = [\n                    {\n                        type: Type.TRUE\n                    }\n                ]; // checks under left refs the subject implicitly\n                // set up the right q\n                _parent.checks.push({\n                    type: Type.TRUE\n                }); // parent implicitly refs the subject\n                right.checks.push({\n                    type: Type.PARENT,\n                    // type is swapped on right side queries\n                    parent: _parent,\n                    child: _child // empty for now\n                });\n                replaceLastQuery(selector, left, compound);\n                // update the ref since we moved things around for `query`\n                selector.currentSubject = subject;\n                selector.compoundCount++;\n                return _child; // now populating the right side's child\n            } else {\n                // parent query\n                // info for parent query\n                var _parent2 = newQuery();\n                var _child2 = newQuery();\n                var pcQChecks = [\n                    {\n                        type: Type.PARENT,\n                        parent: _parent2,\n                        child: _child2\n                    }\n                ];\n                // the parent-child query takes the place of the query previously being populated\n                _parent2.checks = query.checks; // the previous query contains the checks for the parent\n                query.checks = pcQChecks; // pc query takes over\n                selector.compoundCount++;\n                return _child2; // we're now populating the child\n            }\n        }\n    },\n    {\n        name: \"descendant\",\n        separator: true,\n        regex: tokens.descendant,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // default: descendant query\n                var ancChQuery = newQuery();\n                var descendant = newQuery();\n                var ancestor = selector[selector.length - 1];\n                ancChQuery.checks.push({\n                    type: Type.DESCENDANT,\n                    ancestor: ancestor,\n                    descendant: descendant\n                });\n                // the query in the selector should be the '>' itself\n                replaceLastQuery(selector, query, ancChQuery);\n                selector.compoundCount++;\n                // we're now populating the descendant query with expressions that follow\n                return descendant;\n            } else if (selector.currentSubject === query) {\n                // compound split query\n                var compound = newQuery();\n                var left = selector[selector.length - 1];\n                var right = newQuery();\n                var subject = newQuery();\n                var _descendant = newQuery();\n                var _ancestor = newQuery();\n                // set up the root compound q\n                compound.checks.push({\n                    type: Type.COMPOUND_SPLIT,\n                    left: left,\n                    right: right,\n                    subject: subject\n                });\n                // populate the subject and replace the q at the old spot (within left) with TRUE\n                subject.checks = query.checks; // take the checks from the left\n                query.checks = [\n                    {\n                        type: Type.TRUE\n                    }\n                ]; // checks under left refs the subject implicitly\n                // set up the right q\n                _ancestor.checks.push({\n                    type: Type.TRUE\n                }); // ancestor implicitly refs the subject\n                right.checks.push({\n                    type: Type.ANCESTOR,\n                    // type is swapped on right side queries\n                    ancestor: _ancestor,\n                    descendant: _descendant // empty for now\n                });\n                replaceLastQuery(selector, left, compound);\n                // update the ref since we moved things around for `query`\n                selector.currentSubject = subject;\n                selector.compoundCount++;\n                return _descendant; // now populating the right side's descendant\n            } else {\n                // ancestor query\n                // info for parent query\n                var _ancestor2 = newQuery();\n                var _descendant2 = newQuery();\n                var adQChecks = [\n                    {\n                        type: Type.ANCESTOR,\n                        ancestor: _ancestor2,\n                        descendant: _descendant2\n                    }\n                ];\n                // the parent-child query takes the place of the query previously being populated\n                _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n                query.checks = adQChecks; // pc query takes over\n                selector.compoundCount++;\n                return _descendant2; // we're now populating the child\n            }\n        }\n    },\n    {\n        name: \"subject\",\n        modifier: true,\n        regex: tokens.subject,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject != null && selector.currentSubject !== query) {\n                warn(\"Redefinition of subject in selector `\" + selector.toString() + \"`\");\n                return false;\n            }\n            selector.currentSubject = query;\n            var topQ = selector[selector.length - 1];\n            var topChk = topQ.checks[0];\n            var topType = topChk == null ? null : topChk.type;\n            if (topType === Type.DIRECTED_EDGE) {\n                // directed edge with subject on the target\n                // change to target node check\n                topChk.type = Type.NODE_TARGET;\n            } else if (topType === Type.UNDIRECTED_EDGE) {\n                // undirected edge with subject on the second node\n                // change to neighbor check\n                topChk.type = Type.NODE_NEIGHBOR;\n                topChk.node = topChk.nodes[1]; // second node is subject\n                topChk.neighbor = topChk.nodes[0];\n                // clean up unused fields for new type\n                topChk.nodes = null;\n            }\n        }\n    }\n];\nexprs.forEach(function(e) {\n    return e.regexObj = new RegExp(\"^\" + e.regex);\n});\n/**\n * Of all the expressions, find the first match in the remaining text.\n * @param {string} remaining The remaining text to parse\n * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n */ var consumeExpr = function consumeExpr(remaining) {\n    var expr;\n    var match;\n    var name;\n    for(var j = 0; j < exprs.length; j++){\n        var e = exprs[j];\n        var n = e.name;\n        var m1 = remaining.match(e.regexObj);\n        if (m1 != null) {\n            match = m1;\n            expr = e;\n            name = n;\n            var consumed = m1[0];\n            remaining = remaining.substring(consumed.length);\n            break; // we've consumed one expr, so we can return now\n        }\n    }\n    return {\n        expr: expr,\n        match: match,\n        name: name,\n        remaining: remaining\n    };\n};\n/**\n * Consume all the leading whitespace\n * @param {string} remaining The text to consume\n * @returns The text with the leading whitespace removed\n */ var consumeWhitespace = function consumeWhitespace(remaining) {\n    var match = remaining.match(/^\\s+/);\n    if (match) {\n        var consumed = match[0];\n        remaining = remaining.substring(consumed.length);\n    }\n    return remaining;\n};\n/**\n * Parse the string and store the parsed representation in the Selector.\n * @param {string} selector The selector string\n * @returns `true` if the selector was successfully parsed, `false` otherwise\n */ var parse = function parse(selector) {\n    var self1 = this;\n    var remaining = self1.inputText = selector;\n    var currentQuery = self1[0] = newQuery();\n    self1.length = 1;\n    remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n    for(;;){\n        var exprInfo = consumeExpr(remaining);\n        if (exprInfo.expr == null) {\n            warn(\"The selector `\" + selector + \"`is invalid\");\n            return false;\n        } else {\n            var args = exprInfo.match.slice(1);\n            // let the token populate the selector object in currentQuery\n            var ret = exprInfo.expr.populate(self1, currentQuery, args);\n            if (ret === false) {\n                return false; // exit if population failed\n            } else if (ret != null) {\n                currentQuery = ret; // change the current query to be filled if the expr specifies\n            }\n        }\n        remaining = exprInfo.remaining;\n        // we're done when there's nothing left to parse\n        if (remaining.match(/^\\s*$/)) {\n            break;\n        }\n    }\n    var lastQ = self1[self1.length - 1];\n    if (self1.currentSubject != null) {\n        lastQ.subject = self1.currentSubject;\n    }\n    lastQ.edgeCount = self1.edgeCount;\n    lastQ.compoundCount = self1.compoundCount;\n    for(var i = 0; i < self1.length; i++){\n        var q = self1[i];\n        // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n        if (q.compoundCount > 0 && q.edgeCount > 0) {\n            warn(\"The selector `\" + selector + \"` is invalid because it uses both a compound selector and an edge selector\");\n            return false;\n        }\n        if (q.edgeCount > 1) {\n            warn(\"The selector `\" + selector + \"` is invalid because it uses multiple edge selectors\");\n            return false;\n        } else if (q.edgeCount === 1) {\n            warn(\"The selector `\" + selector + \"` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.\");\n        }\n    }\n    return true; // success\n};\n/**\n * Get the selector represented as a string.  This value uses default formatting,\n * so things like spacing may differ from the input text passed to the constructor.\n * @returns {string} The selector string\n */ var toString = function toString() {\n    if (this.toStringCache != null) {\n        return this.toStringCache;\n    }\n    var clean = function clean(obj) {\n        if (obj == null) {\n            return \"\";\n        } else {\n            return obj;\n        }\n    };\n    var cleanVal = function cleanVal(val) {\n        if (string(val)) {\n            return '\"' + val + '\"';\n        } else {\n            return clean(val);\n        }\n    };\n    var space = function space(val) {\n        return \" \" + val + \" \";\n    };\n    var checkToString = function checkToString(check, subject) {\n        var type = check.type, value = check.value;\n        switch(type){\n            case Type.GROUP:\n                {\n                    var group = clean(value);\n                    return group.substring(0, group.length - 1);\n                }\n            case Type.DATA_COMPARE:\n                {\n                    var field = check.field, operator = check.operator;\n                    return \"[\" + field + space(clean(operator)) + cleanVal(value) + \"]\";\n                }\n            case Type.DATA_BOOL:\n                {\n                    var _operator = check.operator, _field = check.field;\n                    return \"[\" + clean(_operator) + _field + \"]\";\n                }\n            case Type.DATA_EXIST:\n                {\n                    var _field2 = check.field;\n                    return \"[\" + _field2 + \"]\";\n                }\n            case Type.META_COMPARE:\n                {\n                    var _operator2 = check.operator, _field3 = check.field;\n                    return \"[[\" + _field3 + space(clean(_operator2)) + cleanVal(value) + \"]]\";\n                }\n            case Type.STATE:\n                {\n                    return value;\n                }\n            case Type.ID:\n                {\n                    return \"#\" + value;\n                }\n            case Type.CLASS:\n                {\n                    return \".\" + value;\n                }\n            case Type.PARENT:\n            case Type.CHILD:\n                {\n                    return queryToString(check.parent, subject) + space(\">\") + queryToString(check.child, subject);\n                }\n            case Type.ANCESTOR:\n            case Type.DESCENDANT:\n                {\n                    return queryToString(check.ancestor, subject) + \" \" + queryToString(check.descendant, subject);\n                }\n            case Type.COMPOUND_SPLIT:\n                {\n                    var lhs = queryToString(check.left, subject);\n                    var sub = queryToString(check.subject, subject);\n                    var rhs = queryToString(check.right, subject);\n                    return lhs + (lhs.length > 0 ? \" \" : \"\") + sub + rhs;\n                }\n            case Type.TRUE:\n                {\n                    return \"\";\n                }\n        }\n    };\n    var queryToString = function queryToString(query, subject) {\n        return query.checks.reduce(function(str, chk, i) {\n            return str + (subject === query && i === 0 ? \"$\" : \"\") + checkToString(chk, subject);\n        }, \"\");\n    };\n    var str = \"\";\n    for(var i = 0; i < this.length; i++){\n        var query = this[i];\n        str += queryToString(query, query.subject);\n        if (this.length > 1 && i < this.length - 1) {\n            str += \", \";\n        }\n    }\n    this.toStringCache = str;\n    return str;\n};\nvar parse$1 = {\n    parse: parse,\n    toString: toString\n};\nvar valCmp = function valCmp(fieldVal, operator, value) {\n    var matches;\n    var isFieldStr = string(fieldVal);\n    var isFieldNum = number$1(fieldVal);\n    var isValStr = string(value);\n    var fieldStr, valStr;\n    var caseInsensitive = false;\n    var notExpr = false;\n    var isIneqCmp = false;\n    if (operator.indexOf(\"!\") >= 0) {\n        operator = operator.replace(\"!\", \"\");\n        notExpr = true;\n    }\n    if (operator.indexOf(\"@\") >= 0) {\n        operator = operator.replace(\"@\", \"\");\n        caseInsensitive = true;\n    }\n    if (isFieldStr || isValStr || caseInsensitive) {\n        fieldStr = !isFieldStr && !isFieldNum ? \"\" : \"\" + fieldVal;\n        valStr = \"\" + value;\n    }\n    // if we're doing a case insensitive comparison, then we're using a STRING comparison\n    // even if we're comparing numbers\n    if (caseInsensitive) {\n        fieldVal = fieldStr = fieldStr.toLowerCase();\n        value = valStr = valStr.toLowerCase();\n    }\n    switch(operator){\n        case \"*=\":\n            matches = fieldStr.indexOf(valStr) >= 0;\n            break;\n        case \"$=\":\n            matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n            break;\n        case \"^=\":\n            matches = fieldStr.indexOf(valStr) === 0;\n            break;\n        case \"=\":\n            matches = fieldVal === value;\n            break;\n        case \">\":\n            isIneqCmp = true;\n            matches = fieldVal > value;\n            break;\n        case \">=\":\n            isIneqCmp = true;\n            matches = fieldVal >= value;\n            break;\n        case \"<\":\n            isIneqCmp = true;\n            matches = fieldVal < value;\n            break;\n        case \"<=\":\n            isIneqCmp = true;\n            matches = fieldVal <= value;\n            break;\n        default:\n            matches = false;\n            break;\n    }\n    // apply the not op, but null vals for inequalities should always stay non-matching\n    if (notExpr && (fieldVal != null || !isIneqCmp)) {\n        matches = !matches;\n    }\n    return matches;\n};\nvar boolCmp = function boolCmp(fieldVal, operator) {\n    switch(operator){\n        case \"?\":\n            return fieldVal ? true : false;\n        case \"!\":\n            return fieldVal ? false : true;\n        case \"^\":\n            return fieldVal === undefined;\n    }\n};\nvar existCmp = function existCmp(fieldVal) {\n    return fieldVal !== undefined;\n};\nvar data$1 = function data(ele, field) {\n    return ele.data(field);\n};\nvar meta = function meta(ele, field) {\n    return ele[field]();\n};\n/** A lookup of `match(check, ele)` functions by `Type` int */ var match = [];\n/**\n * Returns whether the query matches for the element\n * @param query The `{ type, value, ... }` query object\n * @param ele The element to compare against\n*/ var matches$1 = function matches(query, ele) {\n    return query.checks.every(function(chk) {\n        return match[chk.type](chk, ele);\n    });\n};\nmatch[Type.GROUP] = function(check, ele) {\n    var group = check.value;\n    return group === \"*\" || group === ele.group();\n};\nmatch[Type.STATE] = function(check, ele) {\n    var stateSelector = check.value;\n    return stateSelectorMatches(stateSelector, ele);\n};\nmatch[Type.ID] = function(check, ele) {\n    var id = check.value;\n    return ele.id() === id;\n};\nmatch[Type.CLASS] = function(check, ele) {\n    var cls = check.value;\n    return ele.hasClass(cls);\n};\nmatch[Type.META_COMPARE] = function(check, ele) {\n    var field = check.field, operator = check.operator, value = check.value;\n    return valCmp(meta(ele, field), operator, value);\n};\nmatch[Type.DATA_COMPARE] = function(check, ele) {\n    var field = check.field, operator = check.operator, value = check.value;\n    return valCmp(data$1(ele, field), operator, value);\n};\nmatch[Type.DATA_BOOL] = function(check, ele) {\n    var field = check.field, operator = check.operator;\n    return boolCmp(data$1(ele, field), operator);\n};\nmatch[Type.DATA_EXIST] = function(check, ele) {\n    var field = check.field;\n    check.operator;\n    return existCmp(data$1(ele, field));\n};\nmatch[Type.UNDIRECTED_EDGE] = function(check, ele) {\n    var qA = check.nodes[0];\n    var qB = check.nodes[1];\n    var src = ele.source();\n    var tgt = ele.target();\n    return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n};\nmatch[Type.NODE_NEIGHBOR] = function(check, ele) {\n    return matches$1(check.node, ele) && ele.neighborhood().some(function(n) {\n        return n.isNode() && matches$1(check.neighbor, n);\n    });\n};\nmatch[Type.DIRECTED_EDGE] = function(check, ele) {\n    return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n};\nmatch[Type.NODE_SOURCE] = function(check, ele) {\n    return matches$1(check.source, ele) && ele.outgoers().some(function(n) {\n        return n.isNode() && matches$1(check.target, n);\n    });\n};\nmatch[Type.NODE_TARGET] = function(check, ele) {\n    return matches$1(check.target, ele) && ele.incomers().some(function(n) {\n        return n.isNode() && matches$1(check.source, n);\n    });\n};\nmatch[Type.CHILD] = function(check, ele) {\n    return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n};\nmatch[Type.PARENT] = function(check, ele) {\n    return matches$1(check.parent, ele) && ele.children().some(function(c) {\n        return matches$1(check.child, c);\n    });\n};\nmatch[Type.DESCENDANT] = function(check, ele) {\n    return matches$1(check.descendant, ele) && ele.ancestors().some(function(a) {\n        return matches$1(check.ancestor, a);\n    });\n};\nmatch[Type.ANCESTOR] = function(check, ele) {\n    return matches$1(check.ancestor, ele) && ele.descendants().some(function(d) {\n        return matches$1(check.descendant, d);\n    });\n};\nmatch[Type.COMPOUND_SPLIT] = function(check, ele) {\n    return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n};\nmatch[Type.TRUE] = function() {\n    return true;\n};\nmatch[Type.COLLECTION] = function(check, ele) {\n    var collection = check.value;\n    return collection.has(ele);\n};\nmatch[Type.FILTER] = function(check, ele) {\n    var filter = check.value;\n    return filter(ele);\n};\n// filter an existing collection\nvar filter = function filter(collection) {\n    var self1 = this;\n    // for 1 id #foo queries, just get the element\n    if (self1.length === 1 && self1[0].checks.length === 1 && self1[0].checks[0].type === Type.ID) {\n        return collection.getElementById(self1[0].checks[0].value).collection();\n    }\n    var selectorFunction = function selectorFunction(element) {\n        for(var j = 0; j < self1.length; j++){\n            var query = self1[j];\n            if (matches$1(query, element)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (self1.text() == null) {\n        selectorFunction = function selectorFunction() {\n            return true;\n        };\n    }\n    return collection.filter(selectorFunction);\n}; // filter\n// does selector match a single element?\nvar matches = function matches(ele) {\n    var self1 = this;\n    for(var j = 0; j < self1.length; j++){\n        var query = self1[j];\n        if (matches$1(query, ele)) {\n            return true;\n        }\n    }\n    return false;\n}; // matches\nvar matching = {\n    matches: matches,\n    filter: filter\n};\nvar Selector = function Selector(selector) {\n    this.inputText = selector;\n    this.currentSubject = null;\n    this.compoundCount = 0;\n    this.edgeCount = 0;\n    this.length = 0;\n    if (selector == null || string(selector) && selector.match(/^\\s*$/)) ;\n    else if (elementOrCollection(selector)) {\n        this.addQuery({\n            checks: [\n                {\n                    type: Type.COLLECTION,\n                    value: selector.collection()\n                }\n            ]\n        });\n    } else if (fn$6(selector)) {\n        this.addQuery({\n            checks: [\n                {\n                    type: Type.FILTER,\n                    value: selector\n                }\n            ]\n        });\n    } else if (string(selector)) {\n        if (!this.parse(selector)) {\n            this.invalid = true;\n        }\n    } else {\n        error(\"A selector must be created from a string; found \");\n    }\n};\nvar selfn = Selector.prototype;\n[\n    parse$1,\n    matching\n].forEach(function(p) {\n    return extend(selfn, p);\n});\nselfn.text = function() {\n    return this.inputText;\n};\nselfn.size = function() {\n    return this.length;\n};\nselfn.eq = function(i) {\n    return this[i];\n};\nselfn.sameText = function(otherSel) {\n    return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n};\nselfn.addQuery = function(q) {\n    this[this.length++] = q;\n};\nselfn.selector = selfn.toString;\nvar elesfn$g = {\n    allAre: function allAre(selector) {\n        var selObj = new Selector(selector);\n        return this.every(function(ele) {\n            return selObj.matches(ele);\n        });\n    },\n    is: function is(selector) {\n        var selObj = new Selector(selector);\n        return this.some(function(ele) {\n            return selObj.matches(ele);\n        });\n    },\n    some: function some(fn, thisArg) {\n        for(var i = 0; i < this.length; i++){\n            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                this[i],\n                i,\n                this\n            ]);\n            if (ret) {\n                return true;\n            }\n        }\n        return false;\n    },\n    every: function every(fn, thisArg) {\n        for(var i = 0; i < this.length; i++){\n            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                this[i],\n                i,\n                this\n            ]);\n            if (!ret) {\n                return false;\n            }\n        }\n        return true;\n    },\n    same: function same(collection) {\n        // cheap collection ref check\n        if (this === collection) {\n            return true;\n        }\n        collection = this.cy().collection(collection);\n        var thisLength = this.length;\n        var collectionLength = collection.length;\n        // cheap length check\n        if (thisLength !== collectionLength) {\n            return false;\n        }\n        // cheap element ref check\n        if (thisLength === 1) {\n            return this[0] === collection[0];\n        }\n        return this.every(function(ele) {\n            return collection.hasElementWithId(ele.id());\n        });\n    },\n    anySame: function anySame(collection) {\n        collection = this.cy().collection(collection);\n        return this.some(function(ele) {\n            return collection.hasElementWithId(ele.id());\n        });\n    },\n    allAreNeighbors: function allAreNeighbors(collection) {\n        collection = this.cy().collection(collection);\n        var nhood = this.neighborhood();\n        return collection.every(function(ele) {\n            return nhood.hasElementWithId(ele.id());\n        });\n    },\n    contains: function contains(collection) {\n        collection = this.cy().collection(collection);\n        var self1 = this;\n        return collection.every(function(ele) {\n            return self1.hasElementWithId(ele.id());\n        });\n    }\n};\nelesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\nelesfn$g.has = elesfn$g.contains;\nelesfn$g.equal = elesfn$g.equals = elesfn$g.same;\nvar cache = function cache(fn, name) {\n    return function traversalCache(arg1, arg2, arg3, arg4) {\n        var selectorOrEles = arg1;\n        var eles = this;\n        var key;\n        if (selectorOrEles == null) {\n            key = \"\";\n        } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n            key = selectorOrEles.id();\n        }\n        if (eles.length === 1 && key) {\n            var _p = eles[0]._private;\n            var tch = _p.traversalCache = _p.traversalCache || {};\n            var ch = tch[name] = tch[name] || [];\n            var hash = hashString(key);\n            var cacheHit = ch[hash];\n            if (cacheHit) {\n                return cacheHit;\n            } else {\n                return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n            }\n        } else {\n            return fn.call(eles, arg1, arg2, arg3, arg4);\n        }\n    };\n};\nvar elesfn$f = {\n    parent: function parent(selector) {\n        var parents = [];\n        // optimisation for single ele call\n        if (this.length === 1) {\n            var parent = this[0]._private.parent;\n            if (parent) {\n                return parent;\n            }\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _parent = ele._private.parent;\n            if (_parent) {\n                parents.push(_parent);\n            }\n        }\n        return this.spawn(parents, true).filter(selector);\n    },\n    parents: function parents(selector) {\n        var parents = [];\n        var eles = this.parent();\n        while(eles.nonempty()){\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                parents.push(ele);\n            }\n            eles = eles.parent();\n        }\n        return this.spawn(parents, true).filter(selector);\n    },\n    commonAncestors: function commonAncestors(selector) {\n        var ancestors;\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var parents = ele.parents();\n            ancestors = ancestors || parents;\n            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n        }\n        return ancestors.filter(selector);\n    },\n    orphans: function orphans(selector) {\n        return this.stdFilter(function(ele) {\n            return ele.isOrphan();\n        }).filter(selector);\n    },\n    nonorphans: function nonorphans(selector) {\n        return this.stdFilter(function(ele) {\n            return ele.isChild();\n        }).filter(selector);\n    },\n    children: cache(function(selector) {\n        var children = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var eleChildren = ele._private.children;\n            for(var j = 0; j < eleChildren.length; j++){\n                children.push(eleChildren[j]);\n            }\n        }\n        return this.spawn(children, true).filter(selector);\n    }, \"children\"),\n    siblings: function siblings(selector) {\n        return this.parent().children().not(this).filter(selector);\n    },\n    isParent: function isParent() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.children.length !== 0;\n        }\n    },\n    isChildless: function isChildless() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.children.length === 0;\n        }\n    },\n    isChild: function isChild() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.parent != null;\n        }\n    },\n    isOrphan: function isOrphan() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.parent == null;\n        }\n    },\n    descendants: function descendants(selector) {\n        var elements = [];\n        function add(eles) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                elements.push(ele);\n                if (ele.children().nonempty()) {\n                    add(ele.children());\n                }\n            }\n        }\n        add(this.children());\n        return this.spawn(elements, true).filter(selector);\n    }\n};\nfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n    var q = [];\n    var did = new Set$1();\n    var cy = eles.cy();\n    var hasCompounds = cy.hasCompoundNodes();\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (includeSelf) {\n            q.push(ele);\n        } else if (hasCompounds) {\n            recursiveStep(q, did, ele);\n        }\n    }\n    while(q.length > 0){\n        var _ele = q.shift();\n        fn(_ele);\n        did.add(_ele.id());\n        if (hasCompounds) {\n            recursiveStep(q, did, _ele);\n        }\n    }\n    return eles;\n}\nfunction addChildren(q, did, ele) {\n    if (ele.isParent()) {\n        var children = ele._private.children;\n        for(var i = 0; i < children.length; i++){\n            var child = children[i];\n            if (!did.has(child.id())) {\n                q.push(child);\n            }\n        }\n    }\n}\n// very efficient version of eles.add( eles.descendants() ).forEach()\n// for internal use\nelesfn$f.forEachDown = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addChildren);\n};\nfunction addParent(q, did, ele) {\n    if (ele.isChild()) {\n        var parent = ele._private.parent;\n        if (!did.has(parent.id())) {\n            q.push(parent);\n        }\n    }\n}\nelesfn$f.forEachUp = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParent);\n};\nfunction addParentAndChildren(q, did, ele) {\n    addParent(q, did, ele);\n    addChildren(q, did, ele);\n}\nelesfn$f.forEachUpAndDown = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n};\n// aliases\nelesfn$f.ancestors = elesfn$f.parents;\nvar fn$5, elesfn$e;\nfn$5 = elesfn$e = {\n    data: define.data({\n        field: \"data\",\n        bindingEvent: \"data\",\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: \"data\",\n        settingTriggersEvent: true,\n        triggerFnName: \"trigger\",\n        allowGetting: true,\n        immutableKeys: {\n            \"id\": true,\n            \"source\": true,\n            \"target\": true,\n            \"parent\": true\n        },\n        updateStyle: true\n    }),\n    removeData: define.removeData({\n        field: \"data\",\n        event: \"data\",\n        triggerFnName: \"trigger\",\n        triggerEvent: true,\n        immutableKeys: {\n            \"id\": true,\n            \"source\": true,\n            \"target\": true,\n            \"parent\": true\n        },\n        updateStyle: true\n    }),\n    scratch: define.data({\n        field: \"scratch\",\n        bindingEvent: \"scratch\",\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: \"scratch\",\n        settingTriggersEvent: true,\n        triggerFnName: \"trigger\",\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeScratch: define.removeData({\n        field: \"scratch\",\n        event: \"scratch\",\n        triggerFnName: \"trigger\",\n        triggerEvent: true,\n        updateStyle: true\n    }),\n    rscratch: define.data({\n        field: \"rscratch\",\n        allowBinding: false,\n        allowSetting: true,\n        settingTriggersEvent: false,\n        allowGetting: true\n    }),\n    removeRscratch: define.removeData({\n        field: \"rscratch\",\n        triggerEvent: false\n    }),\n    id: function id() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.data.id;\n        }\n    }\n};\n// aliases\nfn$5.attr = fn$5.data;\nfn$5.removeAttr = fn$5.removeData;\nvar data = elesfn$e;\nvar elesfn$d = {};\nfunction defineDegreeFunction(callback) {\n    return function(includeLoops) {\n        var self1 = this;\n        if (includeLoops === undefined) {\n            includeLoops = true;\n        }\n        if (self1.length === 0) {\n            return;\n        }\n        if (self1.isNode() && !self1.removed()) {\n            var degree = 0;\n            var node = self1[0];\n            var connectedEdges = node._private.edges;\n            for(var i = 0; i < connectedEdges.length; i++){\n                var edge = connectedEdges[i];\n                if (!includeLoops && edge.isLoop()) {\n                    continue;\n                }\n                degree += callback(node, edge);\n            }\n            return degree;\n        } else {\n            return;\n        }\n    };\n}\nextend(elesfn$d, {\n    degree: defineDegreeFunction(function(node, edge) {\n        if (edge.source().same(edge.target())) {\n            return 2;\n        } else {\n            return 1;\n        }\n    }),\n    indegree: defineDegreeFunction(function(node, edge) {\n        if (edge.target().same(node)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }),\n    outdegree: defineDegreeFunction(function(node, edge) {\n        if (edge.source().same(node)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    })\n});\nfunction defineDegreeBoundsFunction(degreeFn, callback) {\n    return function(includeLoops) {\n        var ret;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            var ele = nodes[i];\n            var degree = ele[degreeFn](includeLoops);\n            if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n                ret = degree;\n            }\n        }\n        return ret;\n    };\n}\nextend(elesfn$d, {\n    minDegree: defineDegreeBoundsFunction(\"degree\", function(degree, min) {\n        return degree < min;\n    }),\n    maxDegree: defineDegreeBoundsFunction(\"degree\", function(degree, max) {\n        return degree > max;\n    }),\n    minIndegree: defineDegreeBoundsFunction(\"indegree\", function(degree, min) {\n        return degree < min;\n    }),\n    maxIndegree: defineDegreeBoundsFunction(\"indegree\", function(degree, max) {\n        return degree > max;\n    }),\n    minOutdegree: defineDegreeBoundsFunction(\"outdegree\", function(degree, min) {\n        return degree < min;\n    }),\n    maxOutdegree: defineDegreeBoundsFunction(\"outdegree\", function(degree, max) {\n        return degree > max;\n    })\n});\nextend(elesfn$d, {\n    totalDegree: function totalDegree(includeLoops) {\n        var total = 0;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            total += nodes[i].degree(includeLoops);\n        }\n        return total;\n    }\n});\nvar fn$4, elesfn$c;\nvar beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (!ele.locked()) {\n            var oldPos = ele._private.position;\n            var delta = {\n                x: newPos.x != null ? newPos.x - oldPos.x : 0,\n                y: newPos.y != null ? newPos.y - oldPos.y : 0\n            };\n            if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n                ele.children().shift(delta, silent);\n            }\n            ele.dirtyBoundingBoxCache();\n        }\n    }\n};\nvar positionDef = {\n    field: \"position\",\n    bindingEvent: \"position\",\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: \"position\",\n    settingTriggersEvent: true,\n    triggerFnName: \"emitAndNotify\",\n    allowGetting: true,\n    validKeys: [\n        \"x\",\n        \"y\"\n    ],\n    beforeGet: function beforeGet(ele) {\n        ele.updateCompoundBounds();\n    },\n    beforeSet: function beforeSet(eles, newPos) {\n        beforePositionSet(eles, newPos, false);\n    },\n    onSet: function onSet(eles) {\n        eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n        return !ele.locked();\n    }\n};\nfn$4 = elesfn$c = {\n    position: define.data(positionDef),\n    // position but no notification to renderer\n    silentPosition: define.data(extend({}, positionDef, {\n        allowBinding: false,\n        allowSetting: true,\n        settingTriggersEvent: false,\n        allowGetting: false,\n        beforeSet: function beforeSet(eles, newPos) {\n            beforePositionSet(eles, newPos, true);\n        },\n        onSet: function onSet(eles) {\n            eles.dirtyCompoundBoundsCache();\n        }\n    })),\n    positions: function positions(pos, silent) {\n        if (plainObject(pos)) {\n            if (silent) {\n                this.silentPosition(pos);\n            } else {\n                this.position(pos);\n            }\n        } else if (fn$6(pos)) {\n            var _fn = pos;\n            var cy = this.cy();\n            cy.startBatch();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var _pos = undefined;\n                if (_pos = _fn(ele, i)) {\n                    if (silent) {\n                        ele.silentPosition(_pos);\n                    } else {\n                        ele.position(_pos);\n                    }\n                }\n            }\n            cy.endBatch();\n        }\n        return this; // chaining\n    },\n    silentPositions: function silentPositions(pos) {\n        return this.positions(pos, true);\n    },\n    shift: function shift(dim, val, silent) {\n        var delta;\n        if (plainObject(dim)) {\n            delta = {\n                x: number$1(dim.x) ? dim.x : 0,\n                y: number$1(dim.y) ? dim.y : 0\n            };\n            silent = val;\n        } else if (string(dim) && number$1(val)) {\n            delta = {\n                x: 0,\n                y: 0\n            };\n            delta[dim] = val;\n        }\n        if (delta != null) {\n            var cy = this.cy();\n            cy.startBatch();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                // exclude any node that is a descendant of the calling collection\n                if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n                    continue;\n                }\n                var pos = ele.position();\n                var newPos = {\n                    x: pos.x + delta.x,\n                    y: pos.y + delta.y\n                };\n                if (silent) {\n                    ele.silentPosition(newPos);\n                } else {\n                    ele.position(newPos);\n                }\n            }\n            cy.endBatch();\n        }\n        return this;\n    },\n    silentShift: function silentShift(dim, val) {\n        if (plainObject(dim)) {\n            this.shift(dim, true);\n        } else if (string(dim) && number$1(val)) {\n            this.shift(dim, val, true);\n        }\n        return this;\n    },\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function renderedPosition(dim, val) {\n        var ele = this[0];\n        var cy = this.cy();\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var rpos = plainObject(dim) ? dim : undefined;\n        var setting = rpos !== undefined || val !== undefined && string(dim);\n        if (ele && ele.isNode()) {\n            // must have an element and must be a node to return position\n            if (setting) {\n                for(var i = 0; i < this.length; i++){\n                    var _ele = this[i];\n                    if (val !== undefined) {\n                        // set one dimension\n                        _ele.position(dim, (val - pan[dim]) / zoom);\n                    } else if (rpos !== undefined) {\n                        // set whole position\n                        _ele.position(renderedToModelPosition(rpos, zoom, pan));\n                    }\n                }\n            } else {\n                // getting\n                var pos = ele.position();\n                rpos = modelToRenderedPosition$1(pos, zoom, pan);\n                if (dim === undefined) {\n                    // then return the whole rendered position\n                    return rpos;\n                } else {\n                    // then return the specified dimension\n                    return rpos[dim];\n                }\n            }\n        } else if (!setting) {\n            return undefined; // for empty collection case\n        }\n        return this; // chaining\n    },\n    // get/set the position relative to the parent\n    relativePosition: function relativePosition(dim, val) {\n        var ele = this[0];\n        var cy = this.cy();\n        var ppos = plainObject(dim) ? dim : undefined;\n        var setting = ppos !== undefined || val !== undefined && string(dim);\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        if (ele && ele.isNode()) {\n            // must have an element and must be a node to return position\n            if (setting) {\n                for(var i = 0; i < this.length; i++){\n                    var _ele2 = this[i];\n                    var parent = hasCompoundNodes ? _ele2.parent() : null;\n                    var hasParent = parent && parent.length > 0;\n                    var relativeToParent = hasParent;\n                    if (hasParent) {\n                        parent = parent[0];\n                    }\n                    var origin = relativeToParent ? parent.position() : {\n                        x: 0,\n                        y: 0\n                    };\n                    if (val !== undefined) {\n                        // set one dimension\n                        _ele2.position(dim, val + origin[dim]);\n                    } else if (ppos !== undefined) {\n                        // set whole position\n                        _ele2.position({\n                            x: ppos.x + origin.x,\n                            y: ppos.y + origin.y\n                        });\n                    }\n                }\n            } else {\n                // getting\n                var pos = ele.position();\n                var _parent = hasCompoundNodes ? ele.parent() : null;\n                var _hasParent = _parent && _parent.length > 0;\n                var _relativeToParent = _hasParent;\n                if (_hasParent) {\n                    _parent = _parent[0];\n                }\n                var _origin = _relativeToParent ? _parent.position() : {\n                    x: 0,\n                    y: 0\n                };\n                ppos = {\n                    x: pos.x - _origin.x,\n                    y: pos.y - _origin.y\n                };\n                if (dim === undefined) {\n                    // then return the whole rendered position\n                    return ppos;\n                } else {\n                    // then return the specified dimension\n                    return ppos[dim];\n                }\n            }\n        } else if (!setting) {\n            return undefined; // for empty collection case\n        }\n        return this; // chaining\n    }\n};\n// aliases\nfn$4.modelPosition = fn$4.point = fn$4.position;\nfn$4.modelPositions = fn$4.points = fn$4.positions;\nfn$4.renderedPoint = fn$4.renderedPosition;\nfn$4.relativePoint = fn$4.relativePosition;\nvar position = elesfn$c;\nvar fn$3, elesfn$b;\nfn$3 = elesfn$b = {};\nelesfn$b.renderedBoundingBox = function(options) {\n    var bb = this.boundingBox(options);\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var x1 = bb.x1 * zoom + pan.x;\n    var x2 = bb.x2 * zoom + pan.x;\n    var y1 = bb.y1 * zoom + pan.y;\n    var y2 = bb.y2 * zoom + pan.y;\n    return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n    };\n};\nelesfn$b.dirtyCompoundBoundsCache = function() {\n    var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n        return this;\n    }\n    this.forEachUp(function(ele) {\n        if (ele.isParent()) {\n            var _p = ele._private;\n            _p.compoundBoundsClean = false;\n            _p.bbCache = null;\n            if (!silent) {\n                ele.emitAndNotify(\"bounds\");\n            }\n        }\n    });\n    return this;\n};\nelesfn$b.updateCompoundBounds = function() {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n    // not possible to do on non-compound graphs or with the style disabled\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n        return this;\n    }\n    // save cycles when batching -- but bounds will be stale (or not exist yet)\n    if (!force && cy.batching()) {\n        return this;\n    }\n    function update(parent) {\n        if (!parent.isParent()) {\n            return;\n        }\n        var _p = parent._private;\n        var children = parent.children();\n        var includeLabels = parent.pstyle(\"compound-sizing-wrt-labels\").value === \"include\";\n        var min = {\n            width: {\n                val: parent.pstyle(\"min-width\").pfValue,\n                left: parent.pstyle(\"min-width-bias-left\"),\n                right: parent.pstyle(\"min-width-bias-right\")\n            },\n            height: {\n                val: parent.pstyle(\"min-height\").pfValue,\n                top: parent.pstyle(\"min-height-bias-top\"),\n                bottom: parent.pstyle(\"min-height-bias-bottom\")\n            }\n        };\n        var bb = children.boundingBox({\n            includeLabels: includeLabels,\n            includeOverlays: false,\n            // updating the compound bounds happens outside of the regular\n            // cache cycle (i.e. before fired events)\n            useCache: false\n        });\n        var pos = _p.position;\n        // if children take up zero area then keep position and fall back on stylesheet w/h\n        if (bb.w === 0 || bb.h === 0) {\n            bb = {\n                w: parent.pstyle(\"width\").pfValue,\n                h: parent.pstyle(\"height\").pfValue\n            };\n            bb.x1 = pos.x - bb.w / 2;\n            bb.x2 = pos.x + bb.w / 2;\n            bb.y1 = pos.y - bb.h / 2;\n            bb.y2 = pos.y + bb.h / 2;\n        }\n        function computeBiasValues(propDiff, propBias, propBiasComplement) {\n            var biasDiff = 0;\n            var biasComplementDiff = 0;\n            var biasTotal = propBias + propBiasComplement;\n            if (propDiff > 0 && biasTotal > 0) {\n                biasDiff = propBias / biasTotal * propDiff;\n                biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n            }\n            return {\n                biasDiff: biasDiff,\n                biasComplementDiff: biasComplementDiff\n            };\n        }\n        function computePaddingValues(width, height, paddingObject, relativeTo) {\n            // Assuming percentage is number from 0 to 1\n            if (paddingObject.units === \"%\") {\n                switch(relativeTo){\n                    case \"width\":\n                        return width > 0 ? paddingObject.pfValue * width : 0;\n                    case \"height\":\n                        return height > 0 ? paddingObject.pfValue * height : 0;\n                    case \"average\":\n                        return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n                    case \"min\":\n                        return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n                    case \"max\":\n                        return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n                    default:\n                        return 0;\n                }\n            } else if (paddingObject.units === \"px\") {\n                return paddingObject.pfValue;\n            } else {\n                return 0;\n            }\n        }\n        var leftVal = min.width.left.value;\n        if (min.width.left.units === \"px\" && min.width.val > 0) {\n            leftVal = leftVal * 100 / min.width.val;\n        }\n        var rightVal = min.width.right.value;\n        if (min.width.right.units === \"px\" && min.width.val > 0) {\n            rightVal = rightVal * 100 / min.width.val;\n        }\n        var topVal = min.height.top.value;\n        if (min.height.top.units === \"px\" && min.height.val > 0) {\n            topVal = topVal * 100 / min.height.val;\n        }\n        var bottomVal = min.height.bottom.value;\n        if (min.height.bottom.units === \"px\" && min.height.val > 0) {\n            bottomVal = bottomVal * 100 / min.height.val;\n        }\n        var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n        var diffLeft = widthBiasDiffs.biasDiff;\n        var diffRight = widthBiasDiffs.biasComplementDiff;\n        var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n        var diffTop = heightBiasDiffs.biasDiff;\n        var diffBottom = heightBiasDiffs.biasComplementDiff;\n        _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle(\"padding\"), parent.pstyle(\"padding-relative-to\").value);\n        _p.autoWidth = Math.max(bb.w, min.width.val);\n        pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n        _p.autoHeight = Math.max(bb.h, min.height.val);\n        pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n    }\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var _p = ele._private;\n        if (!_p.compoundBoundsClean || force) {\n            update(ele);\n            if (!cy.batching()) {\n                _p.compoundBoundsClean = true;\n            }\n        }\n    }\n    return this;\n};\nvar noninf = function noninf(x) {\n    if (x === Infinity || x === -Infinity) {\n        return 0;\n    }\n    return x;\n};\nvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n    // don't update with zero area boxes\n    if (x2 - x1 === 0 || y2 - y1 === 0) {\n        return;\n    }\n    // don't update with null dim\n    if (x1 == null || y1 == null || x2 == null || y2 == null) {\n        return;\n    }\n    b.x1 = x1 < b.x1 ? x1 : b.x1;\n    b.x2 = x2 > b.x2 ? x2 : b.x2;\n    b.y1 = y1 < b.y1 ? y1 : b.y1;\n    b.y2 = y2 > b.y2 ? y2 : b.y2;\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n};\nvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n    if (b2 == null) {\n        return b;\n    }\n    return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n};\nvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n    return getPrefixedProperty(obj, field, prefix);\n};\nvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var halfArW = rstyle.arrowWidth / 2;\n    var arrowType = ele.pstyle(prefix + \"-arrow-shape\").value;\n    var x;\n    var y;\n    if (arrowType !== \"none\") {\n        if (prefix === \"source\") {\n            x = rstyle.srcX;\n            y = rstyle.srcY;\n        } else if (prefix === \"target\") {\n            x = rstyle.tgtX;\n            y = rstyle.tgtY;\n        } else {\n            x = rstyle.midX;\n            y = rstyle.midY;\n        }\n        // always store the individual arrow bounds\n        var bbs = _p.arrowBounds = _p.arrowBounds || {};\n        var bb = bbs[prefix] = bbs[prefix] || {};\n        bb.x1 = x - halfArW;\n        bb.y1 = y - halfArW;\n        bb.x2 = x + halfArW;\n        bb.y2 = y + halfArW;\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n        expandBoundingBox(bb, 1);\n        updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n    }\n};\nvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var prefixDash;\n    if (prefix) {\n        prefixDash = prefix + \"-\";\n    } else {\n        prefixDash = \"\";\n    }\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var label = ele.pstyle(prefixDash + \"label\").strValue;\n    if (label) {\n        var halign = ele.pstyle(\"text-halign\");\n        var valign = ele.pstyle(\"text-valign\");\n        var labelWidth = prefixedProperty(rstyle, \"labelWidth\", prefix);\n        var labelHeight = prefixedProperty(rstyle, \"labelHeight\", prefix);\n        var labelX = prefixedProperty(rstyle, \"labelX\", prefix);\n        var labelY = prefixedProperty(rstyle, \"labelY\", prefix);\n        var marginX = ele.pstyle(prefixDash + \"text-margin-x\").pfValue;\n        var marginY = ele.pstyle(prefixDash + \"text-margin-y\").pfValue;\n        var isEdge = ele.isEdge();\n        var rotation = ele.pstyle(prefixDash + \"text-rotation\");\n        var outlineWidth = ele.pstyle(\"text-outline-width\").pfValue;\n        var borderWidth = ele.pstyle(\"text-border-width\").pfValue;\n        var halfBorderWidth = borderWidth / 2;\n        var padding = ele.pstyle(\"text-background-padding\").pfValue;\n        var marginOfError = 2; // expand to work around browser dimension inaccuracies\n        var lh = labelHeight;\n        var lw = labelWidth;\n        var lw_2 = lw / 2;\n        var lh_2 = lh / 2;\n        var lx1, lx2, ly1, ly2;\n        if (isEdge) {\n            lx1 = labelX - lw_2;\n            lx2 = labelX + lw_2;\n            ly1 = labelY - lh_2;\n            ly2 = labelY + lh_2;\n        } else {\n            switch(halign.value){\n                case \"left\":\n                    lx1 = labelX - lw;\n                    lx2 = labelX;\n                    break;\n                case \"center\":\n                    lx1 = labelX - lw_2;\n                    lx2 = labelX + lw_2;\n                    break;\n                case \"right\":\n                    lx1 = labelX;\n                    lx2 = labelX + lw;\n                    break;\n            }\n            switch(valign.value){\n                case \"top\":\n                    ly1 = labelY - lh;\n                    ly2 = labelY;\n                    break;\n                case \"center\":\n                    ly1 = labelY - lh_2;\n                    ly2 = labelY + lh_2;\n                    break;\n                case \"bottom\":\n                    ly1 = labelY;\n                    ly2 = labelY + lh;\n                    break;\n            }\n        }\n        // shift by margin and expand by outline and border\n        var leftPad = marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n        var rightPad = marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n        var topPad = marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n        var botPad = marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n        lx1 += leftPad;\n        lx2 += rightPad;\n        ly1 += topPad;\n        ly2 += botPad;\n        // always store the unrotated label bounds separately\n        var bbPrefix = prefix || \"main\";\n        var bbs = _p.labelBounds;\n        var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n        bb.x1 = lx1;\n        bb.y1 = ly1;\n        bb.x2 = lx2;\n        bb.y2 = ly2;\n        bb.w = lx2 - lx1;\n        bb.h = ly2 - ly1;\n        bb.leftPad = leftPad;\n        bb.rightPad = rightPad;\n        bb.topPad = topPad;\n        bb.botPad = botPad;\n        var isAutorotate = isEdge && rotation.strValue === \"autorotate\";\n        var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n        if (isAutorotate || isPfValue) {\n            var theta = isAutorotate ? prefixedProperty(_p.rstyle, \"labelAngle\", prefix) : rotation.pfValue;\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            // rotation point (default value for center-center)\n            var xo = (lx1 + lx2) / 2;\n            var yo = (ly1 + ly2) / 2;\n            if (!isEdge) {\n                switch(halign.value){\n                    case \"left\":\n                        xo = lx2;\n                        break;\n                    case \"right\":\n                        xo = lx1;\n                        break;\n                }\n                switch(valign.value){\n                    case \"top\":\n                        yo = ly2;\n                        break;\n                    case \"bottom\":\n                        yo = ly1;\n                        break;\n                }\n            }\n            var rotate = function rotate(x, y) {\n                x = x - xo;\n                y = y - yo;\n                return {\n                    x: x * cos - y * sin + xo,\n                    y: x * sin + y * cos + yo\n                };\n            };\n            var px1y1 = rotate(lx1, ly1);\n            var px1y2 = rotate(lx1, ly2);\n            var px2y1 = rotate(lx2, ly1);\n            var px2y2 = rotate(lx2, ly2);\n            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n        }\n        var bbPrefixRot = bbPrefix + \"Rot\";\n        var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n        bbRot.x1 = lx1;\n        bbRot.y1 = ly1;\n        bbRot.x2 = lx2;\n        bbRot.y2 = ly2;\n        bbRot.w = lx2 - lx1;\n        bbRot.h = ly2 - ly1;\n        updateBounds(bounds, lx1, ly1, lx2, ly2);\n        updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n    }\n    return bounds;\n};\nvar updateBoundsFromOutline = function updateBoundsFromOutline(bounds, ele) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var outlineOpacity = ele.pstyle(\"outline-opacity\").value;\n    var outlineWidth = ele.pstyle(\"outline-width\").value;\n    var outlineOffset = ele.pstyle(\"outline-offset\").value;\n    var expansion = outlineWidth + outlineOffset;\n    updateBoundsFromMiter(bounds, ele, outlineOpacity, expansion, \"outside\", expansion / 2);\n};\nvar updateBoundsFromMiter = function updateBoundsFromMiter(bounds, ele, opacity, expansionSize, expansionPosition, useFallbackValue) {\n    if (opacity === 0 || expansionSize <= 0 || expansionPosition === \"inside\") {\n        return;\n    }\n    var cy = ele.cy();\n    var shape = ele.pstyle(\"shape\").value;\n    var rshape = cy.renderer().nodeShapes[shape];\n    var _ele$position = ele.position(), x = _ele$position.x, y = _ele$position.y;\n    var w = ele.width();\n    var h = ele.height();\n    if (rshape.hasMiterBounds) {\n        if (expansionPosition === \"center\") {\n            expansionSize /= 2;\n        }\n        var mbb = rshape.miterBounds(x, y, w, h, expansionSize);\n        updateBoundsFromBox(bounds, mbb);\n    } else if (useFallbackValue != null && useFallbackValue > 0) {\n        expandBoundingBoxSides(bounds, [\n            useFallbackValue,\n            useFallbackValue,\n            useFallbackValue,\n            useFallbackValue\n        ]);\n    }\n};\nvar updateBoundsFromMiterBorder = function updateBoundsFromMiterBorder(bounds, ele) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var borderOpacity = ele.pstyle(\"border-opacity\").value;\n    var borderWidth = ele.pstyle(\"border-width\").pfValue;\n    var borderPosition = ele.pstyle(\"border-position\").value;\n    updateBoundsFromMiter(bounds, ele, borderOpacity, borderWidth, borderPosition);\n};\n// get the bounding box of the elements (in raw model position)\nvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n    var cy = ele._private.cy;\n    var styleEnabled = cy.styleEnabled();\n    var headless = cy.headless();\n    var bounds = makeBoundingBox();\n    var _p = ele._private;\n    var isNode = ele.isNode();\n    var isEdge = ele.isEdge();\n    var ex1, ex2, ey1, ey2; // extrema of body / lines\n    var x, y; // node pos\n    var rstyle = _p.rstyle;\n    var manualExpansion = isNode && styleEnabled ? ele.pstyle(\"bounds-expansion\").pfValue : [\n        0\n    ];\n    // must use `display` prop only, as reading `compound.width()` causes recursion\n    // (other factors like width values will be considered later in this function anyway)\n    var isDisplayed = function isDisplayed(ele) {\n        return ele.pstyle(\"display\").value !== \"none\";\n    };\n    var displayed = !styleEnabled || isDisplayed(ele) && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n    if (displayed) {\n        // displayed suffices, since we will find zero area eles anyway\n        var overlayOpacity = 0;\n        var overlayPadding = 0;\n        if (styleEnabled && options.includeOverlays) {\n            overlayOpacity = ele.pstyle(\"overlay-opacity\").value;\n            if (overlayOpacity !== 0) {\n                overlayPadding = ele.pstyle(\"overlay-padding\").value;\n            }\n        }\n        var underlayOpacity = 0;\n        var underlayPadding = 0;\n        if (styleEnabled && options.includeUnderlays) {\n            underlayOpacity = ele.pstyle(\"underlay-opacity\").value;\n            if (underlayOpacity !== 0) {\n                underlayPadding = ele.pstyle(\"underlay-padding\").value;\n            }\n        }\n        var padding = Math.max(overlayPadding, underlayPadding);\n        var w = 0;\n        var wHalf = 0;\n        if (styleEnabled) {\n            w = ele.pstyle(\"width\").pfValue;\n            wHalf = w / 2;\n        }\n        if (isNode && options.includeNodes) {\n            var pos = ele.position();\n            x = pos.x;\n            y = pos.y;\n            var _w = ele.outerWidth();\n            var halfW = _w / 2;\n            var h = ele.outerHeight();\n            var halfH = h / 2;\n            // handle node dimensions\n            /////////////////////////\n            ex1 = x - halfW;\n            ex2 = x + halfW;\n            ey1 = y - halfH;\n            ey2 = y + halfH;\n            updateBounds(bounds, ex1, ey1, ex2, ey2);\n            if (styleEnabled) {\n                updateBoundsFromOutline(bounds, ele);\n            }\n            if (styleEnabled && options.includeOutlines && !headless) {\n                updateBoundsFromOutline(bounds, ele);\n            }\n            if (styleEnabled) {\n                updateBoundsFromMiterBorder(bounds, ele);\n            }\n        } else if (isEdge && options.includeEdges) {\n            if (styleEnabled && !headless) {\n                var curveStyle = ele.pstyle(\"curve-style\").strValue;\n                // handle edge dimensions (rough box estimate)\n                //////////////////////////////////////////////\n                ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                // take into account edge width\n                ex1 -= wHalf;\n                ex2 += wHalf;\n                ey1 -= wHalf;\n                ey2 += wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n                // precise edges\n                ////////////////\n                if (curveStyle === \"haystack\") {\n                    var hpts = rstyle.haystackPts;\n                    if (hpts && hpts.length === 2) {\n                        ex1 = hpts[0].x;\n                        ey1 = hpts[0].y;\n                        ex2 = hpts[1].x;\n                        ey2 = hpts[1].y;\n                        if (ex1 > ex2) {\n                            var temp = ex1;\n                            ex1 = ex2;\n                            ex2 = temp;\n                        }\n                        if (ey1 > ey2) {\n                            var _temp = ey1;\n                            ey1 = ey2;\n                            ey2 = _temp;\n                        }\n                        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n                    }\n                } else if (curveStyle === \"bezier\" || curveStyle === \"unbundled-bezier\" || endsWith(curveStyle, \"segments\") || endsWith(curveStyle, \"taxi\")) {\n                    var pts;\n                    switch(curveStyle){\n                        case \"bezier\":\n                        case \"unbundled-bezier\":\n                            pts = rstyle.bezierPts;\n                            break;\n                        case \"segments\":\n                        case \"taxi\":\n                        case \"round-segments\":\n                        case \"round-taxi\":\n                            pts = rstyle.linePts;\n                            break;\n                    }\n                    if (pts != null) {\n                        for(var j = 0; j < pts.length; j++){\n                            var pt = pts[j];\n                            ex1 = pt.x - wHalf;\n                            ex2 = pt.x + wHalf;\n                            ey1 = pt.y - wHalf;\n                            ey2 = pt.y + wHalf;\n                            updateBounds(bounds, ex1, ey1, ex2, ey2);\n                        }\n                    }\n                } // bezier-like or segment-like edge\n            } else {\n                // headless or style disabled\n                // fallback on source and target positions\n                //////////////////////////////////////////\n                var n1 = ele.source();\n                var n1pos = n1.position();\n                var n2 = ele.target();\n                var n2pos = n2.position();\n                ex1 = n1pos.x;\n                ex2 = n2pos.x;\n                ey1 = n1pos.y;\n                ey2 = n2pos.y;\n                if (ex1 > ex2) {\n                    var _temp2 = ex1;\n                    ex1 = ex2;\n                    ex2 = _temp2;\n                }\n                if (ey1 > ey2) {\n                    var _temp3 = ey1;\n                    ey1 = ey2;\n                    ey2 = _temp3;\n                }\n                // take into account edge width\n                ex1 -= wHalf;\n                ex2 += wHalf;\n                ey1 -= wHalf;\n                ey2 += wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n            } // headless or style disabled\n        } // edges\n        // handle edge arrow size\n        /////////////////////////\n        if (styleEnabled && options.includeEdges && isEdge) {\n            updateBoundsFromArrow(bounds, ele, \"mid-source\");\n            updateBoundsFromArrow(bounds, ele, \"mid-target\");\n            updateBoundsFromArrow(bounds, ele, \"source\");\n            updateBoundsFromArrow(bounds, ele, \"target\");\n        }\n        // ghost\n        ////////\n        if (styleEnabled) {\n            var ghost = ele.pstyle(\"ghost\").value === \"yes\";\n            if (ghost) {\n                var gx = ele.pstyle(\"ghost-offset-x\").pfValue;\n                var gy = ele.pstyle(\"ghost-offset-y\").pfValue;\n                updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n            }\n        }\n        // always store the body bounds separately from the labels\n        var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n        assignBoundingBox(bbBody, bounds);\n        expandBoundingBoxSides(bbBody, manualExpansion);\n        expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n        // overlay\n        //////////\n        if (styleEnabled) {\n            ex1 = bounds.x1;\n            ex2 = bounds.x2;\n            ey1 = bounds.y1;\n            ey2 = bounds.y2;\n            updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n        }\n        // always store the body bounds separately from the labels\n        var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n        assignBoundingBox(bbOverlay, bounds);\n        expandBoundingBoxSides(bbOverlay, manualExpansion);\n        expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n        // handle label dimensions\n        //////////////////////////\n        var bbLabels = _p.labelBounds = _p.labelBounds || {};\n        if (bbLabels.all != null) {\n            clearBoundingBox(bbLabels.all);\n        } else {\n            bbLabels.all = makeBoundingBox();\n        }\n        if (styleEnabled && options.includeLabels) {\n            if (options.includeMainLabels) {\n                updateBoundsFromLabel(bounds, ele, null);\n            }\n            if (isEdge) {\n                if (options.includeSourceLabels) {\n                    updateBoundsFromLabel(bounds, ele, \"source\");\n                }\n                if (options.includeTargetLabels) {\n                    updateBoundsFromLabel(bounds, ele, \"target\");\n                }\n            }\n        } // style enabled for labels\n    } // if displayed\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    if (bounds.w > 0 && bounds.h > 0 && displayed) {\n        expandBoundingBoxSides(bounds, manualExpansion);\n        // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n        expandBoundingBox(bounds, 1);\n    }\n    return bounds;\n};\nvar getKey = function getKey(opts) {\n    var i = 0;\n    var tf = function tf(val) {\n        return (val ? 1 : 0) << i++;\n    };\n    var key = 0;\n    key += tf(opts.incudeNodes);\n    key += tf(opts.includeEdges);\n    key += tf(opts.includeLabels);\n    key += tf(opts.includeMainLabels);\n    key += tf(opts.includeSourceLabels);\n    key += tf(opts.includeTargetLabels);\n    key += tf(opts.includeOverlays);\n    key += tf(opts.includeOutlines);\n    return key;\n};\nvar getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n    var r = function r(x) {\n        return Math.round(x);\n    };\n    if (ele.isEdge()) {\n        var p1 = ele.source().position();\n        var p2 = ele.target().position();\n        return hashIntsArray([\n            r(p1.x),\n            r(p1.y),\n            r(p2.x),\n            r(p2.y)\n        ]);\n    } else {\n        var p = ele.position();\n        return hashIntsArray([\n            r(p.x),\n            r(p.y)\n        ]);\n    }\n};\nvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n    var _p = ele._private;\n    var bb;\n    var isEdge = ele.isEdge();\n    var key = opts == null ? defBbOptsKey : getKey(opts);\n    var usingDefOpts = key === defBbOptsKey;\n    if (_p.bbCache == null) {\n        bb = boundingBoxImpl(ele, defBbOpts);\n        _p.bbCache = bb;\n        _p.bbCachePosKey = getBoundingBoxPosKey(ele);\n    } else {\n        bb = _p.bbCache;\n    }\n    // not using def opts => need to build up bb from combination of sub bbs\n    if (!usingDefOpts) {\n        var isNode = ele.isNode();\n        bb = makeBoundingBox();\n        if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n            if (opts.includeOverlays) {\n                updateBoundsFromBox(bb, _p.overlayBounds);\n            } else {\n                updateBoundsFromBox(bb, _p.bodyBounds);\n            }\n        }\n        if (opts.includeLabels) {\n            if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n                updateBoundsFromBox(bb, _p.labelBounds.all);\n            } else {\n                if (opts.includeMainLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n                }\n                if (opts.includeSourceLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n                }\n                if (opts.includeTargetLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n                }\n            }\n        }\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n    }\n    return bb;\n};\nvar defBbOpts = {\n    includeNodes: true,\n    includeEdges: true,\n    includeLabels: true,\n    includeMainLabels: true,\n    includeSourceLabels: true,\n    includeTargetLabels: true,\n    includeOverlays: true,\n    includeUnderlays: true,\n    includeOutlines: true,\n    useCache: true\n};\nvar defBbOptsKey = getKey(defBbOpts);\nvar filledBbOpts = defaults$g(defBbOpts);\nelesfn$b.boundingBox = function(options) {\n    var bounds;\n    var useCache = options === undefined || options.useCache === undefined || options.useCache === true;\n    var isDirty = memoize(function(ele) {\n        var _p = ele._private;\n        return _p.bbCache == null || _p.styleDirty || _p.bbCachePosKey !== getBoundingBoxPosKey(ele);\n    }, function(ele) {\n        return ele.id();\n    });\n    // the main usecase is ele.boundingBox() for a single element with no/def options\n    // specified s.t. the cache is used, so check for this case to make it faster by\n    // avoiding the overhead of the rest of the function\n    if (useCache && this.length === 1 && !isDirty(this[0])) {\n        if (options === undefined) {\n            options = defBbOpts;\n        } else {\n            options = filledBbOpts(options);\n        }\n        bounds = cachedBoundingBoxImpl(this[0], options);\n    } else {\n        bounds = makeBoundingBox();\n        options = options || defBbOpts;\n        var opts = filledBbOpts(options);\n        var eles = this;\n        var cy = eles.cy();\n        var styleEnabled = cy.styleEnabled();\n        // cache the isDirty state for all eles, edges first since they depend on node state\n        this.edges().forEach(isDirty);\n        this.nodes().forEach(isDirty);\n        if (styleEnabled) {\n            this.recalculateRenderedStyle(useCache);\n        }\n        this.updateCompoundBounds(!useCache);\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (isDirty(ele)) {\n                ele.dirtyBoundingBoxCache();\n            }\n            updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));\n        }\n    }\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    return bounds;\n};\nelesfn$b.dirtyBoundingBoxCache = function() {\n    for(var i = 0; i < this.length; i++){\n        var _p = this[i]._private;\n        _p.bbCache = null;\n        _p.bbCachePosKey = null;\n        _p.bodyBounds = null;\n        _p.overlayBounds = null;\n        _p.labelBounds.all = null;\n        _p.labelBounds.source = null;\n        _p.labelBounds.target = null;\n        _p.labelBounds.main = null;\n        _p.labelBounds.sourceRot = null;\n        _p.labelBounds.targetRot = null;\n        _p.labelBounds.mainRot = null;\n        _p.arrowBounds.source = null;\n        _p.arrowBounds.target = null;\n        _p.arrowBounds[\"mid-source\"] = null;\n        _p.arrowBounds[\"mid-target\"] = null;\n    }\n    this.emitAndNotify(\"bounds\");\n    return this;\n};\n// private helper to get bounding box for custom node positions\n// - good for perf in certain cases but currently requires dirtying the rendered style\n// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n// - try to use for only things like discrete layouts where the node position would change anyway\nelesfn$b.boundingBoxAt = function(fn) {\n    var nodes = this.nodes();\n    var cy = this.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var parents = cy.collection();\n    if (hasCompoundNodes) {\n        parents = nodes.filter(function(node) {\n            return node.isParent();\n        });\n        nodes = nodes.not(parents);\n    }\n    if (plainObject(fn)) {\n        var obj = fn;\n        fn = function fn() {\n            return obj;\n        };\n    }\n    var storeOldPos = function storeOldPos(node, i) {\n        return node._private.bbAtOldPos = fn(node, i);\n    };\n    var getOldPos = function getOldPos(node) {\n        return node._private.bbAtOldPos;\n    };\n    cy.startBatch();\n    nodes.forEach(storeOldPos).silentPositions(fn);\n    if (hasCompoundNodes) {\n        parents.dirtyCompoundBoundsCache();\n        parents.dirtyBoundingBoxCache();\n        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n    var bb = copyBoundingBox(this.boundingBox({\n        useCache: false\n    }));\n    nodes.silentPositions(getOldPos);\n    if (hasCompoundNodes) {\n        parents.dirtyCompoundBoundsCache();\n        parents.dirtyBoundingBoxCache();\n        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n    cy.endBatch();\n    return bb;\n};\nfn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\nfn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\nvar bounds = elesfn$b;\nvar fn$2, elesfn$a;\nfn$2 = elesfn$a = {};\nvar defineDimFns = function defineDimFns(opts) {\n    opts.uppercaseName = capitalize(opts.name);\n    opts.autoName = \"auto\" + opts.uppercaseName;\n    opts.labelName = \"label\" + opts.uppercaseName;\n    opts.outerName = \"outer\" + opts.uppercaseName;\n    opts.uppercaseOuterName = capitalize(opts.outerName);\n    fn$2[opts.name] = function dimImpl() {\n        var ele = this[0];\n        var _p = ele._private;\n        var cy = _p.cy;\n        var styleEnabled = cy._private.styleEnabled;\n        if (ele) {\n            if (styleEnabled) {\n                if (ele.isParent()) {\n                    ele.updateCompoundBounds();\n                    return _p[opts.autoName] || 0;\n                }\n                var d = ele.pstyle(opts.name);\n                switch(d.strValue){\n                    case \"label\":\n                        ele.recalculateRenderedStyle();\n                        return _p.rstyle[opts.labelName] || 0;\n                    default:\n                        return d.pfValue;\n                }\n            } else {\n                return 1;\n            }\n        }\n    };\n    fn$2[\"outer\" + opts.uppercaseName] = function outerDimImpl() {\n        var ele = this[0];\n        var _p = ele._private;\n        var cy = _p.cy;\n        var styleEnabled = cy._private.styleEnabled;\n        if (ele) {\n            if (styleEnabled) {\n                var dim = ele[opts.name]();\n                var borderPos = ele.pstyle(\"border-position\").value;\n                var border;\n                if (borderPos === \"center\") {\n                    border = ele.pstyle(\"border-width\").pfValue; // n.b. 1/2 each side\n                } else if (borderPos === \"outside\") {\n                    border = 2 * ele.pstyle(\"border-width\").pfValue;\n                } else {\n                    // 'inside'\n                    border = 0;\n                }\n                var padding = 2 * ele.padding();\n                return dim + border + padding;\n            } else {\n                return 1;\n            }\n        }\n    };\n    fn$2[\"rendered\" + opts.uppercaseName] = function renderedDimImpl() {\n        var ele = this[0];\n        if (ele) {\n            var d = ele[opts.name]();\n            return d * this.cy().zoom();\n        }\n    };\n    fn$2[\"rendered\" + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n        var ele = this[0];\n        if (ele) {\n            var od = ele[opts.outerName]();\n            return od * this.cy().zoom();\n        }\n    };\n};\ndefineDimFns({\n    name: \"width\"\n});\ndefineDimFns({\n    name: \"height\"\n});\nelesfn$a.padding = function() {\n    var ele = this[0];\n    var _p = ele._private;\n    if (ele.isParent()) {\n        ele.updateCompoundBounds();\n        if (_p.autoPadding !== undefined) {\n            return _p.autoPadding;\n        } else {\n            return ele.pstyle(\"padding\").pfValue;\n        }\n    } else {\n        return ele.pstyle(\"padding\").pfValue;\n    }\n};\nelesfn$a.paddedHeight = function() {\n    var ele = this[0];\n    return ele.height() + 2 * ele.padding();\n};\nelesfn$a.paddedWidth = function() {\n    var ele = this[0];\n    return ele.width() + 2 * ele.padding();\n};\nvar widthHeight = elesfn$a;\nvar ifEdge = function ifEdge(ele, getValue) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        return getValue(ele);\n    }\n};\nvar ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        var cy = ele.cy();\n        return modelToRenderedPosition$1(getPoint(ele), cy.zoom(), cy.pan());\n    }\n};\nvar ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        var cy = ele.cy();\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        return getPoints(ele).map(function(p) {\n            return modelToRenderedPosition$1(p, zoom, pan);\n        });\n    }\n};\nvar controlPoints = function controlPoints(ele) {\n    return ele.renderer().getControlPoints(ele);\n};\nvar segmentPoints = function segmentPoints(ele) {\n    return ele.renderer().getSegmentPoints(ele);\n};\nvar sourceEndpoint = function sourceEndpoint(ele) {\n    return ele.renderer().getSourceEndpoint(ele);\n};\nvar targetEndpoint = function targetEndpoint(ele) {\n    return ele.renderer().getTargetEndpoint(ele);\n};\nvar midpoint = function midpoint(ele) {\n    return ele.renderer().getEdgeMidpoint(ele);\n};\nvar pts = {\n    controlPoints: {\n        get: controlPoints,\n        mult: true\n    },\n    segmentPoints: {\n        get: segmentPoints,\n        mult: true\n    },\n    sourceEndpoint: {\n        get: sourceEndpoint\n    },\n    targetEndpoint: {\n        get: targetEndpoint\n    },\n    midpoint: {\n        get: midpoint\n    }\n};\nvar renderedName = function renderedName(name) {\n    return \"rendered\" + name[0].toUpperCase() + name.substr(1);\n};\nvar edgePoints = Object.keys(pts).reduce(function(obj, name) {\n    var spec = pts[name];\n    var rName = renderedName(name);\n    obj[name] = function() {\n        return ifEdge(this, spec.get);\n    };\n    if (spec.mult) {\n        obj[rName] = function() {\n            return ifEdgeRenderedPositions(this, spec.get);\n        };\n    } else {\n        obj[rName] = function() {\n            return ifEdgeRenderedPosition(this, spec.get);\n        };\n    }\n    return obj;\n}, {});\nvar dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/ var Event = function Event(src, props) {\n    this.recycle(src, props);\n};\nfunction returnFalse() {\n    return false;\n}\nfunction returnTrue() {\n    return true;\n}\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n    instanceString: function instanceString() {\n        return \"event\";\n    },\n    recycle: function recycle(src, props) {\n        this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n        if (src != null && src.preventDefault) {\n            // Browser Event object\n            this.type = src.type;\n            // Events bubbling up the document may have been marked as prevented\n            // by a handler lower down the tree; reflect the correct value.\n            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n        } else if (src != null && src.type) {\n            // Plain object containing all event details\n            props = src;\n        } else {\n            // Event string\n            this.type = src;\n        }\n        // Put explicitly provided properties onto the event object\n        if (props != null) {\n            // more efficient to manually copy fields we use\n            this.originalEvent = props.originalEvent;\n            this.type = props.type != null ? props.type : this.type;\n            this.cy = props.cy;\n            this.target = props.target;\n            this.position = props.position;\n            this.renderedPosition = props.renderedPosition;\n            this.namespace = props.namespace;\n            this.layout = props.layout;\n        }\n        if (this.cy != null && this.position != null && this.renderedPosition == null) {\n            // create a rendered position based on the passed position\n            var pos = this.position;\n            var zoom = this.cy.zoom();\n            var pan = this.cy.pan();\n            this.renderedPosition = {\n                x: pos.x * zoom + pan.x,\n                y: pos.y * zoom + pan.y\n            };\n        }\n        // Create a timestamp if incoming event doesn't have one\n        this.timeStamp = src && src.timeStamp || Date.now();\n    },\n    preventDefault: function preventDefault() {\n        this.isDefaultPrevented = returnTrue;\n        var e = this.originalEvent;\n        if (!e) {\n            return;\n        }\n        // if preventDefault exists run it on the original event\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n    },\n    stopPropagation: function stopPropagation() {\n        this.isPropagationStopped = returnTrue;\n        var e = this.originalEvent;\n        if (!e) {\n            return;\n        }\n        // if stopPropagation exists run it on the original event\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n        this.isImmediatePropagationStopped = returnTrue;\n        this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n};\nvar eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\nvar universalNamespace = \".*\"; // matches as if no namespace specified and prevents users from unbinding accidentally\nvar defaults$8 = {\n    qualifierCompare: function qualifierCompare(q1, q2) {\n        return q1 === q2;\n    },\n    eventMatches: function eventMatches() {\n        return true;\n    },\n    addEventFields: function addEventFields() {},\n    callbackContext: function callbackContext(context /*, listener, eventObj*/ ) {\n        return context;\n    },\n    beforeEmit: function beforeEmit() {},\n    afterEmit: function afterEmit() {},\n    bubble: function bubble() {\n        return false;\n    },\n    parent: function parent() {\n        return null;\n    },\n    context: null\n};\nvar defaultsKeys = Object.keys(defaults$8);\nvar emptyOpts = {};\nfunction Emitter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n    var context = arguments.length > 1 ? arguments[1] : undefined;\n    // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n    for(var i = 0; i < defaultsKeys.length; i++){\n        var key = defaultsKeys[i];\n        this[key] = opts[key] || defaults$8[key];\n    }\n    this.context = context || this.context;\n    this.listeners = [];\n    this.emitting = 0;\n}\nvar p = Emitter.prototype;\nvar forEachEvent = function forEachEvent(self1, handler, events, qualifier, callback, conf, confOverrides) {\n    if (fn$6(qualifier)) {\n        callback = qualifier;\n        qualifier = null;\n    }\n    if (confOverrides) {\n        if (conf == null) {\n            conf = confOverrides;\n        } else {\n            conf = extend({}, conf, confOverrides);\n        }\n    }\n    var eventList = array(events) ? events : events.split(/\\s+/);\n    for(var i = 0; i < eventList.length; i++){\n        var evt = eventList[i];\n        if (emptyString(evt)) {\n            continue;\n        }\n        var match = evt.match(eventRegex); // type[.namespace]\n        if (match) {\n            var type = match[1];\n            var namespace = match[2] ? match[2] : null;\n            var ret = handler(self1, evt, type, namespace, qualifier, callback, conf);\n            if (ret === false) {\n                break;\n            } // allow exiting early\n        }\n    }\n};\nvar makeEventObj = function makeEventObj(self1, obj) {\n    self1.addEventFields(self1.context, obj);\n    return new Event(obj.type, obj);\n};\nvar forEachEventObj = function forEachEventObj(self1, handler, events) {\n    if (event(events)) {\n        handler(self1, events);\n        return;\n    } else if (plainObject(events)) {\n        handler(self1, makeEventObj(self1, events));\n        return;\n    }\n    var eventList = array(events) ? events : events.split(/\\s+/);\n    for(var i = 0; i < eventList.length; i++){\n        var evt = eventList[i];\n        if (emptyString(evt)) {\n            continue;\n        }\n        var match = evt.match(eventRegex); // type[.namespace]\n        if (match) {\n            var type = match[1];\n            var namespace = match[2] ? match[2] : null;\n            var eventObj = makeEventObj(self1, {\n                type: type,\n                namespace: namespace,\n                target: self1.context\n            });\n            handler(self1, eventObj);\n        }\n    }\n};\np.on = p.addListener = function(events, qualifier, callback, conf, confOverrides) {\n    forEachEvent(this, function(self1, event, type, namespace, qualifier, callback, conf) {\n        if (fn$6(callback)) {\n            self1.listeners.push({\n                event: event,\n                // full event string\n                callback: callback,\n                // callback to run\n                type: type,\n                // the event type (e.g. 'click')\n                namespace: namespace,\n                // the event namespace (e.g. \".foo\")\n                qualifier: qualifier,\n                // a restriction on whether to match this emitter\n                conf: conf // additional configuration\n            });\n        }\n    }, events, qualifier, callback, conf, confOverrides);\n    return this;\n};\np.one = function(events, qualifier, callback, conf) {\n    return this.on(events, qualifier, callback, conf, {\n        one: true\n    });\n};\np.removeListener = p.off = function(events, qualifier, callback, conf) {\n    var _this = this;\n    if (this.emitting !== 0) {\n        this.listeners = copyArray(this.listeners);\n    }\n    var listeners = this.listeners;\n    var _loop = function _loop(i) {\n        var listener = listeners[i];\n        forEachEvent(_this, function(self1, event, type, namespace, qualifier, callback /*, conf*/ ) {\n            if ((listener.type === type || events === \"*\") && (!namespace && listener.namespace !== \".*\" || listener.namespace === namespace) && (!qualifier || self1.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n                listeners.splice(i, 1);\n                return false;\n            }\n        }, events, qualifier, callback, conf);\n    };\n    for(var i = listeners.length - 1; i >= 0; i--){\n        _loop(i);\n    }\n    return this;\n};\np.removeAllListeners = function() {\n    return this.removeListener(\"*\");\n};\np.emit = p.trigger = function(events, extraParams, manualCallback) {\n    var listeners = this.listeners;\n    var numListenersBeforeEmit = listeners.length;\n    this.emitting++;\n    if (!array(extraParams)) {\n        extraParams = [\n            extraParams\n        ];\n    }\n    forEachEventObj(this, function(self1, eventObj) {\n        if (manualCallback != null) {\n            listeners = [\n                {\n                    event: eventObj.event,\n                    type: eventObj.type,\n                    namespace: eventObj.namespace,\n                    callback: manualCallback\n                }\n            ];\n            numListenersBeforeEmit = listeners.length;\n        }\n        var _loop2 = function _loop2() {\n            var listener = listeners[i];\n            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self1.eventMatches(self1.context, listener, eventObj)) {\n                var args = [\n                    eventObj\n                ];\n                if (extraParams != null) {\n                    push(args, extraParams);\n                }\n                self1.beforeEmit(self1.context, listener, eventObj);\n                if (listener.conf && listener.conf.one) {\n                    self1.listeners = self1.listeners.filter(function(l) {\n                        return l !== listener;\n                    });\n                }\n                var context = self1.callbackContext(self1.context, listener, eventObj);\n                var ret = listener.callback.apply(context, args);\n                self1.afterEmit(self1.context, listener, eventObj);\n                if (ret === false) {\n                    eventObj.stopPropagation();\n                    eventObj.preventDefault();\n                }\n            } // if listener matches\n        };\n        for(var i = 0; i < numListenersBeforeEmit; i++){\n            _loop2();\n        } // for listener\n        if (self1.bubble(self1.context) && !eventObj.isPropagationStopped()) {\n            self1.parent(self1.context).emit(eventObj, extraParams);\n        }\n    }, events);\n    this.emitting--;\n    return this;\n};\nvar emitterOptions$1 = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n        if (selector1 == null || selector2 == null) {\n            return selector1 == null && selector2 == null;\n        } else {\n            return selector1.sameText(selector2);\n        }\n    },\n    eventMatches: function eventMatches(ele, listener, eventObj) {\n        var selector = listener.qualifier;\n        if (selector != null) {\n            return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n        }\n        return true;\n    },\n    addEventFields: function addEventFields(ele, evt) {\n        evt.cy = ele.cy();\n        evt.target = ele;\n    },\n    callbackContext: function callbackContext(ele, listener, eventObj) {\n        return listener.qualifier != null ? eventObj.target : ele;\n    },\n    beforeEmit: function beforeEmit(context, listener /*, eventObj*/ ) {\n        if (listener.conf && listener.conf.once) {\n            listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n        }\n    },\n    bubble: function bubble() {\n        return true;\n    },\n    parent: function parent(ele) {\n        return ele.isChild() ? ele.parent() : ele.cy();\n    }\n};\nvar argSelector$1 = function argSelector(arg) {\n    if (string(arg)) {\n        return new Selector(arg);\n    } else {\n        return arg;\n    }\n};\nvar elesfn$9 = {\n    createEmitter: function createEmitter() {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _p = ele._private;\n            if (!_p.emitter) {\n                _p.emitter = new Emitter(emitterOptions$1, ele);\n            }\n        }\n        return this;\n    },\n    emitter: function emitter() {\n        return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().on(events, argSel, callback);\n        }\n        return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().removeListener(events, argSel, callback);\n        }\n        return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().removeAllListeners();\n        }\n        return this;\n    },\n    one: function one(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().one(events, argSel, callback);\n        }\n        return this;\n    },\n    once: function once(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().on(events, argSel, callback, {\n                once: true,\n                onceCollection: this\n            });\n        }\n    },\n    emit: function emit(events, extraParams) {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().emit(events, extraParams);\n        }\n        return this;\n    },\n    emitAndNotify: function emitAndNotify(event, extraParams) {\n        // for internal use only\n        if (this.length === 0) {\n            return;\n        } // empty collections don't need to notify anything\n        // notify renderer\n        this.cy().notify(event, this);\n        this.emit(event, extraParams);\n        return this;\n    }\n};\ndefine.eventAliasesOn(elesfn$9);\nvar elesfn$8 = {\n    nodes: function nodes(selector) {\n        return this.filter(function(ele) {\n            return ele.isNode();\n        }).filter(selector);\n    },\n    edges: function edges(selector) {\n        return this.filter(function(ele) {\n            return ele.isEdge();\n        }).filter(selector);\n    },\n    // internal helper to get nodes and edges as separate collections with single iteration over elements\n    byGroup: function byGroup() {\n        var nodes = this.spawn();\n        var edges = this.spawn();\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            if (ele.isNode()) {\n                nodes.push(ele);\n            } else {\n                edges.push(ele);\n            }\n        }\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    },\n    filter: function filter(_filter, thisArg) {\n        if (_filter === undefined) {\n            // check this first b/c it's the most common/performant case\n            return this;\n        } else if (string(_filter) || elementOrCollection(_filter)) {\n            return new Selector(_filter).filter(this);\n        } else if (fn$6(_filter)) {\n            var filterEles = this.spawn();\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var include = thisArg ? _filter.apply(thisArg, [\n                    ele,\n                    i,\n                    eles\n                ]) : _filter(ele, i, eles);\n                if (include) {\n                    filterEles.push(ele);\n                }\n            }\n            return filterEles;\n        }\n        return this.spawn(); // if not handled by above, give 'em an empty collection\n    },\n    not: function not(toRemove) {\n        if (!toRemove) {\n            return this;\n        } else {\n            if (string(toRemove)) {\n                toRemove = this.filter(toRemove);\n            }\n            var elements = this.spawn();\n            for(var i = 0; i < this.length; i++){\n                var element = this[i];\n                var remove = toRemove.has(element);\n                if (!remove) {\n                    elements.push(element);\n                }\n            }\n            return elements;\n        }\n    },\n    absoluteComplement: function absoluteComplement() {\n        var cy = this.cy();\n        return cy.mutableElements().not(this);\n    },\n    intersect: function intersect(other) {\n        // if a selector is specified, then filter by it instead\n        if (string(other)) {\n            var selector = other;\n            return this.filter(selector);\n        }\n        var elements = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var col1Smaller = this.length < other.length;\n        var colS = col1Smaller ? col1 : col2;\n        var colL = col1Smaller ? col2 : col1;\n        for(var i = 0; i < colS.length; i++){\n            var ele = colS[i];\n            if (colL.has(ele)) {\n                elements.push(ele);\n            }\n        }\n        return elements;\n    },\n    xor: function xor(other) {\n        var cy = this._private.cy;\n        if (string(other)) {\n            other = cy.$(other);\n        }\n        var elements = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var add = function add(col, other) {\n            for(var i = 0; i < col.length; i++){\n                var ele = col[i];\n                var id = ele._private.data.id;\n                var inOther = other.hasElementWithId(id);\n                if (!inOther) {\n                    elements.push(ele);\n                }\n            }\n        };\n        add(col1, col2);\n        add(col2, col1);\n        return elements;\n    },\n    diff: function diff(other) {\n        var cy = this._private.cy;\n        if (string(other)) {\n            other = cy.$(other);\n        }\n        var left = this.spawn();\n        var right = this.spawn();\n        var both = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var add = function add(col, other, retEles) {\n            for(var i = 0; i < col.length; i++){\n                var ele = col[i];\n                var id = ele._private.data.id;\n                var inOther = other.hasElementWithId(id);\n                if (inOther) {\n                    both.merge(ele);\n                } else {\n                    retEles.push(ele);\n                }\n            }\n        };\n        add(col1, col2, left);\n        add(col2, col1, right);\n        return {\n            left: left,\n            right: right,\n            both: both\n        };\n    },\n    add: function add(toAdd) {\n        var cy = this._private.cy;\n        if (!toAdd) {\n            return this;\n        }\n        if (string(toAdd)) {\n            var selector = toAdd;\n            toAdd = cy.mutableElements().filter(selector);\n        }\n        var elements = this.spawnSelf();\n        for(var i = 0; i < toAdd.length; i++){\n            var ele = toAdd[i];\n            var add = !this.has(ele);\n            if (add) {\n                elements.push(ele);\n            }\n        }\n        return elements;\n    },\n    // in place merge on calling collection\n    merge: function merge(toAdd) {\n        var _p = this._private;\n        var cy = _p.cy;\n        if (!toAdd) {\n            return this;\n        }\n        if (toAdd && string(toAdd)) {\n            var selector = toAdd;\n            toAdd = cy.mutableElements().filter(selector);\n        }\n        var map = _p.map;\n        for(var i = 0; i < toAdd.length; i++){\n            var toAddEle = toAdd[i];\n            var id = toAddEle._private.data.id;\n            var add = !map.has(id);\n            if (add) {\n                var index = this.length++;\n                this[index] = toAddEle;\n                map.set(id, {\n                    ele: toAddEle,\n                    index: index\n                });\n            }\n        }\n        return this; // chaining\n    },\n    unmergeAt: function unmergeAt(i) {\n        var ele = this[i];\n        var id = ele.id();\n        var _p = this._private;\n        var map = _p.map;\n        // remove ele\n        this[i] = undefined;\n        map[\"delete\"](id);\n        var unmergedLastEle = i === this.length - 1;\n        // replace empty spot with last ele in collection\n        if (this.length > 1 && !unmergedLastEle) {\n            var lastEleI = this.length - 1;\n            var lastEle = this[lastEleI];\n            var lastEleId = lastEle._private.data.id;\n            this[lastEleI] = undefined;\n            this[i] = lastEle;\n            map.set(lastEleId, {\n                ele: lastEle,\n                index: i\n            });\n        }\n        // the collection is now 1 ele smaller\n        this.length--;\n        return this;\n    },\n    // remove single ele in place in calling collection\n    unmergeOne: function unmergeOne(ele) {\n        ele = ele[0];\n        var _p = this._private;\n        var id = ele._private.data.id;\n        var map = _p.map;\n        var entry = map.get(id);\n        if (!entry) {\n            return this; // no need to remove\n        }\n        var i = entry.index;\n        this.unmergeAt(i);\n        return this;\n    },\n    // remove eles in place on calling collection\n    unmerge: function unmerge(toRemove) {\n        var cy = this._private.cy;\n        if (!toRemove) {\n            return this;\n        }\n        if (toRemove && string(toRemove)) {\n            var selector = toRemove;\n            toRemove = cy.mutableElements().filter(selector);\n        }\n        for(var i = 0; i < toRemove.length; i++){\n            this.unmergeOne(toRemove[i]);\n        }\n        return this; // chaining\n    },\n    unmergeBy: function unmergeBy(toRmFn) {\n        for(var i = this.length - 1; i >= 0; i--){\n            var ele = this[i];\n            if (toRmFn(ele)) {\n                this.unmergeAt(i);\n            }\n        }\n        return this;\n    },\n    map: function map(mapFn, thisArg) {\n        var arr = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var ret = thisArg ? mapFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : mapFn(ele, i, eles);\n            arr.push(ret);\n        }\n        return arr;\n    },\n    reduce: function reduce(fn, initialValue) {\n        var val = initialValue;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            val = fn(val, eles[i], i, eles);\n        }\n        return val;\n    },\n    max: function max(valFn, thisArg) {\n        var max = -Infinity;\n        var maxEle;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var val = thisArg ? valFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : valFn(ele, i, eles);\n            if (val > max) {\n                max = val;\n                maxEle = ele;\n            }\n        }\n        return {\n            value: max,\n            ele: maxEle\n        };\n    },\n    min: function min(valFn, thisArg) {\n        var min = Infinity;\n        var minEle;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var val = thisArg ? valFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : valFn(ele, i, eles);\n            if (val < min) {\n                min = val;\n                minEle = ele;\n            }\n        }\n        return {\n            value: min,\n            ele: minEle\n        };\n    }\n};\n// aliases\nvar fn$1 = elesfn$8;\nfn$1[\"u\"] = fn$1[\"|\"] = fn$1[\"+\"] = fn$1.union = fn$1.or = fn$1.add;\nfn$1[\"\\\\\"] = fn$1[\"!\"] = fn$1[\"-\"] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\nfn$1[\"n\"] = fn$1[\"&\"] = fn$1[\".\"] = fn$1.and = fn$1.intersection = fn$1.intersect;\nfn$1[\"^\"] = fn$1[\"(+)\"] = fn$1[\"(-)\"] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\nfn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\nfn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\nvar elesfn$7 = {\n    isNode: function isNode() {\n        return this.group() === \"nodes\";\n    },\n    isEdge: function isEdge() {\n        return this.group() === \"edges\";\n    },\n    isLoop: function isLoop() {\n        return this.isEdge() && this.source()[0] === this.target()[0];\n    },\n    isSimple: function isSimple() {\n        return this.isEdge() && this.source()[0] !== this.target()[0];\n    },\n    group: function group() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.group;\n        }\n    }\n};\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */ var zIndexSort = function zIndexSort(a, b) {\n    var cy = a.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    function getDepth(ele) {\n        var style = ele.pstyle(\"z-compound-depth\");\n        if (style.value === \"auto\") {\n            return hasCompoundNodes ? ele.zDepth() : 0;\n        } else if (style.value === \"bottom\") {\n            return -1;\n        } else if (style.value === \"top\") {\n            return MAX_INT$1;\n        }\n        // 'orphan'\n        return 0;\n    }\n    var depthDiff = getDepth(a) - getDepth(b);\n    if (depthDiff !== 0) {\n        return depthDiff;\n    }\n    function getEleDepth(ele) {\n        var style = ele.pstyle(\"z-index-compare\");\n        if (style.value === \"auto\") {\n            return ele.isNode() ? 1 : 0;\n        }\n        // 'manual'\n        return 0;\n    }\n    var eleDiff = getEleDepth(a) - getEleDepth(b);\n    if (eleDiff !== 0) {\n        return eleDiff;\n    }\n    var zDiff = a.pstyle(\"z-index\").value - b.pstyle(\"z-index\").value;\n    if (zDiff !== 0) {\n        return zDiff;\n    }\n    // compare indices in the core (order added to graph w/ last on top)\n    return a.poolIndex() - b.poolIndex();\n};\nvar elesfn$6 = {\n    forEach: function forEach(fn, thisArg) {\n        if (fn$6(fn)) {\n            var N = this.length;\n            for(var i = 0; i < N; i++){\n                var ele = this[i];\n                var ret = thisArg ? fn.apply(thisArg, [\n                    ele,\n                    i,\n                    this\n                ]) : fn(ele, i, this);\n                if (ret === false) {\n                    break;\n                } // exit each early on return false\n            }\n        }\n        return this;\n    },\n    toArray: function toArray() {\n        var array = [];\n        for(var i = 0; i < this.length; i++){\n            array.push(this[i]);\n        }\n        return array;\n    },\n    slice: function slice(start, end) {\n        var array = [];\n        var thisSize = this.length;\n        if (end == null) {\n            end = thisSize;\n        }\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start = thisSize + start;\n        }\n        if (end < 0) {\n            end = thisSize + end;\n        }\n        for(var i = start; i >= 0 && i < end && i < thisSize; i++){\n            array.push(this[i]);\n        }\n        return this.spawn(array);\n    },\n    size: function size() {\n        return this.length;\n    },\n    eq: function eq(i) {\n        return this[i] || this.spawn();\n    },\n    first: function first() {\n        return this[0] || this.spawn();\n    },\n    last: function last() {\n        return this[this.length - 1] || this.spawn();\n    },\n    empty: function empty() {\n        return this.length === 0;\n    },\n    nonempty: function nonempty() {\n        return !this.empty();\n    },\n    sort: function sort(sortFn) {\n        if (!fn$6(sortFn)) {\n            return this;\n        }\n        var sorted = this.toArray().sort(sortFn);\n        return this.spawn(sorted);\n    },\n    sortByZIndex: function sortByZIndex() {\n        return this.sort(zIndexSort);\n    },\n    zDepth: function zDepth() {\n        var ele = this[0];\n        if (!ele) {\n            return undefined;\n        }\n        // let cy = ele.cy();\n        var _p = ele._private;\n        var group = _p.group;\n        if (group === \"nodes\") {\n            var depth = _p.data.parent ? ele.parents().size() : 0;\n            if (!ele.isParent()) {\n                return MAX_INT$1 - 1; // childless nodes always on top\n            }\n            return depth;\n        } else {\n            var src = _p.source;\n            var tgt = _p.target;\n            var srcDepth = src.zDepth();\n            var tgtDepth = tgt.zDepth();\n            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n        }\n    }\n};\nelesfn$6.each = elesfn$6.forEach;\nvar defineSymbolIterator = function defineSymbolIterator() {\n    var typeofUndef = \"undefined\";\n    var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef;\n    if (isIteratorSupported) {\n        elesfn$6[Symbol.iterator] = function() {\n            var _this = this;\n            var entry = {\n                value: undefined,\n                done: false\n            };\n            var i = 0;\n            var length = this.length;\n            return _defineProperty$1({\n                next: function next() {\n                    if (i < length) {\n                        entry.value = _this[i++];\n                    } else {\n                        entry.value = undefined;\n                        entry.done = true;\n                    }\n                    return entry;\n                }\n            }, Symbol.iterator, function() {\n                return this;\n            });\n        };\n    }\n};\ndefineSymbolIterator();\nvar getLayoutDimensionOptions = defaults$g({\n    nodeDimensionsIncludeLabels: false\n});\nvar elesfn$5 = {\n    // Calculates and returns node dimensions { x, y } based on options given\n    layoutDimensions: function layoutDimensions(options) {\n        options = getLayoutDimensionOptions(options);\n        var dims;\n        if (!this.takesUpSpace()) {\n            dims = {\n                w: 0,\n                h: 0\n            };\n        } else if (options.nodeDimensionsIncludeLabels) {\n            var bbDim = this.boundingBox();\n            dims = {\n                w: bbDim.w,\n                h: bbDim.h\n            };\n        } else {\n            dims = {\n                w: this.outerWidth(),\n                h: this.outerHeight()\n            };\n        }\n        // sanitise the dimensions for external layouts (avoid division by zero)\n        if (dims.w === 0 || dims.h === 0) {\n            dims.w = dims.h = 1;\n        }\n        return dims;\n    },\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function layoutPositions(layout, options, fn) {\n        var nodes = this.nodes().filter(function(n) {\n            return !n.isParent();\n        });\n        var cy = this.cy();\n        var layoutEles = options.eles; // nodes & edges\n        var getMemoizeKey = function getMemoizeKey(node) {\n            return node.id();\n        };\n        var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function\n        layout.emit({\n            type: \"layoutstart\",\n            layout: layout\n        });\n        layout.animations = [];\n        var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n            var center = {\n                x: nodesBb.x1 + nodesBb.w / 2,\n                y: nodesBb.y1 + nodesBb.h / 2\n            };\n            var spacingVector = {\n                // scale from center of bounding box (not necessarily 0,0)\n                x: (pos.x - center.x) * spacing,\n                y: (pos.y - center.y) * spacing\n            };\n            return {\n                x: center.x + spacingVector.x,\n                y: center.y + spacingVector.y\n            };\n        };\n        var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n        var spacingBb = function spacingBb() {\n            if (!useSpacingFactor) {\n                return null;\n            }\n            var bb = makeBoundingBox();\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var pos = fnMem(node, i);\n                expandBoundingBoxByPoint(bb, pos.x, pos.y);\n            }\n            return bb;\n        };\n        var bb = spacingBb();\n        var getFinalPos = memoize(function(node, i) {\n            var newPos = fnMem(node, i);\n            if (useSpacingFactor) {\n                var spacing = Math.abs(options.spacingFactor);\n                newPos = calculateSpacing(spacing, bb, newPos);\n            }\n            if (options.transform != null) {\n                newPos = options.transform(node, newPos);\n            }\n            return newPos;\n        }, getMemoizeKey);\n        if (options.animate) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var newPos = getFinalPos(node, i);\n                var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n                if (animateNode) {\n                    var ani = node.animation({\n                        position: newPos,\n                        duration: options.animationDuration,\n                        easing: options.animationEasing\n                    });\n                    layout.animations.push(ani);\n                } else {\n                    node.position(newPos);\n                }\n            }\n            if (options.fit) {\n                var fitAni = cy.animation({\n                    fit: {\n                        boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n                        padding: options.padding\n                    },\n                    duration: options.animationDuration,\n                    easing: options.animationEasing\n                });\n                layout.animations.push(fitAni);\n            } else if (options.zoom !== undefined && options.pan !== undefined) {\n                var zoomPanAni = cy.animation({\n                    zoom: options.zoom,\n                    pan: options.pan,\n                    duration: options.animationDuration,\n                    easing: options.animationEasing\n                });\n                layout.animations.push(zoomPanAni);\n            }\n            layout.animations.forEach(function(ani) {\n                return ani.play();\n            });\n            layout.one(\"layoutready\", options.ready);\n            layout.emit({\n                type: \"layoutready\",\n                layout: layout\n            });\n            Promise$1.all(layout.animations.map(function(ani) {\n                return ani.promise();\n            })).then(function() {\n                layout.one(\"layoutstop\", options.stop);\n                layout.emit({\n                    type: \"layoutstop\",\n                    layout: layout\n                });\n            });\n        } else {\n            nodes.positions(getFinalPos);\n            if (options.fit) {\n                cy.fit(options.eles, options.padding);\n            }\n            if (options.zoom != null) {\n                cy.zoom(options.zoom);\n            }\n            if (options.pan) {\n                cy.pan(options.pan);\n            }\n            layout.one(\"layoutready\", options.ready);\n            layout.emit({\n                type: \"layoutready\",\n                layout: layout\n            });\n            layout.one(\"layoutstop\", options.stop);\n            layout.emit({\n                type: \"layoutstop\",\n                layout: layout\n            });\n        }\n        return this; // chaining\n    },\n    layout: function layout(options) {\n        var cy = this.cy();\n        return cy.makeLayout(extend({}, options, {\n            eles: this\n        }));\n    }\n};\n// aliases:\nelesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\nfunction styleCache(key, fn, ele) {\n    var _p = ele._private;\n    var cache = _p.styleCache = _p.styleCache || [];\n    var val;\n    if ((val = cache[key]) != null) {\n        return val;\n    } else {\n        val = cache[key] = fn(ele);\n        return val;\n    }\n}\nfunction cacheStyleFunction(key, fn) {\n    key = hashString(key);\n    return function cachedStyleFunction(ele) {\n        return styleCache(key, fn, ele);\n    };\n}\nfunction cachePrototypeStyleFunction(key, fn) {\n    key = hashString(key);\n    var selfFn = function selfFn(ele) {\n        return fn.call(ele);\n    };\n    return function cachedPrototypeStyleFunction() {\n        var ele = this[0];\n        if (ele) {\n            return styleCache(key, selfFn, ele);\n        }\n    };\n}\nvar elesfn$4 = {\n    recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n        var cy = this.cy();\n        var renderer = cy.renderer();\n        var styleEnabled = cy.styleEnabled();\n        if (renderer && styleEnabled) {\n            renderer.recalculateRenderedStyle(this, useCache);\n        }\n        return this;\n    },\n    dirtyStyleCache: function dirtyStyleCache() {\n        var cy = this.cy();\n        var dirty = function dirty(ele) {\n            return ele._private.styleCache = null;\n        };\n        if (cy.hasCompoundNodes()) {\n            var eles;\n            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n            eles.merge(eles.connectedEdges());\n            eles.forEach(dirty);\n        } else {\n            this.forEach(function(ele) {\n                dirty(ele);\n                ele.connectedEdges().forEach(dirty);\n            });\n        }\n        return this;\n    },\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function updateStyle(notifyRenderer) {\n        var cy = this._private.cy;\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        if (cy.batching()) {\n            var bEles = cy._private.batchStyleEles;\n            bEles.merge(this);\n            return this; // chaining and exit early when batching\n        }\n        var hasCompounds = cy.hasCompoundNodes();\n        var updatedEles = this;\n        notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n        if (hasCompounds) {\n            // then add everything up and down for compound selector checks\n            updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n        }\n        // let changedEles = style.apply( updatedEles );\n        var changedEles = updatedEles;\n        if (notifyRenderer) {\n            changedEles.emitAndNotify(\"style\"); // let renderer know we changed style\n        } else {\n            changedEles.emit(\"style\"); // just fire the event\n        }\n        updatedEles.forEach(function(ele) {\n            return ele._private.styleDirty = true;\n        });\n        return this; // chaining\n    },\n    // private: clears dirty flag and recalculates style\n    cleanStyle: function cleanStyle() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return;\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            if (ele._private.styleDirty) {\n                // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                ele._private.styleDirty = false;\n                cy.style().apply(ele);\n            }\n        }\n    },\n    // get the internal parsed style object for the specified property\n    parsedStyle: function parsedStyle(property) {\n        var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var ele = this[0];\n        var cy = ele.cy();\n        if (!cy.styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            // this.cleanStyle();\n            // Inline the important part of cleanStyle(), for raw performance\n            if (ele._private.styleDirty) {\n                // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                ele._private.styleDirty = false;\n                cy.style().apply(ele);\n            }\n            var overriddenStyle = ele._private.style[property];\n            if (overriddenStyle != null) {\n                return overriddenStyle;\n            } else if (includeNonDefault) {\n                return cy.style().getDefaultProperty(property);\n            } else {\n                return null;\n            }\n        }\n    },\n    numericStyle: function numericStyle(property) {\n        var ele = this[0];\n        if (!ele.cy().styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            var pstyle = ele.pstyle(property);\n            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n        }\n    },\n    numericStyleUnits: function numericStyleUnits(property) {\n        var ele = this[0];\n        if (!ele.cy().styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            return ele.pstyle(property).units;\n        }\n    },\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedStyle: function renderedStyle(property) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var ele = this[0];\n        if (ele) {\n            return cy.style().getRenderedStyle(ele, property);\n        }\n    },\n    // read the calculated css style of the element or override the style (via a bypass)\n    style: function style(name, value) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var updateTransitions = false;\n        var style = cy.style();\n        if (plainObject(name)) {\n            // then extend the bypass\n            var props = name;\n            style.applyBypass(this, props, updateTransitions);\n            this.emitAndNotify(\"style\"); // let the renderer know we've updated style\n        } else if (string(name)) {\n            if (value === undefined) {\n                // then get the property from the style\n                var ele = this[0];\n                if (ele) {\n                    return style.getStylePropertyValue(ele, name);\n                } else {\n                    // empty collection => can't get any value\n                    return;\n                }\n            } else {\n                // then set the bypass with the property value\n                style.applyBypass(this, name, value, updateTransitions);\n                this.emitAndNotify(\"style\"); // let the renderer know we've updated style\n            }\n        } else if (name === undefined) {\n            var _ele = this[0];\n            if (_ele) {\n                return style.getRawStyle(_ele);\n            } else {\n                // empty collection => can't get any value\n                return;\n            }\n        }\n        return this; // chaining\n    },\n    removeStyle: function removeStyle(names) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var updateTransitions = false;\n        var style = cy.style();\n        var eles = this;\n        if (names === undefined) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                style.removeAllBypasses(ele, updateTransitions);\n            }\n        } else {\n            names = names.split(/\\s+/);\n            for(var _i = 0; _i < eles.length; _i++){\n                var _ele2 = eles[_i];\n                style.removeBypasses(_ele2, names, updateTransitions);\n            }\n        }\n        this.emitAndNotify(\"style\"); // let the renderer know we've updated style\n        return this; // chaining\n    },\n    show: function show() {\n        this.css(\"display\", \"element\");\n        return this; // chaining\n    },\n    hide: function hide() {\n        this.css(\"display\", \"none\");\n        return this; // chaining\n    },\n    effectiveOpacity: function effectiveOpacity() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return 1;\n        }\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        var ele = this[0];\n        if (ele) {\n            var _p = ele._private;\n            var parentOpacity = ele.pstyle(\"opacity\").value;\n            if (!hasCompoundNodes) {\n                return parentOpacity;\n            }\n            var parents = !_p.data.parent ? null : ele.parents();\n            if (parents) {\n                for(var i = 0; i < parents.length; i++){\n                    var parent = parents[i];\n                    var opacity = parent.pstyle(\"opacity\").value;\n                    parentOpacity = opacity * parentOpacity;\n                }\n            }\n            return parentOpacity;\n        }\n    },\n    transparent: function transparent() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return false;\n        }\n        var ele = this[0];\n        var hasCompoundNodes = ele.cy().hasCompoundNodes();\n        if (ele) {\n            if (!hasCompoundNodes) {\n                return ele.pstyle(\"opacity\").value === 0;\n            } else {\n                return ele.effectiveOpacity() === 0;\n            }\n        }\n    },\n    backgrounding: function backgrounding() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return false;\n        }\n        var ele = this[0];\n        return ele._private.backgrounding ? true : false;\n    }\n};\nfunction checkCompound(ele, parentOk) {\n    var _p = ele._private;\n    var parents = _p.data.parent ? ele.parents() : null;\n    if (parents) {\n        for(var i = 0; i < parents.length; i++){\n            var parent = parents[i];\n            if (!parentOk(parent)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction defineDerivedStateFunction(specs) {\n    var ok = specs.ok;\n    var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n    var parentOk = specs.parentOk || specs.ok;\n    return function() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return true;\n        }\n        var ele = this[0];\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        if (ele) {\n            var _p = ele._private;\n            if (!ok(ele)) {\n                return false;\n            }\n            if (ele.isNode()) {\n                return !hasCompoundNodes || checkCompound(ele, parentOk);\n            } else {\n                var src = _p.source;\n                var tgt = _p.target;\n                return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n            }\n        }\n    };\n}\nvar eleTakesUpSpace = cacheStyleFunction(\"eleTakesUpSpace\", function(ele) {\n    return ele.pstyle(\"display\").value === \"element\" && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\nelesfn$4.takesUpSpace = cachePrototypeStyleFunction(\"takesUpSpace\", defineDerivedStateFunction({\n    ok: eleTakesUpSpace\n}));\nvar eleInteractive = cacheStyleFunction(\"eleInteractive\", function(ele) {\n    return ele.pstyle(\"events\").value === \"yes\" && ele.pstyle(\"visibility\").value === \"visible\" && eleTakesUpSpace(ele);\n});\nvar parentInteractive = cacheStyleFunction(\"parentInteractive\", function(parent) {\n    return parent.pstyle(\"visibility\").value === \"visible\" && eleTakesUpSpace(parent);\n});\nelesfn$4.interactive = cachePrototypeStyleFunction(\"interactive\", defineDerivedStateFunction({\n    ok: eleInteractive,\n    parentOk: parentInteractive,\n    edgeOkViaNode: eleTakesUpSpace\n}));\nelesfn$4.noninteractive = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele.interactive();\n    }\n};\nvar eleVisible = cacheStyleFunction(\"eleVisible\", function(ele) {\n    return ele.pstyle(\"visibility\").value === \"visible\" && ele.pstyle(\"opacity\").pfValue !== 0 && eleTakesUpSpace(ele);\n});\nvar edgeVisibleViaNode = eleTakesUpSpace;\nelesfn$4.visible = cachePrototypeStyleFunction(\"visible\", defineDerivedStateFunction({\n    ok: eleVisible,\n    edgeOkViaNode: edgeVisibleViaNode\n}));\nelesfn$4.hidden = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele.visible();\n    }\n};\nelesfn$4.isBundledBezier = cachePrototypeStyleFunction(\"isBundledBezier\", function() {\n    if (!this.cy().styleEnabled()) {\n        return false;\n    }\n    return !this.removed() && this.pstyle(\"curve-style\").value === \"bezier\" && this.takesUpSpace();\n});\nelesfn$4.bypass = elesfn$4.css = elesfn$4.style;\nelesfn$4.renderedCss = elesfn$4.renderedStyle;\nelesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\nelesfn$4.pstyle = elesfn$4.parsedStyle;\nvar elesfn$3 = {};\nfunction defineSwitchFunction(params) {\n    return function() {\n        var args = arguments;\n        var changedEles = [];\n        // e.g. cy.nodes().select( data, handler )\n        if (args.length === 2) {\n            var data = args[0];\n            var handler = args[1];\n            this.on(params.event, data, handler);\n        } else if (args.length === 1 && fn$6(args[0])) {\n            var _handler = args[0];\n            this.on(params.event, _handler);\n        } else if (args.length === 0 || args.length === 1 && array(args[0])) {\n            var addlEvents = args.length === 1 ? args[0] : null;\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var able = !params.ableField || ele._private[params.ableField];\n                var changed = ele._private[params.field] != params.value;\n                if (params.overrideAble) {\n                    var overrideAble = params.overrideAble(ele);\n                    if (overrideAble !== undefined) {\n                        able = overrideAble;\n                        if (!overrideAble) {\n                            return this;\n                        } // to save cycles assume not able for all on override\n                    }\n                }\n                if (able) {\n                    ele._private[params.field] = params.value;\n                    if (changed) {\n                        changedEles.push(ele);\n                    }\n                }\n            }\n            var changedColl = this.spawn(changedEles);\n            changedColl.updateStyle(); // change of state => possible change of style\n            changedColl.emit(params.event);\n            if (addlEvents) {\n                changedColl.emit(addlEvents);\n            }\n        }\n        return this;\n    };\n}\nfunction defineSwitchSet(params) {\n    elesfn$3[params.field] = function() {\n        var ele = this[0];\n        if (ele) {\n            if (params.overrideField) {\n                var val = params.overrideField(ele);\n                if (val !== undefined) {\n                    return val;\n                }\n            }\n            return ele._private[params.field];\n        }\n    };\n    elesfn$3[params.on] = defineSwitchFunction({\n        event: params.on,\n        field: params.field,\n        ableField: params.ableField,\n        overrideAble: params.overrideAble,\n        value: true\n    });\n    elesfn$3[params.off] = defineSwitchFunction({\n        event: params.off,\n        field: params.field,\n        ableField: params.ableField,\n        overrideAble: params.overrideAble,\n        value: false\n    });\n}\ndefineSwitchSet({\n    field: \"locked\",\n    overrideField: function overrideField(ele) {\n        return ele.cy().autolock() ? true : undefined;\n    },\n    on: \"lock\",\n    off: \"unlock\"\n});\ndefineSwitchSet({\n    field: \"grabbable\",\n    overrideField: function overrideField(ele) {\n        return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n    },\n    on: \"grabify\",\n    off: \"ungrabify\"\n});\ndefineSwitchSet({\n    field: \"selected\",\n    ableField: \"selectable\",\n    overrideAble: function overrideAble(ele) {\n        return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: \"select\",\n    off: \"unselect\"\n});\ndefineSwitchSet({\n    field: \"selectable\",\n    overrideField: function overrideField(ele) {\n        return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: \"selectify\",\n    off: \"unselectify\"\n});\nelesfn$3.deselect = elesfn$3.unselect;\nelesfn$3.grabbed = function() {\n    var ele = this[0];\n    if (ele) {\n        return ele._private.grabbed;\n    }\n};\ndefineSwitchSet({\n    field: \"active\",\n    on: \"activate\",\n    off: \"unactivate\"\n});\ndefineSwitchSet({\n    field: \"pannable\",\n    on: \"panify\",\n    off: \"unpanify\"\n});\nelesfn$3.inactive = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele._private.active;\n    }\n};\nvar elesfn$2 = {};\n// DAG functions\n////////////////\nvar defineDagExtremity = function defineDagExtremity(params) {\n    return function dagExtremityImpl(selector) {\n        var eles = this;\n        var ret = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            var disqualified = false;\n            var edges = ele.connectedEdges();\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n                    disqualified = true;\n                    break;\n                }\n            }\n            if (!disqualified) {\n                ret.push(ele);\n            }\n        }\n        return this.spawn(ret, true).filter(selector);\n    };\n};\nvar defineDagOneHop = function defineDagOneHop(params) {\n    return function(selector) {\n        var eles = this;\n        var oEles = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            var edges = ele.connectedEdges();\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                if (params.outgoing && src === ele) {\n                    oEles.push(edge);\n                    oEles.push(tgt);\n                } else if (params.incoming && tgt === ele) {\n                    oEles.push(edge);\n                    oEles.push(src);\n                }\n            }\n        }\n        return this.spawn(oEles, true).filter(selector);\n    };\n};\nvar defineDagAllHops = function defineDagAllHops(params) {\n    return function(selector) {\n        var eles = this;\n        var sEles = [];\n        var sElesIds = {};\n        for(;;){\n            var next = params.outgoing ? eles.outgoers() : eles.incomers();\n            if (next.length === 0) {\n                break;\n            } // done if none left\n            var newNext = false;\n            for(var i = 0; i < next.length; i++){\n                var n = next[i];\n                var nid = n.id();\n                if (!sElesIds[nid]) {\n                    sElesIds[nid] = true;\n                    sEles.push(n);\n                    newNext = true;\n                }\n            }\n            if (!newNext) {\n                break;\n            } // done if touched all outgoers already\n            eles = next;\n        }\n        return this.spawn(sEles, true).filter(selector);\n    };\n};\nelesfn$2.clearTraversalCache = function() {\n    for(var i = 0; i < this.length; i++){\n        this[i]._private.traversalCache = null;\n    }\n};\nextend(elesfn$2, {\n    // get the root nodes in the DAG\n    roots: defineDagExtremity({\n        noIncomingEdges: true\n    }),\n    // get the leaf nodes in the DAG\n    leaves: defineDagExtremity({\n        noOutgoingEdges: true\n    }),\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: cache(defineDagOneHop({\n        outgoing: true\n    }), \"outgoers\"),\n    // aka DAG descendants\n    successors: defineDagAllHops({\n        outgoing: true\n    }),\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: cache(defineDagOneHop({\n        incoming: true\n    }), \"incomers\"),\n    // aka DAG ancestors\n    predecessors: defineDagAllHops({})\n});\n// Neighbourhood functions\n//////////////////////////\nextend(elesfn$2, {\n    neighborhood: cache(function(selector) {\n        var elements = [];\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            // for all nodes\n            var node = nodes[i];\n            var connectedEdges = node.connectedEdges();\n            // for each connected edge, add the edge and the other node\n            for(var j = 0; j < connectedEdges.length; j++){\n                var edge = connectedEdges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                var otherNode = node === src ? tgt : src;\n                // need check in case of loop\n                if (otherNode.length > 0) {\n                    elements.push(otherNode[0]); // add node 1 hop away\n                }\n                // add connected edge\n                elements.push(edge[0]);\n            }\n        }\n        return this.spawn(elements, true).filter(selector);\n    }, \"neighborhood\"),\n    closedNeighborhood: function closedNeighborhood(selector) {\n        return this.neighborhood().add(this).filter(selector);\n    },\n    openNeighborhood: function openNeighborhood(selector) {\n        return this.neighborhood(selector);\n    }\n});\n// aliases\nelesfn$2.neighbourhood = elesfn$2.neighborhood;\nelesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\nelesfn$2.openNeighbourhood = elesfn$2.openNeighborhood;\n// Edge functions\n/////////////////\nextend(elesfn$2, {\n    source: cache(function sourceImpl(selector) {\n        var ele = this[0];\n        var src;\n        if (ele) {\n            src = ele._private.source || ele.cy().collection();\n        }\n        return src && selector ? src.filter(selector) : src;\n    }, \"source\"),\n    target: cache(function targetImpl(selector) {\n        var ele = this[0];\n        var tgt;\n        if (ele) {\n            tgt = ele._private.target || ele.cy().collection();\n        }\n        return tgt && selector ? tgt.filter(selector) : tgt;\n    }, \"target\"),\n    sources: defineSourceFunction({\n        attr: \"source\"\n    }),\n    targets: defineSourceFunction({\n        attr: \"target\"\n    })\n});\nfunction defineSourceFunction(params) {\n    return function sourceImpl(selector) {\n        var sources = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var src = ele._private[params.attr];\n            if (src) {\n                sources.push(src);\n            }\n        }\n        return this.spawn(sources, true).filter(selector);\n    };\n}\nextend(elesfn$2, {\n    edgesWith: cache(defineEdgesWithFunction(), \"edgesWith\"),\n    edgesTo: cache(defineEdgesWithFunction({\n        thisIsSrc: true\n    }), \"edgesTo\")\n});\nfunction defineEdgesWithFunction(params) {\n    return function edgesWithImpl(otherNodes) {\n        var elements = [];\n        var cy = this._private.cy;\n        var p = params || {};\n        // get elements if a selector is specified\n        if (string(otherNodes)) {\n            otherNodes = cy.$(otherNodes);\n        }\n        for(var h = 0; h < otherNodes.length; h++){\n            var edges = otherNodes[h]._private.edges;\n            for(var i = 0; i < edges.length; i++){\n                var edge = edges[i];\n                var edgeData = edge._private.data;\n                var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n                var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n                var edgeConnectsThisAndOther = thisToOther || otherToThis;\n                if (!edgeConnectsThisAndOther) {\n                    continue;\n                }\n                if (p.thisIsSrc || p.thisIsTgt) {\n                    if (p.thisIsSrc && !thisToOther) {\n                        continue;\n                    }\n                    if (p.thisIsTgt && !otherToThis) {\n                        continue;\n                    }\n                }\n                elements.push(edge);\n            }\n        }\n        return this.spawn(elements, true);\n    };\n}\nextend(elesfn$2, {\n    connectedEdges: cache(function(selector) {\n        var retEles = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var node = eles[i];\n            if (!node.isNode()) {\n                continue;\n            }\n            var edges = node._private.edges;\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                retEles.push(edge);\n            }\n        }\n        return this.spawn(retEles, true).filter(selector);\n    }, \"connectedEdges\"),\n    connectedNodes: cache(function(selector) {\n        var retEles = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var edge = eles[i];\n            if (!edge.isEdge()) {\n                continue;\n            }\n            retEles.push(edge.source()[0]);\n            retEles.push(edge.target()[0]);\n        }\n        return this.spawn(retEles, true).filter(selector);\n    }, \"connectedNodes\"),\n    parallelEdges: cache(defineParallelEdgesFunction(), \"parallelEdges\"),\n    codirectedEdges: cache(defineParallelEdgesFunction({\n        codirected: true\n    }), \"codirectedEdges\")\n});\nfunction defineParallelEdgesFunction(params) {\n    var defaults = {\n        codirected: false\n    };\n    params = extend({}, defaults, params);\n    return function parallelEdgesImpl(selector) {\n        // micro-optimised for renderer\n        var elements = [];\n        var edges = this.edges();\n        var p = params;\n        // look at all the edges in the collection\n        for(var i = 0; i < edges.length; i++){\n            var edge1 = edges[i];\n            var edge1_p = edge1._private;\n            var src1 = edge1_p.source;\n            var srcid1 = src1._private.data.id;\n            var tgtid1 = edge1_p.data.target;\n            var srcEdges1 = src1._private.edges;\n            // look at edges connected to the src node of this edge\n            for(var j = 0; j < srcEdges1.length; j++){\n                var edge2 = srcEdges1[j];\n                var edge2data = edge2._private.data;\n                var tgtid2 = edge2data.target;\n                var srcid2 = edge2data.source;\n                var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n                var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n                if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n                    elements.push(edge2);\n                }\n            }\n        }\n        return this.spawn(elements, true).filter(selector);\n    };\n}\n// Misc functions\n/////////////////\nextend(elesfn$2, {\n    components: function components(root) {\n        var self1 = this;\n        var cy = self1.cy();\n        var visited = cy.collection();\n        var unvisited = root == null ? self1.nodes() : root.nodes();\n        var components = [];\n        if (root != null && unvisited.empty()) {\n            // root may contain only edges\n            unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n        }\n        var visitInComponent = function visitInComponent(node, component) {\n            visited.merge(node);\n            unvisited.unmerge(node);\n            component.merge(node);\n        };\n        if (unvisited.empty()) {\n            return self1.spawn();\n        }\n        var _loop = function _loop() {\n            // each iteration yields a component\n            var cmpt = cy.collection();\n            components.push(cmpt);\n            var root = unvisited[0];\n            visitInComponent(root, cmpt);\n            self1.bfs({\n                directed: false,\n                roots: root,\n                visit: function visit(v) {\n                    return visitInComponent(v, cmpt);\n                }\n            });\n            cmpt.forEach(function(node) {\n                node.connectedEdges().forEach(function(e) {\n                    // connectedEdges() usually cached\n                    if (self1.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n                        // has() is cheap\n                        cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n                    }\n                });\n            });\n        };\n        do {\n            _loop();\n        }while (unvisited.length > 0);\n        return components;\n    },\n    component: function component() {\n        var ele = this[0];\n        return ele.cy().mutableElements().components(ele)[0];\n    }\n});\nelesfn$2.componentsOf = elesfn$2.components;\n// represents a set of nodes, edges, or both together\nvar Collection = function Collection(cy, elements) {\n    var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (cy === undefined) {\n        error(\"A collection must have a reference to the core\");\n        return;\n    }\n    var map = new Map$1();\n    var createdElements = false;\n    if (!elements) {\n        elements = [];\n    } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n        createdElements = true;\n        // make elements from json and restore all at once later\n        var eles = [];\n        var elesIds = new Set$1();\n        for(var i = 0, l = elements.length; i < l; i++){\n            var json = elements[i];\n            if (json.data == null) {\n                json.data = {};\n            }\n            var _data = json.data;\n            // make sure newly created elements have valid ids\n            if (_data.id == null) {\n                _data.id = uuid();\n            } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n                continue; // can't create element if prior id already exists\n            }\n            var ele = new Element(cy, json, false);\n            eles.push(ele);\n            elesIds.add(_data.id);\n        }\n        elements = eles;\n    }\n    this.length = 0;\n    for(var _i = 0, _l = elements.length; _i < _l; _i++){\n        var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n        if (element$1 == null) {\n            continue;\n        }\n        var id = element$1._private.data.id;\n        if (!unique || !map.has(id)) {\n            if (unique) {\n                map.set(id, {\n                    index: this.length,\n                    ele: element$1\n                });\n            }\n            this[this.length] = element$1;\n            this.length++;\n        }\n    }\n    this._private = {\n        eles: this,\n        cy: cy,\n        get map () {\n            if (this.lazyMap == null) {\n                this.rebuildMap();\n            }\n            return this.lazyMap;\n        },\n        set map (m){\n            this.lazyMap = m;\n        },\n        rebuildMap: function rebuildMap() {\n            var m1 = this.lazyMap = new Map$1();\n            var eles = this.eles;\n            for(var _i2 = 0; _i2 < eles.length; _i2++){\n                var _ele = eles[_i2];\n                m1.set(_ele.id(), {\n                    index: _i2,\n                    ele: _ele\n                });\n            }\n        }\n    };\n    if (unique) {\n        this._private.map = map;\n    }\n    // restore the elements if we created them from json\n    if (createdElements && !removed) {\n        this.restore();\n    }\n};\n// Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\nvar elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\nelesfn$1.instanceString = function() {\n    return \"collection\";\n};\nelesfn$1.spawn = function(eles, unique) {\n    return new Collection(this.cy(), eles, unique);\n};\nelesfn$1.spawnSelf = function() {\n    return this.spawn(this);\n};\nelesfn$1.cy = function() {\n    return this._private.cy;\n};\nelesfn$1.renderer = function() {\n    return this._private.cy.renderer();\n};\nelesfn$1.element = function() {\n    return this[0];\n};\nelesfn$1.collection = function() {\n    if (collection(this)) {\n        return this;\n    } else {\n        // an element\n        return new Collection(this._private.cy, [\n            this\n        ]);\n    }\n};\nelesfn$1.unique = function() {\n    return new Collection(this._private.cy, this, true);\n};\nelesfn$1.hasElementWithId = function(id) {\n    id = \"\" + id; // id must be string\n    return this._private.map.has(id);\n};\nelesfn$1.getElementById = function(id) {\n    id = \"\" + id; // id must be string\n    var cy = this._private.cy;\n    var entry = this._private.map.get(id);\n    return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\nelesfn$1.$id = elesfn$1.getElementById;\nelesfn$1.poolIndex = function() {\n    var cy = this._private.cy;\n    var eles = cy._private.elements;\n    var id = this[0]._private.data.id;\n    return eles._private.map.get(id).index;\n};\nelesfn$1.indexOf = function(ele) {\n    var id = ele[0]._private.data.id;\n    return this._private.map.get(id).index;\n};\nelesfn$1.indexOfId = function(id) {\n    id = \"\" + id; // id must be string\n    return this._private.map.get(id).index;\n};\nelesfn$1.json = function(obj) {\n    var ele = this.element();\n    var cy = this.cy();\n    if (ele == null && obj) {\n        return this;\n    } // can't set to no eles\n    if (ele == null) {\n        return undefined;\n    } // can't get from no eles\n    var p = ele._private;\n    if (plainObject(obj)) {\n        // set\n        cy.startBatch();\n        if (obj.data) {\n            ele.data(obj.data);\n            var _data2 = p.data;\n            if (ele.isEdge()) {\n                // source and target are immutable via data()\n                var move = false;\n                var spec = {};\n                var src = obj.data.source;\n                var tgt = obj.data.target;\n                if (src != null && src != _data2.source) {\n                    spec.source = \"\" + src; // id must be string\n                    move = true;\n                }\n                if (tgt != null && tgt != _data2.target) {\n                    spec.target = \"\" + tgt; // id must be string\n                    move = true;\n                }\n                if (move) {\n                    ele = ele.move(spec);\n                }\n            } else {\n                // parent is immutable via data()\n                var newParentValSpecd = \"parent\" in obj.data;\n                var parent = obj.data.parent;\n                if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n                    if (parent === undefined) {\n                        // can't set undefined imperatively, so use null\n                        parent = null;\n                    }\n                    if (parent != null) {\n                        parent = \"\" + parent; // id must be string\n                    }\n                    ele = ele.move({\n                        parent: parent\n                    });\n                }\n            }\n        }\n        if (obj.position) {\n            ele.position(obj.position);\n        }\n        // ignore group -- immutable\n        var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n            var obj_k = obj[k];\n            if (obj_k != null && obj_k !== p[k]) {\n                if (obj_k) {\n                    ele[trueFnName]();\n                } else {\n                    ele[falseFnName]();\n                }\n            }\n        };\n        checkSwitch(\"removed\", \"remove\", \"restore\");\n        checkSwitch(\"selected\", \"select\", \"unselect\");\n        checkSwitch(\"selectable\", \"selectify\", \"unselectify\");\n        checkSwitch(\"locked\", \"lock\", \"unlock\");\n        checkSwitch(\"grabbable\", \"grabify\", \"ungrabify\");\n        checkSwitch(\"pannable\", \"panify\", \"unpanify\");\n        if (obj.classes != null) {\n            ele.classes(obj.classes);\n        }\n        cy.endBatch();\n        return this;\n    } else if (obj === undefined) {\n        // get\n        var json = {\n            data: copy(p.data),\n            position: copy(p.position),\n            group: p.group,\n            removed: p.removed,\n            selected: p.selected,\n            selectable: p.selectable,\n            locked: p.locked,\n            grabbable: p.grabbable,\n            pannable: p.pannable,\n            classes: null\n        };\n        json.classes = \"\";\n        var i = 0;\n        p.classes.forEach(function(cls) {\n            return json.classes += i++ === 0 ? cls : \" \" + cls;\n        });\n        return json;\n    }\n};\nelesfn$1.jsons = function() {\n    var jsons = [];\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var json = ele.json();\n        jsons.push(json);\n    }\n    return jsons;\n};\nelesfn$1.clone = function() {\n    var cy = this.cy();\n    var elesArr = [];\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var json = ele.json();\n        var clone = new Element(cy, json, false); // NB no restore\n        elesArr.push(clone);\n    }\n    return new Collection(cy, elesArr);\n};\nelesfn$1.copy = elesfn$1.clone;\nelesfn$1.restore = function() {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self1 = this;\n    var cy = self1.cy();\n    var cy_p = cy._private;\n    // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n    var nodes = [];\n    var edges = [];\n    var elements;\n    for(var _i3 = 0, l = self1.length; _i3 < l; _i3++){\n        var ele = self1[_i3];\n        if (addToPool && !ele.removed()) {\n            continue;\n        }\n        // keep nodes first in the array and edges after\n        if (ele.isNode()) {\n            // put to front of array if node\n            nodes.push(ele);\n        } else {\n            // put to end of array if edge\n            edges.push(ele);\n        }\n    }\n    elements = nodes.concat(edges);\n    var i;\n    var removeFromElements = function removeFromElements() {\n        elements.splice(i, 1);\n        i--;\n    };\n    // now, restore each element\n    for(i = 0; i < elements.length; i++){\n        var _ele2 = elements[i];\n        var _private = _ele2._private;\n        var _data3 = _private.data;\n        // the traversal cache should start fresh when ele is added\n        _ele2.clearTraversalCache();\n        // set id and validate\n        if (!addToPool && !_private.removed) ;\n        else if (_data3.id === undefined) {\n            _data3.id = uuid();\n        } else if (number$1(_data3.id)) {\n            _data3.id = \"\" + _data3.id; // now it's a string\n        } else if (emptyString(_data3.id) || !string(_data3.id)) {\n            error(\"Can not create element with invalid string ID `\" + _data3.id + \"`\");\n            // can't create element if it has empty string as id or non-string id\n            removeFromElements();\n            continue;\n        } else if (cy.hasElementWithId(_data3.id)) {\n            error(\"Can not create second element with ID `\" + _data3.id + \"`\");\n            // can't create element if one already has that id\n            removeFromElements();\n            continue;\n        }\n        var id = _data3.id; // id is finalised, now let's keep a ref\n        if (_ele2.isNode()) {\n            // extra checks for nodes\n            var pos = _private.position;\n            // make sure the nodes have a defined position\n            if (pos.x == null) {\n                pos.x = 0;\n            }\n            if (pos.y == null) {\n                pos.y = 0;\n            }\n        }\n        if (_ele2.isEdge()) {\n            // extra checks for edges\n            var edge = _ele2;\n            var fields = [\n                \"source\",\n                \"target\"\n            ];\n            var fieldsLength = fields.length;\n            var badSourceOrTarget = false;\n            for(var j = 0; j < fieldsLength; j++){\n                var field = fields[j];\n                var val = _data3[field];\n                if (number$1(val)) {\n                    val = _data3[field] = \"\" + _data3[field]; // now string\n                }\n                if (val == null || val === \"\") {\n                    // can't create if source or target is not defined properly\n                    error(\"Can not create edge `\" + id + \"` with unspecified \" + field);\n                    badSourceOrTarget = true;\n                } else if (!cy.hasElementWithId(val)) {\n                    // can't create edge if one of its nodes doesn't exist\n                    error(\"Can not create edge `\" + id + \"` with nonexistant \" + field + \" `\" + val + \"`\");\n                    badSourceOrTarget = true;\n                }\n            }\n            if (badSourceOrTarget) {\n                removeFromElements();\n                continue;\n            } // can't create this\n            var src = cy.getElementById(_data3.source);\n            var tgt = cy.getElementById(_data3.target);\n            // only one edge in node if loop\n            if (src.same(tgt)) {\n                src._private.edges.push(edge);\n            } else {\n                src._private.edges.push(edge);\n                tgt._private.edges.push(edge);\n            }\n            edge._private.source = src;\n            edge._private.target = tgt;\n        } // if is edge\n        // create mock ids / indexes maps for element so it can be used like collections\n        _private.map = new Map$1();\n        _private.map.set(id, {\n            ele: _ele2,\n            index: 0\n        });\n        _private.removed = false;\n        if (addToPool) {\n            cy.addToPool(_ele2);\n        }\n    } // for each element\n    // do compound node sanity checks\n    for(var _i4 = 0; _i4 < nodes.length; _i4++){\n        // each node\n        var node = nodes[_i4];\n        var _data4 = node._private.data;\n        if (number$1(_data4.parent)) {\n            // then automake string\n            _data4.parent = \"\" + _data4.parent;\n        }\n        var parentId = _data4.parent;\n        var specifiedParent = parentId != null;\n        if (specifiedParent || node._private.parent) {\n            var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n            if (parent.empty()) {\n                // non-existant parent; just remove it\n                _data4.parent = undefined;\n            } else if (parent[0].removed()) {\n                warn(\"Node added with missing parent, reference to parent removed\");\n                _data4.parent = undefined;\n                node._private.parent = null;\n            } else {\n                var selfAsParent = false;\n                var ancestor = parent;\n                while(!ancestor.empty()){\n                    if (node.same(ancestor)) {\n                        // mark self as parent and remove from data\n                        selfAsParent = true;\n                        _data4.parent = undefined; // remove parent reference\n                        break;\n                    }\n                    ancestor = ancestor.parent();\n                }\n                if (!selfAsParent) {\n                    // connect with children\n                    parent[0]._private.children.push(node);\n                    node._private.parent = parent[0];\n                    // let the core know we have a compound graph\n                    cy_p.hasCompoundNodes = true;\n                }\n            } // else\n        } // if specified parent\n    } // for each node\n    if (elements.length > 0) {\n        var restored = elements.length === self1.length ? self1 : new Collection(cy, elements);\n        for(var _i5 = 0; _i5 < restored.length; _i5++){\n            var _ele3 = restored[_i5];\n            if (_ele3.isNode()) {\n                continue;\n            }\n            // adding an edge invalidates the traversal caches for the parallel edges\n            _ele3.parallelEdges().clearTraversalCache();\n            // adding an edge invalidates the traversal cache for the connected nodes\n            _ele3.source().clearTraversalCache();\n            _ele3.target().clearTraversalCache();\n        }\n        var toUpdateStyle;\n        if (cy_p.hasCompoundNodes) {\n            toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n        } else {\n            toUpdateStyle = restored;\n        }\n        toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n        if (notifyRenderer) {\n            restored.emitAndNotify(\"add\");\n        } else if (addToPool) {\n            restored.emit(\"add\");\n        }\n    }\n    return self1; // chainability\n};\nelesfn$1.removed = function() {\n    var ele = this[0];\n    return ele && ele._private.removed;\n};\nelesfn$1.inside = function() {\n    var ele = this[0];\n    return ele && !ele._private.removed;\n};\nelesfn$1.remove = function() {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self1 = this;\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self1._private.cy;\n    // add connected edges\n    function addConnectedEdges(node) {\n        var edges = node._private.edges;\n        for(var i = 0; i < edges.length; i++){\n            add(edges[i]);\n        }\n    }\n    // add descendant nodes\n    function addChildren(node) {\n        var children = node._private.children;\n        for(var i = 0; i < children.length; i++){\n            add(children[i]);\n        }\n    }\n    function add(ele) {\n        var alreadyAdded = elesToRemoveIds[ele.id()];\n        if (removeFromPool && ele.removed() || alreadyAdded) {\n            return;\n        } else {\n            elesToRemoveIds[ele.id()] = true;\n        }\n        if (ele.isNode()) {\n            elesToRemove.push(ele); // nodes are removed last\n            addConnectedEdges(ele);\n            addChildren(ele);\n        } else {\n            elesToRemove.unshift(ele); // edges are removed first\n        }\n    }\n    // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n    for(var i = 0, l = self1.length; i < l; i++){\n        var ele = self1[i];\n        add(ele);\n    }\n    function removeEdgeRef(node, edge) {\n        var connectedEdges = node._private.edges;\n        removeFromArray(connectedEdges, edge);\n        // removing an edges invalidates the traversal cache for its nodes\n        node.clearTraversalCache();\n    }\n    function removeParallelRef(pllEdge) {\n        // removing an edge invalidates the traversal caches for the parallel edges\n        pllEdge.clearTraversalCache();\n    }\n    var alteredParents = [];\n    alteredParents.ids = {};\n    function removeChildRef(parent, ele) {\n        ele = ele[0];\n        parent = parent[0];\n        var children = parent._private.children;\n        var pid = parent.id();\n        removeFromArray(children, ele); // remove parent => child ref\n        ele._private.parent = null; // remove child => parent ref\n        if (!alteredParents.ids[pid]) {\n            alteredParents.ids[pid] = true;\n            alteredParents.push(parent);\n        }\n    }\n    self1.dirtyCompoundBoundsCache();\n    if (removeFromPool) {\n        cy.removeFromPool(elesToRemove); // remove from core pool\n    }\n    for(var _i6 = 0; _i6 < elesToRemove.length; _i6++){\n        var _ele4 = elesToRemove[_i6];\n        if (_ele4.isEdge()) {\n            // remove references to this edge in its connected nodes\n            var src = _ele4.source()[0];\n            var tgt = _ele4.target()[0];\n            removeEdgeRef(src, _ele4);\n            removeEdgeRef(tgt, _ele4);\n            var pllEdges = _ele4.parallelEdges();\n            for(var j = 0; j < pllEdges.length; j++){\n                var pllEdge = pllEdges[j];\n                removeParallelRef(pllEdge);\n                if (pllEdge.isBundledBezier()) {\n                    pllEdge.dirtyBoundingBoxCache();\n                }\n            }\n        } else {\n            // remove reference to parent\n            var parent = _ele4.parent();\n            if (parent.length !== 0) {\n                removeChildRef(parent, _ele4);\n            }\n        }\n        if (removeFromPool) {\n            // mark as removed\n            _ele4._private.removed = true;\n        }\n    }\n    // check to see if we have a compound graph or not\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n    for(var _i7 = 0; _i7 < elesStillInside.length; _i7++){\n        var _ele5 = elesStillInside[_i7];\n        if (_ele5.isParent()) {\n            cy._private.hasCompoundNodes = true;\n            break;\n        }\n    }\n    var removedElements = new Collection(this.cy(), elesToRemove);\n    if (removedElements.size() > 0) {\n        // must manually notify since trigger won't do this automatically once removed\n        if (notifyRenderer) {\n            removedElements.emitAndNotify(\"remove\");\n        } else if (removeFromPool) {\n            removedElements.emit(\"remove\");\n        }\n    }\n    // the parents who were modified by the removal need their style updated\n    for(var _i8 = 0; _i8 < alteredParents.length; _i8++){\n        var _ele6 = alteredParents[_i8];\n        if (!removeFromPool || !_ele6.removed()) {\n            _ele6.updateStyle();\n        }\n    }\n    return removedElements;\n};\nelesfn$1.move = function(struct) {\n    var cy = this._private.cy;\n    var eles = this;\n    // just clean up refs, caches, etc. in the same way as when removing and then restoring\n    // (our calls to remove/restore do not remove from the graph or make events)\n    var notifyRenderer = false;\n    var modifyPool = false;\n    var toString = function toString(id) {\n        return id == null ? id : \"\" + id;\n    }; // id must be string\n    if (struct.source !== undefined || struct.target !== undefined) {\n        var srcId = toString(struct.source);\n        var tgtId = toString(struct.target);\n        var srcExists = srcId != null && cy.hasElementWithId(srcId);\n        var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n        if (srcExists || tgtExists) {\n            cy.batch(function() {\n                // avoid duplicate style updates\n                eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                eles.emitAndNotify(\"moveout\");\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _data5 = ele._private.data;\n                    if (ele.isEdge()) {\n                        if (srcExists) {\n                            _data5.source = srcId;\n                        }\n                        if (tgtExists) {\n                            _data5.target = tgtId;\n                        }\n                    }\n                }\n                eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n            });\n            eles.emitAndNotify(\"move\");\n        }\n    } else if (struct.parent !== undefined) {\n        // move node to new parent\n        var parentId = toString(struct.parent);\n        var parentExists = parentId === null || cy.hasElementWithId(parentId);\n        if (parentExists) {\n            var pidToAssign = parentId === null ? undefined : parentId;\n            cy.batch(function() {\n                // avoid duplicate style updates\n                var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                updated.emitAndNotify(\"moveout\");\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _data6 = ele._private.data;\n                    if (ele.isNode()) {\n                        _data6.parent = pidToAssign;\n                    }\n                }\n                updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n            });\n            eles.emitAndNotify(\"move\");\n        }\n    }\n    return this;\n};\n[\n    elesfn$j,\n    elesfn$i,\n    elesfn$h,\n    elesfn$g,\n    elesfn$f,\n    data,\n    elesfn$d,\n    dimensions,\n    elesfn$9,\n    elesfn$8,\n    elesfn$7,\n    elesfn$6,\n    elesfn$5,\n    elesfn$4,\n    elesfn$3,\n    elesfn$2\n].forEach(function(props) {\n    extend(elesfn$1, props);\n});\nvar corefn$9 = {\n    add: function add(opts) {\n        var elements;\n        var cy = this;\n        // add the elements\n        if (elementOrCollection(opts)) {\n            var eles = opts;\n            if (eles._private.cy === cy) {\n                // same instance => just restore\n                elements = eles.restore();\n            } else {\n                // otherwise, copy from json\n                var jsons = [];\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    jsons.push(ele.json());\n                }\n                elements = new Collection(cy, jsons);\n            }\n        } else if (array(opts)) {\n            var _jsons = opts;\n            elements = new Collection(cy, _jsons);\n        } else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n            var elesByGroup = opts;\n            var _jsons2 = [];\n            var grs = [\n                \"nodes\",\n                \"edges\"\n            ];\n            for(var _i = 0, il = grs.length; _i < il; _i++){\n                var group = grs[_i];\n                var elesArray = elesByGroup[group];\n                if (array(elesArray)) {\n                    for(var j = 0, jl = elesArray.length; j < jl; j++){\n                        var json = extend({\n                            group: group\n                        }, elesArray[j]);\n                        _jsons2.push(json);\n                    }\n                }\n            }\n            elements = new Collection(cy, _jsons2);\n        } else {\n            var _json = opts;\n            elements = new Element(cy, _json).collection();\n        }\n        return elements;\n    },\n    remove: function remove(collection) {\n        if (elementOrCollection(collection)) ;\n        else if (string(collection)) {\n            var selector = collection;\n            collection = this.$(selector);\n        }\n        return collection.remove();\n    }\n};\n/* global Float32Array */ /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */ function generateCubicBezier(mX1, mY1, mX2, mY2) {\n    var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 0.001, SUBDIVISION_PRECISION = 0.0000001, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1.0 / (kSplineTableSize - 1.0), float32ArraySupported = typeof Float32Array !== \"undefined\";\n    /* Must contain four arguments. */ if (arguments.length !== 4) {\n        return false;\n    }\n    /* Arguments must be numbers. */ for(var i = 0; i < 4; ++i){\n        if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n            return false;\n        }\n    }\n    /* X values must be in the [0, 1] range. */ mX1 = Math.min(mX1, 1);\n    mX2 = Math.min(mX2, 1);\n    mX1 = Math.max(mX1, 0);\n    mX2 = Math.max(mX2, 0);\n    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function newtonRaphsonIterate(aX, aGuessT) {\n        for(var _i = 0; _i < NEWTON_ITERATIONS; ++_i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function calcSampleValues() {\n        for(var _i2 = 0; _i2 < kSplineTableSize; ++_i2){\n            mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function binarySubdivide(aX, aA, aB) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    }\n    function getTForX(aX) {\n        var intervalStart = 0.0, currentSample = 1, lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n        }\n    }\n    var _precomputed = false;\n    function precompute() {\n        _precomputed = true;\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            calcSampleValues();\n        }\n    }\n    var f = function f(aX) {\n        if (!_precomputed) {\n            precompute();\n        }\n        if (mX1 === mY1 && mX2 === mY2) {\n            return aX;\n        }\n        if (aX === 0) {\n            return 0;\n        }\n        if (aX === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(aX), mY1, mY2);\n    };\n    f.getControlPoints = function() {\n        return [\n            {\n                x: mX1,\n                y: mY1\n            },\n            {\n                x: mX2,\n                y: mY2\n            }\n        ];\n    };\n    var str = \"generateBezier(\" + [\n        mX1,\n        mY1,\n        mX2,\n        mY2\n    ] + \")\";\n    f.toString = function() {\n        return str;\n    };\n    return f;\n}\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */ /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */ var generateSpringRK4 = function() {\n    function springAccelerationForState(state) {\n        return -state.tension * state.x - state.friction * state.v;\n    }\n    function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n        var state = {\n            x: initialState.x + derivative.dx * dt,\n            v: initialState.v + derivative.dv * dt,\n            tension: initialState.tension,\n            friction: initialState.friction\n        };\n        return {\n            dx: state.v,\n            dv: springAccelerationForState(state)\n        };\n    }\n    function springIntegrateState(state, dt) {\n        var a = {\n            dx: state.v,\n            dv: springAccelerationForState(state)\n        }, b = springEvaluateStateWithDerivative(state, dt * 0.5, a), c = springEvaluateStateWithDerivative(state, dt * 0.5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx), dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n        state.x = state.x + dxdt * dt;\n        state.v = state.v + dvdt * dt;\n        return state;\n    }\n    return function springRK4Factory(tension, friction, duration) {\n        var initState = {\n            x: -1,\n            v: 0,\n            tension: null,\n            friction: null\n        }, path = [\n            0\n        ], time_lapsed = 0, tolerance = 1 / 10000, DT = 16 / 1000, have_duration, dt, last_state;\n        tension = parseFloat(tension) || 500;\n        friction = parseFloat(friction) || 20;\n        duration = duration || null;\n        initState.tension = tension;\n        initState.friction = friction;\n        have_duration = duration !== null;\n        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */ if (have_duration) {\n            /* Run the simulation without a duration. */ time_lapsed = springRK4Factory(tension, friction);\n            /* Compute the adjusted time delta. */ dt = time_lapsed / duration * DT;\n        } else {\n            dt = DT;\n        }\n        for(;;){\n            /* Next/step function .*/ last_state = springIntegrateState(last_state || initState, dt);\n            /* Store the position. */ path.push(1 + last_state.x);\n            time_lapsed += 16;\n            /* If the change threshold is reached, break. */ if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n                break;\n            }\n        }\n        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */ return !have_duration ? time_lapsed : function(percentComplete) {\n            return path[percentComplete * (path.length - 1) | 0];\n        };\n    };\n}();\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n    var bezier = generateCubicBezier(t1, p1, t2, p2);\n    return function(start, end, percent) {\n        return start + (end - start) * bezier(percent);\n    };\n};\nvar easings = {\n    \"linear\": function linear(start, end, percent) {\n        return start + (end - start) * percent;\n    },\n    // default easings\n    \"ease\": cubicBezier(0.25, 0.1, 0.25, 1),\n    \"ease-in\": cubicBezier(0.42, 0, 1, 1),\n    \"ease-out\": cubicBezier(0, 0, 0.58, 1),\n    \"ease-in-out\": cubicBezier(0.42, 0, 0.58, 1),\n    // sine\n    \"ease-in-sine\": cubicBezier(0.47, 0, 0.745, 0.715),\n    \"ease-out-sine\": cubicBezier(0.39, 0.575, 0.565, 1),\n    \"ease-in-out-sine\": cubicBezier(0.445, 0.05, 0.55, 0.95),\n    // quad\n    \"ease-in-quad\": cubicBezier(0.55, 0.085, 0.68, 0.53),\n    \"ease-out-quad\": cubicBezier(0.25, 0.46, 0.45, 0.94),\n    \"ease-in-out-quad\": cubicBezier(0.455, 0.03, 0.515, 0.955),\n    // cubic\n    \"ease-in-cubic\": cubicBezier(0.55, 0.055, 0.675, 0.19),\n    \"ease-out-cubic\": cubicBezier(0.215, 0.61, 0.355, 1),\n    \"ease-in-out-cubic\": cubicBezier(0.645, 0.045, 0.355, 1),\n    // quart\n    \"ease-in-quart\": cubicBezier(0.895, 0.03, 0.685, 0.22),\n    \"ease-out-quart\": cubicBezier(0.165, 0.84, 0.44, 1),\n    \"ease-in-out-quart\": cubicBezier(0.77, 0, 0.175, 1),\n    // quint\n    \"ease-in-quint\": cubicBezier(0.755, 0.05, 0.855, 0.06),\n    \"ease-out-quint\": cubicBezier(0.23, 1, 0.32, 1),\n    \"ease-in-out-quint\": cubicBezier(0.86, 0, 0.07, 1),\n    // expo\n    \"ease-in-expo\": cubicBezier(0.95, 0.05, 0.795, 0.035),\n    \"ease-out-expo\": cubicBezier(0.19, 1, 0.22, 1),\n    \"ease-in-out-expo\": cubicBezier(1, 0, 0, 1),\n    // circ\n    \"ease-in-circ\": cubicBezier(0.6, 0.04, 0.98, 0.335),\n    \"ease-out-circ\": cubicBezier(0.075, 0.82, 0.165, 1),\n    \"ease-in-out-circ\": cubicBezier(0.785, 0.135, 0.15, 0.86),\n    // user param easings...\n    \"spring\": function spring(tension, friction, duration) {\n        if (duration === 0) {\n            // can't get a spring w/ duration 0\n            return easings.linear; // duration 0 => jump to end so impl doesn't matter\n        }\n        var spring = generateSpringRK4(tension, friction, duration);\n        return function(start, end, percent) {\n            return start + (end - start) * spring(percent);\n        };\n    },\n    \"cubic-bezier\": cubicBezier\n};\nfunction getEasedValue(type, start, end, percent, easingFn) {\n    if (percent === 1) {\n        return end;\n    }\n    if (start === end) {\n        return end;\n    }\n    var val = easingFn(start, end, percent);\n    if (type == null) {\n        return val;\n    }\n    if (type.roundValue || type.color) {\n        val = Math.round(val);\n    }\n    if (type.min !== undefined) {\n        val = Math.max(val, type.min);\n    }\n    if (type.max !== undefined) {\n        val = Math.min(val, type.max);\n    }\n    return val;\n}\nfunction getValue(prop, spec) {\n    if (prop.pfValue != null || prop.value != null) {\n        if (prop.pfValue != null && (spec == null || spec.type.units !== \"%\")) {\n            return prop.pfValue;\n        } else {\n            return prop.value;\n        }\n    } else {\n        return prop;\n    }\n}\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n    var type = propSpec != null ? propSpec.type : null;\n    if (percent < 0) {\n        percent = 0;\n    } else if (percent > 1) {\n        percent = 1;\n    }\n    var start = getValue(startProp, propSpec);\n    var end = getValue(endProp, propSpec);\n    if (number$1(start) && number$1(end)) {\n        return getEasedValue(type, start, end, percent, easingFn);\n    } else if (array(start) && array(end)) {\n        var easedArr = [];\n        for(var i = 0; i < end.length; i++){\n            var si = start[i];\n            var ei = end[i];\n            if (si != null && ei != null) {\n                var val = getEasedValue(type, si, ei, percent, easingFn);\n                easedArr.push(val);\n            } else {\n                easedArr.push(ei);\n            }\n        }\n        return easedArr;\n    }\n    return undefined;\n}\nfunction step$1(self1, ani, now, isCore) {\n    var isEles = !isCore;\n    var _p = self1._private;\n    var ani_p = ani._private;\n    var pEasing = ani_p.easing;\n    var startTime = ani_p.startTime;\n    var cy = isCore ? self1 : self1.cy();\n    var style = cy.style();\n    if (!ani_p.easingImpl) {\n        if (pEasing == null) {\n            // use default\n            ani_p.easingImpl = easings[\"linear\"];\n        } else {\n            // then define w/ name\n            var easingVals;\n            if (string(pEasing)) {\n                var easingProp = style.parse(\"transition-timing-function\", pEasing);\n                easingVals = easingProp.value;\n            } else {\n                // then assume preparsed array\n                easingVals = pEasing;\n            }\n            var name, args;\n            if (string(easingVals)) {\n                name = easingVals;\n                args = [];\n            } else {\n                name = easingVals[1];\n                args = easingVals.slice(2).map(function(n) {\n                    return +n;\n                });\n            }\n            if (args.length > 0) {\n                // create with args\n                if (name === \"spring\") {\n                    args.push(ani_p.duration); // need duration to generate spring\n                }\n                ani_p.easingImpl = easings[name].apply(null, args);\n            } else {\n                // static impl by name\n                ani_p.easingImpl = easings[name];\n            }\n        }\n    }\n    var easing = ani_p.easingImpl;\n    var percent;\n    if (ani_p.duration === 0) {\n        percent = 1;\n    } else {\n        percent = (now - startTime) / ani_p.duration;\n    }\n    if (ani_p.applying) {\n        percent = ani_p.progress;\n    }\n    if (percent < 0) {\n        percent = 0;\n    } else if (percent > 1) {\n        percent = 1;\n    }\n    if (ani_p.delay == null) {\n        // then update\n        var startPos = ani_p.startPosition;\n        var endPos = ani_p.position;\n        if (endPos && isEles && !self1.locked()) {\n            var newPos = {};\n            if (valid(startPos.x, endPos.x)) {\n                newPos.x = ease(startPos.x, endPos.x, percent, easing);\n            }\n            if (valid(startPos.y, endPos.y)) {\n                newPos.y = ease(startPos.y, endPos.y, percent, easing);\n            }\n            self1.position(newPos);\n        }\n        var startPan = ani_p.startPan;\n        var endPan = ani_p.pan;\n        var pan = _p.pan;\n        var animatingPan = endPan != null && isCore;\n        if (animatingPan) {\n            if (valid(startPan.x, endPan.x)) {\n                pan.x = ease(startPan.x, endPan.x, percent, easing);\n            }\n            if (valid(startPan.y, endPan.y)) {\n                pan.y = ease(startPan.y, endPan.y, percent, easing);\n            }\n            self1.emit(\"pan\");\n        }\n        var startZoom = ani_p.startZoom;\n        var endZoom = ani_p.zoom;\n        var animatingZoom = endZoom != null && isCore;\n        if (animatingZoom) {\n            if (valid(startZoom, endZoom)) {\n                _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n            }\n            self1.emit(\"zoom\");\n        }\n        if (animatingPan || animatingZoom) {\n            self1.emit(\"viewport\");\n        }\n        var props = ani_p.style;\n        if (props && props.length > 0 && isEles) {\n            for(var i = 0; i < props.length; i++){\n                var prop = props[i];\n                var _name = prop.name;\n                var end = prop;\n                var start = ani_p.startStyle[_name];\n                var propSpec = style.properties[start.name];\n                var easedVal = ease(start, end, percent, easing, propSpec);\n                style.overrideBypass(self1, _name, easedVal);\n            } // for props\n            self1.emit(\"style\");\n        } // if\n    }\n    ani_p.progress = percent;\n    return percent;\n}\nfunction valid(start, end) {\n    if (start == null || end == null) {\n        return false;\n    }\n    if (number$1(start) && number$1(end)) {\n        return true;\n    } else if (start && end) {\n        return true;\n    }\n    return false;\n}\nfunction startAnimation(self1, ani, now, isCore) {\n    var ani_p = ani._private;\n    ani_p.started = true;\n    ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\nfunction stepAll(now, cy) {\n    var eles = cy._private.aniEles;\n    var doneEles = [];\n    function stepOne(ele, isCore) {\n        var _p = ele._private;\n        var current = _p.animation.current;\n        var queue = _p.animation.queue;\n        var ranAnis = false;\n        // if nothing currently animating, get something from the queue\n        if (current.length === 0) {\n            var next = queue.shift();\n            if (next) {\n                current.push(next);\n            }\n        }\n        var callbacks = function callbacks(_callbacks) {\n            for(var j = _callbacks.length - 1; j >= 0; j--){\n                var cb = _callbacks[j];\n                cb();\n            }\n            _callbacks.splice(0, _callbacks.length);\n        };\n        // step and remove if done\n        for(var i = current.length - 1; i >= 0; i--){\n            var ani = current[i];\n            var ani_p = ani._private;\n            if (ani_p.stopped) {\n                current.splice(i, 1);\n                ani_p.hooked = false;\n                ani_p.playing = false;\n                ani_p.started = false;\n                callbacks(ani_p.frames);\n                continue;\n            }\n            if (!ani_p.playing && !ani_p.applying) {\n                continue;\n            }\n            // an apply() while playing shouldn't do anything\n            if (ani_p.playing && ani_p.applying) {\n                ani_p.applying = false;\n            }\n            if (!ani_p.started) {\n                startAnimation(ele, ani, now);\n            }\n            step$1(ele, ani, now, isCore);\n            if (ani_p.applying) {\n                ani_p.applying = false;\n            }\n            callbacks(ani_p.frames);\n            if (ani_p.step != null) {\n                ani_p.step(now);\n            }\n            if (ani.completed()) {\n                current.splice(i, 1);\n                ani_p.hooked = false;\n                ani_p.playing = false;\n                ani_p.started = false;\n                callbacks(ani_p.completes);\n            }\n            ranAnis = true;\n        }\n        if (!isCore && current.length === 0 && queue.length === 0) {\n            doneEles.push(ele);\n        }\n        return ranAnis;\n    } // stepElement\n    // handle all eles\n    var ranEleAni = false;\n    for(var e = 0; e < eles.length; e++){\n        var ele = eles[e];\n        var handledThisEle = stepOne(ele);\n        ranEleAni = ranEleAni || handledThisEle;\n    } // each element\n    var ranCoreAni = stepOne(cy, true);\n    // notify renderer\n    if (ranEleAni || ranCoreAni) {\n        if (eles.length > 0) {\n            cy.notify(\"draw\", eles);\n        } else {\n            cy.notify(\"draw\");\n        }\n    }\n    // remove elements from list of currently animating if its queues are empty\n    eles.unmerge(doneEles);\n    cy.emit(\"step\");\n} // stepAll\nvar corefn$8 = {\n    // pull in animation functions\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop(),\n    addToAnimationPool: function addToAnimationPool(eles) {\n        var cy = this;\n        if (!cy.styleEnabled()) {\n            return;\n        } // save cycles when no style used\n        cy._private.aniEles.merge(eles);\n    },\n    stopAnimationLoop: function stopAnimationLoop() {\n        this._private.animationsRunning = false;\n    },\n    startAnimationLoop: function startAnimationLoop() {\n        var cy = this;\n        cy._private.animationsRunning = true;\n        if (!cy.styleEnabled()) {\n            return;\n        } // save cycles when no style used\n        // NB the animation loop will exec in headless environments if style enabled\n        // and explicit cy.destroy() is necessary to stop the loop\n        function headlessStep() {\n            if (!cy._private.animationsRunning) {\n                return;\n            }\n            requestAnimationFrame(function animationStep(now) {\n                stepAll(now, cy);\n                headlessStep();\n            });\n        }\n        var renderer = cy.renderer();\n        if (renderer && renderer.beforeRender) {\n            // let the renderer schedule animations\n            renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n                stepAll(now, cy);\n            }, renderer.beforeRenderPriorities.animations);\n        } else {\n            // manage the animation loop ourselves\n            headlessStep(); // first call\n        }\n    }\n};\nvar emitterOptions = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n        if (selector1 == null || selector2 == null) {\n            return selector1 == null && selector2 == null;\n        } else {\n            return selector1.sameText(selector2);\n        }\n    },\n    eventMatches: function eventMatches(cy, listener, eventObj) {\n        var selector = listener.qualifier;\n        if (selector != null) {\n            return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n        }\n        return true;\n    },\n    addEventFields: function addEventFields(cy, evt) {\n        evt.cy = cy;\n        evt.target = cy;\n    },\n    callbackContext: function callbackContext(cy, listener, eventObj) {\n        return listener.qualifier != null ? eventObj.target : cy;\n    }\n};\nvar argSelector = function argSelector(arg) {\n    if (string(arg)) {\n        return new Selector(arg);\n    } else {\n        return arg;\n    }\n};\nvar elesfn = {\n    createEmitter: function createEmitter() {\n        var _p = this._private;\n        if (!_p.emitter) {\n            _p.emitter = new Emitter(emitterOptions, this);\n        }\n        return this;\n    },\n    emitter: function emitter() {\n        return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n        this.emitter().on(events, argSelector(selector), callback);\n        return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n        this.emitter().removeListener(events, argSelector(selector), callback);\n        return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n        this.emitter().removeAllListeners();\n        return this;\n    },\n    one: function one(events, selector, callback) {\n        this.emitter().one(events, argSelector(selector), callback);\n        return this;\n    },\n    once: function once(events, selector, callback) {\n        this.emitter().one(events, argSelector(selector), callback);\n        return this;\n    },\n    emit: function emit(events, extraParams) {\n        this.emitter().emit(events, extraParams);\n        return this;\n    },\n    emitAndNotify: function emitAndNotify(event, eles) {\n        this.emit(event);\n        this.notify(event, eles);\n        return this;\n    }\n};\ndefine.eventAliasesOn(elesfn);\nvar corefn$7 = {\n    png: function png(options) {\n        var renderer = this._private.renderer;\n        options = options || {};\n        return renderer.png(options);\n    },\n    jpg: function jpg(options) {\n        var renderer = this._private.renderer;\n        options = options || {};\n        options.bg = options.bg || \"#fff\";\n        return renderer.jpg(options);\n    }\n};\ncorefn$7.jpeg = corefn$7.jpg;\nvar corefn$6 = {\n    layout: function layout(options) {\n        var cy = this;\n        if (options == null) {\n            error(\"Layout options must be specified to make a layout\");\n            return;\n        }\n        if (options.name == null) {\n            error(\"A `name` must be specified to make a layout\");\n            return;\n        }\n        var name = options.name;\n        var Layout = cy.extension(\"layout\", name);\n        if (Layout == null) {\n            error(\"No such layout `\" + name + \"` found.  Did you forget to import it and `cytoscape.use()` it?\");\n            return;\n        }\n        var eles;\n        if (string(options.eles)) {\n            eles = cy.$(options.eles);\n        } else {\n            eles = options.eles != null ? options.eles : cy.$();\n        }\n        var layout = new Layout(extend({}, options, {\n            cy: cy,\n            eles: eles\n        }));\n        return layout;\n    }\n};\ncorefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\nvar corefn$5 = {\n    notify: function notify(eventName, eventEles) {\n        var _p = this._private;\n        if (this.batching()) {\n            _p.batchNotifications = _p.batchNotifications || {};\n            var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n            if (eventEles != null) {\n                eles.merge(eventEles);\n            }\n            return; // notifications are disabled during batching\n        }\n        if (!_p.notificationsEnabled) {\n            return;\n        } // exit on disabled\n        var renderer = this.renderer();\n        // exit if destroy() called on core or renderer in between frames #1499 #1528\n        if (this.destroyed() || !renderer) {\n            return;\n        }\n        renderer.notify(eventName, eventEles);\n    },\n    notifications: function notifications(bool) {\n        var p = this._private;\n        if (bool === undefined) {\n            return p.notificationsEnabled;\n        } else {\n            p.notificationsEnabled = bool ? true : false;\n        }\n        return this;\n    },\n    noNotifications: function noNotifications(callback) {\n        this.notifications(false);\n        callback();\n        this.notifications(true);\n    },\n    batching: function batching() {\n        return this._private.batchCount > 0;\n    },\n    startBatch: function startBatch() {\n        var _p = this._private;\n        if (_p.batchCount == null) {\n            _p.batchCount = 0;\n        }\n        if (_p.batchCount === 0) {\n            _p.batchStyleEles = this.collection();\n            _p.batchNotifications = {};\n        }\n        _p.batchCount++;\n        return this;\n    },\n    endBatch: function endBatch() {\n        var _p = this._private;\n        if (_p.batchCount === 0) {\n            return this;\n        }\n        _p.batchCount--;\n        if (_p.batchCount === 0) {\n            // update style for dirty eles\n            _p.batchStyleEles.updateStyle();\n            var renderer = this.renderer();\n            // notify the renderer of queued eles and event types\n            Object.keys(_p.batchNotifications).forEach(function(eventName) {\n                var eles = _p.batchNotifications[eventName];\n                if (eles.empty()) {\n                    renderer.notify(eventName);\n                } else {\n                    renderer.notify(eventName, eles);\n                }\n            });\n        }\n        return this;\n    },\n    batch: function batch(callback) {\n        this.startBatch();\n        callback();\n        this.endBatch();\n        return this;\n    },\n    // for backwards compatibility\n    batchData: function batchData(map) {\n        var cy = this;\n        return this.batch(function() {\n            var ids = Object.keys(map);\n            for(var i = 0; i < ids.length; i++){\n                var id = ids[i];\n                var data = map[id];\n                var ele = cy.getElementById(id);\n                ele.data(data);\n            }\n        });\n    }\n};\nvar rendererDefaults = defaults$g({\n    hideEdgesOnViewport: false,\n    textureOnViewport: false,\n    motionBlur: false,\n    motionBlurOpacity: 0.05,\n    pixelRatio: undefined,\n    desktopTapThreshold: 4,\n    touchTapThreshold: 8,\n    wheelSensitivity: 1,\n    debug: false,\n    showFps: false,\n    // webgl options\n    webgl: false,\n    webglDebug: false,\n    webglDebugShowAtlases: false,\n    // defaults good for mobile\n    webglTexSize: 2048,\n    webglTexRows: 36,\n    webglTexRowsNodes: 18,\n    webglBatchSize: 2048,\n    webglTexPerBatch: 14,\n    webglBgColor: [\n        255,\n        255,\n        255\n    ]\n});\nvar corefn$4 = {\n    renderTo: function renderTo(context, zoom, pan, pxRatio) {\n        var r = this._private.renderer;\n        r.renderTo(context, zoom, pan, pxRatio);\n        return this;\n    },\n    renderer: function renderer() {\n        return this._private.renderer;\n    },\n    forceRender: function forceRender() {\n        this.notify(\"draw\");\n        return this;\n    },\n    resize: function resize() {\n        this.invalidateSize();\n        this.emitAndNotify(\"resize\");\n        return this;\n    },\n    initRenderer: function initRenderer(options) {\n        var cy = this;\n        var RendererProto = cy.extension(\"renderer\", options.name);\n        if (RendererProto == null) {\n            error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n            return;\n        }\n        if (options.wheelSensitivity !== undefined) {\n            warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n        }\n        var rOpts = rendererDefaults(options);\n        rOpts.cy = cy;\n        cy._private.renderer = new RendererProto(rOpts);\n        this.notify(\"init\");\n    },\n    destroyRenderer: function destroyRenderer() {\n        var cy = this;\n        cy.notify(\"destroy\"); // destroy the renderer\n        var domEle = cy.container();\n        if (domEle) {\n            domEle._cyreg = null;\n            while(domEle.childNodes.length > 0){\n                domEle.removeChild(domEle.childNodes[0]);\n            }\n        }\n        cy._private.renderer = null; // to be extra safe, remove the ref\n        cy.mutableElements().forEach(function(ele) {\n            var _p = ele._private;\n            _p.rscratch = {};\n            _p.rstyle = {};\n            _p.animation.current = [];\n            _p.animation.queue = [];\n        });\n    },\n    onRender: function onRender(fn) {\n        return this.on(\"render\", fn);\n    },\n    offRender: function offRender(fn) {\n        return this.off(\"render\", fn);\n    }\n};\ncorefn$4.invalidateDimensions = corefn$4.resize;\nvar corefn$3 = {\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function collection(eles, opts) {\n        if (string(eles)) {\n            return this.$(eles);\n        } else if (elementOrCollection(eles)) {\n            return eles.collection();\n        } else if (array(eles)) {\n            if (!opts) {\n                opts = {};\n            }\n            return new Collection(this, eles, opts.unique, opts.removed);\n        }\n        return new Collection(this);\n    },\n    nodes: function nodes(selector) {\n        var nodes = this.$(function(ele) {\n            return ele.isNode();\n        });\n        if (selector) {\n            return nodes.filter(selector);\n        }\n        return nodes;\n    },\n    edges: function edges(selector) {\n        var edges = this.$(function(ele) {\n            return ele.isEdge();\n        });\n        if (selector) {\n            return edges.filter(selector);\n        }\n        return edges;\n    },\n    // search the graph like jQuery\n    $: function $(selector) {\n        var eles = this._private.elements;\n        if (selector) {\n            return eles.filter(selector);\n        } else {\n            return eles.spawnSelf();\n        }\n    },\n    mutableElements: function mutableElements() {\n        return this._private.elements;\n    }\n};\n// aliases\ncorefn$3.elements = corefn$3.filter = corefn$3.$;\nvar styfn$8 = {};\n// keys for style blocks, e.g. ttfftt\nvar TRUE = \"t\";\nvar FALSE = \"f\";\n// (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\nstyfn$8.apply = function(eles) {\n    var self1 = this;\n    var _p = self1._private;\n    var cy = _p.cy;\n    var updatedEles = cy.collection();\n    for(var ie = 0; ie < eles.length; ie++){\n        var ele = eles[ie];\n        var cxtMeta = self1.getContextMeta(ele);\n        if (cxtMeta.empty) {\n            continue;\n        }\n        var cxtStyle = self1.getContextStyle(cxtMeta);\n        var app = self1.applyContextStyle(cxtMeta, cxtStyle, ele);\n        if (ele._private.appliedInitStyle) {\n            self1.updateTransitions(ele, app.diffProps);\n        } else {\n            ele._private.appliedInitStyle = true;\n        }\n        var hintsDiff = self1.updateStyleHints(ele);\n        if (hintsDiff) {\n            updatedEles.push(ele);\n        }\n    } // for elements\n    return updatedEles;\n};\nstyfn$8.getPropertiesDiff = function(oldCxtKey, newCxtKey) {\n    var self1 = this;\n    var cache = self1._private.propDiffs = self1._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + \"-\" + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n    if (cachedVal) {\n        return cachedVal;\n    }\n    var diffProps = [];\n    var addedProp = {};\n    for(var i = 0; i < self1.length; i++){\n        var cxt = self1[i];\n        var oldHasCxt = oldCxtKey[i] === TRUE;\n        var newHasCxt = newCxtKey[i] === TRUE;\n        var cxtHasDiffed = oldHasCxt !== newHasCxt;\n        var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n        if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n            var props = undefined;\n            if (cxtHasDiffed && cxtHasMappedProps) {\n                props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n            } else if (cxtHasDiffed) {\n                props = cxt.properties; // need to check them all\n            } else if (cxtHasMappedProps) {\n                props = cxt.mappedProperties; // only need to check mapped\n            }\n            for(var j = 0; j < props.length; j++){\n                var prop = props[j];\n                var name = prop.name;\n                // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n                // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n                // is cached)\n                var laterCxtOverrides = false;\n                for(var k = i + 1; k < self1.length; k++){\n                    var laterCxt = self1[k];\n                    var hasLaterCxt = newCxtKey[k] === TRUE;\n                    if (!hasLaterCxt) {\n                        continue;\n                    } // can't override unless the context is active\n                    laterCxtOverrides = laterCxt.properties[prop.name] != null;\n                    if (laterCxtOverrides) {\n                        break;\n                    } // exit early as long as one later context overrides\n                }\n                if (!addedProp[name] && !laterCxtOverrides) {\n                    addedProp[name] = true;\n                    diffProps.push(name);\n                }\n            } // for props\n        } // if\n    } // for contexts\n    cache[dualCxtKey] = diffProps;\n    return diffProps;\n};\nstyfn$8.getContextMeta = function(ele) {\n    var self1 = this;\n    var cxtKey = \"\";\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || \"\";\n    // get the cxt key\n    for(var i = 0; i < self1.length; i++){\n        var context = self1[i];\n        var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n        if (contextSelectorMatches) {\n            cxtKey += TRUE;\n        } else {\n            cxtKey += FALSE;\n        }\n    } // for context\n    diffProps = self1.getPropertiesDiff(prevKey, cxtKey);\n    ele._private.styleCxtKey = cxtKey;\n    return {\n        key: cxtKey,\n        diffPropNames: diffProps,\n        empty: diffProps.length === 0\n    };\n};\n// gets a computed ele style object based on matched contexts\nstyfn$8.getContextStyle = function(cxtMeta) {\n    var cxtKey = cxtMeta.key;\n    var self1 = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n    // if already computed style, returned cached copy\n    if (cxtStyles[cxtKey]) {\n        return cxtStyles[cxtKey];\n    }\n    var style = {\n        _private: {\n            key: cxtKey\n        }\n    };\n    for(var i = 0; i < self1.length; i++){\n        var cxt = self1[i];\n        var hasCxt = cxtKey[i] === TRUE;\n        if (!hasCxt) {\n            continue;\n        }\n        for(var j = 0; j < cxt.properties.length; j++){\n            var prop = cxt.properties[j];\n            style[prop.name] = prop;\n        }\n    }\n    cxtStyles[cxtKey] = style;\n    return style;\n};\nstyfn$8.applyContextStyle = function(cxtMeta, cxtStyle, ele) {\n    var self1 = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n    var types = self1.types;\n    for(var i = 0; i < diffProps.length; i++){\n        var diffPropName = diffProps[i];\n        var cxtProp = cxtStyle[diffPropName];\n        var eleProp = ele.pstyle(diffPropName);\n        if (!cxtProp) {\n            // no context prop means delete\n            if (!eleProp) {\n                continue; // no existing prop means nothing needs to be removed\n            // nb affects initial application on mapped values like control-point-distances\n            } else if (eleProp.bypass) {\n                cxtProp = {\n                    name: diffPropName,\n                    deleteBypassed: true\n                };\n            } else {\n                cxtProp = {\n                    name: diffPropName,\n                    \"delete\": true\n                };\n            }\n        }\n        // save cycles when the context prop doesn't need to be applied\n        if (eleProp === cxtProp) {\n            continue;\n        }\n        // save cycles when a mapped context prop doesn't need to be applied\n        if (cxtProp.mapped === types.fn // context prop is function mapper\n         && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n         && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n         && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n        ) {\n            // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n            var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n            var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n            if (fnValue === mapping.prevFnValue) {\n                continue;\n            }\n        }\n        var retDiffProp = retDiffProps[diffPropName] = {\n            prev: eleProp\n        };\n        self1.applyParsedProperty(ele, cxtProp);\n        retDiffProp.next = ele.pstyle(diffPropName);\n        if (retDiffProp.next && retDiffProp.next.bypass) {\n            retDiffProp.next = retDiffProp.next.bypassed;\n        }\n    }\n    return {\n        diffProps: retDiffProps\n    };\n};\nstyfn$8.updateStyleHints = function(ele) {\n    var _p = ele._private;\n    var self1 = this;\n    var propNames = self1.propertyGroupNames;\n    var propGrKeys = self1.propertyGroupKeys;\n    var propHash = function propHash(ele, propNames, seedKey) {\n        return self1.getPropertiesHash(ele, propNames, seedKey);\n    };\n    var oldStyleKey = _p.styleKey;\n    if (ele.removed()) {\n        return false;\n    }\n    var isNode = _p.group === \"nodes\";\n    // get the style key hashes per prop group\n    // but lazily -- only use non-default prop values to reduce the number of hashes\n    //\n    var overriddenStyles = ele._private.style;\n    propNames = Object.keys(overriddenStyles);\n    for(var i = 0; i < propGrKeys.length; i++){\n        var grKey = propGrKeys[i];\n        _p.styleKeys[grKey] = [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ];\n    }\n    var updateGrKey1 = function updateGrKey1(val, grKey) {\n        return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n    };\n    var updateGrKey2 = function updateGrKey2(val, grKey) {\n        return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n    };\n    var updateGrKey = function updateGrKey(val, grKey) {\n        updateGrKey1(val, grKey);\n        updateGrKey2(val, grKey);\n    };\n    var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n        for(var j = 0; j < strVal.length; j++){\n            var ch = strVal.charCodeAt(j);\n            updateGrKey1(ch, grKey);\n            updateGrKey2(ch, grKey);\n        }\n    };\n    // - hashing works on 32 bit ints b/c we use bitwise ops\n    // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n    // - raise up small numbers so more significant digits are seen by hashing\n    // - make small numbers larger than a normal value to avoid collisions\n    // - works in practice and it's relatively cheap\n    var N = 2000000000;\n    var cleanNum = function cleanNum(val) {\n        return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n    };\n    for(var _i = 0; _i < propNames.length; _i++){\n        var name = propNames[_i];\n        var parsedProp = overriddenStyles[name];\n        if (parsedProp == null) {\n            continue;\n        }\n        var propInfo = this.properties[name];\n        var type = propInfo.type;\n        var _grKey = propInfo.groupKey;\n        var normalizedNumberVal = undefined;\n        if (propInfo.hashOverride != null) {\n            normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n        } else if (parsedProp.pfValue != null) {\n            normalizedNumberVal = parsedProp.pfValue;\n        }\n        // might not be a number if it allows enums\n        var numberVal = propInfo.enums == null ? parsedProp.value : null;\n        var haveNormNum = normalizedNumberVal != null;\n        var haveUnitedNum = numberVal != null;\n        var haveNum = haveNormNum || haveUnitedNum;\n        var units = parsedProp.units;\n        // numbers are cheaper to hash than strings\n        // 1 hash op vs n hash ops (for length n string)\n        if (type.number && haveNum && !type.multiple) {\n            var v = haveNormNum ? normalizedNumberVal : numberVal;\n            updateGrKey(cleanNum(v), _grKey);\n            if (!haveNormNum && units != null) {\n                updateGrKeyWStr(units, _grKey);\n            }\n        } else {\n            updateGrKeyWStr(parsedProp.strValue, _grKey);\n        }\n    }\n    // overall style key\n    //\n    var hash = [\n        DEFAULT_HASH_SEED,\n        DEFAULT_HASH_SEED_ALT\n    ];\n    for(var _i2 = 0; _i2 < propGrKeys.length; _i2++){\n        var _grKey2 = propGrKeys[_i2];\n        var grHash = _p.styleKeys[_grKey2];\n        hash[0] = hashInt(grHash[0], hash[0]);\n        hash[1] = hashIntAlt(grHash[1], hash[1]);\n    }\n    _p.styleKey = combineHashes(hash[0], hash[1]);\n    // label dims\n    //\n    var sk = _p.styleKeys;\n    _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n    var labelKeys = propHash(ele, [\n        \"label\"\n    ], sk.labelDimensions);\n    _p.labelKey = combineHashesArray(labelKeys);\n    _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n    if (!isNode) {\n        var sourceLabelKeys = propHash(ele, [\n            \"source-label\"\n        ], sk.labelDimensions);\n        _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n        _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n        var targetLabelKeys = propHash(ele, [\n            \"target-label\"\n        ], sk.labelDimensions);\n        _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n        _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n    }\n    // node\n    //\n    if (isNode) {\n        var _p$styleKeys = _p.styleKeys, nodeBody = _p$styleKeys.nodeBody, nodeBorder = _p$styleKeys.nodeBorder, nodeOutline = _p$styleKeys.nodeOutline, backgroundImage = _p$styleKeys.backgroundImage, compound = _p$styleKeys.compound, pie = _p$styleKeys.pie, stripe = _p$styleKeys.stripe;\n        var nodeKeys = [\n            nodeBody,\n            nodeBorder,\n            nodeOutline,\n            backgroundImage,\n            compound,\n            pie,\n            stripe\n        ].filter(function(k) {\n            return k != null;\n        }).reduce(hashArrays, [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ]);\n        _p.nodeKey = combineHashesArray(nodeKeys);\n        _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n        _p.hasStripe = stripe != null && stripe[0] !== DEFAULT_HASH_SEED && stripe[1] !== DEFAULT_HASH_SEED_ALT;\n    }\n    return oldStyleKey !== _p.styleKey;\n};\nstyfn$8.clearStyleHints = function(ele) {\n    var _p = ele._private;\n    _p.styleCxtKey = \"\";\n    _p.styleKeys = {};\n    _p.styleKey = null;\n    _p.labelKey = null;\n    _p.labelStyleKey = null;\n    _p.sourceLabelKey = null;\n    _p.sourceLabelStyleKey = null;\n    _p.targetLabelKey = null;\n    _p.targetLabelStyleKey = null;\n    _p.nodeKey = null;\n    _p.hasPie = null;\n    _p.hasStripe = null;\n};\n// apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\nstyfn$8.applyParsedProperty = function(ele, parsedProp) {\n    var self1 = this;\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var flatProp;\n    var types = self1.types;\n    var type = self1.properties[prop.name].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[prop.name];\n    var origPropIsBypass = origProp && origProp.bypass;\n    var _p = ele._private;\n    var flatPropMapping = \"mapping\";\n    var getVal = function getVal(p) {\n        if (p == null) {\n            return null;\n        } else if (p.pfValue != null) {\n            return p.pfValue;\n        } else {\n            return p.value;\n        }\n    };\n    var checkTriggers = function checkTriggers() {\n        var fromVal = getVal(origProp);\n        var toVal = getVal(prop);\n        self1.checkTriggers(ele, prop.name, fromVal, toVal);\n    };\n    // edge sanity checks to prevent the client from making serious mistakes\n    if (parsedProp.name === \"curve-style\" && ele.isEdge() && // loops must be bundled beziers\n    (parsedProp.value !== \"bezier\" && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n    parsedProp.value === \"haystack\" && (ele.source().isParent() || ele.target().isParent()))) {\n        prop = parsedProp = this.parse(parsedProp.name, \"bezier\", propIsBypass);\n    }\n    if (prop[\"delete\"]) {\n        // delete the property and use the default value on falsey value\n        style[prop.name] = undefined;\n        checkTriggers();\n        return true;\n    }\n    if (prop.deleteBypassed) {\n        // delete the property that the\n        if (!origProp) {\n            checkTriggers();\n            return true; // can't delete if no prop\n        } else if (origProp.bypass) {\n            // delete bypassed\n            origProp.bypassed = undefined;\n            checkTriggers();\n            return true;\n        } else {\n            return false; // we're unsuccessful deleting the bypassed\n        }\n    }\n    // check if we need to delete the current bypass\n    if (prop.deleteBypass) {\n        // then this property is just here to indicate we need to delete\n        if (!origProp) {\n            checkTriggers();\n            return true; // property is already not defined\n        } else if (origProp.bypass) {\n            // then replace the bypass property with the original\n            // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n            style[prop.name] = origProp.bypassed;\n            checkTriggers();\n            return true;\n        } else {\n            return false; // we're unsuccessful deleting the bypass\n        }\n    }\n    var printMappingErr = function printMappingErr() {\n        warn(\"Do not assign mappings to elements without corresponding data (i.e. ele `\" + ele.id() + \"` has no mapping for property `\" + prop.name + \"` with data field `\" + prop.field + \"`); try a `[\" + prop.field + \"]` selector to limit scope to elements with `\" + prop.field + \"` defined\");\n    };\n    // put the property in the style objects\n    switch(prop.mapped){\n        // flatten the property if mapped\n        case types.mapData:\n            {\n                // flatten the field (e.g. data.foo.bar)\n                var fields = prop.field.split(\".\");\n                var fieldVal = _p.data;\n                for(var i = 0; i < fields.length && fieldVal; i++){\n                    var field = fields[i];\n                    fieldVal = fieldVal[field];\n                }\n                if (fieldVal == null) {\n                    printMappingErr();\n                    return false;\n                }\n                var percent;\n                if (!number$1(fieldVal)) {\n                    // then don't apply and fall back on the existing style\n                    warn(\"Do not use continuous mappers without specifying numeric data (i.e. `\" + prop.field + \": \" + fieldVal + \"` for `\" + ele.id() + \"` is non-numeric)\");\n                    return false;\n                } else {\n                    var fieldWidth = prop.fieldMax - prop.fieldMin;\n                    if (fieldWidth === 0) {\n                        // safety check -- not strictly necessary as no props of zero range should be passed here\n                        percent = 0;\n                    } else {\n                        percent = (fieldVal - prop.fieldMin) / fieldWidth;\n                    }\n                }\n                // make sure to bound percent value\n                if (percent < 0) {\n                    percent = 0;\n                } else if (percent > 1) {\n                    percent = 1;\n                }\n                if (type.color) {\n                    var r1 = prop.valueMin[0];\n                    var r2 = prop.valueMax[0];\n                    var g1 = prop.valueMin[1];\n                    var g2 = prop.valueMax[1];\n                    var b1 = prop.valueMin[2];\n                    var b2 = prop.valueMax[2];\n                    var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n                    var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n                    var clr = [\n                        Math.round(r1 + (r2 - r1) * percent),\n                        Math.round(g1 + (g2 - g1) * percent),\n                        Math.round(b1 + (b2 - b1) * percent),\n                        Math.round(a1 + (a2 - a1) * percent)\n                    ];\n                    flatProp = {\n                        // colours are simple, so just create the flat property instead of expensive string parsing\n                        bypass: prop.bypass,\n                        // we're a bypass if the mapping property is a bypass\n                        name: prop.name,\n                        value: clr,\n                        strValue: \"rgb(\" + clr[0] + \", \" + clr[1] + \", \" + clr[2] + \")\"\n                    };\n                } else if (type.number) {\n                    var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n                    flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n                } else {\n                    return false; // can only map to colours and numbers\n                }\n                if (!flatProp) {\n                    // if we can't flatten the property, then don't apply the property and fall back on the existing style\n                    printMappingErr();\n                    return false;\n                }\n                flatProp.mapping = prop; // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        // direct mapping\n        case types.data:\n            {\n                // flatten the field (e.g. data.foo.bar)\n                var _fields = prop.field.split(\".\");\n                var _fieldVal = _p.data;\n                for(var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++){\n                    var _field = _fields[_i3];\n                    _fieldVal = _fieldVal[_field];\n                }\n                if (_fieldVal != null) {\n                    flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n                }\n                if (!flatProp) {\n                    // if we can't flatten the property, then don't apply and fall back on the existing style\n                    printMappingErr();\n                    return false;\n                }\n                flatProp.mapping = prop; // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        case types.fn:\n            {\n                var fn = prop.value;\n                var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n                prop.prevFnValue = fnRetVal;\n                if (fnRetVal == null) {\n                    warn(\"Custom function mappers may not return null (i.e. `\" + prop.name + \"` for ele `\" + ele.id() + \"` is null)\");\n                    return false;\n                }\n                flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n                if (!flatProp) {\n                    warn(\"Custom function mappers may not return invalid values for the property type (i.e. `\" + prop.name + \"` for ele `\" + ele.id() + \"` is invalid)\");\n                    return false;\n                }\n                flatProp.mapping = copy(prop); // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        case undefined:\n            break;\n        // just set the property\n        default:\n            return false;\n    }\n    // if the property is a bypass property, then link the resultant property to the original one\n    if (propIsBypass) {\n        if (origPropIsBypass) {\n            // then this bypass overrides the existing one\n            prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n        } else {\n            // then link the orig prop to the new bypass\n            prop.bypassed = origProp;\n        }\n        style[prop.name] = prop; // and set\n    } else {\n        // prop is not bypass\n        if (origPropIsBypass) {\n            // then keep the orig prop (since it's a bypass) and link to the new prop\n            origProp.bypassed = prop;\n        } else {\n            // then just replace the old prop with the new one\n            style[prop.name] = prop;\n        }\n    }\n    checkTriggers();\n    return true;\n};\nstyfn$8.cleanElements = function(eles, keepBypasses) {\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        this.clearStyleHints(ele);\n        ele.dirtyCompoundBoundsCache();\n        ele.dirtyBoundingBoxCache();\n        if (!keepBypasses) {\n            ele._private.style = {};\n        } else {\n            var style = ele._private.style;\n            var propNames = Object.keys(style);\n            for(var j = 0; j < propNames.length; j++){\n                var propName = propNames[j];\n                var eleProp = style[propName];\n                if (eleProp != null) {\n                    if (eleProp.bypass) {\n                        eleProp.bypassed = null;\n                    } else {\n                        style[propName] = null;\n                    }\n                }\n            }\n        }\n    }\n};\n// updates the visual style for all elements (useful for manual style modification after init)\nstyfn$8.update = function() {\n    var cy = this._private.cy;\n    var eles = cy.mutableElements();\n    eles.updateStyle();\n};\n// diffProps : { name => { prev, next } }\nstyfn$8.updateTransitions = function(ele, diffProps) {\n    var self1 = this;\n    var _p = ele._private;\n    var props = ele.pstyle(\"transition-property\").value;\n    var duration = ele.pstyle(\"transition-duration\").pfValue;\n    var delay = ele.pstyle(\"transition-delay\").pfValue;\n    if (props.length > 0 && duration > 0) {\n        var style = {};\n        // build up the style to animate towards\n        var anyPrev = false;\n        for(var i = 0; i < props.length; i++){\n            var prop = props[i];\n            var styProp = ele.pstyle(prop);\n            var diffProp = diffProps[prop];\n            if (!diffProp) {\n                continue;\n            }\n            var prevProp = diffProp.prev;\n            var fromProp = prevProp;\n            var toProp = diffProp.next != null ? diffProp.next : styProp;\n            var diff = false;\n            var initVal = undefined;\n            var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n            if (!fromProp) {\n                continue;\n            }\n            // consider px values\n            if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n                diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n                initVal = fromProp.pfValue + initDt * diff;\n            // consider numerical values\n            } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n                diff = toProp.value - fromProp.value; // nonzero is truthy\n                initVal = fromProp.value + initDt * diff;\n            // consider colour values\n            } else if (array(fromProp.value) && array(toProp.value)) {\n                diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n                initVal = fromProp.strValue;\n            }\n            // the previous value is good for an animation only if it's different\n            if (diff) {\n                style[prop] = toProp.strValue; // to val\n                this.applyBypass(ele, prop, initVal); // from val\n                anyPrev = true;\n            }\n        } // end if props allow ani\n        // can't transition if there's nothing previous to transition from\n        if (!anyPrev) {\n            return;\n        }\n        _p.transitioning = true;\n        new Promise$1(function(resolve) {\n            if (delay > 0) {\n                ele.delayAnimation(delay).play().promise().then(resolve);\n            } else {\n                resolve();\n            }\n        }).then(function() {\n            return ele.animation({\n                style: style,\n                duration: duration,\n                easing: ele.pstyle(\"transition-timing-function\").value,\n                queue: false\n            }).play().promise();\n        }).then(function() {\n            // if( !isBypass ){\n            self1.removeBypasses(ele, props);\n            ele.emitAndNotify(\"style\");\n            // }\n            _p.transitioning = false;\n        });\n    } else if (_p.transitioning) {\n        this.removeBypasses(ele, props);\n        ele.emitAndNotify(\"style\");\n        _p.transitioning = false;\n    }\n};\nstyfn$8.checkTrigger = function(ele, name, fromValue, toValue, getTrigger, onTrigger) {\n    var prop = this.properties[name];\n    var triggerCheck = getTrigger(prop);\n    if (ele.removed()) {\n        return;\n    }\n    if (triggerCheck != null && triggerCheck(fromValue, toValue, ele)) {\n        onTrigger(prop);\n    }\n};\nstyfn$8.checkZOrderTrigger = function(ele, name, fromValue, toValue) {\n    var _this = this;\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersZOrder;\n    }, function() {\n        _this._private.cy.notify(\"zorder\", ele);\n    });\n};\nstyfn$8.checkBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBounds;\n    }, function(prop) {\n        ele.dirtyCompoundBoundsCache();\n        ele.dirtyBoundingBoxCache();\n    });\n};\nstyfn$8.checkConnectedEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBoundsOfConnectedEdges;\n    }, function(prop) {\n        ele.connectedEdges().forEach(function(edge) {\n            edge.dirtyBoundingBoxCache();\n        });\n    });\n};\nstyfn$8.checkParallelEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBoundsOfParallelEdges;\n    }, function(prop) {\n        ele.parallelEdges().forEach(function(pllEdge) {\n            pllEdge.dirtyBoundingBoxCache();\n        });\n    });\n};\nstyfn$8.checkTriggers = function(ele, name, fromValue, toValue) {\n    ele.dirtyStyleCache();\n    this.checkZOrderTrigger(ele, name, fromValue, toValue);\n    this.checkBoundsTrigger(ele, name, fromValue, toValue);\n    this.checkConnectedEdgesBoundsTrigger(ele, name, fromValue, toValue);\n    this.checkParallelEdgesBoundsTrigger(ele, name, fromValue, toValue);\n};\nvar styfn$7 = {};\n// bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\nstyfn$7.applyBypass = function(eles, name, value, updateTransitions) {\n    var self1 = this;\n    var props = [];\n    var isBypass = true;\n    // put all the properties (can specify one or many) in an array after parsing them\n    if (name === \"*\" || name === \"**\") {\n        // apply to all property names\n        if (value !== undefined) {\n            for(var i = 0; i < self1.properties.length; i++){\n                var prop = self1.properties[i];\n                var _name = prop.name;\n                var parsedProp = this.parse(_name, value, true);\n                if (parsedProp) {\n                    props.push(parsedProp);\n                }\n            }\n        }\n    } else if (string(name)) {\n        // then parse the single property\n        var _parsedProp = this.parse(name, value, true);\n        if (_parsedProp) {\n            props.push(_parsedProp);\n        }\n    } else if (plainObject(name)) {\n        // then parse each property\n        var specifiedProps = name;\n        updateTransitions = value;\n        var names = Object.keys(specifiedProps);\n        for(var _i = 0; _i < names.length; _i++){\n            var _name2 = names[_i];\n            var _value = specifiedProps[_name2];\n            if (_value === undefined) {\n                // try camel case name too\n                _value = specifiedProps[dash2camel(_name2)];\n            }\n            if (_value !== undefined) {\n                var _parsedProp2 = this.parse(_name2, _value, true);\n                if (_parsedProp2) {\n                    props.push(_parsedProp2);\n                }\n            }\n        }\n    } else {\n        // can't do anything without well defined properties\n        return false;\n    }\n    // we've failed if there are no valid properties\n    if (props.length === 0) {\n        return false;\n    }\n    // now, apply the bypass properties on the elements\n    var ret = false; // return true if at least one succesful bypass applied\n    for(var _i2 = 0; _i2 < eles.length; _i2++){\n        // for each ele\n        var ele = eles[_i2];\n        var diffProps = {};\n        var diffProp = undefined;\n        for(var j = 0; j < props.length; j++){\n            // for each prop\n            var _prop = props[j];\n            if (updateTransitions) {\n                var prevProp = ele.pstyle(_prop.name);\n                diffProp = diffProps[_prop.name] = {\n                    prev: prevProp\n                };\n            }\n            ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n            if (updateTransitions) {\n                diffProp.next = ele.pstyle(_prop.name);\n            }\n        } // for props\n        if (ret) {\n            this.updateStyleHints(ele);\n        }\n        if (updateTransitions) {\n            this.updateTransitions(ele, diffProps, isBypass);\n        }\n    } // for eles\n    return ret;\n};\n// only useful in specific cases like animation\nstyfn$7.overrideBypass = function(eles, name, value) {\n    name = camel2dash(name);\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var prop = ele._private.style[name];\n        var type = this.properties[name].type;\n        var isColor = type.color;\n        var isMulti = type.mutiple;\n        var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n        if (!prop || !prop.bypass) {\n            // need a bypass if one doesn't exist\n            this.applyBypass(ele, name, value);\n        } else {\n            prop.value = value;\n            if (prop.pfValue != null) {\n                prop.pfValue = value;\n            }\n            if (isColor) {\n                prop.strValue = \"rgb(\" + value.join(\",\") + \")\";\n            } else if (isMulti) {\n                prop.strValue = value.join(\" \");\n            } else {\n                prop.strValue = \"\" + value;\n            }\n            this.updateStyleHints(ele);\n        }\n        this.checkTriggers(ele, name, oldValue, value);\n    }\n};\nstyfn$7.removeAllBypasses = function(eles, updateTransitions) {\n    return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\nstyfn$7.removeBypasses = function(eles, props, updateTransitions) {\n    var isBypass = true;\n    for(var j = 0; j < eles.length; j++){\n        var ele = eles[j];\n        var diffProps = {};\n        for(var i = 0; i < props.length; i++){\n            var name = props[i];\n            var prop = this.properties[name];\n            var prevProp = ele.pstyle(prop.name);\n            if (!prevProp || !prevProp.bypass) {\n                continue;\n            }\n            var value = \"\"; // empty => remove bypass\n            var parsedProp = this.parse(name, value, true);\n            var diffProp = diffProps[prop.name] = {\n                prev: prevProp\n            };\n            this.applyParsedProperty(ele, parsedProp);\n            diffProp.next = ele.pstyle(prop.name);\n        } // for props\n        this.updateStyleHints(ele);\n        if (updateTransitions) {\n            this.updateTransitions(ele, diffProps, isBypass);\n        }\n    } // for eles\n};\nvar styfn$6 = {};\n// gets what an em size corresponds to in pixels relative to a dom element\nstyfn$6.getEmSizeInPixels = function() {\n    var px = this.containerCss(\"font-size\");\n    if (px != null) {\n        return parseFloat(px);\n    } else {\n        return 1; // for headless\n    }\n};\n// gets css property from the core container\nstyfn$6.containerCss = function(propName) {\n    var cy = this._private.cy;\n    var domElement = cy.container();\n    var containerWindow = cy.window();\n    if (containerWindow && domElement && containerWindow.getComputedStyle) {\n        return containerWindow.getComputedStyle(domElement).getPropertyValue(propName);\n    }\n};\nvar styfn$5 = {};\n// gets the rendered style for an element\nstyfn$5.getRenderedStyle = function(ele, prop) {\n    if (prop) {\n        return this.getStylePropertyValue(ele, prop, true);\n    } else {\n        return this.getRawStyle(ele, true);\n    }\n};\n// gets the raw style for an element\nstyfn$5.getRawStyle = function(ele, isRenderedVal) {\n    var self1 = this;\n    ele = ele[0]; // insure it's an element\n    if (ele) {\n        var rstyle = {};\n        for(var i = 0; i < self1.properties.length; i++){\n            var prop = self1.properties[i];\n            var val = self1.getStylePropertyValue(ele, prop.name, isRenderedVal);\n            if (val != null) {\n                rstyle[prop.name] = val;\n                rstyle[dash2camel(prop.name)] = val;\n            }\n        }\n        return rstyle;\n    }\n};\nstyfn$5.getIndexedStyle = function(ele, property, subproperty, index) {\n    var pstyle = ele.pstyle(property)[subproperty][index];\n    return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\nstyfn$5.getStylePropertyValue = function(ele, propName, isRenderedVal) {\n    var self1 = this;\n    ele = ele[0]; // insure it's an element\n    if (ele) {\n        var prop = self1.properties[propName];\n        if (prop.alias) {\n            prop = prop.pointsTo;\n        }\n        var type = prop.type;\n        var styleProp = ele.pstyle(prop.name);\n        if (styleProp) {\n            var value = styleProp.value, units = styleProp.units, strValue = styleProp.strValue;\n            if (isRenderedVal && type.number && value != null && number$1(value)) {\n                var zoom = ele.cy().zoom();\n                var getRenderedValue = function getRenderedValue(val) {\n                    return val * zoom;\n                };\n                var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n                    return getRenderedValue(val) + units;\n                };\n                var isArrayValue = array(value);\n                var haveUnits = isArrayValue ? units.every(function(u) {\n                    return u != null;\n                }) : units != null;\n                if (haveUnits) {\n                    if (isArrayValue) {\n                        return value.map(function(v, i) {\n                            return getValueStringWithUnits(v, units[i]);\n                        }).join(\" \");\n                    } else {\n                        return getValueStringWithUnits(value, units);\n                    }\n                } else {\n                    if (isArrayValue) {\n                        return value.map(function(v) {\n                            return string(v) ? v : \"\" + getRenderedValue(v);\n                        }).join(\" \");\n                    } else {\n                        return \"\" + getRenderedValue(value);\n                    }\n                }\n            } else if (strValue != null) {\n                return strValue;\n            }\n        }\n        return null;\n    }\n};\nstyfn$5.getAnimationStartStyle = function(ele, aniProps) {\n    var rstyle = {};\n    for(var i = 0; i < aniProps.length; i++){\n        var aniProp = aniProps[i];\n        var name = aniProp.name;\n        var styleProp = ele.pstyle(name);\n        if (styleProp !== undefined) {\n            // then make a prop of it\n            if (plainObject(styleProp)) {\n                styleProp = this.parse(name, styleProp.strValue);\n            } else {\n                styleProp = this.parse(name, styleProp);\n            }\n        }\n        if (styleProp) {\n            rstyle[name] = styleProp;\n        }\n    }\n    return rstyle;\n};\nstyfn$5.getPropsList = function(propsObj) {\n    var self1 = this;\n    var rstyle = [];\n    var style = propsObj;\n    var props = self1.properties;\n    if (style) {\n        var names = Object.keys(style);\n        for(var i = 0; i < names.length; i++){\n            var name = names[i];\n            var val = style[name];\n            var prop = props[name] || props[camel2dash(name)];\n            var styleProp = this.parse(prop.name, val);\n            if (styleProp) {\n                rstyle.push(styleProp);\n            }\n        }\n    }\n    return rstyle;\n};\nstyfn$5.getNonDefaultPropertiesHash = function(ele, propNames, seed) {\n    var hash = seed.slice();\n    var name, val, strVal, chVal;\n    var i, j;\n    for(i = 0; i < propNames.length; i++){\n        name = propNames[i];\n        val = ele.pstyle(name, false);\n        if (val == null) {\n            continue;\n        } else if (val.pfValue != null) {\n            hash[0] = hashInt(chVal, hash[0]);\n            hash[1] = hashIntAlt(chVal, hash[1]);\n        } else {\n            strVal = val.strValue;\n            for(j = 0; j < strVal.length; j++){\n                chVal = strVal.charCodeAt(j);\n                hash[0] = hashInt(chVal, hash[0]);\n                hash[1] = hashIntAlt(chVal, hash[1]);\n            }\n        }\n    }\n    return hash;\n};\nstyfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\nvar styfn$4 = {};\nstyfn$4.appendFromJson = function(json) {\n    var style = this;\n    for(var i = 0; i < json.length; i++){\n        var context = json[i];\n        var selector = context.selector;\n        var props = context.style || context.css;\n        var names = Object.keys(props);\n        style.selector(selector); // apply selector\n        for(var j = 0; j < names.length; j++){\n            var name = names[j];\n            var value = props[name];\n            style.css(name, value); // apply property\n        }\n    }\n    return style;\n};\n// accessible cy.style() function\nstyfn$4.fromJson = function(json) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromJson(json);\n    return style;\n};\n// get json from cy.style() api\nstyfn$4.json = function() {\n    var json = [];\n    for(var i = this.defaultLength; i < this.length; i++){\n        var cxt = this[i];\n        var selector = cxt.selector;\n        var props = cxt.properties;\n        var css = {};\n        for(var j = 0; j < props.length; j++){\n            var prop = props[j];\n            css[prop.name] = prop.strValue;\n        }\n        json.push({\n            selector: !selector ? \"core\" : selector.toString(),\n            style: css\n        });\n    }\n    return json;\n};\nvar styfn$3 = {};\nstyfn$3.appendFromString = function(string) {\n    var self1 = this;\n    var style = this;\n    var remaining = \"\" + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr;\n    // remove comments from the style string\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, \"\");\n    function removeSelAndBlockFromRemaining() {\n        // remove the parsed selector and block from the remaining text to parse\n        if (remaining.length > selAndBlockStr.length) {\n            remaining = remaining.substr(selAndBlockStr.length);\n        } else {\n            remaining = \"\";\n        }\n    }\n    function removePropAndValFromRem() {\n        // remove the parsed property and value from the remaining block text to parse\n        if (blockRem.length > propAndValStr.length) {\n            blockRem = blockRem.substr(propAndValStr.length);\n        } else {\n            blockRem = \"\";\n        }\n    }\n    for(;;){\n        var nothingLeftToParse = remaining.match(/^\\s*$/);\n        if (nothingLeftToParse) {\n            break;\n        }\n        var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n        if (!selAndBlock) {\n            warn(\"Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: \" + remaining);\n            break;\n        }\n        selAndBlockStr = selAndBlock[0];\n        // parse the selector\n        var selectorStr = selAndBlock[1];\n        if (selectorStr !== \"core\") {\n            var selector = new Selector(selectorStr);\n            if (selector.invalid) {\n                warn(\"Skipping parsing of block: Invalid selector found in string stylesheet: \" + selectorStr);\n                // skip this selector and block\n                removeSelAndBlockFromRemaining();\n                continue;\n            }\n        }\n        // parse the block of properties and values\n        var blockStr = selAndBlock[2];\n        var invalidBlock = false;\n        blockRem = blockStr;\n        var props = [];\n        for(;;){\n            var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n            if (_nothingLeftToParse) {\n                break;\n            }\n            var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n            if (!propAndVal) {\n                warn(\"Skipping parsing of block: Invalid formatting of style property and value definitions found in:\" + blockStr);\n                invalidBlock = true;\n                break;\n            }\n            propAndValStr = propAndVal[0];\n            var propStr = propAndVal[1];\n            var valStr = propAndVal[2];\n            var prop = self1.properties[propStr];\n            if (!prop) {\n                warn(\"Skipping property: Invalid property name in: \" + propAndValStr);\n                // skip this property in the block\n                removePropAndValFromRem();\n                continue;\n            }\n            var parsedProp = style.parse(propStr, valStr);\n            if (!parsedProp) {\n                warn(\"Skipping property: Invalid property definition in: \" + propAndValStr);\n                // skip this property in the block\n                removePropAndValFromRem();\n                continue;\n            }\n            props.push({\n                name: propStr,\n                val: valStr\n            });\n            removePropAndValFromRem();\n        }\n        if (invalidBlock) {\n            removeSelAndBlockFromRemaining();\n            break;\n        }\n        // put the parsed block in the style\n        style.selector(selectorStr);\n        for(var i = 0; i < props.length; i++){\n            var _prop = props[i];\n            style.css(_prop.name, _prop.val);\n        }\n        removeSelAndBlockFromRemaining();\n    }\n    return style;\n};\nstyfn$3.fromString = function(string) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromString(string);\n    return style;\n};\nvar styfn$2 = {};\n(function() {\n    var number$1 = number;\n    var rgba = rgbaNoBackRefs;\n    var hsla = hslaNoBackRefs;\n    var hex3$1 = hex3;\n    var hex6$1 = hex6;\n    var data = function data(prefix) {\n        return \"^\" + prefix + \"\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$\";\n    };\n    var mapData = function mapData(prefix) {\n        var mapArg = number$1 + \"|\\\\w+|\" + rgba + \"|\" + hsla + \"|\" + hex3$1 + \"|\" + hex6$1;\n        return \"^\" + prefix + \"\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(\" + number$1 + \")\\\\s*\\\\,\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + mapArg + \")\\\\s*\\\\,\\\\s*(\" + mapArg + \")\\\\)$\";\n    };\n    var urlRegexes = [\n        \"^url\\\\s*\\\\(\\\\s*['\\\"]?(.+?)['\\\"]?\\\\s*\\\\)$\",\n        \"^(none)$\",\n        \"^(.+)$\"\n    ];\n    // each visual style property has a type and needs to be validated according to it\n    styfn$2.types = {\n        time: {\n            number: true,\n            min: 0,\n            units: \"s|ms\",\n            implicitUnits: \"ms\"\n        },\n        percent: {\n            number: true,\n            min: 0,\n            max: 100,\n            units: \"%\",\n            implicitUnits: \"%\"\n        },\n        percentages: {\n            number: true,\n            min: 0,\n            max: 100,\n            units: \"%\",\n            implicitUnits: \"%\",\n            multiple: true\n        },\n        zeroOneNumber: {\n            number: true,\n            min: 0,\n            max: 1,\n            unitless: true\n        },\n        zeroOneNumbers: {\n            number: true,\n            min: 0,\n            max: 1,\n            unitless: true,\n            multiple: true\n        },\n        nOneOneNumber: {\n            number: true,\n            min: -1,\n            max: 1,\n            unitless: true\n        },\n        nonNegativeInt: {\n            number: true,\n            min: 0,\n            integer: true,\n            unitless: true\n        },\n        nonNegativeNumber: {\n            number: true,\n            min: 0,\n            unitless: true\n        },\n        position: {\n            enums: [\n                \"parent\",\n                \"origin\"\n            ]\n        },\n        nodeSize: {\n            number: true,\n            min: 0,\n            enums: [\n                \"label\"\n            ]\n        },\n        number: {\n            number: true,\n            unitless: true\n        },\n        numbers: {\n            number: true,\n            unitless: true,\n            multiple: true\n        },\n        positiveNumber: {\n            number: true,\n            unitless: true,\n            min: 0,\n            strictMin: true\n        },\n        size: {\n            number: true,\n            min: 0\n        },\n        bidirectionalSize: {\n            number: true\n        },\n        // allows negative\n        bidirectionalSizeMaybePercent: {\n            number: true,\n            allowPercent: true\n        },\n        // allows negative\n        bidirectionalSizes: {\n            number: true,\n            multiple: true\n        },\n        // allows negative\n        sizeMaybePercent: {\n            number: true,\n            min: 0,\n            allowPercent: true\n        },\n        axisDirection: {\n            enums: [\n                \"horizontal\",\n                \"leftward\",\n                \"rightward\",\n                \"vertical\",\n                \"upward\",\n                \"downward\",\n                \"auto\"\n            ]\n        },\n        axisDirectionExplicit: {\n            enums: [\n                \"leftward\",\n                \"rightward\",\n                \"upward\",\n                \"downward\"\n            ]\n        },\n        axisDirectionPrimary: {\n            enums: [\n                \"horizontal\",\n                \"vertical\"\n            ]\n        },\n        paddingRelativeTo: {\n            enums: [\n                \"width\",\n                \"height\",\n                \"average\",\n                \"min\",\n                \"max\"\n            ]\n        },\n        bgWH: {\n            number: true,\n            min: 0,\n            allowPercent: true,\n            enums: [\n                \"auto\"\n            ],\n            multiple: true\n        },\n        bgPos: {\n            number: true,\n            allowPercent: true,\n            multiple: true\n        },\n        bgRelativeTo: {\n            enums: [\n                \"inner\",\n                \"include-padding\"\n            ],\n            multiple: true\n        },\n        bgRepeat: {\n            enums: [\n                \"repeat\",\n                \"repeat-x\",\n                \"repeat-y\",\n                \"no-repeat\"\n            ],\n            multiple: true\n        },\n        bgFit: {\n            enums: [\n                \"none\",\n                \"contain\",\n                \"cover\"\n            ],\n            multiple: true\n        },\n        bgCrossOrigin: {\n            enums: [\n                \"anonymous\",\n                \"use-credentials\",\n                \"null\"\n            ],\n            multiple: true\n        },\n        bgClip: {\n            enums: [\n                \"none\",\n                \"node\"\n            ],\n            multiple: true\n        },\n        bgContainment: {\n            enums: [\n                \"inside\",\n                \"over\"\n            ],\n            multiple: true\n        },\n        boxSelection: {\n            enums: [\n                \"contain\",\n                \"overlap\",\n                \"none\"\n            ]\n        },\n        color: {\n            color: true\n        },\n        colors: {\n            color: true,\n            multiple: true\n        },\n        fill: {\n            enums: [\n                \"solid\",\n                \"linear-gradient\",\n                \"radial-gradient\"\n            ]\n        },\n        bool: {\n            enums: [\n                \"yes\",\n                \"no\"\n            ]\n        },\n        bools: {\n            enums: [\n                \"yes\",\n                \"no\"\n            ],\n            multiple: true\n        },\n        lineStyle: {\n            enums: [\n                \"solid\",\n                \"dotted\",\n                \"dashed\"\n            ]\n        },\n        lineCap: {\n            enums: [\n                \"butt\",\n                \"round\",\n                \"square\"\n            ]\n        },\n        linePosition: {\n            enums: [\n                \"center\",\n                \"inside\",\n                \"outside\"\n            ]\n        },\n        lineJoin: {\n            enums: [\n                \"round\",\n                \"bevel\",\n                \"miter\"\n            ]\n        },\n        borderStyle: {\n            enums: [\n                \"solid\",\n                \"dotted\",\n                \"dashed\",\n                \"double\"\n            ]\n        },\n        curveStyle: {\n            enums: [\n                \"bezier\",\n                \"unbundled-bezier\",\n                \"haystack\",\n                \"segments\",\n                \"straight\",\n                \"straight-triangle\",\n                \"taxi\",\n                \"round-segments\",\n                \"round-taxi\"\n            ]\n        },\n        radiusType: {\n            enums: [\n                \"arc-radius\",\n                \"influence-radius\"\n            ],\n            multiple: true\n        },\n        fontFamily: {\n            regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n        },\n        fontStyle: {\n            enums: [\n                \"italic\",\n                \"normal\",\n                \"oblique\"\n            ]\n        },\n        fontWeight: {\n            enums: [\n                \"normal\",\n                \"bold\",\n                \"bolder\",\n                \"lighter\",\n                \"100\",\n                \"200\",\n                \"300\",\n                \"400\",\n                \"500\",\n                \"600\",\n                \"800\",\n                \"900\",\n                100,\n                200,\n                300,\n                400,\n                500,\n                600,\n                700,\n                800,\n                900\n            ]\n        },\n        textDecoration: {\n            enums: [\n                \"none\",\n                \"underline\",\n                \"overline\",\n                \"line-through\"\n            ]\n        },\n        textTransform: {\n            enums: [\n                \"none\",\n                \"uppercase\",\n                \"lowercase\"\n            ]\n        },\n        textWrap: {\n            enums: [\n                \"none\",\n                \"wrap\",\n                \"ellipsis\"\n            ]\n        },\n        textOverflowWrap: {\n            enums: [\n                \"whitespace\",\n                \"anywhere\"\n            ]\n        },\n        textBackgroundShape: {\n            enums: [\n                \"rectangle\",\n                \"roundrectangle\",\n                \"round-rectangle\",\n                \"circle\"\n            ]\n        },\n        nodeShape: {\n            enums: [\n                \"rectangle\",\n                \"roundrectangle\",\n                \"round-rectangle\",\n                \"cutrectangle\",\n                \"cut-rectangle\",\n                \"bottomroundrectangle\",\n                \"bottom-round-rectangle\",\n                \"barrel\",\n                \"ellipse\",\n                \"triangle\",\n                \"round-triangle\",\n                \"square\",\n                \"pentagon\",\n                \"round-pentagon\",\n                \"hexagon\",\n                \"round-hexagon\",\n                \"concavehexagon\",\n                \"concave-hexagon\",\n                \"heptagon\",\n                \"round-heptagon\",\n                \"octagon\",\n                \"round-octagon\",\n                \"tag\",\n                \"round-tag\",\n                \"star\",\n                \"diamond\",\n                \"round-diamond\",\n                \"vee\",\n                \"rhomboid\",\n                \"right-rhomboid\",\n                \"polygon\"\n            ]\n        },\n        overlayShape: {\n            enums: [\n                \"roundrectangle\",\n                \"round-rectangle\",\n                \"ellipse\"\n            ]\n        },\n        cornerRadius: {\n            number: true,\n            min: 0,\n            units: \"px|em\",\n            implicitUnits: \"px\",\n            enums: [\n                \"auto\"\n            ]\n        },\n        compoundIncludeLabels: {\n            enums: [\n                \"include\",\n                \"exclude\"\n            ]\n        },\n        arrowShape: {\n            enums: [\n                \"tee\",\n                \"triangle\",\n                \"triangle-tee\",\n                \"circle-triangle\",\n                \"triangle-cross\",\n                \"triangle-backcurve\",\n                \"vee\",\n                \"square\",\n                \"circle\",\n                \"diamond\",\n                \"chevron\",\n                \"none\"\n            ]\n        },\n        arrowFill: {\n            enums: [\n                \"filled\",\n                \"hollow\"\n            ]\n        },\n        arrowWidth: {\n            number: true,\n            units: \"%|px|em\",\n            implicitUnits: \"px\",\n            enums: [\n                \"match-line\"\n            ]\n        },\n        display: {\n            enums: [\n                \"element\",\n                \"none\"\n            ]\n        },\n        visibility: {\n            enums: [\n                \"hidden\",\n                \"visible\"\n            ]\n        },\n        zCompoundDepth: {\n            enums: [\n                \"bottom\",\n                \"orphan\",\n                \"auto\",\n                \"top\"\n            ]\n        },\n        zIndexCompare: {\n            enums: [\n                \"auto\",\n                \"manual\"\n            ]\n        },\n        valign: {\n            enums: [\n                \"top\",\n                \"center\",\n                \"bottom\"\n            ]\n        },\n        halign: {\n            enums: [\n                \"left\",\n                \"center\",\n                \"right\"\n            ]\n        },\n        justification: {\n            enums: [\n                \"left\",\n                \"center\",\n                \"right\",\n                \"auto\"\n            ]\n        },\n        text: {\n            string: true\n        },\n        data: {\n            mapping: true,\n            regex: data(\"data\")\n        },\n        layoutData: {\n            mapping: true,\n            regex: data(\"layoutData\")\n        },\n        scratch: {\n            mapping: true,\n            regex: data(\"scratch\")\n        },\n        mapData: {\n            mapping: true,\n            regex: mapData(\"mapData\")\n        },\n        mapLayoutData: {\n            mapping: true,\n            regex: mapData(\"mapLayoutData\")\n        },\n        mapScratch: {\n            mapping: true,\n            regex: mapData(\"mapScratch\")\n        },\n        fn: {\n            mapping: true,\n            fn: true\n        },\n        url: {\n            regexes: urlRegexes,\n            singleRegexMatchValue: true\n        },\n        urls: {\n            regexes: urlRegexes,\n            singleRegexMatchValue: true,\n            multiple: true\n        },\n        propList: {\n            propList: true\n        },\n        angle: {\n            number: true,\n            units: \"deg|rad\",\n            implicitUnits: \"rad\"\n        },\n        textRotation: {\n            number: true,\n            units: \"deg|rad\",\n            implicitUnits: \"rad\",\n            enums: [\n                \"none\",\n                \"autorotate\"\n            ]\n        },\n        polygonPointList: {\n            number: true,\n            multiple: true,\n            evenMultiple: true,\n            min: -1,\n            max: 1,\n            unitless: true\n        },\n        edgeDistances: {\n            enums: [\n                \"intersection\",\n                \"node-position\",\n                \"endpoints\"\n            ]\n        },\n        edgeEndpoint: {\n            number: true,\n            multiple: true,\n            units: \"%|px|em|deg|rad\",\n            implicitUnits: \"px\",\n            enums: [\n                \"inside-to-node\",\n                \"outside-to-node\",\n                \"outside-to-node-or-label\",\n                \"outside-to-line\",\n                \"outside-to-line-or-label\"\n            ],\n            singleEnum: true,\n            validate: function validate(valArr, unitsArr) {\n                switch(valArr.length){\n                    case 2:\n                        // can be % or px only\n                        return unitsArr[0] !== \"deg\" && unitsArr[0] !== \"rad\" && unitsArr[1] !== \"deg\" && unitsArr[1] !== \"rad\";\n                    case 1:\n                        // can be enum, deg, or rad only\n                        return string(valArr[0]) || unitsArr[0] === \"deg\" || unitsArr[0] === \"rad\";\n                    default:\n                        return false;\n                }\n            }\n        },\n        easing: {\n            regexes: [\n                \"^(spring)\\\\s*\\\\(\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*\\\\)$\",\n                \"^(cubic-bezier)\\\\s*\\\\(\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*,\\\\s*(\" + number$1 + \")\\\\s*\\\\)$\"\n            ],\n            enums: [\n                \"linear\",\n                \"ease\",\n                \"ease-in\",\n                \"ease-out\",\n                \"ease-in-out\",\n                \"ease-in-sine\",\n                \"ease-out-sine\",\n                \"ease-in-out-sine\",\n                \"ease-in-quad\",\n                \"ease-out-quad\",\n                \"ease-in-out-quad\",\n                \"ease-in-cubic\",\n                \"ease-out-cubic\",\n                \"ease-in-out-cubic\",\n                \"ease-in-quart\",\n                \"ease-out-quart\",\n                \"ease-in-out-quart\",\n                \"ease-in-quint\",\n                \"ease-out-quint\",\n                \"ease-in-out-quint\",\n                \"ease-in-expo\",\n                \"ease-out-expo\",\n                \"ease-in-out-expo\",\n                \"ease-in-circ\",\n                \"ease-out-circ\",\n                \"ease-in-out-circ\"\n            ]\n        },\n        gradientDirection: {\n            enums: [\n                \"to-bottom\",\n                \"to-top\",\n                \"to-left\",\n                \"to-right\",\n                \"to-bottom-right\",\n                \"to-bottom-left\",\n                \"to-top-right\",\n                \"to-top-left\",\n                \"to-right-bottom\",\n                \"to-left-bottom\",\n                \"to-right-top\",\n                \"to-left-top\" // different order\n            ]\n        },\n        boundsExpansion: {\n            number: true,\n            multiple: true,\n            min: 0,\n            validate: function validate(valArr) {\n                var length = valArr.length;\n                return length === 1 || length === 2 || length === 4;\n            }\n        }\n    };\n    var diff = {\n        zeroNonZero: function zeroNonZero(val1, val2) {\n            if ((val1 == null || val2 == null) && val1 !== val2) {\n                return true; // null cases could represent any value\n            }\n            if (val1 == 0 && val2 != 0) {\n                return true;\n            } else if (val1 != 0 && val2 == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        any: function any(val1, val2) {\n            return val1 != val2;\n        },\n        emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n            var empty1 = emptyString(str1);\n            var empty2 = emptyString(str2);\n            return empty1 && !empty2 || !empty1 && empty2;\n        }\n    };\n    // define visual style properties\n    //\n    // - n.b. adding a new group of props may require updates to updateStyleHints()\n    // - adding new props to an existing group gets handled automatically\n    var t = styfn$2.types;\n    var mainLabel = [\n        {\n            name: \"label\",\n            type: t.text,\n            triggersBounds: diff.any,\n            triggersZOrder: diff.emptyNonEmpty\n        },\n        {\n            name: \"text-rotation\",\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-margin-x\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-margin-y\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        }\n    ];\n    var sourceLabel = [\n        {\n            name: \"source-label\",\n            type: t.text,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"source-text-rotation\",\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"source-text-margin-x\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"source-text-margin-y\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"source-text-offset\",\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var targetLabel = [\n        {\n            name: \"target-label\",\n            type: t.text,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"target-text-rotation\",\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"target-text-margin-x\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"target-text-margin-y\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"target-text-offset\",\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var labelDimensions = [\n        {\n            name: \"font-family\",\n            type: t.fontFamily,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"font-style\",\n            type: t.fontStyle,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"font-weight\",\n            type: t.fontWeight,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"font-size\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-transform\",\n            type: t.textTransform,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-wrap\",\n            type: t.textWrap,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-overflow-wrap\",\n            type: t.textOverflowWrap,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-max-width\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-outline-width\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"line-height\",\n            type: t.positiveNumber,\n            triggersBounds: diff.any\n        }\n    ];\n    var commonLabel = [\n        {\n            name: \"text-valign\",\n            type: t.valign,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-halign\",\n            type: t.halign,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"color\",\n            type: t.color\n        },\n        {\n            name: \"text-outline-color\",\n            type: t.color\n        },\n        {\n            name: \"text-outline-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"text-background-color\",\n            type: t.color\n        },\n        {\n            name: \"text-background-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"text-background-padding\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-border-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"text-border-color\",\n            type: t.color\n        },\n        {\n            name: \"text-border-width\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-border-style\",\n            type: t.borderStyle,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-background-shape\",\n            type: t.textBackgroundShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"text-justification\",\n            type: t.justification\n        },\n        {\n            name: \"box-select-labels\",\n            type: t.bool,\n            triggersBounds: diff.any\n        }\n    ];\n    var behavior = [\n        {\n            name: \"events\",\n            type: t.bool,\n            triggersZOrder: diff.any\n        },\n        {\n            name: \"text-events\",\n            type: t.bool,\n            triggersZOrder: diff.any\n        },\n        {\n            name: \"box-selection\",\n            type: t.boxSelection,\n            triggersZOrder: diff.any\n        }\n    ];\n    var visibility = [\n        {\n            name: \"display\",\n            type: t.display,\n            triggersZOrder: diff.any,\n            triggersBounds: diff.any,\n            triggersBoundsOfConnectedEdges: diff.any,\n            triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue, ele) {\n                if (fromValue === toValue) {\n                    return false;\n                }\n                // only if edge is bundled bezier (so as not to affect performance of other edges)\n                return ele.pstyle(\"curve-style\").value === \"bezier\";\n            }\n        },\n        {\n            name: \"visibility\",\n            type: t.visibility,\n            triggersZOrder: diff.any\n        },\n        {\n            name: \"opacity\",\n            type: t.zeroOneNumber,\n            triggersZOrder: diff.zeroNonZero\n        },\n        {\n            name: \"text-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"min-zoomed-font-size\",\n            type: t.size\n        },\n        {\n            name: \"z-compound-depth\",\n            type: t.zCompoundDepth,\n            triggersZOrder: diff.any\n        },\n        {\n            name: \"z-index-compare\",\n            type: t.zIndexCompare,\n            triggersZOrder: diff.any\n        },\n        {\n            name: \"z-index\",\n            type: t.number,\n            triggersZOrder: diff.any\n        }\n    ];\n    var overlay = [\n        {\n            name: \"overlay-padding\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"overlay-color\",\n            type: t.color\n        },\n        {\n            name: \"overlay-opacity\",\n            type: t.zeroOneNumber,\n            triggersBounds: diff.zeroNonZero\n        },\n        {\n            name: \"overlay-shape\",\n            type: t.overlayShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"overlay-corner-radius\",\n            type: t.cornerRadius\n        }\n    ];\n    var underlay = [\n        {\n            name: \"underlay-padding\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"underlay-color\",\n            type: t.color\n        },\n        {\n            name: \"underlay-opacity\",\n            type: t.zeroOneNumber,\n            triggersBounds: diff.zeroNonZero\n        },\n        {\n            name: \"underlay-shape\",\n            type: t.overlayShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"underlay-corner-radius\",\n            type: t.cornerRadius\n        }\n    ];\n    var transition = [\n        {\n            name: \"transition-property\",\n            type: t.propList\n        },\n        {\n            name: \"transition-duration\",\n            type: t.time\n        },\n        {\n            name: \"transition-delay\",\n            type: t.time\n        },\n        {\n            name: \"transition-timing-function\",\n            type: t.easing\n        }\n    ];\n    var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n        if (parsedProp.value === \"label\") {\n            return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n        } else {\n            return parsedProp.pfValue;\n        }\n    };\n    var nodeBody = [\n        {\n            name: \"height\",\n            type: t.nodeSize,\n            triggersBounds: diff.any,\n            hashOverride: nodeSizeHashOverride\n        },\n        {\n            name: \"width\",\n            type: t.nodeSize,\n            triggersBounds: diff.any,\n            hashOverride: nodeSizeHashOverride\n        },\n        {\n            name: \"shape\",\n            type: t.nodeShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"shape-polygon-points\",\n            type: t.polygonPointList,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"corner-radius\",\n            type: t.cornerRadius\n        },\n        {\n            name: \"background-color\",\n            type: t.color\n        },\n        {\n            name: \"background-fill\",\n            type: t.fill\n        },\n        {\n            name: \"background-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"background-blacken\",\n            type: t.nOneOneNumber\n        },\n        {\n            name: \"background-gradient-stop-colors\",\n            type: t.colors\n        },\n        {\n            name: \"background-gradient-stop-positions\",\n            type: t.percentages\n        },\n        {\n            name: \"background-gradient-direction\",\n            type: t.gradientDirection\n        },\n        {\n            name: \"padding\",\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"padding-relative-to\",\n            type: t.paddingRelativeTo,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"bounds-expansion\",\n            type: t.boundsExpansion,\n            triggersBounds: diff.any\n        }\n    ];\n    var nodeBorder = [\n        {\n            name: \"border-color\",\n            type: t.color\n        },\n        {\n            name: \"border-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"border-width\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"border-style\",\n            type: t.borderStyle\n        },\n        {\n            name: \"border-cap\",\n            type: t.lineCap\n        },\n        {\n            name: \"border-join\",\n            type: t.lineJoin\n        },\n        {\n            name: \"border-dash-pattern\",\n            type: t.numbers\n        },\n        {\n            name: \"border-dash-offset\",\n            type: t.number\n        },\n        {\n            name: \"border-position\",\n            type: t.linePosition\n        }\n    ];\n    var nodeOutline = [\n        {\n            name: \"outline-color\",\n            type: t.color\n        },\n        {\n            name: \"outline-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"outline-width\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"outline-style\",\n            type: t.borderStyle\n        },\n        {\n            name: \"outline-offset\",\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var backgroundImage = [\n        {\n            name: \"background-image\",\n            type: t.urls\n        },\n        {\n            name: \"background-image-crossorigin\",\n            type: t.bgCrossOrigin\n        },\n        {\n            name: \"background-image-opacity\",\n            type: t.zeroOneNumbers\n        },\n        {\n            name: \"background-image-containment\",\n            type: t.bgContainment\n        },\n        {\n            name: \"background-image-smoothing\",\n            type: t.bools\n        },\n        {\n            name: \"background-position-x\",\n            type: t.bgPos\n        },\n        {\n            name: \"background-position-y\",\n            type: t.bgPos\n        },\n        {\n            name: \"background-width-relative-to\",\n            type: t.bgRelativeTo\n        },\n        {\n            name: \"background-height-relative-to\",\n            type: t.bgRelativeTo\n        },\n        {\n            name: \"background-repeat\",\n            type: t.bgRepeat\n        },\n        {\n            name: \"background-fit\",\n            type: t.bgFit\n        },\n        {\n            name: \"background-clip\",\n            type: t.bgClip\n        },\n        {\n            name: \"background-width\",\n            type: t.bgWH\n        },\n        {\n            name: \"background-height\",\n            type: t.bgWH\n        },\n        {\n            name: \"background-offset-x\",\n            type: t.bgPos\n        },\n        {\n            name: \"background-offset-y\",\n            type: t.bgPos\n        }\n    ];\n    var compound = [\n        {\n            name: \"position\",\n            type: t.position,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"compound-sizing-wrt-labels\",\n            type: t.compoundIncludeLabels,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"min-width\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"min-width-bias-left\",\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"min-width-bias-right\",\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"min-height\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"min-height-bias-top\",\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"min-height-bias-bottom\",\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        }\n    ];\n    var edgeLine = [\n        {\n            name: \"line-style\",\n            type: t.lineStyle\n        },\n        {\n            name: \"line-color\",\n            type: t.color\n        },\n        {\n            name: \"line-fill\",\n            type: t.fill\n        },\n        {\n            name: \"line-cap\",\n            type: t.lineCap\n        },\n        {\n            name: \"line-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"line-dash-pattern\",\n            type: t.numbers\n        },\n        {\n            name: \"line-dash-offset\",\n            type: t.number\n        },\n        {\n            name: \"line-outline-width\",\n            type: t.size\n        },\n        {\n            name: \"line-outline-color\",\n            type: t.color\n        },\n        {\n            name: \"line-gradient-stop-colors\",\n            type: t.colors\n        },\n        {\n            name: \"line-gradient-stop-positions\",\n            type: t.percentages\n        },\n        {\n            name: \"curve-style\",\n            type: t.curveStyle,\n            triggersBounds: diff.any,\n            triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue) {\n                if (fromValue === toValue) {\n                    return false;\n                } // must have diff\n                return fromValue === \"bezier\" || // remove from bundle\n                toValue === \"bezier\"; // add to bundle\n            }\n        },\n        {\n            name: \"haystack-radius\",\n            type: t.zeroOneNumber,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"source-endpoint\",\n            type: t.edgeEndpoint,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"target-endpoint\",\n            type: t.edgeEndpoint,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"control-point-step-size\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"control-point-distances\",\n            type: t.bidirectionalSizes,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"control-point-weights\",\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"segment-distances\",\n            type: t.bidirectionalSizes,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"segment-weights\",\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"segment-radii\",\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"radius-type\",\n            type: t.radiusType,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"taxi-turn\",\n            type: t.bidirectionalSizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"taxi-turn-min-distance\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"taxi-direction\",\n            type: t.axisDirection,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"taxi-radius\",\n            type: t.number,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"edge-distances\",\n            type: t.edgeDistances,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"arrow-scale\",\n            type: t.positiveNumber,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"loop-direction\",\n            type: t.angle,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"loop-sweep\",\n            type: t.angle,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"source-distance-from-node\",\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"target-distance-from-node\",\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var ghost = [\n        {\n            name: \"ghost\",\n            type: t.bool,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"ghost-offset-x\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"ghost-offset-y\",\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"ghost-opacity\",\n            type: t.zeroOneNumber\n        }\n    ];\n    var core = [\n        {\n            name: \"selection-box-color\",\n            type: t.color\n        },\n        {\n            name: \"selection-box-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"selection-box-border-color\",\n            type: t.color\n        },\n        {\n            name: \"selection-box-border-width\",\n            type: t.size\n        },\n        {\n            name: \"active-bg-color\",\n            type: t.color\n        },\n        {\n            name: \"active-bg-opacity\",\n            type: t.zeroOneNumber\n        },\n        {\n            name: \"active-bg-size\",\n            type: t.size\n        },\n        {\n            name: \"outside-texture-bg-color\",\n            type: t.color\n        },\n        {\n            name: \"outside-texture-bg-opacity\",\n            type: t.zeroOneNumber\n        }\n    ];\n    // pie backgrounds for nodes\n    var pie = [];\n    styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n    pie.push({\n        name: \"pie-size\",\n        type: t.sizeMaybePercent\n    });\n    pie.push({\n        name: \"pie-hole\",\n        type: t.sizeMaybePercent\n    });\n    pie.push({\n        name: \"pie-start-angle\",\n        type: t.angle\n    });\n    for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n        pie.push({\n            name: \"pie-\" + i + \"-background-color\",\n            type: t.color\n        });\n        pie.push({\n            name: \"pie-\" + i + \"-background-size\",\n            type: t.percent\n        });\n        pie.push({\n            name: \"pie-\" + i + \"-background-opacity\",\n            type: t.zeroOneNumber\n        });\n    }\n    // stripe backgrounds for nodes\n    var stripe = [];\n    styfn$2.stripeBackgroundN = 16; // because the stripe properties are numbered, give access to a constant N (for renderer use)\n    stripe.push({\n        name: \"stripe-size\",\n        type: t.sizeMaybePercent\n    });\n    stripe.push({\n        name: \"stripe-direction\",\n        type: t.axisDirectionPrimary\n    });\n    for(var _i = 1; _i <= styfn$2.stripeBackgroundN; _i++){\n        stripe.push({\n            name: \"stripe-\" + _i + \"-background-color\",\n            type: t.color\n        });\n        stripe.push({\n            name: \"stripe-\" + _i + \"-background-size\",\n            type: t.percent\n        });\n        stripe.push({\n            name: \"stripe-\" + _i + \"-background-opacity\",\n            type: t.zeroOneNumber\n        });\n    }\n    // edge arrows\n    var edgeArrow = [];\n    var arrowPrefixes = styfn$2.arrowPrefixes = [\n        \"source\",\n        \"mid-source\",\n        \"target\",\n        \"mid-target\"\n    ];\n    [\n        {\n            name: \"arrow-shape\",\n            type: t.arrowShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: \"arrow-color\",\n            type: t.color\n        },\n        {\n            name: \"arrow-fill\",\n            type: t.arrowFill\n        },\n        {\n            name: \"arrow-width\",\n            type: t.arrowWidth\n        }\n    ].forEach(function(prop) {\n        arrowPrefixes.forEach(function(prefix) {\n            var name = prefix + \"-\" + prop.name;\n            var type = prop.type, triggersBounds = prop.triggersBounds;\n            edgeArrow.push({\n                name: name,\n                type: type,\n                triggersBounds: triggersBounds\n            });\n        });\n    }, {});\n    var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, nodeOutline, backgroundImage, pie, stripe, compound, edgeLine, edgeArrow, core);\n    var propGroups = styfn$2.propertyGroups = {\n        // common to all eles\n        behavior: behavior,\n        transition: transition,\n        visibility: visibility,\n        overlay: overlay,\n        underlay: underlay,\n        ghost: ghost,\n        // labels\n        commonLabel: commonLabel,\n        labelDimensions: labelDimensions,\n        mainLabel: mainLabel,\n        sourceLabel: sourceLabel,\n        targetLabel: targetLabel,\n        // node props\n        nodeBody: nodeBody,\n        nodeBorder: nodeBorder,\n        nodeOutline: nodeOutline,\n        backgroundImage: backgroundImage,\n        pie: pie,\n        stripe: stripe,\n        compound: compound,\n        // edge props\n        edgeLine: edgeLine,\n        edgeArrow: edgeArrow,\n        core: core\n    };\n    var propGroupNames = styfn$2.propertyGroupNames = {};\n    var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n    propGroupKeys.forEach(function(key) {\n        propGroupNames[key] = propGroups[key].map(function(prop) {\n            return prop.name;\n        });\n        propGroups[key].forEach(function(prop) {\n            return prop.groupKey = key;\n        });\n    });\n    // define aliases\n    var aliases = styfn$2.aliases = [\n        {\n            name: \"content\",\n            pointsTo: \"label\"\n        },\n        {\n            name: \"control-point-distance\",\n            pointsTo: \"control-point-distances\"\n        },\n        {\n            name: \"control-point-weight\",\n            pointsTo: \"control-point-weights\"\n        },\n        {\n            name: \"segment-distance\",\n            pointsTo: \"segment-distances\"\n        },\n        {\n            name: \"segment-weight\",\n            pointsTo: \"segment-weights\"\n        },\n        {\n            name: \"segment-radius\",\n            pointsTo: \"segment-radii\"\n        },\n        {\n            name: \"edge-text-rotation\",\n            pointsTo: \"text-rotation\"\n        },\n        {\n            name: \"padding-left\",\n            pointsTo: \"padding\"\n        },\n        {\n            name: \"padding-right\",\n            pointsTo: \"padding\"\n        },\n        {\n            name: \"padding-top\",\n            pointsTo: \"padding\"\n        },\n        {\n            name: \"padding-bottom\",\n            pointsTo: \"padding\"\n        }\n    ];\n    // list of property names\n    styfn$2.propertyNames = props.map(function(p) {\n        return p.name;\n    });\n    // allow access of properties by name ( e.g. style.properties.height )\n    for(var _i2 = 0; _i2 < props.length; _i2++){\n        var prop = props[_i2];\n        props[prop.name] = prop; // allow lookup by name\n    }\n    // map aliases\n    for(var _i3 = 0; _i3 < aliases.length; _i3++){\n        var alias = aliases[_i3];\n        var pointsToProp = props[alias.pointsTo];\n        var aliasProp = {\n            name: alias.name,\n            alias: true,\n            pointsTo: pointsToProp\n        };\n        // add alias prop for parsing\n        props.push(aliasProp);\n        props[alias.name] = aliasProp; // allow lookup by name\n    }\n})();\nstyfn$2.getDefaultProperty = function(name) {\n    return this.getDefaultProperties()[name];\n};\nstyfn$2.getDefaultProperties = function() {\n    var _p = this._private;\n    if (_p.defaultProperties != null) {\n        return _p.defaultProperties;\n    }\n    var rawProps = extend({\n        // core props\n        \"selection-box-color\": \"#ddd\",\n        \"selection-box-opacity\": 0.65,\n        \"selection-box-border-color\": \"#aaa\",\n        \"selection-box-border-width\": 1,\n        \"active-bg-color\": \"black\",\n        \"active-bg-opacity\": 0.15,\n        \"active-bg-size\": 30,\n        \"outside-texture-bg-color\": \"#000\",\n        \"outside-texture-bg-opacity\": 0.125,\n        // common node/edge props\n        \"events\": \"yes\",\n        \"text-events\": \"no\",\n        \"text-valign\": \"top\",\n        \"text-halign\": \"center\",\n        \"text-justification\": \"auto\",\n        \"line-height\": 1,\n        \"color\": \"#000\",\n        \"box-selection\": \"contain\",\n        \"text-outline-color\": \"#000\",\n        \"text-outline-width\": 0,\n        \"text-outline-opacity\": 1,\n        \"text-opacity\": 1,\n        \"text-decoration\": \"none\",\n        \"text-transform\": \"none\",\n        \"text-wrap\": \"none\",\n        \"text-overflow-wrap\": \"whitespace\",\n        \"text-max-width\": 9999,\n        \"text-background-color\": \"#000\",\n        \"text-background-opacity\": 0,\n        \"text-background-shape\": \"rectangle\",\n        \"text-background-padding\": 0,\n        \"text-border-opacity\": 0,\n        \"text-border-width\": 0,\n        \"text-border-style\": \"solid\",\n        \"text-border-color\": \"#000\",\n        \"font-family\": \"Helvetica Neue, Helvetica, sans-serif\",\n        \"font-style\": \"normal\",\n        \"font-weight\": \"normal\",\n        \"font-size\": 16,\n        \"min-zoomed-font-size\": 0,\n        \"text-rotation\": \"none\",\n        \"source-text-rotation\": \"none\",\n        \"target-text-rotation\": \"none\",\n        \"visibility\": \"visible\",\n        \"display\": \"element\",\n        \"opacity\": 1,\n        \"z-compound-depth\": \"auto\",\n        \"z-index-compare\": \"auto\",\n        \"z-index\": 0,\n        \"label\": \"\",\n        \"text-margin-x\": 0,\n        \"text-margin-y\": 0,\n        \"source-label\": \"\",\n        \"source-text-offset\": 0,\n        \"source-text-margin-x\": 0,\n        \"source-text-margin-y\": 0,\n        \"target-label\": \"\",\n        \"target-text-offset\": 0,\n        \"target-text-margin-x\": 0,\n        \"target-text-margin-y\": 0,\n        \"overlay-opacity\": 0,\n        \"overlay-color\": \"#000\",\n        \"overlay-padding\": 10,\n        \"overlay-shape\": \"round-rectangle\",\n        \"overlay-corner-radius\": \"auto\",\n        \"underlay-opacity\": 0,\n        \"underlay-color\": \"#000\",\n        \"underlay-padding\": 10,\n        \"underlay-shape\": \"round-rectangle\",\n        \"underlay-corner-radius\": \"auto\",\n        \"transition-property\": \"none\",\n        \"transition-duration\": 0,\n        \"transition-delay\": 0,\n        \"transition-timing-function\": \"linear\",\n        \"box-select-labels\": \"no\",\n        // node props\n        \"background-blacken\": 0,\n        \"background-color\": \"#999\",\n        \"background-fill\": \"solid\",\n        \"background-opacity\": 1,\n        \"background-image\": \"none\",\n        \"background-image-crossorigin\": \"anonymous\",\n        \"background-image-opacity\": 1,\n        \"background-image-containment\": \"inside\",\n        \"background-image-smoothing\": \"yes\",\n        \"background-position-x\": \"50%\",\n        \"background-position-y\": \"50%\",\n        \"background-offset-x\": 0,\n        \"background-offset-y\": 0,\n        \"background-width-relative-to\": \"include-padding\",\n        \"background-height-relative-to\": \"include-padding\",\n        \"background-repeat\": \"no-repeat\",\n        \"background-fit\": \"none\",\n        \"background-clip\": \"node\",\n        \"background-width\": \"auto\",\n        \"background-height\": \"auto\",\n        \"border-color\": \"#000\",\n        \"border-opacity\": 1,\n        \"border-width\": 0,\n        \"border-style\": \"solid\",\n        \"border-dash-pattern\": [\n            4,\n            2\n        ],\n        \"border-dash-offset\": 0,\n        \"border-cap\": \"butt\",\n        \"border-join\": \"miter\",\n        \"border-position\": \"center\",\n        \"outline-color\": \"#999\",\n        \"outline-opacity\": 1,\n        \"outline-width\": 0,\n        \"outline-offset\": 0,\n        \"outline-style\": \"solid\",\n        \"height\": 30,\n        \"width\": 30,\n        \"shape\": \"ellipse\",\n        \"shape-polygon-points\": \"-1, -1,   1, -1,   1, 1,   -1, 1\",\n        \"corner-radius\": \"auto\",\n        \"bounds-expansion\": 0,\n        // node gradient\n        \"background-gradient-direction\": \"to-bottom\",\n        \"background-gradient-stop-colors\": \"#999\",\n        \"background-gradient-stop-positions\": \"0%\",\n        // ghost props\n        \"ghost\": \"no\",\n        \"ghost-offset-y\": 0,\n        \"ghost-offset-x\": 0,\n        \"ghost-opacity\": 0,\n        // compound props\n        \"padding\": 0,\n        \"padding-relative-to\": \"width\",\n        \"position\": \"origin\",\n        \"compound-sizing-wrt-labels\": \"include\",\n        \"min-width\": 0,\n        \"min-width-bias-left\": 0,\n        \"min-width-bias-right\": 0,\n        \"min-height\": 0,\n        \"min-height-bias-top\": 0,\n        \"min-height-bias-bottom\": 0\n    }, {\n        // node pie bg\n        \"pie-size\": \"100%\",\n        \"pie-hole\": 0,\n        \"pie-start-angle\": \"0deg\"\n    }, [\n        {\n            name: \"pie-{{i}}-background-color\",\n            value: \"black\"\n        },\n        {\n            name: \"pie-{{i}}-background-size\",\n            value: \"0%\"\n        },\n        {\n            name: \"pie-{{i}}-background-opacity\",\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n            var name = prop.name.replace(\"{{i}}\", i);\n            var val = prop.value;\n            css[name] = val;\n        }\n        return css;\n    }, {}), {\n        // node stripes bg\n        \"stripe-size\": \"100%\",\n        \"stripe-direction\": \"horizontal\"\n    }, [\n        {\n            name: \"stripe-{{i}}-background-color\",\n            value: \"black\"\n        },\n        {\n            name: \"stripe-{{i}}-background-size\",\n            value: \"0%\"\n        },\n        {\n            name: \"stripe-{{i}}-background-opacity\",\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        for(var i = 1; i <= styfn$2.stripeBackgroundN; i++){\n            var name = prop.name.replace(\"{{i}}\", i);\n            var val = prop.value;\n            css[name] = val;\n        }\n        return css;\n    }, {}), {\n        // edge props\n        \"line-style\": \"solid\",\n        \"line-color\": \"#999\",\n        \"line-fill\": \"solid\",\n        \"line-cap\": \"butt\",\n        \"line-opacity\": 1,\n        \"line-outline-width\": 0,\n        \"line-outline-color\": \"#000\",\n        \"line-gradient-stop-colors\": \"#999\",\n        \"line-gradient-stop-positions\": \"0%\",\n        \"control-point-step-size\": 40,\n        \"control-point-weights\": 0.5,\n        \"segment-weights\": 0.5,\n        \"segment-distances\": 20,\n        \"segment-radii\": 15,\n        \"radius-type\": \"arc-radius\",\n        \"taxi-turn\": \"50%\",\n        \"taxi-radius\": 15,\n        \"taxi-turn-min-distance\": 10,\n        \"taxi-direction\": \"auto\",\n        \"edge-distances\": \"intersection\",\n        \"curve-style\": \"haystack\",\n        \"haystack-radius\": 0,\n        \"arrow-scale\": 1,\n        \"loop-direction\": \"-45deg\",\n        \"loop-sweep\": \"-90deg\",\n        \"source-distance-from-node\": 0,\n        \"target-distance-from-node\": 0,\n        \"source-endpoint\": \"outside-to-node\",\n        \"target-endpoint\": \"outside-to-node\",\n        \"line-dash-pattern\": [\n            6,\n            3\n        ],\n        \"line-dash-offset\": 0\n    }, [\n        {\n            name: \"arrow-shape\",\n            value: \"none\"\n        },\n        {\n            name: \"arrow-color\",\n            value: \"#999\"\n        },\n        {\n            name: \"arrow-fill\",\n            value: \"filled\"\n        },\n        {\n            name: \"arrow-width\",\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        styfn$2.arrowPrefixes.forEach(function(prefix) {\n            var name = prefix + \"-\" + prop.name;\n            var val = prop.value;\n            css[name] = val;\n        });\n        return css;\n    }, {}));\n    var parsedProps = {};\n    for(var i = 0; i < this.properties.length; i++){\n        var prop = this.properties[i];\n        if (prop.pointsTo) {\n            continue;\n        }\n        var name = prop.name;\n        var val = rawProps[name];\n        var parsedProp = this.parse(name, val);\n        parsedProps[name] = parsedProp;\n    }\n    _p.defaultProperties = parsedProps;\n    return _p.defaultProperties;\n};\nstyfn$2.addDefaultStylesheet = function() {\n    this.selector(\":parent\").css({\n        \"shape\": \"rectangle\",\n        \"padding\": 10,\n        \"background-color\": \"#eee\",\n        \"border-color\": \"#ccc\",\n        \"border-width\": 1\n    }).selector(\"edge\").css({\n        \"width\": 3\n    }).selector(\":loop\").css({\n        \"curve-style\": \"bezier\"\n    }).selector(\"edge:compound\").css({\n        \"curve-style\": \"bezier\",\n        \"source-endpoint\": \"outside-to-line\",\n        \"target-endpoint\": \"outside-to-line\"\n    }).selector(\":selected\").css({\n        \"background-color\": \"#0169D9\",\n        \"line-color\": \"#0169D9\",\n        \"source-arrow-color\": \"#0169D9\",\n        \"target-arrow-color\": \"#0169D9\",\n        \"mid-source-arrow-color\": \"#0169D9\",\n        \"mid-target-arrow-color\": \"#0169D9\"\n    }).selector(\":parent:selected\").css({\n        \"background-color\": \"#CCE1F9\",\n        \"border-color\": \"#aec8e5\"\n    }).selector(\":active\").css({\n        \"overlay-color\": \"black\",\n        \"overlay-padding\": 10,\n        \"overlay-opacity\": 0.25\n    });\n    this.defaultLength = this.length;\n};\nvar styfn$1 = {};\n// a caching layer for property parsing\nstyfn$1.parse = function(name, value, propIsBypass, propIsFlat) {\n    var self1 = this;\n    // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n    if (fn$6(value)) {\n        return self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n    var flatKey = propIsFlat === \"mapping\" || propIsFlat === true || propIsFlat === false || propIsFlat == null ? \"dontcare\" : propIsFlat;\n    var bypassKey = propIsBypass ? \"t\" : \"f\";\n    var valueKey = \"\" + value;\n    var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n    var propCache = self1.propCache = self1.propCache || [];\n    var ret;\n    if (!(ret = propCache[argHash])) {\n        ret = propCache[argHash] = self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n    // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n    // - mappings can't be shared b/c mappings are per-element\n    if (propIsBypass || propIsFlat === \"mapping\") {\n        // need a copy since props are mutated later in their lifecycles\n        ret = copy(ret);\n        if (ret) {\n            ret.value = copy(ret.value); // because it could be an array, e.g. colour\n        }\n    }\n    return ret;\n};\nstyfn$1.parseImplWarn = function(name, value, propIsBypass, propIsFlat) {\n    var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n    if (!prop && value != null) {\n        warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n    }\n    if (prop && (prop.name === \"width\" || prop.name === \"height\") && value === \"label\") {\n        warn(\"The style value of `label` is deprecated for `\" + prop.name + \"`\");\n    }\n    return prop;\n};\n// parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\nstyfn$1.parseImpl = function(name, value, propIsBypass, propIsFlat) {\n    var self1 = this;\n    name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n    var property = self1.properties[name];\n    var passedValue = value;\n    var types = self1.types;\n    if (!property) {\n        return null;\n    } // return null on property of unknown name\n    if (value === undefined) {\n        return null;\n    } // can't assign undefined\n    // the property may be an alias\n    if (property.alias) {\n        property = property.pointsTo;\n        name = property.name;\n    }\n    var valueIsString = string(value);\n    if (valueIsString) {\n        // trim the value to make parsing easier\n        value = value.trim();\n    }\n    var type = property.type;\n    if (!type) {\n        return null;\n    } // no type, no luck\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n    if (propIsBypass && (value === \"\" || value === null)) {\n        return {\n            name: name,\n            value: value,\n            bypass: true,\n            deleteBypass: true\n        };\n    }\n    // check if value is a function used as a mapper\n    if (fn$6(value)) {\n        return {\n            name: name,\n            value: value,\n            strValue: \"fn\",\n            mapped: types.fn,\n            bypass: propIsBypass\n        };\n    }\n    // check if value is mapped\n    var data, mapData;\n    if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== \"a\") ;\n    else if (value.length >= 7 && value[0] === \"d\" && (data = new RegExp(types.data.regex).exec(value))) {\n        if (propIsBypass) {\n            return false;\n        } // mappers not allowed in bypass\n        var mapped = types.data;\n        return {\n            name: name,\n            value: data,\n            strValue: \"\" + value,\n            mapped: mapped,\n            field: data[1],\n            bypass: propIsBypass\n        };\n    } else if (value.length >= 10 && value[0] === \"m\" && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n        if (propIsBypass) {\n            return false;\n        } // mappers not allowed in bypass\n        if (type.multiple) {\n            return false;\n        } // impossible to map to num\n        var _mapped = types.mapData;\n        // we can map only if the type is a colour or a number\n        if (!(type.color || type.number)) {\n            return false;\n        }\n        var valueMin = this.parse(name, mapData[4]); // parse to validate\n        if (!valueMin || valueMin.mapped) {\n            return false;\n        } // can't be invalid or mapped\n        var valueMax = this.parse(name, mapData[5]); // parse to validate\n        if (!valueMax || valueMax.mapped) {\n            return false;\n        } // can't be invalid or mapped\n        // check if valueMin and valueMax are the same\n        if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n            warn(\"`\" + name + \": \" + value + \"` is not a valid mapper because the output range is zero; converting to `\" + name + \": \" + valueMin.strValue + \"`\");\n            return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n        } else if (type.color) {\n            var c1 = valueMin.value;\n            var c2 = valueMax.value;\n            var same = c1[0] === c2[0] // red\n             && c1[1] === c2[1] // green\n             && c1[2] === c2[2] // blue\n             && // optional alpha\n            (c1[3] === c2[3] // same alpha outright\n             || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n            ) && (c2[3] == null || c2[3] === 1 // full opacity for colour 2?\n            ));\n            if (same) {\n                return false;\n            } // can't make a mapper without a range\n        }\n        return {\n            name: name,\n            value: mapData,\n            strValue: \"\" + value,\n            mapped: _mapped,\n            field: mapData[1],\n            fieldMin: parseFloat(mapData[2]),\n            // min & max are numeric\n            fieldMax: parseFloat(mapData[3]),\n            valueMin: valueMin.value,\n            valueMax: valueMax.value,\n            bypass: propIsBypass\n        };\n    }\n    if (type.multiple && propIsFlat !== \"multiple\") {\n        var vals;\n        if (valueIsString) {\n            vals = value.split(/\\s+/);\n        } else if (array(value)) {\n            vals = value;\n        } else {\n            vals = [\n                value\n            ];\n        }\n        if (type.evenMultiple && vals.length % 2 !== 0) {\n            return null;\n        }\n        var valArr = [];\n        var unitsArr = [];\n        var pfValArr = [];\n        var strVal = \"\";\n        var hasEnum = false;\n        for(var i = 0; i < vals.length; i++){\n            var p = self1.parse(name, vals[i], propIsBypass, \"multiple\");\n            hasEnum = hasEnum || string(p.value);\n            valArr.push(p.value);\n            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n            unitsArr.push(p.units);\n            strVal += (i > 0 ? \" \" : \"\") + p.strValue;\n        }\n        if (type.validate && !type.validate(valArr, unitsArr)) {\n            return null;\n        }\n        if (type.singleEnum && hasEnum) {\n            if (valArr.length === 1 && string(valArr[0])) {\n                return {\n                    name: name,\n                    value: valArr[0],\n                    strValue: valArr[0],\n                    bypass: propIsBypass\n                };\n            } else {\n                return null;\n            }\n        }\n        return {\n            name: name,\n            value: valArr,\n            pfValue: pfValArr,\n            strValue: strVal,\n            bypass: propIsBypass,\n            units: unitsArr\n        };\n    }\n    // several types also allow enums\n    var checkEnums = function checkEnums() {\n        for(var _i = 0; _i < type.enums.length; _i++){\n            var en = type.enums[_i];\n            if (en === value) {\n                return {\n                    name: name,\n                    value: value,\n                    strValue: \"\" + value,\n                    bypass: propIsBypass\n                };\n            }\n        }\n        return null;\n    };\n    // check the type and return the appropriate object\n    if (type.number) {\n        var units;\n        var implicitUnits = \"px\"; // not set => px\n        if (type.units) {\n            // use specified units if set\n            units = type.units;\n        }\n        if (type.implicitUnits) {\n            implicitUnits = type.implicitUnits;\n        }\n        if (!type.unitless) {\n            if (valueIsString) {\n                var unitsRegex = \"px|em\" + (type.allowPercent ? \"|\\\\%\" : \"\");\n                if (units) {\n                    unitsRegex = units;\n                } // only allow explicit units if so set\n                var match = value.match(\"^(\" + number + \")(\" + unitsRegex + \")?\" + \"$\");\n                if (match) {\n                    value = match[1];\n                    units = match[2] || implicitUnits;\n                }\n            } else if (!units || type.implicitUnits) {\n                units = implicitUnits; // implicitly px if unspecified\n            }\n        }\n        value = parseFloat(value);\n        // if not a number and enums not allowed, then the value is invalid\n        if (isNaN(value) && type.enums === undefined) {\n            return null;\n        }\n        // check if this number type also accepts special keywords in place of numbers\n        // (i.e. `left`, `auto`, etc)\n        if (isNaN(value) && type.enums !== undefined) {\n            value = passedValue;\n            return checkEnums();\n        }\n        // check if value must be an integer\n        if (type.integer && !integer(value)) {\n            return null;\n        }\n        // check value is within range\n        if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n            return null;\n        }\n        var ret = {\n            name: name,\n            value: value,\n            strValue: \"\" + value + (units ? units : \"\"),\n            units: units,\n            bypass: propIsBypass\n        };\n        // normalise value in pixels\n        if (type.unitless || units !== \"px\" && units !== \"em\") {\n            ret.pfValue = value;\n        } else {\n            ret.pfValue = units === \"px\" || !units ? value : this.getEmSizeInPixels() * value;\n        }\n        // normalise value in ms\n        if (units === \"ms\" || units === \"s\") {\n            ret.pfValue = units === \"ms\" ? value : 1000 * value;\n        }\n        // normalise value in rad\n        if (units === \"deg\" || units === \"rad\") {\n            ret.pfValue = units === \"rad\" ? value : deg2rad(value);\n        }\n        // normalize value in %\n        if (units === \"%\") {\n            ret.pfValue = value / 100;\n        }\n        return ret;\n    } else if (type.propList) {\n        var props = [];\n        var propsStr = \"\" + value;\n        if (propsStr === \"none\") ;\n        else {\n            // go over each prop\n            var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n            for(var _i2 = 0; _i2 < propsSplit.length; _i2++){\n                var propName = propsSplit[_i2].trim();\n                if (self1.properties[propName]) {\n                    props.push(propName);\n                } else {\n                    warn(\"`\" + propName + \"` is not a valid property name\");\n                }\n            }\n            if (props.length === 0) {\n                return null;\n            }\n        }\n        return {\n            name: name,\n            value: props,\n            strValue: props.length === 0 ? \"none\" : props.join(\" \"),\n            bypass: propIsBypass\n        };\n    } else if (type.color) {\n        var tuple = color2tuple(value);\n        if (!tuple) {\n            return null;\n        }\n        return {\n            name: name,\n            value: tuple,\n            pfValue: tuple,\n            strValue: \"rgb(\" + tuple[0] + \",\" + tuple[1] + \",\" + tuple[2] + \")\",\n            // n.b. no spaces b/c of multiple support\n            bypass: propIsBypass\n        };\n    } else if (type.regex || type.regexes) {\n        // first check enums\n        if (type.enums) {\n            var enumProp = checkEnums();\n            if (enumProp) {\n                return enumProp;\n            }\n        }\n        var regexes = type.regexes ? type.regexes : [\n            type.regex\n        ];\n        for(var _i3 = 0; _i3 < regexes.length; _i3++){\n            var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n            var m1 = regex.exec(value);\n            if (m1) {\n                // regex matches\n                return {\n                    name: name,\n                    value: type.singleRegexMatchValue ? m1[1] : m1,\n                    strValue: \"\" + value,\n                    bypass: propIsBypass\n                };\n            }\n        }\n        return null; // didn't match any\n    } else if (type.string) {\n        // just return\n        return {\n            name: name,\n            value: \"\" + value,\n            strValue: \"\" + value,\n            bypass: propIsBypass\n        };\n    } else if (type.enums) {\n        // check enums last because it's a combo type in others\n        return checkEnums();\n    } else {\n        return null; // not a type we can handle\n    }\n};\nvar _Style = function Style(cy) {\n    if (!(this instanceof _Style)) {\n        return new _Style(cy);\n    }\n    if (!core(cy)) {\n        error(\"A style must have a core reference\");\n        return;\n    }\n    this._private = {\n        cy: cy,\n        coreStyle: {}\n    };\n    this.length = 0;\n    this.resetToDefault();\n};\nvar styfn = _Style.prototype;\nstyfn.instanceString = function() {\n    return \"style\";\n};\n// remove all contexts\nstyfn.clear = function() {\n    var _p = this._private;\n    var cy = _p.cy;\n    var eles = cy.elements();\n    for(var i = 0; i < this.length; i++){\n        this[i] = undefined;\n    }\n    this.length = 0;\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n    this.cleanElements(eles, true);\n    eles.forEach(function(ele) {\n        var ele_p = ele[0]._private;\n        ele_p.styleDirty = true;\n        ele_p.appliedInitStyle = false;\n    });\n    return this; // chaining\n};\nstyfn.resetToDefault = function() {\n    this.clear();\n    this.addDefaultStylesheet();\n    return this;\n};\n// builds a style object for the 'core' selector\nstyfn.core = function(propName) {\n    return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n};\n// create a new context from the specified selector string and switch to that context\nstyfn.selector = function(selectorStr) {\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === \"core\" ? null : new Selector(selectorStr);\n    var i = this.length++; // new context means new index\n    this[i] = {\n        selector: selector,\n        properties: [],\n        mappedProperties: [],\n        index: i\n    };\n    return this; // chaining\n};\n// add one or many css rules to the current context\nstyfn.css = function() {\n    var self1 = this;\n    var args = arguments;\n    if (args.length === 1) {\n        var map = args[0];\n        for(var i = 0; i < self1.properties.length; i++){\n            var prop = self1.properties[i];\n            var mapVal = map[prop.name];\n            if (mapVal === undefined) {\n                mapVal = map[dash2camel(prop.name)];\n            }\n            if (mapVal !== undefined) {\n                this.cssRule(prop.name, mapVal);\n            }\n        }\n    } else if (args.length === 2) {\n        this.cssRule(args[0], args[1]);\n    }\n    // do nothing if args are invalid\n    return this; // chaining\n};\nstyfn.style = styfn.css;\n// add a single css rule to the current context\nstyfn.cssRule = function(name, value) {\n    // name-value pair\n    var property = this.parse(name, value);\n    // add property to current context if valid\n    if (property) {\n        var i = this.length - 1;\n        this[i].properties.push(property);\n        this[i].properties[property.name] = property; // allow access by name as well\n        if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n            this._private.hasPie = true;\n        }\n        if (property.name.match(/stripe-(\\d+)-background-size/) && property.value) {\n            this._private.hasStripe = true;\n        }\n        if (property.mapped) {\n            this[i].mappedProperties.push(property);\n        }\n        // add to core style if necessary\n        var currentSelectorIsCore = !this[i].selector;\n        if (currentSelectorIsCore) {\n            this._private.coreStyle[property.name] = property;\n        }\n    }\n    return this; // chaining\n};\nstyfn.append = function(style) {\n    if (stylesheet(style)) {\n        style.appendToStyle(this);\n    } else if (array(style)) {\n        this.appendFromJson(style);\n    } else if (string(style)) {\n        this.appendFromString(style);\n    } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n    return this;\n};\n// static function\n_Style.fromJson = function(cy, json) {\n    var style = new _Style(cy);\n    style.fromJson(json);\n    return style;\n};\n_Style.fromString = function(cy, string) {\n    return new _Style(cy).fromString(string);\n};\n[\n    styfn$8,\n    styfn$7,\n    styfn$6,\n    styfn$5,\n    styfn$4,\n    styfn$3,\n    styfn$2,\n    styfn$1\n].forEach(function(props) {\n    extend(styfn, props);\n});\n_Style.types = styfn.types;\n_Style.properties = styfn.properties;\n_Style.propertyGroups = styfn.propertyGroups;\n_Style.propertyGroupNames = styfn.propertyGroupNames;\n_Style.propertyGroupKeys = styfn.propertyGroupKeys;\nvar corefn$2 = {\n    style: function style(newStyle) {\n        if (newStyle) {\n            var s = this.setStyle(newStyle);\n            s.update();\n        }\n        return this._private.style;\n    },\n    setStyle: function setStyle(style) {\n        var _p = this._private;\n        if (stylesheet(style)) {\n            _p.style = style.generateStyle(this);\n        } else if (array(style)) {\n            _p.style = _Style.fromJson(this, style);\n        } else if (string(style)) {\n            _p.style = _Style.fromString(this, style);\n        } else {\n            _p.style = _Style(this);\n        }\n        return _p.style;\n    },\n    // e.g. cy.data() changed => recalc ele mappers\n    updateStyle: function updateStyle() {\n        this.mutableElements().updateStyle(); // just send to all eles\n    }\n};\nvar defaultSelectionType = \"single\";\nvar corefn$1 = {\n    autolock: function autolock(bool) {\n        if (bool !== undefined) {\n            this._private.autolock = bool ? true : false;\n        } else {\n            return this._private.autolock;\n        }\n        return this; // chaining\n    },\n    autoungrabify: function autoungrabify(bool) {\n        if (bool !== undefined) {\n            this._private.autoungrabify = bool ? true : false;\n        } else {\n            return this._private.autoungrabify;\n        }\n        return this; // chaining\n    },\n    autounselectify: function autounselectify(bool) {\n        if (bool !== undefined) {\n            this._private.autounselectify = bool ? true : false;\n        } else {\n            return this._private.autounselectify;\n        }\n        return this; // chaining\n    },\n    selectionType: function selectionType(selType) {\n        var _p = this._private;\n        if (_p.selectionType == null) {\n            _p.selectionType = defaultSelectionType;\n        }\n        if (selType !== undefined) {\n            if (selType === \"additive\" || selType === \"single\") {\n                _p.selectionType = selType;\n            }\n        } else {\n            return _p.selectionType;\n        }\n        return this;\n    },\n    panningEnabled: function panningEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.panningEnabled = bool ? true : false;\n        } else {\n            return this._private.panningEnabled;\n        }\n        return this; // chaining\n    },\n    userPanningEnabled: function userPanningEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.userPanningEnabled = bool ? true : false;\n        } else {\n            return this._private.userPanningEnabled;\n        }\n        return this; // chaining\n    },\n    zoomingEnabled: function zoomingEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.zoomingEnabled = bool ? true : false;\n        } else {\n            return this._private.zoomingEnabled;\n        }\n        return this; // chaining\n    },\n    userZoomingEnabled: function userZoomingEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.userZoomingEnabled = bool ? true : false;\n        } else {\n            return this._private.userZoomingEnabled;\n        }\n        return this; // chaining\n    },\n    boxSelectionEnabled: function boxSelectionEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.boxSelectionEnabled = bool ? true : false;\n        } else {\n            return this._private.boxSelectionEnabled;\n        }\n        return this; // chaining\n    },\n    pan: function pan() {\n        var args = arguments;\n        var pan = this._private.pan;\n        var dim, val, dims, x, y;\n        switch(args.length){\n            case 0:\n                // .pan()\n                return pan;\n            case 1:\n                if (string(args[0])) {\n                    // .pan('x')\n                    dim = args[0];\n                    return pan[dim];\n                } else if (plainObject(args[0])) {\n                    // .pan({ x: 0, y: 100 })\n                    if (!this._private.panningEnabled) {\n                        return this;\n                    }\n                    dims = args[0];\n                    x = dims.x;\n                    y = dims.y;\n                    if (number$1(x)) {\n                        pan.x = x;\n                    }\n                    if (number$1(y)) {\n                        pan.y = y;\n                    }\n                    this.emit(\"pan viewport\");\n                }\n                break;\n            case 2:\n                // .pan('x', 100)\n                if (!this._private.panningEnabled) {\n                    return this;\n                }\n                dim = args[0];\n                val = args[1];\n                if ((dim === \"x\" || dim === \"y\") && number$1(val)) {\n                    pan[dim] = val;\n                }\n                this.emit(\"pan viewport\");\n                break;\n        }\n        this.notify(\"viewport\");\n        return this; // chaining\n    },\n    panBy: function panBy(arg0, arg1) {\n        var args = arguments;\n        var pan = this._private.pan;\n        var dim, val, dims, x, y;\n        if (!this._private.panningEnabled) {\n            return this;\n        }\n        switch(args.length){\n            case 1:\n                if (plainObject(arg0)) {\n                    // .panBy({ x: 0, y: 100 })\n                    dims = args[0];\n                    x = dims.x;\n                    y = dims.y;\n                    if (number$1(x)) {\n                        pan.x += x;\n                    }\n                    if (number$1(y)) {\n                        pan.y += y;\n                    }\n                    this.emit(\"pan viewport\");\n                }\n                break;\n            case 2:\n                // .panBy('x', 100)\n                dim = arg0;\n                val = arg1;\n                if ((dim === \"x\" || dim === \"y\") && number$1(val)) {\n                    pan[dim] += val;\n                }\n                this.emit(\"pan viewport\");\n                break;\n        }\n        this.notify(\"viewport\");\n        return this; // chaining\n    },\n    gc: function gc() {\n        this.notify(\"gc\");\n    },\n    fit: function fit(elements, padding) {\n        var viewportState = this.getFitViewport(elements, padding);\n        if (viewportState) {\n            var _p = this._private;\n            _p.zoom = viewportState.zoom;\n            _p.pan = viewportState.pan;\n            this.emit(\"pan zoom viewport\");\n            this.notify(\"viewport\");\n        }\n        return this; // chaining\n    },\n    getFitViewport: function getFitViewport(elements, padding) {\n        if (number$1(elements) && padding === undefined) {\n            // elements is optional\n            padding = elements;\n            elements = undefined;\n        }\n        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n            return;\n        }\n        var bb;\n        if (string(elements)) {\n            var sel = elements;\n            elements = this.$(sel);\n        } else if (boundingBox(elements)) {\n            // assume bb\n            var bbe = elements;\n            bb = {\n                x1: bbe.x1,\n                y1: bbe.y1,\n                x2: bbe.x2,\n                y2: bbe.y2\n            };\n            bb.w = bb.x2 - bb.x1;\n            bb.h = bb.y2 - bb.y1;\n        } else if (!elementOrCollection(elements)) {\n            elements = this.mutableElements();\n        }\n        if (elementOrCollection(elements) && elements.empty()) {\n            return;\n        } // can't fit to nothing\n        bb = bb || elements.boundingBox();\n        var w = this.width();\n        var h = this.height();\n        var zoom;\n        padding = number$1(padding) ? padding : 0;\n        if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);\n            // crop zoom\n            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n            var pan = {\n                // now pan to middle\n                x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n                y: (h - zoom * (bb.y1 + bb.y2)) / 2\n            };\n            return {\n                zoom: zoom,\n                pan: pan\n            };\n        }\n        return;\n    },\n    zoomRange: function zoomRange(min, max) {\n        var _p = this._private;\n        if (max == null) {\n            var opts = min;\n            min = opts.min;\n            max = opts.max;\n        }\n        if (number$1(min) && number$1(max) && min <= max) {\n            _p.minZoom = min;\n            _p.maxZoom = max;\n        } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n            _p.minZoom = min;\n        } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n            _p.maxZoom = max;\n        }\n        return this;\n    },\n    minZoom: function minZoom(zoom) {\n        if (zoom === undefined) {\n            return this._private.minZoom;\n        } else {\n            return this.zoomRange({\n                min: zoom\n            });\n        }\n    },\n    maxZoom: function maxZoom(zoom) {\n        if (zoom === undefined) {\n            return this._private.maxZoom;\n        } else {\n            return this.zoomRange({\n                max: zoom\n            });\n        }\n    },\n    getZoomedViewport: function getZoomedViewport(params) {\n        var _p = this._private;\n        var currentPan = _p.pan;\n        var currentZoom = _p.zoom;\n        var pos; // in rendered px\n        var zoom;\n        var bail = false;\n        if (!_p.zoomingEnabled) {\n            // zooming disabled\n            bail = true;\n        }\n        if (number$1(params)) {\n            // then set the zoom\n            zoom = params;\n        } else if (plainObject(params)) {\n            // then zoom about a point\n            zoom = params.level;\n            if (params.position != null) {\n                pos = modelToRenderedPosition$1(params.position, currentZoom, currentPan);\n            } else if (params.renderedPosition != null) {\n                pos = params.renderedPosition;\n            }\n            if (pos != null && !_p.panningEnabled) {\n                // panning disabled\n                bail = true;\n            }\n        }\n        // crop zoom\n        zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n        zoom = zoom < _p.minZoom ? _p.minZoom : zoom;\n        // can't zoom with invalid params\n        if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n            return null;\n        }\n        if (pos != null) {\n            // set zoom about position\n            var pan1 = currentPan;\n            var zoom1 = currentZoom;\n            var zoom2 = zoom;\n            var pan2 = {\n                x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n                y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n            };\n            return {\n                zoomed: true,\n                panned: true,\n                zoom: zoom2,\n                pan: pan2\n            };\n        } else {\n            // just set the zoom\n            return {\n                zoomed: true,\n                panned: false,\n                zoom: zoom,\n                pan: currentPan\n            };\n        }\n    },\n    zoom: function zoom(params) {\n        if (params === undefined) {\n            // get\n            return this._private.zoom;\n        } else {\n            // set\n            var vp = this.getZoomedViewport(params);\n            var _p = this._private;\n            if (vp == null || !vp.zoomed) {\n                return this;\n            }\n            _p.zoom = vp.zoom;\n            if (vp.panned) {\n                _p.pan.x = vp.pan.x;\n                _p.pan.y = vp.pan.y;\n            }\n            this.emit(\"zoom\" + (vp.panned ? \" pan\" : \"\") + \" viewport\");\n            this.notify(\"viewport\");\n            return this; // chaining\n        }\n    },\n    viewport: function viewport(opts) {\n        var _p = this._private;\n        var zoomDefd = true;\n        var panDefd = true;\n        var events = []; // to trigger\n        var zoomFailed = false;\n        var panFailed = false;\n        if (!opts) {\n            return this;\n        }\n        if (!number$1(opts.zoom)) {\n            zoomDefd = false;\n        }\n        if (!plainObject(opts.pan)) {\n            panDefd = false;\n        }\n        if (!zoomDefd && !panDefd) {\n            return this;\n        }\n        if (zoomDefd) {\n            var z = opts.zoom;\n            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n                zoomFailed = true;\n            } else {\n                _p.zoom = z;\n                events.push(\"zoom\");\n            }\n        }\n        if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n            var p = opts.pan;\n            if (number$1(p.x)) {\n                _p.pan.x = p.x;\n                panFailed = false;\n            }\n            if (number$1(p.y)) {\n                _p.pan.y = p.y;\n                panFailed = false;\n            }\n            if (!panFailed) {\n                events.push(\"pan\");\n            }\n        }\n        if (events.length > 0) {\n            events.push(\"viewport\");\n            this.emit(events.join(\" \"));\n            this.notify(\"viewport\");\n        }\n        return this; // chaining\n    },\n    center: function center(elements) {\n        var pan = this.getCenterPan(elements);\n        if (pan) {\n            this._private.pan = pan;\n            this.emit(\"pan viewport\");\n            this.notify(\"viewport\");\n        }\n        return this; // chaining\n    },\n    getCenterPan: function getCenterPan(elements, zoom) {\n        if (!this._private.panningEnabled) {\n            return;\n        }\n        if (string(elements)) {\n            var selector = elements;\n            elements = this.mutableElements().filter(selector);\n        } else if (!elementOrCollection(elements)) {\n            elements = this.mutableElements();\n        }\n        if (elements.length === 0) {\n            return;\n        } // can't centre pan to nothing\n        var bb = elements.boundingBox();\n        var w = this.width();\n        var h = this.height();\n        zoom = zoom === undefined ? this._private.zoom : zoom;\n        var pan = {\n            // middle\n            x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n            y: (h - zoom * (bb.y1 + bb.y2)) / 2\n        };\n        return pan;\n    },\n    reset: function reset() {\n        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n            return this;\n        }\n        this.viewport({\n            pan: {\n                x: 0,\n                y: 0\n            },\n            zoom: 1\n        });\n        return this; // chaining\n    },\n    invalidateSize: function invalidateSize() {\n        this._private.sizeCache = null;\n    },\n    size: function size() {\n        var _p = this._private;\n        var container = _p.container;\n        var cy = this;\n        return _p.sizeCache = _p.sizeCache || (container ? function() {\n            var style = cy.window().getComputedStyle(container);\n            var val = function val(name) {\n                return parseFloat(style.getPropertyValue(name));\n            };\n            return {\n                width: container.clientWidth - val(\"padding-left\") - val(\"padding-right\"),\n                height: container.clientHeight - val(\"padding-top\") - val(\"padding-bottom\")\n            };\n        }() : {\n            // fallback if no container (not 0 b/c can be used for dividing etc)\n            width: 1,\n            height: 1\n        });\n    },\n    width: function width() {\n        return this.size().width;\n    },\n    height: function height() {\n        return this.size().height;\n    },\n    extent: function extent() {\n        var pan = this._private.pan;\n        var zoom = this._private.zoom;\n        var rb = this.renderedExtent();\n        var b = {\n            x1: (rb.x1 - pan.x) / zoom,\n            x2: (rb.x2 - pan.x) / zoom,\n            y1: (rb.y1 - pan.y) / zoom,\n            y2: (rb.y2 - pan.y) / zoom\n        };\n        b.w = b.x2 - b.x1;\n        b.h = b.y2 - b.y1;\n        return b;\n    },\n    renderedExtent: function renderedExtent() {\n        var width = this.width();\n        var height = this.height();\n        return {\n            x1: 0,\n            y1: 0,\n            x2: width,\n            y2: height,\n            w: width,\n            h: height\n        };\n    },\n    multiClickDebounceTime: function multiClickDebounceTime(_int) {\n        if (_int) this._private.multiClickDebounceTime = _int;\n        else return this._private.multiClickDebounceTime;\n        return this; // chaining\n    }\n};\n// aliases\ncorefn$1.centre = corefn$1.center;\n// backwards compatibility\ncorefn$1.autolockNodes = corefn$1.autolock;\ncorefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\nvar fn = {\n    data: define.data({\n        field: \"data\",\n        bindingEvent: \"data\",\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: \"data\",\n        settingTriggersEvent: true,\n        triggerFnName: \"trigger\",\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeData: define.removeData({\n        field: \"data\",\n        event: \"data\",\n        triggerFnName: \"trigger\",\n        triggerEvent: true,\n        updateStyle: true\n    }),\n    scratch: define.data({\n        field: \"scratch\",\n        bindingEvent: \"scratch\",\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: \"scratch\",\n        settingTriggersEvent: true,\n        triggerFnName: \"trigger\",\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeScratch: define.removeData({\n        field: \"scratch\",\n        event: \"scratch\",\n        triggerFnName: \"trigger\",\n        triggerEvent: true,\n        updateStyle: true\n    })\n};\n// aliases\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\nvar Core = function Core(opts) {\n    var cy = this;\n    opts = extend({}, opts);\n    var container = opts.container;\n    // allow for passing a wrapped jquery object\n    // e.g. cytoscape({ container: $('#cy') })\n    if (container && !htmlElement(container) && htmlElement(container[0])) {\n        container = container[0];\n    }\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n    reg = reg || {};\n    if (reg && reg.cy) {\n        reg.cy.destroy();\n        reg = {}; // old instance => replace reg completely\n    }\n    var readies = reg.readies = reg.readies || [];\n    if (container) {\n        container._cyreg = reg;\n    } // make sure container assoc'd reg points to this cy\n    reg.cy = cy;\n    var head = _window !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = extend({\n        name: head ? \"grid\" : \"null\"\n    }, options.layout);\n    options.renderer = extend({\n        name: head ? \"canvas\" : \"null\"\n    }, options.renderer);\n    var defVal = function defVal(def, val, altVal) {\n        if (val !== undefined) {\n            return val;\n        } else if (altVal !== undefined) {\n            return altVal;\n        } else {\n            return def;\n        }\n    };\n    var _p = this._private = {\n        container: container,\n        // html dom ele container\n        ready: false,\n        // whether ready has been triggered\n        options: options,\n        // cached options\n        elements: new Collection(this),\n        // elements in the graph\n        listeners: [],\n        // list of listeners\n        aniEles: new Collection(this),\n        // elements being animated\n        data: options.data || {},\n        // data for the core\n        scratch: {},\n        // scratch object for core\n        layout: null,\n        renderer: null,\n        destroyed: false,\n        // whether destroy was called\n        notificationsEnabled: true,\n        // whether notifications are sent to the renderer\n        minZoom: 1e-50,\n        maxZoom: 1e50,\n        zoomingEnabled: defVal(true, options.zoomingEnabled),\n        userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n        panningEnabled: defVal(true, options.panningEnabled),\n        userPanningEnabled: defVal(true, options.userPanningEnabled),\n        boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n        autolock: defVal(false, options.autolock, options.autolockNodes),\n        autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n        autounselectify: defVal(false, options.autounselectify),\n        styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n        zoom: number$1(options.zoom) ? options.zoom : 1,\n        pan: {\n            x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n            y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n        },\n        animation: {\n            // object for currently-running animations\n            current: [],\n            queue: []\n        },\n        hasCompoundNodes: false,\n        multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n    };\n    this.createEmitter();\n    // set selection type\n    this.selectionType(options.selectionType);\n    // init zoom bounds\n    this.zoomRange({\n        min: options.minZoom,\n        max: options.maxZoom\n    });\n    var loadExtData = function loadExtData(extData, next) {\n        var anyIsPromise = extData.some(promise);\n        if (anyIsPromise) {\n            return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n        } else {\n            next(extData); // exec synchronously for convenience\n        }\n    };\n    // start with the default stylesheet so we have something before loading an external stylesheet\n    if (_p.styleEnabled) {\n        cy.setStyle([]);\n    }\n    // create the renderer\n    var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n    cy.initRenderer(rendererOptions);\n    var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n        cy.notifications(false);\n        // remove old elements\n        var oldEles = cy.mutableElements();\n        if (oldEles.length > 0) {\n            oldEles.remove();\n        }\n        if (elements != null) {\n            if (plainObject(elements) || array(elements)) {\n                cy.add(elements);\n            }\n        }\n        cy.one(\"layoutready\", function(e) {\n            cy.notifications(true);\n            cy.emit(e); // we missed this event by turning notifications off, so pass it on\n            cy.one(\"load\", onload);\n            cy.emitAndNotify(\"load\");\n        }).one(\"layoutstop\", function() {\n            cy.one(\"done\", ondone);\n            cy.emit(\"done\");\n        });\n        var layoutOpts = extend({}, cy._private.options.layout);\n        layoutOpts.eles = cy.elements();\n        cy.layout(layoutOpts).run();\n    };\n    loadExtData([\n        options.style,\n        options.elements\n    ], function(thens) {\n        var initStyle = thens[0];\n        var initEles = thens[1];\n        // init style\n        if (_p.styleEnabled) {\n            cy.style().append(initStyle);\n        }\n        // initial load\n        setElesAndLayout(initEles, function() {\n            // onready\n            cy.startAnimationLoop();\n            _p.ready = true;\n            // if a ready callback is specified as an option, the bind it\n            if (fn$6(options.ready)) {\n                cy.on(\"ready\", options.ready);\n            }\n            // bind all the ready handlers registered before creating this instance\n            for(var i = 0; i < readies.length; i++){\n                var fn = readies[i];\n                cy.on(\"ready\", fn);\n            }\n            if (reg) {\n                reg.readies = [];\n            } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n            cy.emit(\"ready\");\n        }, options.done);\n    });\n};\nvar corefn = Core.prototype; // short alias\nextend(corefn, {\n    instanceString: function instanceString() {\n        return \"core\";\n    },\n    isReady: function isReady() {\n        return this._private.ready;\n    },\n    destroyed: function destroyed() {\n        return this._private.destroyed;\n    },\n    ready: function ready(fn) {\n        if (this.isReady()) {\n            this.emitter().emit(\"ready\", [], fn); // just calls fn as though triggered via ready event\n        } else {\n            this.on(\"ready\", fn);\n        }\n        return this;\n    },\n    destroy: function destroy() {\n        var cy = this;\n        if (cy.destroyed()) return;\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        this.emit(\"destroy\");\n        cy._private.destroyed = true;\n        return cy;\n    },\n    hasElementWithId: function hasElementWithId(id) {\n        return this._private.elements.hasElementWithId(id);\n    },\n    getElementById: function getElementById(id) {\n        return this._private.elements.getElementById(id);\n    },\n    hasCompoundNodes: function hasCompoundNodes() {\n        return this._private.hasCompoundNodes;\n    },\n    headless: function headless() {\n        return this._private.renderer.isHeadless();\n    },\n    styleEnabled: function styleEnabled() {\n        return this._private.styleEnabled;\n    },\n    addToPool: function addToPool(eles) {\n        this._private.elements.merge(eles);\n        return this; // chaining\n    },\n    removeFromPool: function removeFromPool(eles) {\n        this._private.elements.unmerge(eles);\n        return this;\n    },\n    container: function container() {\n        return this._private.container || null;\n    },\n    window: function window1() {\n        var container = this._private.container;\n        if (container == null) return _window;\n        var ownerDocument = this._private.container.ownerDocument;\n        if (ownerDocument === undefined || ownerDocument == null) {\n            return _window;\n        }\n        return ownerDocument.defaultView || _window;\n    },\n    mount: function mount(container) {\n        if (container == null) {\n            return;\n        }\n        var cy = this;\n        var _p = cy._private;\n        var options = _p.options;\n        if (!htmlElement(container) && htmlElement(container[0])) {\n            container = container[0];\n        }\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        _p.container = container;\n        _p.styleEnabled = true;\n        cy.invalidateSize();\n        cy.initRenderer(extend({}, options, options.renderer, {\n            // allow custom renderer name to be re-used, otherwise use canvas\n            name: options.renderer.name === \"null\" ? \"canvas\" : options.renderer.name\n        }));\n        cy.startAnimationLoop();\n        cy.style(options.style);\n        cy.emit(\"mount\");\n        return cy;\n    },\n    unmount: function unmount() {\n        var cy = this;\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        cy.initRenderer({\n            name: \"null\"\n        });\n        cy.emit(\"unmount\");\n        return cy;\n    },\n    options: function options() {\n        return copy(this._private.options);\n    },\n    json: function json(obj) {\n        var cy = this;\n        var _p = cy._private;\n        var eles = cy.mutableElements();\n        var getFreshRef = function getFreshRef(ele) {\n            return cy.getElementById(ele.id());\n        };\n        if (plainObject(obj)) {\n            // set\n            cy.startBatch();\n            if (obj.elements) {\n                var idInJson = {};\n                var updateEles = function updateEles(jsons, gr) {\n                    var toAdd = [];\n                    var toMod = [];\n                    for(var i = 0; i < jsons.length; i++){\n                        var json = jsons[i];\n                        if (!json.data.id) {\n                            warn(\"cy.json() cannot handle elements without an ID attribute\");\n                            continue;\n                        }\n                        var id = \"\" + json.data.id; // id must be string\n                        var ele = cy.getElementById(id);\n                        idInJson[id] = true;\n                        if (ele.length !== 0) {\n                            // existing element should be updated\n                            toMod.push({\n                                ele: ele,\n                                json: json\n                            });\n                        } else {\n                            // otherwise should be added\n                            if (gr) {\n                                json.group = gr;\n                                toAdd.push(json);\n                            } else {\n                                toAdd.push(json);\n                            }\n                        }\n                    }\n                    cy.add(toAdd);\n                    for(var _i = 0; _i < toMod.length; _i++){\n                        var _toMod$_i = toMod[_i], _ele = _toMod$_i.ele, _json = _toMod$_i.json;\n                        _ele.json(_json);\n                    }\n                };\n                if (array(obj.elements)) {\n                    // elements: []\n                    updateEles(obj.elements);\n                } else {\n                    // elements: { nodes: [], edges: [] }\n                    var grs = [\n                        \"nodes\",\n                        \"edges\"\n                    ];\n                    for(var i = 0; i < grs.length; i++){\n                        var gr = grs[i];\n                        var elements = obj.elements[gr];\n                        if (array(elements)) {\n                            updateEles(elements, gr);\n                        }\n                    }\n                }\n                var parentsToRemove = cy.collection();\n                eles.filter(function(ele) {\n                    return !idInJson[ele.id()];\n                }).forEach(function(ele) {\n                    if (ele.isParent()) {\n                        parentsToRemove.merge(ele);\n                    } else {\n                        ele.remove();\n                    }\n                });\n                // so that children are not removed w/parent\n                parentsToRemove.forEach(function(ele) {\n                    return ele.children().move({\n                        parent: null\n                    });\n                });\n                // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n                parentsToRemove.forEach(function(ele) {\n                    return getFreshRef(ele).remove();\n                });\n            }\n            if (obj.style) {\n                cy.style(obj.style);\n            }\n            if (obj.zoom != null && obj.zoom !== _p.zoom) {\n                cy.zoom(obj.zoom);\n            }\n            if (obj.pan) {\n                if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n                    cy.pan(obj.pan);\n                }\n            }\n            if (obj.data) {\n                cy.data(obj.data);\n            }\n            var fields = [\n                \"minZoom\",\n                \"maxZoom\",\n                \"zoomingEnabled\",\n                \"userZoomingEnabled\",\n                \"panningEnabled\",\n                \"userPanningEnabled\",\n                \"boxSelectionEnabled\",\n                \"autolock\",\n                \"autoungrabify\",\n                \"autounselectify\",\n                \"multiClickDebounceTime\"\n            ];\n            for(var _i2 = 0; _i2 < fields.length; _i2++){\n                var f = fields[_i2];\n                if (obj[f] != null) {\n                    cy[f](obj[f]);\n                }\n            }\n            cy.endBatch();\n            return this; // chaining\n        } else {\n            // get\n            var flat = !!obj;\n            var json = {};\n            if (flat) {\n                json.elements = this.elements().map(function(ele) {\n                    return ele.json();\n                });\n            } else {\n                json.elements = {};\n                eles.forEach(function(ele) {\n                    var group = ele.group();\n                    if (!json.elements[group]) {\n                        json.elements[group] = [];\n                    }\n                    json.elements[group].push(ele.json());\n                });\n            }\n            if (this._private.styleEnabled) {\n                json.style = cy.style().json();\n            }\n            json.data = copy(cy.data());\n            var options = _p.options;\n            json.zoomingEnabled = _p.zoomingEnabled;\n            json.userZoomingEnabled = _p.userZoomingEnabled;\n            json.zoom = _p.zoom;\n            json.minZoom = _p.minZoom;\n            json.maxZoom = _p.maxZoom;\n            json.panningEnabled = _p.panningEnabled;\n            json.userPanningEnabled = _p.userPanningEnabled;\n            json.pan = copy(_p.pan);\n            json.boxSelectionEnabled = _p.boxSelectionEnabled;\n            json.renderer = copy(options.renderer);\n            json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n            json.textureOnViewport = options.textureOnViewport;\n            json.wheelSensitivity = options.wheelSensitivity;\n            json.motionBlur = options.motionBlur;\n            json.multiClickDebounceTime = options.multiClickDebounceTime;\n            return json;\n        }\n    }\n});\ncorefn.$id = corefn.getElementById;\n[\n    corefn$9,\n    corefn$8,\n    elesfn,\n    corefn$7,\n    corefn$6,\n    corefn$5,\n    corefn$4,\n    corefn$3,\n    corefn$2,\n    corefn$1,\n    fn\n].forEach(function(props) {\n    extend(corefn, props);\n});\n/* eslint-disable no-unused-vars */ var defaults$7 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    directed: false,\n    // whether the tree is directed downwards (or edges can point in any direction if false)\n    direction: \"downward\",\n    // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.\n    padding: 30,\n    // padding on fit\n    circle: false,\n    // put depths in concentric circles if true, put depths top down if false\n    grid: false,\n    // whether to create an even grid into which the DAG is placed (circle:false only)\n    spacingFactor: 1.75,\n    // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    roots: undefined,\n    // the roots of the trees\n    depthSort: undefined,\n    // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled,\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nvar deprecatedOptionDefaults = {\n    maximal: false,\n    // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n    acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n};\n/* eslint-enable */ var getInfo = function getInfo(ele) {\n    return ele.scratch(\"breadthfirst\");\n};\nvar setInfo = function setInfo(ele, obj) {\n    return ele.scratch(\"breadthfirst\", obj);\n};\nfunction BreadthFirstLayout(options) {\n    this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n}\nBreadthFirstLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().filter(function(n) {\n        return n.isChildless();\n    });\n    var graph = eles;\n    var directed = options.directed;\n    var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n    var hasBoundingBox = !!options.boundingBox;\n    var bb = makeBoundingBox(hasBoundingBox ? options.boundingBox : structuredClone(cy.extent()));\n    var roots;\n    if (elementOrCollection(options.roots)) {\n        roots = options.roots;\n    } else if (array(options.roots)) {\n        var rootsArray = [];\n        for(var i = 0; i < options.roots.length; i++){\n            var id = options.roots[i];\n            var ele = cy.getElementById(id);\n            rootsArray.push(ele);\n        }\n        roots = cy.collection(rootsArray);\n    } else if (string(options.roots)) {\n        roots = cy.$(options.roots);\n    } else {\n        if (directed) {\n            roots = nodes.roots();\n        } else {\n            var components = eles.components();\n            roots = cy.collection();\n            var _loop = function _loop() {\n                var comp = components[_i];\n                var maxDegree = comp.maxDegree(false);\n                var compRoots = comp.filter(function(ele) {\n                    return ele.degree(false) === maxDegree;\n                });\n                roots = roots.add(compRoots);\n            };\n            for(var _i = 0; _i < components.length; _i++){\n                _loop();\n            }\n        }\n    }\n    var depths = [];\n    var foundByBfs = {};\n    var addToDepth = function addToDepth(ele, d) {\n        if (depths[d] == null) {\n            depths[d] = [];\n        }\n        var i = depths[d].length;\n        depths[d].push(ele);\n        setInfo(ele, {\n            index: i,\n            depth: d\n        });\n    };\n    var changeDepth = function changeDepth(ele, newDepth) {\n        var _getInfo = getInfo(ele), depth = _getInfo.depth, index = _getInfo.index;\n        depths[depth][index] = null;\n        // add only childless nodes\n        if (ele.isChildless()) addToDepth(ele, newDepth);\n    };\n    // find the depths of the nodes\n    graph.bfs({\n        roots: roots,\n        directed: options.directed,\n        visit: function visit(node, edge, pNode, i, depth) {\n            var ele = node[0];\n            var id = ele.id();\n            // add only childless nodes\n            if (ele.isChildless()) addToDepth(ele, depth);\n            foundByBfs[id] = true;\n        }\n    });\n    // check for nodes not found by bfs\n    var orphanNodes = [];\n    for(var _i2 = 0; _i2 < nodes.length; _i2++){\n        var _ele = nodes[_i2];\n        if (foundByBfs[_ele.id()]) {\n            continue;\n        } else {\n            orphanNodes.push(_ele);\n        }\n    }\n    // assign the nodes a depth and index\n    var assignDepthsAt = function assignDepthsAt(i) {\n        var eles = depths[i];\n        for(var j = 0; j < eles.length; j++){\n            var _ele2 = eles[j];\n            if (_ele2 == null) {\n                eles.splice(j, 1);\n                j--;\n                continue;\n            }\n            setInfo(_ele2, {\n                depth: i,\n                index: j\n            });\n        }\n    };\n    var adjustMaximally = function adjustMaximally(ele, shifted) {\n        var eInfo = getInfo(ele);\n        var incomers = ele.incomers().filter(function(el) {\n            return el.isNode() && eles.has(el);\n        });\n        var maxDepth = -1;\n        var id = ele.id();\n        for(var k = 0; k < incomers.length; k++){\n            var incmr = incomers[k];\n            var iInfo = getInfo(incmr);\n            maxDepth = Math.max(maxDepth, iInfo.depth);\n        }\n        if (eInfo.depth <= maxDepth) {\n            if (!options.acyclic && shifted[id]) {\n                return null;\n            }\n            var newDepth = maxDepth + 1;\n            changeDepth(ele, newDepth);\n            shifted[id] = newDepth;\n            return true;\n        }\n        return false;\n    };\n    // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n    if (directed && maximal) {\n        var Q = [];\n        var shifted = {};\n        var enqueue = function enqueue(n) {\n            return Q.push(n);\n        };\n        var dequeue = function dequeue() {\n            return Q.shift();\n        };\n        nodes.forEach(function(n) {\n            return Q.push(n);\n        });\n        while(Q.length > 0){\n            var _ele3 = dequeue();\n            var didShift = adjustMaximally(_ele3, shifted);\n            if (didShift) {\n                _ele3.outgoers().filter(function(el) {\n                    return el.isNode() && eles.has(el);\n                }).forEach(enqueue);\n            } else if (didShift === null) {\n                warn(\"Detected double maximal shift for node `\" + _ele3.id() + \"`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.\");\n                break; // exit on failure\n            }\n        }\n    }\n    // find min distance we need to leave between nodes\n    var minDistance = 0;\n    if (options.avoidOverlap) {\n        for(var _i3 = 0; _i3 < nodes.length; _i3++){\n            var n = nodes[_i3];\n            var nbb = n.layoutDimensions(options);\n            var w = nbb.w;\n            var h = nbb.h;\n            minDistance = Math.max(minDistance, w, h);\n        }\n    }\n    // get the weighted percent for an element based on its connectivity to other levels\n    var cachedWeightedPercent = {};\n    var getWeightedPercent = function getWeightedPercent(ele) {\n        if (cachedWeightedPercent[ele.id()]) {\n            return cachedWeightedPercent[ele.id()];\n        }\n        var eleDepth = getInfo(ele).depth;\n        var neighbors = ele.neighborhood();\n        var percent = 0;\n        var samples = 0;\n        for(var _i4 = 0; _i4 < neighbors.length; _i4++){\n            var neighbor = neighbors[_i4];\n            if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n                continue;\n            }\n            var bf = getInfo(neighbor);\n            if (bf == null) {\n                continue;\n            }\n            var index = bf.index;\n            var depth = bf.depth;\n            // unassigned neighbours shouldn't affect the ordering\n            if (index == null || depth == null) {\n                continue;\n            }\n            var nDepth = depths[depth].length;\n            if (depth < eleDepth) {\n                // only get influenced by elements above\n                percent += index / nDepth;\n                samples++;\n            }\n        }\n        samples = Math.max(1, samples);\n        percent = percent / samples;\n        if (samples === 0) {\n            // put lone nodes at the start\n            percent = 0;\n        }\n        cachedWeightedPercent[ele.id()] = percent;\n        return percent;\n    };\n    // rearrange the indices in each depth level based on connectivity\n    var sortFn = function sortFn(a, b) {\n        var apct = getWeightedPercent(a);\n        var bpct = getWeightedPercent(b);\n        var diff = apct - bpct;\n        if (diff === 0) {\n            return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n        } else {\n            return diff;\n        }\n    };\n    if (options.depthSort !== undefined) {\n        sortFn = options.depthSort;\n    }\n    var depthsLen = depths.length;\n    // sort each level to make connected nodes closer\n    for(var _i5 = 0; _i5 < depthsLen; _i5++){\n        depths[_i5].sort(sortFn);\n        assignDepthsAt(_i5);\n    }\n    // assign orphan nodes to a new top-level depth\n    var orphanDepth = [];\n    for(var _i6 = 0; _i6 < orphanNodes.length; _i6++){\n        orphanDepth.push(orphanNodes[_i6]);\n    }\n    var assignDepths = function assignDepths() {\n        for(var _i7 = 0; _i7 < depthsLen; _i7++){\n            assignDepthsAt(_i7);\n        }\n    };\n    // add a new top-level depth only when there are orphan nodes\n    if (orphanDepth.length) {\n        depths.unshift(orphanDepth);\n        depthsLen = depths.length;\n        assignDepths();\n    }\n    var biggestDepthSize = 0;\n    for(var _i8 = 0; _i8 < depthsLen; _i8++){\n        biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n    }\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    // average node size\n    var aveNodeSize = nodes.reduce(function(acc, node) {\n        return function(box) {\n            return {\n                w: acc.w === -1 ? box.w : (acc.w + box.w) / 2,\n                h: acc.h === -1 ? box.h : (acc.h + box.h) / 2\n            };\n        }(node.boundingBox({\n            includeLabels: options.nodeDimensionsIncludeLabels\n        }));\n    }, {\n        w: -1,\n        h: -1\n    });\n    var distanceY = Math.max(// only one depth\n    depthsLen === 1 ? 0 : // inside a bounding box, no need for top & bottom padding\n    hasBoundingBox ? (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen - 1) : (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen + 1), minDistance);\n    var maxDepthSize = depths.reduce(function(max, eles) {\n        return Math.max(max, eles.length);\n    }, 0);\n    var getPositionTopBottom = function getPositionTopBottom(ele) {\n        var _getInfo2 = getInfo(ele), depth = _getInfo2.depth, index = _getInfo2.index;\n        if (options.circle) {\n            var radiusStepSize = Math.min(bb.w / 2 / depthsLen, bb.h / 2 / depthsLen);\n            radiusStepSize = Math.max(radiusStepSize, minDistance);\n            var radius = radiusStepSize * depth + radiusStepSize - (depthsLen > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n            var theta = 2 * Math.PI / depths[depth].length * index;\n            if (depth === 0 && depths[0].length === 1) {\n                radius = 1;\n            }\n            return {\n                x: center.x + radius * Math.cos(theta),\n                y: center.y + radius * Math.sin(theta)\n            };\n        } else {\n            var depthSize = depths[depth].length;\n            var distanceX = Math.max(// only one depth\n            depthSize === 1 ? 0 : // inside a bounding box, no need for left & right padding\n            hasBoundingBox ? (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) - 1) : (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n            var epos = {\n                x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n                y: center.y + (depth + 1 - (depthsLen + 1) / 2) * distanceY\n            };\n            return epos;\n        }\n    };\n    var rotateDegrees = {\n        \"downward\": 0,\n        \"leftward\": 90,\n        \"upward\": 180,\n        \"rightward\": -90\n    };\n    if (Object.keys(rotateDegrees).indexOf(options.direction) === -1) {\n        error(\"Invalid direction '\".concat(options.direction, \"' specified for breadthfirst layout. Valid values are: \").concat(Object.keys(rotateDegrees).join(\", \")));\n    }\n    var getPosition = function getPosition(ele) {\n        return rotatePosAndSkewByBox(getPositionTopBottom(ele), bb, rotateDegrees[options.direction]);\n    };\n    eles.nodes().layoutPositions(this, options, getPosition);\n    return this; // chaining\n};\nvar defaults$6 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox and radius if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    radius: undefined,\n    // the radius of the circle\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction CircleLayout(options) {\n    this.options = extend({}, defaults$6, options);\n}\nCircleLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var nodes = eles.nodes().not(\":parent\");\n    if (options.sort) {\n        nodes = nodes.sort(options.sort);\n    }\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n    var dTheta = sweep / Math.max(1, nodes.length - 1);\n    var r;\n    var minDistance = 0;\n    for(var i = 0; i < nodes.length; i++){\n        var n = nodes[i];\n        var nbb = n.layoutDimensions(options);\n        var w = nbb.w;\n        var h = nbb.h;\n        minDistance = Math.max(minDistance, w, h);\n    }\n    if (number$1(options.radius)) {\n        r = options.radius;\n    } else if (nodes.length <= 1) {\n        r = 0;\n    } else {\n        r = Math.min(bb.h, bb.w) / 2 - minDistance;\n    }\n    // calculate the radius\n    if (nodes.length > 1 && options.avoidOverlap) {\n        // but only if more than one node (can't overlap)\n        minDistance *= 1.75; // just to have some nice spacing\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n        r = Math.max(rMin, r);\n    }\n    var getPos = function getPos(ele, i) {\n        var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n        var rx = r * Math.cos(theta);\n        var ry = r * Math.sin(theta);\n        var pos = {\n            x: center.x + rx,\n            y: center.y + ry\n        };\n        return pos;\n    };\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n};\nvar defaults$5 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    equidistant: false,\n    // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n    minNodeSpacing: 10,\n    // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    height: undefined,\n    // height of layout area (overrides container height)\n    width: undefined,\n    // width of layout area (overrides container width)\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    concentric: function concentric(node) {\n        // returns numeric value for each node, placing higher nodes in levels towards the centre\n        return node.degree();\n    },\n    levelWidth: function levelWidth(nodes) {\n        // the variation of concentric values in each level\n        return nodes.maxDegree() / 4;\n    },\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nfunction ConcentricLayout(options) {\n    this.options = extend({}, defaults$5, options);\n}\nConcentricLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(\":parent\");\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    var nodeValues = []; // { node, value }\n    var maxNodeSize = 0;\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        var value = undefined;\n        // calculate the node value\n        value = options.concentric(node);\n        nodeValues.push({\n            value: value,\n            node: node\n        });\n        // for style mapping\n        node._private.scratch.concentric = value;\n    }\n    // in case we used the `concentric` in style\n    nodes.updateStyle();\n    // calculate max size now based on potentially updated mappers\n    for(var _i = 0; _i < nodes.length; _i++){\n        var _node = nodes[_i];\n        var nbb = _node.layoutDimensions(options);\n        maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n    }\n    // sort node values in descreasing order\n    nodeValues.sort(function(a, b) {\n        return b.value - a.value;\n    });\n    var levelWidth = options.levelWidth(nodes);\n    // put the values into levels\n    var levels = [\n        []\n    ];\n    var currentLevel = levels[0];\n    for(var _i2 = 0; _i2 < nodeValues.length; _i2++){\n        var val = nodeValues[_i2];\n        if (currentLevel.length > 0) {\n            var diff = Math.abs(currentLevel[0].value - val.value);\n            if (diff >= levelWidth) {\n                currentLevel = [];\n                levels.push(currentLevel);\n            }\n        }\n        currentLevel.push(val);\n    }\n    // create positions from levels\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n    if (!options.avoidOverlap) {\n        // then strictly constrain to bb\n        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n        var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n        var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n        minDist = Math.min(minDist, rStep);\n    }\n    // find the metrics for each level\n    var r = 0;\n    for(var _i3 = 0; _i3 < levels.length; _i3++){\n        var level = levels[_i3];\n        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n        // calculate the radius\n        if (level.length > 1 && options.avoidOverlap) {\n            // but only if more than one node (can't overlap)\n            var dcos = Math.cos(dTheta) - Math.cos(0);\n            var dsin = Math.sin(dTheta) - Math.sin(0);\n            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n            r = Math.max(rMin, r);\n        }\n        level.r = r;\n        r += minDist;\n    }\n    if (options.equidistant) {\n        var rDeltaMax = 0;\n        var _r = 0;\n        for(var _i4 = 0; _i4 < levels.length; _i4++){\n            var _level = levels[_i4];\n            var rDelta = _level.r - _r;\n            rDeltaMax = Math.max(rDeltaMax, rDelta);\n        }\n        _r = 0;\n        for(var _i5 = 0; _i5 < levels.length; _i5++){\n            var _level2 = levels[_i5];\n            if (_i5 === 0) {\n                _r = _level2.r;\n            }\n            _level2.r = _r;\n            _r += rDeltaMax;\n        }\n    }\n    // calculate the node positions\n    var pos = {}; // id => position\n    for(var _i6 = 0; _i6 < levels.length; _i6++){\n        var _level3 = levels[_i6];\n        var _dTheta = _level3.dTheta;\n        var _r2 = _level3.r;\n        for(var j = 0; j < _level3.length; j++){\n            var _val = _level3[j];\n            var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n            var p = {\n                x: center.x + _r2 * Math.cos(theta),\n                y: center.y + _r2 * Math.sin(theta)\n            };\n            pos[_val.node.id()] = p;\n        }\n    }\n    // position the nodes\n    eles.nodes().layoutPositions(this, options, function(ele) {\n        var id = ele.id();\n        return pos[id];\n    });\n    return this; // chaining\n};\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/ var DEBUG;\n/**\n * @brief :  default layout options\n */ var defaults$4 = {\n    // Called on `layoutready`\n    ready: function ready() {},\n    // Called on `layoutstop`\n    stop: function stop() {},\n    // Whether to animate while running the layout\n    // true : Animate continuously as the layout is running\n    // false : Just show the end result\n    // 'end' : Animate with the end result, from the initial positions to the end positions\n    animate: true,\n    // Easing of the animation for animate:'end'\n    animationEasing: undefined,\n    // The duration of the animation for animate:'end'\n    animationDuration: undefined,\n    // A function that determines whether the node should be animated\n    // All nodes animated by default on animate enabled\n    // Non-animated nodes are positioned immediately when the layout starts\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // The layout animates only after this many milliseconds for animate:true\n    // (prevents flashing on fast runs)\n    animationThreshold: 250,\n    // Number of iterations between consecutive screen positions update\n    refresh: 20,\n    // Whether to fit the network view after when done\n    fit: true,\n    // Padding on fit\n    padding: 30,\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox: undefined,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    nodeDimensionsIncludeLabels: false,\n    // Randomize the initial positions of the nodes (true) or use existing positions (false)\n    randomize: false,\n    // Extra spacing between components in non-compound graphs\n    componentSpacing: 40,\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion: function nodeRepulsion(node) {\n        return 2048;\n    },\n    // Node repulsion (overlapping) multiplier\n    nodeOverlap: 4,\n    // Ideal edge (non nested) length\n    idealEdgeLength: function idealEdgeLength(edge) {\n        return 32;\n    },\n    // Divisor to compute edge forces\n    edgeElasticity: function edgeElasticity(edge) {\n        return 32;\n    },\n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor: 1.2,\n    // Gravity force (constant)\n    gravity: 1,\n    // Maximum number of iterations to perform\n    numIter: 1000,\n    // Initial temperature (maximum node displacement)\n    initialTemp: 1000,\n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor: 0.99,\n    // Lower temperature threshold (below this point the layout will end)\n    minTemp: 1.0\n};\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */ function CoseLayout(options) {\n    this.options = extend({}, defaults$4, options);\n    this.options.layout = this;\n    // Exclude any edge that has a source or target node that is not in the set of passed-in nodes\n    var nodes = this.options.eles.nodes();\n    var edges = this.options.eles.edges();\n    var notEdges = edges.filter(function(e) {\n        var sourceId = e.source().data(\"id\");\n        var targetId = e.target().data(\"id\");\n        var hasSource = nodes.some(function(n) {\n            return n.data(\"id\") === sourceId;\n        });\n        var hasTarget = nodes.some(function(n) {\n            return n.data(\"id\") === targetId;\n        });\n        return !hasSource || !hasTarget;\n    });\n    this.options.eles = this.options.eles.not(notEdges);\n}\n/**\n * @brief : runs the layout\n */ CoseLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var layout = this;\n    layout.stopped = false;\n    if (options.animate === true || options.animate === false) {\n        layout.emit({\n            type: \"layoutstart\",\n            layout: layout\n        });\n    }\n    // Set DEBUG - Global variable\n    if (true === options.debug) {\n        DEBUG = true;\n    } else {\n        DEBUG = false;\n    }\n    // Initialize layout info\n    var layoutInfo = createLayoutInfo(cy, layout, options);\n    // Show LayoutInfo contents if debugging\n    if (DEBUG) {\n        printLayoutInfo(layoutInfo);\n    }\n    // If required, randomize node positions\n    if (options.randomize) {\n        randomizePositions(layoutInfo);\n    }\n    var startTime = performanceNow();\n    var refresh = function refresh() {\n        refreshPositions(layoutInfo, cy, options);\n        // Fit the graph if necessary\n        if (true === options.fit) {\n            cy.fit(options.padding);\n        }\n    };\n    var mainLoop = function mainLoop(i) {\n        if (layout.stopped || i >= options.numIter) {\n            // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n            return false;\n        }\n        // Do one step in the phisical simulation\n        step(layoutInfo, options);\n        // Update temperature\n        layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n        // logDebug(\"New temperature: \" + layoutInfo.temperature);\n        if (layoutInfo.temperature < options.minTemp) {\n            // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n            return false;\n        }\n        return true;\n    };\n    var done = function done() {\n        if (options.animate === true || options.animate === false) {\n            refresh();\n            // Layout has finished\n            layout.one(\"layoutstop\", options.stop);\n            layout.emit({\n                type: \"layoutstop\",\n                layout: layout\n            });\n        } else {\n            var nodes = options.eles.nodes();\n            var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n            nodes.layoutPositions(layout, options, getScaledPos);\n        }\n    };\n    var i = 0;\n    var loopRet = true;\n    if (options.animate === true) {\n        var _frame = function frame() {\n            var f = 0;\n            while(loopRet && f < options.refresh){\n                loopRet = mainLoop(i);\n                i++;\n                f++;\n            }\n            if (!loopRet) {\n                // it's done\n                separateComponents(layoutInfo, options);\n                done();\n            } else {\n                var now = performanceNow();\n                if (now - startTime >= options.animationThreshold) {\n                    refresh();\n                }\n                requestAnimationFrame(_frame);\n            }\n        };\n        _frame();\n    } else {\n        while(loopRet){\n            loopRet = mainLoop(i);\n            i++;\n        }\n        separateComponents(layoutInfo, options);\n        done();\n    }\n    return this; // chaining\n};\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */ CoseLayout.prototype.stop = function() {\n    this.stopped = true;\n    if (this.thread) {\n        this.thread.stop();\n    }\n    this.emit(\"layoutstop\");\n    return this; // chaining\n};\nCoseLayout.prototype.destroy = function() {\n    if (this.thread) {\n        this.thread.stop();\n    }\n    return this; // chaining\n};\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */ var createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var layoutInfo = {\n        isCompound: cy.hasCompoundNodes(),\n        layoutNodes: [],\n        idToIndex: {},\n        nodeSize: nodes.size(),\n        graphSet: [],\n        indexToGraph: [],\n        layoutEdges: [],\n        edgeSize: edges.size(),\n        temperature: options.initialTemp,\n        clientWidth: bb.w,\n        clientHeight: bb.h,\n        boundingBox: bb\n    };\n    var components = options.eles.components();\n    var id2cmptId = {};\n    for(var i = 0; i < components.length; i++){\n        var component = components[i];\n        for(var j = 0; j < component.length; j++){\n            var node = component[j];\n            id2cmptId[node.id()] = i;\n        }\n    }\n    // Iterate over all nodes, creating layout nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = nodes[i];\n        var nbb = n.layoutDimensions(options);\n        var tempNode = {};\n        tempNode.isLocked = n.locked();\n        tempNode.id = n.data(\"id\");\n        tempNode.parentId = n.data(\"parent\");\n        tempNode.cmptId = id2cmptId[n.id()];\n        tempNode.children = [];\n        tempNode.positionX = n.position(\"x\");\n        tempNode.positionY = n.position(\"y\");\n        tempNode.offsetX = 0;\n        tempNode.offsetY = 0;\n        tempNode.height = nbb.w;\n        tempNode.width = nbb.h;\n        tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n        tempNode.minX = tempNode.positionX - tempNode.width / 2;\n        tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n        tempNode.minY = tempNode.positionY - tempNode.height / 2;\n        tempNode.padLeft = parseFloat(n.style(\"padding\"));\n        tempNode.padRight = parseFloat(n.style(\"padding\"));\n        tempNode.padTop = parseFloat(n.style(\"padding\"));\n        tempNode.padBottom = parseFloat(n.style(\"padding\"));\n        // forces\n        tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;\n        // Add new node\n        layoutInfo.layoutNodes.push(tempNode);\n        // Add entry to id-index map\n        layoutInfo.idToIndex[tempNode.id] = i;\n    }\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n    var end = -1; // Points to the end of the queue\n    var tempGraph = [];\n    // Second pass to add child information and\n    // initialize queue for hierarchical traversal\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        var p_id = n.parentId;\n        // Check if node n has a parent node\n        if (null != p_id) {\n            // Add node Id to parent's list of children\n            layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n        } else {\n            // If a node doesn't have a parent, then it's in the root graph\n            queue[++end] = n.id;\n            tempGraph.push(n.id);\n        }\n    }\n    // Add root graph to graphSet\n    layoutInfo.graphSet.push(tempGraph);\n    // Traverse the graph, level by level,\n    while(start <= end){\n        // Get the node to visit and remove it from queue\n        var node_id = queue[start++];\n        var node_ix = layoutInfo.idToIndex[node_id];\n        var node = layoutInfo.layoutNodes[node_ix];\n        var children = node.children;\n        if (children.length > 0) {\n            // Add children nodes as a new graph to graph set\n            layoutInfo.graphSet.push(children);\n            // Add children to que queue to be visited\n            for(var i = 0; i < children.length; i++){\n                queue[++end] = children[i];\n            }\n        }\n    }\n    // Create indexToGraph map\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        for(var j = 0; j < graph.length; j++){\n            var index = layoutInfo.idToIndex[graph[j]];\n            layoutInfo.indexToGraph[index] = i;\n        }\n    }\n    // Iterate over all edges, creating Layout Edges\n    for(var i = 0; i < layoutInfo.edgeSize; i++){\n        var e = edges[i];\n        var tempEdge = {};\n        tempEdge.id = e.data(\"id\");\n        tempEdge.sourceId = e.data(\"source\");\n        tempEdge.targetId = e.data(\"target\");\n        // Compute ideal length\n        var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n        var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;\n        // Check if it's an inter graph edge\n        var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n        var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n        var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n        var targetGraph = layoutInfo.indexToGraph[targetIx];\n        if (sourceGraph != targetGraph) {\n            // Find lowest common graph ancestor\n            var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n            // Compute sum of node depths, relative to lca graph\n            var lcaGraph = layoutInfo.graphSet[lca];\n            var depth = 0;\n            // Source depth\n            var tempNode = layoutInfo.layoutNodes[sourceIx];\n            while(-1 === lcaGraph.indexOf(tempNode.id)){\n                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                depth++;\n            }\n            // Target depth\n            tempNode = layoutInfo.layoutNodes[targetIx];\n            while(-1 === lcaGraph.indexOf(tempNode.id)){\n                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                depth++;\n            }\n            // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n            //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n            //  \". Depth: \" + depth);\n            // Update idealLength\n            idealLength *= depth * options.nestingFactor;\n        }\n        tempEdge.idealLength = idealLength;\n        tempEdge.elasticity = elasticity;\n        layoutInfo.layoutEdges.push(tempEdge);\n    }\n    // Finally, return layoutInfo object\n    return layoutInfo;\n};\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */ var findLCA = function findLCA(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = _findLCA_aux(node1, node2, 0, layoutInfo);\n    if (2 > res.count) {\n        // If aux function couldn't find the common ancester,\n        // then it is the root graph\n        return 0;\n    } else {\n        return res.graph;\n    }\n};\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancestors (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */ var _findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx];\n    // If both nodes belongs to graphIx\n    if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n        return {\n            count: 2,\n            graph: graphIx\n        };\n    }\n    // Make recursive calls for all subgraphs\n    var c = 0;\n    for(var i = 0; i < graph.length; i++){\n        var nodeId = graph[i];\n        var nodeIx = layoutInfo.idToIndex[nodeId];\n        var children = layoutInfo.layoutNodes[nodeIx].children;\n        // If the node has no child, skip it\n        if (0 === children.length) {\n            continue;\n        }\n        var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n        var result = _findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n        if (0 === result.count) {\n            continue;\n        } else if (1 === result.count) {\n            // One of (node1, node2) is present in this subgraph\n            c++;\n            if (2 === c) {\n                break;\n            }\n        } else {\n            // Both nodes are present in this subgraph\n            return result;\n        }\n    }\n    return {\n        count: c,\n        graph: graphIx\n    };\n};\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */ var printLayoutInfo;\n/**\n * @brief : Randomizes the position of all nodes\n */ var randomizePositions = function randomizePositions(layoutInfo, cy) {\n    var width = layoutInfo.clientWidth;\n    var height = layoutInfo.clientHeight;\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        // No need to randomize compound nodes or locked nodes\n        if (0 === n.children.length && !n.isLocked) {\n            n.positionX = Math.random() * width;\n            n.positionY = Math.random() * height;\n        }\n    }\n};\nvar getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n    var bb = layoutInfo.boundingBox;\n    var coseBB = {\n        x1: Infinity,\n        x2: -Infinity,\n        y1: Infinity,\n        y2: -Infinity\n    };\n    if (options.boundingBox) {\n        nodes.forEach(function(node) {\n            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data(\"id\")]];\n            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n        });\n        coseBB.w = coseBB.x2 - coseBB.x1;\n        coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n    return function(ele, i) {\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data(\"id\")]];\n        if (options.boundingBox) {\n            // then add extra bounding box constraint\n            // Handle single node case where coseBB.w or coseBB.h is 0\n            var pctX = coseBB.w === 0 ? 0.5 : (lnode.positionX - coseBB.x1) / coseBB.w;\n            var pctY = coseBB.h === 0 ? 0.5 : (lnode.positionY - coseBB.y1) / coseBB.h;\n            return {\n                x: bb.x1 + pctX * bb.w,\n                y: bb.y1 + pctY * bb.h\n            };\n        } else {\n            return {\n                x: lnode.positionX,\n                y: lnode.positionY\n            };\n        }\n    };\n};\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */ var refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n    // var s = 'Refreshing positions';\n    // logDebug(s);\n    var layout = options.layout;\n    var nodes = options.eles.nodes();\n    var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n    nodes.positions(getScaledPos);\n    // Trigger layoutReady only on first call\n    if (true !== layoutInfo.ready) {\n        // s = 'Triggering layoutready';\n        // logDebug(s);\n        layoutInfo.ready = true;\n        layout.one(\"layoutready\", options.ready);\n        layout.emit({\n            type: \"layoutready\",\n            layout: this\n        });\n    }\n};\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */ // var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n/**\n * @brief          : Performs one iteration of the physical simulation\n * @arg layoutInfo : LayoutInfo object already initialized\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */ var step = function step(layoutInfo, options, _step) {\n    // var s = \"\\n\\n###############################\";\n    // s += \"\\nSTEP: \" + step;\n    // s += \"\\n###############################\\n\";\n    // logDebug(s);\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, options);\n    // Calculate edge forces\n    calculateEdgeForces(layoutInfo);\n    // Calculate gravity forces\n    calculateGravityForces(layoutInfo, options);\n    // Propagate forces from parent to child\n    propagateForces(layoutInfo);\n    // Update positions based on calculated forces\n    updatePositions(layoutInfo);\n};\n/**\n * @brief : Computes the node repulsion forces\n */ var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    // var s = 'calculateNodeForces';\n    // logDebug(s);\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n        // Now get all the pairs of nodes\n        // Only get each pair once, (A, B) = (B, A)\n        for(var j = 0; j < numNodes; j++){\n            var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n            for(var k = j + 1; k < numNodes; k++){\n                var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n                nodeRepulsion(node1, node2, layoutInfo, options);\n            }\n        }\n    }\n};\nvar randomDistance = function randomDistance(max) {\n    return -1 + 2 * max * Math.random();\n};\n/**\n * @brief : Compute the node repulsion forces between a pair of nodes\n */ var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n    // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n    var cmptId1 = node1.cmptId;\n    var cmptId2 = node2.cmptId;\n    if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n        return;\n    }\n    // Get direction of line connecting both node centers\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    var maxRandDist = 1;\n    // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n    // If both centers are the same, apply a random force\n    if (0 === directionX && 0 === directionY) {\n        directionX = randomDistance(maxRandDist);\n        directionY = randomDistance(maxRandDist);\n    }\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n    if (overlap > 0) {\n        // s += \"\\nNodes DO overlap.\";\n        // s += \"\\nOverlap: \" + overlap;\n        // If nodes overlap, repulsion force is proportional\n        // to the overlap\n        var force = options.nodeOverlap * overlap;\n        // Compute the module and components of the force vector\n        var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n        // s += \"\\nDistance: \" + distance;\n        var forceX = force * directionX / distance;\n        var forceY = force * directionY / distance;\n    } else {\n        // s += \"\\nNodes do NOT overlap.\";\n        // If there's no overlap, force is inversely proportional\n        // to squared distance\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(node1, directionX, directionY);\n        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n        // Use clipping points to compute distance\n        var distanceX = point2.x - point1.x;\n        var distanceY = point2.y - point1.y;\n        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n        var distance = Math.sqrt(distanceSqr);\n        // s += \"\\nDistance: \" + distance;\n        // Compute the module and components of the force vector\n        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n        var forceX = force * distanceX / distance;\n        var forceY = force * distanceY / distance;\n    }\n    // Apply force\n    if (!node1.isLocked) {\n        node1.offsetX -= forceX;\n        node1.offsetY -= forceY;\n    }\n    if (!node2.isLocked) {\n        node2.offsetX += forceX;\n        node2.offsetY += forceY;\n    }\n    // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    // logDebug(s);\n    return;\n};\n/**\n * @brief  : Determines whether two nodes overlap or not\n * @return : Amount of overlapping (0 => no overlap)\n */ var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n    if (dX > 0) {\n        var overlapX = node1.maxX - node2.minX;\n    } else {\n        var overlapX = node2.maxX - node1.minX;\n    }\n    if (dY > 0) {\n        var overlapY = node1.maxY - node2.minY;\n    } else {\n        var overlapY = node2.maxY - node1.minY;\n    }\n    if (overlapX >= 0 && overlapY >= 0) {\n        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n        return 0;\n    }\n};\n/**\n * @brief : Finds the point in which an edge (direction dX, dY) intersects\n *          the rectangular bounding box of it's source/target node\n */ var findClippingPoint = function findClippingPoint(node, dX, dY) {\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height || 1;\n    var W = node.width || 1;\n    var dirSlope = dY / dX;\n    var nodeSlope = H / W;\n    // var s = 'Computing clipping point of node ' + node.id +\n    //   \" . Height:  \" + H + \", Width: \" + W +\n    //   \"\\nDirection \" + dX + \", \" + dY;\n    //\n    // Compute intersection\n    var res = {};\n    // Case: Vertical direction (up)\n    if (0 === dX && 0 < dY) {\n        res.x = X;\n        // s += \"\\nUp direction\";\n        res.y = Y + H / 2;\n        return res;\n    }\n    // Case: Vertical direction (down)\n    if (0 === dX && 0 > dY) {\n        res.x = X;\n        res.y = Y + H / 2;\n        // s += \"\\nDown direction\";\n        return res;\n    }\n    // Case: Intersects the right border\n    if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X + W / 2;\n        res.y = Y + W * dY / 2 / dX;\n        // s += \"\\nRightborder\";\n        return res;\n    }\n    // Case: Intersects the left border\n    if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X - W / 2;\n        res.y = Y - W * dY / 2 / dX;\n        // s += \"\\nLeftborder\";\n        return res;\n    }\n    // Case: Intersects the top border\n    if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X + H * dX / 2 / dY;\n        res.y = Y + H / 2;\n        // s += \"\\nTop border\";\n        return res;\n    }\n    // Case: Intersects the bottom border\n    if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X - H * dX / 2 / dY;\n        res.y = Y - H / 2;\n        // s += \"\\nBottom border\";\n        return res;\n    }\n    // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    // logDebug(s);\n    return res;\n};\n/**\n * @brief : Calculates all edge forces\n */ var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n    // Iterate over all edges\n    for(var i = 0; i < layoutInfo.edgeSize; i++){\n        // Get edge, source & target nodes\n        var edge = layoutInfo.layoutEdges[i];\n        var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n        var source = layoutInfo.layoutNodes[sourceIx];\n        var targetIx = layoutInfo.idToIndex[edge.targetId];\n        var target = layoutInfo.layoutNodes[targetIx];\n        // Get direction of line connecting both node centers\n        var directionX = target.positionX - source.positionX;\n        var directionY = target.positionY - source.positionY;\n        // If both centers are the same, do nothing.\n        // A random force has already been applied as node repulsion\n        if (0 === directionX && 0 === directionY) {\n            continue;\n        }\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(source, directionX, directionY);\n        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n        var lx = point2.x - point1.x;\n        var ly = point2.y - point1.y;\n        var l = Math.sqrt(lx * lx + ly * ly);\n        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n        if (0 !== l) {\n            var forceX = force * lx / l;\n            var forceY = force * ly / l;\n        } else {\n            var forceX = 0;\n            var forceY = 0;\n        }\n        // Add this force to target and source nodes\n        if (!source.isLocked) {\n            source.offsetX += forceX;\n            source.offsetY += forceY;\n        }\n        if (!target.isLocked) {\n            target.offsetX -= forceX;\n            target.offsetY -= forceY;\n        }\n    // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n    // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n    // logDebug(s);\n    }\n};\n/**\n * @brief : Computes gravity forces for all nodes\n */ var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n    if (options.gravity === 0) {\n        return;\n    }\n    var distThreshold = 1;\n    // var s = 'calculateGravityForces';\n    // logDebug(s);\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n        // Compute graph center\n        if (0 === i) {\n            var centerX = layoutInfo.clientHeight / 2;\n            var centerY = layoutInfo.clientWidth / 2;\n        } else {\n            // Get Parent node for this graph, and use its position as center\n            var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n            var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n            var centerX = parent.positionX;\n            var centerY = parent.positionY;\n        }\n        // s = \"Center found at: \" + centerX + \", \" + centerY;\n        // logDebug(s);\n        // Apply force to all nodes in graph\n        for(var j = 0; j < numNodes; j++){\n            var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n            // s = \"Node: \" + node.id;\n            if (node.isLocked) {\n                continue;\n            }\n            var dx = centerX - node.positionX;\n            var dy = centerY - node.positionY;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d > distThreshold) {\n                var fx = options.gravity * dx / d;\n                var fy = options.gravity * dy / d;\n                node.offsetX += fx;\n                node.offsetY += fy;\n            // s += \": Applied force: \" + fx + \", \" + fy;\n            }\n        // logDebug(s);\n        }\n    }\n};\n/**\n * @brief          : This function propagates the existing offsets from\n *                   parent nodes to its descendents.\n * @arg layoutInfo : layoutInfo Object\n * @arg cy         : cytoscape Object\n * @arg options    : Layout options\n */ var propagateForces = function propagateForces(layoutInfo, options) {\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n    var end = -1; // Points to the end of the queue\n    // logDebug('propagateForces');\n    // Start by visiting the nodes in the root graph\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length;\n    // Traverse the graph, level by level,\n    while(start <= end){\n        // Get the node to visit and remove it from queue\n        var nodeId = queue[start++];\n        var nodeIndex = layoutInfo.idToIndex[nodeId];\n        var node = layoutInfo.layoutNodes[nodeIndex];\n        var children = node.children;\n        // We only need to process the node if it's compound\n        if (0 < children.length && !node.isLocked) {\n            var offX = node.offsetX;\n            var offY = node.offsetY;\n            // var s = \"Propagating offset from parent node : \" + node.id +\n            //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n            // s += \"\\n Children: \" + children.toString();\n            // logDebug(s);\n            for(var i = 0; i < children.length; i++){\n                var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n                // Propagate offset\n                childNode.offsetX += offX;\n                childNode.offsetY += offY;\n                // Add children to queue to be visited\n                queue[++end] = children[i];\n            }\n            // Reset parent offsets\n            node.offsetX = 0;\n            node.offsetY = 0;\n        }\n    }\n};\n/**\n * @brief : Updates the layout model positions, based on\n *          the accumulated forces\n */ var updatePositions = function updatePositions(layoutInfo, options) {\n    // var s = 'Updating positions';\n    // logDebug(s);\n    // Reset boundaries for compound nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length) {\n            // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n            n.maxX = undefined;\n            n.minX = undefined;\n            n.maxY = undefined;\n            n.minY = undefined;\n        }\n    }\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length || n.isLocked) {\n            continue;\n        }\n        // s = \"Node: \" + n.id + \" Previous position: (\" +\n        // n.positionX + \", \" + n.positionY + \").\";\n        // Limit displacement in order to improve stability\n        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n        n.positionX += tempForce.x;\n        n.positionY += tempForce.y;\n        n.offsetX = 0;\n        n.offsetY = 0;\n        n.minX = n.positionX - n.width;\n        n.maxX = n.positionX + n.width;\n        n.minY = n.positionY - n.height;\n        n.maxY = n.positionY + n.height;\n        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n        // logDebug(s);\n        // Update ancestry boudaries\n        _updateAncestryBoundaries(n, layoutInfo);\n    }\n    // Update size, position of compund nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length && !n.isLocked) {\n            n.positionX = (n.maxX + n.minX) / 2;\n            n.positionY = (n.maxY + n.minY) / 2;\n            n.width = n.maxX - n.minX;\n            n.height = n.maxY - n.minY;\n        // s = \"Updating position, size of compound node \" + n.id;\n        // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        // logDebug(s);\n        }\n    }\n};\n/**\n * @brief : Limits a force (forceX, forceY) to be not\n *          greater (in modulo) than max.\n 8          Preserves force direction.\n  */ var limitForce = function limitForce(forceX, forceY, max) {\n    // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n    if (force > max) {\n        var res = {\n            x: max * forceX / force,\n            y: max * forceY / force\n        };\n    } else {\n        var res = {\n            x: forceX,\n            y: forceY\n        };\n    }\n    // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    // logDebug(s);\n    return res;\n};\n/**\n * @brief : Function used for keeping track of compound node\n *          sizes, since they should bound all their subnodes.\n */ var _updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n    // var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n    if (null == parentId) {\n        // If there's no parent, we are done\n        // s += \". No parent node.\";\n        // logDebug(s);\n        return;\n    }\n    // Get Parent Node\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false;\n    // MaxX\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n        p.maxX = node.maxX + p.padRight;\n        flag = true;\n    // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    }\n    // MinX\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n        p.minX = node.minX - p.padLeft;\n        flag = true;\n    // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    }\n    // MaxY\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n        p.maxY = node.maxY + p.padBottom;\n        flag = true;\n    // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    }\n    // MinY\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n        p.minY = node.minY - p.padTop;\n        flag = true;\n    // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    }\n    // If updated boundaries, propagate changes upward\n    if (flag) {\n        // logDebug(s);\n        return _updateAncestryBoundaries(p, layoutInfo);\n    }\n    // s += \". No changes in boundaries/position of parent node \" + p.id;\n    // logDebug(s);\n    return;\n};\nvar separateComponents = function separateComponents(layoutInfo, options) {\n    var nodes = layoutInfo.layoutNodes;\n    var components = [];\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        var cid = node.cmptId;\n        var component = components[cid] = components[cid] || [];\n        component.push(node);\n    }\n    var totalA = 0;\n    for(var i = 0; i < components.length; i++){\n        var c = components[i];\n        if (!c) {\n            continue;\n        }\n        c.x1 = Infinity;\n        c.x2 = -Infinity;\n        c.y1 = Infinity;\n        c.y2 = -Infinity;\n        for(var j = 0; j < c.length; j++){\n            var n = c[j];\n            c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n            c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n            c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n            c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n        }\n        c.w = c.x2 - c.x1;\n        c.h = c.y2 - c.y1;\n        totalA += c.w * c.h;\n    }\n    components.sort(function(c1, c2) {\n        return c2.w * c2.h - c1.w * c1.h;\n    });\n    var x = 0;\n    var y = 0;\n    var usedW = 0;\n    var rowH = 0;\n    var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n    for(var i = 0; i < components.length; i++){\n        var c = components[i];\n        if (!c) {\n            continue;\n        }\n        for(var j = 0; j < c.length; j++){\n            var n = c[j];\n            if (!n.isLocked) {\n                n.positionX += x - c.x1;\n                n.positionY += y - c.y1;\n            }\n        }\n        x += c.w + options.componentSpacing;\n        usedW += c.w + options.componentSpacing;\n        rowH = Math.max(rowH, c.h);\n        if (usedW > maxRowW) {\n            y += rowH + options.componentSpacing;\n            x = 0;\n            usedW = 0;\n            rowH = 0;\n        }\n    }\n};\nvar defaults$3 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // padding used on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    avoidOverlapPadding: 10,\n    // extra spacing around nodes when avoidOverlap: true\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    condense: false,\n    // uses all available space on false, uses minimal space on true\n    rows: undefined,\n    // force num of rows in the grid\n    cols: undefined,\n    // force num of columns in the grid\n    position: function position(node) {},\n    // returns { row, col } for element\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction GridLayout(options) {\n    this.options = extend({}, defaults$3, options);\n}\nGridLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(\":parent\");\n    if (options.sort) {\n        nodes = nodes.sort(options.sort);\n    }\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    if (bb.h === 0 || bb.w === 0) {\n        eles.nodes().layoutPositions(this, options, function(ele) {\n            return {\n                x: bb.x1,\n                y: bb.y1\n            };\n        });\n    } else {\n        // width/height * splits^2 = cells where splits is number of times to split width\n        var cells = nodes.size();\n        var splits = Math.sqrt(cells * bb.h / bb.w);\n        var rows = Math.round(splits);\n        var cols = Math.round(bb.w / bb.h * splits);\n        var small = function small(val) {\n            if (val == null) {\n                return Math.min(rows, cols);\n            } else {\n                var min = Math.min(rows, cols);\n                if (min == rows) {\n                    rows = val;\n                } else {\n                    cols = val;\n                }\n            }\n        };\n        var large = function large(val) {\n            if (val == null) {\n                return Math.max(rows, cols);\n            } else {\n                var max = Math.max(rows, cols);\n                if (max == rows) {\n                    rows = val;\n                } else {\n                    cols = val;\n                }\n            }\n        };\n        var oRows = options.rows;\n        var oCols = options.cols != null ? options.cols : options.columns;\n        // if rows or columns were set in options, use those values\n        if (oRows != null && oCols != null) {\n            rows = oRows;\n            cols = oCols;\n        } else if (oRows != null && oCols == null) {\n            rows = oRows;\n            cols = Math.ceil(cells / rows);\n        } else if (oRows == null && oCols != null) {\n            cols = oCols;\n            rows = Math.ceil(cells / cols);\n        } else if (cols * rows > cells) {\n            var sm = small();\n            var lg = large();\n            // reducing the small side takes away the most cells, so try it first\n            if ((sm - 1) * lg >= cells) {\n                small(sm - 1);\n            } else if ((lg - 1) * sm >= cells) {\n                large(lg - 1);\n            }\n        } else {\n            // if rounding was too low, add rows or columns\n            while(cols * rows < cells){\n                var _sm = small();\n                var _lg = large();\n                // try to add to larger side first (adds less in multiplication)\n                if ((_lg + 1) * _sm >= cells) {\n                    large(_lg + 1);\n                } else {\n                    small(_sm + 1);\n                }\n            }\n        }\n        var cellWidth = bb.w / cols;\n        var cellHeight = bb.h / rows;\n        if (options.condense) {\n            cellWidth = 0;\n            cellHeight = 0;\n        }\n        if (options.avoidOverlap) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var pos = node._private.position;\n                if (pos.x == null || pos.y == null) {\n                    // for bb\n                    pos.x = 0;\n                    pos.y = 0;\n                }\n                var nbb = node.layoutDimensions(options);\n                var p = options.avoidOverlapPadding;\n                var w = nbb.w + p;\n                var h = nbb.h + p;\n                cellWidth = Math.max(cellWidth, w);\n                cellHeight = Math.max(cellHeight, h);\n            }\n        }\n        var cellUsed = {}; // e.g. 'c-0-2' => true\n        var used = function used(row, col) {\n            return cellUsed[\"c-\" + row + \"-\" + col] ? true : false;\n        };\n        var use = function use(row, col) {\n            cellUsed[\"c-\" + row + \"-\" + col] = true;\n        };\n        // to keep track of current cell position\n        var row = 0;\n        var col = 0;\n        var moveToNextCell = function moveToNextCell() {\n            col++;\n            if (col >= cols) {\n                col = 0;\n                row++;\n            }\n        };\n        // get a cache of all the manual positions\n        var id2manPos = {};\n        for(var _i = 0; _i < nodes.length; _i++){\n            var _node = nodes[_i];\n            var rcPos = options.position(_node);\n            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n                // must have at least row or col def'd\n                var _pos = {\n                    row: rcPos.row,\n                    col: rcPos.col\n                };\n                if (_pos.col === undefined) {\n                    // find unused col\n                    _pos.col = 0;\n                    while(used(_pos.row, _pos.col)){\n                        _pos.col++;\n                    }\n                } else if (_pos.row === undefined) {\n                    // find unused row\n                    _pos.row = 0;\n                    while(used(_pos.row, _pos.col)){\n                        _pos.row++;\n                    }\n                }\n                id2manPos[_node.id()] = _pos;\n                use(_pos.row, _pos.col);\n            }\n        }\n        var getPos = function getPos(element, i) {\n            var x, y;\n            if (element.locked() || element.isParent()) {\n                return false;\n            }\n            // see if we have a manual position set\n            var rcPos = id2manPos[element.id()];\n            if (rcPos) {\n                x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n                y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n            } else {\n                // otherwise set automatically\n                while(used(row, col)){\n                    moveToNextCell();\n                }\n                x = col * cellWidth + cellWidth / 2 + bb.x1;\n                y = row * cellHeight + cellHeight / 2 + bb.y1;\n                use(row, col);\n                moveToNextCell();\n            }\n            return {\n                x: x,\n                y: y\n            };\n        };\n        nodes.layoutPositions(this, options, getPos);\n    }\n    return this; // chaining\n};\n// default layout options\nvar defaults$2 = {\n    ready: function ready() {},\n    // on layoutready\n    stop: function stop() {} // on layoutstop\n};\n// constructor\n// options : object containing layout options\nfunction NullLayout(options) {\n    this.options = extend({}, defaults$2, options);\n}\n// runs the layout\nNullLayout.prototype.run = function() {\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n    var layout = this;\n    // cy is automatically populated for us in the constructor\n    // (disable eslint for next line as this serves as example layout code to external developers)\n    // eslint-disable-next-line no-unused-vars\n    options.cy;\n    layout.emit(\"layoutstart\");\n    // puts all nodes at (0, 0)\n    // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n    eles.nodes().positions(function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    });\n    // trigger layoutready when each node has had its position set at least once\n    layout.one(\"layoutready\", options.ready);\n    layout.emit(\"layoutready\");\n    // trigger layoutstop when the layout stops (e.g. finishes)\n    layout.one(\"layoutstop\", options.stop);\n    layout.emit(\"layoutstop\");\n    return this; // chaining\n};\n// called on continuous layouts to stop them before they finish\nNullLayout.prototype.stop = function() {\n    return this; // chaining\n};\nvar defaults$1 = {\n    positions: undefined,\n    // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined,\n    // the zoom level to set (prob want fit = false if set)\n    pan: undefined,\n    // the pan level to set (prob want fit = false if set)\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // padding on fit\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nfunction PresetLayout(options) {\n    this.options = extend({}, defaults$1, options);\n}\nPresetLayout.prototype.run = function() {\n    var options = this.options;\n    var eles = options.eles;\n    var nodes = eles.nodes();\n    var posIsFn = fn$6(options.positions);\n    function getPosition(node) {\n        if (options.positions == null) {\n            return copyPosition(node.position());\n        }\n        if (posIsFn) {\n            return options.positions(node);\n        }\n        var pos = options.positions[node._private.data.id];\n        if (pos == null) {\n            return null;\n        }\n        return pos;\n    }\n    nodes.layoutPositions(this, options, function(node, i) {\n        var position = getPosition(node);\n        if (node.locked() || position == null) {\n            return false;\n        }\n        return position;\n    });\n    return this; // chaining\n};\nvar defaults = {\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // fit padding\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction RandomLayout(options) {\n    this.options = extend({}, defaults, options);\n}\nRandomLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var getPos = function getPos(node, i) {\n        return {\n            x: bb.x1 + Math.round(Math.random() * bb.w),\n            y: bb.y1 + Math.round(Math.random() * bb.h)\n        };\n    };\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n};\nvar layout = [\n    {\n        name: \"breadthfirst\",\n        impl: BreadthFirstLayout\n    },\n    {\n        name: \"circle\",\n        impl: CircleLayout\n    },\n    {\n        name: \"concentric\",\n        impl: ConcentricLayout\n    },\n    {\n        name: \"cose\",\n        impl: CoseLayout\n    },\n    {\n        name: \"grid\",\n        impl: GridLayout\n    },\n    {\n        name: \"null\",\n        impl: NullLayout\n    },\n    {\n        name: \"preset\",\n        impl: PresetLayout\n    },\n    {\n        name: \"random\",\n        impl: RandomLayout\n    }\n];\nfunction NullRenderer(options) {\n    this.options = options;\n    this.notifications = 0; // for testing\n}\nvar noop = function noop() {};\nvar throwImgErr = function throwImgErr() {\n    throw new Error(\"A headless instance can not render images\");\n};\nNullRenderer.prototype = {\n    recalculateRenderedStyle: noop,\n    notify: function notify() {\n        this.notifications++;\n    },\n    init: noop,\n    isHeadless: function isHeadless() {\n        return true;\n    },\n    png: throwImgErr,\n    jpg: throwImgErr\n};\nvar BRp$f = {};\nBRp$f.arrowShapeWidth = 0.3;\nBRp$f.registerArrowShapes = function() {\n    var arrowShapes = this.arrowShapes = {};\n    var renderer = this;\n    // Contract for arrow shapes:\n    // 0, 0 is arrow tip\n    // (0, 1) is direction towards node\n    // (1, 0) is right\n    //\n    // functional api:\n    // collide: check x, y in shape\n    // roughCollide: called before collide, no false negatives\n    // draw: draw\n    // spacing: dist(arrowTip, nodeBoundary)\n    // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n    var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n        var x1 = translation.x - size / 2 - padding;\n        var x2 = translation.x + size / 2 + padding;\n        var y1 = translation.y - size / 2 - padding;\n        var y2 = translation.y + size / 2 + padding;\n        var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n        return inside;\n    };\n    var transform = function transform(x, y, size, angle, translation) {\n        var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n        var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n        var xScaled = xRotated * size;\n        var yScaled = yRotated * size;\n        var xTranslated = xScaled + translation.x;\n        var yTranslated = yScaled + translation.y;\n        return {\n            x: xTranslated,\n            y: yTranslated\n        };\n    };\n    var transformPoints = function transformPoints(pts, size, angle, translation) {\n        var retPts = [];\n        for(var i = 0; i < pts.length; i += 2){\n            var x = pts[i];\n            var y = pts[i + 1];\n            retPts.push(transform(x, y, size, angle, translation));\n        }\n        return retPts;\n    };\n    var pointsToArr = function pointsToArr(pts) {\n        var ret = [];\n        for(var i = 0; i < pts.length; i++){\n            var p = pts[i];\n            ret.push(p.x, p.y);\n        }\n        return ret;\n    };\n    var standardGap = function standardGap(edge) {\n        return edge.pstyle(\"width\").pfValue * edge.pstyle(\"arrow-scale\").pfValue * 2;\n    };\n    var defineArrowShape = function defineArrowShape(name, defn) {\n        if (string(defn)) {\n            defn = arrowShapes[defn];\n        }\n        arrowShapes[name] = extend({\n            name: name,\n            points: [\n                -0.15,\n                -0.3,\n                0.15,\n                -0.3,\n                0.15,\n                0.3,\n                -0.15,\n                0.3\n            ],\n            collide: function collide(x, y, size, angle, translation, padding) {\n                var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                var inside = pointInsidePolygonPoints(x, y, points);\n                return inside;\n            },\n            roughCollide: bbCollide,\n            draw: function draw(context, size, angle, translation) {\n                var points = transformPoints(this.points, size, angle, translation);\n                renderer.arrowShapeImpl(\"polygon\")(context, points);\n            },\n            spacing: function spacing(edge) {\n                return 0;\n            },\n            gap: standardGap\n        }, defn);\n    };\n    defineArrowShape(\"none\", {\n        collide: falsify,\n        roughCollide: falsify,\n        draw: noop$1,\n        spacing: zeroify,\n        gap: zeroify\n    });\n    defineArrowShape(\"triangle\", {\n        points: [\n            -0.15,\n            -0.3,\n            0,\n            0,\n            0.15,\n            -0.3\n        ]\n    });\n    defineArrowShape(\"arrow\", \"triangle\");\n    defineArrowShape(\"triangle-backcurve\", {\n        points: arrowShapes[\"triangle\"].points,\n        controlPoint: [\n            0,\n            -0.15\n        ],\n        roughCollide: bbCollide,\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var ptsTrans = transformPoints(this.points, size, angle, translation);\n            var ctrlPt = this.controlPoint;\n            var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n        },\n        gap: function gap(edge) {\n            return standardGap(edge) * 0.8;\n        }\n    });\n    defineArrowShape(\"triangle-tee\", {\n        points: [\n            0,\n            0,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3,\n            0,\n            0\n        ],\n        pointsTee: [\n            -0.15,\n            -0.4,\n            -0.15,\n            -0.5,\n            0.15,\n            -0.5,\n            0.15,\n            -0.4\n        ],\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.points, size, angle, translation);\n            var teePts = transformPoints(this.pointsTee, size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n        }\n    });\n    defineArrowShape(\"circle-triangle\", {\n        radius: 0.15,\n        pointsTr: [\n            0,\n            -0.15,\n            0.15,\n            -0.45,\n            -0.15,\n            -0.45,\n            0,\n            -0.15\n        ],\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var t = translation;\n            var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.pointsTr, size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n        },\n        spacing: function spacing(edge) {\n            return renderer.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.radius;\n        }\n    });\n    defineArrowShape(\"triangle-cross\", {\n        points: [\n            0,\n            0,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3,\n            0,\n            0\n        ],\n        baseCrossLinePts: [\n            -0.15,\n            -0.4,\n            // first half of the rectangle\n            -0.15,\n            -0.4,\n            0.15,\n            -0.4,\n            // second half of the rectangle\n            0.15,\n            -0.4\n        ],\n        crossLinePts: function crossLinePts(size, edgeWidth) {\n            // shift points so that the distance between the cross points matches edge width\n            var p = this.baseCrossLinePts.slice();\n            var shiftFactor = edgeWidth / size;\n            var y0 = 3;\n            var y1 = 5;\n            p[y0] = p[y0] - shiftFactor;\n            p[y1] = p[y1] - shiftFactor;\n            return p;\n        },\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.points, size, angle, translation);\n            var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n        }\n    });\n    defineArrowShape(\"vee\", {\n        points: [\n            -0.15,\n            -0.3,\n            0,\n            0,\n            0.15,\n            -0.3,\n            0,\n            -0.15\n        ],\n        gap: function gap(edge) {\n            return standardGap(edge) * 0.525;\n        }\n    });\n    defineArrowShape(\"circle\", {\n        radius: 0.15,\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var t = translation;\n            var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n        },\n        spacing: function spacing(edge) {\n            return renderer.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.radius;\n        }\n    });\n    defineArrowShape(\"tee\", {\n        points: [\n            -0.15,\n            0,\n            -0.15,\n            -0.1,\n            0.15,\n            -0.1,\n            0.15,\n            0\n        ],\n        spacing: function spacing(edge) {\n            return 1;\n        },\n        gap: function gap(edge) {\n            return 1;\n        }\n    });\n    defineArrowShape(\"square\", {\n        points: [\n            -0.15,\n            0.00,\n            0.15,\n            0.00,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3\n        ]\n    });\n    defineArrowShape(\"diamond\", {\n        points: [\n            -0.15,\n            -0.15,\n            0,\n            -0.3,\n            0.15,\n            -0.15,\n            0,\n            0\n        ],\n        gap: function gap(edge) {\n            return edge.pstyle(\"width\").pfValue * edge.pstyle(\"arrow-scale\").value;\n        }\n    });\n    defineArrowShape(\"chevron\", {\n        points: [\n            0,\n            0,\n            -0.15,\n            -0.15,\n            -0.1,\n            -0.2,\n            0,\n            -0.1,\n            0.1,\n            -0.2,\n            0.15,\n            -0.15\n        ],\n        gap: function gap(edge) {\n            return 0.95 * edge.pstyle(\"width\").pfValue * edge.pstyle(\"arrow-scale\").value;\n        }\n    });\n};\nvar BRp$e = {};\n// Project mouse\nBRp$e.projectIntoViewport = function(clientX, clientY) {\n    var cy = this.cy;\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    var scale = offsets[4];\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n    var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n    return [\n        x,\n        y\n    ];\n};\nBRp$e.findContainerClientCoords = function() {\n    if (this.containerBB) {\n        return this.containerBB;\n    }\n    var container = this.container;\n    var rect = container.getBoundingClientRect();\n    var style = this.cy.window().getComputedStyle(container);\n    var styleValue = function styleValue(name) {\n        return parseFloat(style.getPropertyValue(name));\n    };\n    var padding = {\n        left: styleValue(\"padding-left\"),\n        right: styleValue(\"padding-right\"),\n        top: styleValue(\"padding-top\"),\n        bottom: styleValue(\"padding-bottom\")\n    };\n    var border = {\n        left: styleValue(\"border-left-width\"),\n        right: styleValue(\"border-right-width\"),\n        top: styleValue(\"border-top-width\"),\n        bottom: styleValue(\"border-bottom-width\")\n    };\n    var clientWidth = container.clientWidth;\n    var clientHeight = container.clientHeight;\n    var paddingHor = padding.left + padding.right;\n    var paddingVer = padding.top + padding.bottom;\n    var borderHor = border.left + border.right;\n    var scale = rect.width / (clientWidth + borderHor);\n    var unscaledW = clientWidth - paddingHor;\n    var unscaledH = clientHeight - paddingVer;\n    var left = rect.left + padding.left + border.left;\n    var top = rect.top + padding.top + border.top;\n    return this.containerBB = [\n        left,\n        top,\n        unscaledW,\n        unscaledH,\n        scale\n    ];\n};\nBRp$e.invalidateContainerClientCoordsCache = function() {\n    this.containerBB = null;\n};\nBRp$e.findNearestElement = function(x, y, interactiveElementsOnly, isTouch) {\n    return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n};\nBRp$e.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n    var self1 = this;\n    var r = this;\n    var eles = r.getCachedZSortedEles();\n    var near = []; // 1 node max, 1 edge max\n    var zoom = r.cy.zoom();\n    var hasCompounds = r.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n    var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n    var labelThreshold = (isTouch ? 8 : 2) / zoom;\n    var minSqDist = Infinity;\n    var nearEdge;\n    var nearNode;\n    if (interactiveElementsOnly) {\n        eles = eles.interactive;\n    }\n    function addEle(ele, sqDist) {\n        if (ele.isNode()) {\n            if (nearNode) {\n                return; // can't replace node\n            } else {\n                nearNode = ele;\n                near.push(ele);\n            }\n        }\n        if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n            if (nearEdge) {\n                // then replace existing edge\n                // can replace only if same z-index\n                if (nearEdge.pstyle(\"z-compound-depth\").value === ele.pstyle(\"z-compound-depth\").value && nearEdge.pstyle(\"z-compound-depth\").value === ele.pstyle(\"z-compound-depth\").value) {\n                    for(var i = 0; i < near.length; i++){\n                        if (near[i].isEdge()) {\n                            near[i] = ele;\n                            nearEdge = ele;\n                            minSqDist = sqDist != null ? sqDist : minSqDist;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                near.push(ele);\n                nearEdge = ele;\n                minSqDist = sqDist != null ? sqDist : minSqDist;\n            }\n        }\n    }\n    function checkNode(node) {\n        var width = node.outerWidth() + 2 * nodeThreshold;\n        var height = node.outerHeight() + 2 * nodeThreshold;\n        var hw = width / 2;\n        var hh = height / 2;\n        var pos = node.position();\n        var cornerRadius = node.pstyle(\"corner-radius\").value === \"auto\" ? \"auto\" : node.pstyle(\"corner-radius\").pfValue;\n        var rs = node._private.rscratch;\n        if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n         && pos.y - hh <= y && y <= pos.y + hh // bb check y\n        ) {\n            var shape = r.nodeShapes[self1.getNodeShape(node)];\n            if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y, cornerRadius, rs)) {\n                addEle(node, 0);\n                return true;\n            }\n        }\n    }\n    function checkEdge(edge) {\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        var styleWidth = edge.pstyle(\"width\").pfValue;\n        var scale = edge.pstyle(\"arrow-scale\").value;\n        var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n        var widthSq = width * width;\n        var width2 = width * 2;\n        var src = _p.source;\n        var tgt = _p.target;\n        var sqDist;\n        if (rs.edgeType === \"segments\" || rs.edgeType === \"straight\" || rs.edgeType === \"haystack\") {\n            var pts = rs.allpts;\n            for(var i = 0; i + 3 < pts.length; i += 2){\n                if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n                    addEle(edge, sqDist);\n                    return true;\n                }\n            }\n        } else if (rs.edgeType === \"bezier\" || rs.edgeType === \"multibezier\" || rs.edgeType === \"self\" || rs.edgeType === \"compound\") {\n            var pts = rs.allpts;\n            for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n                if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n                    addEle(edge, sqDist);\n                    return true;\n                }\n            }\n        }\n        // if we're close to the edge but didn't hit it, maybe we hit its arrows\n        var src = src || _p.source;\n        var tgt = tgt || _p.target;\n        var arSize = self1.getArrowWidth(styleWidth, scale);\n        var arrows = [\n            {\n                name: \"source\",\n                x: rs.arrowStartX,\n                y: rs.arrowStartY,\n                angle: rs.srcArrowAngle\n            },\n            {\n                name: \"target\",\n                x: rs.arrowEndX,\n                y: rs.arrowEndY,\n                angle: rs.tgtArrowAngle\n            },\n            {\n                name: \"mid-source\",\n                x: rs.midX,\n                y: rs.midY,\n                angle: rs.midsrcArrowAngle\n            },\n            {\n                name: \"mid-target\",\n                x: rs.midX,\n                y: rs.midY,\n                angle: rs.midtgtArrowAngle\n            }\n        ];\n        for(var i = 0; i < arrows.length; i++){\n            var ar = arrows[i];\n            var shape = r.arrowShapes[edge.pstyle(ar.name + \"-arrow-shape\").value];\n            var edgeWidth = edge.pstyle(\"width\").pfValue;\n            if (shape.roughCollide(x, y, arSize, ar.angle, {\n                x: ar.x,\n                y: ar.y\n            }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n                x: ar.x,\n                y: ar.y\n            }, edgeWidth, edgeThreshold)) {\n                addEle(edge);\n                return true;\n            }\n        }\n        // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n        if (hasCompounds && near.length > 0) {\n            checkNode(src);\n            checkNode(tgt);\n        }\n    }\n    function preprop(obj, name, pre) {\n        return getPrefixedProperty(obj, name, pre);\n    }\n    function checkLabel(ele, prefix) {\n        var _p = ele._private;\n        var th = labelThreshold;\n        var prefixDash;\n        if (prefix) {\n            prefixDash = prefix + \"-\";\n        } else {\n            prefixDash = \"\";\n        }\n        ele.boundingBox();\n        var bb = _p.labelBounds[prefix || \"main\"];\n        var text = ele.pstyle(prefixDash + \"label\").value;\n        var eventsEnabled = ele.pstyle(\"text-events\").strValue === \"yes\";\n        if (!eventsEnabled || !text) {\n            return;\n        }\n        var lx = preprop(_p.rscratch, \"labelX\", prefix);\n        var ly = preprop(_p.rscratch, \"labelY\", prefix);\n        var theta = preprop(_p.rscratch, \"labelAngle\", prefix);\n        var ox = ele.pstyle(prefixDash + \"text-margin-x\").pfValue;\n        var oy = ele.pstyle(prefixDash + \"text-margin-y\").pfValue;\n        var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n        var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n        var ly1 = bb.y1 - th - oy;\n        var ly2 = bb.y2 + th - oy;\n        if (theta) {\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            var rotate = function rotate(x, y) {\n                x = x - lx;\n                y = y - ly;\n                return {\n                    x: x * cos - y * sin + lx,\n                    y: x * sin + y * cos + ly\n                };\n            };\n            var px1y1 = rotate(lx1, ly1);\n            var px1y2 = rotate(lx1, ly2);\n            var px2y1 = rotate(lx2, ly1);\n            var px2y2 = rotate(lx2, ly2);\n            var points = [\n                // with the margin added after the rotation is applied\n                px1y1.x + ox,\n                px1y1.y + oy,\n                px2y1.x + ox,\n                px2y1.y + oy,\n                px2y2.x + ox,\n                px2y2.y + oy,\n                px1y2.x + ox,\n                px1y2.y + oy\n            ];\n            if (pointInsidePolygonPoints(x, y, points)) {\n                addEle(ele);\n                return true;\n            }\n        } else {\n            // do a cheaper bb check\n            if (inBoundingBox(bb, x, y)) {\n                addEle(ele);\n                return true;\n            }\n        }\n    }\n    for(var i = eles.length - 1; i >= 0; i--){\n        // reverse order for precedence\n        var ele = eles[i];\n        if (ele.isNode()) {\n            checkNode(ele) || checkLabel(ele);\n        } else {\n            // then edge\n            checkEdge(ele) || checkLabel(ele) || checkLabel(ele, \"source\") || checkLabel(ele, \"target\");\n        }\n    }\n    return near;\n};\n// 'Give me everything from this box'\nBRp$e.getAllInBox = function(x1, y1, x2, y2) {\n    var eles = this.getCachedZSortedEles().interactive;\n    var zoom = this.cy.zoom();\n    var labelThreshold = 2 / zoom;\n    var box = [];\n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2);\n    x1 = x1c;\n    x2 = x2c;\n    y1 = y1c;\n    y2 = y2c;\n    var boxBb = makeBoundingBox({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    });\n    var selectionBox = [\n        {\n            x: boxBb.x1,\n            y: boxBb.y1\n        },\n        {\n            x: boxBb.x2,\n            y: boxBb.y1\n        },\n        {\n            x: boxBb.x2,\n            y: boxBb.y2\n        },\n        {\n            x: boxBb.x1,\n            y: boxBb.y2\n        }\n    ];\n    var boxEdges = [\n        [\n            selectionBox[0],\n            selectionBox[1]\n        ],\n        [\n            selectionBox[1],\n            selectionBox[2]\n        ],\n        [\n            selectionBox[2],\n            selectionBox[3]\n        ],\n        [\n            selectionBox[3],\n            selectionBox[0]\n        ]\n    ];\n    function preprop(obj, name, pre) {\n        return getPrefixedProperty(obj, name, pre);\n    }\n    function getRotatedLabelBox(ele, prefix) {\n        var _p = ele._private;\n        var th = labelThreshold;\n        var prefixDash = \"\";\n        ele.boundingBox();\n        var bb = _p.labelBounds[\"main\"];\n        // If the bounding box is not available, return null.\n        // This indicates that the label box cannot be calculated, which is consistent\n        // with the expected behavior of this function. Returning null allows the caller\n        // to handle the absence of a bounding box explicitly.\n        if (!bb) {\n            return null;\n        }\n        var lx = preprop(_p.rscratch, \"labelX\", prefix);\n        var ly = preprop(_p.rscratch, \"labelY\", prefix);\n        var theta = preprop(_p.rscratch, \"labelAngle\", prefix);\n        var ox = ele.pstyle(prefixDash + \"text-margin-x\").pfValue;\n        var oy = ele.pstyle(prefixDash + \"text-margin-y\").pfValue;\n        var lx1 = bb.x1 - th - ox;\n        var lx2 = bb.x2 + th - ox;\n        var ly1 = bb.y1 - th - oy;\n        var ly2 = bb.y2 + th - oy;\n        if (theta) {\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            var rotate = function rotate(x, y) {\n                x = x - lx;\n                y = y - ly;\n                return {\n                    x: x * cos - y * sin + lx,\n                    y: x * sin + y * cos + ly\n                };\n            };\n            return [\n                rotate(lx1, ly1),\n                rotate(lx2, ly1),\n                rotate(lx2, ly2),\n                rotate(lx1, ly2)\n            ];\n        } else {\n            return [\n                {\n                    x: lx1,\n                    y: ly1\n                },\n                {\n                    x: lx2,\n                    y: ly1\n                },\n                {\n                    x: lx2,\n                    y: ly2\n                },\n                {\n                    x: lx1,\n                    y: ly2\n                }\n            ];\n        }\n    }\n    function doLinesIntersect(p1, p2, q1, q2) {\n        function ccw(a, b, c) {\n            return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n        }\n        return ccw(p1, q1, q2) !== ccw(p2, q1, q2) && ccw(p1, p2, q1) !== ccw(p1, p2, q2);\n    }\n    for(var e = 0; e < eles.length; e++){\n        var ele = eles[e];\n        if (ele.isNode()) {\n            var node = ele;\n            var textEvents = node.pstyle(\"text-events\").strValue === \"yes\";\n            var nodeBoxSelectMode = node.pstyle(\"box-selection\").strValue;\n            var labelBoxSelectEnabled = node.pstyle(\"box-select-labels\").strValue === \"yes\";\n            if (nodeBoxSelectMode === \"none\") {\n                continue;\n            }\n            var includeLabels = (nodeBoxSelectMode === \"overlap\" || labelBoxSelectEnabled) && textEvents;\n            var nodeBb = node.boundingBox({\n                includeNodes: true,\n                includeEdges: false,\n                includeLabels: includeLabels\n            });\n            if (nodeBoxSelectMode === \"contain\") {\n                var selected = false;\n                if (labelBoxSelectEnabled && textEvents) {\n                    var rotatedLabelBox = getRotatedLabelBox(node);\n                    if (rotatedLabelBox && satPolygonIntersection(rotatedLabelBox, selectionBox)) {\n                        box.push(node);\n                        selected = true;\n                    }\n                }\n                if (!selected && boundingBoxInBoundingBox(boxBb, nodeBb)) {\n                    box.push(node);\n                }\n            } else if (nodeBoxSelectMode === \"overlap\") {\n                if (boundingBoxesIntersect(boxBb, nodeBb)) {\n                    var nodeBodyBb = node.boundingBox({\n                        includeNodes: true,\n                        includeEdges: true,\n                        includeLabels: false,\n                        includeMainLabels: false,\n                        includeSourceLabels: false,\n                        includeTargetLabels: false\n                    });\n                    var nodeBodyCorners = [\n                        {\n                            x: nodeBodyBb.x1,\n                            y: nodeBodyBb.y1\n                        },\n                        {\n                            x: nodeBodyBb.x2,\n                            y: nodeBodyBb.y1\n                        },\n                        {\n                            x: nodeBodyBb.x2,\n                            y: nodeBodyBb.y2\n                        },\n                        {\n                            x: nodeBodyBb.x1,\n                            y: nodeBodyBb.y2\n                        }\n                    ];\n                    // if node body intersects, no need to check label\n                    if (satPolygonIntersection(nodeBodyCorners, selectionBox)) {\n                        box.push(node);\n                    } else {\n                        // only check label if node body didn't intersect\n                        var _rotatedLabelBox = getRotatedLabelBox(node);\n                        if (_rotatedLabelBox && satPolygonIntersection(_rotatedLabelBox, selectionBox)) {\n                            box.push(node);\n                        }\n                    }\n                }\n            }\n        } else {\n            var edge = ele;\n            var _p = edge._private;\n            var rs = _p.rscratch;\n            var edgeBoxSelectMode = edge.pstyle(\"box-selection\").strValue;\n            if (edgeBoxSelectMode === \"none\") {\n                continue;\n            }\n            if (edgeBoxSelectMode === \"contain\") {\n                if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n                    continue;\n                }\n                if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n                    continue;\n                }\n                if (rs.edgeType === \"bezier\" || rs.edgeType === \"multibezier\" || rs.edgeType === \"self\" || rs.edgeType === \"compound\" || rs.edgeType === \"segments\" || rs.edgeType === \"haystack\") {\n                    var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    var allInside = true;\n                    for(var i = 0; i < pts.length; i++){\n                        if (!pointInBoundingBox(boxBb, pts[i])) {\n                            allInside = false;\n                            break;\n                        }\n                    }\n                    if (allInside) {\n                        box.push(edge);\n                    }\n                } else if (rs.edgeType === \"straight\") {\n                    box.push(edge);\n                }\n            } else if (edgeBoxSelectMode === \"overlap\") {\n                var _selected = false;\n                // Check: either endpoint inside box\n                if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null && (inBoundingBox(boxBb, rs.startX, rs.startY) || inBoundingBox(boxBb, rs.endX, rs.endY))) {\n                    box.push(edge);\n                    _selected = true;\n                } else if (!_selected && rs.edgeType === \"haystack\") {\n                    var haystackPts = _p.rstyle.haystackPts;\n                    for(var _i = 0; _i < haystackPts.length; _i++){\n                        if (pointInBoundingBox(boxBb, haystackPts[_i])) {\n                            box.push(edge);\n                            _selected = true;\n                            break;\n                        }\n                    }\n                }\n                // Segment intersection check (only if not already selected)\n                if (!_selected) {\n                    var _pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    // straight edges\n                    if ((!_pts || _pts.length < 2) && rs.edgeType === \"straight\") {\n                        if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null) {\n                            _pts = [\n                                {\n                                    x: rs.startX,\n                                    y: rs.startY\n                                },\n                                {\n                                    x: rs.endX,\n                                    y: rs.endY\n                                }\n                            ];\n                        }\n                    }\n                    if (!_pts || _pts.length < 2) continue;\n                    for(var _i2 = 0; _i2 < _pts.length - 1; _i2++){\n                        var segStart = _pts[_i2];\n                        var segEnd = _pts[_i2 + 1];\n                        for(var b = 0; b < boxEdges.length; b++){\n                            var _boxEdges$b = _slicedToArray(boxEdges[b], 2), boxStart = _boxEdges$b[0], boxEnd = _boxEdges$b[1];\n                            if (doLinesIntersect(segStart, segEnd, boxStart, boxEnd)) {\n                                box.push(edge);\n                                _selected = true;\n                                break;\n                            }\n                        }\n                        if (_selected) break;\n                    }\n                }\n            }\n        }\n    }\n    return box;\n};\nvar BRp$d = {};\nBRp$d.calculateArrowAngles = function(edge) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === \"haystack\";\n    var isBezier = rs.edgeType === \"bezier\";\n    var isMultibezier = rs.edgeType === \"multibezier\";\n    var isSegments = rs.edgeType === \"segments\";\n    var isCompound = rs.edgeType === \"compound\";\n    var isSelf = rs.edgeType === \"self\";\n    // Displacement gives direction for arrowhead orientation\n    var dispX, dispY;\n    var startX, startY, endX, endY, midX, midY;\n    if (isHaystack) {\n        startX = rs.haystackPts[0];\n        startY = rs.haystackPts[1];\n        endX = rs.haystackPts[2];\n        endY = rs.haystackPts[3];\n    } else {\n        startX = rs.arrowStartX;\n        startY = rs.arrowStartY;\n        endX = rs.arrowEndX;\n        endY = rs.arrowEndY;\n    }\n    midX = rs.midX;\n    midY = rs.midY;\n    // source\n    //\n    if (isSegments) {\n        dispX = startX - rs.segpts[0];\n        dispY = startY - rs.segpts[1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n        var pts = rs.allpts;\n        var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n        var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n        dispX = startX - bX;\n        dispY = startY - bY;\n    } else {\n        dispX = startX - midX;\n        dispY = startY - midY;\n    }\n    rs.srcArrowAngle = getAngleFromDisp(dispX, dispY);\n    // mid target\n    //\n    var midX = rs.midX;\n    var midY = rs.midY;\n    if (isHaystack) {\n        midX = (startX + endX) / 2;\n        midY = (startY + endY) / 2;\n    }\n    dispX = endX - startX;\n    dispY = endY - startY;\n    if (isSegments) {\n        var pts = rs.allpts;\n        if (pts.length / 2 % 2 === 0) {\n            var i2 = pts.length / 2;\n            var i1 = i2 - 2;\n            dispX = pts[i2] - pts[i1];\n            dispY = pts[i2 + 1] - pts[i1 + 1];\n        } else if (rs.isRound) {\n            dispX = rs.midVector[1];\n            dispY = -rs.midVector[0];\n        } else {\n            var i2 = pts.length / 2 - 1;\n            var i1 = i2 - 2;\n            dispX = pts[i2] - pts[i1];\n            dispY = pts[i2 + 1] - pts[i1 + 1];\n        }\n    } else if (isMultibezier || isCompound || isSelf) {\n        var pts = rs.allpts;\n        var cpts = rs.ctrlpts;\n        var bp0x, bp0y;\n        var bp1x, bp1y;\n        if (cpts.length / 2 % 2 === 0) {\n            var p0 = pts.length / 2 - 1; // startpt\n            var ic = p0 + 2;\n            var p1 = ic + 2;\n            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n        } else {\n            var ic = pts.length / 2 - 1; // ctrpt\n            var p0 = ic - 2; // startpt\n            var p1 = ic + 2; // endpt\n            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n        }\n        dispX = bp1x - bp0x;\n        dispY = bp1y - bp0y;\n    }\n    rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n    rs.midDispX = dispX;\n    rs.midDispY = dispY;\n    // mid source\n    //\n    dispX *= -1;\n    dispY *= -1;\n    if (isSegments) {\n        var pts = rs.allpts;\n        if (pts.length / 2 % 2 === 0) ;\n        else if (!rs.isRound) {\n            var i2 = pts.length / 2 - 1;\n            var i3 = i2 + 2;\n            dispX = -(pts[i3] - pts[i2]);\n            dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n        }\n    }\n    rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY);\n    // target\n    //\n    if (isSegments) {\n        dispX = endX - rs.segpts[rs.segpts.length - 2];\n        dispY = endY - rs.segpts[rs.segpts.length - 1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n        var pts = rs.allpts;\n        var l = pts.length;\n        var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n        var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n        dispX = endX - bX;\n        dispY = endY - bY;\n    } else {\n        dispX = endX - midX;\n        dispY = endY - midY;\n    }\n    rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n};\nBRp$d.getArrowWidth = BRp$d.getArrowHeight = function(edgeWidth, scale) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n    var cachedVal = cache[edgeWidth + \", \" + scale];\n    if (cachedVal) {\n        return cachedVal;\n    }\n    cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n    cache[edgeWidth + \", \" + scale] = cachedVal;\n    return cachedVal;\n};\n/**\n * Explained by Blindman67 at https://stackoverflow.com/a/44856925/11028828\n */ // Declare reused variable to avoid reallocating variables every time the function is called\nvar x, y, v1 = {}, v2 = {}, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut, radius, limit;\nvar startX, startY, stopX, stopY;\nvar lastPoint;\n// convert 2 points into vector form, polar form, and normalised\nvar asVec = function asVec(p, pp, v) {\n    v.x = pp.x - p.x;\n    v.y = pp.y - p.y;\n    v.len = Math.sqrt(v.x * v.x + v.y * v.y);\n    v.nx = v.x / v.len;\n    v.ny = v.y / v.len;\n    v.ang = Math.atan2(v.ny, v.nx);\n};\nvar invertVec = function invertVec(originalV, invertedV) {\n    invertedV.x = originalV.x * -1;\n    invertedV.y = originalV.y * -1;\n    invertedV.nx = originalV.nx * -1;\n    invertedV.ny = originalV.ny * -1;\n    invertedV.ang = originalV.ang > 0 ? -(Math.PI - originalV.ang) : Math.PI + originalV.ang;\n};\nvar calcCornerArc = function calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius) {\n    //-----------------------------------------\n    // Part 1\n    previousPoint !== lastPoint ? asVec(currentPoint, previousPoint, v1) : invertVec(v2, v1); // Avoid recalculating vec if it is the invert of the last one calculated\n    asVec(currentPoint, nextPoint, v2);\n    sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n    sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n    angle = Math.asin(Math.max(-1, Math.min(1, sinA)));\n    if (Math.abs(angle) < 1e-6) {\n        x = currentPoint.x;\n        y = currentPoint.y;\n        cRadius = radius = 0;\n        return;\n    }\n    //-----------------------------------------\n    radDirection = 1;\n    drawDirection = false;\n    if (sinA90 < 0) {\n        if (angle < 0) {\n            angle = Math.PI + angle;\n        } else {\n            angle = Math.PI - angle;\n            radDirection = -1;\n            drawDirection = true;\n        }\n    } else {\n        if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n    }\n    if (currentPoint.radius !== undefined) {\n        radius = currentPoint.radius;\n    } else {\n        radius = radiusMax;\n    }\n    //-----------------------------------------\n    // Part 2\n    halfAngle = angle / 2;\n    //-----------------------------------------\n    limit = Math.min(v1.len / 2, v2.len / 2);\n    if (isArcRadius) {\n        //-----------------------------------------\n        // Part 3\n        lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));\n        //-----------------------------------------\n        // Special part A\n        if (lenOut > limit) {\n            lenOut = limit;\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else {\n            cRadius = radius;\n        }\n    } else {\n        lenOut = Math.min(limit, radius);\n        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    }\n    //-----------------------------------------\n    //-----------------------------------------\n    // Part 4\n    stopX = currentPoint.x + v2.nx * lenOut;\n    stopY = currentPoint.y + v2.ny * lenOut;\n    //-----------------------------------------\n    // Part 5\n    x = stopX - v2.ny * cRadius * radDirection;\n    y = stopY + v2.nx * cRadius * radDirection;\n    //-----------------------------------------\n    // Additional Part : calculate start point E\n    startX = currentPoint.x + v1.nx * lenOut;\n    startY = currentPoint.y + v1.ny * lenOut;\n    // Save last point to avoid recalculating vector when not needed\n    lastPoint = currentPoint;\n};\n/**\n * Draw corner provided by {@link getRoundCorner}\n *\n * @param ctx :CanvasRenderingContext2D\n * @param roundCorner {{cx:number, cy:number, radius:number, endAngle: number, startAngle: number, counterClockwise: boolean}}\n */ function drawPreparedRoundCorner(ctx, roundCorner) {\n    if (roundCorner.radius === 0) ctx.lineTo(roundCorner.cx, roundCorner.cy);\n    else ctx.arc(roundCorner.cx, roundCorner.cy, roundCorner.radius, roundCorner.startAngle, roundCorner.endAngle, roundCorner.counterClockwise);\n}\n/**\n * Get round corner from a point and its previous and next neighbours in a path\n *\n * @param previousPoint {{x: number, y:number, radius: number?}}\n * @param currentPoint {{x: number, y:number, radius: number?}}\n * @param nextPoint {{x: number, y:number, radius: number?}}\n * @param radiusMax :number\n * @param isArcRadius :boolean\n * @return {{\n * cx:number, cy:number, radius:number,\n * startX:number, startY:number,\n * stopX:number, stopY: number,\n * endAngle: number, startAngle: number, counterClockwise: boolean\n * }}\n */ function getRoundCorner(previousPoint, currentPoint, nextPoint, radiusMax) {\n    var isArcRadius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    if (radiusMax === 0 || currentPoint.radius === 0) return {\n        cx: currentPoint.x,\n        cy: currentPoint.y,\n        radius: 0,\n        startX: currentPoint.x,\n        startY: currentPoint.y,\n        stopX: currentPoint.x,\n        stopY: currentPoint.y,\n        startAngle: undefined,\n        endAngle: undefined,\n        counterClockwise: undefined\n    };\n    calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius);\n    return {\n        cx: x,\n        cy: y,\n        radius: cRadius,\n        startX: startX,\n        startY: startY,\n        stopX: stopX,\n        stopY: stopY,\n        startAngle: v1.ang + Math.PI / 2 * radDirection,\n        endAngle: v2.ang - Math.PI / 2 * radDirection,\n        counterClockwise: drawDirection\n    };\n}\nvar AVOID_IMPOSSIBLE_BEZIER_CONSTANT = 0.01;\nvar AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L = Math.sqrt(2 * AVOID_IMPOSSIBLE_BEZIER_CONSTANT);\nvar BRp$c = {};\nBRp$c.findMidptPtsEtc = function(edge, pairInfo) {\n    var posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts, vectorNormInverse = pairInfo.vectorNormInverse;\n    var midptPts;\n    // n.b. assumes all edges in bezier bundle have same endpoints specified\n    var srcManEndpt = edge.pstyle(\"source-endpoint\");\n    var tgtManEndpt = edge.pstyle(\"target-endpoint\");\n    var haveManualEndPts = srcManEndpt.units != null && tgtManEndpt.units != null;\n    var recalcVectorNormInverse = function recalcVectorNormInverse(x1, y1, x2, y2) {\n        var dy = y2 - y1;\n        var dx = x2 - x1;\n        var l = Math.sqrt(dx * dx + dy * dy);\n        return {\n            x: -dy / l,\n            y: dx / l\n        };\n    };\n    var edgeDistances = edge.pstyle(\"edge-distances\").value;\n    switch(edgeDistances){\n        case \"node-position\":\n            midptPts = posPts;\n            break;\n        case \"intersection\":\n            midptPts = intersectionPts;\n            break;\n        case \"endpoints\":\n            {\n                if (haveManualEndPts) {\n                    var _this$manualEndptToPx = this.manualEndptToPx(edge.source()[0], srcManEndpt), _this$manualEndptToPx2 = _slicedToArray(_this$manualEndptToPx, 2), x1 = _this$manualEndptToPx2[0], y1 = _this$manualEndptToPx2[1];\n                    var _this$manualEndptToPx3 = this.manualEndptToPx(edge.target()[0], tgtManEndpt), _this$manualEndptToPx4 = _slicedToArray(_this$manualEndptToPx3, 2), x2 = _this$manualEndptToPx4[0], y2 = _this$manualEndptToPx4[1];\n                    var endPts = {\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2\n                    };\n                    vectorNormInverse = recalcVectorNormInverse(x1, y1, x2, y2);\n                    midptPts = endPts;\n                } else {\n                    warn(\"Edge \".concat(edge.id(), \" has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).\"));\n                    midptPts = intersectionPts; // back to default\n                }\n                break;\n            }\n    }\n    return {\n        midptPts: midptPts,\n        vectorNormInverse: vectorNormInverse\n    };\n};\nBRp$c.findHaystackPoints = function(edges) {\n    for(var i = 0; i < edges.length; i++){\n        var edge = edges[i];\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        if (!rs.haystack) {\n            var angle = Math.random() * 2 * Math.PI;\n            rs.source = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n            angle = Math.random() * 2 * Math.PI;\n            rs.target = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n        }\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcPos = src.position();\n        var tgtPos = tgt.position();\n        var srcW = src.width();\n        var tgtW = tgt.width();\n        var srcH = src.height();\n        var tgtH = tgt.height();\n        var radius = edge.pstyle(\"haystack-radius\").value;\n        var halfRadius = radius / 2; // b/c have to half width/height\n        rs.haystackPts = rs.allpts = [\n            rs.source.x * srcW * halfRadius + srcPos.x,\n            rs.source.y * srcH * halfRadius + srcPos.y,\n            rs.target.x * tgtW * halfRadius + tgtPos.x,\n            rs.target.y * tgtH * halfRadius + tgtPos.y\n        ];\n        rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n        rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n        // always override as haystack in case set to different type previously\n        rs.edgeType = \"haystack\";\n        rs.haystack = true;\n        this.storeEdgeProjections(edge);\n        this.calculateArrowAngles(edge);\n        this.recalculateEdgeLabelProjections(edge);\n        this.calculateLabelAngles(edge);\n    }\n};\nBRp$c.findSegmentsPoints = function(edge, pairInfo) {\n    // Segments (multiple straight lines)\n    var rs = edge._private.rscratch;\n    var segmentWs = edge.pstyle(\"segment-weights\");\n    var segmentDs = edge.pstyle(\"segment-distances\");\n    var segmentRs = edge.pstyle(\"segment-radii\");\n    var segmentTs = edge.pstyle(\"radius-type\");\n    var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n    var lastRadius = segmentRs.pfValue[segmentRs.pfValue.length - 1];\n    var lastRadiusType = segmentTs.pfValue[segmentTs.pfValue.length - 1];\n    rs.edgeType = \"segments\";\n    rs.segpts = [];\n    rs.radii = [];\n    rs.isArcRadius = [];\n    for(var s = 0; s < segmentsN; s++){\n        var w = segmentWs.pfValue[s];\n        var d = segmentDs.pfValue[s];\n        var w1 = 1 - w;\n        var w2 = w;\n        var _this$findMidptPtsEtc = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc.midptPts, vectorNormInverse = _this$findMidptPtsEtc.vectorNormInverse;\n        var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n        };\n        rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n        rs.radii.push(segmentRs.pfValue[s] !== undefined ? segmentRs.pfValue[s] : lastRadius);\n        rs.isArcRadius.push((segmentTs.pfValue[s] !== undefined ? segmentTs.pfValue[s] : lastRadiusType) === \"arc-radius\");\n    }\n};\nBRp$c.findLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n    // Self-edge\n    var rs = edge._private.rscratch;\n    var dirCounts = pairInfo.dirCounts, srcPos = pairInfo.srcPos;\n    var ctrlptDists = edge.pstyle(\"control-point-distances\");\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var loopDir = edge.pstyle(\"loop-direction\").pfValue;\n    var loopSwp = edge.pstyle(\"loop-sweep\").pfValue;\n    var stepSize = edge.pstyle(\"control-point-step-size\").pfValue;\n    rs.edgeType = \"self\";\n    var j = i;\n    var loopDist = stepSize;\n    if (edgeIsUnbundled) {\n        j = 0;\n        loopDist = ctrlptDist;\n    }\n    var loopAngle = loopDir - Math.PI / 2;\n    var outAngle = loopAngle - loopSwp / 2;\n    var inAngle = loopAngle + loopSwp / 2;\n    // increase by step size for overlapping loops, keyed on direction and sweep values\n    var dc = String(loopDir + \"_\" + loopSwp);\n    j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n    rs.ctrlpts = [\n        srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)\n    ];\n};\nBRp$c.findCompoundLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n    // Compound edge\n    var rs = edge._private.rscratch;\n    rs.edgeType = \"compound\";\n    var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n    var stepSize = edge.pstyle(\"control-point-step-size\").pfValue;\n    var ctrlptDists = edge.pstyle(\"control-point-distances\");\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var j = i;\n    var loopDist = stepSize;\n    if (edgeIsUnbundled) {\n        j = 0;\n        loopDist = ctrlptDist;\n    }\n    var loopW = 50;\n    var loopaPos = {\n        x: srcPos.x - srcW / 2,\n        y: srcPos.y - srcH / 2\n    };\n    var loopbPos = {\n        x: tgtPos.x - tgtW / 2,\n        y: tgtPos.y - tgtH / 2\n    };\n    var loopPos = {\n        x: Math.min(loopaPos.x, loopbPos.x),\n        y: Math.min(loopaPos.y, loopbPos.y)\n    };\n    // avoids cases with impossible beziers\n    var minCompoundStretch = 0.5;\n    var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n    var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n    rs.ctrlpts = [\n        loopPos.x,\n        loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,\n        loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,\n        loopPos.y\n    ];\n};\nBRp$c.findStraightEdgePoints = function(edge) {\n    // Straight edge within bundle\n    edge._private.rscratch.edgeType = \"straight\";\n};\nBRp$c.findBezierPoints = function(edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n    var rs = edge._private.rscratch;\n    var stepSize = edge.pstyle(\"control-point-step-size\").pfValue;\n    var ctrlptDists = edge.pstyle(\"control-point-distances\");\n    var ctrlptWs = edge.pstyle(\"control-point-weights\");\n    var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var ctrlptWeight = ctrlptWs.value[0];\n    // (Multi)bezier\n    var multi = edgeIsUnbundled;\n    rs.edgeType = multi ? \"multibezier\" : \"bezier\";\n    rs.ctrlpts = [];\n    for(var b = 0; b < bezierN; b++){\n        var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n        var manctrlptDist = undefined;\n        var sign = signum(normctrlptDist);\n        if (multi) {\n            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n            ctrlptWeight = ctrlptWs.value[b];\n        }\n        if (edgeIsUnbundled) {\n            // multi or single unbundled\n            manctrlptDist = ctrlptDist;\n        } else {\n            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n        }\n        var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n        var w1 = 1 - ctrlptWeight;\n        var w2 = ctrlptWeight;\n        var _this$findMidptPtsEtc2 = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc2.midptPts, vectorNormInverse = _this$findMidptPtsEtc2.vectorNormInverse;\n        var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n        };\n        rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n    }\n};\nBRp$c.findTaxiPoints = function(edge, pairInfo) {\n    // Taxicab geometry with two turns maximum\n    var rs = edge._private.rscratch;\n    rs.edgeType = \"segments\";\n    var VERTICAL = \"vertical\";\n    var HORIZONTAL = \"horizontal\";\n    var LEFTWARD = \"leftward\";\n    var RIGHTWARD = \"rightward\";\n    var DOWNWARD = \"downward\";\n    var UPWARD = \"upward\";\n    var AUTO = \"auto\";\n    var posPts = pairInfo.posPts, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n    var edgeDistances = edge.pstyle(\"edge-distances\").value;\n    var dIncludesNodeBody = edgeDistances !== \"node-position\";\n    var taxiDir = edge.pstyle(\"taxi-direction\").value;\n    var rawTaxiDir = taxiDir; // unprocessed value\n    var taxiTurn = edge.pstyle(\"taxi-turn\");\n    var turnIsPercent = taxiTurn.units === \"%\";\n    var taxiTurnPfVal = taxiTurn.pfValue;\n    var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n    var minD = edge.pstyle(\"taxi-turn-min-distance\").pfValue;\n    var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n    var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n    var pdx = posPts.x2 - posPts.x1;\n    var pdy = posPts.y2 - posPts.y1;\n    // take away the effective w/h from the magnitude of the delta value\n    var subDWH = function subDWH(dxy, dwh) {\n        if (dxy > 0) {\n            return Math.max(dxy - dwh, 0);\n        } else {\n            return Math.min(dxy + dwh, 0);\n        }\n    };\n    var dx = subDWH(pdx, dw);\n    var dy = subDWH(pdy, dh);\n    var isExplicitDir = false;\n    if (rawTaxiDir === AUTO) {\n        taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n    } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n        taxiDir = VERTICAL;\n        isExplicitDir = true;\n    } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n        taxiDir = HORIZONTAL;\n        isExplicitDir = true;\n    }\n    var isVert = taxiDir === VERTICAL;\n    var l = isVert ? dy : dx;\n    var pl = isVert ? pdy : pdx;\n    var sgnL = signum(pl);\n    var forcedDir = false;\n    if (!(isExplicitDir && (turnIsPercent || turnIsNegative) // forcing in this case would cause weird growing in the opposite direction\n    ) && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n        sgnL *= -1;\n        l = sgnL * Math.abs(l);\n        forcedDir = true;\n    }\n    var d;\n    if (turnIsPercent) {\n        var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n        d = p * l;\n    } else {\n        var k = taxiTurnPfVal < 0 ? l : 0;\n        d = k + taxiTurnPfVal * sgnL;\n    }\n    var getIsTooClose = function getIsTooClose(d) {\n        return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n    };\n    var isTooCloseSrc = getIsTooClose(d);\n    var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n    var isTooClose = isTooCloseSrc || isTooCloseTgt;\n    if (isTooClose && !forcedDir) {\n        // non-ideal routing\n        if (isVert) {\n            // vertical fallbacks\n            var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n            var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n            if (lShapeInsideSrc) {\n                // horizontal Z-shape (direction not respected)\n                var x = (posPts.x1 + posPts.x2) / 2;\n                var y1 = posPts.y1, y2 = posPts.y2;\n                rs.segpts = [\n                    x,\n                    y1,\n                    x,\n                    y2\n                ];\n            } else if (lShapeInsideTgt) {\n                // vertical Z-shape (distance not respected)\n                var y = (posPts.y1 + posPts.y2) / 2;\n                var x1 = posPts.x1, x2 = posPts.x2;\n                rs.segpts = [\n                    x1,\n                    y,\n                    x2,\n                    y\n                ];\n            } else {\n                // L-shape fallback (turn distance not respected, but works well with tree siblings)\n                rs.segpts = [\n                    posPts.x1,\n                    posPts.y2\n                ];\n            }\n        } else {\n            // horizontal fallbacks\n            var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n            var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n            if (_lShapeInsideSrc) {\n                // vertical Z-shape (direction not respected)\n                var _y = (posPts.y1 + posPts.y2) / 2;\n                var _x = posPts.x1, _x2 = posPts.x2;\n                rs.segpts = [\n                    _x,\n                    _y,\n                    _x2,\n                    _y\n                ];\n            } else if (_lShapeInsideTgt) {\n                // horizontal Z-shape (turn distance not respected)\n                var _x3 = (posPts.x1 + posPts.x2) / 2;\n                var _y2 = posPts.y1, _y3 = posPts.y2;\n                rs.segpts = [\n                    _x3,\n                    _y2,\n                    _x3,\n                    _y3\n                ];\n            } else {\n                // L-shape (turn distance not respected, but works well for tree siblings)\n                rs.segpts = [\n                    posPts.x2,\n                    posPts.y1\n                ];\n            }\n        }\n    } else {\n        // ideal routing\n        if (isVert) {\n            var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n            var _x4 = posPts.x1, _x5 = posPts.x2;\n            rs.segpts = [\n                _x4,\n                _y4,\n                _x5,\n                _y4\n            ];\n        } else {\n            // horizontal\n            var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n            var _y5 = posPts.y1, _y6 = posPts.y2;\n            rs.segpts = [\n                _x6,\n                _y5,\n                _x6,\n                _y6\n            ];\n        }\n    }\n    if (rs.isRound) {\n        var radius = edge.pstyle(\"taxi-radius\").value;\n        var isArcRadius = edge.pstyle(\"radius-type\").value[0] === \"arc-radius\";\n        rs.radii = new Array(rs.segpts.length / 2).fill(radius);\n        rs.isArcRadius = new Array(rs.segpts.length / 2).fill(isArcRadius);\n    }\n};\nBRp$c.tryToCorrectInvalidPoints = function(edge, pairInfo) {\n    var rs = edge._private.rscratch;\n    // can only correct beziers for now...\n    if (rs.edgeType === \"bezier\") {\n        var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH, srcShape = pairInfo.srcShape, tgtShape = pairInfo.tgtShape, srcCornerRadius = pairInfo.srcCornerRadius, tgtCornerRadius = pairInfo.tgtCornerRadius, srcRs = pairInfo.srcRs, tgtRs = pairInfo.tgtRs;\n        var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n        var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n        var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n        var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n        var minCpADistFactor = 3;\n        var arrowW = this.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.arrowShapeWidth;\n        var minCpADist = minCpADistFactor * arrowW;\n        var startACpDist = dist({\n            x: rs.ctrlpts[0],\n            y: rs.ctrlpts[1]\n        }, {\n            x: rs.startX,\n            y: rs.startY\n        });\n        var closeStartACp = startACpDist < minCpADist;\n        var endACpDist = dist({\n            x: rs.ctrlpts[0],\n            y: rs.ctrlpts[1]\n        }, {\n            x: rs.endX,\n            y: rs.endY\n        });\n        var closeEndACp = endACpDist < minCpADist;\n        var overlapping = false;\n        if (badStart || badAStart || closeStartACp) {\n            overlapping = true;\n            // project control point along line from src centre to outside the src shape\n            // (otherwise intersection will yield nothing)\n            var cpD = {\n                // delta\n                x: rs.ctrlpts[0] - srcPos.x,\n                y: rs.ctrlpts[1] - srcPos.y\n            };\n            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n            var cpM = {\n                // normalised delta\n                x: cpD.x / cpL,\n                y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = {\n                // *2 radius guarantees outside shape\n                x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n                y: rs.ctrlpts[1] + cpM.y * 2 * radius\n            };\n            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0, srcCornerRadius, srcRs);\n            if (closeStartACp) {\n                rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n                rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n            } else {\n                rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n                rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n        }\n        if (badEnd || badAEnd || closeEndACp) {\n            overlapping = true;\n            // project control point along line from tgt centre to outside the tgt shape\n            // (otherwise intersection will yield nothing)\n            var _cpD = {\n                // delta\n                x: rs.ctrlpts[0] - tgtPos.x,\n                y: rs.ctrlpts[1] - tgtPos.y\n            };\n            var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n            var _cpM = {\n                // normalised delta\n                x: _cpD.x / _cpL,\n                y: _cpD.y / _cpL\n            };\n            var _radius = Math.max(srcW, srcH);\n            var _cpProj = {\n                // *2 radius guarantees outside shape\n                x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n                y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n            };\n            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0, tgtCornerRadius, tgtRs);\n            if (closeEndACp) {\n                rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n                rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n            } else {\n                rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n                rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n            }\n        }\n        if (overlapping) {\n            // recalc endpts\n            this.findEndpoints(edge);\n        }\n    }\n};\nBRp$c.storeAllpts = function(edge) {\n    var rs = edge._private.rscratch;\n    if (rs.edgeType === \"multibezier\" || rs.edgeType === \"bezier\" || rs.edgeType === \"self\" || rs.edgeType === \"compound\") {\n        rs.allpts = [];\n        rs.allpts.push(rs.startX, rs.startY);\n        for(var b = 0; b + 1 < rs.ctrlpts.length; b += 2){\n            // ctrl pt itself\n            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);\n            // the midpt between ctrlpts as intermediate destination pts\n            if (b + 3 < rs.ctrlpts.length) {\n                rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n            }\n        }\n        rs.allpts.push(rs.endX, rs.endY);\n        var m1, mt;\n        if (rs.ctrlpts.length / 2 % 2 === 0) {\n            m1 = rs.allpts.length / 2 - 1;\n            rs.midX = rs.allpts[m1];\n            rs.midY = rs.allpts[m1 + 1];\n        } else {\n            m1 = rs.allpts.length / 2 - 3;\n            mt = 0.5;\n            rs.midX = qbezierAt(rs.allpts[m1], rs.allpts[m1 + 2], rs.allpts[m1 + 4], mt);\n            rs.midY = qbezierAt(rs.allpts[m1 + 1], rs.allpts[m1 + 3], rs.allpts[m1 + 5], mt);\n        }\n    } else if (rs.edgeType === \"straight\") {\n        // need to calc these after endpts\n        rs.allpts = [\n            rs.startX,\n            rs.startY,\n            rs.endX,\n            rs.endY\n        ];\n        // default midpt for labels etc\n        rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n        rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n    } else if (rs.edgeType === \"segments\") {\n        rs.allpts = [];\n        rs.allpts.push(rs.startX, rs.startY);\n        rs.allpts.push.apply(rs.allpts, rs.segpts);\n        rs.allpts.push(rs.endX, rs.endY);\n        if (rs.isRound) {\n            rs.roundCorners = [];\n            for(var i = 2; i + 3 < rs.allpts.length; i += 2){\n                var radius = rs.radii[i / 2 - 1];\n                var isArcRadius = rs.isArcRadius[i / 2 - 1];\n                rs.roundCorners.push(getRoundCorner({\n                    x: rs.allpts[i - 2],\n                    y: rs.allpts[i - 1]\n                }, {\n                    x: rs.allpts[i],\n                    y: rs.allpts[i + 1],\n                    radius: radius\n                }, {\n                    x: rs.allpts[i + 2],\n                    y: rs.allpts[i + 3]\n                }, radius, isArcRadius));\n            }\n        }\n        if (rs.segpts.length % 4 === 0) {\n            var i2 = rs.segpts.length / 2;\n            var i1 = i2 - 2;\n            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n        } else {\n            var _i = rs.segpts.length / 2 - 1;\n            if (!rs.isRound) {\n                rs.midX = rs.segpts[_i];\n                rs.midY = rs.segpts[_i + 1];\n            } else {\n                var point = {\n                    x: rs.segpts[_i],\n                    y: rs.segpts[_i + 1]\n                };\n                var corner = rs.roundCorners[_i / 2];\n                if (corner.radius === 0) {\n                    // On collinear points\n                    var nextPoint = {\n                        x: rs.segpts[_i + 2],\n                        y: rs.segpts[_i + 3]\n                    };\n                    rs.midX = point.x;\n                    rs.midY = point.y;\n                    rs.midVector = [\n                        point.y - nextPoint.y,\n                        nextPoint.x - point.x\n                    ];\n                } else {\n                    // On rounded points\n                    var v = [\n                        point.x - corner.cx,\n                        point.y - corner.cy\n                    ];\n                    var factor = corner.radius / Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n                    v = v.map(function(c) {\n                        return c * factor;\n                    });\n                    rs.midX = corner.cx + v[0];\n                    rs.midY = corner.cy + v[1];\n                    rs.midVector = v;\n                }\n            }\n        }\n    }\n};\nBRp$c.checkForInvalidEdgeWarning = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n        rs.loggedErr = false;\n    } else {\n        if (!rs.loggedErr) {\n            rs.loggedErr = true;\n            warn(\"Edge `\" + edge.id() + \"` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.\");\n        }\n    }\n};\nBRp$c.findEdgeControlPoints = function(edges) {\n    var _this = this;\n    if (!edges || edges.length === 0) {\n        return;\n    }\n    var r = this;\n    var cy = r.cy;\n    var hasCompounds = cy.hasCompoundNodes();\n    var hashTable = new Map$1();\n    var getKey = function getKey(pairId, edgeIsUnbundled) {\n        return [].concat(_toConsumableArray(pairId), [\n            edgeIsUnbundled ? 1 : 0\n        ]).join(\"-\");\n    };\n    var pairIds = [];\n    var haystackEdges = [];\n    // create a table of edge (src, tgt) => list of edges between them\n    for(var i = 0; i < edges.length; i++){\n        var edge = edges[i];\n        var _p = edge._private;\n        var curveStyle = edge.pstyle(\"curve-style\").value;\n        // ignore edges who are not to be displayed\n        // they shouldn't take up space\n        if (edge.removed() || !edge.takesUpSpace()) {\n            continue;\n        }\n        if (curveStyle === \"haystack\") {\n            haystackEdges.push(edge);\n            continue;\n        }\n        var edgeIsUnbundled = curveStyle === \"unbundled-bezier\" || endsWith(curveStyle, \"segments\") || curveStyle === \"straight\" || curveStyle === \"straight-triangle\" || endsWith(curveStyle, \"taxi\");\n        var edgeIsBezier = curveStyle === \"unbundled-bezier\" || curveStyle === \"bezier\";\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcIndex = src.poolIndex();\n        var tgtIndex = tgt.poolIndex();\n        var pairId = [\n            srcIndex,\n            tgtIndex\n        ].sort();\n        var key = getKey(pairId, edgeIsUnbundled);\n        var tableEntry = hashTable.get(key);\n        if (tableEntry == null) {\n            tableEntry = {\n                eles: []\n            };\n            pairIds.push({\n                pairId: pairId,\n                edgeIsUnbundled: edgeIsUnbundled\n            });\n            hashTable.set(key, tableEntry);\n        }\n        tableEntry.eles.push(edge);\n        if (edgeIsUnbundled) {\n            tableEntry.hasUnbundled = true;\n        }\n        if (edgeIsBezier) {\n            tableEntry.hasBezier = true;\n        }\n    }\n    // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount\n    var _loop = function _loop() {\n        var _pairIds$p = pairIds[p], pairId = _pairIds$p.pairId, edgeIsUnbundled = _pairIds$p.edgeIsUnbundled;\n        var key = getKey(pairId, edgeIsUnbundled);\n        var pairInfo = hashTable.get(key);\n        var swappedpairInfo;\n        if (!pairInfo.hasUnbundled) {\n            var pllEdges = pairInfo.eles[0].parallelEdges().filter(function(e) {\n                return e.isBundledBezier();\n            });\n            clearArray(pairInfo.eles);\n            pllEdges.forEach(function(edge) {\n                return pairInfo.eles.push(edge);\n            });\n            // for each pair id, the edges should be sorted by index\n            pairInfo.eles.sort(function(edge1, edge2) {\n                return edge1.poolIndex() - edge2.poolIndex();\n            });\n        }\n        var firstEdge = pairInfo.eles[0];\n        var src = firstEdge.source();\n        var tgt = firstEdge.target();\n        // make sure src/tgt distinction is consistent w.r.t. pairId\n        if (src.poolIndex() > tgt.poolIndex()) {\n            var temp = src;\n            src = tgt;\n            tgt = temp;\n        }\n        var srcPos = pairInfo.srcPos = src.position();\n        var tgtPos = pairInfo.tgtPos = tgt.position();\n        var srcW = pairInfo.srcW = src.outerWidth();\n        var srcH = pairInfo.srcH = src.outerHeight();\n        var tgtW = pairInfo.tgtW = tgt.outerWidth();\n        var tgtH = pairInfo.tgtH = tgt.outerHeight();\n        var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n        var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n        var srcCornerRadius = pairInfo.srcCornerRadius = src.pstyle(\"corner-radius\").value === \"auto\" ? \"auto\" : src.pstyle(\"corner-radius\").pfValue;\n        var tgtCornerRadius = pairInfo.tgtCornerRadius = tgt.pstyle(\"corner-radius\").value === \"auto\" ? \"auto\" : tgt.pstyle(\"corner-radius\").pfValue;\n        var tgtRs = pairInfo.tgtRs = tgt._private.rscratch;\n        var srcRs = pairInfo.srcRs = src._private.rscratch;\n        pairInfo.dirCounts = {\n            \"north\": 0,\n            \"west\": 0,\n            \"south\": 0,\n            \"east\": 0,\n            \"northwest\": 0,\n            \"southwest\": 0,\n            \"northeast\": 0,\n            \"southeast\": 0\n        };\n        for(var _i2 = 0; _i2 < pairInfo.eles.length; _i2++){\n            var _edge = pairInfo.eles[_i2];\n            var rs = _edge[0]._private.rscratch;\n            var _curveStyle = _edge.pstyle(\"curve-style\").value;\n            var _edgeIsUnbundled = _curveStyle === \"unbundled-bezier\" || endsWith(_curveStyle, \"segments\") || endsWith(_curveStyle, \"taxi\");\n            // whether the normalised pair order is the reverse of the edge's src-tgt order\n            var edgeIsSwapped = !src.same(_edge.source());\n            if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n                pairInfo.calculatedIntersection = true;\n                // pt outside src shape to calc distance/displacement from src to tgt\n                var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0, srcCornerRadius, srcRs);\n                var srcIntn = pairInfo.srcIntn = srcOutside;\n                // pt outside tgt shape to calc distance/displacement from src to tgt\n                var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0, tgtCornerRadius, tgtRs);\n                var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n                var intersectionPts = pairInfo.intersectionPts = {\n                    x1: srcOutside[0],\n                    x2: tgtOutside[0],\n                    y1: srcOutside[1],\n                    y2: tgtOutside[1]\n                };\n                var posPts = pairInfo.posPts = {\n                    x1: srcPos.x,\n                    x2: tgtPos.x,\n                    y1: srcPos.y,\n                    y2: tgtPos.y\n                };\n                var dy = tgtOutside[1] - srcOutside[1];\n                var dx = tgtOutside[0] - srcOutside[0];\n                var l = Math.sqrt(dx * dx + dy * dy);\n                if (number$1(l) && l >= AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L) ;\n                else {\n                    l = Math.sqrt(Math.max(dx * dx, AVOID_IMPOSSIBLE_BEZIER_CONSTANT) + Math.max(dy * dy, AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n                }\n                var vector = pairInfo.vector = {\n                    x: dx,\n                    y: dy\n                };\n                var vectorNorm = pairInfo.vectorNorm = {\n                    x: vector.x / l,\n                    y: vector.y / l\n                };\n                var vectorNormInverse = {\n                    x: -vectorNorm.y,\n                    y: vectorNorm.x\n                };\n                // if node shapes overlap, then no ctrl pts to draw\n                pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y, tgtCornerRadius, tgtRs) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y, srcCornerRadius, srcRs);\n                pairInfo.vectorNormInverse = vectorNormInverse;\n                swappedpairInfo = {\n                    nodesOverlap: pairInfo.nodesOverlap,\n                    dirCounts: pairInfo.dirCounts,\n                    calculatedIntersection: true,\n                    hasBezier: pairInfo.hasBezier,\n                    hasUnbundled: pairInfo.hasUnbundled,\n                    eles: pairInfo.eles,\n                    srcPos: tgtPos,\n                    srcRs: tgtRs,\n                    tgtPos: srcPos,\n                    tgtRs: srcRs,\n                    srcW: tgtW,\n                    srcH: tgtH,\n                    tgtW: srcW,\n                    tgtH: srcH,\n                    srcIntn: tgtIntn,\n                    tgtIntn: srcIntn,\n                    srcShape: tgtShape,\n                    tgtShape: srcShape,\n                    posPts: {\n                        x1: posPts.x2,\n                        y1: posPts.y2,\n                        x2: posPts.x1,\n                        y2: posPts.y1\n                    },\n                    intersectionPts: {\n                        x1: intersectionPts.x2,\n                        y1: intersectionPts.y2,\n                        x2: intersectionPts.x1,\n                        y2: intersectionPts.y1\n                    },\n                    vector: {\n                        x: -vector.x,\n                        y: -vector.y\n                    },\n                    vectorNorm: {\n                        x: -vectorNorm.x,\n                        y: -vectorNorm.y\n                    },\n                    vectorNormInverse: {\n                        x: -vectorNormInverse.x,\n                        y: -vectorNormInverse.y\n                    }\n                };\n            }\n            var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n            rs.nodesOverlap = passedPairInfo.nodesOverlap;\n            rs.srcIntn = passedPairInfo.srcIntn;\n            rs.tgtIntn = passedPairInfo.tgtIntn;\n            rs.isRound = _curveStyle.startsWith(\"round\");\n            if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n                _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n            } else if (src === tgt) {\n                _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n            } else if (_curveStyle.endsWith(\"segments\")) {\n                _this.findSegmentsPoints(_edge, passedPairInfo);\n            } else if (_curveStyle.endsWith(\"taxi\")) {\n                _this.findTaxiPoints(_edge, passedPairInfo);\n            } else if (_curveStyle === \"straight\" || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n                _this.findStraightEdgePoints(_edge);\n            } else {\n                _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n            }\n            _this.findEndpoints(_edge);\n            _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n            _this.checkForInvalidEdgeWarning(_edge);\n            _this.storeAllpts(_edge);\n            _this.storeEdgeProjections(_edge);\n            _this.calculateArrowAngles(_edge);\n            _this.recalculateEdgeLabelProjections(_edge);\n            _this.calculateLabelAngles(_edge);\n        } // for pair edges\n    };\n    for(var p = 0; p < pairIds.length; p++){\n        _loop();\n    } // for pair ids\n    // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n    this.findHaystackPoints(haystackEdges);\n};\nfunction getPts(pts) {\n    var retPts = [];\n    if (pts == null) {\n        return;\n    }\n    for(var i = 0; i < pts.length; i += 2){\n        var x = pts[i];\n        var y = pts[i + 1];\n        retPts.push({\n            x: x,\n            y: y\n        });\n    }\n    return retPts;\n}\nBRp$c.getSegmentPoints = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    var type = rs.edgeType;\n    if (type === \"segments\") {\n        return getPts(rs.segpts);\n    }\n};\nBRp$c.getControlPoints = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    var type = rs.edgeType;\n    if (type === \"bezier\" || type === \"multibezier\" || type === \"self\" || type === \"compound\") {\n        return getPts(rs.ctrlpts);\n    }\n};\nBRp$c.getEdgeMidpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    return {\n        x: rs.midX,\n        y: rs.midY\n    };\n};\nvar BRp$b = {};\nBRp$b.manualEndptToPx = function(node, prop) {\n    var r = this;\n    var npos = node.position();\n    var w = node.outerWidth();\n    var h = node.outerHeight();\n    var rs = node._private.rscratch;\n    if (prop.value.length === 2) {\n        var p = [\n            prop.pfValue[0],\n            prop.pfValue[1]\n        ];\n        if (prop.units[0] === \"%\") {\n            p[0] = p[0] * w;\n        }\n        if (prop.units[1] === \"%\") {\n            p[1] = p[1] * h;\n        }\n        p[0] += npos.x;\n        p[1] += npos.y;\n        return p;\n    } else {\n        var angle = prop.pfValue[0];\n        angle = -Math.PI / 2 + angle; // start at 12 o'clock\n        var l = 2 * Math.max(w, h);\n        var _p = [\n            npos.x + Math.cos(angle) * l,\n            npos.y + Math.sin(angle) * l\n        ];\n        return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0, node.pstyle(\"corner-radius\").value === \"auto\" ? \"auto\" : node.pstyle(\"corner-radius\").pfValue, rs);\n    }\n};\nBRp$b.findEndpoints = function(edge) {\n    var _ref, _tgtManEndpt$pfValue, _ref2, _srcManEndpt$pfValue;\n    var r = this;\n    var intersect;\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    var srcPos = source.position();\n    var tgtPos = target.position();\n    var tgtArShape = edge.pstyle(\"target-arrow-shape\").value;\n    var srcArShape = edge.pstyle(\"source-arrow-shape\").value;\n    var tgtDist = edge.pstyle(\"target-distance-from-node\").pfValue;\n    var srcDist = edge.pstyle(\"source-distance-from-node\").pfValue;\n    var srcRs = source._private.rscratch;\n    var tgtRs = target._private.rscratch;\n    var curveStyle = edge.pstyle(\"curve-style\").value;\n    var rs = edge._private.rscratch;\n    var et = rs.edgeType;\n    var taxi = endsWith(curveStyle, \"taxi\"); // Covers taxi and round-taxi\n    var self1 = et === \"self\" || et === \"compound\";\n    var bezier = et === \"bezier\" || et === \"multibezier\" || self1;\n    var multi = et !== \"bezier\";\n    var lines = et === \"straight\" || et === \"segments\";\n    var segments = et === \"segments\";\n    var hasEndpts = bezier || multi || lines;\n    var overrideEndpts = self1 || taxi;\n    var srcManEndpt = edge.pstyle(\"source-endpoint\");\n    var srcManEndptVal = overrideEndpts ? \"outside-to-node\" : srcManEndpt.value;\n    var srcCornerRadius = source.pstyle(\"corner-radius\").value === \"auto\" ? \"auto\" : source.pstyle(\"corner-radius\").pfValue;\n    var tgtManEndpt = edge.pstyle(\"target-endpoint\");\n    var tgtManEndptVal = overrideEndpts ? \"outside-to-node\" : tgtManEndpt.value;\n    var tgtCornerRadius = target.pstyle(\"corner-radius\").value === \"auto\" ? \"auto\" : target.pstyle(\"corner-radius\").pfValue;\n    rs.srcManEndpt = srcManEndpt;\n    rs.tgtManEndpt = tgtManEndpt;\n    var p1; // last known point of edge on target side\n    var p2; // last known point of edge on source side\n    var p1_i; // point to intersect with target shape\n    var p2_i; // point to intersect with source shape\n    var tgtManEndptPt = (_ref = (tgtManEndpt === null || tgtManEndpt === undefined || (_tgtManEndpt$pfValue = tgtManEndpt.pfValue) === null || _tgtManEndpt$pfValue === undefined ? undefined : _tgtManEndpt$pfValue.length) === 2 ? tgtManEndpt.pfValue : null) !== null && _ref !== undefined ? _ref : [\n        0,\n        0\n    ];\n    var srcManEndptPt = (_ref2 = (srcManEndpt === null || srcManEndpt === undefined || (_srcManEndpt$pfValue = srcManEndpt.pfValue) === null || _srcManEndpt$pfValue === undefined ? undefined : _srcManEndpt$pfValue.length) === 2 ? srcManEndpt.pfValue : null) !== null && _ref2 !== undefined ? _ref2 : [\n        0,\n        0\n    ];\n    if (bezier) {\n        var cpStart = [\n            rs.ctrlpts[0],\n            rs.ctrlpts[1]\n        ];\n        var cpEnd = multi ? [\n            rs.ctrlpts[rs.ctrlpts.length - 2],\n            rs.ctrlpts[rs.ctrlpts.length - 1]\n        ] : cpStart;\n        p1 = cpEnd;\n        p2 = cpStart;\n    } else if (lines) {\n        var srcArrowFromPt = !segments ? [\n            tgtPos.x + tgtManEndptPt[0],\n            tgtPos.y + tgtManEndptPt[1]\n        ] : rs.segpts.slice(0, 2);\n        var tgtArrowFromPt = !segments ? [\n            srcPos.x + srcManEndptPt[0],\n            srcPos.y + srcManEndptPt[1]\n        ] : rs.segpts.slice(rs.segpts.length - 2);\n        p1 = tgtArrowFromPt;\n        p2 = srcArrowFromPt;\n    }\n    if (tgtManEndptVal === \"inside-to-node\") {\n        intersect = [\n            tgtPos.x,\n            tgtPos.y\n        ];\n    } else if (tgtManEndpt.units) {\n        intersect = this.manualEndptToPx(target, tgtManEndpt);\n    } else if (tgtManEndptVal === \"outside-to-line\") {\n        intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n    } else {\n        if (tgtManEndptVal === \"outside-to-node\" || tgtManEndptVal === \"outside-to-node-or-label\") {\n            p1_i = p1;\n        } else if (tgtManEndptVal === \"outside-to-line\" || tgtManEndptVal === \"outside-to-line-or-label\") {\n            p1_i = [\n                srcPos.x,\n                srcPos.y\n            ];\n        }\n        intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0, tgtCornerRadius, tgtRs);\n        if (tgtManEndptVal === \"outside-to-node-or-label\" || tgtManEndptVal === \"outside-to-line-or-label\") {\n            var trs = target._private.rscratch;\n            var lw = trs.labelWidth;\n            var lh = trs.labelHeight;\n            var lx = trs.labelX;\n            var ly = trs.labelY;\n            var lw2 = lw / 2;\n            var lh2 = lh / 2;\n            var va = target.pstyle(\"text-valign\").value;\n            if (va === \"top\") {\n                ly -= lh2;\n            } else if (va === \"bottom\") {\n                ly += lh2;\n            }\n            var ha = target.pstyle(\"text-halign\").value;\n            if (ha === \"left\") {\n                lx -= lw2;\n            } else if (ha === \"right\") {\n                lx += lw2;\n            }\n            var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [\n                lx - lw2,\n                ly - lh2,\n                lx + lw2,\n                ly - lh2,\n                lx + lw2,\n                ly + lh2,\n                lx - lw2,\n                ly + lh2\n            ], tgtPos.x, tgtPos.y);\n            if (labelIntersect.length > 0) {\n                var refPt = srcPos;\n                var intSqdist = sqdist(refPt, array2point(intersect));\n                var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n                var minSqDist = intSqdist;\n                if (labIntSqdist < intSqdist) {\n                    intersect = labelIntersect;\n                    minSqDist = labIntSqdist;\n                }\n                if (labelIntersect.length > 2) {\n                    var labInt2SqDist = sqdist(refPt, {\n                        x: labelIntersect[2],\n                        y: labelIntersect[3]\n                    });\n                    if (labInt2SqDist < minSqDist) {\n                        intersect = [\n                            labelIntersect[2],\n                            labelIntersect[3]\n                        ];\n                    }\n                }\n            }\n        }\n    }\n    var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n    var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n    rs.endX = edgeEnd[0];\n    rs.endY = edgeEnd[1];\n    rs.arrowEndX = arrowEnd[0];\n    rs.arrowEndY = arrowEnd[1];\n    if (srcManEndptVal === \"inside-to-node\") {\n        intersect = [\n            srcPos.x,\n            srcPos.y\n        ];\n    } else if (srcManEndpt.units) {\n        intersect = this.manualEndptToPx(source, srcManEndpt);\n    } else if (srcManEndptVal === \"outside-to-line\") {\n        intersect = rs.srcIntn; // use cached value from ctrlpt calc\n    } else {\n        if (srcManEndptVal === \"outside-to-node\" || srcManEndptVal === \"outside-to-node-or-label\") {\n            p2_i = p2;\n        } else if (srcManEndptVal === \"outside-to-line\" || srcManEndptVal === \"outside-to-line-or-label\") {\n            p2_i = [\n                tgtPos.x,\n                tgtPos.y\n            ];\n        }\n        intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0, srcCornerRadius, srcRs);\n        if (srcManEndptVal === \"outside-to-node-or-label\" || srcManEndptVal === \"outside-to-line-or-label\") {\n            var srs = source._private.rscratch;\n            var _lw = srs.labelWidth;\n            var _lh = srs.labelHeight;\n            var _lx = srs.labelX;\n            var _ly = srs.labelY;\n            var _lw2 = _lw / 2;\n            var _lh2 = _lh / 2;\n            var _va = source.pstyle(\"text-valign\").value;\n            if (_va === \"top\") {\n                _ly -= _lh2;\n            } else if (_va === \"bottom\") {\n                _ly += _lh2;\n            }\n            var _ha = source.pstyle(\"text-halign\").value;\n            if (_ha === \"left\") {\n                _lx -= _lw2;\n            } else if (_ha === \"right\") {\n                _lx += _lw2;\n            }\n            var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [\n                _lx - _lw2,\n                _ly - _lh2,\n                _lx + _lw2,\n                _ly - _lh2,\n                _lx + _lw2,\n                _ly + _lh2,\n                _lx - _lw2,\n                _ly + _lh2\n            ], srcPos.x, srcPos.y);\n            if (_labelIntersect.length > 0) {\n                var _refPt = tgtPos;\n                var _intSqdist = sqdist(_refPt, array2point(intersect));\n                var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n                var _minSqDist = _intSqdist;\n                if (_labIntSqdist < _intSqdist) {\n                    intersect = [\n                        _labelIntersect[0],\n                        _labelIntersect[1]\n                    ];\n                    _minSqDist = _labIntSqdist;\n                }\n                if (_labelIntersect.length > 2) {\n                    var _labInt2SqDist = sqdist(_refPt, {\n                        x: _labelIntersect[2],\n                        y: _labelIntersect[3]\n                    });\n                    if (_labInt2SqDist < _minSqDist) {\n                        intersect = [\n                            _labelIntersect[2],\n                            _labelIntersect[3]\n                        ];\n                    }\n                }\n            }\n        }\n    }\n    var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n    var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n    rs.startX = edgeStart[0];\n    rs.startY = edgeStart[1];\n    rs.arrowStartX = arrowStart[0];\n    rs.arrowStartY = arrowStart[1];\n    if (hasEndpts) {\n        if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n            rs.badLine = true;\n        } else {\n            rs.badLine = false;\n        }\n    }\n};\nBRp$b.getSourceEndpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    switch(rs.edgeType){\n        case \"haystack\":\n            return {\n                x: rs.haystackPts[0],\n                y: rs.haystackPts[1]\n            };\n        default:\n            return {\n                x: rs.arrowStartX,\n                y: rs.arrowStartY\n            };\n    }\n};\nBRp$b.getTargetEndpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    switch(rs.edgeType){\n        case \"haystack\":\n            return {\n                x: rs.haystackPts[2],\n                y: rs.haystackPts[3]\n            };\n        default:\n            return {\n                x: rs.arrowEndX,\n                y: rs.arrowEndY\n            };\n    }\n};\nvar BRp$a = {};\nfunction pushBezierPts(r, edge, pts) {\n    var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n        return qbezierAt(p1, p2, p3, t);\n    };\n    var _p = edge._private;\n    var bpts = _p.rstyle.bezierPts;\n    for(var i = 0; i < r.bezierProjPcts.length; i++){\n        var p = r.bezierProjPcts[i];\n        bpts.push({\n            x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n            y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n        });\n    }\n}\nBRp$a.storeEdgeProjections = function(edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var et = rs.edgeType;\n    // clear the cached points state\n    _p.rstyle.bezierPts = null;\n    _p.rstyle.linePts = null;\n    _p.rstyle.haystackPts = null;\n    if (et === \"multibezier\" || et === \"bezier\" || et === \"self\" || et === \"compound\") {\n        _p.rstyle.bezierPts = [];\n        for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n            pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n        }\n    } else if (et === \"segments\") {\n        var lpts = _p.rstyle.linePts = [];\n        for(var i = 0; i + 1 < rs.allpts.length; i += 2){\n            lpts.push({\n                x: rs.allpts[i],\n                y: rs.allpts[i + 1]\n            });\n        }\n    } else if (et === \"haystack\") {\n        var hpts = rs.haystackPts;\n        _p.rstyle.haystackPts = [\n            {\n                x: hpts[0],\n                y: hpts[1]\n            },\n            {\n                x: hpts[2],\n                y: hpts[3]\n            }\n        ];\n    }\n    _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle(\"width\").pfValue, edge.pstyle(\"arrow-scale\").value) * this.arrowShapeWidth;\n};\nBRp$a.recalculateEdgeProjections = function(edges) {\n    this.findEdgeControlPoints(edges);\n};\nvar BRp$9 = {};\nBRp$9.recalculateNodeLabelProjection = function(node) {\n    var content = node.pstyle(\"label\").strValue;\n    if (emptyString(content)) {\n        return;\n    }\n    var textX, textY;\n    var _p = node._private;\n    var nodeWidth = node.width();\n    var nodeHeight = node.height();\n    var padding = node.padding();\n    var nodePos = node.position();\n    var textHalign = node.pstyle(\"text-halign\").strValue;\n    var textValign = node.pstyle(\"text-valign\").strValue;\n    var rs = _p.rscratch;\n    var rstyle = _p.rstyle;\n    switch(textHalign){\n        case \"left\":\n            textX = nodePos.x - nodeWidth / 2 - padding;\n            break;\n        case \"right\":\n            textX = nodePos.x + nodeWidth / 2 + padding;\n            break;\n        default:\n            // e.g. center\n            textX = nodePos.x;\n    }\n    switch(textValign){\n        case \"top\":\n            textY = nodePos.y - nodeHeight / 2 - padding;\n            break;\n        case \"bottom\":\n            textY = nodePos.y + nodeHeight / 2 + padding;\n            break;\n        default:\n            // e.g. middle\n            textY = nodePos.y;\n    }\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n    this.calculateLabelAngles(node);\n    this.applyLabelDimensions(node);\n};\nvar lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n    var angle = Math.atan(dy / dx);\n    if (dx === 0 && angle < 0) {\n        angle = angle * -1;\n    }\n    return angle;\n};\nvar lineAngle = function lineAngle(p0, p1) {\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return lineAngleFromDelta(dx, dy);\n};\nvar bezierAngle = function bezierAngle(p0, p1, p2, t) {\n    var t0 = bound(0, t - 0.001, 1);\n    var t1 = bound(0, t + 0.001, 1);\n    var lp0 = qbezierPtAt(p0, p1, p2, t0);\n    var lp1 = qbezierPtAt(p0, p1, p2, t1);\n    return lineAngle(lp0, lp1);\n};\nBRp$9.recalculateEdgeLabelProjections = function(edge) {\n    var p;\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var r = this;\n    var content = {\n        mid: edge.pstyle(\"label\").strValue,\n        source: edge.pstyle(\"source-label\").strValue,\n        target: edge.pstyle(\"target-label\").strValue\n    };\n    if (content.mid || content.source || content.target) ;\n    else {\n        return; // no labels => no calcs\n    }\n    // add center point to style so bounding box calculations can use it\n    //\n    p = {\n        x: rs.midX,\n        y: rs.midY\n    };\n    var setRs = function setRs(propName, prefix, value) {\n        setPrefixedProperty(_p.rscratch, propName, prefix, value);\n        setPrefixedProperty(_p.rstyle, propName, prefix, value);\n    };\n    setRs(\"labelX\", null, p.x);\n    setRs(\"labelY\", null, p.y);\n    var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n    setRs(\"labelAutoAngle\", null, midAngle);\n    var _createControlPointInfo = function createControlPointInfo() {\n        if (_createControlPointInfo.cache) {\n            return _createControlPointInfo.cache;\n        } // use cache so only 1x per edge\n        var ctrlpts = [];\n        // store each ctrlpt info init\n        for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n            var p0 = {\n                x: rs.allpts[i],\n                y: rs.allpts[i + 1]\n            };\n            var p1 = {\n                x: rs.allpts[i + 2],\n                y: rs.allpts[i + 3]\n            }; // ctrlpt\n            var p2 = {\n                x: rs.allpts[i + 4],\n                y: rs.allpts[i + 5]\n            };\n            ctrlpts.push({\n                p0: p0,\n                p1: p1,\n                p2: p2,\n                startDist: 0,\n                length: 0,\n                segments: []\n            });\n        }\n        var bpts = _p.rstyle.bezierPts;\n        var nProjs = r.bezierProjPcts.length;\n        function addSegment(cp, p0, p1, t0, t1) {\n            var length = dist(p0, p1);\n            var prevSegment = cp.segments[cp.segments.length - 1];\n            var segment = {\n                p0: p0,\n                p1: p1,\n                t0: t0,\n                t1: t1,\n                startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n                length: length\n            };\n            cp.segments.push(segment);\n            cp.length += length;\n        }\n        // update each ctrlpt with segment info\n        for(var _i = 0; _i < ctrlpts.length; _i++){\n            var cp = ctrlpts[_i];\n            var prevCp = ctrlpts[_i - 1];\n            if (prevCp) {\n                cp.startDist = prevCp.startDist + prevCp.length;\n            }\n            addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n            for(var j = 0; j < nProjs - 1; j++){\n                addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n            }\n            addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n        }\n        return _createControlPointInfo.cache = ctrlpts;\n    };\n    var calculateEndProjection = function calculateEndProjection(prefix) {\n        var angle;\n        var isSrc = prefix === \"source\";\n        if (!content[prefix]) {\n            return;\n        }\n        var offset = edge.pstyle(prefix + \"-text-offset\").pfValue;\n        switch(rs.edgeType){\n            case \"self\":\n            case \"compound\":\n            case \"bezier\":\n            case \"multibezier\":\n                {\n                    var cps = _createControlPointInfo();\n                    var selected;\n                    var startDist = 0;\n                    var totalDist = 0;\n                    // find the segment we're on\n                    for(var i = 0; i < cps.length; i++){\n                        var _cp = cps[isSrc ? i : cps.length - 1 - i];\n                        for(var j = 0; j < _cp.segments.length; j++){\n                            var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n                            var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n                            startDist = totalDist;\n                            totalDist += _seg.length;\n                            if (totalDist >= offset || lastSeg) {\n                                selected = {\n                                    cp: _cp,\n                                    segment: _seg\n                                };\n                                break;\n                            }\n                        }\n                        if (selected) {\n                            break;\n                        }\n                    }\n                    var cp = selected.cp;\n                    var seg = selected.segment;\n                    var tSegment = (offset - startDist) / seg.length;\n                    var segDt = seg.t1 - seg.t0;\n                    var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n                    t = bound(0, t, 1);\n                    p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n                    angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n                    break;\n                }\n            case \"straight\":\n            case \"segments\":\n            case \"haystack\":\n                {\n                    var d = 0, di, d0;\n                    var p0, p1;\n                    var l = rs.allpts.length;\n                    for(var _i2 = 0; _i2 + 3 < l; _i2 += 2){\n                        if (isSrc) {\n                            p0 = {\n                                x: rs.allpts[_i2],\n                                y: rs.allpts[_i2 + 1]\n                            };\n                            p1 = {\n                                x: rs.allpts[_i2 + 2],\n                                y: rs.allpts[_i2 + 3]\n                            };\n                        } else {\n                            p0 = {\n                                x: rs.allpts[l - 2 - _i2],\n                                y: rs.allpts[l - 1 - _i2]\n                            };\n                            p1 = {\n                                x: rs.allpts[l - 4 - _i2],\n                                y: rs.allpts[l - 3 - _i2]\n                            };\n                        }\n                        di = dist(p0, p1);\n                        d0 = d;\n                        d += di;\n                        if (d >= offset) {\n                            break;\n                        }\n                    }\n                    var pD = offset - d0;\n                    var _t = pD / di;\n                    _t = bound(0, _t, 1);\n                    p = lineAt(p0, p1, _t);\n                    angle = lineAngle(p0, p1);\n                    break;\n                }\n        }\n        setRs(\"labelX\", prefix, p.x);\n        setRs(\"labelY\", prefix, p.y);\n        setRs(\"labelAutoAngle\", prefix, angle);\n    };\n    calculateEndProjection(\"source\");\n    calculateEndProjection(\"target\");\n    this.applyLabelDimensions(edge);\n};\nBRp$9.applyLabelDimensions = function(ele) {\n    this.applyPrefixedLabelDimensions(ele);\n    if (ele.isEdge()) {\n        this.applyPrefixedLabelDimensions(ele, \"source\");\n        this.applyPrefixedLabelDimensions(ele, \"target\");\n    }\n};\nBRp$9.applyPrefixedLabelDimensions = function(ele, prefix) {\n    var _p = ele._private;\n    var text = this.getLabelText(ele, prefix);\n    var cacheKey = hashString(text, ele._private.labelDimsKey);\n    // save recalc if the label is the same as before\n    if (getPrefixedProperty(_p.rscratch, \"prefixedLabelDimsKey\", prefix) === cacheKey) {\n        return; // then the label dimensions + text are the same\n    }\n    // save the key\n    setPrefixedProperty(_p.rscratch, \"prefixedLabelDimsKey\", prefix, cacheKey);\n    var labelDims = this.calculateLabelDimensions(ele, text);\n    var lineHeight = ele.pstyle(\"line-height\").pfValue;\n    var textWrap = ele.pstyle(\"text-wrap\").strValue;\n    var lines = getPrefixedProperty(_p.rscratch, \"labelWrapCachedLines\", prefix) || [];\n    var numLines = textWrap !== \"wrap\" ? 1 : Math.max(lines.length, 1);\n    var normPerLineHeight = labelDims.height / numLines;\n    var labelLineHeight = normPerLineHeight * lineHeight;\n    var width = labelDims.width;\n    var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n    setPrefixedProperty(_p.rstyle, \"labelWidth\", prefix, width);\n    setPrefixedProperty(_p.rscratch, \"labelWidth\", prefix, width);\n    setPrefixedProperty(_p.rstyle, \"labelHeight\", prefix, height);\n    setPrefixedProperty(_p.rscratch, \"labelHeight\", prefix, height);\n    setPrefixedProperty(_p.rscratch, \"labelLineHeight\", prefix, labelLineHeight);\n};\nBRp$9.getLabelText = function(ele, prefix) {\n    var _p = ele._private;\n    var pfd = prefix ? prefix + \"-\" : \"\";\n    var text = ele.pstyle(pfd + \"label\").strValue;\n    var textTransform = ele.pstyle(\"text-transform\").value;\n    var rscratch = function rscratch(propName, value) {\n        if (value) {\n            setPrefixedProperty(_p.rscratch, propName, prefix, value);\n            return value;\n        } else {\n            return getPrefixedProperty(_p.rscratch, propName, prefix);\n        }\n    };\n    // for empty text, skip all processing\n    if (!text) {\n        return \"\";\n    }\n    if (textTransform == \"none\") ;\n    else if (textTransform == \"uppercase\") {\n        text = text.toUpperCase();\n    } else if (textTransform == \"lowercase\") {\n        text = text.toLowerCase();\n    }\n    var wrapStyle = ele.pstyle(\"text-wrap\").value;\n    if (wrapStyle === \"wrap\") {\n        var labelKey = rscratch(\"labelKey\");\n        // save recalc if the label is the same as before\n        if (labelKey != null && rscratch(\"labelWrapKey\") === labelKey) {\n            return rscratch(\"labelWrapCachedText\");\n        }\n        var zwsp = \"​\";\n        var lines = text.split(\"\\n\");\n        var maxW = ele.pstyle(\"text-max-width\").pfValue;\n        var overflow = ele.pstyle(\"text-overflow-wrap\").value;\n        var overflowAny = overflow === \"anywhere\";\n        var wrappedLines = [];\n        var separatorRegex = /[\\s\\u200b]+|$/g; // Include end of string to add last word\n        for(var l = 0; l < lines.length; l++){\n            var line = lines[l];\n            var lineDims = this.calculateLabelDimensions(ele, line);\n            var lineW = lineDims.width;\n            if (overflowAny) {\n                var processedLine = line.split(\"\").join(zwsp);\n                line = processedLine;\n            }\n            if (lineW > maxW) {\n                // line is too long\n                var separatorMatches = line.matchAll(separatorRegex);\n                var subline = \"\";\n                var previousIndex = 0;\n                // Add fake match\n                var _iterator = _createForOfIteratorHelper(separatorMatches), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var separatorMatch = _step.value;\n                        var wordSeparator = separatorMatch[0];\n                        var word = line.substring(previousIndex, separatorMatch.index);\n                        previousIndex = separatorMatch.index + wordSeparator.length;\n                        var testLine = subline.length === 0 ? word : subline + word + wordSeparator;\n                        var testDims = this.calculateLabelDimensions(ele, testLine);\n                        var testW = testDims.width;\n                        if (testW <= maxW) {\n                            // word fits on current line\n                            subline += word + wordSeparator;\n                        } else {\n                            // word starts new line\n                            if (subline) {\n                                wrappedLines.push(subline);\n                            }\n                            subline = word + wordSeparator;\n                        }\n                    }\n                // if there's remaining text, put it in a wrapped line\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                if (!subline.match(/^[\\s\\u200b]+$/)) {\n                    wrappedLines.push(subline);\n                }\n            } else {\n                // line is already short enough\n                wrappedLines.push(line);\n            }\n        } // for\n        rscratch(\"labelWrapCachedLines\", wrappedLines);\n        text = rscratch(\"labelWrapCachedText\", wrappedLines.join(\"\\n\"));\n        rscratch(\"labelWrapKey\", labelKey);\n    } else if (wrapStyle === \"ellipsis\") {\n        var _maxW = ele.pstyle(\"text-max-width\").pfValue;\n        var ellipsized = \"\";\n        var ellipsis = \"…\";\n        var incLastCh = false;\n        if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n            // the label already fits\n            return text;\n        }\n        for(var i = 0; i < text.length; i++){\n            var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n            if (widthWithNextCh > _maxW) {\n                break;\n            }\n            ellipsized += text[i];\n            if (i === text.length - 1) {\n                incLastCh = true;\n            }\n        }\n        if (!incLastCh) {\n            ellipsized += ellipsis;\n        }\n        return ellipsized;\n    } // if ellipsize\n    return text;\n};\nBRp$9.getLabelJustification = function(ele) {\n    var justification = ele.pstyle(\"text-justification\").strValue;\n    var textHalign = ele.pstyle(\"text-halign\").strValue;\n    if (justification === \"auto\") {\n        if (ele.isNode()) {\n            switch(textHalign){\n                case \"left\":\n                    return \"right\";\n                case \"right\":\n                    return \"left\";\n                default:\n                    return \"center\";\n            }\n        } else {\n            return \"center\";\n        }\n    } else {\n        return justification;\n    }\n};\nBRp$9.calculateLabelDimensions = function(ele, text) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var document1 = containerWindow.document;\n    var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n    var fStyle = ele.pstyle(\"font-style\").strValue;\n    var size = ele.pstyle(\"font-size\").pfValue;\n    var family = ele.pstyle(\"font-family\").strValue;\n    var weight = ele.pstyle(\"font-weight\").strValue;\n    var canvas = this.labelCalcCanvas;\n    var c2d = this.labelCalcCanvasContext;\n    if (!canvas) {\n        canvas = this.labelCalcCanvas = document1.createElement(\"canvas\");\n        c2d = this.labelCalcCanvasContext = canvas.getContext(\"2d\");\n        var ds = canvas.style;\n        ds.position = \"absolute\";\n        ds.left = \"-9999px\";\n        ds.top = \"-9999px\";\n        ds.zIndex = \"-1\";\n        ds.visibility = \"hidden\";\n        ds.pointerEvents = \"none\";\n    }\n    c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n    var width = 0;\n    var height = 0;\n    var lines = text.split(\"\\n\");\n    for(var i = 0; i < lines.length; i++){\n        var line = lines[i];\n        var metrics = c2d.measureText(line);\n        var w = Math.ceil(metrics.width);\n        var h = size;\n        width = Math.max(w, width);\n        height += h;\n    }\n    width += padding;\n    height += padding;\n    return {\n        width: width,\n        height: height\n    };\n};\nBRp$9.calculateLabelAngle = function(ele, prefix) {\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    var isEdge = ele.isEdge();\n    var prefixDash = prefix ? prefix + \"-\" : \"\";\n    var rot = ele.pstyle(prefixDash + \"text-rotation\");\n    var rotStr = rot.strValue;\n    if (rotStr === \"none\") {\n        return 0;\n    } else if (isEdge && rotStr === \"autorotate\") {\n        return rs.labelAutoAngle;\n    } else if (rotStr === \"autorotate\") {\n        return 0;\n    } else {\n        return rot.pfValue;\n    }\n};\nBRp$9.calculateLabelAngles = function(ele) {\n    var r = this;\n    var isEdge = ele.isEdge();\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    rs.labelAngle = r.calculateLabelAngle(ele);\n    if (isEdge) {\n        rs.sourceLabelAngle = r.calculateLabelAngle(ele, \"source\");\n        rs.targetLabelAngle = r.calculateLabelAngle(ele, \"target\");\n    }\n};\nvar BRp$8 = {};\nvar TOO_SMALL_CUT_RECT = 28;\nvar warnedCutRect = false;\nBRp$8.getNodeShape = function(node) {\n    var r = this;\n    var shape = node.pstyle(\"shape\").value;\n    if (shape === \"cutrectangle\" && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n        if (!warnedCutRect) {\n            warn(\"The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead\");\n            warnedCutRect = true;\n        }\n        return \"rectangle\";\n    }\n    if (node.isParent()) {\n        if (shape === \"rectangle\" || shape === \"roundrectangle\" || shape === \"round-rectangle\" || shape === \"cutrectangle\" || shape === \"cut-rectangle\" || shape === \"barrel\") {\n            return shape;\n        } else {\n            return \"rectangle\";\n        }\n    }\n    if (shape === \"polygon\") {\n        var points = node.pstyle(\"shape-polygon-points\").value;\n        return r.nodeShapes.makePolygon(points).name;\n    }\n    return shape;\n};\nvar BRp$7 = {};\nBRp$7.registerCalculationListeners = function() {\n    var cy = this.cy;\n    var elesToUpdate = cy.collection();\n    var r = this;\n    var enqueue = function enqueue(eles) {\n        var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        elesToUpdate.merge(eles);\n        if (dirtyStyleCaches) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var _p = ele._private;\n                var rstyle = _p.rstyle;\n                rstyle.clean = false;\n                rstyle.cleanConnected = false;\n            }\n        }\n    };\n    r.binder(cy).on(\"bounds.* dirty.*\", function onDirtyBounds(e) {\n        var ele = e.target;\n        enqueue(ele);\n    }).on(\"style.* background.*\", function onDirtyStyle(e) {\n        var ele = e.target;\n        enqueue(ele, false);\n    });\n    var updateEleCalcs = function updateEleCalcs(willDraw) {\n        if (willDraw) {\n            var fns = r.onUpdateEleCalcsFns;\n            // because we need to have up-to-date style (e.g. stylesheet mappers)\n            // before calculating rendered style (and pstyle might not be called yet)\n            elesToUpdate.cleanStyle();\n            for(var i = 0; i < elesToUpdate.length; i++){\n                var ele = elesToUpdate[i];\n                var rstyle = ele._private.rstyle;\n                if (ele.isNode() && !rstyle.cleanConnected) {\n                    enqueue(ele.connectedEdges());\n                    rstyle.cleanConnected = true;\n                }\n            }\n            if (fns) {\n                for(var _i = 0; _i < fns.length; _i++){\n                    var fn = fns[_i];\n                    fn(willDraw, elesToUpdate);\n                }\n            }\n            r.recalculateRenderedStyle(elesToUpdate);\n            elesToUpdate = cy.collection();\n        }\n    };\n    r.flushRenderedStyleQueue = function() {\n        updateEleCalcs(true);\n    };\n    r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n};\nBRp$7.onUpdateEleCalcs = function(fn) {\n    var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n    fns.push(fn);\n};\nBRp$7.recalculateRenderedStyle = function(eles, useCache) {\n    var isCleanConnected = function isCleanConnected(ele) {\n        return ele._private.rstyle.cleanConnected;\n    };\n    if (eles.length === 0) {\n        return;\n    }\n    var edges = [];\n    var nodes = [];\n    // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n    if (this.destroyed) {\n        return;\n    }\n    // use cache by default for perf\n    if (useCache === undefined) {\n        useCache = true;\n    }\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        // an edge may be implicitly dirty b/c of one of its connected nodes\n        // (and a request for recalc may come in between frames)\n        if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n            rstyle.clean = false;\n        }\n        if (ele.isEdge() && ele.isBundledBezier()) {\n            if (ele.parallelEdges().some(function(ele) {\n                return !ele._private.rstyle.clean && ele.isBundledBezier();\n            })) {\n                rstyle.clean = false;\n            }\n        }\n        // only update if dirty and in graph\n        if (useCache && rstyle.clean || ele.removed()) {\n            continue;\n        }\n        // only update if not display: none\n        if (ele.pstyle(\"display\").value === \"none\") {\n            continue;\n        }\n        if (_p.group === \"nodes\") {\n            nodes.push(ele);\n        } else {\n            // edges\n            edges.push(ele);\n        }\n        rstyle.clean = true;\n    }\n    // update node data from projections\n    for(var _i2 = 0; _i2 < nodes.length; _i2++){\n        var _ele = nodes[_i2];\n        var _p2 = _ele._private;\n        var _rstyle = _p2.rstyle;\n        var pos = _ele.position();\n        this.recalculateNodeLabelProjection(_ele);\n        _rstyle.nodeX = pos.x;\n        _rstyle.nodeY = pos.y;\n        _rstyle.nodeW = _ele.pstyle(\"width\").pfValue;\n        _rstyle.nodeH = _ele.pstyle(\"height\").pfValue;\n    }\n    this.recalculateEdgeProjections(edges);\n    // update edge data from projections\n    for(var _i3 = 0; _i3 < edges.length; _i3++){\n        var _ele2 = edges[_i3];\n        var _p3 = _ele2._private;\n        var _rstyle2 = _p3.rstyle;\n        var rs = _p3.rscratch;\n        // update rstyle positions\n        _rstyle2.srcX = rs.arrowStartX;\n        _rstyle2.srcY = rs.arrowStartY;\n        _rstyle2.tgtX = rs.arrowEndX;\n        _rstyle2.tgtY = rs.arrowEndY;\n        _rstyle2.midX = rs.midX;\n        _rstyle2.midY = rs.midY;\n        _rstyle2.labelAngle = rs.labelAngle;\n        _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n        _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n    }\n};\nvar BRp$6 = {};\nBRp$6.updateCachedGrabbedEles = function() {\n    var eles = this.cachedZSortedEles;\n    if (!eles) {\n        // just let this be recalculated on the next z sort tick\n        return;\n    }\n    eles.drag = [];\n    eles.nondrag = [];\n    var grabTargets = [];\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var rs = ele._private.rscratch;\n        if (ele.grabbed() && !ele.isParent()) {\n            grabTargets.push(ele);\n        } else if (rs.inDragLayer) {\n            eles.drag.push(ele);\n        } else {\n            eles.nondrag.push(ele);\n        }\n    }\n    // put the grab target nodes last so it's on top of its neighbourhood\n    for(var i = 0; i < grabTargets.length; i++){\n        var ele = grabTargets[i];\n        eles.drag.push(ele);\n    }\n};\nBRp$6.invalidateCachedZSortedEles = function() {\n    this.cachedZSortedEles = null;\n};\nBRp$6.getCachedZSortedEles = function(forceRecalc) {\n    if (forceRecalc || !this.cachedZSortedEles) {\n        var eles = this.cy.mutableElements().toArray();\n        eles.sort(zIndexSort);\n        eles.interactive = eles.filter(function(ele) {\n            return ele.interactive();\n        });\n        this.cachedZSortedEles = eles;\n        this.updateCachedGrabbedEles();\n    } else {\n        eles = this.cachedZSortedEles;\n    }\n    return eles;\n};\nvar BRp$5 = {};\n[\n    BRp$e,\n    BRp$d,\n    BRp$c,\n    BRp$b,\n    BRp$a,\n    BRp$9,\n    BRp$8,\n    BRp$7,\n    BRp$6\n].forEach(function(props) {\n    extend(BRp$5, props);\n});\nvar BRp$4 = {};\nBRp$4.getCachedImage = function(url, crossOrigin, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n    var cache = imageCache[url];\n    if (cache) {\n        if (!cache.image.complete) {\n            cache.image.addEventListener(\"load\", onLoad);\n        }\n        return cache.image;\n    } else {\n        cache = imageCache[url] = imageCache[url] || {};\n        var image = cache.image = new Image(); // eslint-disable-line no-undef\n        image.addEventListener(\"load\", onLoad);\n        image.addEventListener(\"error\", function() {\n            image.error = true;\n        });\n        // #1582 safari doesn't load data uris with crossOrigin properly\n        // https://bugs.webkit.org/show_bug.cgi?id=123978\n        var dataUriPrefix = \"data:\";\n        var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n        if (!isDataUri) {\n            // if crossorigin is 'null'(stringified), then manually set it to null \n            crossOrigin = crossOrigin === \"null\" ? null : crossOrigin;\n            image.crossOrigin = crossOrigin; // prevent tainted canvas\n        }\n        image.src = url;\n        return image;\n    }\n};\nvar BRp$3 = {};\n/* global document, ResizeObserver, MutationObserver */ BRp$3.registerBinding = function(target, event, handler, useCapture) {\n    // eslint-disable-line no-unused-vars\n    var args = Array.prototype.slice.apply(arguments, [\n        1\n    ]); // copy\n    if (Array.isArray(target)) {\n        var res = [];\n        for(var i = 0; i < target.length; i++){\n            var t = target[i];\n            if (t !== undefined) {\n                var b = this.binder(t);\n                res.push(b.on.apply(b, args));\n            }\n        }\n        return res;\n    }\n    var b = this.binder(target);\n    return b.on.apply(b, args);\n};\nBRp$3.binder = function(tgt) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);\n    if (r.supportsPassiveEvents == null) {\n        // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n        var supportsPassive = false;\n        try {\n            var opts = Object.defineProperty({}, \"passive\", {\n                get: function get() {\n                    supportsPassive = true;\n                    return true;\n                }\n            });\n            containerWindow.addEventListener(\"test\", null, opts);\n        } catch (err) {\n        // not supported\n        }\n        r.supportsPassiveEvents = supportsPassive;\n    }\n    var on = function on(event, handler, useCapture) {\n        var args = Array.prototype.slice.call(arguments);\n        if (tgtIsDom && r.supportsPassiveEvents) {\n            // replace useCapture w/ opts obj\n            args[2] = {\n                capture: useCapture != null ? useCapture : false,\n                passive: false,\n                once: false\n            };\n        }\n        r.bindings.push({\n            target: tgt,\n            args: args\n        });\n        (tgt.addEventListener || tgt.on).apply(tgt, args);\n        return this;\n    };\n    return {\n        on: on,\n        addEventListener: on,\n        addListener: on,\n        bind: on\n    };\n};\nBRp$3.nodeIsDraggable = function(node) {\n    return node && node.isNode() && !node.locked() && node.grabbable();\n};\nBRp$3.nodeIsGrabbable = function(node) {\n    return this.nodeIsDraggable(node) && node.interactive();\n};\nBRp$3.load = function() {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var isSelected = function isSelected(ele) {\n        return ele.selected();\n    };\n    var getShadowRoot = function getShadowRoot(element) {\n        var rootNode = element.getRootNode();\n        // Check if the root node is a shadow root\n        if (rootNode && rootNode.nodeType === 11 && rootNode.host !== undefined) {\n            return rootNode;\n        }\n    };\n    var triggerEvents = function triggerEvents(target, names, e, position) {\n        if (target == null) {\n            target = r.cy;\n        }\n        for(var i = 0; i < names.length; i++){\n            var name = names[i];\n            target.emit({\n                originalEvent: e,\n                type: name,\n                position: position\n            });\n        }\n    };\n    var isMultSelKeyDown = function isMultSelKeyDown(e) {\n        return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n    };\n    var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n        var allowPassthrough = true;\n        if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n            // a grabbable compound node below the ele => no passthrough panning\n            for(var i = 0; downs && i < downs.length; i++){\n                var down = downs[i];\n                //if any parent node in event hierarchy isn't pannable, reject passthrough\n                if (down.isNode() && down.isParent() && !down.pannable()) {\n                    allowPassthrough = false;\n                    break;\n                }\n            }\n        } else {\n            allowPassthrough = true;\n        }\n        return allowPassthrough;\n    };\n    var setGrabbed = function setGrabbed(ele) {\n        ele[0]._private.grabbed = true;\n    };\n    var setFreed = function setFreed(ele) {\n        ele[0]._private.grabbed = false;\n    };\n    var setInDragLayer = function setInDragLayer(ele) {\n        ele[0]._private.rscratch.inDragLayer = true;\n    };\n    var setOutDragLayer = function setOutDragLayer(ele) {\n        ele[0]._private.rscratch.inDragLayer = false;\n    };\n    var setGrabTarget = function setGrabTarget(ele) {\n        ele[0]._private.rscratch.isGrabTarget = true;\n    };\n    var removeGrabTarget = function removeGrabTarget(ele) {\n        ele[0]._private.rscratch.isGrabTarget = false;\n    };\n    var addToDragList = function addToDragList(ele, opts) {\n        var list = opts.addToList;\n        var listHasEle = list.has(ele);\n        if (!listHasEle && ele.grabbable() && !ele.locked()) {\n            list.merge(ele);\n            setGrabbed(ele);\n        }\n    };\n    // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n    var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n        if (!node.cy().hasCompoundNodes()) {\n            return;\n        }\n        if (opts.inDragLayer == null && opts.addToList == null) {\n            return;\n        } // nothing to do\n        var innerNodes = node.descendants();\n        if (opts.inDragLayer) {\n            innerNodes.forEach(setInDragLayer);\n            innerNodes.connectedEdges().forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            addToDragList(innerNodes, opts);\n        }\n    };\n    // adds the given nodes and its neighbourhood to the drag layer\n    var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n        opts = opts || {};\n        var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n        if (opts.inDragLayer) {\n            nodes.forEach(setInDragLayer);\n            nodes.neighborhood().stdFilter(function(ele) {\n                return !hasCompoundNodes || ele.isEdge();\n            }).forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            nodes.forEach(function(ele) {\n                addToDragList(ele, opts);\n            });\n        }\n        addDescendantsToDrag(nodes, opts); // always add to drag\n        // also add nodes and edges related to the topmost ancestor\n        updateAncestorsInDragLayer(nodes, {\n            inDragLayer: opts.inDragLayer\n        });\n        r.updateCachedGrabbedEles();\n    };\n    var addNodeToDrag = addNodesToDrag;\n    var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n        if (!grabbedEles) {\n            return;\n        }\n        // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n        r.getCachedZSortedEles().forEach(function(ele) {\n            setFreed(ele);\n            setOutDragLayer(ele);\n            removeGrabTarget(ele);\n        });\n        r.updateCachedGrabbedEles();\n    };\n    // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n    var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n        if (opts.inDragLayer == null && opts.addToList == null) {\n            return;\n        } // nothing to do\n        if (!node.cy().hasCompoundNodes()) {\n            return;\n        }\n        // find top-level parent\n        var parent = node.ancestors().orphans();\n        // no parent node: no nodes to add to the drag layer\n        if (parent.same(node)) {\n            return;\n        }\n        var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n        var edges = nodes.connectedEdges();\n        if (opts.inDragLayer) {\n            edges.forEach(setInDragLayer);\n            nodes.forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            nodes.forEach(function(ele) {\n                addToDragList(ele, opts);\n            });\n        }\n    };\n    var blurActiveDomElement = function blurActiveDomElement() {\n        if (document.activeElement != null && document.activeElement.blur != null) {\n            document.activeElement.blur();\n        }\n    };\n    var haveMutationsApi = typeof MutationObserver !== \"undefined\";\n    var haveResizeObserverApi = typeof ResizeObserver !== \"undefined\";\n    // watch for when the cy container is removed from the dom\n    if (haveMutationsApi) {\n        r.removeObserver = new MutationObserver(function(mutns) {\n            // eslint-disable-line no-undef\n            for(var i = 0; i < mutns.length; i++){\n                var mutn = mutns[i];\n                var rNodes = mutn.removedNodes;\n                if (rNodes) {\n                    for(var j = 0; j < rNodes.length; j++){\n                        var rNode = rNodes[j];\n                        if (rNode === r.container) {\n                            r.destroy();\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        if (r.container.parentNode) {\n            r.removeObserver.observe(r.container.parentNode, {\n                childList: true\n            });\n        }\n    } else {\n        r.registerBinding(r.container, \"DOMNodeRemoved\", function(e) {\n            // eslint-disable-line no-unused-vars\n            r.destroy();\n        });\n    }\n    var onResize = debounce(function() {\n        r.cy.resize();\n    }, 100);\n    if (haveMutationsApi) {\n        r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n        r.styleObserver.observe(r.container, {\n            attributes: true\n        });\n    }\n    // auto resize\n    r.registerBinding(containerWindow, \"resize\", onResize); // eslint-disable-line no-undef\n    if (haveResizeObserverApi) {\n        r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n        r.resizeObserver.observe(r.container);\n    }\n    var forEachUp = function forEachUp(domEle, fn) {\n        while(domEle != null){\n            fn(domEle);\n            domEle = domEle.parentNode;\n        }\n    };\n    var invalidateCoords = function invalidateCoords() {\n        r.invalidateContainerClientCoordsCache();\n    };\n    forEachUp(r.container, function(domEle) {\n        r.registerBinding(domEle, \"transitionend\", invalidateCoords);\n        r.registerBinding(domEle, \"animationend\", invalidateCoords);\n        r.registerBinding(domEle, \"scroll\", invalidateCoords);\n    });\n    // stop right click menu from appearing on cy\n    r.registerBinding(r.container, \"contextmenu\", function(e) {\n        e.preventDefault();\n    });\n    var inBoxSelection = function inBoxSelection() {\n        return r.selection[4] !== 0;\n    };\n    var eventInContainer = function eventInContainer(e) {\n        // save cycles if mouse events aren't to be captured\n        var containerPageCoords = r.findContainerClientCoords();\n        var x = containerPageCoords[0];\n        var y = containerPageCoords[1];\n        var width = containerPageCoords[2];\n        var height = containerPageCoords[3];\n        var positions = e.touches ? e.touches : [\n            e\n        ];\n        var atLeastOnePosInside = false;\n        for(var i = 0; i < positions.length; i++){\n            var p = positions[i];\n            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n                atLeastOnePosInside = true;\n                break;\n            }\n        }\n        if (!atLeastOnePosInside) {\n            return false;\n        }\n        var container = r.container;\n        var target = e.target;\n        var tParent = target.parentNode;\n        var containerIsTarget = false;\n        while(tParent){\n            if (tParent === container) {\n                containerIsTarget = true;\n                break;\n            }\n            tParent = tParent.parentNode;\n        }\n        if (!containerIsTarget) {\n            return false;\n        } // if target is outisde cy container, then this event is not for us\n        return true;\n    };\n    // Primary key\n    r.registerBinding(r.container, \"mousedown\", function mousedownHandler(e) {\n        if (!eventInContainer(e)) {\n            return;\n        }\n        // during left mouse button gestures, ignore other buttons\n        if (r.hoverData.which === 1 && e.which !== 1) {\n            return;\n        }\n        e.preventDefault();\n        blurActiveDomElement();\n        r.hoverData.capture = true;\n        r.hoverData.which = e.which;\n        var cy = r.cy;\n        var gpos = [\n            e.clientX,\n            e.clientY\n        ];\n        var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n        var select = r.selection;\n        var nears = r.findNearestElements(pos[0], pos[1], true, false);\n        var near = nears[0];\n        var draggedElements = r.dragData.possibleDragElements;\n        r.hoverData.mdownPos = pos;\n        r.hoverData.mdownGPos = gpos;\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        var checkForTaphold = function checkForTaphold() {\n            r.hoverData.tapholdCancelled = false;\n            clearTimeout(r.hoverData.tapholdTimeout);\n            r.hoverData.tapholdTimeout = setTimeout(function() {\n                if (r.hoverData.tapholdCancelled) {\n                    return;\n                } else {\n                    var ele = r.hoverData.down;\n                    if (ele) {\n                        ele.emit(makeEvent(\"taphold\"));\n                    } else {\n                        cy.emit(makeEvent(\"taphold\"));\n                    }\n                }\n            }, r.tapholdDuration);\n        };\n        // Right click button\n        if (e.which == 3) {\n            r.hoverData.cxtStarted = true;\n            var cxtEvt = {\n                originalEvent: e,\n                type: \"cxttapstart\",\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n            if (near) {\n                near.activate();\n                near.emit(cxtEvt);\n                r.hoverData.down = near;\n            } else {\n                cy.emit(cxtEvt);\n            }\n            r.hoverData.downTime = new Date().getTime();\n            r.hoverData.cxtDragged = false;\n        // Primary button\n        } else if (e.which == 1) {\n            if (near) {\n                near.activate();\n            }\n            // Element dragging\n            {\n                // If something is under the cursor and it is draggable, prepare to grab it\n                if (near != null) {\n                    if (r.nodeIsGrabbable(near)) {\n                        var triggerGrab = function triggerGrab(ele) {\n                            ele.emit(makeEvent(\"grab\"));\n                        };\n                        setGrabTarget(near);\n                        if (!near.selected()) {\n                            draggedElements = r.dragData.possibleDragElements = cy.collection();\n                            addNodeToDrag(near, {\n                                addToList: draggedElements\n                            });\n                            near.emit(makeEvent(\"grabon\")).emit(makeEvent(\"grab\"));\n                        } else {\n                            draggedElements = r.dragData.possibleDragElements = cy.collection();\n                            var selectedNodes = cy.$(function(ele) {\n                                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n                            });\n                            addNodesToDrag(selectedNodes, {\n                                addToList: draggedElements\n                            });\n                            near.emit(makeEvent(\"grabon\"));\n                            selectedNodes.forEach(triggerGrab);\n                        }\n                        r.redrawHint(\"eles\", true);\n                        r.redrawHint(\"drag\", true);\n                    }\n                }\n                r.hoverData.down = near;\n                r.hoverData.downs = nears;\n                r.hoverData.downTime = new Date().getTime();\n            }\n            triggerEvents(near, [\n                \"mousedown\",\n                \"tapstart\",\n                \"vmousedown\"\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            if (near == null) {\n                select[4] = 1;\n                r.data.bgActivePosistion = {\n                    x: pos[0],\n                    y: pos[1]\n                };\n                r.redrawHint(\"select\", true);\n                r.redraw();\n            } else if (near.pannable()) {\n                select[4] = 1; // for future pan\n            }\n            checkForTaphold();\n        }\n        // Initialize selection box coordinates\n        select[0] = select[2] = pos[0];\n        select[1] = select[3] = pos[1];\n    }, false);\n    var shadowRoot = getShadowRoot(r.container);\n    r.registerBinding([\n        containerWindow,\n        shadowRoot\n    ], \"mousemove\", function mousemoveHandler(e) {\n        // eslint-disable-line no-undef\n        var capture = r.hoverData.capture;\n        if (!capture && !eventInContainer(e)) {\n            return;\n        }\n        var preventDefault = false;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var gpos = [\n            e.clientX,\n            e.clientY\n        ];\n        var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n        var mdownPos = r.hoverData.mdownPos;\n        var mdownGPos = r.hoverData.mdownGPos;\n        var select = r.selection;\n        var near = null;\n        if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n            near = r.findNearestElement(pos[0], pos[1], true, false);\n        }\n        var last = r.hoverData.last;\n        var down = r.hoverData.down;\n        var disp = [\n            pos[0] - select[2],\n            pos[1] - select[3]\n        ];\n        var draggedElements = r.dragData.possibleDragElements;\n        var isOverThresholdDrag;\n        if (mdownGPos) {\n            var dx = gpos[0] - mdownGPos[0];\n            var dx2 = dx * dx;\n            var dy = gpos[1] - mdownGPos[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n        }\n        var multSelKeyDown = isMultSelKeyDown(e);\n        if (isOverThresholdDrag) {\n            r.hoverData.tapholdCancelled = true;\n        }\n        var updateDragDelta = function updateDragDelta() {\n            var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n            if (dragDelta.length === 0) {\n                dragDelta.push(disp[0]);\n                dragDelta.push(disp[1]);\n            } else {\n                dragDelta[0] += disp[0];\n                dragDelta[1] += disp[1];\n            }\n        };\n        preventDefault = true;\n        triggerEvents(near, [\n            \"mousemove\",\n            \"vmousemove\",\n            \"tapdrag\"\n        ], e, {\n            x: pos[0],\n            y: pos[1]\n        });\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        var goIntoBoxMode = function goIntoBoxMode() {\n            r.data.bgActivePosistion = undefined;\n            if (!r.hoverData.selecting) {\n                cy.emit(makeEvent(\"boxstart\"));\n            }\n            select[4] = 1;\n            r.hoverData.selecting = true;\n            r.redrawHint(\"select\", true);\n            r.redraw();\n        };\n        // trigger context drag if rmouse down\n        if (r.hoverData.which === 3) {\n            // but only if over threshold\n            if (isOverThresholdDrag) {\n                var cxtEvt = makeEvent(\"cxtdrag\");\n                if (down) {\n                    down.emit(cxtEvt);\n                } else {\n                    cy.emit(cxtEvt);\n                }\n                r.hoverData.cxtDragged = true;\n                if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n                    if (r.hoverData.cxtOver) {\n                        r.hoverData.cxtOver.emit(makeEvent(\"cxtdragout\"));\n                    }\n                    r.hoverData.cxtOver = near;\n                    if (near) {\n                        near.emit(makeEvent(\"cxtdragover\"));\n                    }\n                }\n            }\n        // Check if we are drag panning the entire graph\n        } else if (r.hoverData.dragging) {\n            preventDefault = true;\n            if (cy.panningEnabled() && cy.userPanningEnabled()) {\n                var deltaP;\n                if (r.hoverData.justStartedPan) {\n                    var mdPos = r.hoverData.mdownPos;\n                    deltaP = {\n                        x: (pos[0] - mdPos[0]) * zoom,\n                        y: (pos[1] - mdPos[1]) * zoom\n                    };\n                    r.hoverData.justStartedPan = false;\n                } else {\n                    deltaP = {\n                        x: disp[0] * zoom,\n                        y: disp[1] * zoom\n                    };\n                }\n                cy.panBy(deltaP);\n                cy.emit(makeEvent(\"dragpan\"));\n                r.hoverData.dragged = true;\n            }\n            // Needs reproject due to pan changing viewport\n            pos = r.projectIntoViewport(e.clientX, e.clientY);\n        // Checks primary button down & out of time & mouse not moved much\n        } else if (select[4] == 1 && (down == null || down.pannable())) {\n            if (isOverThresholdDrag) {\n                if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n                    goIntoBoxMode();\n                } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n                    var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n                    if (allowPassthrough) {\n                        r.hoverData.dragging = true;\n                        r.hoverData.justStartedPan = true;\n                        select[4] = 0;\n                        r.data.bgActivePosistion = array2point(mdownPos);\n                        r.redrawHint(\"select\", true);\n                        r.redraw();\n                    }\n                }\n                if (down && down.pannable() && down.active()) {\n                    down.unactivate();\n                }\n            }\n        } else {\n            if (down && down.pannable() && down.active()) {\n                down.unactivate();\n            }\n            if ((!down || !down.grabbed()) && near != last) {\n                if (last) {\n                    triggerEvents(last, [\n                        \"mouseout\",\n                        \"tapdragout\"\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                }\n                if (near) {\n                    triggerEvents(near, [\n                        \"mouseover\",\n                        \"tapdragover\"\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                }\n                r.hoverData.last = near;\n            }\n            if (down) {\n                if (isOverThresholdDrag) {\n                    // then we can take action\n                    if (cy.boxSelectionEnabled() && multSelKeyDown) {\n                        // then selection overrides\n                        if (down && down.grabbed()) {\n                            freeDraggedElements(draggedElements);\n                            down.emit(makeEvent(\"freeon\"));\n                            draggedElements.emit(makeEvent(\"free\"));\n                            if (r.dragData.didDrag) {\n                                down.emit(makeEvent(\"dragfreeon\"));\n                                draggedElements.emit(makeEvent(\"dragfree\"));\n                            }\n                        }\n                        goIntoBoxMode();\n                    } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n                        // drag node\n                        var justStartedDrag = !r.dragData.didDrag;\n                        if (justStartedDrag) {\n                            r.redrawHint(\"eles\", true);\n                        }\n                        r.dragData.didDrag = true; // indicate that we actually did drag the node\n                        // now, add the elements to the drag layer if not done already\n                        if (!r.hoverData.draggingEles) {\n                            addNodesToDrag(draggedElements, {\n                                inDragLayer: true\n                            });\n                        }\n                        var totalShift = {\n                            x: 0,\n                            y: 0\n                        };\n                        if (number$1(disp[0]) && number$1(disp[1])) {\n                            totalShift.x += disp[0];\n                            totalShift.y += disp[1];\n                            if (justStartedDrag) {\n                                var dragDelta = r.hoverData.dragDelta;\n                                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                    totalShift.x += dragDelta[0];\n                                    totalShift.y += dragDelta[1];\n                                }\n                            }\n                        }\n                        r.hoverData.draggingEles = true;\n                        draggedElements.silentShift(totalShift).emit(makeEvent(\"position\")).emit(makeEvent(\"drag\"));\n                        r.redrawHint(\"drag\", true);\n                        r.redraw();\n                    }\n                } else {\n                    // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n                    updateDragDelta();\n                }\n            }\n            // prevent the dragging from triggering text selection on the page\n            preventDefault = true;\n        }\n        select[2] = pos[0];\n        select[3] = pos[1];\n        if (preventDefault) {\n            if (e.stopPropagation) e.stopPropagation();\n            if (e.preventDefault) e.preventDefault();\n            return false;\n        }\n    }, false);\n    var clickTimeout, didDoubleClick, prevClickTimeStamp;\n    r.registerBinding(containerWindow, \"mouseup\", function mouseupHandler(e) {\n        // eslint-disable-line no-undef\n        // during left mouse button gestures, ignore other buttons\n        if (r.hoverData.which === 1 && e.which !== 1 && r.hoverData.capture) {\n            return;\n        }\n        var capture = r.hoverData.capture;\n        if (!capture) {\n            return;\n        }\n        r.hoverData.capture = false;\n        var cy = r.cy;\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        var select = r.selection;\n        var near = r.findNearestElement(pos[0], pos[1], true, false);\n        var draggedElements = r.dragData.possibleDragElements;\n        var down = r.hoverData.down;\n        var multSelKeyDown = isMultSelKeyDown(e);\n        if (r.data.bgActivePosistion) {\n            r.redrawHint(\"select\", true);\n            r.redraw();\n        }\n        r.hoverData.tapholdCancelled = true;\n        r.data.bgActivePosistion = undefined; // not active bg now\n        if (down) {\n            down.unactivate();\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        if (r.hoverData.which === 3) {\n            var cxtEvt = makeEvent(\"cxttapend\");\n            if (down) {\n                down.emit(cxtEvt);\n            } else {\n                cy.emit(cxtEvt);\n            }\n            if (!r.hoverData.cxtDragged) {\n                var cxtTap = makeEvent(\"cxttap\");\n                if (down) {\n                    down.emit(cxtTap);\n                } else {\n                    cy.emit(cxtTap);\n                }\n            }\n            r.hoverData.cxtDragged = false;\n            r.hoverData.which = null;\n        } else if (r.hoverData.which === 1) {\n            triggerEvents(near, [\n                \"mouseup\",\n                \"tapend\",\n                \"vmouseup\"\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            if (!r.dragData.didDrag && // didn't move a node around\n            !r.hoverData.dragged && // didn't pan\n            !r.hoverData.selecting && // not box selection\n            !r.hoverData.isOverThresholdDrag // didn't move too much\n            ) {\n                triggerEvents(down, [\n                    \"click\",\n                    \"tap\",\n                    \"vclick\"\n                ], e, {\n                    x: pos[0],\n                    y: pos[1]\n                });\n                didDoubleClick = false;\n                if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n                    clickTimeout && clearTimeout(clickTimeout);\n                    didDoubleClick = true;\n                    prevClickTimeStamp = null;\n                    triggerEvents(down, [\n                        \"dblclick\",\n                        \"dbltap\",\n                        \"vdblclick\"\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                } else {\n                    clickTimeout = setTimeout(function() {\n                        if (didDoubleClick) return;\n                        triggerEvents(down, [\n                            \"oneclick\",\n                            \"onetap\",\n                            \"voneclick\"\n                        ], e, {\n                            x: pos[0],\n                            y: pos[1]\n                        });\n                    }, cy.multiClickDebounceTime());\n                    prevClickTimeStamp = e.timeStamp;\n                }\n            }\n            // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n            if (down == null // not mousedown on node\n             && !r.dragData.didDrag // didn't move the node around\n             && !r.hoverData.selecting // not box selection\n             && !r.hoverData.dragged // didn't pan\n             && !isMultSelKeyDown(e)) {\n                cy.$(isSelected).unselect([\n                    \"tapunselect\"\n                ]);\n                if (draggedElements.length > 0) {\n                    r.redrawHint(\"eles\", true);\n                }\n                r.dragData.possibleDragElements = draggedElements = cy.collection();\n            }\n            // Single selection\n            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n                if (near != null && near._private.selectable) {\n                    if (r.hoverData.dragging) ;\n                    else if (cy.selectionType() === \"additive\" || multSelKeyDown) {\n                        if (near.selected()) {\n                            near.unselect([\n                                \"tapunselect\"\n                            ]);\n                        } else {\n                            near.select([\n                                \"tapselect\"\n                            ]);\n                        }\n                    } else {\n                        if (!multSelKeyDown) {\n                            cy.$(isSelected).unmerge(near).unselect([\n                                \"tapunselect\"\n                            ]);\n                            near.select([\n                                \"tapselect\"\n                            ]);\n                        }\n                    }\n                    r.redrawHint(\"eles\", true);\n                }\n            }\n            if (r.hoverData.selecting) {\n                var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n                r.redrawHint(\"select\", true);\n                if (box.length > 0) {\n                    r.redrawHint(\"eles\", true);\n                }\n                cy.emit(makeEvent(\"boxend\"));\n                var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                    return ele.selectable() && !ele.selected();\n                };\n                if (cy.selectionType() === \"additive\") {\n                    box.emit(makeEvent(\"box\")).stdFilter(eleWouldBeSelected).select().emit(makeEvent(\"boxselect\"));\n                } else {\n                    if (!multSelKeyDown) {\n                        cy.$(isSelected).unmerge(box).unselect();\n                    }\n                    box.emit(makeEvent(\"box\")).stdFilter(eleWouldBeSelected).select().emit(makeEvent(\"boxselect\"));\n                }\n                // always need redraw in case eles unselectable\n                r.redraw();\n            }\n            // Cancel drag pan\n            if (r.hoverData.dragging) {\n                r.hoverData.dragging = false;\n                r.redrawHint(\"select\", true);\n                r.redrawHint(\"eles\", true);\n                r.redraw();\n            }\n            if (!select[4]) {\n                r.redrawHint(\"drag\", true);\n                r.redrawHint(\"eles\", true);\n                var downWasGrabbed = down && down.grabbed();\n                freeDraggedElements(draggedElements);\n                if (downWasGrabbed) {\n                    down.emit(makeEvent(\"freeon\"));\n                    draggedElements.emit(makeEvent(\"free\"));\n                    if (r.dragData.didDrag) {\n                        down.emit(makeEvent(\"dragfreeon\"));\n                        draggedElements.emit(makeEvent(\"dragfree\"));\n                    }\n                }\n            }\n        } // else not right mouse\n        select[4] = 0;\n        r.hoverData.down = null;\n        r.hoverData.cxtStarted = false;\n        r.hoverData.draggingEles = false;\n        r.hoverData.selecting = false;\n        r.hoverData.isOverThresholdDrag = false;\n        r.dragData.didDrag = false;\n        r.hoverData.dragged = false;\n        r.hoverData.dragDelta = [];\n        r.hoverData.mdownPos = null;\n        r.hoverData.mdownGPos = null;\n        r.hoverData.which = null;\n    }, false);\n    var wheelDeltas = []; // log of first N wheel deltas\n    var wheelDeltaN = 4; // how many events to log\n    var inaccurateScrollDevice;\n    var inaccurateScrollFactor = 100000; // base of inaccurate wheel deltas (e.g. base 5 could yield wheels of 10, 25, 50, etc.)\n    var allAreDivisibleBy = function allAreDivisibleBy(list, factor) {\n        for(var i = 0; i < list.length; i++){\n            if (list[i] % factor !== 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var allAreSameMagnitude = function allAreSameMagnitude(list) {\n        var firstMag = Math.abs(list[0]);\n        for(var i = 1; i < list.length; i++){\n            if (Math.abs(list[i]) !== firstMag) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var wheelHandler = function wheelHandler(e) {\n        var clamp = false;\n        var delta = e.deltaY;\n        if (delta == null) {\n            // compatibility with old browsers\n            if (e.wheelDeltaY != null) {\n                delta = e.wheelDeltaY / 4;\n            } else if (e.wheelDelta != null) {\n                delta = e.wheelDelta / 4;\n            }\n        }\n        if (delta === 0) {\n            return; // no change in zoom (Bug: Zoom becomes erratic on rapid scroll due to deltaY: 0 event #3394)\n        }\n        if (inaccurateScrollDevice == null) {\n            if (wheelDeltas.length >= wheelDeltaN) {\n                // use log to determine if inaccurate\n                var wds = wheelDeltas;\n                inaccurateScrollDevice = allAreDivisibleBy(wds, 5);\n                if (!inaccurateScrollDevice) {\n                    // check for all large values of exact same magnitude\n                    var firstMag = Math.abs(wds[0]);\n                    inaccurateScrollDevice = allAreSameMagnitude(wds) && firstMag > 5;\n                }\n                if (inaccurateScrollDevice) {\n                    for(var i = 0; i < wds.length; i++){\n                        inaccurateScrollFactor = Math.min(Math.abs(wds[i]), inaccurateScrollFactor);\n                    }\n                }\n            // console.log('Sampled wheel deltas:', wds);\n            // console.log('inaccurateScrollDevice:', inaccurateScrollDevice);\n            // console.log('inaccurateScrollFactor:', inaccurateScrollFactor);\n            } else {\n                // clamp and log until we reach N\n                wheelDeltas.push(delta);\n                clamp = true;\n            // console.log('Clamping initial wheel events until we get a good sample');\n            }\n        } else if (inaccurateScrollDevice) {\n            // keep updating\n            inaccurateScrollFactor = Math.min(Math.abs(delta), inaccurateScrollFactor);\n        // console.log('Keep updating inaccurateScrollFactor beyond sample in case we did not get the smallest possible val:', inaccurateScrollFactor);\n        }\n        if (r.scrollingPage) {\n            return;\n        } // while scrolling, ignore wheel-to-zoom\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        var rpos = [\n            pos[0] * zoom + pan.x,\n            pos[1] * zoom + pan.y\n        ];\n        if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n            // if pan dragging or cxt dragging, wheel movements make no zoom\n            e.preventDefault();\n            return;\n        }\n        if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n            e.preventDefault();\n            r.data.wheelZooming = true;\n            clearTimeout(r.data.wheelTimeout);\n            r.data.wheelTimeout = setTimeout(function() {\n                r.data.wheelZooming = false;\n                r.redrawHint(\"eles\", true);\n                r.redraw();\n            }, 150);\n            var diff;\n            if (clamp && Math.abs(delta) > 5) {\n                delta = signum(delta) * 5;\n            }\n            diff = delta / -250;\n            if (inaccurateScrollDevice) {\n                diff /= inaccurateScrollFactor;\n                diff *= 3;\n            }\n            diff = diff * r.wheelSensitivity;\n            // console.log(`delta = ${delta}, diff = ${diff}, mode = ${e.deltaMode}`)\n            var needsWheelFix = e.deltaMode === 1;\n            if (needsWheelFix) {\n                // fixes slow wheel events on ff/linux and ff/windows\n                diff *= 33;\n            }\n            var newZoom = cy.zoom() * Math.pow(10, diff);\n            if (e.type === \"gesturechange\") {\n                newZoom = r.gestureStartZoom * e.scale;\n            }\n            cy.zoom({\n                level: newZoom,\n                renderedPosition: {\n                    x: rpos[0],\n                    y: rpos[1]\n                }\n            });\n            cy.emit({\n                type: e.type === \"gesturechange\" ? \"pinchzoom\" : \"scrollzoom\",\n                originalEvent: e,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            });\n        }\n    };\n    // Functions to help with whether mouse wheel should trigger zooming\n    // --\n    r.registerBinding(r.container, \"wheel\", wheelHandler, true);\n    // disable nonstandard wheel events\n    // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n    r.registerBinding(containerWindow, \"scroll\", function scrollHandler(e) {\n        // eslint-disable-line no-unused-vars\n        r.scrollingPage = true;\n        clearTimeout(r.scrollingPageTimeout);\n        r.scrollingPageTimeout = setTimeout(function() {\n            r.scrollingPage = false;\n        }, 250);\n    }, true);\n    // desktop safari pinch to zoom start\n    r.registerBinding(r.container, \"gesturestart\", function gestureStartHandler(e) {\n        r.gestureStartZoom = r.cy.zoom();\n        if (!r.hasTouchStarted) {\n            // don't affect touch devices like iphone\n            e.preventDefault();\n        }\n    }, true);\n    r.registerBinding(r.container, \"gesturechange\", function(e) {\n        if (!r.hasTouchStarted) {\n            // don't affect touch devices like iphone\n            wheelHandler(e);\n        }\n    }, true);\n    // Functions to help with handling mouseout/mouseover on the Cytoscape container\n    // Handle mouseout on Cytoscape container\n    r.registerBinding(r.container, \"mouseout\", function mouseOutHandler(e) {\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        r.cy.emit({\n            originalEvent: e,\n            type: \"mouseout\",\n            position: {\n                x: pos[0],\n                y: pos[1]\n            }\n        });\n    }, false);\n    r.registerBinding(r.container, \"mouseover\", function mouseOverHandler(e) {\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        r.cy.emit({\n            originalEvent: e,\n            type: \"mouseover\",\n            position: {\n                x: pos[0],\n                y: pos[1]\n            }\n        });\n    }, false);\n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n    var center1, modelCenter1; // center point on start pinch to zoom\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n    var distance = function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    };\n    var distanceSq = function distanceSq(x1, y1, x2, y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    };\n    var touchstartHandler;\n    r.registerBinding(r.container, \"touchstart\", touchstartHandler = function touchstartHandler(e) {\n        r.hasTouchStarted = true;\n        if (!eventInContainer(e)) {\n            return;\n        }\n        blurActiveDomElement();\n        r.touchData.capture = true;\n        r.data.bgActivePosistion = undefined;\n        var cy = r.cy;\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        // record starting points for pinch-to-zoom\n        if (e.touches[1]) {\n            r.touchData.singleTouchMoved = true;\n            freeDraggedElements(r.dragData.touchDragEles);\n            var offsets = r.findContainerClientCoords();\n            offsetLeft = offsets[0];\n            offsetTop = offsets[1];\n            containerWidth = offsets[2];\n            containerHeight = offsets[3];\n            f1x1 = e.touches[0].clientX - offsetLeft;\n            f1y1 = e.touches[0].clientY - offsetTop;\n            f2x1 = e.touches[1].clientX - offsetLeft;\n            f2y1 = e.touches[1].clientY - offsetTop;\n            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n            var pan = cy.pan();\n            var zoom = cy.zoom();\n            distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n            center1 = [\n                (f1x1 + f2x1) / 2,\n                (f1y1 + f2y1) / 2\n            ];\n            modelCenter1 = [\n                (center1[0] - pan.x) / zoom,\n                (center1[1] - pan.y) / zoom\n            ];\n            // consider context tap\n            var cxtDistThreshold = 200;\n            var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n                var near1 = r.findNearestElement(now[0], now[1], true, true);\n                var near2 = r.findNearestElement(now[2], now[3], true, true);\n                if (near1 && near1.isNode()) {\n                    near1.activate().emit(makeEvent(\"cxttapstart\"));\n                    r.touchData.start = near1;\n                } else if (near2 && near2.isNode()) {\n                    near2.activate().emit(makeEvent(\"cxttapstart\"));\n                    r.touchData.start = near2;\n                } else {\n                    cy.emit(makeEvent(\"cxttapstart\"));\n                }\n                if (r.touchData.start) {\n                    r.touchData.start._private.grabbed = false;\n                }\n                r.touchData.cxt = true;\n                r.touchData.cxtDragged = false;\n                r.data.bgActivePosistion = undefined;\n                r.redraw();\n                return;\n            }\n        }\n        if (e.touches[2]) {\n            // ignore\n            // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n            if (cy.boxSelectionEnabled()) {\n                e.preventDefault();\n            }\n        } else if (e.touches[1]) ;\n        else if (e.touches[0]) {\n            var nears = r.findNearestElements(now[0], now[1], true, true);\n            var near = nears[0];\n            if (near != null) {\n                near.activate();\n                r.touchData.start = near;\n                r.touchData.starts = nears;\n                if (r.nodeIsGrabbable(near)) {\n                    var draggedEles = r.dragData.touchDragEles = cy.collection();\n                    var selectedNodes = null;\n                    r.redrawHint(\"eles\", true);\n                    r.redrawHint(\"drag\", true);\n                    if (near.selected()) {\n                        // reset drag elements, since near will be added again\n                        selectedNodes = cy.$(function(ele) {\n                            return ele.selected() && r.nodeIsGrabbable(ele);\n                        });\n                        addNodesToDrag(selectedNodes, {\n                            addToList: draggedEles\n                        });\n                    } else {\n                        addNodeToDrag(near, {\n                            addToList: draggedEles\n                        });\n                    }\n                    setGrabTarget(near);\n                    near.emit(makeEvent(\"grabon\"));\n                    if (selectedNodes) {\n                        selectedNodes.forEach(function(n) {\n                            n.emit(makeEvent(\"grab\"));\n                        });\n                    } else {\n                        near.emit(makeEvent(\"grab\"));\n                    }\n                }\n            }\n            triggerEvents(near, [\n                \"touchstart\",\n                \"tapstart\",\n                \"vmousedown\"\n            ], e, {\n                x: now[0],\n                y: now[1]\n            });\n            if (near == null) {\n                r.data.bgActivePosistion = {\n                    x: pos[0],\n                    y: pos[1]\n                };\n                r.redrawHint(\"select\", true);\n                r.redraw();\n            }\n            // Tap, taphold\n            // -----\n            r.touchData.singleTouchMoved = false;\n            r.touchData.singleTouchStartTime = +new Date();\n            clearTimeout(r.touchData.tapholdTimeout);\n            r.touchData.tapholdTimeout = setTimeout(function() {\n                if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n                 && !r.touchData.selecting // box selection shouldn't allow taphold through\n                ) {\n                    triggerEvents(r.touchData.start, [\n                        \"taphold\"\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                }\n            }, r.tapholdDuration);\n        }\n        if (e.touches.length >= 1) {\n            var sPos = r.touchData.startPosition = [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ];\n            for(var i = 0; i < now.length; i++){\n                sPos[i] = earlier[i] = now[i];\n            }\n            var touch0 = e.touches[0];\n            r.touchData.startGPosition = [\n                touch0.clientX,\n                touch0.clientY\n            ];\n        }\n    }, false);\n    var touchmoveHandler;\n    r.registerBinding(containerWindow, \"touchmove\", touchmoveHandler = function touchmoveHandler(e) {\n        // eslint-disable-line no-undef\n        var capture = r.touchData.capture;\n        if (!capture && !eventInContainer(e)) {\n            return;\n        }\n        var select = r.selection;\n        var cy = r.cy;\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        var zoom = cy.zoom();\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        var startGPos = r.touchData.startGPosition;\n        var isOverThresholdDrag;\n        if (capture && e.touches[0] && startGPos) {\n            var disp = [];\n            for(var j = 0; j < now.length; j++){\n                disp[j] = now[j] - earlier[j];\n            }\n            var dx = e.touches[0].clientX - startGPos[0];\n            var dx2 = dx * dx;\n            var dy = e.touches[0].clientY - startGPos[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n        }\n        // context swipe cancelling\n        if (capture && r.touchData.cxt) {\n            e.preventDefault();\n            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n            // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n            var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n            var factorSq = distance2Sq / distance1Sq;\n            var distThreshold = 150;\n            var distThresholdSq = distThreshold * distThreshold;\n            var factorThreshold = 1.5;\n            var factorThresholdSq = factorThreshold * factorThreshold;\n            // cancel ctx gestures if the distance b/t the fingers increases\n            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n                r.touchData.cxt = false;\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint(\"select\", true);\n                var cxtEvt = makeEvent(\"cxttapend\");\n                if (r.touchData.start) {\n                    r.touchData.start.unactivate().emit(cxtEvt);\n                    r.touchData.start = null;\n                } else {\n                    cy.emit(cxtEvt);\n                }\n            }\n        }\n        // context swipe\n        if (capture && r.touchData.cxt) {\n            var cxtEvt = makeEvent(\"cxtdrag\");\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint(\"select\", true);\n            if (r.touchData.start) {\n                r.touchData.start.emit(cxtEvt);\n            } else {\n                cy.emit(cxtEvt);\n            }\n            if (r.touchData.start) {\n                r.touchData.start._private.grabbed = false;\n            }\n            r.touchData.cxtDragged = true;\n            var near = r.findNearestElement(now[0], now[1], true, true);\n            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n                if (r.touchData.cxtOver) {\n                    r.touchData.cxtOver.emit(makeEvent(\"cxtdragout\"));\n                }\n                r.touchData.cxtOver = near;\n                if (near) {\n                    near.emit(makeEvent(\"cxtdragover\"));\n                }\n            }\n        // box selection\n        } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n            e.preventDefault();\n            r.data.bgActivePosistion = undefined;\n            this.lastThreeTouch = +new Date();\n            if (!r.touchData.selecting) {\n                cy.emit(makeEvent(\"boxstart\"));\n            }\n            r.touchData.selecting = true;\n            r.touchData.didSelect = true;\n            select[4] = 1;\n            if (!select || select.length === 0 || select[0] === undefined) {\n                select[0] = (now[0] + now[2] + now[4]) / 3;\n                select[1] = (now[1] + now[3] + now[5]) / 3;\n                select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n                select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n            } else {\n                select[2] = (now[0] + now[2] + now[4]) / 3;\n                select[3] = (now[1] + now[3] + now[5]) / 3;\n            }\n            r.redrawHint(\"select\", true);\n            r.redraw();\n        // pinch to zoom\n        } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n         && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n            // two fingers => pinch to zoom\n            e.preventDefault();\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint(\"select\", true);\n            var draggedEles = r.dragData.touchDragEles;\n            if (draggedEles) {\n                r.redrawHint(\"drag\", true);\n                for(var i = 0; i < draggedEles.length; i++){\n                    var de_p = draggedEles[i]._private;\n                    de_p.grabbed = false;\n                    de_p.rscratch.inDragLayer = false;\n                }\n            }\n            var _start = r.touchData.start;\n            // (x2, y2) for fingers 1 and 2\n            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n            var distance2 = distance(f1x2, f1y2, f2x2, f2y2);\n            // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n            // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n            var factor = distance2 / distance1;\n            if (twoFingersStartInside) {\n                // delta finger1\n                var df1x = f1x2 - f1x1;\n                var df1y = f1y2 - f1y1;\n                // delta finger 2\n                var df2x = f2x2 - f2x1;\n                var df2y = f2y2 - f2y1;\n                // translation is the normalised vector of the two fingers movement\n                // i.e. so pinching cancels out and moving together pans\n                var tx = (df1x + df2x) / 2;\n                var ty = (df1y + df2y) / 2;\n                // now calculate the zoom\n                var zoom1 = cy.zoom();\n                var zoom2 = zoom1 * factor;\n                var pan1 = cy.pan();\n                // the model center point converted to the current rendered pos\n                var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n                var ctry = modelCenter1[1] * zoom1 + pan1.y;\n                var pan2 = {\n                    x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n                    y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n                };\n                // remove dragged eles\n                if (_start && _start.active()) {\n                    var draggedEles = r.dragData.touchDragEles;\n                    freeDraggedElements(draggedEles);\n                    r.redrawHint(\"drag\", true);\n                    r.redrawHint(\"eles\", true);\n                    _start.unactivate().emit(makeEvent(\"freeon\"));\n                    draggedEles.emit(makeEvent(\"free\"));\n                    if (r.dragData.didDrag) {\n                        _start.emit(makeEvent(\"dragfreeon\"));\n                        draggedEles.emit(makeEvent(\"dragfree\"));\n                    }\n                }\n                cy.viewport({\n                    zoom: zoom2,\n                    pan: pan2,\n                    cancelOnFailedZoom: true\n                });\n                cy.emit(makeEvent(\"pinchzoom\"));\n                distance1 = distance2;\n                f1x1 = f1x2;\n                f1y1 = f1y2;\n                f2x1 = f2x2;\n                f2y1 = f2y2;\n                r.pinching = true;\n            }\n            // Re-project\n            if (e.touches[0]) {\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n            if (e.touches[1]) {\n                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                now[2] = pos[0];\n                now[3] = pos[1];\n            }\n            if (e.touches[2]) {\n                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                now[4] = pos[0];\n                now[5] = pos[1];\n            }\n        } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n        ) {\n            var start = r.touchData.start;\n            var last = r.touchData.last;\n            var near;\n            if (!r.hoverData.draggingEles && !r.swipePanning) {\n                near = r.findNearestElement(now[0], now[1], true, true);\n            }\n            if (capture && start != null) {\n                e.preventDefault();\n            }\n            // dragging nodes\n            if (capture && start != null && r.nodeIsDraggable(start)) {\n                if (isOverThresholdDrag) {\n                    // then dragging can happen\n                    var draggedEles = r.dragData.touchDragEles;\n                    var justStartedDrag = !r.dragData.didDrag;\n                    if (justStartedDrag) {\n                        addNodesToDrag(draggedEles, {\n                            inDragLayer: true\n                        });\n                    }\n                    r.dragData.didDrag = true;\n                    var totalShift = {\n                        x: 0,\n                        y: 0\n                    };\n                    if (number$1(disp[0]) && number$1(disp[1])) {\n                        totalShift.x += disp[0];\n                        totalShift.y += disp[1];\n                        if (justStartedDrag) {\n                            r.redrawHint(\"eles\", true);\n                            var dragDelta = r.touchData.dragDelta;\n                            if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                totalShift.x += dragDelta[0];\n                                totalShift.y += dragDelta[1];\n                            }\n                        }\n                    }\n                    r.hoverData.draggingEles = true;\n                    draggedEles.silentShift(totalShift).emit(makeEvent(\"position\")).emit(makeEvent(\"drag\"));\n                    r.redrawHint(\"drag\", true);\n                    if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n                        r.redrawHint(\"eles\", true);\n                    }\n                    r.redraw();\n                } else {\n                    // otherwise keep track of drag delta for later\n                    var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n                    if (dragDelta.length === 0) {\n                        dragDelta.push(disp[0]);\n                        dragDelta.push(disp[1]);\n                    } else {\n                        dragDelta[0] += disp[0];\n                        dragDelta[1] += disp[1];\n                    }\n                }\n            }\n            // touchmove\n            {\n                triggerEvents(start || near, [\n                    \"touchmove\",\n                    \"tapdrag\",\n                    \"vmousemove\"\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                if ((!start || !start.grabbed()) && near != last) {\n                    if (last) {\n                        last.emit(makeEvent(\"tapdragout\"));\n                    }\n                    if (near) {\n                        near.emit(makeEvent(\"tapdragover\"));\n                    }\n                }\n                r.touchData.last = near;\n            }\n            // check to cancel taphold\n            if (capture) {\n                for(var i = 0; i < now.length; i++){\n                    if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n                        r.touchData.singleTouchMoved = true;\n                    }\n                }\n            }\n            // panning\n            if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n                var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n                if (allowPassthrough) {\n                    e.preventDefault();\n                    if (!r.data.bgActivePosistion) {\n                        r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n                    }\n                    if (r.swipePanning) {\n                        cy.panBy({\n                            x: disp[0] * zoom,\n                            y: disp[1] * zoom\n                        });\n                        cy.emit(makeEvent(\"dragpan\"));\n                    } else if (isOverThresholdDrag) {\n                        r.swipePanning = true;\n                        cy.panBy({\n                            x: dx * zoom,\n                            y: dy * zoom\n                        });\n                        cy.emit(makeEvent(\"dragpan\"));\n                        if (start) {\n                            start.unactivate();\n                            r.redrawHint(\"select\", true);\n                            r.touchData.start = null;\n                        }\n                    }\n                }\n                // Re-project\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n        }\n        for(var j = 0; j < now.length; j++){\n            earlier[j] = now[j];\n        }\n        // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n        if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint(\"select\", true);\n            r.redraw();\n        }\n    }, false);\n    var touchcancelHandler;\n    r.registerBinding(containerWindow, \"touchcancel\", touchcancelHandler = function touchcancelHandler(e) {\n        // eslint-disable-line no-unused-vars\n        var start = r.touchData.start;\n        r.touchData.capture = false;\n        if (start) {\n            start.unactivate();\n        }\n    });\n    var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n    r.registerBinding(containerWindow, \"touchend\", touchendHandler = function touchendHandler(e) {\n        // eslint-disable-line no-unused-vars\n        var start = r.touchData.start;\n        var capture = r.touchData.capture;\n        if (capture) {\n            if (e.touches.length === 0) {\n                r.touchData.capture = false;\n            }\n            e.preventDefault();\n        } else {\n            return;\n        }\n        var select = r.selection;\n        r.swipePanning = false;\n        r.hoverData.draggingEles = false;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        if (start) {\n            start.unactivate();\n        }\n        var ctxTapend;\n        if (r.touchData.cxt) {\n            ctxTapend = makeEvent(\"cxttapend\");\n            if (start) {\n                start.emit(ctxTapend);\n            } else {\n                cy.emit(ctxTapend);\n            }\n            if (!r.touchData.cxtDragged) {\n                var ctxTap = makeEvent(\"cxttap\");\n                if (start) {\n                    start.emit(ctxTap);\n                } else {\n                    cy.emit(ctxTap);\n                }\n            }\n            if (r.touchData.start) {\n                r.touchData.start._private.grabbed = false;\n            }\n            r.touchData.cxt = false;\n            r.touchData.start = null;\n            r.redraw();\n            return;\n        }\n        // no more box selection if we don't have three fingers\n        if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n            r.touchData.selecting = false;\n            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n            select[0] = undefined;\n            select[1] = undefined;\n            select[2] = undefined;\n            select[3] = undefined;\n            select[4] = 0;\n            r.redrawHint(\"select\", true);\n            cy.emit(makeEvent(\"boxend\"));\n            var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                return ele.selectable() && !ele.selected();\n            };\n            box.emit(makeEvent(\"box\")).stdFilter(eleWouldBeSelected).select().emit(makeEvent(\"boxselect\"));\n            if (box.nonempty()) {\n                r.redrawHint(\"eles\", true);\n            }\n            r.redraw();\n        }\n        if (start != null) {\n            start.unactivate();\n        }\n        if (e.touches[2]) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint(\"select\", true);\n        } else if (e.touches[1]) ;\n        else if (e.touches[0]) ;\n        else if (!e.touches[0]) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint(\"select\", true);\n            var draggedEles = r.dragData.touchDragEles;\n            if (start != null) {\n                var startWasGrabbed = start._private.grabbed;\n                freeDraggedElements(draggedEles);\n                r.redrawHint(\"drag\", true);\n                r.redrawHint(\"eles\", true);\n                if (startWasGrabbed) {\n                    start.emit(makeEvent(\"freeon\"));\n                    draggedEles.emit(makeEvent(\"free\"));\n                    if (r.dragData.didDrag) {\n                        start.emit(makeEvent(\"dragfreeon\"));\n                        draggedEles.emit(makeEvent(\"dragfree\"));\n                    }\n                }\n                triggerEvents(start, [\n                    \"touchend\",\n                    \"tapend\",\n                    \"vmouseup\",\n                    \"tapdragout\"\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                start.unactivate();\n                r.touchData.start = null;\n            } else {\n                var near = r.findNearestElement(now[0], now[1], true, true);\n                triggerEvents(near, [\n                    \"touchend\",\n                    \"tapend\",\n                    \"vmouseup\",\n                    \"tapdragout\"\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n            }\n            var dx = r.touchData.startPosition[0] - now[0];\n            var dx2 = dx * dx;\n            var dy = r.touchData.startPosition[1] - now[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            var rdist2 = dist2 * zoom * zoom;\n            // Tap event, roughly same as mouse click event for touch\n            if (!r.touchData.singleTouchMoved) {\n                if (!start) {\n                    cy.$(\":selected\").unselect([\n                        \"tapunselect\"\n                    ]);\n                }\n                triggerEvents(start, [\n                    \"tap\",\n                    \"vclick\"\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                didDoubleTouch = false;\n                if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n                    touchTimeout && clearTimeout(touchTimeout);\n                    didDoubleTouch = true;\n                    prevTouchTimeStamp = null;\n                    triggerEvents(start, [\n                        \"dbltap\",\n                        \"vdblclick\"\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                } else {\n                    touchTimeout = setTimeout(function() {\n                        if (didDoubleTouch) return;\n                        triggerEvents(start, [\n                            \"onetap\",\n                            \"voneclick\"\n                        ], e, {\n                            x: now[0],\n                            y: now[1]\n                        });\n                    }, cy.multiClickDebounceTime());\n                    prevTouchTimeStamp = e.timeStamp;\n                }\n            }\n            // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n            if (start != null && !r.dragData.didDrag // didn't drag nodes around\n             && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n            ) {\n                if (cy.selectionType() === \"single\") {\n                    cy.$(isSelected).unmerge(start).unselect([\n                        \"tapunselect\"\n                    ]);\n                    start.select([\n                        \"tapselect\"\n                    ]);\n                } else {\n                    if (start.selected()) {\n                        start.unselect([\n                            \"tapunselect\"\n                        ]);\n                    } else {\n                        start.select([\n                            \"tapselect\"\n                        ]);\n                    }\n                }\n                r.redrawHint(\"eles\", true);\n            }\n            r.touchData.singleTouchMoved = true;\n        }\n        for(var j = 0; j < now.length; j++){\n            earlier[j] = now[j];\n        }\n        r.dragData.didDrag = false; // reset for next touchstart\n        if (e.touches.length === 0) {\n            r.touchData.dragDelta = [];\n            r.touchData.startPosition = [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ];\n            r.touchData.startGPosition = null;\n            r.touchData.didSelect = false;\n        }\n        if (e.touches.length < 2) {\n            if (e.touches.length === 1) {\n                // the old start global pos'n may not be the same finger that remains\n                r.touchData.startGPosition = [\n                    e.touches[0].clientX,\n                    e.touches[0].clientY\n                ];\n            }\n            r.pinching = false;\n            r.redrawHint(\"eles\", true);\n            r.redraw();\n        }\n    //r.redraw();\n    }, false);\n    // fallback compatibility layer for ms pointer events\n    if (typeof TouchEvent === \"undefined\") {\n        var pointers = [];\n        var makeTouch = function makeTouch(e) {\n            return {\n                clientX: e.clientX,\n                clientY: e.clientY,\n                force: 1,\n                identifier: e.pointerId,\n                pageX: e.pageX,\n                pageY: e.pageY,\n                radiusX: e.width / 2,\n                radiusY: e.height / 2,\n                screenX: e.screenX,\n                screenY: e.screenY,\n                target: e.target\n            };\n        };\n        var makePointer = function makePointer(e) {\n            return {\n                event: e,\n                touch: makeTouch(e)\n            };\n        };\n        var addPointer = function addPointer(e) {\n            pointers.push(makePointer(e));\n        };\n        var removePointer = function removePointer(e) {\n            for(var i = 0; i < pointers.length; i++){\n                var p = pointers[i];\n                if (p.event.pointerId === e.pointerId) {\n                    pointers.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var updatePointer = function updatePointer(e) {\n            var p = pointers.filter(function(p) {\n                return p.event.pointerId === e.pointerId;\n            })[0];\n            p.event = e;\n            p.touch = makeTouch(e);\n        };\n        var addTouchesToEvent = function addTouchesToEvent(e) {\n            e.touches = pointers.map(function(p) {\n                return p.touch;\n            });\n        };\n        var pointerIsMouse = function pointerIsMouse(e) {\n            return e.pointerType === \"mouse\" || e.pointerType === 4;\n        };\n        r.registerBinding(r.container, \"pointerdown\", function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            e.preventDefault();\n            addPointer(e);\n            addTouchesToEvent(e);\n            touchstartHandler(e);\n        });\n        r.registerBinding(r.container, \"pointerup\", function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            removePointer(e);\n            addTouchesToEvent(e);\n            touchendHandler(e);\n        });\n        r.registerBinding(r.container, \"pointercancel\", function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            removePointer(e);\n            addTouchesToEvent(e);\n            touchcancelHandler(e);\n        });\n        r.registerBinding(r.container, \"pointermove\", function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            e.preventDefault();\n            updatePointer(e);\n            addTouchesToEvent(e);\n            touchmoveHandler(e);\n        });\n    }\n};\nvar BRp$2 = {};\nBRp$2.generatePolygon = function(name, points) {\n    return this.nodeShapes[name] = {\n        renderer: this,\n        name: name,\n        points: points,\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(\"polygon\", context, centerX, centerY, width, height, this.points);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [\n                0,\n                -1\n            ], padding);\n        },\n        hasMiterBounds: name !== \"rectangle\",\n        miterBounds: function miterBounds(centerX, centerY, width, height, strokeWidth, strokePosition) {\n            return miterBox(this.points, centerX, centerY, width, height, strokeWidth);\n        }\n    };\n};\nBRp$2.generateEllipse = function() {\n    return this.nodeShapes[\"ellipse\"] = {\n        renderer: this,\n        name: \"ellipse\",\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n        }\n    };\n};\nBRp$2.generateRoundPolygon = function(name, points) {\n    return this.nodeShapes[name] = {\n        renderer: this,\n        name: name,\n        points: points,\n        getOrCreateCorners: function getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, field) {\n            if (rs[field] !== undefined && rs[field + \"-cx\"] === centerX && rs[field + \"-cy\"] === centerY) {\n                return rs[field];\n            }\n            rs[field] = new Array(points.length / 2);\n            rs[field + \"-cx\"] = centerX;\n            rs[field + \"-cy\"] = centerY;\n            var halfW = width / 2;\n            var halfH = height / 2;\n            cornerRadius = cornerRadius === \"auto\" ? getRoundPolygonRadius(width, height) : cornerRadius;\n            var p = new Array(points.length / 2);\n            for(var _i = 0; _i < points.length / 2; _i++){\n                p[_i] = {\n                    x: centerX + halfW * points[_i * 2],\n                    y: centerY + halfH * points[_i * 2 + 1]\n                };\n            }\n            var i, p1, p2, p3, len = p.length;\n            p1 = p[len - 1];\n            // for each point\n            for(i = 0; i < len; i++){\n                p2 = p[i % len];\n                p3 = p[(i + 1) % len];\n                rs[field][i] = getRoundCorner(p1, p2, p3, cornerRadius);\n                p1 = p2;\n                p2 = p3;\n            }\n            return rs[field];\n        },\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius, rs) {\n            this.renderer.nodeShapeImpl(\"round-polygon\", context, centerX, centerY, width, height, this.points, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, \"drawCorners\"));\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius, rs) {\n            return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height, padding, this.getOrCreateCorners(nodeX, nodeY, width, height, cornerRadius, rs, \"corners\"));\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius, rs) {\n            return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, \"corners\"));\n        }\n    };\n};\nBRp$2.generateRoundRectangle = function() {\n    return this.nodeShapes[\"round-rectangle\"] = this.nodeShapes[\"roundrectangle\"] = {\n        renderer: this,\n        name: \"round-rectangle\",\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var halfWidth = width / 2;\n            var halfHeight = height / 2;\n            cornerRadius = cornerRadius === \"auto\" ? getRoundRectangleRadius(width, height) : cornerRadius;\n            cornerRadius = Math.min(halfWidth, halfHeight, cornerRadius);\n            var diam = cornerRadius * 2;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check top left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n                return true;\n            }\n            // Check top right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n                return true;\n            }\n            return false;\n        }\n    };\n};\nBRp$2.generateCutRectangle = function() {\n    return this.nodeShapes[\"cut-rectangle\"] = this.nodeShapes[\"cutrectangle\"] = {\n        renderer: this,\n        name: \"cut-rectangle\",\n        cornerLength: getCutRectangleCornerLength(),\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, null, cornerRadius);\n        },\n        generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY, cornerRadius) {\n            var cl = cornerRadius === \"auto\" ? this.cornerLength : cornerRadius;\n            var hh = height / 2;\n            var hw = width / 2;\n            var xBegin = centerX - hw;\n            var xEnd = centerX + hw;\n            var yBegin = centerY - hh;\n            var yEnd = centerY + hh;\n            // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n            return {\n                topLeft: [\n                    xBegin,\n                    yBegin + cl,\n                    xBegin + cl,\n                    yBegin,\n                    xBegin + cl,\n                    yBegin + cl\n                ],\n                topRight: [\n                    xEnd - cl,\n                    yBegin,\n                    xEnd,\n                    yBegin + cl,\n                    xEnd - cl,\n                    yBegin + cl\n                ],\n                bottomRight: [\n                    xEnd,\n                    yEnd - cl,\n                    xEnd - cl,\n                    yEnd,\n                    xEnd - cl,\n                    yEnd - cl\n                ],\n                bottomLeft: [\n                    xBegin + cl,\n                    yEnd,\n                    xBegin,\n                    yEnd - cl,\n                    xBegin + cl,\n                    yEnd - cl\n                ]\n            };\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY, cornerRadius);\n            var pts = [].concat.apply([], [\n                cPts.topLeft.splice(0, 4),\n                cPts.topRight.splice(0, 4),\n                cPts.bottomRight.splice(0, 4),\n                cPts.bottomLeft.splice(0, 4)\n            ]);\n            return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var cl = cornerRadius === \"auto\" ? this.cornerLength : cornerRadius;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * cl, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * cl, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n            return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n        }\n    };\n};\nBRp$2.generateBarrel = function() {\n    return this.nodeShapes[\"barrel\"] = {\n        renderer: this,\n        name: \"barrel\",\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            // use two fixed t values for the bezier curve approximation\n            var t0 = 0.15;\n            var t1 = 0.5;\n            var t2 = 0.85;\n            var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n            var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n                // approximate curve pts based on the two t values\n                var m0 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t0);\n                var m1 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t1);\n                var m2 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t2);\n                return [\n                    pts[0],\n                    pts[1],\n                    m0.x,\n                    m0.y,\n                    m1.x,\n                    m1.y,\n                    m2.x,\n                    m2.y,\n                    pts[4],\n                    pts[5]\n                ];\n            };\n            var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n            return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n        },\n        generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n            var hh = height / 2;\n            var hw = width / 2;\n            var xBegin = centerX - hw;\n            var xEnd = centerX + hw;\n            var yBegin = centerY - hh;\n            var yEnd = centerY + hh;\n            var curveConstants = getBarrelCurveConstants(width, height);\n            var hOffset = curveConstants.heightOffset;\n            var wOffset = curveConstants.widthOffset;\n            var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;\n            // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n            var pts = {\n                topLeft: [\n                    xBegin,\n                    yBegin + hOffset,\n                    xBegin + ctrlPtXOffset,\n                    yBegin,\n                    xBegin + wOffset,\n                    yBegin\n                ],\n                topRight: [\n                    xEnd - wOffset,\n                    yBegin,\n                    xEnd - ctrlPtXOffset,\n                    yBegin,\n                    xEnd,\n                    yBegin + hOffset\n                ],\n                bottomRight: [\n                    xEnd,\n                    yEnd - hOffset,\n                    xEnd - ctrlPtXOffset,\n                    yEnd,\n                    xEnd - wOffset,\n                    yEnd\n                ],\n                bottomLeft: [\n                    xBegin + wOffset,\n                    yEnd,\n                    xBegin + ctrlPtXOffset,\n                    yEnd,\n                    xBegin,\n                    yEnd - hOffset\n                ]\n            };\n            pts.topLeft.isTop = true;\n            pts.topRight.isTop = true;\n            pts.bottomLeft.isBottom = true;\n            pts.bottomRight.isBottom = true;\n            return pts;\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var curveConstants = getBarrelCurveConstants(width, height);\n            var hOffset = curveConstants.heightOffset;\n            var wOffset = curveConstants.widthOffset;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n            var getCurveT = function getCurveT(x, y, curvePts) {\n                var x0 = curvePts[4];\n                var x1 = curvePts[2];\n                var x2 = curvePts[0];\n                var y0 = curvePts[5];\n                // var y1 = curvePts[ 3 ];\n                var y2 = curvePts[1];\n                var xMin = Math.min(x0, x2);\n                var xMax = Math.max(x0, x2);\n                var yMin = Math.min(y0, y2);\n                var yMax = Math.max(y0, y2);\n                if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n                    var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n                    var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n                    var validRoots = roots.filter(function(r) {\n                        return 0 <= r && r <= 1;\n                    });\n                    if (validRoots.length > 0) {\n                        return validRoots[0];\n                    }\n                }\n                return null;\n            };\n            var curveRegions = Object.keys(barrelCurvePts);\n            for(var i = 0; i < curveRegions.length; i++){\n                var corner = curveRegions[i];\n                var cornerPts = barrelCurvePts[corner];\n                var t = getCurveT(x, y, cornerPts);\n                if (t == null) {\n                    continue;\n                }\n                var y0 = cornerPts[5];\n                var y1 = cornerPts[3];\n                var y2 = cornerPts[1];\n                var bezY = qbezierAt(y0, y1, y2, t);\n                if (cornerPts.isTop && bezY <= y) {\n                    return true;\n                }\n                if (cornerPts.isBottom && y <= bezY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n};\nBRp$2.generateBottomRoundrectangle = function() {\n    return this.nodeShapes[\"bottom-round-rectangle\"] = this.nodeShapes[\"bottomroundrectangle\"] = {\n        renderer: this,\n        name: \"bottom-round-rectangle\",\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            var topStartX = nodeX - (width / 2 + padding);\n            var topStartY = nodeY - (height / 2 + padding);\n            var topEndY = topStartY;\n            var topEndX = nodeX + (width / 2 + padding);\n            var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n            if (topIntersections.length > 0) {\n                return topIntersections;\n            }\n            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            cornerRadius = cornerRadius === \"auto\" ? getRoundRectangleRadius(width, height) : cornerRadius;\n            var diam = 2 * cornerRadius;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // check non-rounded top side\n            var outerWidth = width / 2 + 2 * padding;\n            var outerHeight = height / 2 + 2 * padding;\n            var points = [\n                centerX - outerWidth,\n                centerY - outerHeight,\n                centerX - outerWidth,\n                centerY,\n                centerX + outerWidth,\n                centerY,\n                centerX + outerWidth,\n                centerY - outerHeight\n            ];\n            if (pointInsidePolygonPoints(x, y, points)) {\n                return true;\n            }\n            // Check bottom right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                return true;\n            }\n            return false;\n        }\n    };\n};\nBRp$2.registerNodeShapes = function() {\n    var nodeShapes = this.nodeShapes = {};\n    var renderer = this;\n    this.generateEllipse();\n    this.generatePolygon(\"triangle\", generateUnitNgonPointsFitToSquare(3, 0));\n    this.generateRoundPolygon(\"round-triangle\", generateUnitNgonPointsFitToSquare(3, 0));\n    this.generatePolygon(\"rectangle\", generateUnitNgonPointsFitToSquare(4, 0));\n    nodeShapes[\"square\"] = nodeShapes[\"rectangle\"];\n    this.generateRoundRectangle();\n    this.generateCutRectangle();\n    this.generateBarrel();\n    this.generateBottomRoundrectangle();\n    {\n        var diamondPoints = [\n            0,\n            1,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            0\n        ];\n        this.generatePolygon(\"diamond\", diamondPoints);\n        this.generateRoundPolygon(\"round-diamond\", diamondPoints);\n    }\n    this.generatePolygon(\"pentagon\", generateUnitNgonPointsFitToSquare(5, 0));\n    this.generateRoundPolygon(\"round-pentagon\", generateUnitNgonPointsFitToSquare(5, 0));\n    this.generatePolygon(\"hexagon\", generateUnitNgonPointsFitToSquare(6, 0));\n    this.generateRoundPolygon(\"round-hexagon\", generateUnitNgonPointsFitToSquare(6, 0));\n    this.generatePolygon(\"heptagon\", generateUnitNgonPointsFitToSquare(7, 0));\n    this.generateRoundPolygon(\"round-heptagon\", generateUnitNgonPointsFitToSquare(7, 0));\n    this.generatePolygon(\"octagon\", generateUnitNgonPointsFitToSquare(8, 0));\n    this.generateRoundPolygon(\"round-octagon\", generateUnitNgonPointsFitToSquare(8, 0));\n    var star5Points = new Array(20);\n    {\n        var outerPoints = generateUnitNgonPoints(5, 0);\n        var innerPoints = generateUnitNgonPoints(5, Math.PI / 5);\n        // Outer radius is 1; inner radius of star is smaller\n        var innerRadius = 0.5 * (3 - Math.sqrt(5));\n        innerRadius *= 1.57;\n        for(var i = 0; i < innerPoints.length / 2; i++){\n            innerPoints[i * 2] *= innerRadius;\n            innerPoints[i * 2 + 1] *= innerRadius;\n        }\n        for(var i = 0; i < 20 / 4; i++){\n            star5Points[i * 4] = outerPoints[i * 2];\n            star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n            star5Points[i * 4 + 2] = innerPoints[i * 2];\n            star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n        }\n    }\n    star5Points = fitPolygonToSquare(star5Points);\n    this.generatePolygon(\"star\", star5Points);\n    this.generatePolygon(\"vee\", [\n        -1,\n        -1,\n        0,\n        -0.333,\n        1,\n        -1,\n        0,\n        1\n    ]);\n    this.generatePolygon(\"rhomboid\", [\n        -1,\n        -1,\n        0.333,\n        -1,\n        1,\n        1,\n        -0.333,\n        1\n    ]);\n    this.generatePolygon(\"right-rhomboid\", [\n        -0.333,\n        -1,\n        1,\n        -1,\n        0.333,\n        1,\n        -1,\n        1\n    ]);\n    this.nodeShapes[\"concavehexagon\"] = this.generatePolygon(\"concave-hexagon\", [\n        -1,\n        -0.95,\n        -0.75,\n        0,\n        -1,\n        0.95,\n        1,\n        0.95,\n        0.75,\n        0,\n        1,\n        -0.95\n    ]);\n    {\n        var tagPoints = [\n            -1,\n            -1,\n            0.25,\n            -1,\n            1,\n            0,\n            0.25,\n            1,\n            -1,\n            1\n        ];\n        this.generatePolygon(\"tag\", tagPoints);\n        this.generateRoundPolygon(\"round-tag\", tagPoints);\n    }\n    nodeShapes.makePolygon = function(points) {\n        // use caching on user-specified polygons so they are as fast as native shapes\n        var key = points.join(\"$\");\n        var name = \"polygon-\" + key;\n        var shape;\n        if (shape = this[name]) {\n            // got cached shape\n            return shape;\n        }\n        // create and cache new shape\n        return renderer.generatePolygon(name, points);\n    };\n};\nvar BRp$1 = {};\nBRp$1.timeToRender = function() {\n    return this.redrawTotalTime / this.redrawCount;\n};\nBRp$1.redraw = function(options) {\n    options = options || staticEmptyObject();\n    var r = this;\n    if (r.averageRedrawTime === undefined) {\n        r.averageRedrawTime = 0;\n    }\n    if (r.lastRedrawTime === undefined) {\n        r.lastRedrawTime = 0;\n    }\n    if (r.lastDrawTime === undefined) {\n        r.lastDrawTime = 0;\n    }\n    r.requestedFrame = true;\n    r.renderOptions = options;\n};\nBRp$1.beforeRender = function(fn, priority) {\n    // the renderer can't add tick callbacks when destroyed\n    if (this.destroyed) {\n        return;\n    }\n    if (priority == null) {\n        error(\"Priority is not optional for beforeRender\");\n    }\n    var cbs = this.beforeRenderCallbacks;\n    cbs.push({\n        fn: fn,\n        priority: priority\n    });\n    // higher priority callbacks executed first\n    cbs.sort(function(a, b) {\n        return b.priority - a.priority;\n    });\n};\nvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n    var cbs = r.beforeRenderCallbacks;\n    for(var i = 0; i < cbs.length; i++){\n        cbs[i].fn(willDraw, startTime);\n    }\n};\nBRp$1.startRenderLoop = function() {\n    var r = this;\n    var cy = r.cy;\n    if (r.renderLoopStarted) {\n        return;\n    } else {\n        r.renderLoopStarted = true;\n    }\n    var _renderFn = function renderFn(requestTime) {\n        if (r.destroyed) {\n            return;\n        }\n        if (cy.batching()) ;\n        else if (r.requestedFrame && !r.skipFrame) {\n            beforeRenderCallbacks(r, true, requestTime);\n            var startTime = performanceNow();\n            r.render(r.renderOptions);\n            var endTime = r.lastDrawTime = performanceNow();\n            if (r.averageRedrawTime === undefined) {\n                r.averageRedrawTime = endTime - startTime;\n            }\n            if (r.redrawCount === undefined) {\n                r.redrawCount = 0;\n            }\n            r.redrawCount++;\n            if (r.redrawTotalTime === undefined) {\n                r.redrawTotalTime = 0;\n            }\n            var duration = endTime - startTime;\n            r.redrawTotalTime += duration;\n            r.lastRedrawTime = duration;\n            // use a weighted average with a bias from the previous average so we don't spike so easily\n            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n            r.requestedFrame = false;\n        } else {\n            beforeRenderCallbacks(r, false, requestTime);\n        }\n        r.skipFrame = false;\n        requestAnimationFrame(_renderFn);\n    };\n    requestAnimationFrame(_renderFn);\n};\nvar BaseRenderer = function BaseRenderer(options) {\n    this.init(options);\n};\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\nBRp.clientFunctions = [\n    \"redrawHint\",\n    \"render\",\n    \"renderTo\",\n    \"matchCanvasSize\",\n    \"nodeShapeImpl\",\n    \"arrowShapeImpl\"\n];\nBRp.init = function(options) {\n    var r = this;\n    r.options = options;\n    r.cy = options.cy;\n    var ctr = r.container = options.cy.container();\n    var containerWindow = r.cy.window();\n    // prepend a stylesheet in the head such that\n    if (containerWindow) {\n        var document1 = containerWindow.document;\n        var head = document1.head;\n        var stylesheetId = \"__________cytoscape_stylesheet\";\n        var className = \"__________cytoscape_container\";\n        var stylesheetAlreadyExists = document1.getElementById(stylesheetId) != null;\n        if (ctr.className.indexOf(className) < 0) {\n            ctr.className = (ctr.className || \"\") + \" \" + className;\n        }\n        if (!stylesheetAlreadyExists) {\n            var stylesheet = document1.createElement(\"style\");\n            stylesheet.id = stylesheetId;\n            stylesheet.textContent = \".\" + className + \" { position: relative; }\";\n            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n        }\n        var computedStyle = containerWindow.getComputedStyle(ctr);\n        var position = computedStyle.getPropertyValue(\"position\");\n        if (position === \"static\") {\n            warn(\"A Cytoscape container has style position:static and so can not use UI extensions properly\");\n        }\n    }\n    r.selection = [\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        0\n    ]; // Coordinates for selection box, plus enabled flag\n    r.bezierProjPcts = [\n        0.05,\n        0.225,\n        0.4,\n        0.5,\n        0.6,\n        0.775,\n        0.95\n    ];\n    //--Pointer-related data\n    r.hoverData = {\n        down: null,\n        last: null,\n        downTime: null,\n        triggerMode: null,\n        dragging: false,\n        initialPan: [\n            null,\n            null\n        ],\n        capture: false\n    };\n    r.dragData = {\n        possibleDragElements: []\n    };\n    r.touchData = {\n        start: null,\n        capture: false,\n        // These 3 fields related to tap, taphold events\n        startPosition: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ],\n        singleTouchStartTime: null,\n        singleTouchMoved: true,\n        now: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ],\n        earlier: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ]\n    };\n    r.redraws = 0;\n    r.showFps = options.showFps;\n    r.debug = options.debug;\n    r.webgl = options.webgl;\n    r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    r.textureOnViewport = options.textureOnViewport;\n    r.wheelSensitivity = options.wheelSensitivity;\n    r.motionBlurEnabled = options.motionBlur; // on by default\n    r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n    r.motionBlur = options.motionBlur; // for initial kick off\n    r.motionBlurOpacity = options.motionBlurOpacity;\n    r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n    r.motionBlurPxRatio = 1;\n    r.mbPxRBlurry = 1; //0.8;\n    r.minMbLowQualFrames = 4;\n    r.fullQualityMb = false;\n    r.clearedForMotionBlur = [];\n    r.desktopTapThreshold = options.desktopTapThreshold;\n    r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n    r.touchTapThreshold = options.touchTapThreshold;\n    r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n    r.tapholdDuration = 500;\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.beforeRenderPriorities = {\n        // higher priority execs before lower one\n        animations: 400,\n        eleCalcs: 300,\n        eleTxrDeq: 200,\n        lyrTxrDeq: 150,\n        lyrTxrSkip: 100\n    };\n    r.registerNodeShapes();\n    r.registerArrowShapes();\n    r.registerCalculationListeners();\n};\nBRp.notify = function(eventName, eles) {\n    var r = this;\n    var cy = r.cy;\n    // the renderer can't be notified after it's destroyed\n    if (this.destroyed) {\n        return;\n    }\n    if (eventName === \"init\") {\n        r.load();\n        return;\n    }\n    if (eventName === \"destroy\") {\n        r.destroy();\n        return;\n    }\n    if (eventName === \"add\" || eventName === \"remove\" || eventName === \"move\" && cy.hasCompoundNodes() || eventName === \"load\" || eventName === \"zorder\" || eventName === \"mount\") {\n        r.invalidateCachedZSortedEles();\n    }\n    if (eventName === \"viewport\") {\n        r.redrawHint(\"select\", true);\n    }\n    if (eventName === \"gc\") {\n        r.redrawHint(\"gc\", true);\n    }\n    if (eventName === \"load\" || eventName === \"resize\" || eventName === \"mount\") {\n        r.invalidateContainerClientCoordsCache();\n        r.matchCanvasSize(r.container);\n    }\n    r.redrawHint(\"eles\", true);\n    r.redrawHint(\"drag\", true);\n    this.startRenderLoop();\n    this.redraw();\n};\nBRp.destroy = function() {\n    var r = this;\n    r.destroyed = true;\n    r.cy.stopAnimationLoop();\n    for(var i = 0; i < r.bindings.length; i++){\n        var binding = r.bindings[i];\n        var b = binding;\n        var tgt = b.target;\n        (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n    }\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.onUpdateEleCalcsFns = [];\n    if (r.removeObserver) {\n        r.removeObserver.disconnect();\n    }\n    if (r.styleObserver) {\n        r.styleObserver.disconnect();\n    }\n    if (r.resizeObserver) {\n        r.resizeObserver.disconnect();\n    }\n    if (r.labelCalcDiv) {\n        try {\n            document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n        } catch (e) {\n        // ie10 issue #1014\n        }\n    }\n};\nBRp.isHeadless = function() {\n    return false;\n};\n[\n    BRp$f,\n    BRp$5,\n    BRp$4,\n    BRp$3,\n    BRp$2,\n    BRp$1\n].forEach(function(props) {\n    extend(BRp, props);\n});\nvar fullFpsTime = 1000 / 60; // assume 60 frames per second\nvar defs = {\n    setupDequeueing: function setupDequeueing(opts) {\n        return function setupDequeueingImpl() {\n            var self1 = this;\n            var r = this.renderer;\n            if (self1.dequeueingSetup) {\n                return;\n            } else {\n                self1.dequeueingSetup = true;\n            }\n            var queueRedraw = debounce(function() {\n                r.redrawHint(\"eles\", true);\n                r.redrawHint(\"drag\", true);\n                r.redraw();\n            }, opts.deqRedrawThreshold);\n            var dequeue = function dequeue(willDraw, frameStartTime) {\n                var startTime = performanceNow();\n                var avgRenderTime = r.averageRedrawTime;\n                var renderTime = r.lastRedrawTime;\n                var deqd = [];\n                var extent = r.cy.extent();\n                var pixelRatio = r.getPixelRatio();\n                // if we aren't in a tick that causes a draw, then the rendered style\n                // queue won't automatically be flushed before dequeueing starts\n                if (!willDraw) {\n                    r.flushRenderedStyleQueue();\n                }\n                while(true){\n                    // eslint-disable-line no-constant-condition\n                    var now = performanceNow();\n                    var duration = now - startTime;\n                    var frameDuration = now - frameStartTime;\n                    if (renderTime < fullFpsTime) {\n                        // if we're rendering faster than the ideal fps, then do dequeueing\n                        // during all of the remaining frame time\n                        var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n                        if (frameDuration >= opts.deqFastCost * timeAvailable) {\n                            break;\n                        }\n                    } else {\n                        if (willDraw) {\n                            if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                                break;\n                            }\n                        } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n                            break;\n                        }\n                    }\n                    var thisDeqd = opts.deq(self1, pixelRatio, extent);\n                    if (thisDeqd.length > 0) {\n                        for(var i = 0; i < thisDeqd.length; i++){\n                            deqd.push(thisDeqd[i]);\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                // callbacks on dequeue\n                if (deqd.length > 0) {\n                    opts.onDeqd(self1, deqd);\n                    if (!willDraw && opts.shouldRedraw(self1, deqd, pixelRatio, extent)) {\n                        queueRedraw();\n                    }\n                }\n            };\n            var priority = opts.priority || noop$1;\n            r.beforeRender(dequeue, priority(self1));\n        };\n    }\n};\n// Allows lookups for (ele, lvl) => cache.\n// Uses keys so elements may share the same cache.\nvar ElementTextureCacheLookup = /*#__PURE__*/ function() {\n    function ElementTextureCacheLookup(getKey) {\n        var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n        _classCallCheck(this, ElementTextureCacheLookup);\n        this.idsByKey = new Map$1();\n        this.keyForId = new Map$1();\n        this.cachesByLvl = new Map$1();\n        this.lvls = [];\n        this.getKey = getKey;\n        this.doesEleInvalidateKey = doesEleInvalidateKey;\n    }\n    return _createClass(ElementTextureCacheLookup, [\n        {\n            key: \"getIdsFor\",\n            value: function getIdsFor(key) {\n                if (key == null) {\n                    error(\"Can not get id list for null key\");\n                }\n                var idsByKey = this.idsByKey;\n                var ids = this.idsByKey.get(key);\n                if (!ids) {\n                    ids = new Set$1();\n                    idsByKey.set(key, ids);\n                }\n                return ids;\n            }\n        },\n        {\n            key: \"addIdForKey\",\n            value: function addIdForKey(key, id) {\n                if (key != null) {\n                    this.getIdsFor(key).add(id);\n                }\n            }\n        },\n        {\n            key: \"deleteIdForKey\",\n            value: function deleteIdForKey(key, id) {\n                if (key != null) {\n                    this.getIdsFor(key)[\"delete\"](id);\n                }\n            }\n        },\n        {\n            key: \"getNumberOfIdsForKey\",\n            value: function getNumberOfIdsForKey(key) {\n                if (key == null) {\n                    return 0;\n                } else {\n                    return this.getIdsFor(key).size;\n                }\n            }\n        },\n        {\n            key: \"updateKeyMappingFor\",\n            value: function updateKeyMappingFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                var currKey = this.getKey(ele);\n                this.deleteIdForKey(prevKey, id);\n                this.addIdForKey(currKey, id);\n                this.keyForId.set(id, currKey);\n            }\n        },\n        {\n            key: \"deleteKeyMappingFor\",\n            value: function deleteKeyMappingFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                this.deleteIdForKey(prevKey, id);\n                this.keyForId[\"delete\"](id);\n            }\n        },\n        {\n            key: \"keyHasChangedFor\",\n            value: function keyHasChangedFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                var newKey = this.getKey(ele);\n                return prevKey !== newKey;\n            }\n        },\n        {\n            key: \"isInvalid\",\n            value: function isInvalid(ele) {\n                return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n            }\n        },\n        {\n            key: \"getCachesAt\",\n            value: function getCachesAt(lvl) {\n                var cachesByLvl = this.cachesByLvl, lvls = this.lvls;\n                var caches = cachesByLvl.get(lvl);\n                if (!caches) {\n                    caches = new Map$1();\n                    cachesByLvl.set(lvl, caches);\n                    lvls.push(lvl);\n                }\n                return caches;\n            }\n        },\n        {\n            key: \"getCache\",\n            value: function getCache(key, lvl) {\n                return this.getCachesAt(lvl).get(key);\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(ele, lvl) {\n                var key = this.getKey(ele);\n                var cache = this.getCache(key, lvl);\n                // getting for an element may need to add to the id list b/c eles can share keys\n                if (cache != null) {\n                    this.updateKeyMappingFor(ele);\n                }\n                return cache;\n            }\n        },\n        {\n            key: \"getForCachedKey\",\n            value: function getForCachedKey(ele, lvl) {\n                var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n                var cache = this.getCache(key, lvl);\n                return cache;\n            }\n        },\n        {\n            key: \"hasCache\",\n            value: function hasCache(key, lvl) {\n                return this.getCachesAt(lvl).has(key);\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(ele, lvl) {\n                var key = this.getKey(ele);\n                return this.hasCache(key, lvl);\n            }\n        },\n        {\n            key: \"setCache\",\n            value: function setCache(key, lvl, cache) {\n                cache.key = key;\n                this.getCachesAt(lvl).set(key, cache);\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(ele, lvl, cache) {\n                var key = this.getKey(ele);\n                this.setCache(key, lvl, cache);\n                this.updateKeyMappingFor(ele);\n            }\n        },\n        {\n            key: \"deleteCache\",\n            value: function deleteCache(key, lvl) {\n                this.getCachesAt(lvl)[\"delete\"](key);\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(ele, lvl) {\n                var key = this.getKey(ele);\n                this.deleteCache(key, lvl);\n            }\n        },\n        {\n            key: \"invalidateKey\",\n            value: function invalidateKey(key) {\n                var _this = this;\n                this.lvls.forEach(function(lvl) {\n                    return _this.deleteCache(key, lvl);\n                });\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(ele) {\n                var id = ele.id();\n                var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n                this.deleteKeyMappingFor(ele);\n                var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n                if (entireKeyInvalidated) {\n                    // clear mapping for current key\n                    this.invalidateKey(key);\n                }\n                return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n            }\n        }\n    ]);\n}();\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\nvar minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\nvar defTxrWidth = 1024; // default/minimum texture width\nvar maxTxrW = 1024; // the maximum width of a texture\nvar maxTxrH = 1024; // the maximum height of a texture\nvar minUtility = 0.2; // if usage of texture is less than this, it is retired\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\nvar maxFullnessChecks = 10; // dequeued after this many checks\nvar deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\nvar deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\nvar getTxrReasons = {\n    dequeue: \"dequeue\",\n    downscale: \"downscale\",\n    highQuality: \"highQuality\"\n};\nvar initDefaults = defaults$g({\n    getKey: null,\n    doesEleInvalidateKey: falsify,\n    drawElement: null,\n    getBoundingBox: null,\n    getRotationPoint: null,\n    getRotationOffset: null,\n    isVisible: trueify,\n    allowEdgeTxrCaching: true,\n    allowParentTxrCaching: true\n});\nvar ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n    var self1 = this;\n    self1.renderer = renderer;\n    self1.onDequeues = [];\n    var opts = initDefaults(initOptions);\n    extend(self1, opts);\n    self1.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n    self1.setupDequeueing();\n};\nvar ETCp = ElementTextureCache.prototype;\nETCp.reasons = getTxrReasons;\n// the list of textures in which new subtextures for elements can be placed\nETCp.getTextureQueue = function(txrH) {\n    var self1 = this;\n    self1.eleImgCaches = self1.eleImgCaches || {};\n    return self1.eleImgCaches[txrH] = self1.eleImgCaches[txrH] || [];\n};\n// the list of usused textures which can be recycled (in use in texture queue)\nETCp.getRetiredTextureQueue = function(txrH) {\n    var self1 = this;\n    var rtxtrQs = self1.eleImgCaches.retired = self1.eleImgCaches.retired || {};\n    var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n    return rtxtrQ;\n};\n// queue of element draw requests at different scale levels\nETCp.getElementQueue = function() {\n    var self1 = this;\n    var q = self1.eleCacheQueue = self1.eleCacheQueue || new Heap(function(a, b) {\n        return b.reqs - a.reqs;\n    });\n    return q;\n};\n// queue of element draw requests at different scale levels (element id lookup)\nETCp.getElementKeyToQueue = function() {\n    var self1 = this;\n    var k2q = self1.eleKeyToCacheQueue = self1.eleKeyToCacheQueue || {};\n    return k2q;\n};\nETCp.getElement = function(ele, bb, pxRatio, lvl, reason) {\n    var self1 = this;\n    var r = this.renderer;\n    var zoom = r.cy.zoom();\n    var lookup = this.lookup;\n    if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n        return null;\n    }\n    if (!self1.allowEdgeTxrCaching && ele.isEdge() || !self1.allowParentTxrCaching && ele.isParent()) {\n        return null;\n    }\n    if (lvl == null) {\n        lvl = Math.ceil(log2(zoom * pxRatio));\n    }\n    if (lvl < minLvl$1) {\n        lvl = minLvl$1;\n    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n        return null;\n    }\n    var scale = Math.pow(2, lvl);\n    var eleScaledH = bb.h * scale;\n    var eleScaledW = bb.w * scale;\n    var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n    if (!this.isVisible(ele, scaledLabelShown)) {\n        return null;\n    }\n    var eleCache = lookup.get(ele, lvl);\n    // if this get was on an unused/invalidated cache, then restore the texture usage metric\n    if (eleCache && eleCache.invalidated) {\n        eleCache.invalidated = false;\n        eleCache.texture.invalidatedWidth -= eleCache.width;\n    }\n    if (eleCache) {\n        return eleCache;\n    }\n    var txrH; // which texture height this ele belongs to\n    if (eleScaledH <= minTxrH) {\n        txrH = minTxrH;\n    } else if (eleScaledH <= txrStepH) {\n        txrH = txrStepH;\n    } else {\n        txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n    }\n    if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n        return null; // caching large elements is not efficient\n    }\n    var txrQ = self1.getTextureQueue(txrH);\n    // first try the second last one in case it has space at the end\n    var txr = txrQ[txrQ.length - 2];\n    var addNewTxr = function addNewTxr() {\n        return self1.recycleTexture(txrH, eleScaledW) || self1.addTexture(txrH, eleScaledW);\n    };\n    // try the last one if there is no second last one\n    if (!txr) {\n        txr = txrQ[txrQ.length - 1];\n    }\n    // if the last one doesn't exist, we need a first one\n    if (!txr) {\n        txr = addNewTxr();\n    }\n    // if there's no room in the current texture, we need a new one\n    if (txr.width - txr.usedWidth < eleScaledW) {\n        txr = addNewTxr();\n    }\n    var scalableFrom = function scalableFrom(otherCache) {\n        return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n    };\n    var deqing = reason && reason === getTxrReasons.dequeue;\n    var highQualityReq = reason && reason === getTxrReasons.highQuality;\n    var downscaleReq = reason && reason === getTxrReasons.downscale;\n    var higherCache; // the nearest cache with a higher level\n    for(var l = lvl + 1; l <= maxLvl$1; l++){\n        var c = lookup.get(ele, l);\n        if (c) {\n            higherCache = c;\n            break;\n        }\n    }\n    var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n    var downscale = function downscale() {\n        txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n    };\n    // reset ele area in texture\n    txr.context.setTransform(1, 0, 0, 1, 0, 0);\n    txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n    if (scalableFrom(oneUpCache)) {\n        // then we can relatively cheaply rescale the existing image w/o rerendering\n        downscale();\n    } else if (scalableFrom(higherCache)) {\n        // then use the higher cache for now and queue the next level down\n        // to cheaply scale towards the smaller level\n        if (highQualityReq) {\n            for(var _l = higherCache.level; _l > lvl; _l--){\n                oneUpCache = self1.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n            }\n            downscale();\n        } else {\n            self1.queueElement(ele, higherCache.level - 1);\n            return higherCache;\n        }\n    } else {\n        var lowerCache; // the nearest cache with a lower level\n        if (!deqing && !highQualityReq && !downscaleReq) {\n            for(var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--){\n                var _c = lookup.get(ele, _l2);\n                if (_c) {\n                    lowerCache = _c;\n                    break;\n                }\n            }\n        }\n        if (scalableFrom(lowerCache)) {\n            // then use the lower quality cache for now and queue the better one for later\n            self1.queueElement(ele, lvl);\n            return lowerCache;\n        }\n        txr.context.translate(txr.usedWidth, 0);\n        txr.context.scale(scale, scale);\n        this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n        txr.context.scale(1 / scale, 1 / scale);\n        txr.context.translate(-txr.usedWidth, 0);\n    }\n    eleCache = {\n        x: txr.usedWidth,\n        texture: txr,\n        level: lvl,\n        scale: scale,\n        width: eleScaledW,\n        height: eleScaledH,\n        scaledLabelShown: scaledLabelShown\n    };\n    txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n    txr.eleCaches.push(eleCache);\n    lookup.set(ele, lvl, eleCache);\n    self1.checkTextureFullness(txr);\n    return eleCache;\n};\nETCp.invalidateElements = function(eles) {\n    for(var i = 0; i < eles.length; i++){\n        this.invalidateElement(eles[i]);\n    }\n};\nETCp.invalidateElement = function(ele) {\n    var self1 = this;\n    var lookup = self1.lookup;\n    var caches = [];\n    var invalid = lookup.isInvalid(ele);\n    if (!invalid) {\n        return; // override the invalidation request if the element key has not changed\n    }\n    for(var lvl = minLvl$1; lvl <= maxLvl$1; lvl++){\n        var cache = lookup.getForCachedKey(ele, lvl);\n        if (cache) {\n            caches.push(cache);\n        }\n    }\n    var noOtherElesUseCache = lookup.invalidate(ele);\n    if (noOtherElesUseCache) {\n        for(var i = 0; i < caches.length; i++){\n            var _cache = caches[i];\n            var txr = _cache.texture;\n            // remove space from the texture it belongs to\n            txr.invalidatedWidth += _cache.width;\n            // mark the cache as invalidated\n            _cache.invalidated = true;\n            // retire the texture if its utility is low\n            self1.checkTextureUtility(txr);\n        }\n    }\n    // remove from queue since the old req was for the old state\n    self1.removeFromQueue(ele);\n};\nETCp.checkTextureUtility = function(txr) {\n    // invalidate all entries in the cache if the cache size is small\n    if (txr.invalidatedWidth >= minUtility * txr.width) {\n        this.retireTexture(txr);\n    }\n};\nETCp.checkTextureFullness = function(txr) {\n    // if texture has been mostly filled and passed over several times, remove\n    // it from the queue so we don't need to waste time looking at it to put new things\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txr.height);\n    if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n        removeFromArray(txrQ, txr);\n    } else {\n        txr.fullnessChecks++;\n    }\n};\nETCp.retireTexture = function(txr) {\n    var self1 = this;\n    var txrH = txr.height;\n    var txrQ = self1.getTextureQueue(txrH);\n    var lookup = this.lookup;\n    // retire the texture from the active / searchable queue:\n    removeFromArray(txrQ, txr);\n    txr.retired = true;\n    // remove the refs from the eles to the caches:\n    var eleCaches = txr.eleCaches;\n    for(var i = 0; i < eleCaches.length; i++){\n        var eleCache = eleCaches[i];\n        lookup.deleteCache(eleCache.key, eleCache.level);\n    }\n    clearArray(eleCaches);\n    // add the texture to a retired queue so it can be recycled in future:\n    var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n    rtxtrQ.push(txr);\n};\nETCp.addTexture = function(txrH, minW) {\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txrH);\n    var txr = {};\n    txrQ.push(txr);\n    txr.eleCaches = [];\n    txr.height = txrH;\n    txr.width = Math.max(defTxrWidth, minW);\n    txr.usedWidth = 0;\n    txr.invalidatedWidth = 0;\n    txr.fullnessChecks = 0;\n    txr.canvas = self1.renderer.makeOffscreenCanvas(txr.width, txr.height);\n    txr.context = txr.canvas.getContext(\"2d\");\n    return txr;\n};\nETCp.recycleTexture = function(txrH, minW) {\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txrH);\n    var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n    for(var i = 0; i < rtxtrQ.length; i++){\n        var txr = rtxtrQ[i];\n        if (txr.width >= minW) {\n            txr.retired = false;\n            txr.usedWidth = 0;\n            txr.invalidatedWidth = 0;\n            txr.fullnessChecks = 0;\n            clearArray(txr.eleCaches);\n            txr.context.setTransform(1, 0, 0, 1, 0, 0);\n            txr.context.clearRect(0, 0, txr.width, txr.height);\n            removeFromArray(rtxtrQ, txr);\n            txrQ.push(txr);\n            return txr;\n        }\n    }\n};\nETCp.queueElement = function(ele, lvl) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var existingReq = k2q[key];\n    if (existingReq) {\n        // use the max lvl b/c in between lvls are cheap to make\n        existingReq.level = Math.max(existingReq.level, lvl);\n        existingReq.eles.merge(ele);\n        existingReq.reqs++;\n        q.updateItem(existingReq);\n    } else {\n        var req = {\n            eles: ele.spawn().merge(ele),\n            level: lvl,\n            reqs: 1,\n            key: key\n        };\n        q.push(req);\n        k2q[key] = req;\n    }\n};\nETCp.dequeue = function(pxRatio /*, extent*/ ) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var dequeued = [];\n    var lookup = self1.lookup;\n    for(var i = 0; i < maxDeqSize$1; i++){\n        if (q.size() > 0) {\n            var req = q.pop();\n            var key = req.key;\n            var ele = req.eles[0]; // all eles have the same key\n            var cacheExists = lookup.hasCache(ele, req.level);\n            // clear out the key to req lookup\n            k2q[key] = null;\n            // dequeueing isn't necessary with an existing cache\n            if (cacheExists) {\n                continue;\n            }\n            dequeued.push(req);\n            var bb = self1.getBoundingBox(ele);\n            self1.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n        } else {\n            break;\n        }\n    }\n    return dequeued;\n};\nETCp.removeFromQueue = function(ele) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var req = k2q[key];\n    if (req != null) {\n        if (req.eles.length === 1) {\n            // remove if last ele in the req\n            // bring to front of queue\n            req.reqs = MAX_INT$1;\n            q.updateItem(req);\n            q.pop(); // remove from queue\n            k2q[key] = null; // remove from lookup map\n        } else {\n            // otherwise just remove ele from req\n            req.eles.unmerge(ele);\n        }\n    }\n};\nETCp.onDequeue = function(fn) {\n    this.onDequeues.push(fn);\n};\nETCp.offDequeue = function(fn) {\n    removeFromArray(this.onDequeues, fn);\n};\nETCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold$1,\n    deqCost: deqCost$1,\n    deqAvgCost: deqAvgCost$1,\n    deqNoDrawCost: deqNoDrawCost$1,\n    deqFastCost: deqFastCost$1,\n    deq: function deq(self1, pxRatio, extent) {\n        return self1.dequeue(pxRatio, extent);\n    },\n    onDeqd: function onDeqd(self1, deqd) {\n        for(var i = 0; i < self1.onDequeues.length; i++){\n            var fn = self1.onDequeues[i];\n            fn(deqd);\n        }\n    },\n    shouldRedraw: function shouldRedraw(self1, deqd, pxRatio, extent) {\n        for(var i = 0; i < deqd.length; i++){\n            var eles = deqd[i].eles;\n            for(var j = 0; j < eles.length; j++){\n                var bb = eles[j].boundingBox();\n                if (boundingBoxesIntersect(bb, extent)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    priority: function priority(self1) {\n        return self1.renderer.beforeRenderPriorities.eleTxrDeq;\n    }\n});\nvar defNumLayers = 1; // default number of layers to use\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\nvar maxLayerDim = 32767; // maximum size for the width/height of layer canvases\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n// var log = function(){ console.log.apply( console, arguments ); };\nvar LayeredTextureCache = function LayeredTextureCache(renderer) {\n    var self1 = this;\n    var r = self1.renderer = renderer;\n    var cy = r.cy;\n    self1.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n    self1.firstGet = true;\n    self1.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n    self1.skipping = false;\n    self1.eleTxrDeqs = cy.collection();\n    self1.scheduleElementRefinement = debounce(function() {\n        self1.refineElementTextures(self1.eleTxrDeqs);\n        self1.eleTxrDeqs.unmerge(self1.eleTxrDeqs);\n    }, refineEleDebounceTime);\n    r.beforeRender(function(willDraw, now) {\n        if (now - self1.lastInvalidationTime <= invalidThreshold) {\n            self1.skipping = true;\n        } else {\n            self1.skipping = false;\n        }\n    }, r.beforeRenderPriorities.lyrTxrSkip);\n    var qSort = function qSort(a, b) {\n        return b.reqs - a.reqs;\n    };\n    self1.layersQueue = new Heap(qSort);\n    self1.setupDequeueing();\n};\nvar LTCp = LayeredTextureCache.prototype;\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\nLTCp.makeLayer = function(bb, lvl) {\n    var scale = Math.pow(2, lvl);\n    var w = Math.ceil(bb.w * scale);\n    var h = Math.ceil(bb.h * scale);\n    var canvas = this.renderer.makeOffscreenCanvas(w, h);\n    var layer = {\n        id: layerIdPool = ++layerIdPool % MAX_INT,\n        bb: bb,\n        level: lvl,\n        width: w,\n        height: h,\n        canvas: canvas,\n        context: canvas.getContext(\"2d\"),\n        eles: [],\n        elesQueue: [],\n        reqs: 0\n    };\n    // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n    var cxt = layer.context;\n    var dx = -layer.bb.x1;\n    var dy = -layer.bb.y1;\n    // do the transform on creation to save cycles (it's the same for all eles)\n    cxt.scale(scale, scale);\n    cxt.translate(dx, dy);\n    return layer;\n};\nLTCp.getLayers = function(eles, pxRatio, lvl) {\n    var self1 = this;\n    var r = self1.renderer;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var firstGet = self1.firstGet;\n    self1.firstGet = false;\n    // log('--\\nget layers with %s eles', eles.length);\n    //log eles.map(function(ele){ return ele.id() }) );\n    if (lvl == null) {\n        lvl = Math.ceil(log2(zoom * pxRatio));\n        if (lvl < minLvl) {\n            lvl = minLvl;\n        } else if (zoom >= maxZoom || lvl > maxLvl) {\n            return null;\n        }\n    }\n    self1.validateLayersElesOrdering(lvl, eles);\n    var layersByLvl = self1.layersByLevel;\n    var scale = Math.pow(2, lvl);\n    var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n    var bb;\n    var lvlComplete = self1.levelIsComplete(lvl, eles);\n    var tmpLayers;\n    var checkTempLevels = function checkTempLevels() {\n        var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n            self1.validateLayersElesOrdering(l, eles);\n            if (self1.levelIsComplete(l, eles)) {\n                tmpLayers = layersByLvl[l];\n                return true;\n            }\n        };\n        var checkLvls = function checkLvls(dir) {\n            if (tmpLayers) {\n                return;\n            }\n            for(var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir){\n                if (canUseAsTmpLvl(l)) {\n                    break;\n                }\n            }\n        };\n        checkLvls(1);\n        checkLvls(-1);\n        // remove the invalid layers; they will be replaced as needed later in this function\n        for(var i = layers.length - 1; i >= 0; i--){\n            var layer = layers[i];\n            if (layer.invalid) {\n                removeFromArray(layers, layer);\n            }\n        }\n    };\n    if (!lvlComplete) {\n        // if the current level is incomplete, then use the closest, best quality layerset temporarily\n        // and later queue the current layerset so we can get the proper quality level soon\n        checkTempLevels();\n    } else {\n        // log('level complete, using existing layers\\n--');\n        return layers;\n    }\n    var getBb = function getBb() {\n        if (!bb) {\n            bb = makeBoundingBox();\n            for(var i = 0; i < eles.length; i++){\n                updateBoundingBox(bb, eles[i].boundingBox());\n            }\n        }\n        return bb;\n    };\n    var makeLayer = function makeLayer(opts) {\n        opts = opts || {};\n        var after = opts.after;\n        getBb();\n        var w = Math.ceil(bb.w * scale);\n        var h = Math.ceil(bb.h * scale);\n        if (w > maxLayerDim || h > maxLayerDim) {\n            return null;\n        }\n        var area = w * h;\n        if (area > maxLayerArea) {\n            return null;\n        }\n        var layer = self1.makeLayer(bb, lvl);\n        if (after != null) {\n            var index = layers.indexOf(after) + 1;\n            layers.splice(index, 0, layer);\n        } else if (opts.insert === undefined || opts.insert) {\n            // no after specified => first layer made so put at start\n            layers.unshift(layer);\n        }\n        // if( tmpLayers ){\n        //self.queueLayer( layer );\n        // }\n        return layer;\n    };\n    if (self1.skipping && !firstGet) {\n        // log('skip layers');\n        return null;\n    }\n    // log('do layers');\n    var layer = null;\n    var maxElesPerLayer = eles.length / defNumLayers;\n    var allowLazyQueueing = !firstGet;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var rs = ele._private.rscratch;\n        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n        // log('look at ele', ele.id());\n        var existingLayer = caches[lvl];\n        if (existingLayer) {\n            // reuse layer for later eles\n            // log('reuse layer for', ele.id());\n            layer = existingLayer;\n            continue;\n        }\n        if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n            // log('make new layer for ele %s', ele.id());\n            layer = makeLayer({\n                insert: true,\n                after: layer\n            });\n            // if now layer can be built then we can't use layers at this level\n            if (!layer) {\n                return null;\n            }\n        // log('new layer with id %s', layer.id);\n        }\n        if (tmpLayers || allowLazyQueueing) {\n            // log('queue ele %s in layer %s', ele.id(), layer.id);\n            self1.queueLayer(layer, ele);\n        } else {\n            // log('draw ele %s in layer %s', ele.id(), layer.id);\n            self1.drawEleInLayer(layer, ele, lvl, pxRatio);\n        }\n        layer.eles.push(ele);\n        caches[lvl] = layer;\n    }\n    // log('--');\n    if (tmpLayers) {\n        // then we only queued the current layerset and can't draw it yet\n        return tmpLayers;\n    }\n    if (allowLazyQueueing) {\n        // log('lazy queue level', lvl);\n        return null;\n    }\n    return layers;\n};\n// a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\nLTCp.getEleLevelForLayerLevel = function(lvl, pxRatio) {\n    return lvl;\n};\nLTCp.drawEleInLayer = function(layer, ele, lvl, pxRatio) {\n    var self1 = this;\n    var r = this.renderer;\n    var context = layer.context;\n    var bb = ele.boundingBox();\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n        return;\n    }\n    lvl = self1.getEleLevelForLayerLevel(lvl, pxRatio);\n    {\n        r.setImgSmoothing(context, false);\n    }\n    {\n        r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n    }\n    {\n        r.setImgSmoothing(context, true);\n    }\n};\nLTCp.levelIsComplete = function(lvl, eles) {\n    var self1 = this;\n    var layers = self1.layersByLevel[lvl];\n    if (!layers || layers.length === 0) {\n        return false;\n    }\n    var numElesInLayers = 0;\n    for(var i = 0; i < layers.length; i++){\n        var layer = layers[i];\n        // if there are any eles needed to be drawn yet, the level is not complete\n        if (layer.reqs > 0) {\n            return false;\n        }\n        // if the layer is invalid, the level is not complete\n        if (layer.invalid) {\n            return false;\n        }\n        numElesInLayers += layer.eles.length;\n    }\n    // we should have exactly the number of eles passed in to be complete\n    if (numElesInLayers !== eles.length) {\n        return false;\n    }\n    return true;\n};\nLTCp.validateLayersElesOrdering = function(lvl, eles) {\n    var layers = this.layersByLevel[lvl];\n    if (!layers) {\n        return;\n    }\n    // if in a layer the eles are not in the same order, then the layer is invalid\n    // (i.e. there is an ele in between the eles in the layer)\n    for(var i = 0; i < layers.length; i++){\n        var layer = layers[i];\n        var offset = -1;\n        // find the offset\n        for(var j = 0; j < eles.length; j++){\n            if (layer.eles[0] === eles[j]) {\n                offset = j;\n                break;\n            }\n        }\n        if (offset < 0) {\n            // then the layer has nonexistent elements and is invalid\n            this.invalidateLayer(layer);\n            continue;\n        }\n        // the eles in the layer must be in the same continuous order, else the layer is invalid\n        var o = offset;\n        for(var j = 0; j < layer.eles.length; j++){\n            if (layer.eles[j] !== eles[o + j]) {\n                // log('invalidate based on ordering', layer.id);\n                this.invalidateLayer(layer);\n                break;\n            }\n        }\n    }\n};\nLTCp.updateElementsInLayers = function(eles, update) {\n    var self1 = this;\n    var isEles = element(eles[0]);\n    // collect udpated elements (cascaded from the layers) and update each\n    // layer itself along the way\n    for(var i = 0; i < eles.length; i++){\n        var req = isEles ? null : eles[i];\n        var ele = isEles ? eles[i] : eles[i].ele;\n        var rs = ele._private.rscratch;\n        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n        for(var l = minLvl; l <= maxLvl; l++){\n            var layer = caches[l];\n            if (!layer) {\n                continue;\n            }\n            // if update is a request from the ele cache, then it affects only\n            // the matching level\n            if (req && self1.getEleLevelForLayerLevel(layer.level) !== req.level) {\n                continue;\n            }\n            update(layer, ele, req);\n        }\n    }\n};\nLTCp.haveLayers = function() {\n    var self1 = this;\n    var haveLayers = false;\n    for(var l = minLvl; l <= maxLvl; l++){\n        var layers = self1.layersByLevel[l];\n        if (layers && layers.length > 0) {\n            haveLayers = true;\n            break;\n        }\n    }\n    return haveLayers;\n};\nLTCp.invalidateElements = function(eles) {\n    var self1 = this;\n    if (eles.length === 0) {\n        return;\n    }\n    self1.lastInvalidationTime = performanceNow();\n    // log('update invalidate layer time from eles');\n    if (eles.length === 0 || !self1.haveLayers()) {\n        return;\n    }\n    self1.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n        self1.invalidateLayer(layer);\n    });\n};\nLTCp.invalidateLayer = function(layer) {\n    // log('update invalidate layer time');\n    this.lastInvalidationTime = performanceNow();\n    if (layer.invalid) {\n        return;\n    } // save cycles\n    var lvl = layer.level;\n    var eles = layer.eles;\n    var layers = this.layersByLevel[lvl];\n    // log('invalidate layer', layer.id );\n    removeFromArray(layers, layer);\n    // layer.eles = [];\n    layer.elesQueue = [];\n    layer.invalid = true;\n    if (layer.replacement) {\n        layer.replacement.invalid = true;\n    }\n    for(var i = 0; i < eles.length; i++){\n        var caches = eles[i]._private.rscratch.imgLayerCaches;\n        if (caches) {\n            caches[lvl] = null;\n        }\n    }\n};\nLTCp.refineElementTextures = function(eles) {\n    var self1 = this;\n    // log('refine', eles.length);\n    self1.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n        var rLyr = layer.replacement;\n        if (!rLyr) {\n            rLyr = layer.replacement = self1.makeLayer(layer.bb, layer.level);\n            rLyr.replaces = layer;\n            rLyr.eles = layer.eles;\n        // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n        }\n        if (!rLyr.reqs) {\n            for(var i = 0; i < rLyr.eles.length; i++){\n                self1.queueLayer(rLyr, rLyr.eles[i]);\n            }\n        // log('queue replacement layer refinement', rLyr.id);\n        }\n    });\n};\nLTCp.enqueueElementRefinement = function(ele) {\n    this.eleTxrDeqs.merge(ele);\n    this.scheduleElementRefinement();\n};\nLTCp.queueLayer = function(layer, ele) {\n    var self1 = this;\n    var q = self1.layersQueue;\n    var elesQ = layer.elesQueue;\n    var hasId = elesQ.hasId = elesQ.hasId || {};\n    // if a layer is going to be replaced, queuing is a waste of time\n    if (layer.replacement) {\n        return;\n    }\n    if (ele) {\n        if (hasId[ele.id()]) {\n            return;\n        }\n        elesQ.push(ele);\n        hasId[ele.id()] = true;\n    }\n    if (layer.reqs) {\n        layer.reqs++;\n        q.updateItem(layer);\n    } else {\n        layer.reqs = 1;\n        q.push(layer);\n    }\n};\nLTCp.dequeue = function(pxRatio) {\n    var self1 = this;\n    var q = self1.layersQueue;\n    var deqd = [];\n    var eleDeqs = 0;\n    while(eleDeqs < maxDeqSize){\n        if (q.size() === 0) {\n            break;\n        }\n        var layer = q.peek();\n        // if a layer has been or will be replaced, then don't waste time with it\n        if (layer.replacement) {\n            // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n            q.pop();\n            continue;\n        }\n        // if this is a replacement layer that has been superceded, then forget it\n        if (layer.replaces && layer !== layer.replaces.replacement) {\n            // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n            q.pop();\n            continue;\n        }\n        if (layer.invalid) {\n            // log('replacement layer %s is invalid; dequeued', layer.id);\n            q.pop();\n            continue;\n        }\n        var ele = layer.elesQueue.shift();\n        if (ele) {\n            // log('dequeue layer %s', layer.id);\n            self1.drawEleInLayer(layer, ele, layer.level, pxRatio);\n            eleDeqs++;\n        }\n        if (deqd.length === 0) {\n            // we need only one entry in deqd to queue redrawing etc\n            deqd.push(true);\n        }\n        // if the layer has all its eles done, then remove from the queue\n        if (layer.elesQueue.length === 0) {\n            q.pop();\n            layer.reqs = 0;\n            // log('dequeue of layer %s complete', layer.id);\n            // when a replacement layer is dequeued, it replaces the old layer in the level\n            if (layer.replaces) {\n                self1.applyLayerReplacement(layer);\n            }\n            self1.requestRedraw();\n        }\n    }\n    return deqd;\n};\nLTCp.applyLayerReplacement = function(layer) {\n    var self1 = this;\n    var layersInLevel = self1.layersByLevel[layer.level];\n    var replaced = layer.replaces;\n    var index = layersInLevel.indexOf(replaced);\n    // if the replaced layer is not in the active list for the level, then replacing\n    // refs would be a mistake (i.e. overwriting the true active layer)\n    if (index < 0 || replaced.invalid) {\n        // log('replacement layer would have no effect', layer.id);\n        return;\n    }\n    layersInLevel[index] = layer; // replace level ref\n    // replace refs in eles\n    for(var i = 0; i < layer.eles.length; i++){\n        var _p = layer.eles[i]._private;\n        var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n        if (cache) {\n            cache[layer.level] = layer;\n        }\n    }\n    // log('apply replacement layer %s over %s', layer.id, replaced.id);\n    self1.requestRedraw();\n};\nLTCp.requestRedraw = debounce(function() {\n    var r = this.renderer;\n    r.redrawHint(\"eles\", true);\n    r.redrawHint(\"drag\", true);\n    r.redraw();\n}, 100);\nLTCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold,\n    deqCost: deqCost,\n    deqAvgCost: deqAvgCost,\n    deqNoDrawCost: deqNoDrawCost,\n    deqFastCost: deqFastCost,\n    deq: function deq(self1, pxRatio) {\n        return self1.dequeue(pxRatio);\n    },\n    onDeqd: noop$1,\n    shouldRedraw: trueify,\n    priority: function priority(self1) {\n        return self1.renderer.beforeRenderPriorities.lyrTxrDeq;\n    }\n});\nvar CRp$b = {};\nvar impl;\nfunction polygon(context, points) {\n    for(var i = 0; i < points.length; i++){\n        var pt = points[i];\n        context.lineTo(pt.x, pt.y);\n    }\n}\nfunction triangleBackcurve(context, points, controlPoint) {\n    var firstPt;\n    for(var i = 0; i < points.length; i++){\n        var pt = points[i];\n        if (i === 0) {\n            firstPt = pt;\n        }\n        context.lineTo(pt.x, pt.y);\n    }\n    context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n}\nfunction triangleTee(context, trianglePoints, teePoints) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    var triPts = trianglePoints;\n    for(var i = 0; i < triPts.length; i++){\n        var pt = triPts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    var teePts = teePoints;\n    var firstTeePt = teePoints[0];\n    context.moveTo(firstTeePt.x, firstTeePt.y);\n    for(var i = 1; i < teePts.length; i++){\n        var pt = teePts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    if (context.closePath) {\n        context.closePath();\n    }\n}\nfunction circleTriangle(context, trianglePoints, rx, ry, r) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    var triPts = trianglePoints;\n    var firstTrPt = triPts[0];\n    context.moveTo(firstTrPt.x, firstTrPt.y);\n    for(var i = 0; i < triPts.length; i++){\n        var pt = triPts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    if (context.closePath) {\n        context.closePath();\n    }\n}\nfunction circle$1(context, rx, ry, r) {\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n}\nCRp$b.arrowShapeImpl = function(name) {\n    return (impl || (impl = {\n        \"polygon\": polygon,\n        \"triangle-backcurve\": triangleBackcurve,\n        \"triangle-tee\": triangleTee,\n        \"circle-triangle\": circleTriangle,\n        \"triangle-cross\": triangleTee,\n        \"circle\": circle$1\n    }))[name];\n};\nvar CRp$a = {};\nCRp$a.drawElement = function(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    } else {\n        r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    }\n};\nCRp$a.drawElementOverlay = function(context, ele) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNodeOverlay(context, ele);\n    } else {\n        r.drawEdgeOverlay(context, ele);\n    }\n};\nCRp$a.drawElementUnderlay = function(context, ele) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNodeUnderlay(context, ele);\n    } else {\n        r.drawEdgeUnderlay(context, ele);\n    }\n};\nCRp$a.drawCachedElementPortion = function(context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n    var r = this;\n    var bb = eleTxrCache.getBoundingBox(ele);\n    if (bb.w === 0 || bb.h === 0) {\n        return;\n    } // ignore zero size case\n    var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n    if (eleCache != null) {\n        var opacity = getOpacity(r, ele);\n        if (opacity === 0) {\n            return;\n        }\n        var theta = getRotation(r, ele);\n        var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h;\n        var x, y, sx, sy, smooth;\n        if (theta !== 0) {\n            var rotPt = eleTxrCache.getRotationPoint(ele);\n            sx = rotPt.x;\n            sy = rotPt.y;\n            context.translate(sx, sy);\n            context.rotate(theta);\n            smooth = r.getImgSmoothing(context);\n            if (!smooth) {\n                r.setImgSmoothing(context, true);\n            }\n            var off = eleTxrCache.getRotationOffset(ele);\n            x = off.x;\n            y = off.y;\n        } else {\n            x = x1;\n            y = y1;\n        }\n        var oldGlobalAlpha;\n        if (opacity !== 1) {\n            oldGlobalAlpha = context.globalAlpha;\n            context.globalAlpha = oldGlobalAlpha * opacity;\n        }\n        context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n        if (opacity !== 1) {\n            context.globalAlpha = oldGlobalAlpha;\n        }\n        if (theta !== 0) {\n            context.rotate(-theta);\n            context.translate(-sx, -sy);\n            if (!smooth) {\n                r.setImgSmoothing(context, false);\n            }\n        }\n    } else {\n        eleTxrCache.drawElement(context, ele); // direct draw fallback\n    }\n};\nvar getZeroRotation = function getZeroRotation() {\n    return 0;\n};\nvar getLabelRotation = function getLabelRotation(r, ele) {\n    return r.getTextAngle(ele, null);\n};\nvar getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n    return r.getTextAngle(ele, \"source\");\n};\nvar getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n    return r.getTextAngle(ele, \"target\");\n};\nvar getOpacity = function getOpacity(r, ele) {\n    return ele.effectiveOpacity();\n};\nvar getTextOpacity = function getTextOpacity(e, ele) {\n    return ele.pstyle(\"text-opacity\").pfValue * ele.effectiveOpacity();\n};\nCRp$a.drawCachedElement = function(context, ele, pxRatio, extent, lvl, requestHighQuality) {\n    var r = this;\n    var _r$data = r.data, eleTxrCache = _r$data.eleTxrCache, lblTxrCache = _r$data.lblTxrCache, slbTxrCache = _r$data.slbTxrCache, tlbTxrCache = _r$data.tlbTxrCache;\n    var bb = ele.boundingBox();\n    var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n        return;\n    }\n    if (!extent || boundingBoxesIntersect(bb, extent)) {\n        var isEdge = ele.isEdge();\n        var badLine = ele.element()._private.rscratch.badLine;\n        r.drawElementUnderlay(context, ele);\n        r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n        if (!isEdge || !badLine) {\n            r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n        }\n        if (isEdge && !badLine) {\n            r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n            r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n        }\n        r.drawElementOverlay(context, ele);\n    }\n};\nCRp$a.drawElements = function(context, eles) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        r.drawElement(context, ele);\n    }\n};\nCRp$a.drawCachedElements = function(context, eles, pxRatio, extent) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n};\nCRp$a.drawCachedNodes = function(context, eles, pxRatio, extent) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (!ele.isNode()) {\n            continue;\n        }\n        r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n};\nCRp$a.drawLayeredElements = function(context, eles, pxRatio, extent) {\n    var r = this;\n    var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n    if (layers) {\n        for(var i = 0; i < layers.length; i++){\n            var layer = layers[i];\n            var bb = layer.bb;\n            if (bb.w === 0 || bb.h === 0) {\n                continue;\n            }\n            context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n        }\n    } else {\n        // fall back on plain caching if no layers\n        r.drawCachedElements(context, eles, pxRatio, extent);\n    }\n};\nvar CRp$9 = {};\nCRp$9.drawEdge = function(context, edge, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var rs = edge._private.rscratch;\n    if (shouldDrawOpacity && !edge.visible()) {\n        return;\n    }\n    // if bezier ctrl pts can not be calculated, then die\n    if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n        // isNaN in case edge is impossible and browser bugs (e.g. safari)\n        return;\n    }\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    var opacity = shouldDrawOpacity ? edge.pstyle(\"opacity\").value : 1;\n    var lineOpacity = shouldDrawOpacity ? edge.pstyle(\"line-opacity\").value : 1;\n    var curveStyle = edge.pstyle(\"curve-style\").value;\n    var lineStyle = edge.pstyle(\"line-style\").value;\n    var edgeWidth = edge.pstyle(\"width\").pfValue;\n    var lineCap = edge.pstyle(\"line-cap\").value;\n    var lineOutlineWidth = edge.pstyle(\"line-outline-width\").value;\n    var lineOutlineColor = edge.pstyle(\"line-outline-color\").value;\n    var effectiveLineOpacity = opacity * lineOpacity;\n    // separate arrow opacity would require arrow-opacity property\n    var effectiveArrowOpacity = opacity * lineOpacity;\n    var drawLine = function drawLine() {\n        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n        if (curveStyle === \"straight-triangle\") {\n            r.eleStrokeStyle(context, edge, strokeOpacity);\n            r.drawEdgeTrianglePath(edge, context, rs.allpts);\n        } else {\n            context.lineWidth = edgeWidth;\n            context.lineCap = lineCap;\n            r.eleStrokeStyle(context, edge, strokeOpacity);\n            r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n            context.lineCap = \"butt\"; // reset for other drawing functions\n        }\n    };\n    var drawLineOutline = function drawLineOutline() {\n        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n        context.lineWidth = edgeWidth + lineOutlineWidth;\n        context.lineCap = lineCap;\n        if (lineOutlineWidth > 0) {\n            r.colorStrokeStyle(context, lineOutlineColor[0], lineOutlineColor[1], lineOutlineColor[2], strokeOpacity);\n        } else {\n            // do not draw any lineOutline\n            context.lineCap = \"butt\"; // reset for other drawing functions\n            return;\n        }\n        if (curveStyle === \"straight-triangle\") {\n            r.drawEdgeTrianglePath(edge, context, rs.allpts);\n        } else {\n            r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n            context.lineCap = \"butt\"; // reset for other drawing functions\n        }\n    };\n    var drawOverlay = function drawOverlay() {\n        if (!shouldDrawOverlay) {\n            return;\n        }\n        r.drawEdgeOverlay(context, edge);\n    };\n    var drawUnderlay = function drawUnderlay() {\n        if (!shouldDrawOverlay) {\n            return;\n        }\n        r.drawEdgeUnderlay(context, edge);\n    };\n    var drawArrows = function drawArrows() {\n        var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n        r.drawArrowheads(context, edge, arrowOpacity);\n    };\n    var drawText = function drawText() {\n        r.drawElementText(context, edge, null, drawLabel);\n    };\n    context.lineJoin = \"round\";\n    var ghost = edge.pstyle(\"ghost\").value === \"yes\";\n    if (ghost) {\n        var gx = edge.pstyle(\"ghost-offset-x\").pfValue;\n        var gy = edge.pstyle(\"ghost-offset-y\").pfValue;\n        var ghostOpacity = edge.pstyle(\"ghost-opacity\").value;\n        var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n        context.translate(gx, gy);\n        drawLine(effectiveGhostOpacity);\n        drawArrows(effectiveGhostOpacity);\n        context.translate(-gx, -gy);\n    } else {\n        drawLineOutline();\n    }\n    drawUnderlay();\n    drawLine();\n    drawArrows();\n    drawOverlay();\n    drawText();\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nvar drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n    if (![\n        \"overlay\",\n        \"underlay\"\n    ].includes(overlayOrUnderlay)) {\n        throw new Error(\"Invalid state\");\n    }\n    return function(context, edge) {\n        if (!edge.visible()) {\n            return;\n        }\n        var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n        if (opacity === 0) {\n            return;\n        }\n        var r = this;\n        var usePaths = r.usePaths();\n        var rs = edge._private.rscratch;\n        var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n        var width = 2 * padding;\n        var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n        context.lineWidth = width;\n        if (rs.edgeType === \"self\" && !usePaths) {\n            context.lineCap = \"butt\";\n        } else {\n            context.lineCap = \"round\";\n        }\n        r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n        r.drawEdgePath(edge, context, rs.allpts, \"solid\");\n    };\n};\nCRp$9.drawEdgeOverlay = drawEdgeOverlayUnderlay(\"overlay\");\nCRp$9.drawEdgeUnderlay = drawEdgeOverlayUnderlay(\"underlay\");\nCRp$9.drawEdgePath = function(edge, context, pts, type) {\n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = this.usePaths();\n    var lineDashPattern = edge.pstyle(\"line-dash-pattern\").pfValue;\n    var lineDashOffset = edge.pstyle(\"line-dash-offset\").pfValue;\n    if (usePaths) {\n        var pathCacheKey = pts.join(\"$\");\n        var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n        if (keyMatches) {\n            path = context = rs.pathCache;\n            pathCacheHit = true;\n        } else {\n            path = context = new Path2D();\n            rs.pathCacheKey = pathCacheKey;\n            rs.pathCache = path;\n        }\n    }\n    if (canvasCxt.setLineDash) {\n        // for very outofdate browsers\n        switch(type){\n            case \"dotted\":\n                canvasCxt.setLineDash([\n                    1,\n                    1\n                ]);\n                break;\n            case \"dashed\":\n                canvasCxt.setLineDash(lineDashPattern);\n                canvasCxt.lineDashOffset = lineDashOffset;\n                break;\n            case \"solid\":\n                canvasCxt.setLineDash([]);\n                break;\n        }\n    }\n    if (!pathCacheHit && !rs.badLine) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.moveTo(pts[0], pts[1]);\n        switch(rs.edgeType){\n            case \"bezier\":\n            case \"self\":\n            case \"compound\":\n            case \"multibezier\":\n                for(var i = 2; i + 3 < pts.length; i += 4){\n                    context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n                }\n                break;\n            case \"straight\":\n            case \"haystack\":\n                for(var _i = 2; _i + 1 < pts.length; _i += 2){\n                    context.lineTo(pts[_i], pts[_i + 1]);\n                }\n                break;\n            case \"segments\":\n                if (rs.isRound) {\n                    var _iterator = _createForOfIteratorHelper(rs.roundCorners), _step;\n                    try {\n                        for(_iterator.s(); !(_step = _iterator.n()).done;){\n                            var corner = _step.value;\n                            drawPreparedRoundCorner(context, corner);\n                        }\n                    } catch (err) {\n                        _iterator.e(err);\n                    } finally{\n                        _iterator.f();\n                    }\n                    context.lineTo(pts[pts.length - 2], pts[pts.length - 1]);\n                } else {\n                    for(var _i2 = 2; _i2 + 1 < pts.length; _i2 += 2){\n                        context.lineTo(pts[_i2], pts[_i2 + 1]);\n                    }\n                }\n                break;\n        }\n    }\n    context = canvasCxt;\n    if (usePaths) {\n        context.stroke(path);\n    } else {\n        context.stroke();\n    }\n    // reset any line dashes\n    if (context.setLineDash) {\n        // for very outofdate browsers\n        context.setLineDash([]);\n    }\n};\nCRp$9.drawEdgeTrianglePath = function(edge, context, pts) {\n    // use line stroke style for triangle fill style\n    context.fillStyle = context.strokeStyle;\n    var edgeWidth = edge.pstyle(\"width\").pfValue;\n    for(var i = 0; i + 1 < pts.length; i += 2){\n        var vector = [\n            pts[i + 2] - pts[i],\n            pts[i + 3] - pts[i + 1]\n        ];\n        var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n        var normal = [\n            vector[1] / length,\n            -vector[0] / length\n        ];\n        var triangleHead = [\n            normal[0] * edgeWidth / 2,\n            normal[1] * edgeWidth / 2\n        ];\n        context.beginPath();\n        context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n        context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n        context.lineTo(pts[i + 2], pts[i + 3]);\n        context.closePath();\n        context.fill();\n    }\n};\nCRp$9.drawArrowheads = function(context, edge, opacity) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === \"haystack\";\n    if (!isHaystack) {\n        this.drawArrowhead(context, edge, \"source\", rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n    }\n    this.drawArrowhead(context, edge, \"mid-target\", rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n    this.drawArrowhead(context, edge, \"mid-source\", rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n    if (!isHaystack) {\n        this.drawArrowhead(context, edge, \"target\", rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n    }\n};\nCRp$9.drawArrowhead = function(context, edge, prefix, x, y, angle, opacity) {\n    if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n        return;\n    }\n    var self1 = this;\n    var arrowShape = edge.pstyle(prefix + \"-arrow-shape\").value;\n    if (arrowShape === \"none\") {\n        return;\n    }\n    var arrowClearFill = edge.pstyle(prefix + \"-arrow-fill\").value === \"hollow\" ? \"both\" : \"filled\";\n    var arrowFill = edge.pstyle(prefix + \"-arrow-fill\").value;\n    var edgeWidth = edge.pstyle(\"width\").pfValue;\n    var pArrowWidth = edge.pstyle(prefix + \"-arrow-width\");\n    var arrowWidth = pArrowWidth.value === \"match-line\" ? edgeWidth : pArrowWidth.pfValue;\n    if (pArrowWidth.units === \"%\") arrowWidth *= edgeWidth;\n    var edgeOpacity = edge.pstyle(\"opacity\").value;\n    if (opacity === undefined) {\n        opacity = edgeOpacity;\n    }\n    var gco = context.globalCompositeOperation;\n    if (opacity !== 1 || arrowFill === \"hollow\") {\n        // then extra clear is needed\n        context.globalCompositeOperation = \"destination-out\";\n        self1.colorFillStyle(context, 255, 255, 255, 1);\n        self1.colorStrokeStyle(context, 255, 255, 255, 1);\n        self1.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n        context.globalCompositeOperation = gco;\n    } // otherwise, the opaque arrow clears it for free :)\n    var color = edge.pstyle(prefix + \"-arrow-color\").value;\n    self1.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    self1.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    self1.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n};\nCRp$9.drawArrowShape = function(edge, context, fill, edgeWidth, shape, shapeWidth, x, y, angle) {\n    var r = this;\n    var usePaths = this.usePaths() && shape !== \"triangle-cross\";\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = {\n        x: x,\n        y: y\n    };\n    var scale = edge.pstyle(\"arrow-scale\").value;\n    var size = this.getArrowWidth(edgeWidth, scale);\n    var shapeImpl = r.arrowShapes[shape];\n    if (usePaths) {\n        var cache = r.arrowPathCache = r.arrowPathCache || [];\n        var key = hashString(shape);\n        var cachedPath = cache[key];\n        if (cachedPath != null) {\n            path = context = cachedPath;\n            pathCacheHit = true;\n        } else {\n            path = context = new Path2D();\n            cache[key] = path;\n        }\n    }\n    if (!pathCacheHit) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        if (usePaths) {\n            // store in the path cache with values easily manipulated later\n            shapeImpl.draw(context, 1, 0, {\n                x: 0,\n                y: 0\n            }, 1);\n        } else {\n            shapeImpl.draw(context, size, angle, translation, edgeWidth);\n        }\n        if (context.closePath) {\n            context.closePath();\n        }\n    }\n    context = canvasContext;\n    if (usePaths) {\n        // set transform to arrow position/orientation\n        context.translate(x, y);\n        context.rotate(angle);\n        context.scale(size, size);\n    }\n    if (fill === \"filled\" || fill === \"both\") {\n        if (usePaths) {\n            context.fill(path);\n        } else {\n            context.fill();\n        }\n    }\n    if (fill === \"hollow\" || fill === \"both\") {\n        context.lineWidth = shapeWidth / (usePaths ? size : 1);\n        context.lineJoin = \"miter\";\n        if (usePaths) {\n            context.stroke(path);\n        } else {\n            context.stroke();\n        }\n    }\n    if (usePaths) {\n        // reset transform by applying inverse\n        context.scale(1 / size, 1 / size);\n        context.rotate(-angle);\n        context.translate(-x, -y);\n    }\n};\nvar CRp$8 = {};\nCRp$8.safeDrawImage = function(context, img, ix, iy, iw, ih, x, y, w, h) {\n    // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n    if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n        return;\n    }\n    try {\n        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n    } catch (e) {\n        warn(e);\n    }\n};\nCRp$8.drawInscribedImage = function(context, img, node, index, nodeOpacity) {\n    var r = this;\n    var pos = node.position();\n    var nodeX = pos.x;\n    var nodeY = pos.y;\n    var styleObj = node.cy().style();\n    var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n    var fit = getIndexedStyle(node, \"background-fit\", \"value\", index);\n    var repeat = getIndexedStyle(node, \"background-repeat\", \"value\", index);\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var paddingX2 = node.padding() * 2;\n    var nodeTW = nodeW + (getIndexedStyle(node, \"background-width-relative-to\", \"value\", index) === \"inner\" ? 0 : paddingX2);\n    var nodeTH = nodeH + (getIndexedStyle(node, \"background-height-relative-to\", \"value\", index) === \"inner\" ? 0 : paddingX2);\n    var rs = node._private.rscratch;\n    var clip = getIndexedStyle(node, \"background-clip\", \"value\", index);\n    var shouldClip = clip === \"node\";\n    var imgOpacity = getIndexedStyle(node, \"background-image-opacity\", \"value\", index) * nodeOpacity;\n    var smooth = getIndexedStyle(node, \"background-image-smoothing\", \"value\", index);\n    var cornerRadius = node.pstyle(\"corner-radius\").value;\n    if (cornerRadius !== \"auto\") cornerRadius = node.pstyle(\"corner-radius\").pfValue;\n    var imgW = img.width || img.cachedW;\n    var imgH = img.height || img.cachedH;\n    // workaround for broken browsers like ie\n    if (null == imgW || null == imgH) {\n        document.body.appendChild(img); // eslint-disable-line no-undef\n        imgW = img.cachedW = img.width || img.offsetWidth;\n        imgH = img.cachedH = img.height || img.offsetHeight;\n        document.body.removeChild(img); // eslint-disable-line no-undef\n    }\n    var w = imgW;\n    var h = imgH;\n    if (getIndexedStyle(node, \"background-width\", \"value\", index) !== \"auto\") {\n        if (getIndexedStyle(node, \"background-width\", \"units\", index) === \"%\") {\n            w = getIndexedStyle(node, \"background-width\", \"pfValue\", index) * nodeTW;\n        } else {\n            w = getIndexedStyle(node, \"background-width\", \"pfValue\", index);\n        }\n    }\n    if (getIndexedStyle(node, \"background-height\", \"value\", index) !== \"auto\") {\n        if (getIndexedStyle(node, \"background-height\", \"units\", index) === \"%\") {\n            h = getIndexedStyle(node, \"background-height\", \"pfValue\", index) * nodeTH;\n        } else {\n            h = getIndexedStyle(node, \"background-height\", \"pfValue\", index);\n        }\n    }\n    if (w === 0 || h === 0) {\n        return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n    if (fit === \"contain\") {\n        var scale = Math.min(nodeTW / w, nodeTH / h);\n        w *= scale;\n        h *= scale;\n    } else if (fit === \"cover\") {\n        var scale = Math.max(nodeTW / w, nodeTH / h);\n        w *= scale;\n        h *= scale;\n    }\n    var x = nodeX - nodeTW / 2; // left\n    var posXUnits = getIndexedStyle(node, \"background-position-x\", \"units\", index);\n    var posXPfVal = getIndexedStyle(node, \"background-position-x\", \"pfValue\", index);\n    if (posXUnits === \"%\") {\n        x += (nodeTW - w) * posXPfVal;\n    } else {\n        x += posXPfVal;\n    }\n    var offXUnits = getIndexedStyle(node, \"background-offset-x\", \"units\", index);\n    var offXPfVal = getIndexedStyle(node, \"background-offset-x\", \"pfValue\", index);\n    if (offXUnits === \"%\") {\n        x += (nodeTW - w) * offXPfVal;\n    } else {\n        x += offXPfVal;\n    }\n    var y = nodeY - nodeTH / 2; // top\n    var posYUnits = getIndexedStyle(node, \"background-position-y\", \"units\", index);\n    var posYPfVal = getIndexedStyle(node, \"background-position-y\", \"pfValue\", index);\n    if (posYUnits === \"%\") {\n        y += (nodeTH - h) * posYPfVal;\n    } else {\n        y += posYPfVal;\n    }\n    var offYUnits = getIndexedStyle(node, \"background-offset-y\", \"units\", index);\n    var offYPfVal = getIndexedStyle(node, \"background-offset-y\", \"pfValue\", index);\n    if (offYUnits === \"%\") {\n        y += (nodeTH - h) * offYPfVal;\n    } else {\n        y += offYPfVal;\n    }\n    if (rs.pathCache) {\n        x -= nodeX;\n        y -= nodeY;\n        nodeX = 0;\n        nodeY = 0;\n    }\n    var gAlpha = context.globalAlpha;\n    context.globalAlpha = imgOpacity;\n    var smoothingEnabled = r.getImgSmoothing(context);\n    var isSmoothingSwitched = false;\n    if (smooth === \"no\" && smoothingEnabled) {\n        r.setImgSmoothing(context, false);\n        isSmoothingSwitched = true;\n    } else if (smooth === \"yes\" && !smoothingEnabled) {\n        r.setImgSmoothing(context, true);\n        isSmoothingSwitched = true;\n    }\n    if (repeat === \"no-repeat\") {\n        if (shouldClip) {\n            context.save();\n            if (rs.pathCache) {\n                context.clip(rs.pathCache);\n            } else {\n                r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n                context.clip();\n            }\n        }\n        r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n        if (shouldClip) {\n            context.restore();\n        }\n    } else {\n        var pattern = context.createPattern(img, repeat);\n        context.fillStyle = pattern;\n        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n        context.translate(x, y);\n        context.fill();\n        context.translate(-x, -y);\n    }\n    context.globalAlpha = gAlpha;\n    if (isSmoothingSwitched) {\n        r.setImgSmoothing(context, smoothingEnabled);\n    }\n};\nvar CRp$7 = {};\nCRp$7.eleTextBiggerThanMin = function(ele, scale) {\n    if (!scale) {\n        var zoom = ele.cy().zoom();\n        var pxRatio = this.getPixelRatio();\n        var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n        scale = Math.pow(2, lvl);\n    }\n    var computedSize = ele.pstyle(\"font-size\").pfValue * scale;\n    var minSize = ele.pstyle(\"min-zoomed-font-size\").pfValue;\n    if (computedSize < minSize) {\n        return false;\n    }\n    return true;\n};\nCRp$7.drawElementText = function(context, ele, shiftToOriginWithBb, force, prefix) {\n    var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    if (force == null) {\n        if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n            return;\n        }\n    } else if (force === false) {\n        return;\n    }\n    if (ele.isNode()) {\n        var label = ele.pstyle(\"label\");\n        if (!label || !label.value) {\n            return;\n        }\n        var justification = r.getLabelJustification(ele);\n        context.textAlign = justification;\n        context.textBaseline = \"bottom\";\n    } else {\n        var badLine = ele.element()._private.rscratch.badLine;\n        var _label = ele.pstyle(\"label\");\n        var srcLabel = ele.pstyle(\"source-label\");\n        var tgtLabel = ele.pstyle(\"target-label\");\n        if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n            return;\n        }\n        context.textAlign = \"center\";\n        context.textBaseline = \"bottom\";\n    }\n    var applyRotation = !shiftToOriginWithBb;\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    if (prefix == null) {\n        r.drawText(context, ele, null, applyRotation, useEleOpacity);\n        if (ele.isEdge()) {\n            r.drawText(context, ele, \"source\", applyRotation, useEleOpacity);\n            r.drawText(context, ele, \"target\", applyRotation, useEleOpacity);\n        }\n    } else {\n        r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n    }\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nCRp$7.getFontCache = function(context) {\n    var cache;\n    this.fontCaches = this.fontCaches || [];\n    for(var i = 0; i < this.fontCaches.length; i++){\n        cache = this.fontCaches[i];\n        if (cache.context === context) {\n            return cache;\n        }\n    }\n    cache = {\n        context: context\n    };\n    this.fontCaches.push(cache);\n    return cache;\n};\n// set up canvas context with font\n// returns transformed text string\nCRp$7.setupTextStyle = function(context, ele) {\n    var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Font style\n    var labelStyle = ele.pstyle(\"font-style\").strValue;\n    var labelSize = ele.pstyle(\"font-size\").pfValue + \"px\";\n    var labelFamily = ele.pstyle(\"font-family\").strValue;\n    var labelWeight = ele.pstyle(\"font-weight\").strValue;\n    var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle(\"text-opacity\").value : 1;\n    var outlineOpacity = ele.pstyle(\"text-outline-opacity\").value * opacity;\n    var color = ele.pstyle(\"color\").value;\n    var outlineColor = ele.pstyle(\"text-outline-color\").value;\n    context.font = labelStyle + \" \" + labelWeight + \" \" + labelSize + \" \" + labelFamily;\n    context.lineJoin = \"round\"; // so text outlines aren't jagged\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n};\nfunction circle(ctx, x, y, width, height) {\n    var diameter = Math.min(width, height);\n    var radius = diameter / 2;\n    var centerX = x + width / 2;\n    var centerY = y + height / 2;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n    ctx.closePath();\n}\nfunction roundRect(ctx, x, y, width, height) {\n    var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n    var r = Math.min(radius, width / 2, height / 2); // prevent overflow\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + width - r, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + r);\n    ctx.lineTo(x + width, y + height - r);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);\n    ctx.lineTo(x + r, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n}\nCRp$7.getTextAngle = function(ele, prefix) {\n    var theta;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var pdash = prefix ? prefix + \"-\" : \"\";\n    var rotation = ele.pstyle(pdash + \"text-rotation\");\n    if (rotation.strValue === \"autorotate\") {\n        var textAngle = getPrefixedProperty(rscratch, \"labelAngle\", prefix);\n        theta = ele.isEdge() ? textAngle : 0;\n    } else if (rotation.strValue === \"none\") {\n        theta = 0;\n    } else {\n        theta = rotation.pfValue;\n    }\n    return theta;\n};\nCRp$7.drawText = function(context, ele, prefix) {\n    var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n    if (useEleOpacity && (parentOpacity === 0 || ele.pstyle(\"text-opacity\").value === 0)) {\n        return;\n    }\n    // use 'main' as an alias for the main label (i.e. null prefix)\n    if (prefix === \"main\") {\n        prefix = null;\n    }\n    var textX = getPrefixedProperty(rscratch, \"labelX\", prefix);\n    var textY = getPrefixedProperty(rscratch, \"labelY\", prefix);\n    var orgTextX, orgTextY; // used for rotation\n    var text = this.getLabelText(ele, prefix);\n    if (text != null && text !== \"\" && !isNaN(textX) && !isNaN(textY)) {\n        this.setupTextStyle(context, ele, useEleOpacity);\n        var pdash = prefix ? prefix + \"-\" : \"\";\n        var textW = getPrefixedProperty(rscratch, \"labelWidth\", prefix);\n        var textH = getPrefixedProperty(rscratch, \"labelHeight\", prefix);\n        var marginX = ele.pstyle(pdash + \"text-margin-x\").pfValue;\n        var marginY = ele.pstyle(pdash + \"text-margin-y\").pfValue;\n        var isEdge = ele.isEdge();\n        var halign = ele.pstyle(\"text-halign\").value;\n        var valign = ele.pstyle(\"text-valign\").value;\n        if (isEdge) {\n            halign = \"center\";\n            valign = \"center\";\n        }\n        textX += marginX;\n        textY += marginY;\n        var theta;\n        if (!applyRotation) {\n            theta = 0;\n        } else {\n            theta = this.getTextAngle(ele, prefix);\n        }\n        if (theta !== 0) {\n            orgTextX = textX;\n            orgTextY = textY;\n            context.translate(orgTextX, orgTextY);\n            context.rotate(theta);\n            textX = 0;\n            textY = 0;\n        }\n        switch(valign){\n            case \"top\":\n                break;\n            case \"center\":\n                textY += textH / 2;\n                break;\n            case \"bottom\":\n                textY += textH;\n                break;\n        }\n        var backgroundOpacity = ele.pstyle(\"text-background-opacity\").value;\n        var borderOpacity = ele.pstyle(\"text-border-opacity\").value;\n        var textBorderWidth = ele.pstyle(\"text-border-width\").pfValue;\n        var backgroundPadding = ele.pstyle(\"text-background-padding\").pfValue;\n        var styleShape = ele.pstyle(\"text-background-shape\").strValue;\n        var rounded = styleShape === \"round-rectangle\" || styleShape === \"roundrectangle\";\n        var circled = styleShape === \"circle\";\n        var roundRadius = 2;\n        if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n            var textFill = context.fillStyle;\n            var textStroke = context.strokeStyle;\n            var textLineWidth = context.lineWidth;\n            var textBackgroundColor = ele.pstyle(\"text-background-color\").value;\n            var textBorderColor = ele.pstyle(\"text-border-color\").value;\n            var textBorderStyle = ele.pstyle(\"text-border-style\").value;\n            var doFill = backgroundOpacity > 0;\n            var doStroke = textBorderWidth > 0 && borderOpacity > 0;\n            var bgX = textX - backgroundPadding;\n            switch(halign){\n                case \"left\":\n                    bgX -= textW;\n                    break;\n                case \"center\":\n                    bgX -= textW / 2;\n                    break;\n            }\n            var bgY = textY - textH - backgroundPadding;\n            var bgW = textW + 2 * backgroundPadding;\n            var bgH = textH + 2 * backgroundPadding;\n            if (doFill) {\n                context.fillStyle = \"rgba(\".concat(textBackgroundColor[0], \",\").concat(textBackgroundColor[1], \",\").concat(textBackgroundColor[2], \",\").concat(backgroundOpacity * parentOpacity, \")\");\n            }\n            if (doStroke) {\n                context.strokeStyle = \"rgba(\".concat(textBorderColor[0], \",\").concat(textBorderColor[1], \",\").concat(textBorderColor[2], \",\").concat(borderOpacity * parentOpacity, \")\");\n                context.lineWidth = textBorderWidth;\n                if (context.setLineDash) {\n                    switch(textBorderStyle){\n                        case \"dotted\":\n                            context.setLineDash([\n                                1,\n                                1\n                            ]);\n                            break;\n                        case \"dashed\":\n                            context.setLineDash([\n                                4,\n                                2\n                            ]);\n                            break;\n                        case \"double\":\n                            context.lineWidth = textBorderWidth / 4;\n                            context.setLineDash([]);\n                            break;\n                        case \"solid\":\n                        default:\n                            context.setLineDash([]);\n                            break;\n                    }\n                }\n            }\n            if (rounded) {\n                context.beginPath();\n                roundRect(context, bgX, bgY, bgW, bgH, roundRadius);\n            } else if (circled) {\n                context.beginPath();\n                circle(context, bgX, bgY, bgW, bgH);\n            } else {\n                context.beginPath();\n                context.rect(bgX, bgY, bgW, bgH);\n            }\n            if (doFill) context.fill();\n            if (doStroke) context.stroke();\n            // Double border pass for 'double' style\n            if (doStroke && textBorderStyle === \"double\") {\n                var whiteWidth = textBorderWidth / 2;\n                context.beginPath();\n                if (rounded) {\n                    roundRect(context, bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth, roundRadius);\n                } else {\n                    context.rect(bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth);\n                }\n                context.stroke();\n            }\n            context.fillStyle = textFill;\n            context.strokeStyle = textStroke;\n            context.lineWidth = textLineWidth;\n            if (context.setLineDash) context.setLineDash([]);\n        }\n        var lineWidth = 2 * ele.pstyle(\"text-outline-width\").pfValue; // *2 b/c the stroke is drawn centred on the middle\n        if (lineWidth > 0) {\n            context.lineWidth = lineWidth;\n        }\n        if (ele.pstyle(\"text-wrap\").value === \"wrap\") {\n            var lines = getPrefixedProperty(rscratch, \"labelWrapCachedLines\", prefix);\n            var lineHeight = getPrefixedProperty(rscratch, \"labelLineHeight\", prefix);\n            var halfTextW = textW / 2;\n            var justification = this.getLabelJustification(ele);\n            if (justification === \"auto\") ;\n            else if (halign === \"left\") {\n                // auto justification : right\n                if (justification === \"left\") {\n                    textX += -textW;\n                } else if (justification === \"center\") {\n                    textX += -halfTextW;\n                } // else same as auto\n            } else if (halign === \"center\") {\n                // auto justfication : center\n                if (justification === \"left\") {\n                    textX += -halfTextW;\n                } else if (justification === \"right\") {\n                    textX += halfTextW;\n                } // else same as auto\n            } else if (halign === \"right\") {\n                // auto justification : left\n                if (justification === \"center\") {\n                    textX += halfTextW;\n                } else if (justification === \"right\") {\n                    textX += textW;\n                } // else same as auto\n            }\n            switch(valign){\n                case \"top\":\n                    textY -= (lines.length - 1) * lineHeight;\n                    break;\n                case \"center\":\n                case \"bottom\":\n                    textY -= (lines.length - 1) * lineHeight;\n                    break;\n            }\n            for(var l = 0; l < lines.length; l++){\n                if (lineWidth > 0) {\n                    context.strokeText(lines[l], textX, textY);\n                }\n                context.fillText(lines[l], textX, textY);\n                textY += lineHeight;\n            }\n        } else {\n            if (lineWidth > 0) {\n                context.strokeText(text, textX, textY);\n            }\n            context.fillText(text, textX, textY);\n        }\n        if (theta !== 0) {\n            context.rotate(-theta);\n            context.translate(-orgTextX, -orgTextY);\n        }\n    }\n};\n/* global Path2D */ var CRp$6 = {};\nCRp$6.drawNode = function(context, node, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var _p = node._private;\n    var rs = _p.rscratch;\n    var pos = node.position();\n    if (!number$1(pos.x) || !number$1(pos.y)) {\n        return; // can't draw node with undefined position\n    }\n    if (shouldDrawOpacity && !node.visible()) {\n        return;\n    }\n    var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n    var usePaths = r.usePaths();\n    var path;\n    var pathCacheHit = false;\n    var padding = node.padding();\n    nodeWidth = node.width() + 2 * padding;\n    nodeHeight = node.height() + 2 * padding;\n    //\n    // setup shift\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    //\n    // load bg image\n    var bgImgProp = node.pstyle(\"background-image\");\n    var urls = bgImgProp.value;\n    var urlDefined = new Array(urls.length);\n    var image = new Array(urls.length);\n    var numImages = 0;\n    for(var i = 0; i < urls.length; i++){\n        var url = urls[i];\n        var defd = urlDefined[i] = url != null && url !== \"none\";\n        if (defd) {\n            var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, \"background-image-crossorigin\", \"value\", i);\n            numImages++;\n            // get image, and if not loaded then ask to redraw when later loaded\n            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function() {\n                _p.backgroundTimestamp = Date.now();\n                node.emitAndNotify(\"background\");\n            });\n        }\n    }\n    //\n    // setup styles\n    var darkness = node.pstyle(\"background-blacken\").value;\n    var borderWidth = node.pstyle(\"border-width\").pfValue;\n    var bgOpacity = node.pstyle(\"background-opacity\").value * eleOpacity;\n    var borderColor = node.pstyle(\"border-color\").value;\n    var borderStyle = node.pstyle(\"border-style\").value;\n    var borderJoin = node.pstyle(\"border-join\").value;\n    var borderCap = node.pstyle(\"border-cap\").value;\n    var borderPosition = node.pstyle(\"border-position\").value;\n    var borderPattern = node.pstyle(\"border-dash-pattern\").pfValue;\n    var borderOffset = node.pstyle(\"border-dash-offset\").pfValue;\n    var borderOpacity = node.pstyle(\"border-opacity\").value * eleOpacity;\n    var outlineWidth = node.pstyle(\"outline-width\").pfValue;\n    var outlineColor = node.pstyle(\"outline-color\").value;\n    var outlineStyle = node.pstyle(\"outline-style\").value;\n    var outlineOpacity = node.pstyle(\"outline-opacity\").value * eleOpacity;\n    var outlineOffset = node.pstyle(\"outline-offset\").value;\n    var cornerRadius = node.pstyle(\"corner-radius\").value;\n    if (cornerRadius !== \"auto\") cornerRadius = node.pstyle(\"corner-radius\").pfValue;\n    var setupShapeColor = function setupShapeColor() {\n        var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n        r.eleFillStyle(context, node, bgOpy);\n    };\n    var setupBorderColor = function setupBorderColor() {\n        var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n        r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n    };\n    var setupOutlineColor = function setupOutlineColor() {\n        var otlnOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : outlineOpacity;\n        r.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], otlnOpy);\n    };\n    //\n    // setup shape\n    var getPath = function getPath(width, height, shape, points) {\n        var pathCache = r.nodePathCache = r.nodePathCache || [];\n        var key = hashStrings(shape === \"polygon\" ? shape + \",\" + points.join(\",\") : shape, \"\" + height, \"\" + width, \"\" + cornerRadius);\n        var cachedPath = pathCache[key];\n        var path;\n        var cacheHit = false;\n        if (cachedPath != null) {\n            path = cachedPath;\n            cacheHit = true;\n            rs.pathCache = path;\n        } else {\n            path = new Path2D();\n            pathCache[key] = rs.pathCache = path;\n        }\n        return {\n            path: path,\n            cacheHit: cacheHit\n        };\n    };\n    var styleShape = node.pstyle(\"shape\").strValue;\n    var shapePts = node.pstyle(\"shape-polygon-points\").pfValue;\n    if (usePaths) {\n        context.translate(pos.x, pos.y);\n        var shapePath = getPath(nodeWidth, nodeHeight, styleShape, shapePts);\n        path = shapePath.path;\n        pathCacheHit = shapePath.cacheHit;\n    }\n    var drawShape = function drawShape() {\n        if (!pathCacheHit) {\n            var npos = pos;\n            if (usePaths) {\n                npos = {\n                    x: 0,\n                    y: 0\n                };\n            }\n            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n        }\n        if (usePaths) {\n            context.fill(path);\n        } else {\n            context.fill();\n        }\n    };\n    var drawImages = function drawImages() {\n        var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n        var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var prevBging = _p.backgrounding;\n        var totalCompleted = 0;\n        for(var _i = 0; _i < image.length; _i++){\n            var bgContainment = node.cy().style().getIndexedStyle(node, \"background-image-containment\", \"value\", _i);\n            if (inside && bgContainment === \"over\" || !inside && bgContainment === \"inside\") {\n                totalCompleted++;\n                continue;\n            }\n            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n                totalCompleted++;\n                r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n            }\n        }\n        _p.backgrounding = !(totalCompleted === numImages);\n        if (prevBging !== _p.backgrounding) {\n            // update style b/c :backgrounding state changed\n            node.updateStyle(false);\n        }\n    };\n    var drawPie = function drawPie() {\n        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n        if (r.hasPie(node)) {\n            r.drawPie(context, node, pieOpacity);\n            // redraw/restore path if steps after pie need it\n            if (redrawShape) {\n                if (!usePaths) {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                }\n            }\n        }\n    };\n    var drawStripe = function drawStripe() {\n        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var stripeOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n        if (r.hasStripe(node)) {\n            context.save();\n            if (usePaths) {\n                context.clip(rs.pathCache);\n            } else {\n                r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                context.clip();\n            }\n            r.drawStripe(context, node, stripeOpacity);\n            context.restore();\n            // redraw/restore path if steps after stripes need it\n            if (redrawShape) {\n                if (!usePaths) {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                }\n            }\n        }\n    };\n    var darken = function darken() {\n        var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n        var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n        var c = darkness > 0 ? 0 : 255;\n        if (darkness !== 0) {\n            r.colorFillStyle(context, c, c, c, opacity);\n            if (usePaths) {\n                context.fill(path);\n            } else {\n                context.fill();\n            }\n        }\n    };\n    var drawBorder = function drawBorder() {\n        if (borderWidth > 0) {\n            context.lineWidth = borderWidth;\n            context.lineCap = borderCap;\n            context.lineJoin = borderJoin;\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                switch(borderStyle){\n                    case \"dotted\":\n                        context.setLineDash([\n                            1,\n                            1\n                        ]);\n                        break;\n                    case \"dashed\":\n                        context.setLineDash(borderPattern);\n                        context.lineDashOffset = borderOffset;\n                        break;\n                    case \"solid\":\n                    case \"double\":\n                        context.setLineDash([]);\n                        break;\n                }\n            }\n            if (borderPosition !== \"center\") {\n                context.save();\n                context.lineWidth *= 2;\n                if (borderPosition === \"inside\") {\n                    usePaths ? context.clip(path) : context.clip();\n                } else {\n                    var region = new Path2D();\n                    region.rect(-nodeWidth / 2 - borderWidth, -nodeHeight / 2 - borderWidth, nodeWidth + 2 * borderWidth, nodeHeight + 2 * borderWidth);\n                    region.addPath(path);\n                    context.clip(region, \"evenodd\");\n                }\n                usePaths ? context.stroke(path) : context.stroke();\n                context.restore();\n            } else {\n                usePaths ? context.stroke(path) : context.stroke();\n            }\n            if (borderStyle === \"double\") {\n                context.lineWidth = borderWidth / 3;\n                var gco = context.globalCompositeOperation;\n                context.globalCompositeOperation = \"destination-out\";\n                if (usePaths) {\n                    context.stroke(path);\n                } else {\n                    context.stroke();\n                }\n                context.globalCompositeOperation = gco;\n            }\n            // reset in case we changed the border style\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                context.setLineDash([]);\n            }\n        }\n    };\n    var drawOutline = function drawOutline() {\n        if (outlineWidth > 0) {\n            context.lineWidth = outlineWidth;\n            context.lineCap = \"butt\";\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                switch(outlineStyle){\n                    case \"dotted\":\n                        context.setLineDash([\n                            1,\n                            1\n                        ]);\n                        break;\n                    case \"dashed\":\n                        context.setLineDash([\n                            4,\n                            2\n                        ]);\n                        break;\n                    case \"solid\":\n                    case \"double\":\n                        context.setLineDash([]);\n                        break;\n                }\n            }\n            var npos = pos;\n            if (usePaths) {\n                npos = {\n                    x: 0,\n                    y: 0\n                };\n            }\n            var shape = r.getNodeShape(node);\n            var bWidth = borderWidth;\n            if (borderPosition === \"inside\") bWidth = 0;\n            if (borderPosition === \"outside\") bWidth *= 2;\n            var scaleX = (nodeWidth + bWidth + (outlineWidth + outlineOffset)) / nodeWidth;\n            var scaleY = (nodeHeight + bWidth + (outlineWidth + outlineOffset)) / nodeHeight;\n            var sWidth = nodeWidth * scaleX;\n            var sHeight = nodeHeight * scaleY;\n            var points = r.nodeShapes[shape].points;\n            var _path;\n            if (usePaths) {\n                var outlinePath = getPath(sWidth, sHeight, shape, points);\n                _path = outlinePath.path;\n            }\n            // draw the outline path, either by using expanded points or by scaling \n            // the dimensions, depending on shape\n            if (shape === \"ellipse\") {\n                r.drawEllipsePath(_path || context, npos.x, npos.y, sWidth, sHeight);\n            } else if ([\n                \"round-diamond\",\n                \"round-heptagon\",\n                \"round-hexagon\",\n                \"round-octagon\",\n                \"round-pentagon\",\n                \"round-polygon\",\n                \"round-triangle\",\n                \"round-tag\"\n            ].includes(shape)) {\n                var sMult = 0;\n                var offsetX = 0;\n                var offsetY = 0;\n                if (shape === \"round-diamond\") {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.4;\n                } else if (shape === \"round-heptagon\") {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.075;\n                    offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 35;\n                } else if (shape === \"round-hexagon\") {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n                } else if (shape === \"round-pentagon\") {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.13;\n                    offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 15;\n                } else if (shape === \"round-tag\") {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n                    offsetX = (bWidth / 2 + outlineWidth + outlineOffset) * .07;\n                } else if (shape === \"round-triangle\") {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * (Math.PI / 2);\n                    offsetY = -(bWidth + outlineOffset / 2 + outlineWidth) / Math.PI;\n                }\n                if (sMult !== 0) {\n                    scaleX = (nodeWidth + sMult) / nodeWidth;\n                    sWidth = nodeWidth * scaleX;\n                    if (![\n                        \"round-hexagon\",\n                        \"round-tag\"\n                    ].includes(shape)) {\n                        scaleY = (nodeHeight + sMult) / nodeHeight;\n                        sHeight = nodeHeight * scaleY;\n                    }\n                }\n                cornerRadius = cornerRadius === \"auto\" ? getRoundPolygonRadius(sWidth, sHeight) : cornerRadius;\n                var halfW = sWidth / 2;\n                var halfH = sHeight / 2;\n                var radius = cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2;\n                var p = new Array(points.length / 2);\n                var corners = new Array(points.length / 2);\n                for(var _i2 = 0; _i2 < points.length / 2; _i2++){\n                    p[_i2] = {\n                        x: npos.x + offsetX + halfW * points[_i2 * 2],\n                        y: npos.y + offsetY + halfH * points[_i2 * 2 + 1]\n                    };\n                }\n                var _i3, p1, p2, p3, len = p.length;\n                p1 = p[len - 1];\n                // for each point\n                for(_i3 = 0; _i3 < len; _i3++){\n                    p2 = p[_i3 % len];\n                    p3 = p[(_i3 + 1) % len];\n                    corners[_i3] = getRoundCorner(p1, p2, p3, radius);\n                    p1 = p2;\n                    p2 = p3;\n                }\n                r.drawRoundPolygonPath(_path || context, npos.x + offsetX, npos.y + offsetY, nodeWidth * scaleX, nodeHeight * scaleY, points, corners);\n            } else if ([\n                \"roundrectangle\",\n                \"round-rectangle\"\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === \"auto\" ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n                r.drawRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n            } else if ([\n                \"cutrectangle\",\n                \"cut-rectangle\"\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === \"auto\" ? getCutRectangleCornerLength() : cornerRadius;\n                r.drawCutRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, null, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 4);\n            } else if ([\n                \"bottomroundrectangle\",\n                \"bottom-round-rectangle\"\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === \"auto\" ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n                r.drawBottomRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n            } else if (shape === \"barrel\") {\n                r.drawBarrelPath(_path || context, npos.x, npos.y, sWidth, sHeight);\n            } else if (shape.startsWith(\"polygon\") || [\n                \"rhomboid\",\n                \"right-rhomboid\",\n                \"round-tag\",\n                \"tag\",\n                \"vee\"\n            ].includes(shape)) {\n                var pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n                points = joinLines(expandPolygon(points, pad));\n                r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n            } else {\n                var _pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n                points = joinLines(expandPolygon(points, -_pad));\n                r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n            }\n            if (usePaths) {\n                context.stroke(_path);\n            } else {\n                context.stroke();\n            }\n            if (outlineStyle === \"double\") {\n                context.lineWidth = bWidth / 3;\n                var gco = context.globalCompositeOperation;\n                context.globalCompositeOperation = \"destination-out\";\n                if (usePaths) {\n                    context.stroke(_path);\n                } else {\n                    context.stroke();\n                }\n                context.globalCompositeOperation = gco;\n            }\n            // reset in case we changed the border style\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                context.setLineDash([]);\n            }\n        }\n    };\n    var drawOverlay = function drawOverlay() {\n        if (shouldDrawOverlay) {\n            r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n        }\n    };\n    var drawUnderlay = function drawUnderlay() {\n        if (shouldDrawOverlay) {\n            r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n        }\n    };\n    var drawText = function drawText() {\n        r.drawElementText(context, node, null, drawLabel);\n    };\n    var ghost = node.pstyle(\"ghost\").value === \"yes\";\n    if (ghost) {\n        var gx = node.pstyle(\"ghost-offset-x\").pfValue;\n        var gy = node.pstyle(\"ghost-offset-y\").pfValue;\n        var ghostOpacity = node.pstyle(\"ghost-opacity\").value;\n        var effGhostOpacity = ghostOpacity * eleOpacity;\n        context.translate(gx, gy);\n        setupOutlineColor();\n        drawOutline();\n        setupShapeColor(ghostOpacity * bgOpacity);\n        drawShape();\n        drawImages(effGhostOpacity, true);\n        setupBorderColor(ghostOpacity * borderOpacity);\n        drawBorder();\n        drawPie(darkness !== 0 || borderWidth !== 0);\n        drawStripe(darkness !== 0 || borderWidth !== 0);\n        drawImages(effGhostOpacity, false);\n        darken(effGhostOpacity);\n        context.translate(-gx, -gy);\n    }\n    if (usePaths) {\n        context.translate(-pos.x, -pos.y);\n    }\n    drawUnderlay();\n    if (usePaths) {\n        context.translate(pos.x, pos.y);\n    }\n    setupOutlineColor();\n    drawOutline();\n    setupShapeColor();\n    drawShape();\n    drawImages(eleOpacity, true);\n    setupBorderColor();\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawStripe(darkness !== 0 || borderWidth !== 0);\n    drawImages(eleOpacity, false);\n    darken();\n    if (usePaths) {\n        context.translate(-pos.x, -pos.y);\n    }\n    drawText();\n    drawOverlay();\n    //\n    // clean up shift\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nvar drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n    if (![\n        \"overlay\",\n        \"underlay\"\n    ].includes(overlayOrUnderlay)) {\n        throw new Error(\"Invalid state\");\n    }\n    return function(context, node, pos, nodeWidth, nodeHeight) {\n        var r = this;\n        if (!node.visible()) {\n            return;\n        }\n        var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n        var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n        var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n        var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n        var radius = node.pstyle(\"\".concat(overlayOrUnderlay, \"-corner-radius\")).value;\n        if (opacity > 0) {\n            pos = pos || node.position();\n            if (nodeWidth == null || nodeHeight == null) {\n                var _padding = node.padding();\n                nodeWidth = node.width() + 2 * _padding;\n                nodeHeight = node.height() + 2 * _padding;\n            }\n            r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n            r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2, radius);\n            context.fill();\n        }\n    };\n};\nCRp$6.drawNodeOverlay = drawNodeOverlayUnderlay(\"overlay\");\nCRp$6.drawNodeUnderlay = drawNodeOverlayUnderlay(\"underlay\");\n// does the node have at least one pie piece?\nCRp$6.hasPie = function(node) {\n    node = node[0]; // ensure ele ref\n    return node._private.hasPie;\n};\nCRp$6.hasStripe = function(node) {\n    node = node[0]; // ensure ele ref\n    return node._private.hasStripe;\n};\nCRp$6.drawPie = function(context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var pieSize = node.pstyle(\"pie-size\");\n    var hole = node.pstyle(\"pie-hole\");\n    var overallStartAngle = node.pstyle(\"pie-start-angle\").pfValue;\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n    var holeRadius;\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = this.usePaths();\n    if (usePaths) {\n        x = 0;\n        y = 0;\n    }\n    if (pieSize.units === \"%\") {\n        radius = radius * pieSize.pfValue;\n    } else if (pieSize.pfValue !== undefined) {\n        radius = pieSize.pfValue / 2; // diameter in pixels => radius\n    }\n    if (hole.units === \"%\") {\n        holeRadius = radius * hole.pfValue;\n    } else if (hole.pfValue !== undefined) {\n        holeRadius = hole.pfValue / 2; // diameter in pixels => radius\n    }\n    if (holeRadius >= radius) {\n        return; // the pie would be invisible anyway\n    }\n    for(var i = 1; i <= cyStyle.pieBackgroundN; i++){\n        // 1..N\n        var size = node.pstyle(\"pie-\" + i + \"-background-size\").value;\n        var color = node.pstyle(\"pie-\" + i + \"-background-color\").value;\n        var opacity = node.pstyle(\"pie-\" + i + \"-background-opacity\").value * nodeOpacity;\n        var percent = size / 100; // map integer range [0, 100] to [0, 1]\n        // percent can't push beyond 1\n        if (percent + lastPercent > 1) {\n            percent = 1 - lastPercent;\n        }\n        var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n        angleStart += overallStartAngle; // shift by the overall pie start angle\n        var angleDelta = 2 * Math.PI * percent;\n        var angleEnd = angleStart + angleDelta;\n        // ignore if\n        // - zero size\n        // - we're already beyond the full circle\n        // - adding the current slice would go beyond the full circle\n        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n            continue;\n        }\n        if (holeRadius === 0) {\n            // make a pie slice\n            context.beginPath();\n            context.moveTo(x, y);\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.closePath();\n        } else {\n            // make a pie slice that's like the above but with a hole in the middle\n            context.beginPath();\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.arc(x, y, holeRadius, angleEnd, angleStart, true); // true for anticlockwise\n            context.closePath();\n        }\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        context.fill();\n        lastPercent += percent;\n    }\n};\nCRp$6.drawStripe = function(context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = this.usePaths();\n    context.save();\n    var direction = node.pstyle(\"stripe-direction\").value;\n    var stripeSize = node.pstyle(\"stripe-size\");\n    switch(direction){\n        case \"vertical\":\n            break;\n        // default\n        case \"righward\":\n            context.rotate(-Math.PI / 2);\n            break;\n    }\n    var stripeW = nodeW;\n    var stripeH = nodeH;\n    if (stripeSize.units === \"%\") {\n        stripeW = stripeW * stripeSize.pfValue;\n        stripeH = stripeH * stripeSize.pfValue;\n    } else if (stripeSize.pfValue !== undefined) {\n        stripeW = stripeSize.pfValue;\n        stripeH = stripeSize.pfValue;\n    }\n    if (usePaths) {\n        x = 0;\n        y = 0;\n    }\n    // shift up from the centre of the node to the top-left corner\n    y -= stripeW / 2;\n    x -= stripeH / 2;\n    for(var i = 1; i <= cyStyle.stripeBackgroundN; i++){\n        // 1..N\n        var size = node.pstyle(\"stripe-\" + i + \"-background-size\").value;\n        var color = node.pstyle(\"stripe-\" + i + \"-background-color\").value;\n        var opacity = node.pstyle(\"stripe-\" + i + \"-background-opacity\").value * nodeOpacity;\n        var percent = size / 100; // map integer range [0, 100] to [0, 1]\n        // percent can't push beyond 1\n        if (percent + lastPercent > 1) {\n            percent = 1 - lastPercent;\n        }\n        // ignore if\n        // - zero size\n        // - we're already beyond the full chart\n        // - adding the current slice would go beyond the full chart\n        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n            continue;\n        }\n        // draw rect for the current stripe\n        context.beginPath();\n        context.rect(x, y + stripeH * lastPercent, stripeW, stripeH * percent);\n        context.closePath();\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        context.fill();\n        lastPercent += percent;\n    }\n    context.restore();\n};\nvar CRp$5 = {};\nvar motionBlurDelay = 100;\n// var isFirefox = typeof InstallTrigger !== 'undefined';\nCRp$5.getPixelRatio = function() {\n    var context = this.data.contexts[0];\n    if (this.forcedPixelRatio != null) {\n        return this.forcedPixelRatio;\n    }\n    var containerWindow = this.cy.window();\n    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    return (containerWindow.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n};\nCRp$5.paintCache = function(context) {\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n    for(var i = 0; i < caches.length; i++){\n        cache = caches[i];\n        if (cache.context === context) {\n            needToCreateCache = false;\n            break;\n        }\n    }\n    if (needToCreateCache) {\n        cache = {\n            context: context\n        };\n        caches.push(cache);\n    }\n    return cache;\n};\nCRp$5.createGradientStyleFor = function(context, shapeStyleName, ele, fill, opacity) {\n    var gradientStyle;\n    var usePaths = this.usePaths();\n    var colors = ele.pstyle(shapeStyleName + \"-gradient-stop-colors\").value, positions = ele.pstyle(shapeStyleName + \"-gradient-stop-positions\").pfValue;\n    if (fill === \"radial-gradient\") {\n        if (ele.isEdge()) {\n            var start = ele.sourceEndpoint(), end = ele.targetEndpoint(), mid = ele.midpoint();\n            var d1 = dist(start, mid);\n            var d2 = dist(end, mid);\n            gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n        } else {\n            var pos = usePaths ? {\n                x: 0,\n                y: 0\n            } : ele.position(), width = ele.paddedWidth(), height = ele.paddedHeight();\n            gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n        }\n    } else {\n        if (ele.isEdge()) {\n            var _start = ele.sourceEndpoint(), _end = ele.targetEndpoint();\n            gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n        } else {\n            var _pos = usePaths ? {\n                x: 0,\n                y: 0\n            } : ele.position(), _width = ele.paddedWidth(), _height = ele.paddedHeight(), halfWidth = _width / 2, halfHeight = _height / 2;\n            var direction = ele.pstyle(\"background-gradient-direction\").value;\n            switch(direction){\n                case \"to-bottom\":\n                    gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n                    break;\n                case \"to-top\":\n                    gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n                    break;\n                case \"to-left\":\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n                    break;\n                case \"to-right\":\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n                    break;\n                case \"to-bottom-right\":\n                case \"to-right-bottom\":\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n                    break;\n                case \"to-top-right\":\n                case \"to-right-top\":\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n                    break;\n                case \"to-bottom-left\":\n                case \"to-left-bottom\":\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n                    break;\n                case \"to-top-left\":\n                case \"to-left-top\":\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n                    break;\n            }\n        }\n    }\n    if (!gradientStyle) return null; // invalid gradient style\n    var hasPositions = positions.length === colors.length;\n    var length = colors.length;\n    for(var i = 0; i < length; i++){\n        gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), \"rgba(\" + colors[i][0] + \",\" + colors[i][1] + \",\" + colors[i][2] + \",\" + opacity + \")\");\n    }\n    return gradientStyle;\n};\nCRp$5.gradientFillStyle = function(context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, \"background\", ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n    context.fillStyle = gradientStyle;\n};\nCRp$5.colorFillStyle = function(context, r, g, b, a) {\n    context.fillStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n// turn off for now, seems context does its own caching\n// var cache = this.paintCache(context);\n// var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// if( cache.fillStyle !== fillStyle ){\n//   context.fillStyle = cache.fillStyle = fillStyle;\n// }\n};\nCRp$5.eleFillStyle = function(context, ele, opacity) {\n    var backgroundFill = ele.pstyle(\"background-fill\").value;\n    if (backgroundFill === \"linear-gradient\" || backgroundFill === \"radial-gradient\") {\n        this.gradientFillStyle(context, ele, backgroundFill, opacity);\n    } else {\n        var backgroundColor = ele.pstyle(\"background-color\").value;\n        this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n    }\n};\nCRp$5.gradientStrokeStyle = function(context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, \"line\", ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n    context.strokeStyle = gradientStyle;\n};\nCRp$5.colorStrokeStyle = function(context, r, g, b, a) {\n    context.strokeStyle = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n// turn off for now, seems context does its own caching\n// var cache = this.paintCache(context);\n// var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// if( cache.strokeStyle !== strokeStyle ){\n//   context.strokeStyle = cache.strokeStyle = strokeStyle;\n// }\n};\nCRp$5.eleStrokeStyle = function(context, ele, opacity) {\n    var lineFill = ele.pstyle(\"line-fill\").value;\n    if (lineFill === \"linear-gradient\" || lineFill === \"radial-gradient\") {\n        this.gradientStrokeStyle(context, ele, lineFill, opacity);\n    } else {\n        var lineColor = ele.pstyle(\"line-color\").value;\n        this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n    }\n};\n// Resize canvas\nCRp$5.matchCanvasSize = function(container) {\n    var r = this;\n    var data = r.data;\n    var bb = r.findContainerClientCoords();\n    var width = bb[2];\n    var height = bb[3];\n    var pixelRatio = r.getPixelRatio();\n    var mbPxRatio = r.motionBlurPxRatio;\n    if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n        pixelRatio = mbPxRatio;\n    }\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n    if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n        return; // save cycles if same\n    }\n    r.fontCaches = null; // resizing resets the style\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + \"px\";\n    canvasContainer.style.height = height + \"px\";\n    for(var i = 0; i < r.CANVAS_LAYERS; i++){\n        canvas = data.canvases[i];\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n    }\n    for(var i = 0; i < r.BUFFER_COUNT; i++){\n        canvas = data.bufferCanvases[i];\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n    }\n    r.textureMult = 1;\n    if (pixelRatio <= 1) {\n        canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n        r.textureMult = 2;\n        canvas.width = canvasWidth * r.textureMult;\n        canvas.height = canvasHeight * r.textureMult;\n    }\n    r.canvasWidth = canvasWidth;\n    r.canvasHeight = canvasHeight;\n    r.pixelRatio = pixelRatio;\n};\nCRp$5.renderTo = function(cxt, zoom, pan, pxRatio) {\n    this.render({\n        forcedContext: cxt,\n        forcedZoom: zoom,\n        forcedPan: pan,\n        drawAllLayers: true,\n        forcedPxRatio: pxRatio\n    });\n};\nCRp$5.clearCanvas = function() {\n    var r = this;\n    var data = r.data;\n    function clear(context) {\n        context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n    }\n    clear(data.contexts[r.NODE]);\n    clear(data.contexts[r.DRAG]);\n};\nCRp$5.render = function(options) {\n    var r = this;\n    options = options || staticEmptyObject();\n    var cy = r.cy;\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var data = r.data;\n    var needDraw = data.canvasNeedsRedraw;\n    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    var mbPxRatio = r.motionBlurPxRatio;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var inNodeDragGesture = r.hoverData.draggingEles;\n    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n    var motionBlurFadeEffect = motionBlur;\n    if (!forcedContext) {\n        if (r.prevPxRatio !== pixelRatio) {\n            r.invalidateContainerClientCoordsCache();\n            r.matchCanvasSize(r.container);\n            r.redrawHint(\"eles\", true);\n            r.redrawHint(\"drag\", true);\n        }\n        r.prevPxRatio = pixelRatio;\n    }\n    if (!forcedContext && r.motionBlurTimeout) {\n        clearTimeout(r.motionBlurTimeout);\n    }\n    if (motionBlur) {\n        if (r.mbFrames == null) {\n            r.mbFrames = 0;\n        }\n        r.mbFrames++;\n        if (r.mbFrames < 3) {\n            // need several frames before even high quality motionblur\n            motionBlurFadeEffect = false;\n        }\n        // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n        if (r.mbFrames > r.minMbLowQualFrames) {\n            //r.fullQualityMb = false;\n            r.motionBlurPxRatio = r.mbPxRBlurry;\n        }\n    }\n    if (r.clearingMotionBlur) {\n        r.motionBlurPxRatio = 1;\n    }\n    // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n    // because a rogue async texture frame would clear needDraw\n    if (r.textureDrawLastFrame && !textureDraw) {\n        needDraw[r.NODE] = true;\n        needDraw[r.SELECT_BOX] = true;\n    }\n    var style = cy.style();\n    var zoom = cy.zoom();\n    var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n    var pan = cy.pan();\n    var effectivePan = {\n        x: pan.x,\n        y: pan.y\n    };\n    var vp = {\n        zoom: zoom,\n        pan: {\n            x: pan.x,\n            y: pan.y\n        }\n    };\n    var prevVp = r.prevViewport;\n    var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n    // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n    if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n        r.motionBlurPxRatio = 1;\n    }\n    if (forcedPan) {\n        effectivePan = forcedPan;\n    }\n    // apply pixel ratio\n    effectiveZoom *= pixelRatio;\n    effectivePan.x *= pixelRatio;\n    effectivePan.y *= pixelRatio;\n    var eles = r.getCachedZSortedEles();\n    function mbclear(context, x, y, w, h) {\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = \"destination-out\";\n        r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n        context.fillRect(x, y, w, h);\n        context.globalCompositeOperation = gco;\n    }\n    function setContextTransform(context, clear) {\n        var ePan, eZoom, w, h;\n        if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n            ePan = {\n                x: pan.x * mbPxRatio,\n                y: pan.y * mbPxRatio\n            };\n            eZoom = zoom * mbPxRatio;\n            w = r.canvasWidth * mbPxRatio;\n            h = r.canvasHeight * mbPxRatio;\n        } else {\n            ePan = effectivePan;\n            eZoom = effectiveZoom;\n            w = r.canvasWidth;\n            h = r.canvasHeight;\n        }\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        if (clear === \"motionBlur\") {\n            mbclear(context, 0, 0, w, h);\n        } else if (!forcedContext && (clear === undefined || clear)) {\n            context.clearRect(0, 0, w, h);\n        }\n        if (!drawAllLayers) {\n            context.translate(ePan.x, ePan.y);\n            context.scale(eZoom, eZoom);\n        }\n        if (forcedPan) {\n            context.translate(forcedPan.x, forcedPan.y);\n        }\n        if (forcedZoom) {\n            context.scale(forcedZoom, forcedZoom);\n        }\n    }\n    if (!textureDraw) {\n        r.textureDrawLastFrame = false;\n    }\n    if (textureDraw) {\n        r.textureDrawLastFrame = true;\n        if (!r.textureCache) {\n            r.textureCache = {};\n            r.textureCache.bb = cy.mutableElements().boundingBox();\n            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n            var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n            cxt.setTransform(1, 0, 0, 1, 0, 0);\n            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n            r.render({\n                forcedContext: cxt,\n                drawOnlyNodeLayer: true,\n                forcedPxRatio: pixelRatio * r.textureMult\n            });\n            var vp = r.textureCache.viewport = {\n                zoom: cy.zoom(),\n                pan: cy.pan(),\n                width: r.canvasWidth,\n                height: r.canvasHeight\n            };\n            vp.mpan = {\n                x: (0 - vp.pan.x) / vp.zoom,\n                y: (0 - vp.pan.y) / vp.zoom\n            };\n        }\n        needDraw[r.DRAG] = false;\n        needDraw[r.NODE] = false;\n        var context = data.contexts[r.NODE];\n        var texture = r.textureCache.texture;\n        var vp = r.textureCache.viewport;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        if (motionBlur) {\n            mbclear(context, 0, 0, vp.width, vp.height);\n        } else {\n            context.clearRect(0, 0, vp.width, vp.height);\n        }\n        var outsideBgColor = style.core(\"outside-texture-bg-color\").value;\n        var outsideBgOpacity = style.core(\"outside-texture-bg-opacity\").value;\n        r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n        context.fillRect(0, 0, vp.width, vp.height);\n        var zoom = cy.zoom();\n        setContextTransform(context, false);\n        context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n        context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    } else if (r.textureOnViewport && !forcedContext) {\n        // clear the cache since we don't need it\n        r.textureCache = null;\n    }\n    var extent = cy.extent();\n    var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n    var hideEdges = r.hideEdgesOnViewport && vpManip;\n    var needMbClear = [];\n    needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n    if (needMbClear[r.NODE]) {\n        r.clearedForMotionBlur[r.NODE] = true;\n    }\n    needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n    if (needMbClear[r.DRAG]) {\n        r.clearedForMotionBlur[r.DRAG] = true;\n    }\n    if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n        var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n        var clear = motionBlur && !useBuffer ? \"motionBlur\" : undefined;\n        setContextTransform(context, clear);\n        if (hideEdges) {\n            r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n        } else {\n            r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n        }\n        if (r.debug) {\n            r.drawDebugPoints(context, eles.nondrag);\n        }\n        if (!drawAllLayers && !motionBlur) {\n            needDraw[r.NODE] = false;\n        }\n    }\n    if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n        var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n        setContextTransform(context, motionBlur && !useBuffer ? \"motionBlur\" : undefined);\n        if (hideEdges) {\n            r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n        } else {\n            r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n        }\n        if (r.debug) {\n            r.drawDebugPoints(context, eles.drag);\n        }\n        if (!drawAllLayers && !motionBlur) {\n            needDraw[r.DRAG] = false;\n        }\n    }\n    this.drawSelectionRectangle(options, setContextTransform);\n    // motionblur: blit rendered blurry frames\n    if (motionBlur && mbPxRatio !== 1) {\n        var cxtNode = data.contexts[r.NODE];\n        var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n        var cxtDrag = data.contexts[r.DRAG];\n        var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n        var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n            cxt.setTransform(1, 0, 0, 1, 0, 0);\n            if (needClear || !motionBlurFadeEffect) {\n                cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n            } else {\n                mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n            }\n            var pxr = mbPxRatio;\n            cxt.drawImage(txt, // img\n            0, 0, // sx, sy\n            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n            0, 0, // x, y\n            r.canvasWidth, r.canvasHeight // w, h\n            );\n        };\n        if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n            needDraw[r.NODE] = false;\n        }\n        if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n            needDraw[r.DRAG] = false;\n        }\n    }\n    r.prevViewport = vp;\n    if (r.clearingMotionBlur) {\n        r.clearingMotionBlur = false;\n        r.motionBlurCleared = true;\n        r.motionBlur = true;\n    }\n    if (motionBlur) {\n        r.motionBlurTimeout = setTimeout(function() {\n            r.motionBlurTimeout = null;\n            r.clearedForMotionBlur[r.NODE] = false;\n            r.clearedForMotionBlur[r.DRAG] = false;\n            r.motionBlur = false;\n            r.clearingMotionBlur = !textureDraw;\n            r.mbFrames = 0;\n            needDraw[r.NODE] = true;\n            needDraw[r.DRAG] = true;\n            r.redraw();\n        }, motionBlurDelay);\n    }\n    if (!forcedContext) {\n        cy.emit(\"render\");\n    }\n};\nvar fpsHeight;\nCRp$5.drawSelectionRectangle = function(options, setContextTransform) {\n    var r = this;\n    var cy = r.cy;\n    var data = r.data;\n    var style = cy.style();\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var drawAllLayers = options.drawAllLayers;\n    var needDraw = data.canvasNeedsRedraw;\n    var forcedContext = options.forcedContext;\n    if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n        var context = forcedContext || data.contexts[r.SELECT_BOX];\n        setContextTransform(context);\n        if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n            var zoom = r.cy.zoom();\n            var borderWidth = style.core(\"selection-box-border-width\").value / zoom;\n            context.lineWidth = borderWidth;\n            context.fillStyle = \"rgba(\" + style.core(\"selection-box-color\").value[0] + \",\" + style.core(\"selection-box-color\").value[1] + \",\" + style.core(\"selection-box-color\").value[2] + \",\" + style.core(\"selection-box-opacity\").value + \")\";\n            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n            if (borderWidth > 0) {\n                context.strokeStyle = \"rgba(\" + style.core(\"selection-box-border-color\").value[0] + \",\" + style.core(\"selection-box-border-color\").value[1] + \",\" + style.core(\"selection-box-border-color\").value[2] + \",\" + style.core(\"selection-box-opacity\").value + \")\";\n                context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n            }\n        }\n        if (data.bgActivePosistion && !r.hoverData.selecting) {\n            var zoom = r.cy.zoom();\n            var pos = data.bgActivePosistion;\n            context.fillStyle = \"rgba(\" + style.core(\"active-bg-color\").value[0] + \",\" + style.core(\"active-bg-color\").value[1] + \",\" + style.core(\"active-bg-color\").value[2] + \",\" + style.core(\"active-bg-opacity\").value + \")\";\n            context.beginPath();\n            context.arc(pos.x, pos.y, style.core(\"active-bg-size\").pfValue / zoom, 0, 2 * Math.PI);\n            context.fill();\n        }\n        var timeToRender = r.lastRedrawTime;\n        if (r.showFps && timeToRender) {\n            timeToRender = Math.round(timeToRender);\n            var fps = Math.round(1000 / timeToRender);\n            var text = \"1 frame = \" + timeToRender + \" ms = \" + fps + \" fps\";\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            context.fillStyle = \"rgba(255, 0, 0, 0.75)\";\n            context.strokeStyle = \"rgba(255, 0, 0, 0.75)\";\n            // context.lineWidth = 1;\n            context.font = \"30px Arial\";\n            if (!fpsHeight) {\n                var dims = context.measureText(text);\n                fpsHeight = dims.actualBoundingBoxAscent;\n            }\n            context.fillText(text, 0, fpsHeight);\n            var maxFps = 60;\n            context.strokeRect(0, fpsHeight + 10, 250, 20);\n            context.fillRect(0, fpsHeight + 10, 250 * Math.min(fps / maxFps, 1), 20);\n        }\n        if (!drawAllLayers) {\n            needDraw[r.SELECT_BOX] = false;\n        }\n    }\n};\n/**\n * Notes:\n * - All colors have premultiplied alpha. Very important for textues and \n *   blending to work correctly.\n */ function compileShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(gl.getShaderInfoLog(shader));\n    }\n    // console.log(gl.getShaderInfoLog(shader));\n    return shader;\n}\nfunction createProgram(gl, vertexSource, fragementSource) {\n    var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);\n    var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragementSource);\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(\"Could not initialize shaders\");\n    }\n    return program;\n}\n/**\n * Creates an offscren canvas with a 2D context, for the\n * canvas renderer to use for drawing textures.\n */ function createTextureCanvas(r, width, height) {\n    if (height === undefined) {\n        height = width;\n    }\n    var canvas = r.makeOffscreenCanvas(width, height);\n    var ctx = canvas.context = canvas.getContext(\"2d\");\n    canvas.clear = function() {\n        return ctx.clearRect(0, 0, canvas.width, canvas.height);\n    };\n    canvas.clear();\n    return canvas;\n}\n/**\n * Returns the current pan & zoom values, scaled by the pixel ratio.\n */ function getEffectivePanZoom(r) {\n    var pixelRatio = r.pixelRatio;\n    var zoom = r.cy.zoom();\n    var pan = r.cy.pan();\n    return {\n        zoom: zoom * pixelRatio,\n        pan: {\n            x: pan.x * pixelRatio,\n            y: pan.y * pixelRatio\n        }\n    };\n}\n/**\n * Returns the zoom value, scaled by the pixel ratio.\n */ function getEffectiveZoom(r) {\n    var pixelRatio = r.pixelRatio;\n    var zoom = r.cy.zoom();\n    return zoom * pixelRatio;\n}\nfunction modelToRenderedPosition(r, pan, zoom, x, y) {\n    var rx = x * zoom + pan.x;\n    var ry = y * zoom + pan.y;\n    ry = Math.round(r.canvasHeight - ry); // adjust for webgl\n    return [\n        rx,\n        ry\n    ];\n}\nfunction isSimpleShape(node) {\n    // the actual shape is checked in ElementDrawingWebGL._getVertTypeForShape()\n    // no need to check it twice, this just checks other visual properties\n    if (node.pstyle(\"background-fill\").value !== \"solid\") return false;\n    if (node.pstyle(\"background-image\").strValue !== \"none\") return false;\n    if (node.pstyle(\"border-width\").value === 0) return true;\n    if (node.pstyle(\"border-opacity\").value === 0) return true;\n    // we have a border but it must be simple\n    if (node.pstyle(\"border-style\").value !== \"solid\") return false;\n    // TODO ignoring 'border-cap', 'border-join' and 'border-position' for now\n    return true;\n}\nfunction arrayEqual(a1, a2) {\n    if (a1.length !== a2.length) {\n        return false;\n    }\n    for(var i = 0; i < a1.length; i++){\n        if (a1[i] !== a2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Takes color & opacity style values and converts them to WebGL format. \n * Alpha is premultiplied.\n */ function toWebGLColor(color, opacity, outArray) {\n    var r = color[0] / 255;\n    var g = color[1] / 255;\n    var b = color[2] / 255;\n    var a = opacity;\n    var arr = outArray || new Array(4);\n    arr[0] = r * a;\n    arr[1] = g * a;\n    arr[2] = b * a;\n    arr[3] = a;\n    return arr;\n}\nfunction indexToVec4(index, outArray) {\n    var arr = outArray || new Array(4);\n    arr[0] = (index >> 0 & 0xFF) / 0xFF;\n    arr[1] = (index >> 8 & 0xFF) / 0xFF;\n    arr[2] = (index >> 16 & 0xFF) / 0xFF;\n    arr[3] = (index >> 24 & 0xFF) / 0xFF;\n    return arr;\n}\nfunction vec4ToIndex(vec4) {\n    return vec4[0] + (vec4[1] << 8) + (vec4[2] << 16) + (vec4[3] << 24);\n}\nfunction createTexture(gl, debugID) {\n    var texture = gl.createTexture();\n    texture.buffer = function(offscreenCanvas) {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        // very important, this tells webgl to premultiply colors by the alpha channel\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreenCanvas);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    };\n    texture.deleteTexture = function() {\n        gl.deleteTexture(texture);\n    };\n    return texture;\n}\nfunction getTypeInfo(gl, glslType) {\n    switch(glslType){\n        case \"float\":\n            return [\n                1,\n                gl.FLOAT,\n                4\n            ];\n        case \"vec2\":\n            return [\n                2,\n                gl.FLOAT,\n                4\n            ];\n        case \"vec3\":\n            return [\n                3,\n                gl.FLOAT,\n                4\n            ];\n        case \"vec4\":\n            return [\n                4,\n                gl.FLOAT,\n                4\n            ];\n        case \"int\":\n            return [\n                1,\n                gl.INT,\n                4\n            ];\n        case \"ivec2\":\n            return [\n                2,\n                gl.INT,\n                4\n            ];\n    }\n}\nfunction createTypedArray(gl, glType, dataOrSize) {\n    switch(glType){\n        case gl.FLOAT:\n            return new Float32Array(dataOrSize);\n        case gl.INT:\n            return new Int32Array(dataOrSize);\n    }\n}\nfunction createTypedArrayView(gl, glType, array, stride, size, i) {\n    switch(glType){\n        case gl.FLOAT:\n            return new Float32Array(array.buffer, i * stride, size);\n        case gl.INT:\n            return new Int32Array(array.buffer, i * stride, size);\n    }\n}\n/** @param {WebGLRenderingContext} gl */ function createBufferStaticDraw(gl, type, attributeLoc, dataArray) {\n    var _getTypeInfo = getTypeInfo(gl, type), _getTypeInfo2 = _slicedToArray(_getTypeInfo, 2), size = _getTypeInfo2[0], glType = _getTypeInfo2[1];\n    var data = createTypedArray(gl, glType, dataArray);\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n    if (glType === gl.FLOAT) {\n        gl.vertexAttribPointer(attributeLoc, size, glType, false, 0, 0);\n    } else if (glType === gl.INT) {\n        gl.vertexAttribIPointer(attributeLoc, size, glType, 0, 0);\n    }\n    gl.enableVertexAttribArray(attributeLoc);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    return buffer;\n}\n/** \n * Creates a float buffer with gl.DYNAMIC_DRAW.\n * The returned buffer object contains functions to easily set instance data and buffer the data before a draw call.\n * @param {WebGLRenderingContext} gl \n */ function createBufferDynamicDraw(gl, instances, type, attributeLoc) {\n    var _getTypeInfo3 = getTypeInfo(gl, type), _getTypeInfo4 = _slicedToArray(_getTypeInfo3, 3), size = _getTypeInfo4[0], glType = _getTypeInfo4[1], bytes = _getTypeInfo4[2];\n    var dataArray = createTypedArray(gl, glType, instances * size);\n    var stride = size * bytes;\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, instances * stride, gl.DYNAMIC_DRAW);\n    gl.enableVertexAttribArray(attributeLoc);\n    if (glType === gl.FLOAT) {\n        gl.vertexAttribPointer(attributeLoc, size, glType, false, stride, 0);\n    } else if (glType === gl.INT) {\n        gl.vertexAttribIPointer(attributeLoc, size, glType, stride, 0);\n    }\n    gl.vertexAttribDivisor(attributeLoc, 1);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    // use array views to set values directly into the buffer array\n    var views = new Array(instances);\n    for(var i = 0; i < instances; i++){\n        views[i] = createTypedArrayView(gl, glType, dataArray, stride, size, i);\n    }\n    buffer.dataArray = dataArray;\n    buffer.stride = stride;\n    buffer.size = size;\n    buffer.getView = function(i) {\n        return views[i];\n    };\n    buffer.setPoint = function(i, x, y) {\n        var view = views[i];\n        view[0] = x;\n        view[1] = y;\n    };\n    buffer.bufferSubData = function(count) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        if (count) {\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray, 0, count * size);\n        } else {\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray);\n        }\n    };\n    return buffer;\n}\n/** \n * Creates a buffer of 3x3 matrix data for use as attribute data.\n * @param {WebGLRenderingContext} gl \n */ function create3x3MatrixBufferDynamicDraw(gl, instances, attributeLoc) {\n    var matrixSize = 9; // 3x3 matrix\n    var matrixData = new Float32Array(instances * matrixSize);\n    // use matrix views to set values directly into the matrixData array\n    var matrixViews = new Array(instances);\n    for(var i = 0; i < instances; i++){\n        var byteOffset = i * matrixSize * 4; // 4 bytes per float\n        matrixViews[i] = new Float32Array(matrixData.buffer, byteOffset, matrixSize); // array view\n    }\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);\n    // each row of the matrix needs to be a separate attribute\n    for(var _i = 0; _i < 3; _i++){\n        var loc = attributeLoc + _i;\n        gl.enableVertexAttribArray(loc);\n        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 3 * 12, _i * 12);\n        gl.vertexAttribDivisor(loc, 1);\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    buffer.getMatrixView = function(i) {\n        return matrixViews[i];\n    };\n    // TODO this is too slow, use getMatrixView and pass the view directly to the glmatrix library\n    buffer.setData = function(matrix, i) {\n        matrixViews[i].set(matrix, 0);\n    };\n    buffer.bufferSubData = function() {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);\n    };\n    return buffer;\n}\n/** \n * Creates a Frame Buffer to use for offscreen rendering.\n * @param {WebGLRenderingContext} gl \n */ function createPickingFrameBuffer(gl) {\n    // Create and bind the framebuffer\n    var fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    // Create a texture to render to\n    var targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    // attach the texture as the first color attachment\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    fb.setFramebufferAttachmentSizes = function(width, height) {\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    };\n    return fb;\n}\n/**\n * Common utilities\n * @module glMatrix\n */ // Configuration Constants\nvar ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function() {\n    var y = 0, i = arguments.length;\n    while(i--){\n        y += arguments[i] * arguments[i];\n    }\n    return Math.sqrt(y);\n};\n/**\n * 3x3 Matrix\n * @module mat3\n */ /**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */ function create() {\n    var out = new ARRAY_TYPE(9);\n    if (ARRAY_TYPE != Float32Array) {\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[5] = 0;\n        out[6] = 0;\n        out[7] = 0;\n    }\n    out[0] = 1;\n    out[4] = 1;\n    out[8] = 1;\n    return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */ function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */ function multiply(out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2];\n    var a10 = a[3], a11 = a[4], a12 = a[5];\n    var a20 = a[6], a21 = a[7], a22 = a[8];\n    var b00 = b[0], b01 = b[1], b02 = b[2];\n    var b10 = b[3], b11 = b[4], b12 = b[5];\n    var b20 = b[6], b21 = b[7], b22 = b[8];\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */ function translate(out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */ function rotate(out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/ function scale(out, a, v) {\n    var x = v[0], y = v[1];\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */ function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n// A \"texture atlas\" is a big canvas, and sections of it are used as textures for nodes/labels.\n/**\n * A single square texture atlas (also known as a \"sprite sheet\").\n */ var Atlas = /*#__PURE__*/ function() {\n    function Atlas(r, texSize, texRows, createTextureCanvas) {\n        _classCallCheck(this, Atlas);\n        this.debugID = Math.floor(Math.random() * 10000);\n        this.r = r;\n        this.texSize = texSize;\n        this.texRows = texRows;\n        this.texHeight = Math.floor(texSize / texRows);\n        this.enableWrapping = true; // hardcoded for now, can be made an option\n        this.locked = false; // once an atlas is locked it can no longer be drawn to\n        this.texture = null; // WebGLTexture object\n        this.needsBuffer = true;\n        // a \"location\" is an pointer into the atlas with a 'row' and 'x' fields\n        this.freePointer = {\n            x: 0,\n            row: 0\n        };\n        // map from the style key to the row/x where the texture starts\n        // if the texture wraps then there's a second location\n        this.keyToLocation = new Map(); // styleKey -> [ location, location ]\n        this.canvas = createTextureCanvas(r, texSize, texSize);\n        this.scratch = createTextureCanvas(r, texSize, this.texHeight, \"scratch\");\n    }\n    return _createClass(Atlas, [\n        {\n            key: \"lock\",\n            value: function lock() {\n                this.locked = true;\n            }\n        },\n        {\n            key: \"getKeys\",\n            value: function getKeys() {\n                return new Set(this.keyToLocation.keys());\n            }\n        },\n        {\n            key: \"getScale\",\n            value: function getScale(_ref) {\n                var w = _ref.w, h = _ref.h;\n                var texHeight = this.texHeight, maxTexWidth = this.texSize;\n                // try to fit to the height of a row\n                var scale = texHeight / h; // TODO what about pixelRatio?\n                var texW = w * scale;\n                var texH = h * scale;\n                // if the scaled width is too wide then scale to fit max width instead\n                if (texW > maxTexWidth) {\n                    scale = maxTexWidth / w;\n                    texW = w * scale;\n                    texH = h * scale;\n                }\n                return {\n                    scale: scale,\n                    texW: texW,\n                    texH: texH\n                };\n            }\n        },\n        {\n            key: \"draw\",\n            value: function draw(key, bb, doDrawing) {\n                var _this = this;\n                if (this.locked) throw new Error(\"can't draw, atlas is locked\");\n                var texSize = this.texSize, texRows = this.texRows, texHeight = this.texHeight;\n                var _this$getScale = this.getScale(bb), scale = _this$getScale.scale, texW = _this$getScale.texW, texH = _this$getScale.texH;\n                var drawAt = function drawAt(location, canvas) {\n                    if (doDrawing && canvas) {\n                        var context = canvas.context;\n                        var x = location.x, row = location.row;\n                        var xOffset = x;\n                        var yOffset = texHeight * row;\n                        context.save();\n                        context.translate(xOffset, yOffset);\n                        context.scale(scale, scale);\n                        doDrawing(context, bb);\n                        context.restore();\n                    }\n                };\n                var locations = [\n                    null,\n                    null\n                ];\n                var drawNormal = function drawNormal() {\n                    // don't need to wrap, draw directly on the canvas\n                    drawAt(_this.freePointer, _this.canvas);\n                    locations[0] = {\n                        x: _this.freePointer.x,\n                        y: _this.freePointer.row * texHeight,\n                        w: texW,\n                        h: texH\n                    };\n                    locations[1] = {\n                        // create a second location with a width of 0, for convenience\n                        x: _this.freePointer.x + texW,\n                        y: _this.freePointer.row * texHeight,\n                        w: 0,\n                        h: texH\n                    };\n                    // move the pointer to the end of the texture\n                    _this.freePointer.x += texW;\n                    if (_this.freePointer.x == texSize) {\n                        _this.freePointer.x = 0;\n                        _this.freePointer.row++;\n                    }\n                };\n                var drawWrapped = function drawWrapped() {\n                    var scratch = _this.scratch, canvas = _this.canvas;\n                    // Draw to the scratch canvas\n                    scratch.clear();\n                    drawAt({\n                        x: 0,\n                        row: 0\n                    }, scratch);\n                    var firstTexW = texSize - _this.freePointer.x;\n                    var secondTexW = texW - firstTexW;\n                    var h = texHeight;\n                    {\n                        // copy first part of scratch to the first texture\n                        var dx = _this.freePointer.x;\n                        var dy = _this.freePointer.row * texHeight;\n                        var w = firstTexW;\n                        canvas.context.drawImage(scratch, 0, 0, w, h, dx, dy, w, h);\n                        locations[0] = {\n                            x: dx,\n                            y: dy,\n                            w: w,\n                            h: texH\n                        };\n                    }\n                    {\n                        // copy second part of scratch to the second texture\n                        var sx = firstTexW;\n                        var _dy = (_this.freePointer.row + 1) * texHeight;\n                        var _w = secondTexW;\n                        if (canvas) {\n                            canvas.context.drawImage(scratch, sx, 0, _w, h, 0, _dy, _w, h);\n                        }\n                        locations[1] = {\n                            x: 0,\n                            y: _dy,\n                            w: _w,\n                            h: texH\n                        };\n                    }\n                    _this.freePointer.x = secondTexW;\n                    _this.freePointer.row++;\n                };\n                var moveToStartOfNextRow = function moveToStartOfNextRow() {\n                    _this.freePointer.x = 0;\n                    _this.freePointer.row++;\n                };\n                if (this.freePointer.x + texW <= texSize) {\n                    // There's enough space in the current row\n                    drawNormal();\n                } else if (this.freePointer.row >= texRows - 1) {\n                    // Need to move to the next row, but there are no more rows, atlas is full.\n                    return false;\n                } else if (this.freePointer.x === texSize) {\n                    // happen to be right at end of current row\n                    moveToStartOfNextRow();\n                    drawNormal();\n                } else if (this.enableWrapping) {\n                    // draw part of the texture to the end of the curent row, then wrap to the next row\n                    drawWrapped();\n                } else {\n                    // move to the start of the next row, then draw normally\n                    moveToStartOfNextRow();\n                    drawNormal();\n                }\n                this.keyToLocation.set(key, locations);\n                this.needsBuffer = true;\n                return locations;\n            }\n        },\n        {\n            key: \"getOffsets\",\n            value: function getOffsets(key) {\n                return this.keyToLocation.get(key);\n            }\n        },\n        {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n                return this.freePointer.x === 0 && this.freePointer.row === 0;\n            }\n        },\n        {\n            key: \"canFit\",\n            value: function canFit(bb) {\n                if (this.locked) return false;\n                var texSize = this.texSize, texRows = this.texRows;\n                var _this$getScale2 = this.getScale(bb), texW = _this$getScale2.texW;\n                if (this.freePointer.x + texW > texSize) {\n                    // need to wrap\n                    return this.freePointer.row < texRows - 1; // return true if there's a row to wrap to\n                }\n                return true;\n            }\n        },\n        {\n            key: \"bufferIfNeeded\",\n            value: function bufferIfNeeded(gl) {\n                if (!this.texture) {\n                    this.texture = createTexture(gl, this.debugID);\n                }\n                if (this.needsBuffer) {\n                    this.texture.buffer(this.canvas);\n                    this.needsBuffer = false;\n                    if (this.locked) {\n                        this.canvas = null;\n                        this.scratch = null;\n                    }\n                }\n            }\n        },\n        {\n            key: \"dispose\",\n            value: function dispose() {\n                if (this.texture) {\n                    this.texture.deleteTexture();\n                    this.texture = null;\n                }\n                this.canvas = null;\n                this.scratch = null;\n                this.locked = true;\n            }\n        }\n    ]);\n}();\n/**\n * A collection of texture atlases, all of the same \"render type\". \n * ('node-body' is an example of a render type.)\n * An AtlasCollection can also be notified when a texture is no longer needed, \n * and it can garbage collect the unused textures.\n */ var AtlasCollection = /*#__PURE__*/ function() {\n    function AtlasCollection(r, texSize, texRows, createTextureCanvas) {\n        _classCallCheck(this, AtlasCollection);\n        this.r = r;\n        this.texSize = texSize;\n        this.texRows = texRows;\n        this.createTextureCanvas = createTextureCanvas;\n        this.atlases = [];\n        this.styleKeyToAtlas = new Map();\n        this.markedKeys = new Set(); // marked for garbage collection\n    }\n    return _createClass(AtlasCollection, [\n        {\n            key: \"getKeys\",\n            value: function getKeys() {\n                return new Set(this.styleKeyToAtlas.keys());\n            }\n        },\n        {\n            key: \"_createAtlas\",\n            value: function _createAtlas() {\n                var r = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas = this.createTextureCanvas;\n                return new Atlas(r, texSize, texRows, createTextureCanvas);\n            }\n        },\n        {\n            key: \"_getScratchCanvas\",\n            value: function _getScratchCanvas() {\n                if (!this.scratch) {\n                    var r = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas = this.createTextureCanvas;\n                    var texHeight = Math.floor(texSize / texRows);\n                    this.scratch = createTextureCanvas(r, texSize, texHeight, \"scratch\");\n                }\n                return this.scratch;\n            }\n        },\n        {\n            key: \"draw\",\n            value: function draw(key, bb, doDrawing) {\n                var atlas = this.styleKeyToAtlas.get(key);\n                if (!atlas) {\n                    // check for space at the end of the last atlas\n                    atlas = this.atlases[this.atlases.length - 1];\n                    if (!atlas || !atlas.canFit(bb)) {\n                        if (atlas) atlas.lock();\n                        // create a new atlas\n                        atlas = this._createAtlas();\n                        this.atlases.push(atlas);\n                    }\n                    atlas.draw(key, bb, doDrawing);\n                    this.styleKeyToAtlas.set(key, atlas);\n                }\n                return atlas;\n            }\n        },\n        {\n            key: \"getAtlas\",\n            value: function getAtlas(key) {\n                return this.styleKeyToAtlas.get(key);\n            }\n        },\n        {\n            key: \"hasAtlas\",\n            value: function hasAtlas(key) {\n                return this.styleKeyToAtlas.has(key);\n            }\n        },\n        {\n            key: \"markKeyForGC\",\n            value: function markKeyForGC(key) {\n                this.markedKeys.add(key);\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                var _this2 = this;\n                var markedKeys = this.markedKeys;\n                if (markedKeys.size === 0) {\n                    console.log(\"nothing to garbage collect\");\n                    return;\n                }\n                var newAtlases = [];\n                var newStyleKeyToAtlas = new Map();\n                var newAtlas = null;\n                var _iterator = _createForOfIteratorHelper(this.atlases), _step;\n                try {\n                    var _loop = function _loop() {\n                        var atlas = _step.value;\n                        var keys = atlas.getKeys();\n                        var keysToCollect = intersection(markedKeys, keys);\n                        if (keysToCollect.size === 0) {\n                            // this atlas can still be used\n                            newAtlases.push(atlas);\n                            keys.forEach(function(k) {\n                                return newStyleKeyToAtlas.set(k, atlas);\n                            });\n                            return 1; // continue\n                        }\n                        if (!newAtlas) {\n                            newAtlas = _this2._createAtlas();\n                            newAtlases.push(newAtlas);\n                        }\n                        var _iterator2 = _createForOfIteratorHelper(keys), _step2;\n                        try {\n                            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                                var key = _step2.value;\n                                if (!keysToCollect.has(key)) {\n                                    var _atlas$getOffsets = atlas.getOffsets(key), _atlas$getOffsets2 = _slicedToArray(_atlas$getOffsets, 2), s1 = _atlas$getOffsets2[0], s2 = _atlas$getOffsets2[1];\n                                    if (!newAtlas.canFit({\n                                        w: s1.w + s2.w,\n                                        h: s1.h\n                                    })) {\n                                        newAtlas.lock();\n                                        newAtlas = _this2._createAtlas();\n                                        newAtlases.push(newAtlas);\n                                    }\n                                    if (atlas.canvas) {\n                                        // if the texture can't be copied then it will have to be redrawn on the next frame\n                                        _this2._copyTextureToNewAtlas(key, atlas, newAtlas);\n                                        newStyleKeyToAtlas.set(key, newAtlas);\n                                    }\n                                }\n                            }\n                        } catch (err) {\n                            _iterator2.e(err);\n                        } finally{\n                            _iterator2.f();\n                        }\n                        atlas.dispose();\n                    };\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        if (_loop()) continue;\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                this.atlases = newAtlases;\n                this.styleKeyToAtlas = newStyleKeyToAtlas;\n                this.markedKeys = new Set();\n            }\n        },\n        {\n            key: \"_copyTextureToNewAtlas\",\n            value: function _copyTextureToNewAtlas(key, oldAtlas, newAtlas) {\n                var _oldAtlas$getOffsets = oldAtlas.getOffsets(key), _oldAtlas$getOffsets2 = _slicedToArray(_oldAtlas$getOffsets, 2), s1 = _oldAtlas$getOffsets2[0], s2 = _oldAtlas$getOffsets2[1];\n                if (s2.w === 0) {\n                    // the texture does not wrap, draw directly to new atlas\n                    newAtlas.draw(key, s1, function(context) {\n                        context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);\n                    });\n                } else {\n                    // the texture wraps, first draw both parts to a scratch canvas\n                    var scratch = this._getScratchCanvas();\n                    scratch.clear();\n                    scratch.context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);\n                    scratch.context.drawImage(oldAtlas.canvas, s2.x, s2.y, s2.w, s2.h, s1.w, 0, s2.w, s2.h);\n                    // now draw the scratch to the new atlas\n                    var w = s1.w + s2.w;\n                    var h = s1.h;\n                    newAtlas.draw(key, {\n                        w: w,\n                        h: h\n                    }, function(context) {\n                        context.drawImage(scratch, 0, 0, w, h, 0, 0, w, h // the destination context has already been translated to the correct position\n                        );\n                    });\n                }\n            }\n        },\n        {\n            key: \"getCounts\",\n            value: function getCounts() {\n                return {\n                    keyCount: this.styleKeyToAtlas.size,\n                    atlasCount: new Set(this.styleKeyToAtlas.values()).size\n                };\n            }\n        }\n    ]);\n}();\nfunction intersection(set1, set2) {\n    // TODO why no Set.intersection in node 16???\n    if (set1.intersection) return set1.intersection(set2);\n    else return new Set(_toConsumableArray(set1).filter(function(x) {\n        return set2.has(x);\n    }));\n}\n/**\n * Used to manage batches of Atlases for drawing nodes and labels.\n * Supports different types of AtlasCollections for different render types,\n * for example 'node-body' and 'node-label' would be different render types.\n * Render types are kept separate because they will likely need to be garbage collected\n * separately and its not entierly guaranteed that their style keys won't collide.\n */ var AtlasManager = /*#__PURE__*/ function() {\n    function AtlasManager(r, globalOptions) {\n        _classCallCheck(this, AtlasManager);\n        this.r = r;\n        this.globalOptions = globalOptions;\n        this.atlasSize = globalOptions.webglTexSize;\n        this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;\n        this.renderTypes = new Map(); // renderType:string -> renderTypeOptions\n        this.collections = new Map(); // collectionName:string -> AtlasCollection\n        this.typeAndIdToKey = new Map(); // [renderType,id] => Array<style key>\n    }\n    return _createClass(AtlasManager, [\n        {\n            key: \"getAtlasSize\",\n            value: function getAtlasSize() {\n                return this.atlasSize;\n            }\n        },\n        {\n            key: \"addAtlasCollection\",\n            value: function addAtlasCollection(collectionName, atlasCollectionOptions) {\n                var _this$globalOptions = this.globalOptions, webglTexSize = _this$globalOptions.webglTexSize, createTextureCanvas = _this$globalOptions.createTextureCanvas;\n                var texRows = atlasCollectionOptions.texRows;\n                var cachedCreateTextureCanvas = this._cacheScratchCanvas(createTextureCanvas);\n                var atlasCollection = new AtlasCollection(this.r, webglTexSize, texRows, cachedCreateTextureCanvas);\n                this.collections.set(collectionName, atlasCollection);\n            }\n        },\n        {\n            key: \"addRenderType\",\n            value: function addRenderType(type, renderTypeOptions) {\n                var collection = renderTypeOptions.collection;\n                if (!this.collections.has(collection)) throw new Error(\"invalid atlas collection name '\".concat(collection, \"'\"));\n                var atlasCollection = this.collections.get(collection);\n                var opts = extend({\n                    type: type,\n                    atlasCollection: atlasCollection\n                }, renderTypeOptions);\n                this.renderTypes.set(type, opts);\n            }\n        },\n        {\n            key: \"getRenderTypeOpts\",\n            value: function getRenderTypeOpts(type) {\n                return this.renderTypes.get(type);\n            }\n        },\n        {\n            key: \"getAtlasCollection\",\n            value: function getAtlasCollection(name) {\n                return this.collections.get(name);\n            }\n        },\n        {\n            key: \"_cacheScratchCanvas\",\n            value: function _cacheScratchCanvas(createTextureCanvas) {\n                // all scratch canvases for the same render type will have the same width and height (ie webglTexRows option)\n                // but we'll keep track of the width and height just to be safe\n                var prevW = -1;\n                var prevH = -1;\n                var scratchCanvas = null;\n                return function(r, w, h, scratch) {\n                    if (scratch) {\n                        if (!scratchCanvas || w != prevW || h != prevH) {\n                            prevW = w;\n                            prevH = h;\n                            scratchCanvas = createTextureCanvas(r, w, h);\n                        }\n                        return scratchCanvas;\n                    } else {\n                        return createTextureCanvas(r, w, h);\n                    }\n                };\n            }\n        },\n        {\n            key: \"_key\",\n            value: function _key(renderType, id) {\n                return \"\".concat(renderType, \"-\").concat(id); // TODO not very efficient\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(eles) {\n                var _this3 = this;\n                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref2$forceRedraw = _ref2.forceRedraw, forceRedraw = _ref2$forceRedraw === undefined ? false : _ref2$forceRedraw, _ref2$filterEle = _ref2.filterEle, filterEle = _ref2$filterEle === undefined ? function() {\n                    return true;\n                } : _ref2$filterEle, _ref2$filterType = _ref2.filterType, filterType = _ref2$filterType === undefined ? function() {\n                    return true;\n                } : _ref2$filterType;\n                var needGC = false;\n                var runGCNow = false;\n                var _iterator3 = _createForOfIteratorHelper(eles), _step3;\n                try {\n                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                        var ele = _step3.value;\n                        if (filterEle(ele)) {\n                            var _iterator4 = _createForOfIteratorHelper(this.renderTypes.values()), _step4;\n                            try {\n                                var _loop2 = function _loop2() {\n                                    var opts = _step4.value;\n                                    var renderType = opts.type;\n                                    if (filterType(renderType)) {\n                                        var atlasCollection = _this3.collections.get(opts.collection);\n                                        var key = opts.getKey(ele);\n                                        var keyArray = Array.isArray(key) ? key : [\n                                            key\n                                        ];\n                                        // when a node's background image finishes loading, the style key doesn't change but still needs to be redrawn\n                                        if (forceRedraw) {\n                                            keyArray.forEach(function(key) {\n                                                return atlasCollection.markKeyForGC(key);\n                                            });\n                                            runGCNow = true; // run GC to remove the old texture right now, that way we don't need to remember for the next gc \n                                        } else {\n                                            var id = opts.getID ? opts.getID(ele) : ele.id();\n                                            var mapKey = _this3._key(renderType, id);\n                                            var oldKeyArray = _this3.typeAndIdToKey.get(mapKey);\n                                            if (oldKeyArray !== undefined && !arrayEqual(keyArray, oldKeyArray)) {\n                                                // conservative approach, if any of the keys don't match then throw them all away\n                                                needGC = true;\n                                                _this3.typeAndIdToKey[\"delete\"](mapKey);\n                                                oldKeyArray.forEach(function(oldKey) {\n                                                    return atlasCollection.markKeyForGC(oldKey);\n                                                });\n                                            }\n                                        }\n                                    }\n                                };\n                                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                                    _loop2();\n                                }\n                            } catch (err) {\n                                _iterator4.e(err);\n                            } finally{\n                                _iterator4.f();\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator3.e(err);\n                } finally{\n                    _iterator3.f();\n                }\n                if (runGCNow) {\n                    this.gc();\n                    needGC = false;\n                }\n                return needGC;\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                var _iterator5 = _createForOfIteratorHelper(this.collections.values()), _step5;\n                try {\n                    for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                        var collection = _step5.value;\n                        collection.gc();\n                    }\n                } catch (err) {\n                    _iterator5.e(err);\n                } finally{\n                    _iterator5.f();\n                }\n            }\n        },\n        {\n            key: \"getOrCreateAtlas\",\n            value: function getOrCreateAtlas(ele, type, bb, styleKey) {\n                // styleKey is not an array here\n                var opts = this.renderTypes.get(type);\n                var atlasCollection = this.collections.get(opts.collection);\n                // draws the texture only if needed\n                var drawn = false;\n                var atlas = atlasCollection.draw(styleKey, bb, function(context) {\n                    if (opts.drawClipped) {\n                        context.save();\n                        context.beginPath();\n                        context.rect(0, 0, bb.w, bb.h);\n                        context.clip();\n                        opts.drawElement(context, ele, bb, true, true);\n                        context.restore();\n                    } else {\n                        opts.drawElement(context, ele, bb, true, true);\n                    }\n                    drawn = true;\n                });\n                if (drawn) {\n                    var id = opts.getID ? opts.getID(ele) : ele.id(); // for testing\n                    var mapKey = this._key(type, id);\n                    if (this.typeAndIdToKey.has(mapKey)) {\n                        this.typeAndIdToKey.get(mapKey).push(styleKey);\n                    } else {\n                        this.typeAndIdToKey.set(mapKey, [\n                            styleKey\n                        ]);\n                    }\n                }\n                return atlas;\n            }\n        },\n        {\n            key: \"getAtlasInfo\",\n            value: function getAtlasInfo(ele, type) {\n                var _this4 = this;\n                var opts = this.renderTypes.get(type);\n                var key = opts.getKey(ele);\n                var keyArray = Array.isArray(key) ? key : [\n                    key\n                ];\n                return keyArray.map(function(styleKey) {\n                    var bb = opts.getBoundingBox(ele, styleKey); // pass the key back to the getBoundingBox method\n                    var atlas = _this4.getOrCreateAtlas(ele, type, bb, styleKey);\n                    var _atlas$getOffsets3 = atlas.getOffsets(styleKey), _atlas$getOffsets4 = _slicedToArray(_atlas$getOffsets3, 2), tex1 = _atlas$getOffsets4[0], tex2 = _atlas$getOffsets4[1];\n                    return {\n                        atlas: atlas,\n                        tex: tex1,\n                        tex1: tex1,\n                        tex2: tex2,\n                        bb: bb\n                    };\n                });\n            }\n        },\n        {\n            key: \"getDebugInfo\",\n            value: function getDebugInfo() {\n                var debugInfo = [];\n                var _iterator6 = _createForOfIteratorHelper(this.collections), _step6;\n                try {\n                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                        var _step6$value = _slicedToArray(_step6.value, 2), name = _step6$value[0], collection = _step6$value[1];\n                        var _collection$getCounts = collection.getCounts(), keyCount = _collection$getCounts.keyCount, atlasCount = _collection$getCounts.atlasCount;\n                        debugInfo.push({\n                            type: name,\n                            keyCount: keyCount,\n                            atlasCount: atlasCount\n                        });\n                    }\n                } catch (err) {\n                    _iterator6.e(err);\n                } finally{\n                    _iterator6.f();\n                }\n                return debugInfo;\n            }\n        }\n    ]);\n}();\nvar AtlasBatchManager = /*#__PURE__*/ function() {\n    function AtlasBatchManager(globalOptions) {\n        _classCallCheck(this, AtlasBatchManager);\n        this.globalOptions = globalOptions;\n        this.atlasSize = globalOptions.webglTexSize;\n        this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;\n        this.batchAtlases = [];\n    }\n    return _createClass(AtlasBatchManager, [\n        {\n            key: \"getMaxAtlasesPerBatch\",\n            value: function getMaxAtlasesPerBatch() {\n                return this.maxAtlasesPerBatch;\n            }\n        },\n        {\n            key: \"getAtlasSize\",\n            value: function getAtlasSize() {\n                return this.atlasSize;\n            }\n        },\n        {\n            key: \"getIndexArray\",\n            value: function getIndexArray() {\n                return Array.from({\n                    length: this.maxAtlasesPerBatch\n                }, function(v, i) {\n                    return i;\n                });\n            }\n        },\n        {\n            key: \"startBatch\",\n            value: function startBatch() {\n                this.batchAtlases = [];\n            }\n        },\n        {\n            key: \"getAtlasCount\",\n            value: function getAtlasCount() {\n                return this.batchAtlases.length;\n            }\n        },\n        {\n            key: \"getAtlases\",\n            value: function getAtlases() {\n                return this.batchAtlases;\n            }\n        },\n        {\n            key: \"canAddToCurrentBatch\",\n            value: function canAddToCurrentBatch(atlas) {\n                if (this.batchAtlases.length === this.maxAtlasesPerBatch) {\n                    return this.batchAtlases.includes(atlas);\n                }\n                return true; // not full\n            }\n        },\n        {\n            key: \"getAtlasIndexForBatch\",\n            value: function getAtlasIndexForBatch(atlas) {\n                var atlasID = this.batchAtlases.indexOf(atlas);\n                if (atlasID < 0) {\n                    if (this.batchAtlases.length === this.maxAtlasesPerBatch) {\n                        throw new Error(\"cannot add more atlases to batch\");\n                    }\n                    this.batchAtlases.push(atlas);\n                    atlasID = this.batchAtlases.length - 1;\n                }\n                return atlasID;\n            }\n        }\n    ]);\n}();\n// Fragment shader functions to calculate signed distance\n// https://iquilezles.org/articles/distfunctions2d/\n// ellipse: https://www.shadertoy.com/view/4lsXDN \n/**\n * param p - point\n * float r - circle radius, eg 0.5 for unit circle\n */ var circleSD = \"\\n  float circleSD(vec2 p, float r) {\\n    return distance(vec2(0), p) - r; // signed distance\\n  }\\n\";\n/**\n * param p - point\n * param b - b.x = half width, b.y = half height\n */ var rectangleSD = \"\\n  float rectangleSD(vec2 p, vec2 b) {\\n    vec2 d = abs(p)-b;\\n    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);\\n  }\\n\";\n/**\n * param p - point\n * param b - b.x = half width, b.y = half height\n * param cr - vector of corner radiuses\n */ var roundRectangleSD = \"\\n  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {\\n    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;\\n    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;\\n    vec2 q = abs(p) - b + cr.x;\\n    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;\\n  }\\n\";\n/**\n * param p - point\n * param ab - a.x = horizontal radius, a.y = vertical radius\n */ var ellipseSD = \"\\n  float ellipseSD(vec2 p, vec2 ab) {\\n    p = abs( p ); // symmetry\\n\\n    // find root with Newton solver\\n    vec2 q = ab*(p-ab);\\n    float w = (q.x<q.y)? 1.570796327 : 0.0;\\n    for( int i=0; i<5; i++ ) {\\n      vec2 cs = vec2(cos(w),sin(w));\\n      vec2 u = ab*vec2( cs.x,cs.y);\\n      vec2 v = ab*vec2(-cs.y,cs.x);\\n      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\\n    }\\n    \\n    // compute final point and distance\\n    float d = length(p-ab*vec2(cos(w),sin(w)));\\n    \\n    // return signed distance\\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\\n  }\\n\";\n/**\n * Two render modes. Each mode has its own shader program. They are almost identical, the main difference is the output.\n * SCREEN:  output pixel colors to the screen\n * PICKING: output z-order index to an offscreen framebuffer, used to detect what's under the mouse cursor\n */ var RENDER_TARGET = {\n    SCREEN: {\n        name: \"screen\",\n        screen: true\n    },\n    PICKING: {\n        name: \"picking\",\n        picking: true\n    }\n};\n/**\n * Special handing for label textures in PICKING mode. See issue #3337.\n */ var TEX_PICKING_MODE = {\n    // render the texture just like in RENDER_TARGET.SCREEN mode\n    IGNORE: 1,\n    // don't render the texture at all\n    USE_BB: 2 // render the bounding box as an opaque rectangle\n};\n// Vertex types.\n// Used directly in the shaders so must be numeric.\n// There is only one shader program used for an entire frame that renders all types of elements.\n// There are if-else blocks in the shaders that do different things depending on the vertex type.\n// This allows all elements to be rendererd in large batches without switching shader programs.\nvar TEXTURE = 0;\nvar EDGE_STRAIGHT = 1;\nvar EDGE_CURVE_SEGMENT = 2;\nvar EDGE_ARROW = 3;\nvar RECTANGLE = 4;\nvar ROUND_RECTANGLE = 5;\nvar BOTTOM_ROUND_RECTANGLE = 6;\nvar ELLIPSE = 7;\nvar ElementDrawingWebGL = /*#__PURE__*/ function() {\n    /**\n   * @param {WebGLRenderingContext} gl\n   */ function ElementDrawingWebGL(r, gl, opts) {\n        _classCallCheck(this, ElementDrawingWebGL);\n        this.r = r; // reference to the canvas renderer\n        this.gl = gl;\n        this.maxInstances = opts.webglBatchSize;\n        this.atlasSize = opts.webglTexSize;\n        this.bgColor = opts.bgColor;\n        this.debug = opts.webglDebug;\n        this.batchDebugInfo = [];\n        opts.enableWrapping = true;\n        opts.createTextureCanvas = createTextureCanvas; // Unit tests mock this\n        this.atlasManager = new AtlasManager(r, opts);\n        this.batchManager = new AtlasBatchManager(opts);\n        this.simpleShapeOptions = new Map();\n        this.program = this._createShaderProgram(RENDER_TARGET.SCREEN);\n        this.pickingProgram = this._createShaderProgram(RENDER_TARGET.PICKING);\n        this.vao = this._createVAO();\n    }\n    /**\n   * @param { string } collectionName\n   * @param {{ texRows: number }} opts\n   */ return _createClass(ElementDrawingWebGL, [\n        {\n            key: \"addAtlasCollection\",\n            value: function addAtlasCollection(collectionName, opts) {\n                this.atlasManager.addAtlasCollection(collectionName, opts);\n            }\n        },\n        {\n            key: \"addTextureAtlasRenderType\",\n            value: function addTextureAtlasRenderType(typeName, opts) {\n                this.atlasManager.addRenderType(typeName, opts);\n            }\n        },\n        {\n            key: \"addSimpleShapeRenderType\",\n            value: function addSimpleShapeRenderType(typeName, opts) {\n                this.simpleShapeOptions.set(typeName, opts);\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(eles) {\n                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, type = _ref.type;\n                var atlasManager = this.atlasManager;\n                if (type) {\n                    return atlasManager.invalidate(eles, {\n                        filterType: function filterType(t) {\n                            return t === type;\n                        },\n                        forceRedraw: true\n                    });\n                } else {\n                    return atlasManager.invalidate(eles);\n                }\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                this.atlasManager.gc();\n            }\n        },\n        {\n            key: \"_createShaderProgram\",\n            value: function _createShaderProgram(renderTarget) {\n                var gl = this.gl;\n                var vertexShaderSource = \"#version 300 es\\n      precision highp float;\\n\\n      uniform mat3 uPanZoomMatrix;\\n      uniform int  uAtlasSize;\\n      \\n      // instanced\\n      in vec2 aPosition; // a vertex from the unit square\\n      \\n      in mat3 aTransform; // used to transform verticies, eg into a bounding box\\n      in int aVertType; // the type of thing we are rendering\\n\\n      // the z-index that is output when using picking mode\\n      in vec4 aIndex;\\n      \\n      // For textures\\n      in int aAtlasId; // which shader unit/atlas to use\\n      in vec4 aTex; // x/y/w/h of texture in atlas\\n\\n      // for edges\\n      in vec4 aPointAPointB;\\n      in vec4 aPointCPointD;\\n      in vec2 aLineWidth; // also used for node border width\\n\\n      // simple shapes\\n      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]\\n      in vec4 aColor; // also used for edges\\n      in vec4 aBorderColor; // aLineWidth is used for border width\\n\\n      // output values passed to the fragment shader\\n      out vec2 vTexCoord;\\n      out vec4 vColor;\\n      out vec2 vPosition;\\n      // flat values are not interpolated\\n      flat out int vAtlasId; \\n      flat out int vVertType;\\n      flat out vec2 vTopRight;\\n      flat out vec2 vBotLeft;\\n      flat out vec4 vCornerRadius;\\n      flat out vec4 vBorderColor;\\n      flat out vec2 vBorderWidth;\\n      flat out vec4 vIndex;\\n      \\n      void main(void) {\\n        int vid = gl_VertexID;\\n        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below\\n\\n        if(aVertType == \".concat(TEXTURE, \") {\\n          float texX = aTex.x; // texture coordinates\\n          float texY = aTex.y;\\n          float texW = aTex.z;\\n          float texH = aTex.w;\\n\\n          if(vid == 1 || vid == 2 || vid == 4) {\\n            texX += texW;\\n          }\\n          if(vid == 2 || vid == 4 || vid == 5) {\\n            texY += texH;\\n          }\\n\\n          float d = float(uAtlasSize);\\n          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n        }\\n        else if(aVertType == \").concat(RECTANGLE, \" || aVertType == \").concat(ELLIPSE, \" \\n             || aVertType == \").concat(ROUND_RECTANGLE, \" || aVertType == \").concat(BOTTOM_ROUND_RECTANGLE, \") { // simple shapes\\n\\n          // the bounding box is needed by the fragment shader\\n          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat\\n          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat\\n          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated\\n\\n          // calculations are done in the fragment shader, just pass these along\\n          vColor = aColor;\\n          vCornerRadius = aCornerRadius;\\n          vBorderColor = aBorderColor;\\n          vBorderWidth = aLineWidth;\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n        }\\n        else if(aVertType == \").concat(EDGE_STRAIGHT, \") {\\n          vec2 source = aPointAPointB.xy;\\n          vec2 target = aPointAPointB.zw;\\n\\n          // adjust the geometry so that the line is centered on the edge\\n          position.y = position.y - 0.5;\\n\\n          // stretch the unit square into a long skinny rectangle\\n          vec2 xBasis = target - source;\\n          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\\n          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;\\n\\n          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);\\n          vColor = aColor;\\n        } \\n        else if(aVertType == \").concat(EDGE_CURVE_SEGMENT, \") {\\n          vec2 pointA = aPointAPointB.xy;\\n          vec2 pointB = aPointAPointB.zw;\\n          vec2 pointC = aPointCPointD.xy;\\n          vec2 pointD = aPointCPointD.zw;\\n\\n          // adjust the geometry so that the line is centered on the edge\\n          position.y = position.y - 0.5;\\n\\n          vec2 p0, p1, p2, pos;\\n          if(position.x == 0.0) { // The left side of the unit square\\n            p0 = pointA;\\n            p1 = pointB;\\n            p2 = pointC;\\n            pos = position;\\n          } else { // The right side of the unit square, use same approach but flip the geometry upside down\\n            p0 = pointD;\\n            p1 = pointC;\\n            p2 = pointB;\\n            pos = vec2(0.0, -position.y);\\n          }\\n\\n          vec2 p01 = p1 - p0;\\n          vec2 p12 = p2 - p1;\\n          vec2 p21 = p1 - p2;\\n\\n          // Find the normal vector.\\n          vec2 tangent = normalize(normalize(p12) + normalize(p01));\\n          vec2 normal = vec2(-tangent.y, tangent.x);\\n\\n          // Find the vector perpendicular to p0 -> p1.\\n          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));\\n\\n          // Determine the bend direction.\\n          float sigma = sign(dot(p01 + p21, normal));\\n          float width = aLineWidth[0];\\n\\n          if(sign(pos.y) == -sigma) {\\n            // This is an intersecting vertex. Adjust the position so that there's no overlap.\\n            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);\\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\\n          } else {\\n            // This is a non-intersecting vertex. Treat it like a mitre join.\\n            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);\\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\\n          }\\n\\n          vColor = aColor;\\n        } \\n        else if(aVertType == \").concat(EDGE_ARROW, \" && vid < 3) {\\n          // massage the first triangle into an edge arrow\\n          if(vid == 0)\\n            position = vec2(-0.15, -0.3);\\n          if(vid == 1)\\n            position = vec2(  0.0,  0.0);\\n          if(vid == 2)\\n            position = vec2( 0.15, -0.3);\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n          vColor = aColor;\\n        }\\n        else {\\n          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space\\n        }\\n\\n        vAtlasId = aAtlasId;\\n        vVertType = aVertType;\\n        vIndex = aIndex;\\n      }\\n    \");\n                var idxs = this.batchManager.getIndexArray();\n                var fragmentShaderSource = \"#version 300 es\\n      precision highp float;\\n\\n      // declare texture unit for each texture atlas in the batch\\n      \".concat(idxs.map(function(i) {\n                    return \"uniform sampler2D uTexture\".concat(i, \";\");\n                }).join(\"\\n\t\"), \"\\n\\n      uniform vec4 uBGColor;\\n      uniform float uZoom;\\n\\n      in vec2 vTexCoord;\\n      in vec4 vColor;\\n      in vec2 vPosition; // model coordinates\\n\\n      flat in int vAtlasId;\\n      flat in vec4 vIndex;\\n      flat in int vVertType;\\n      flat in vec2 vTopRight;\\n      flat in vec2 vBotLeft;\\n      flat in vec4 vCornerRadius;\\n      flat in vec4 vBorderColor;\\n      flat in vec2 vBorderWidth;\\n\\n      out vec4 outColor;\\n\\n      \").concat(circleSD, \"\\n      \").concat(rectangleSD, \"\\n      \").concat(roundRectangleSD, \"\\n      \").concat(ellipseSD, \"\\n\\n      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha\\n        return vec4( \\n          top.rgb + (bot.rgb * (1.0 - top.a)),\\n          top.a   + (bot.a   * (1.0 - top.a)) \\n        );\\n      }\\n\\n      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance\\n        // scale to the zoom level so that borders don't look blurry when zoomed in\\n        // note 1.5 is an aribitrary value chosen because it looks good\\n        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); \\n      }\\n\\n      void main(void) {\\n        if(vVertType == \").concat(TEXTURE, \") {\\n          // look up the texel from the texture unit\\n          \").concat(idxs.map(function(i) {\n                    return \"if(vAtlasId == \".concat(i, \") outColor = texture(uTexture\").concat(i, \", vTexCoord);\");\n                }).join(\"\\n\telse \"), \"\\n        } \\n        else if(vVertType == \").concat(EDGE_ARROW, \") {\\n          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';\\n          outColor = blend(vColor, uBGColor);\\n          outColor.a = 1.0; // make opaque, masks out line under arrow\\n        }\\n        else if(vVertType == \").concat(RECTANGLE, \" && vBorderWidth == vec2(0.0)) { // simple rectangle with no border\\n          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done\\n        }\\n        else if(vVertType == \").concat(RECTANGLE, \" || vVertType == \").concat(ELLIPSE, \" \\n          || vVertType == \").concat(ROUND_RECTANGLE, \" || vVertType == \").concat(BOTTOM_ROUND_RECTANGLE, \") { // use SDF\\n\\n          float outerBorder = vBorderWidth[0];\\n          float innerBorder = vBorderWidth[1];\\n          float borderPadding = outerBorder * 2.0;\\n          float w = vTopRight.x - vBotLeft.x - borderPadding;\\n          float h = vTopRight.y - vBotLeft.y - borderPadding;\\n          vec2 b = vec2(w/2.0, h/2.0); // half width, half height\\n          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center\\n\\n          float d; // signed distance\\n          if(vVertType == \").concat(RECTANGLE, \") {\\n            d = rectangleSD(p, b);\\n          } else if(vVertType == \").concat(ELLIPSE, \" && w == h) {\\n            d = circleSD(p, b.x); // faster than ellipse\\n          } else if(vVertType == \").concat(ELLIPSE, \") {\\n            d = ellipseSD(p, b);\\n          } else {\\n            d = roundRectangleSD(p, b, vCornerRadius.wzyx);\\n          }\\n\\n          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling\\n          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box\\n          if(d > 0.0) {\\n            if(d > outerBorder) {\\n              discard;\\n            } else {\\n              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);\\n            }\\n          } else {\\n            if(d > innerBorder) {\\n              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;\\n              vec4 innerBorderColor = blend(vBorderColor, vColor);\\n              outColor = distInterp(innerBorderColor, outerColor, d);\\n            } \\n            else {\\n              vec4 outerColor;\\n              if(innerBorder == 0.0 && outerBorder == 0.0) {\\n                outerColor = vec4(0);\\n              } else if(innerBorder == 0.0) {\\n                outerColor = vBorderColor;\\n              } else {\\n                outerColor = blend(vBorderColor, vColor);\\n              }\\n              outColor = distInterp(vColor, outerColor, d - innerBorder);\\n            }\\n          }\\n        }\\n        else {\\n          outColor = vColor;\\n        }\\n\\n        \").concat(renderTarget.picking ? \"if(outColor.a == 0.0) discard;\\n             else outColor = vIndex;\" : \"\", \"\\n      }\\n    \");\n                var program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n                // instance geometry\n                program.aPosition = gl.getAttribLocation(program, \"aPosition\");\n                // attributes\n                program.aIndex = gl.getAttribLocation(program, \"aIndex\");\n                program.aVertType = gl.getAttribLocation(program, \"aVertType\");\n                program.aTransform = gl.getAttribLocation(program, \"aTransform\");\n                program.aAtlasId = gl.getAttribLocation(program, \"aAtlasId\");\n                program.aTex = gl.getAttribLocation(program, \"aTex\");\n                program.aPointAPointB = gl.getAttribLocation(program, \"aPointAPointB\");\n                program.aPointCPointD = gl.getAttribLocation(program, \"aPointCPointD\");\n                program.aLineWidth = gl.getAttribLocation(program, \"aLineWidth\");\n                program.aColor = gl.getAttribLocation(program, \"aColor\");\n                program.aCornerRadius = gl.getAttribLocation(program, \"aCornerRadius\");\n                program.aBorderColor = gl.getAttribLocation(program, \"aBorderColor\");\n                // uniforms\n                program.uPanZoomMatrix = gl.getUniformLocation(program, \"uPanZoomMatrix\");\n                program.uAtlasSize = gl.getUniformLocation(program, \"uAtlasSize\");\n                program.uBGColor = gl.getUniformLocation(program, \"uBGColor\");\n                program.uZoom = gl.getUniformLocation(program, \"uZoom\");\n                program.uTextures = [];\n                for(var i = 0; i < this.batchManager.getMaxAtlasesPerBatch(); i++){\n                    program.uTextures.push(gl.getUniformLocation(program, \"uTexture\".concat(i)));\n                }\n                return program;\n            }\n        },\n        {\n            key: \"_createVAO\",\n            value: function _createVAO() {\n                var unitSquare = [\n                    0,\n                    0,\n                    1,\n                    0,\n                    1,\n                    1,\n                    0,\n                    0,\n                    1,\n                    1,\n                    0,\n                    1\n                ];\n                this.vertexCount = unitSquare.length / 2;\n                var n = this.maxInstances;\n                var gl = this.gl, program = this.program;\n                var vao = gl.createVertexArray();\n                gl.bindVertexArray(vao);\n                createBufferStaticDraw(gl, \"vec2\", program.aPosition, unitSquare);\n                // Create buffers for all the attributes\n                this.transformBuffer = create3x3MatrixBufferDynamicDraw(gl, n, program.aTransform);\n                this.indexBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aIndex);\n                this.vertTypeBuffer = createBufferDynamicDraw(gl, n, \"int\", program.aVertType);\n                this.atlasIdBuffer = createBufferDynamicDraw(gl, n, \"int\", program.aAtlasId);\n                this.texBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aTex);\n                this.pointAPointBBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aPointAPointB);\n                this.pointCPointDBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aPointCPointD);\n                this.lineWidthBuffer = createBufferDynamicDraw(gl, n, \"vec2\", program.aLineWidth);\n                this.colorBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aColor);\n                this.cornerRadiusBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aCornerRadius);\n                this.borderColorBuffer = createBufferDynamicDraw(gl, n, \"vec4\", program.aBorderColor);\n                gl.bindVertexArray(null);\n                return vao;\n            }\n        },\n        {\n            key: \"buffers\",\n            get: function get() {\n                var _this = this;\n                if (!this._buffers) {\n                    this._buffers = Object.keys(this).filter(function(k) {\n                        return endsWith(k, \"Buffer\");\n                    }).map(function(k) {\n                        return _this[k];\n                    });\n                }\n                return this._buffers;\n            }\n        },\n        {\n            key: \"startFrame\",\n            value: function startFrame(panZoomMatrix) {\n                var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RENDER_TARGET.SCREEN;\n                this.panZoomMatrix = panZoomMatrix;\n                this.renderTarget = renderTarget;\n                this.batchDebugInfo = [];\n                this.wrappedCount = 0;\n                this.simpleCount = 0;\n                this.startBatch();\n            }\n        },\n        {\n            key: \"startBatch\",\n            value: function startBatch() {\n                this.instanceCount = 0;\n                this.batchManager.startBatch();\n            }\n        },\n        {\n            key: \"endFrame\",\n            value: function endFrame() {\n                this.endBatch();\n            }\n        },\n        {\n            key: \"_isVisible\",\n            value: function _isVisible(ele, opts) {\n                if (ele.visible()) {\n                    if (opts && opts.isVisible) {\n                        return opts.isVisible(ele);\n                    }\n                    return true;\n                }\n                return false;\n            }\n        },\n        {\n            key: \"drawTexture\",\n            value: function drawTexture(ele, eleIndex, type) {\n                var atlasManager = this.atlasManager, batchManager = this.batchManager;\n                var opts = atlasManager.getRenderTypeOpts(type);\n                if (!this._isVisible(ele, opts)) {\n                    return;\n                }\n                // Edges with invalid points could be passed here (labels), causing errors\n                // Ref: Random \"Script Error\" thrown when generating nodes and edges in newest webgl version #3365\n                // https://github.com/cytoscape/cytoscape.js/issues/3365\n                if (ele.isEdge() && !this._isValidEdge(ele)) {\n                    return;\n                }\n                if (this.renderTarget.picking && opts.getTexPickingMode) {\n                    var mode = opts.getTexPickingMode(ele);\n                    if (mode === TEX_PICKING_MODE.IGNORE) {\n                        return;\n                    } else if (mode == TEX_PICKING_MODE.USE_BB) {\n                        this.drawPickingRectangle(ele, eleIndex, type);\n                        return;\n                    }\n                }\n                // Get the atlas and the texture coordinates, will draw the texture if it hasn't been drawn yet\n                // May be more than one texture if for example the label has multiple lines\n                var atlasInfoArray = atlasManager.getAtlasInfo(ele, type);\n                var _iterator = _createForOfIteratorHelper(atlasInfoArray), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var atlasInfo = _step.value;\n                        var atlas = atlasInfo.atlas, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2; // tex2 is used if the label wraps and there are two textures\n                        if (!batchManager.canAddToCurrentBatch(atlas)) {\n                            this.endBatch();\n                        }\n                        var atlasIndex = batchManager.getAtlasIndexForBatch(atlas);\n                        for(var _i = 0, _arr = [\n                            [\n                                tex1,\n                                true\n                            ],\n                            [\n                                tex2,\n                                false\n                            ]\n                        ]; _i < _arr.length; _i++){\n                            var _arr$_i = _slicedToArray(_arr[_i], 2), tex = _arr$_i[0], first = _arr$_i[1];\n                            if (tex.w != 0) {\n                                var instance = this.instanceCount;\n                                this.vertTypeBuffer.getView(instance)[0] = TEXTURE;\n                                var indexView = this.indexBuffer.getView(instance);\n                                indexToVec4(eleIndex, indexView);\n                                // Set values in the buffers using Typed Array Views for performance.\n                                var atlasIdView = this.atlasIdBuffer.getView(instance);\n                                atlasIdView[0] = atlasIndex;\n                                // we have two sets of texture coordinates and transforms because textures can wrap in the atlas\n                                var texView = this.texBuffer.getView(instance);\n                                texView[0] = tex.x;\n                                texView[1] = tex.y;\n                                texView[2] = tex.w;\n                                texView[3] = tex.h;\n                                var matrixView = this.transformBuffer.getMatrixView(instance);\n                                this.setTransformMatrix(ele, matrixView, opts, atlasInfo, first);\n                                this.instanceCount++;\n                                if (!first) this.wrappedCount++;\n                                if (this.instanceCount >= this.maxInstances) {\n                                    this.endBatch();\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n            }\n        },\n        {\n            key: \"setTransformMatrix\",\n            value: function setTransformMatrix(ele, matrix, opts, atlasInfo) {\n                var first = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n                var padding = 0;\n                if (opts.shapeProps && opts.shapeProps.padding) {\n                    padding = ele.pstyle(opts.shapeProps.padding).pfValue;\n                }\n                if (atlasInfo) {\n                    // we've already computed the bb and tex bounds for a texture\n                    var bb = atlasInfo.bb, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2;\n                    // wrapped textures need separate matrix for each part\n                    var ratio = tex1.w / (tex1.w + tex2.w);\n                    if (!first) {\n                        // first = true means its the first part of the wrapped texture\n                        ratio = 1 - ratio;\n                    }\n                    var adjBB = this._getAdjustedBB(bb, padding, first, ratio);\n                    this._applyTransformMatrix(matrix, adjBB, opts, ele);\n                } else {\n                    // we don't have a texture, or we want to avoid creating a texture for simple shapes\n                    var _bb = opts.getBoundingBox(ele);\n                    var _adjBB = this._getAdjustedBB(_bb, padding, true, 1);\n                    this._applyTransformMatrix(matrix, _adjBB, opts, ele);\n                }\n            }\n        },\n        {\n            key: \"_applyTransformMatrix\",\n            value: function _applyTransformMatrix(matrix, adjBB, opts, ele) {\n                var x, y;\n                identity(matrix);\n                var theta = opts.getRotation ? opts.getRotation(ele) : 0;\n                if (theta !== 0) {\n                    var _opts$getRotationPoin = opts.getRotationPoint(ele), sx = _opts$getRotationPoin.x, sy = _opts$getRotationPoin.y;\n                    translate(matrix, matrix, [\n                        sx,\n                        sy\n                    ]);\n                    rotate(matrix, matrix, theta);\n                    var offset = opts.getRotationOffset(ele);\n                    x = offset.x + (adjBB.xOffset || 0);\n                    y = offset.y + (adjBB.yOffset || 0);\n                } else {\n                    x = adjBB.x1;\n                    y = adjBB.y1;\n                }\n                translate(matrix, matrix, [\n                    x,\n                    y\n                ]);\n                scale(matrix, matrix, [\n                    adjBB.w,\n                    adjBB.h\n                ]);\n            }\n        },\n        {\n            key: \"_getAdjustedBB\",\n            value: function _getAdjustedBB(bb, padding, first, ratio) {\n                var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h, yOffset = bb.yOffset;\n                if (padding) {\n                    x1 -= padding;\n                    y1 -= padding;\n                    w += 2 * padding;\n                    h += 2 * padding;\n                }\n                var xOffset = 0;\n                var adjW = w * ratio;\n                if (first && ratio < 1) {\n                    w = adjW;\n                } else if (!first && ratio < 1) {\n                    xOffset = w - adjW;\n                    x1 += xOffset;\n                    w = adjW;\n                }\n                return {\n                    x1: x1,\n                    y1: y1,\n                    w: w,\n                    h: h,\n                    xOffset: xOffset,\n                    yOffset: yOffset\n                };\n            }\n        },\n        {\n            key: \"drawPickingRectangle\",\n            value: function drawPickingRectangle(ele, eleIndex, type) {\n                var opts = this.atlasManager.getRenderTypeOpts(type);\n                var instance = this.instanceCount;\n                this.vertTypeBuffer.getView(instance)[0] = RECTANGLE;\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor([\n                    0,\n                    0,\n                    0\n                ], 1, colorView); // opaque, so entire label BB is clickable\n                var matrixView = this.transformBuffer.getMatrixView(instance);\n                this.setTransformMatrix(ele, matrixView, opts);\n                this.simpleCount++;\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"drawNode\",\n            value: function drawNode(node, eleIndex, type) {\n                var opts = this.simpleShapeOptions.get(type);\n                if (!this._isVisible(node, opts)) {\n                    return;\n                }\n                var props = opts.shapeProps;\n                // Check if we have to use a texture\n                var vertType = this._getVertTypeForShape(node, props.shape);\n                if (vertType === undefined || opts.isSimple && !opts.isSimple(node)) {\n                    this.drawTexture(node, eleIndex, type);\n                    return;\n                }\n                // Render a \"simple shape\" using SDF (signed distance fields)\n                var instance = this.instanceCount;\n                this.vertTypeBuffer.getView(instance)[0] = vertType;\n                if (vertType === ROUND_RECTANGLE || vertType === BOTTOM_ROUND_RECTANGLE) {\n                    // get corner radius\n                    var bb = opts.getBoundingBox(node);\n                    var radius = this._getCornerRadius(node, props.radius, bb);\n                    var radiusView = this.cornerRadiusBuffer.getView(instance);\n                    radiusView[0] = radius; // top-right\n                    radiusView[1] = radius; // bottom-right\n                    radiusView[2] = radius; // top-left\n                    radiusView[3] = radius; // bottom-left\n                    if (vertType === BOTTOM_ROUND_RECTANGLE) {\n                        radiusView[0] = 0;\n                        radiusView[2] = 0;\n                    }\n                }\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var color = node.pstyle(props.color).value;\n                var opacity = node.pstyle(props.opacity).value;\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor(color, opacity, colorView);\n                var lineWidthView = this.lineWidthBuffer.getView(instance); // reuse edge line width attribute for node border\n                lineWidthView[0] = 0;\n                lineWidthView[1] = 0;\n                if (props.border) {\n                    var borderWidth = node.pstyle(\"border-width\").value;\n                    if (borderWidth > 0) {\n                        var borderColor = node.pstyle(\"border-color\").value;\n                        var borderOpacity = node.pstyle(\"border-opacity\").value;\n                        var borderColorView = this.borderColorBuffer.getView(instance);\n                        toWebGLColor(borderColor, borderOpacity, borderColorView);\n                        // SDF distance is negative inside the shape and positive outside\n                        var borderPos = node.pstyle(\"border-position\").value;\n                        if (borderPos === \"inside\") {\n                            lineWidthView[0] = 0;\n                            lineWidthView[1] = -borderWidth;\n                        } else if (borderPos === \"outside\") {\n                            lineWidthView[0] = borderWidth;\n                            lineWidthView[1] = 0;\n                        } else {\n                            // 'center'\n                            var halfWidth = borderWidth / 2;\n                            lineWidthView[0] = halfWidth;\n                            lineWidthView[1] = -halfWidth;\n                        }\n                    }\n                }\n                var matrixView = this.transformBuffer.getMatrixView(instance);\n                this.setTransformMatrix(node, matrixView, opts);\n                this.simpleCount++;\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"_getVertTypeForShape\",\n            value: function _getVertTypeForShape(node, shapeProp) {\n                var shape = node.pstyle(shapeProp).value;\n                switch(shape){\n                    case \"rectangle\":\n                        return RECTANGLE;\n                    case \"ellipse\":\n                        return ELLIPSE;\n                    case \"roundrectangle\":\n                    case \"round-rectangle\":\n                        return ROUND_RECTANGLE;\n                    case \"bottom-round-rectangle\":\n                        return BOTTOM_ROUND_RECTANGLE;\n                    default:\n                        return undefined;\n                }\n            }\n        },\n        {\n            key: \"_getCornerRadius\",\n            value: function _getCornerRadius(node, radiusProp, _ref2) {\n                var w = _ref2.w, h = _ref2.h;\n                // see CRp.drawRoundRectanglePath\n                if (node.pstyle(radiusProp).value === \"auto\") {\n                    return getRoundRectangleRadius(w, h);\n                } else {\n                    var radius = node.pstyle(radiusProp).pfValue;\n                    var halfWidth = w / 2;\n                    var halfHeight = h / 2;\n                    return Math.min(radius, halfHeight, halfWidth);\n                }\n            }\n        },\n        {\n            key: \"drawEdgeArrow\",\n            value: function drawEdgeArrow(edge, eleIndex, prefix) {\n                if (!edge.visible()) {\n                    return;\n                }\n                // Edge points and arrow angles etc are calculated by the base renderer and cached in the rscratch object.\n                var rs = edge._private.rscratch;\n                var x, y, angle;\n                if (prefix === \"source\") {\n                    x = rs.arrowStartX;\n                    y = rs.arrowStartY;\n                    angle = rs.srcArrowAngle;\n                } else {\n                    x = rs.arrowEndX;\n                    y = rs.arrowEndY;\n                    angle = rs.tgtArrowAngle;\n                }\n                // taken from CRp.drawArrowhead\n                if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n                    return;\n                }\n                // check shape after the x/y check because pstyle() is a bit slow\n                var arrowShape = edge.pstyle(prefix + \"-arrow-shape\").value;\n                if (arrowShape === \"none\") {\n                    return;\n                }\n                var color = edge.pstyle(prefix + \"-arrow-color\").value;\n                var baseOpacity = edge.pstyle(\"opacity\").value;\n                var lineOpacity = edge.pstyle(\"line-opacity\").value;\n                var opacity = baseOpacity * lineOpacity;\n                var lineWidth = edge.pstyle(\"width\").pfValue;\n                var scale$1 = edge.pstyle(\"arrow-scale\").value;\n                var size = this.r.getArrowWidth(lineWidth, scale$1);\n                var instance = this.instanceCount;\n                var transform = this.transformBuffer.getMatrixView(instance);\n                identity(transform);\n                translate(transform, transform, [\n                    x,\n                    y\n                ]);\n                scale(transform, transform, [\n                    size,\n                    size\n                ]);\n                rotate(transform, transform, angle);\n                this.vertTypeBuffer.getView(instance)[0] = EDGE_ARROW;\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor(color, opacity, colorView);\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"drawEdgeLine\",\n            value: function drawEdgeLine(edge, eleIndex) {\n                if (!edge.visible()) {\n                    return;\n                }\n                var points = this._getEdgePoints(edge);\n                if (!points) {\n                    return;\n                }\n                // line style\n                var baseOpacity = edge.pstyle(\"opacity\").value;\n                var lineOpacity = edge.pstyle(\"line-opacity\").value;\n                var width = edge.pstyle(\"width\").pfValue;\n                var color = edge.pstyle(\"line-color\").value;\n                var opacity = baseOpacity * lineOpacity;\n                if (points.length / 2 + this.instanceCount > this.maxInstances) {\n                    this.endBatch();\n                }\n                if (points.length == 4) {\n                    // straight line\n                    var instance = this.instanceCount;\n                    this.vertTypeBuffer.getView(instance)[0] = EDGE_STRAIGHT;\n                    var indexView = this.indexBuffer.getView(instance);\n                    indexToVec4(eleIndex, indexView);\n                    var colorView = this.colorBuffer.getView(instance);\n                    toWebGLColor(color, opacity, colorView);\n                    var lineWidthBuffer = this.lineWidthBuffer.getView(instance);\n                    lineWidthBuffer[0] = width;\n                    var sourceTargetView = this.pointAPointBBuffer.getView(instance);\n                    sourceTargetView[0] = points[0]; // source x\n                    sourceTargetView[1] = points[1]; // source y\n                    sourceTargetView[2] = points[2]; // target x\n                    sourceTargetView[3] = points[3]; // target y\n                    this.instanceCount++;\n                    if (this.instanceCount >= this.maxInstances) {\n                        this.endBatch();\n                    }\n                } else {\n                    // curved line\n                    for(var i = 0; i < points.length - 2; i += 2){\n                        var _instance = this.instanceCount;\n                        this.vertTypeBuffer.getView(_instance)[0] = EDGE_CURVE_SEGMENT;\n                        var _indexView = this.indexBuffer.getView(_instance);\n                        indexToVec4(eleIndex, _indexView);\n                        var _colorView = this.colorBuffer.getView(_instance);\n                        toWebGLColor(color, opacity, _colorView);\n                        var _lineWidthBuffer = this.lineWidthBuffer.getView(_instance);\n                        _lineWidthBuffer[0] = width;\n                        var pAx = points[i - 2], pAy = points[i - 1];\n                        var pBx = points[i], pBy = points[i + 1];\n                        var pCx = points[i + 2], pCy = points[i + 3];\n                        var pDx = points[i + 4], pDy = points[i + 5];\n                        // make phantom points for the first and last segments\n                        // TODO adding 0.001 to avoid division by zero in the shader (I think), need a better solution\n                        if (i == 0) {\n                            pAx = 2 * pBx - pCx + 0.001;\n                            pAy = 2 * pBy - pCy + 0.001;\n                        }\n                        if (i == points.length - 4) {\n                            pDx = 2 * pCx - pBx + 0.001;\n                            pDy = 2 * pCy - pBy + 0.001;\n                        }\n                        var pointABView = this.pointAPointBBuffer.getView(_instance);\n                        pointABView[0] = pAx;\n                        pointABView[1] = pAy;\n                        pointABView[2] = pBx;\n                        pointABView[3] = pBy;\n                        var pointCDView = this.pointCPointDBuffer.getView(_instance);\n                        pointCDView[0] = pCx;\n                        pointCDView[1] = pCy;\n                        pointCDView[2] = pDx;\n                        pointCDView[3] = pDy;\n                        this.instanceCount++;\n                        if (this.instanceCount >= this.maxInstances) {\n                            this.endBatch();\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"_isValidEdge\",\n            value: function _isValidEdge(edge) {\n                var rs = edge._private.rscratch;\n                if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n                    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n                    return false;\n                }\n                return true;\n            }\n        },\n        {\n            key: \"_getEdgePoints\",\n            value: function _getEdgePoints(edge) {\n                var rs = edge._private.rscratch;\n                // if bezier ctrl pts can not be calculated, then die\n                if (!this._isValidEdge(edge)) {\n                    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n                    return;\n                }\n                var controlPoints = rs.allpts;\n                if (controlPoints.length == 4) {\n                    return controlPoints;\n                }\n                var numSegments = this._getNumSegments(edge);\n                return this._getCurveSegmentPoints(controlPoints, numSegments);\n            }\n        },\n        {\n            key: \"_getNumSegments\",\n            value: function _getNumSegments(edge) {\n                // TODO Need a heuristic that decides how many segments to use. Factors to consider:\n                // - edge width/length\n                // - edge curvature (the more the curvature, the more segments)\n                // - zoom level (more segments when zoomed in)\n                // - number of visible edges (more segments when there are fewer edges)\n                // - performance (fewer segments when performance is a concern)\n                // - user configurable option(s)\n                // note: number of segments must be less than the max number of instances\n                // note: segments don't need to be evenly spaced out, it might make sense to have shorter segments nearer to the control points\n                var numSegments = 15;\n                return Math.min(Math.max(numSegments, 5), this.maxInstances);\n            }\n        },\n        {\n            key: \"_getCurveSegmentPoints\",\n            value: function _getCurveSegmentPoints(controlPoints, segments) {\n                if (controlPoints.length == 4) {\n                    return controlPoints; // straight line\n                }\n                var curvePoints = Array((segments + 1) * 2);\n                for(var i = 0; i <= segments; i++){\n                    // the first and last points are the same as the first and last control points\n                    if (i == 0) {\n                        curvePoints[0] = controlPoints[0];\n                        curvePoints[1] = controlPoints[1];\n                    } else if (i == segments) {\n                        curvePoints[i * 2] = controlPoints[controlPoints.length - 2];\n                        curvePoints[i * 2 + 1] = controlPoints[controlPoints.length - 1];\n                    } else {\n                        var t = i / segments; // segments have equal length, its not strictly necessary to do it this way\n                        // pass in curvePoints to set the values in the array directly\n                        this._setCurvePoint(controlPoints, t, curvePoints, i * 2);\n                    }\n                }\n                return curvePoints;\n            }\n        },\n        {\n            key: \"_setCurvePoint\",\n            value: function _setCurvePoint(points, t, curvePoints, cpi) {\n                if (points.length <= 2) {\n                    curvePoints[cpi] = points[0];\n                    curvePoints[cpi + 1] = points[1];\n                } else {\n                    var newpoints = Array(points.length - 2);\n                    for(var i = 0; i < newpoints.length; i += 2){\n                        var x = (1 - t) * points[i] + t * points[i + 2];\n                        var y = (1 - t) * points[i + 1] + t * points[i + 3];\n                        newpoints[i] = x;\n                        newpoints[i + 1] = y;\n                    }\n                    return this._setCurvePoint(newpoints, t, curvePoints, cpi);\n                }\n            }\n        },\n        {\n            key: \"endBatch\",\n            value: function endBatch() {\n                var gl = this.gl, vao = this.vao, vertexCount = this.vertexCount, count = this.instanceCount;\n                if (count === 0) return;\n                var program = this.renderTarget.picking ? this.pickingProgram : this.program;\n                gl.useProgram(program);\n                gl.bindVertexArray(vao);\n                // buffer the attribute data\n                var _iterator2 = _createForOfIteratorHelper(this.buffers), _step2;\n                try {\n                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                        var buffer = _step2.value;\n                        buffer.bufferSubData(count);\n                    }\n                } catch (err) {\n                    _iterator2.e(err);\n                } finally{\n                    _iterator2.f();\n                }\n                var atlases = this.batchManager.getAtlases();\n                // must buffer before activating texture units\n                for(var i = 0; i < atlases.length; i++){\n                    atlases[i].bufferIfNeeded(gl);\n                }\n                // Activate all the texture units that we need\n                for(var _i2 = 0; _i2 < atlases.length; _i2++){\n                    gl.activeTexture(gl.TEXTURE0 + _i2);\n                    gl.bindTexture(gl.TEXTURE_2D, atlases[_i2].texture);\n                    gl.uniform1i(program.uTextures[_i2], _i2);\n                }\n                // Set the uniforms\n                gl.uniform1f(program.uZoom, getEffectiveZoom(this.r));\n                gl.uniformMatrix3fv(program.uPanZoomMatrix, false, this.panZoomMatrix);\n                gl.uniform1i(program.uAtlasSize, this.batchManager.getAtlasSize());\n                // set background color, needed for edge arrow color blending\n                var webglBgColor = toWebGLColor(this.bgColor, 1);\n                gl.uniform4fv(program.uBGColor, webglBgColor);\n                // draw!\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, vertexCount, count);\n                gl.bindVertexArray(null);\n                gl.bindTexture(gl.TEXTURE_2D, null); // TODO is this right when having multiple texture units?\n                if (this.debug) {\n                    this.batchDebugInfo.push({\n                        count: count,\n                        // instance count\n                        atlasCount: atlases.length\n                    });\n                }\n                // start the next batch, even if not needed\n                this.startBatch();\n            }\n        },\n        {\n            key: \"getDebugInfo\",\n            value: function getDebugInfo() {\n                var atlasInfo = this.atlasManager.getDebugInfo();\n                var totalAtlases = atlasInfo.reduce(function(count, info) {\n                    return count + info.atlasCount;\n                }, 0);\n                var batchInfo = this.batchDebugInfo;\n                var totalInstances = batchInfo.reduce(function(count, info) {\n                    return count + info.count;\n                }, 0);\n                return {\n                    atlasInfo: atlasInfo,\n                    totalAtlases: totalAtlases,\n                    wrappedCount: this.wrappedCount,\n                    simpleCount: this.simpleCount,\n                    batchCount: batchInfo.length,\n                    batchInfo: batchInfo,\n                    totalInstances: totalInstances\n                };\n            }\n        }\n    ]);\n}();\nvar CRp$4 = {};\n/**\n * Initialize the WebGL rendering mode after the Canvas renderer has been initialized.\n */ CRp$4.initWebgl = function(opts, fns) {\n    var r = this;\n    var gl = r.data.contexts[r.WEBGL];\n    // Set defaults and limits for configuration options.\n    opts.bgColor = getBGColor(r);\n    opts.webglTexSize = Math.min(opts.webglTexSize, gl.getParameter(gl.MAX_TEXTURE_SIZE));\n    opts.webglTexRows = Math.min(opts.webglTexRows, 54);\n    opts.webglTexRowsNodes = Math.min(opts.webglTexRowsNodes, 54);\n    opts.webglBatchSize = Math.min(opts.webglBatchSize, 16384);\n    opts.webglTexPerBatch = Math.min(opts.webglTexPerBatch, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));\n    // Turn debug mode on or off.\n    r.webglDebug = opts.webglDebug;\n    r.webglDebugShowAtlases = opts.webglDebugShowAtlases;\n    // Create offscreen framebuffer that stores the results when RENDER_TARGET.PICKING is enabled.\n    // This is used to store the topmost element z-index for each pixel, which is used to tell whats under the mouse cursor point.\n    r.pickingFrameBuffer = createPickingFrameBuffer(gl);\n    r.pickingFrameBuffer.needsDraw = true;\n    // Create an ElementDrawingWebGL instance wich is used to do the actual WebGL rendering.\n    // This instance needs to be configured to draw various types of elements.\n    r.drawing = new ElementDrawingWebGL(r, gl, opts);\n    // Some functions that are used to configure ElementDrawingWebGL\n    var getLabelRotation = function getLabelRotation(prop) {\n        return function(ele) {\n            return r.getTextAngle(ele, prop);\n        };\n    };\n    var isLabelVisible = function isLabelVisible(prop) {\n        return function(ele) {\n            var label = ele.pstyle(prop);\n            return label && label.value;\n        };\n    };\n    var isLayerVisible = function isLayerVisible(prefix) {\n        return function(node) {\n            // prefix is 'overlay' or 'underlay'\n            return node.pstyle(\"\".concat(prefix, \"-opacity\")).value > 0;\n        };\n    };\n    var getTexPickingMode = function getTexPickingMode(ele) {\n        // tells when a label should be clickable\n        var enabled = ele.pstyle(\"text-events\").strValue === \"yes\";\n        return enabled ? TEX_PICKING_MODE.USE_BB : TEX_PICKING_MODE.IGNORE;\n    };\n    var getBBForSimpleShape = function getBBForSimpleShape(node) {\n        // \"simple\" shapes need their BB to include border and padding\n        var _node$position = node.position(), x = _node$position.x, y = _node$position.y;\n        var w = node.outerWidth(); // includes border and padding\n        var h = node.outerHeight();\n        return {\n            w: w,\n            h: h,\n            x1: x - w / 2,\n            y1: y - h / 2\n        };\n    };\n    // An AtlasCollection is a collection of Atlases that have the same configuraiton options.\n    // Create one for node bodies and one for all types of labels.\n    r.drawing.addAtlasCollection(\"node\", {\n        texRows: opts.webglTexRowsNodes\n    });\n    r.drawing.addAtlasCollection(\"label\", {\n        texRows: opts.webglTexRows\n    });\n    // Configure the different types of elements that can be rendered.\n    // Node bodies can be rendered as textures or as \"simple shapes\". \n    // Simple shapes are preferred because they do not use texture memory.\n    // Textures are required if the node body uses complex styles. \n    r.drawing.addTextureAtlasRenderType(\"node-body\", {\n        collection: \"node\",\n        getKey: fns.getStyleKey,\n        getBoundingBox: fns.getElementBox,\n        drawElement: fns.drawElement\n    });\n    r.drawing.addSimpleShapeRenderType(\"node-body\", {\n        getBoundingBox: getBBForSimpleShape,\n        isSimple: isSimpleShape,\n        shapeProps: {\n            shape: \"shape\",\n            color: \"background-color\",\n            opacity: \"background-opacity\",\n            radius: \"corner-radius\",\n            border: true\n        }\n    });\n    r.drawing.addSimpleShapeRenderType(\"node-overlay\", {\n        getBoundingBox: getBBForSimpleShape,\n        isVisible: isLayerVisible(\"overlay\"),\n        shapeProps: {\n            shape: \"overlay-shape\",\n            color: \"overlay-color\",\n            opacity: \"overlay-opacity\",\n            padding: \"overlay-padding\",\n            radius: \"overlay-corner-radius\"\n        }\n    });\n    r.drawing.addSimpleShapeRenderType(\"node-underlay\", {\n        getBoundingBox: getBBForSimpleShape,\n        isVisible: isLayerVisible(\"underlay\"),\n        shapeProps: {\n            shape: \"underlay-shape\",\n            color: \"underlay-color\",\n            opacity: \"underlay-opacity\",\n            padding: \"underlay-padding\",\n            radius: \"underlay-corner-radius\"\n        }\n    });\n    r.drawing.addTextureAtlasRenderType(\"label\", {\n        // node label or edge mid label\n        collection: \"label\",\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getLabelKey, null),\n        getBoundingBox: getBoundingBoxForLabel(fns.getLabelBox, null),\n        drawClipped: true,\n        drawElement: fns.drawLabel,\n        getRotation: getLabelRotation(null),\n        getRotationPoint: fns.getLabelRotationPoint,\n        getRotationOffset: fns.getLabelRotationOffset,\n        isVisible: isLabelVisible(\"label\")\n    });\n    r.drawing.addTextureAtlasRenderType(\"edge-source-label\", {\n        collection: \"label\",\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getSourceLabelKey, \"source\"),\n        getBoundingBox: getBoundingBoxForLabel(fns.getSourceLabelBox, \"source\"),\n        drawClipped: true,\n        drawElement: fns.drawSourceLabel,\n        getRotation: getLabelRotation(\"source\"),\n        getRotationPoint: fns.getSourceLabelRotationPoint,\n        getRotationOffset: fns.getSourceLabelRotationOffset,\n        isVisible: isLabelVisible(\"source-label\")\n    });\n    r.drawing.addTextureAtlasRenderType(\"edge-target-label\", {\n        collection: \"label\",\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getTargetLabelKey, \"target\"),\n        getBoundingBox: getBoundingBoxForLabel(fns.getTargetLabelBox, \"target\"),\n        drawClipped: true,\n        drawElement: fns.drawTargetLabel,\n        getRotation: getLabelRotation(\"target\"),\n        getRotationPoint: fns.getTargetLabelRotationPoint,\n        getRotationOffset: fns.getTargetLabelRotationOffset,\n        isVisible: isLabelVisible(\"target-label\")\n    });\n    // Very simplistic way of triggering garbage collection, just use a timer.\n    var setGCFlag = debounce(function() {\n        console.log(\"garbage collect flag set\");\n        r.data.gc = true;\n    }, 10000);\n    // Event listener checks if style keys are no longer in use.\n    r.onUpdateEleCalcs(function(willDraw, eles) {\n        var gcNeeded = false;\n        if (eles && eles.length > 0) {\n            gcNeeded |= r.drawing.invalidate(eles);\n        }\n        if (gcNeeded) {\n            setGCFlag();\n        }\n    });\n    // \"Override\" certain functions in canvas and base renderer\n    overrideCanvasRendererFunctions(r);\n};\nfunction getBGColor(r) {\n    var container = r.cy.container();\n    var cssColor = container && container.style && container.style.backgroundColor || \"white\";\n    return color2tuple(cssColor);\n}\nfunction getLabelLines(ele, prefix) {\n    var rs = ele._private.rscratch;\n    return getPrefixedProperty(rs, \"labelWrapCachedLines\", prefix) || [];\n}\n/** \n * Handle multi-line labels by rendering each line as a seperate texture.\n * That means each line needs its own style key.\n */ var getStyleKeysForLabel = function getStyleKeysForLabel(getKey, prefix) {\n    return function(ele) {\n        var key = getKey(ele);\n        var lines = getLabelLines(ele, prefix);\n        if (lines.length > 1) {\n            return lines.map(function(line, index) {\n                return \"\".concat(key, \"_\").concat(index);\n            });\n        }\n        return key;\n    };\n};\n/**\n * Need to create a separate bounding box for each line of a multi-line label.\n * Note that 'drawClipped: true' should be used with this.\n */ var getBoundingBoxForLabel = function getBoundingBoxForLabel(getBoundingBox, prefix) {\n    return function(ele, styleKey) {\n        var bb = getBoundingBox(ele);\n        if (typeof styleKey === \"string\") {\n            var ui = styleKey.indexOf(\"_\");\n            if (ui > 0) {\n                var lineIndex = Number(styleKey.substring(ui + 1));\n                var lines = getLabelLines(ele, prefix);\n                // Adjust the height and Y coordinate for one line of the label.\n                var h = bb.h / lines.length;\n                var yOffset = h * lineIndex;\n                var y1 = bb.y1 + yOffset;\n                // the yOffset is needed when rotating the label\n                return {\n                    x1: bb.x1,\n                    w: bb.w,\n                    y1: y1,\n                    h: h,\n                    yOffset: yOffset\n                };\n            }\n        }\n        return bb;\n    };\n};\n/**\n * Plug into the canvas renderer by dynamically overriding some of its functions.\n * This requires minimal changes to the canvas rendrerer.\n */ function overrideCanvasRendererFunctions(r) {\n    {\n        // Override the render function to call the webgl render function if the zoom level is appropriate\n        var renderCanvas = r.render;\n        r.render = function(options) {\n            options = options || {};\n            var cy = r.cy;\n            if (r.webgl) {\n                // If the zoom level is greater than the max zoom level, then disable webgl and switch back to \n                // the canvas renderer.\n                if (cy.zoom() > maxZoom$1) {\n                    clearWebgl(r);\n                    renderCanvas.call(r, options);\n                } else {\n                    clearCanvas(r);\n                    renderWebgl(r, options, RENDER_TARGET.SCREEN);\n                }\n            }\n        };\n    }\n    {\n        // Override the matchCanvasSize function to update the picking frame buffer size\n        var baseFunc = r.matchCanvasSize;\n        r.matchCanvasSize = function(container) {\n            baseFunc.call(r, container);\n            r.pickingFrameBuffer.setFramebufferAttachmentSizes(r.canvasWidth, r.canvasHeight);\n            r.pickingFrameBuffer.needsDraw = true;\n        };\n    }\n    {\n        // Override function to call the webgl version for picking.\n        // Don't override r.getAllInBox() selction box picking, its not accurate enough with webgl\n        r.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n            // the canvas version of this function is very slow on large graphs\n            return findNearestElementsWebgl(r, x, y);\n        };\n    }\n    {\n        // need to know when the cached elements have changed so we can invalidate our caches\n        var _baseFunc = r.invalidateCachedZSortedEles;\n        r.invalidateCachedZSortedEles = function() {\n            _baseFunc.call(r);\n            r.pickingFrameBuffer.needsDraw = true;\n        };\n    }\n    {\n        // need to know when the cached elements have changed so we can invalidate our caches\n        var _baseFunc2 = r.notify;\n        r.notify = function(eventName, eles) {\n            _baseFunc2.call(r, eventName, eles);\n            if (eventName === \"viewport\" || eventName === \"bounds\") {\n                r.pickingFrameBuffer.needsDraw = true;\n            } else if (eventName === \"background\") {\n                // background image finished loading, need to redraw\n                r.drawing.invalidate(eles, {\n                    type: \"node-body\"\n                });\n            }\n        };\n    }\n}\nfunction clearWebgl(r) {\n    var gl = r.data.contexts[r.WEBGL];\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n}\nfunction clearCanvas(r) {\n    // the CRp.clearCanvas() function doesn't take the transform into account\n    var clear = function clear(context) {\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        context.restore();\n    };\n    clear(r.data.contexts[r.NODE]);\n    clear(r.data.contexts[r.DRAG]);\n}\nfunction createPanZoomMatrix(r) {\n    var width = r.canvasWidth;\n    var height = r.canvasHeight;\n    var _util$getEffectivePan = getEffectivePanZoom(r), pan = _util$getEffectivePan.pan, zoom = _util$getEffectivePan.zoom;\n    var transform = create();\n    translate(transform, transform, [\n        pan.x,\n        pan.y\n    ]);\n    scale(transform, transform, [\n        zoom,\n        zoom\n    ]);\n    var projection$1 = create();\n    projection(projection$1, width, height);\n    var product = create();\n    multiply(product, projection$1, transform);\n    return product;\n}\nfunction setContextTransform(r, context) {\n    var width = r.canvasWidth;\n    var height = r.canvasHeight;\n    var _util$getEffectivePan2 = getEffectivePanZoom(r), pan = _util$getEffectivePan2.pan, zoom = _util$getEffectivePan2.zoom;\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.clearRect(0, 0, width, height);\n    context.translate(pan.x, pan.y);\n    context.scale(zoom, zoom);\n}\nfunction drawSelectionRectangle(r, options) {\n    r.drawSelectionRectangle(options, function(context) {\n        return setContextTransform(r, context);\n    });\n}\nfunction drawAxes(r) {\n    // for debgging\n    var context = r.data.contexts[r.NODE];\n    context.save();\n    setContextTransform(r, context);\n    context.strokeStyle = \"rgba(0, 0, 0, 0.3)\";\n    context.beginPath();\n    context.moveTo(-1e3, 0);\n    context.lineTo(1000, 0);\n    context.stroke();\n    context.beginPath();\n    context.moveTo(0, -1e3);\n    context.lineTo(0, 1000);\n    context.stroke();\n    context.restore();\n}\nfunction drawAtlases(r) {\n    // For debugging the atlases, this doesn't work for Atlases that are locked\n    var draw = function draw(drawing, name, row) {\n        var collection = drawing.atlasManager.getAtlasCollection(name);\n        var context = r.data.contexts[r.NODE];\n        var atlases = collection.atlases;\n        for(var _i = 0; _i < atlases.length; _i++){\n            var atlas = atlases[_i];\n            var canvas = atlas.canvas;\n            if (canvas) {\n                var w = canvas.width;\n                var h = canvas.height;\n                var x = w * _i;\n                var y = canvas.height * row;\n                var scale = 0.4;\n                context.save();\n                context.scale(scale, scale);\n                context.drawImage(canvas, x, y);\n                context.strokeStyle = \"black\";\n                context.rect(x, y, w, h);\n                context.stroke();\n                context.restore();\n            }\n        }\n    };\n    var i = 0;\n    draw(r.drawing, \"node\", i++);\n    draw(r.drawing, \"label\", i++);\n}\n/**\n * Returns the z-order index of elments under or very close to the mouse cursor point.\n * Arguments are in model coordinates.\n * (x1, y1) is top left corner\n * (x2, y2) is bottom right corner (optional)\n * Returns a Set of indexes.\n */ function getPickingIndexes(r, mX1, mY1, mX2, mY2) {\n    var x, y, w, h;\n    var _util$getEffectivePan3 = getEffectivePanZoom(r), pan = _util$getEffectivePan3.pan, zoom = _util$getEffectivePan3.zoom;\n    {\n        var _util$modelToRendered = modelToRenderedPosition(r, pan, zoom, mX1, mY1), _util$modelToRendered2 = _slicedToArray(_util$modelToRendered, 2), cX1 = _util$modelToRendered2[0], cY1 = _util$modelToRendered2[1];\n        var t = 6; // should be even\n        x = cX1 - t / 2;\n        y = cY1 - t / 2;\n        w = t;\n        h = t;\n    }\n    if (w === 0 || h === 0) {\n        return [];\n    }\n    var gl = r.data.contexts[r.WEBGL];\n    gl.bindFramebuffer(gl.FRAMEBUFFER, r.pickingFrameBuffer);\n    if (r.pickingFrameBuffer.needsDraw) {\n        // Draw element z-indexes to the picking framebuffer\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        renderWebgl(r, null, RENDER_TARGET.PICKING);\n        r.pickingFrameBuffer.needsDraw = false;\n    }\n    var n = w * h; // number of pixels to read\n    var data = new Uint8Array(n * 4); // 4 bytes per pixel\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    var indexes = new Set();\n    for(var i = 0; i < n; i++){\n        var pixel = data.slice(i * 4, i * 4 + 4);\n        var index = vec4ToIndex(pixel) - 1; // The framebuffer is cleared with 0s, so z-indexes are offset by 1\n        if (index >= 0) {\n            indexes.add(index);\n        }\n    }\n    return indexes;\n}\n/**\n * Cy.js: model coordinate y axis goes down\n */ function findNearestElementsWebgl(r, x, y) {\n    // model coordinates\n    var indexes = getPickingIndexes(r, x, y);\n    var eles = r.getCachedZSortedEles();\n    var node, edge;\n    var _iterator = _createForOfIteratorHelper(indexes), _step;\n    try {\n        for(_iterator.s(); !(_step = _iterator.n()).done;){\n            var index = _step.value;\n            var ele = eles[index];\n            if (!node && ele.isNode()) {\n                node = ele;\n            }\n            if (!edge && ele.isEdge()) {\n                edge = ele;\n            }\n            if (node && edge) {\n                break;\n            }\n        }\n    } catch (err) {\n        _iterator.e(err);\n    } finally{\n        _iterator.f();\n    }\n    return [\n        node,\n        edge\n    ].filter(Boolean);\n}\n/**\n * Draw one node or edge. \n */ function drawEle(r, index, ele) {\n    var drawing = r.drawing;\n    index += 1; // 0 is used to clear the background, need to offset all z-indexes by one\n    if (ele.isNode()) {\n        drawing.drawNode(ele, index, \"node-underlay\");\n        drawing.drawNode(ele, index, \"node-body\");\n        drawing.drawTexture(ele, index, \"label\");\n        drawing.drawNode(ele, index, \"node-overlay\");\n    } else {\n        drawing.drawEdgeLine(ele, index);\n        drawing.drawEdgeArrow(ele, index, \"source\");\n        drawing.drawEdgeArrow(ele, index, \"target\");\n        drawing.drawTexture(ele, index, \"label\");\n        drawing.drawTexture(ele, index, \"edge-source-label\");\n        drawing.drawTexture(ele, index, \"edge-target-label\");\n    }\n}\n/**\n * Render one frame.\n */ function renderWebgl(r, options, renderTarget) {\n    var start;\n    if (r.webglDebug) {\n        start = performance.now(); // eslint-disable-line no-undef\n    }\n    var drawing = r.drawing;\n    var eleCount = 0;\n    if (renderTarget.screen) {\n        if (r.data.canvasNeedsRedraw[r.SELECT_BOX]) {\n            drawSelectionRectangle(r, options);\n        }\n    }\n    // see drawing-elements.js drawCachedElement()\n    if (r.data.canvasNeedsRedraw[r.NODE] || renderTarget.picking) {\n        var gl = r.data.contexts[r.WEBGL];\n        if (renderTarget.screen) {\n            gl.clearColor(0, 0, 0, 0); // background color\n            gl.enable(gl.BLEND); // enable alpha blending of colors\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // webgl colors use premultiplied alpha\n        } else {\n            gl.disable(gl.BLEND); // don't blend z-order index values! they are not colors\n        }\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        var panZoomMatrix = createPanZoomMatrix(r);\n        var eles = r.getCachedZSortedEles();\n        eleCount = eles.length;\n        drawing.startFrame(panZoomMatrix, renderTarget);\n        if (renderTarget.screen) {\n            for(var i = 0; i < eles.nondrag.length; i++){\n                drawEle(r, i, eles.nondrag[i]);\n            }\n            for(var _i2 = 0; _i2 < eles.drag.length; _i2++){\n                drawEle(r, _i2, eles.drag[_i2]);\n            }\n        } else if (renderTarget.picking) {\n            for(var _i3 = 0; _i3 < eles.length; _i3++){\n                drawEle(r, _i3, eles[_i3]);\n            }\n        }\n        drawing.endFrame();\n        if (renderTarget.screen && r.webglDebugShowAtlases) {\n            drawAxes(r);\n            drawAtlases(r);\n        }\n        r.data.canvasNeedsRedraw[r.NODE] = false;\n        r.data.canvasNeedsRedraw[r.DRAG] = false;\n    }\n    if (r.webglDebug) {\n        // eslint-disable-next-line no-undef\n        var end = performance.now();\n        var compact = false;\n        var time = Math.ceil(end - start);\n        var debugInfo = drawing.getDebugInfo();\n        var report = [\n            \"\".concat(eleCount, \" elements\"),\n            \"\".concat(debugInfo.totalInstances, \" instances\"),\n            \"\".concat(debugInfo.batchCount, \" batches\"),\n            \"\".concat(debugInfo.totalAtlases, \" atlases\"),\n            \"\".concat(debugInfo.wrappedCount, \" wrapped textures\"),\n            \"\".concat(debugInfo.simpleCount, \" simple shapes\")\n        ].join(\", \");\n        if (compact) {\n            console.log(\"WebGL (\".concat(renderTarget.name, \") - time \").concat(time, \"ms, \").concat(report));\n        } else {\n            console.log(\"WebGL (\".concat(renderTarget.name, \") - frame time \").concat(time, \"ms\"));\n            console.log(\"Totals:\");\n            console.log(\"  \".concat(report));\n            console.log(\"Texture Atlases Used:\");\n            var atlasInfo = debugInfo.atlasInfo;\n            var _iterator2 = _createForOfIteratorHelper(atlasInfo), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var info = _step2.value;\n                    console.log(\"  \".concat(info.type, \": \").concat(info.keyCount, \" keys, \").concat(info.atlasCount, \" atlases\"));\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            console.log(\"\");\n        }\n    }\n    if (r.data.gc) {\n        console.log(\"Garbage Collect!\");\n        r.data.gc = false;\n        drawing.gc();\n    }\n}\nvar CRp$3 = {};\n// @O Polygon drawing\nCRp$3.drawPolygonPath = function(context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n    for(var i = 1; i < points.length / 2; i++){\n        context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n    }\n    context.closePath();\n};\nCRp$3.drawRoundPolygonPath = function(context, x, y, width, height, points, corners) {\n    corners.forEach(function(corner) {\n        return drawPreparedRoundCorner(context, corner);\n    });\n    context.closePath();\n};\n// Round rectangle drawing\nCRp$3.drawRoundRectanglePath = function(context, x, y, width, height, radius) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = radius === \"auto\" ? getRoundRectangleRadius(width, height) : Math.min(radius, halfHeight, halfWidth);\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    // Arc from middle top to right side\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n    // Arc from right side to bottom\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    // Arc from bottom to left side\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    // Arc from left side to topBorder\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n    // Join line\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n};\nCRp$3.drawBottomRoundRectanglePath = function(context, x, y, width, height, radius) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = radius === \"auto\" ? getRoundRectangleRadius(width, height) : radius;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight);\n    context.lineTo(x + halfWidth, y);\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    context.lineTo(x - halfWidth, y - halfHeight);\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n};\nCRp$3.drawCutRectanglePath = function(context, x, y, width, height, points, corners) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerLength = corners === \"auto\" ? getCutRectangleCornerLength() : corners;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n    context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n    context.closePath();\n};\nCRp$3.drawBarrelPath = function(context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var xBegin = x - halfWidth;\n    var xEnd = x + halfWidth;\n    var yBegin = y - halfHeight;\n    var yEnd = y + halfHeight;\n    var barrelCurveConstants = getBarrelCurveConstants(width, height);\n    var wOffset = barrelCurveConstants.widthOffset;\n    var hOffset = barrelCurveConstants.heightOffset;\n    var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(xBegin, yBegin + hOffset);\n    context.lineTo(xBegin, yEnd - hOffset);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n    context.lineTo(xEnd - wOffset, yEnd);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n    context.lineTo(xEnd, yBegin + hOffset);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n    context.lineTo(xBegin + wOffset, yBegin);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n    context.closePath();\n};\nvar sin0 = Math.sin(0);\nvar cos0 = Math.cos(0);\nvar sin = {};\nvar cos = {};\nvar ellipseStepSize = Math.PI / 40;\nfor(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n}\nCRp$3.drawEllipsePath = function(context, centerX, centerY, width, height) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    if (context.ellipse) {\n        context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n    } else {\n        var xPos, yPos;\n        var rw = width / 2;\n        var rh = height / 2;\n        for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n            if (i === 0) {\n                context.moveTo(xPos, yPos);\n            } else {\n                context.lineTo(xPos, yPos);\n            }\n        }\n    }\n    context.closePath();\n};\n/* global atob, ArrayBuffer, Uint8Array, Blob */ var CRp$2 = {};\nCRp$2.createBuffer = function(w, h) {\n    var buffer = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n    buffer.width = w;\n    buffer.height = h;\n    return [\n        buffer,\n        buffer.getContext(\"2d\")\n    ];\n};\nCRp$2.bufferCanvasImage = function(options) {\n    var cy = this.cy;\n    var eles = cy.mutableElements();\n    var bb = eles.boundingBox();\n    var ctrRect = this.findContainerClientCoords();\n    var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n    var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n    var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n    var pxRatio = this.getPixelRatio();\n    var scale = 1;\n    if (options.scale !== undefined) {\n        width *= options.scale;\n        height *= options.scale;\n        scale = options.scale;\n    } else if (specdMaxDims) {\n        var maxScaleW = Infinity;\n        var maxScaleH = Infinity;\n        if (number$1(options.maxWidth)) {\n            maxScaleW = scale * options.maxWidth / width;\n        }\n        if (number$1(options.maxHeight)) {\n            maxScaleH = scale * options.maxHeight / height;\n        }\n        scale = Math.min(maxScaleW, maxScaleH);\n        width *= scale;\n        height *= scale;\n    }\n    if (!specdMaxDims) {\n        width *= pxRatio;\n        height *= pxRatio;\n        scale *= pxRatio;\n    }\n    var buffCanvas = document.createElement(\"canvas\"); // eslint-disable-line no-undef\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n    buffCanvas.style.width = width + \"px\";\n    buffCanvas.style.height = height + \"px\";\n    var buffCxt = buffCanvas.getContext(\"2d\");\n    // Rasterize the layers, but only if container has nonzero size\n    if (width > 0 && height > 0) {\n        buffCxt.clearRect(0, 0, width, height);\n        buffCxt.globalCompositeOperation = \"source-over\";\n        var zsortedEles = this.getCachedZSortedEles();\n        if (options.full) {\n            // draw the full bounds of the graph\n            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n            buffCxt.scale(scale, scale);\n            this.drawElements(buffCxt, zsortedEles);\n            buffCxt.scale(1 / scale, 1 / scale);\n            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n        } else {\n            // draw the current view\n            var pan = cy.pan();\n            var translation = {\n                x: pan.x * scale,\n                y: pan.y * scale\n            };\n            scale *= cy.zoom();\n            buffCxt.translate(translation.x, translation.y);\n            buffCxt.scale(scale, scale);\n            this.drawElements(buffCxt, zsortedEles);\n            buffCxt.scale(1 / scale, 1 / scale);\n            buffCxt.translate(-translation.x, -translation.y);\n        }\n        // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n        if (options.bg) {\n            buffCxt.globalCompositeOperation = \"destination-over\";\n            buffCxt.fillStyle = options.bg;\n            buffCxt.rect(0, 0, width, height);\n            buffCxt.fill();\n        }\n    }\n    return buffCanvas;\n};\nfunction b64ToBlob(b64, mimeType) {\n    var bytes = atob(b64);\n    var buff = new ArrayBuffer(bytes.length);\n    var buffUint8 = new Uint8Array(buff);\n    for(var i = 0; i < bytes.length; i++){\n        buffUint8[i] = bytes.charCodeAt(i);\n    }\n    return new Blob([\n        buff\n    ], {\n        type: mimeType\n    });\n}\nfunction b64UriToB64(b64uri) {\n    var i = b64uri.indexOf(\",\");\n    return b64uri.substr(i + 1);\n}\nfunction output(options, canvas, mimeType) {\n    var getB64Uri = function getB64Uri() {\n        return canvas.toDataURL(mimeType, options.quality);\n    };\n    switch(options.output){\n        case \"blob-promise\":\n            return new Promise$1(function(resolve, reject) {\n                try {\n                    canvas.toBlob(function(blob) {\n                        if (blob != null) {\n                            resolve(blob);\n                        } else {\n                            reject(new Error(\"`canvas.toBlob()` sent a null value in its callback\"));\n                        }\n                    }, mimeType, options.quality);\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        case \"blob\":\n            return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n        case \"base64\":\n            return b64UriToB64(getB64Uri());\n        case \"base64uri\":\n        default:\n            return getB64Uri();\n    }\n}\nCRp$2.png = function(options) {\n    return output(options, this.bufferCanvasImage(options), \"image/png\");\n};\nCRp$2.jpg = function(options) {\n    return output(options, this.bufferCanvasImage(options), \"image/jpeg\");\n};\nvar CRp$1 = {};\nCRp$1.nodeShapeImpl = function(name, context, centerX, centerY, width, height, points, corners) {\n    switch(name){\n        case \"ellipse\":\n            return this.drawEllipsePath(context, centerX, centerY, width, height);\n        case \"polygon\":\n            return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n        case \"round-polygon\":\n            return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points, corners);\n        case \"roundrectangle\":\n        case \"round-rectangle\":\n            return this.drawRoundRectanglePath(context, centerX, centerY, width, height, corners);\n        case \"cutrectangle\":\n        case \"cut-rectangle\":\n            return this.drawCutRectanglePath(context, centerX, centerY, width, height, points, corners);\n        case \"bottomroundrectangle\":\n        case \"bottom-round-rectangle\":\n            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height, corners);\n        case \"barrel\":\n            return this.drawBarrelPath(context, centerX, centerY, width, height);\n    }\n};\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\nCRp.CANVAS_LAYERS = 3;\n//\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\nCRp.WEBGL = 3;\nCRp.CANVAS_TYPES = [\n    \"2d\",\n    \"2d\",\n    \"2d\",\n    \"webgl2\"\n];\nCRp.BUFFER_COUNT = 3;\n//\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\nfunction CanvasRenderer(options) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var document1 = containerWindow.document;\n    if (options.webgl) {\n        CRp.CANVAS_LAYERS = r.CANVAS_LAYERS = 4;\n        console.log(\"webgl rendering enabled\");\n    }\n    r.data = {\n        canvases: new Array(CRp.CANVAS_LAYERS),\n        contexts: new Array(CRp.CANVAS_LAYERS),\n        canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n        bufferCanvases: new Array(CRp.BUFFER_COUNT),\n        bufferContexts: new Array(CRp.CANVAS_LAYERS)\n    };\n    var tapHlOffAttr = \"-webkit-tap-highlight-color\";\n    var tapHlOffStyle = \"rgba(0,0,0,0)\";\n    r.data.canvasContainer = document1.createElement(\"div\"); // eslint-disable-line no-undef\n    var containerStyle = r.data.canvasContainer.style;\n    r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n    containerStyle.position = \"relative\";\n    containerStyle.zIndex = \"0\";\n    containerStyle.overflow = \"hidden\";\n    var container = options.cy.container();\n    container.appendChild(r.data.canvasContainer);\n    container.style[tapHlOffAttr] = tapHlOffStyle;\n    var styleMap = {\n        \"-webkit-user-select\": \"none\",\n        \"-moz-user-select\": \"-moz-none\",\n        \"user-select\": \"none\",\n        \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n        \"outline-style\": \"none\"\n    };\n    if (ms()) {\n        styleMap[\"-ms-touch-action\"] = \"none\";\n        styleMap[\"touch-action\"] = \"none\";\n    }\n    for(var i = 0; i < CRp.CANVAS_LAYERS; i++){\n        var canvas = r.data.canvases[i] = document1.createElement(\"canvas\"); // eslint-disable-line no-undef\n        var type = CRp.CANVAS_TYPES[i];\n        r.data.contexts[i] = canvas.getContext(type);\n        if (!r.data.contexts[i]) {\n            error(\"Could not create canvas of type \" + type);\n        }\n        Object.keys(styleMap).forEach(function(k) {\n            canvas.style[k] = styleMap[k];\n        });\n        canvas.style.position = \"absolute\";\n        canvas.setAttribute(\"data-id\", \"layer\" + i);\n        canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n        r.data.canvasContainer.appendChild(canvas);\n        r.data.canvasNeedsRedraw[i] = false;\n    }\n    r.data.topCanvas = r.data.canvases[0];\n    r.data.canvases[CRp.NODE].setAttribute(\"data-id\", \"layer\" + CRp.NODE + \"-node\");\n    r.data.canvases[CRp.SELECT_BOX].setAttribute(\"data-id\", \"layer\" + CRp.SELECT_BOX + \"-selectbox\");\n    r.data.canvases[CRp.DRAG].setAttribute(\"data-id\", \"layer\" + CRp.DRAG + \"-drag\");\n    if (r.data.canvases[CRp.WEBGL]) {\n        r.data.canvases[CRp.WEBGL].setAttribute(\"data-id\", \"layer\" + CRp.WEBGL + \"-webgl\");\n    }\n    for(var i = 0; i < CRp.BUFFER_COUNT; i++){\n        r.data.bufferCanvases[i] = document1.createElement(\"canvas\"); // eslint-disable-line no-undef\n        r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext(\"2d\");\n        r.data.bufferCanvases[i].style.position = \"absolute\";\n        r.data.bufferCanvases[i].setAttribute(\"data-id\", \"buffer\" + i);\n        r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n        r.data.bufferCanvases[i].style.visibility = \"hidden\";\n    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n    }\n    r.pathsEnabled = true;\n    var emptyBb = makeBoundingBox();\n    var getBoxCenter = function getBoxCenter(bb) {\n        return {\n            x: (bb.x1 + bb.x2) / 2,\n            y: (bb.y1 + bb.y2) / 2\n        };\n    };\n    var getCenterOffset = function getCenterOffset(bb) {\n        return {\n            x: -bb.w / 2,\n            y: -bb.h / 2\n        };\n    };\n    var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n        var _p = ele[0]._private;\n        var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n        return !same;\n    };\n    var getStyleKey = function getStyleKey(ele) {\n        return ele[0]._private.nodeKey;\n    };\n    var getLabelKey = function getLabelKey(ele) {\n        return ele[0]._private.labelStyleKey;\n    };\n    var getSourceLabelKey = function getSourceLabelKey(ele) {\n        return ele[0]._private.sourceLabelStyleKey;\n    };\n    var getTargetLabelKey = function getTargetLabelKey(ele) {\n        return ele[0]._private.targetLabelStyleKey;\n    };\n    var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n    };\n    var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, \"main\", useEleOpacity);\n    };\n    var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, \"source\", useEleOpacity);\n    };\n    var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, \"target\", useEleOpacity);\n    };\n    var getElementBox = function getElementBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.bodyBounds;\n    };\n    var getLabelBox = function getLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.main || emptyBb;\n    };\n    var getSourceLabelBox = function getSourceLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.source || emptyBb;\n    };\n    var getTargetLabelBox = function getTargetLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.target || emptyBb;\n    };\n    var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n        return scaledLabelShown;\n    };\n    var getElementRotationPoint = function getElementRotationPoint(ele) {\n        return getBoxCenter(getElementBox(ele));\n    };\n    var addTextMargin = function addTextMargin(prefix, pt, ele) {\n        var pre = prefix ? prefix + \"-\" : \"\";\n        return {\n            x: pt.x + ele.pstyle(pre + \"text-margin-x\").pfValue,\n            y: pt.y + ele.pstyle(pre + \"text-margin-y\").pfValue\n        };\n    };\n    var getRsPt = function getRsPt(ele, x, y) {\n        var rs = ele[0]._private.rscratch;\n        return {\n            x: rs[x],\n            y: rs[y]\n        };\n    };\n    var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n        return addTextMargin(\"\", getRsPt(ele, \"labelX\", \"labelY\"), ele);\n    };\n    var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n        return addTextMargin(\"source\", getRsPt(ele, \"sourceLabelX\", \"sourceLabelY\"), ele);\n    };\n    var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n        return addTextMargin(\"target\", getRsPt(ele, \"targetLabelX\", \"targetLabelY\"), ele);\n    };\n    var getElementRotationOffset = function getElementRotationOffset(ele) {\n        return getCenterOffset(getElementBox(ele));\n    };\n    var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n        return getCenterOffset(getSourceLabelBox(ele));\n    };\n    var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n        return getCenterOffset(getTargetLabelBox(ele));\n    };\n    var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n        var bb = getLabelBox(ele);\n        var p = getCenterOffset(getLabelBox(ele));\n        if (ele.isNode()) {\n            switch(ele.pstyle(\"text-halign\").value){\n                case \"left\":\n                    p.x = -bb.w - (bb.leftPad || 0);\n                    break;\n                case \"right\":\n                    p.x = -(bb.rightPad || 0);\n                    break;\n            }\n            switch(ele.pstyle(\"text-valign\").value){\n                case \"top\":\n                    p.y = -bb.h - (bb.topPad || 0);\n                    break;\n                case \"bottom\":\n                    p.y = -(bb.botPad || 0);\n                    break;\n            }\n        }\n        return p;\n    };\n    var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n        getKey: getStyleKey,\n        doesEleInvalidateKey: backgroundTimestampHasChanged,\n        drawElement: drawElement,\n        getBoundingBox: getElementBox,\n        getRotationPoint: getElementRotationPoint,\n        getRotationOffset: getElementRotationOffset,\n        allowEdgeTxrCaching: false,\n        allowParentTxrCaching: false\n    });\n    var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n        getKey: getLabelKey,\n        drawElement: drawLabel,\n        getBoundingBox: getLabelBox,\n        getRotationPoint: getLabelRotationPoint,\n        getRotationOffset: getLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n        getKey: getSourceLabelKey,\n        drawElement: drawSourceLabel,\n        getBoundingBox: getSourceLabelBox,\n        getRotationPoint: getSourceLabelRotationPoint,\n        getRotationOffset: getSourceLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n        getKey: getTargetLabelKey,\n        drawElement: drawTargetLabel,\n        getBoundingBox: getTargetLabelBox,\n        getRotationPoint: getTargetLabelRotationPoint,\n        getRotationOffset: getTargetLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n    r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n        // each cache should check for sub-key diff to see that the update affects that cache particularly\n        eleTxrCache.invalidateElements(eles);\n        lblTxrCache.invalidateElements(eles);\n        slbTxrCache.invalidateElements(eles);\n        tlbTxrCache.invalidateElements(eles);\n        // any change invalidates the layers\n        lyrTxrCache.invalidateElements(eles);\n        // update the old bg timestamp so diffs can be done in the ele txr caches\n        for(var _i = 0; _i < eles.length; _i++){\n            var _p = eles[_i]._private;\n            _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n        }\n    });\n    var refineInLayers = function refineInLayers(reqs) {\n        for(var i = 0; i < reqs.length; i++){\n            lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n        }\n    };\n    eleTxrCache.onDequeue(refineInLayers);\n    lblTxrCache.onDequeue(refineInLayers);\n    slbTxrCache.onDequeue(refineInLayers);\n    tlbTxrCache.onDequeue(refineInLayers);\n    if (options.webgl) {\n        r.initWebgl(options, {\n            getStyleKey: getStyleKey,\n            getLabelKey: getLabelKey,\n            getSourceLabelKey: getSourceLabelKey,\n            getTargetLabelKey: getTargetLabelKey,\n            drawElement: drawElement,\n            drawLabel: drawLabel,\n            drawSourceLabel: drawSourceLabel,\n            drawTargetLabel: drawTargetLabel,\n            getElementBox: getElementBox,\n            getLabelBox: getLabelBox,\n            getSourceLabelBox: getSourceLabelBox,\n            getTargetLabelBox: getTargetLabelBox,\n            getElementRotationPoint: getElementRotationPoint,\n            getElementRotationOffset: getElementRotationOffset,\n            getLabelRotationPoint: getLabelRotationPoint,\n            getSourceLabelRotationPoint: getSourceLabelRotationPoint,\n            getTargetLabelRotationPoint: getTargetLabelRotationPoint,\n            getLabelRotationOffset: getLabelRotationOffset,\n            getSourceLabelRotationOffset: getSourceLabelRotationOffset,\n            getTargetLabelRotationOffset: getTargetLabelRotationOffset\n        });\n    }\n}\nCRp.redrawHint = function(group, bool) {\n    var r = this;\n    switch(group){\n        case \"eles\":\n            r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n            break;\n        case \"drag\":\n            r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n            break;\n        case \"select\":\n            r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n            break;\n        case \"gc\":\n            r.data.gc = true;\n            break;\n    }\n};\n// whether to use Path2D caching for drawing\nvar pathsImpld = typeof Path2D !== \"undefined\";\nCRp.path2dEnabled = function(on) {\n    if (on === undefined) {\n        return this.pathsEnabled;\n    }\n    this.pathsEnabled = on ? true : false;\n};\nCRp.usePaths = function() {\n    return pathsImpld && this.pathsEnabled;\n};\nCRp.setImgSmoothing = function(context, bool) {\n    if (context.imageSmoothingEnabled != null) {\n        context.imageSmoothingEnabled = bool;\n    } else {\n        context.webkitImageSmoothingEnabled = bool;\n        context.mozImageSmoothingEnabled = bool;\n        context.msImageSmoothingEnabled = bool;\n    }\n};\nCRp.getImgSmoothing = function(context) {\n    if (context.imageSmoothingEnabled != null) {\n        return context.imageSmoothingEnabled;\n    } else {\n        return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n    }\n};\nCRp.makeOffscreenCanvas = function(width, height) {\n    var canvas;\n    if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== \"undefined\") {\n        canvas = new OffscreenCanvas(width, height);\n    } else {\n        var containerWindow = this.cy.window();\n        var document1 = containerWindow.document;\n        canvas = document1.createElement(\"canvas\"); // eslint-disable-line no-undef\n        canvas.width = width;\n        canvas.height = height;\n    }\n    return canvas;\n};\n[\n    CRp$b,\n    CRp$a,\n    CRp$9,\n    CRp$8,\n    CRp$7,\n    CRp$6,\n    CRp$5,\n    CRp$4,\n    CRp$3,\n    CRp$2,\n    CRp$1\n].forEach(function(props) {\n    extend(CRp, props);\n});\nvar renderer = [\n    {\n        name: \"null\",\n        impl: NullRenderer\n    },\n    {\n        name: \"base\",\n        impl: BR\n    },\n    {\n        name: \"canvas\",\n        impl: CR\n    }\n];\nvar incExts = [\n    {\n        type: \"layout\",\n        extensions: layout\n    },\n    {\n        type: \"renderer\",\n        extensions: renderer\n    }\n];\n// registered extensions to cytoscape, indexed by name\nvar extensions = {};\n// registered modules for extensions, indexed by name\nvar modules = {};\nfunction setExtension(type, name, registrant) {\n    var ext = registrant;\n    var overrideErr = function overrideErr(field) {\n        warn(\"Can not register `\" + name + \"` for `\" + type + \"` since `\" + field + \"` already exists in the prototype and can not be overridden\");\n    };\n    if (type === \"core\") {\n        if (Core.prototype[name]) {\n            return overrideErr(name);\n        } else {\n            Core.prototype[name] = registrant;\n        }\n    } else if (type === \"collection\") {\n        if (Collection.prototype[name]) {\n            return overrideErr(name);\n        } else {\n            Collection.prototype[name] = registrant;\n        }\n    } else if (type === \"layout\") {\n        // fill in missing layout functions in the prototype\n        var Layout = function Layout(options) {\n            this.options = options;\n            registrant.call(this, options);\n            // make sure layout has _private for use w/ std apis like .on()\n            if (!plainObject(this._private)) {\n                this._private = {};\n            }\n            this._private.cy = options.cy;\n            this._private.listeners = [];\n            this.createEmitter();\n        };\n        var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n        var optLayoutFns = [];\n        for(var i = 0; i < optLayoutFns.length; i++){\n            var fnName = optLayoutFns[i];\n            layoutProto[fnName] = layoutProto[fnName] || function() {\n                return this;\n            };\n        }\n        // either .start() or .run() is defined, so autogen the other\n        if (layoutProto.start && !layoutProto.run) {\n            layoutProto.run = function() {\n                this.start();\n                return this;\n            };\n        } else if (!layoutProto.start && layoutProto.run) {\n            layoutProto.start = function() {\n                this.run();\n                return this;\n            };\n        }\n        var regStop = registrant.prototype.stop;\n        layoutProto.stop = function() {\n            var opts = this.options;\n            if (opts && opts.animate) {\n                var anis = this.animations;\n                if (anis) {\n                    for(var _i = 0; _i < anis.length; _i++){\n                        anis[_i].stop();\n                    }\n                }\n            }\n            if (regStop) {\n                regStop.call(this);\n            } else {\n                this.emit(\"layoutstop\");\n            }\n            return this;\n        };\n        if (!layoutProto.destroy) {\n            layoutProto.destroy = function() {\n                return this;\n            };\n        }\n        layoutProto.cy = function() {\n            return this._private.cy;\n        };\n        var getCy = function getCy(layout) {\n            return layout._private.cy;\n        };\n        var emitterOpts = {\n            addEventFields: function addEventFields(layout, evt) {\n                evt.layout = layout;\n                evt.cy = getCy(layout);\n                evt.target = layout;\n            },\n            bubble: function bubble() {\n                return true;\n            },\n            parent: function parent(layout) {\n                return getCy(layout);\n            }\n        };\n        extend(layoutProto, {\n            createEmitter: function createEmitter() {\n                this._private.emitter = new Emitter(emitterOpts, this);\n                return this;\n            },\n            emitter: function emitter() {\n                return this._private.emitter;\n            },\n            on: function on(evt, cb) {\n                this.emitter().on(evt, cb);\n                return this;\n            },\n            one: function one(evt, cb) {\n                this.emitter().one(evt, cb);\n                return this;\n            },\n            once: function once(evt, cb) {\n                this.emitter().one(evt, cb);\n                return this;\n            },\n            removeListener: function removeListener(evt, cb) {\n                this.emitter().removeListener(evt, cb);\n                return this;\n            },\n            removeAllListeners: function removeAllListeners() {\n                this.emitter().removeAllListeners();\n                return this;\n            },\n            emit: function emit(evt, params) {\n                this.emitter().emit(evt, params);\n                return this;\n            }\n        });\n        define.eventAliasesOn(layoutProto);\n        ext = Layout; // replace with our wrapped layout\n    } else if (type === \"renderer\" && name !== \"null\" && name !== \"base\") {\n        // user registered renderers inherit from base\n        var BaseRenderer = getExtension(\"renderer\", \"base\");\n        var bProto = BaseRenderer.prototype;\n        var RegistrantRenderer = registrant;\n        var rProto = registrant.prototype;\n        var Renderer = function Renderer() {\n            BaseRenderer.apply(this, arguments);\n            RegistrantRenderer.apply(this, arguments);\n        };\n        var proto = Renderer.prototype;\n        for(var pName in bProto){\n            var pVal = bProto[pName];\n            var existsInR = rProto[pName] != null;\n            if (existsInR) {\n                return overrideErr(pName);\n            }\n            proto[pName] = pVal; // take impl from base\n        }\n        for(var _pName in rProto){\n            proto[_pName] = rProto[_pName]; // take impl from registrant\n        }\n        bProto.clientFunctions.forEach(function(name) {\n            proto[name] = proto[name] || function() {\n                error(\"Renderer does not implement `renderer.\" + name + \"()` on its prototype\");\n            };\n        });\n        ext = Renderer;\n    } else if (type === \"__proto__\" || type === \"constructor\" || type === \"prototype\") {\n        // to avoid potential prototype pollution\n        return error(type + \" is an illegal type to be registered, possibly lead to prototype pollutions\");\n    }\n    return setMap({\n        map: extensions,\n        keys: [\n            type,\n            name\n        ],\n        value: ext\n    });\n}\nfunction getExtension(type, name) {\n    return getMap({\n        map: extensions,\n        keys: [\n            type,\n            name\n        ]\n    });\n}\nfunction setModule(type, name, moduleType, moduleName, registrant) {\n    return setMap({\n        map: modules,\n        keys: [\n            type,\n            name,\n            moduleType,\n            moduleName\n        ],\n        value: registrant\n    });\n}\nfunction getModule(type, name, moduleType, moduleName) {\n    return getMap({\n        map: modules,\n        keys: [\n            type,\n            name,\n            moduleType,\n            moduleName\n        ]\n    });\n}\nvar extension = function extension() {\n    // e.g. extension('renderer', 'svg')\n    if (arguments.length === 2) {\n        return getExtension.apply(null, arguments);\n    } else if (arguments.length === 3) {\n        return setExtension.apply(null, arguments);\n    } else if (arguments.length === 4) {\n        return getModule.apply(null, arguments);\n    } else if (arguments.length === 5) {\n        return setModule.apply(null, arguments);\n    } else {\n        error(\"Invalid extension access syntax\");\n    }\n};\n// allows a core instance to access extensions internally\nCore.prototype.extension = extension;\n// included extensions\nincExts.forEach(function(group) {\n    group.extensions.forEach(function(ext) {\n        setExtension(group.type, ext.name, ext.impl);\n    });\n});\n// a dummy stylesheet object that doesn't need a reference to the core\n// (useful for init)\nvar _Stylesheet = function Stylesheet() {\n    if (!(this instanceof _Stylesheet)) {\n        return new _Stylesheet();\n    }\n    this.length = 0;\n};\nvar sheetfn = _Stylesheet.prototype;\nsheetfn.instanceString = function() {\n    return \"stylesheet\";\n};\n// just store the selector to be parsed later\nsheetfn.selector = function(selector) {\n    var i = this.length++;\n    this[i] = {\n        selector: selector,\n        properties: []\n    };\n    return this; // chaining\n};\n// just store the property to be parsed later\nsheetfn.css = function(name, value) {\n    var i = this.length - 1;\n    if (string(name)) {\n        this[i].properties.push({\n            name: name,\n            value: value\n        });\n    } else if (plainObject(name)) {\n        var map = name;\n        var propNames = Object.keys(map);\n        for(var j = 0; j < propNames.length; j++){\n            var key = propNames[j];\n            var mapVal = map[key];\n            if (mapVal == null) {\n                continue;\n            }\n            var prop = _Style.properties[key] || _Style.properties[dash2camel(key)];\n            if (prop == null) {\n                continue;\n            }\n            var _name = prop.name;\n            var _value = mapVal;\n            this[i].properties.push({\n                name: _name,\n                value: _value\n            });\n        }\n    }\n    return this; // chaining\n};\nsheetfn.style = sheetfn.css;\n// generate a real style object from the dummy stylesheet\nsheetfn.generateStyle = function(cy) {\n    var style = new _Style(cy);\n    return this.appendToStyle(style);\n};\n// append a dummy stylesheet object on a real style object\nsheetfn.appendToStyle = function(style) {\n    for(var i = 0; i < this.length; i++){\n        var context = this[i];\n        var selector = context.selector;\n        var props = context.properties;\n        style.selector(selector); // apply selector\n        for(var j = 0; j < props.length; j++){\n            var prop = props[j];\n            style.css(prop.name, prop.value); // apply property\n        }\n    }\n    return style;\n};\nvar version = \"3.33.1\";\nvar cytoscape = function cytoscape(options) {\n    // if no options specified, use default\n    if (options === undefined) {\n        options = {};\n    }\n    // create instance\n    if (plainObject(options)) {\n        return new Core(options);\n    } else if (string(options)) {\n        return extension.apply(extension, arguments);\n    }\n};\n// e.g. cytoscape.use( require('cytoscape-foo'), bar )\ncytoscape.use = function(ext) {\n    var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n    args.unshift(cytoscape); // cytoscape is first arg to ext\n    ext.apply(null, args);\n    return this;\n};\ncytoscape.warnings = function(bool) {\n    return warnings(bool);\n};\n// replaced by build system\ncytoscape.version = version;\n// expose public apis (mostly for extensions)\ncytoscape.stylesheet = cytoscape.Stylesheet = _Stylesheet;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUVELFNBQVNBLGtCQUFrQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCLFNBQVFBLEtBQUtBLElBQUlELEVBQUVFLE1BQU0sS0FBTUQsQ0FBQUEsSUFBSUQsRUFBRUUsTUFBTTtJQUM1QyxJQUFLLElBQUlDLElBQUksR0FBR0MsSUFBSUMsTUFBTUosSUFBSUUsSUFBSUYsR0FBR0UsSUFBS0MsQ0FBQyxDQUFDRCxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNyRCxPQUFPQztBQUNUO0FBQ0EsU0FBU0UsZ0JBQWdCTixDQUFDO0lBQ3hCLElBQUlLLE1BQU1FLE9BQU8sQ0FBQ1AsSUFBSSxPQUFPQTtBQUMvQjtBQUNBLFNBQVNRLG1CQUFtQlIsQ0FBQztJQUMzQixJQUFJSyxNQUFNRSxPQUFPLENBQUNQLElBQUksT0FBT0Qsa0JBQWtCQztBQUNqRDtBQUNBLFNBQVNTLGdCQUFnQlIsQ0FBQyxFQUFFRyxDQUFDO0lBQzNCLElBQUksQ0FBRUgsQ0FBQUEsYUFBYUcsQ0FBQUEsR0FBSSxNQUFNLElBQUlNLFVBQVU7QUFDN0M7QUFDQSxTQUFTQyxrQkFBa0JSLENBQUMsRUFBRUgsQ0FBQztJQUM3QixJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSVosRUFBRUUsTUFBTSxFQUFFVSxJQUFLO1FBQ2pDLElBQUlDLElBQUliLENBQUMsQ0FBQ1ksRUFBRTtRQUNaQyxFQUFFQyxVQUFVLEdBQUdELEVBQUVDLFVBQVUsSUFBSSxPQUFPRCxFQUFFRSxZQUFZLEdBQUcsTUFBTSxXQUFXRixLQUFNQSxDQUFBQSxFQUFFRyxRQUFRLEdBQUcsSUFBRyxHQUFJQyxPQUFPQyxjQUFjLENBQUNmLEdBQUdnQixlQUFlTixFQUFFTyxHQUFHLEdBQUdQO0lBQ3BKO0FBQ0Y7QUFDQSxTQUFTUSxhQUFhbEIsQ0FBQyxFQUFFSCxDQUFDLEVBQUVZLENBQUM7SUFDM0IsT0FBT1osS0FBS1csa0JBQWtCUixFQUFFbUIsU0FBUyxFQUFFdEIsSUFBSWlCLE9BQU9DLGNBQWMsQ0FBQ2YsR0FBRyxhQUFhO1FBQ25GYSxVQUFVO0lBQ1osSUFBSWI7QUFDTjtBQUNBLFNBQVNvQiwyQkFBMkJ2QixDQUFDLEVBQUVHLENBQUM7SUFDdEMsSUFBSVMsSUFBSSxlQUFlLE9BQU9ZLFVBQVV4QixDQUFDLENBQUN3QixPQUFPQyxRQUFRLENBQUMsSUFBSXpCLENBQUMsQ0FBQyxhQUFhO0lBQzdFLElBQUksQ0FBQ1ksR0FBRztRQUNOLElBQUlQLE1BQU1FLE9BQU8sQ0FBQ1AsTUFBT1ksQ0FBQUEsSUFBSWMsNEJBQTRCMUIsRUFBQyxLQUFNRyxHQUFHO1lBQ2pFUyxLQUFNWixDQUFBQSxJQUFJWSxDQUFBQTtZQUNWLElBQUlSLElBQUksR0FDTnVCLElBQUksWUFBYTtZQUNuQixPQUFPO2dCQUNMQyxHQUFHRDtnQkFDSHZCLEdBQUc7b0JBQ0QsT0FBT0EsS0FBS0osRUFBRUUsTUFBTSxHQUFHO3dCQUNyQjJCLE1BQU07b0JBQ1IsSUFBSTt3QkFDRkEsTUFBTTt3QkFDTkMsT0FBTzlCLENBQUMsQ0FBQ0ksSUFBSTtvQkFDZjtnQkFDRjtnQkFDQUQsR0FBRyxTQUFVSCxDQUFDO29CQUNaLE1BQU1BO2dCQUNSO2dCQUNBK0IsR0FBR0o7WUFDTDtRQUNGO1FBQ0EsTUFBTSxJQUFJakIsVUFBVTtJQUN0QjtJQUNBLElBQUlHLEdBQ0ZaLElBQUksTUFDSitCLElBQUk7SUFDTixPQUFPO1FBQ0xKLEdBQUc7WUFDRGhCLElBQUlBLEVBQUVxQixJQUFJLENBQUNqQztRQUNiO1FBQ0FJLEdBQUc7WUFDRCxJQUFJSixJQUFJWSxFQUFFc0IsSUFBSTtZQUNkLE9BQU9qQyxJQUFJRCxFQUFFNkIsSUFBSSxFQUFFN0I7UUFDckI7UUFDQUcsR0FBRyxTQUFVSCxDQUFDO1lBQ1pnQyxJQUFJLE1BQU1uQixJQUFJYjtRQUNoQjtRQUNBK0IsR0FBRztZQUNELElBQUk7Z0JBQ0Y5QixLQUFLLFFBQVFXLEVBQUV1QixNQUFNLElBQUl2QixFQUFFdUIsTUFBTTtZQUNuQyxTQUFVO2dCQUNSLElBQUlILEdBQUcsTUFBTW5CO1lBQ2Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTdUIsa0JBQWtCakMsQ0FBQyxFQUFFSCxDQUFDLEVBQUVZLENBQUM7SUFDaEMsT0FBTyxDQUFDWixJQUFJbUIsZUFBZW5CLEVBQUMsS0FBTUcsSUFBSWMsT0FBT0MsY0FBYyxDQUFDZixHQUFHSCxHQUFHO1FBQ2hFOEIsT0FBT2xCO1FBQ1BFLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxVQUFVO0lBQ1osS0FBS2IsQ0FBQyxDQUFDSCxFQUFFLEdBQUdZLEdBQUdUO0FBQ2pCO0FBQ0EsU0FBU2tDLGlCQUFpQnJDLENBQUM7SUFDekIsSUFBSSxlQUFlLE9BQU93QixVQUFVLFFBQVF4QixDQUFDLENBQUN3QixPQUFPQyxRQUFRLENBQUMsSUFBSSxRQUFRekIsQ0FBQyxDQUFDLGFBQWEsRUFBRSxPQUFPSyxNQUFNaUMsSUFBSSxDQUFDdEM7QUFDL0c7QUFDQSxTQUFTdUMsc0JBQXNCdkMsQ0FBQyxFQUFFd0MsQ0FBQztJQUNqQyxJQUFJNUIsSUFBSSxRQUFRWixJQUFJLE9BQU8sZUFBZSxPQUFPd0IsVUFBVXhCLENBQUMsQ0FBQ3dCLE9BQU9DLFFBQVEsQ0FBQyxJQUFJekIsQ0FBQyxDQUFDLGFBQWE7SUFDaEcsSUFBSSxRQUFRWSxHQUFHO1FBQ2IsSUFBSVQsR0FDRkMsR0FDQXFDLEdBQ0FULEdBQ0EvQixJQUFJLEVBQUUsRUFDTjhCLElBQUksTUFDSmxCLElBQUk7UUFDTixJQUFJO1lBQ0YsSUFBSTRCLElBQUksQ0FBQzdCLElBQUlBLEVBQUVxQixJQUFJLENBQUNqQyxFQUFDLEVBQUdrQyxJQUFJLEVBQUUsTUFBTU0sR0FBRztnQkFDckMsSUFBSXZCLE9BQU9MLE9BQU9BLEdBQUc7Z0JBQ3JCbUIsSUFBSSxDQUFDO1lBQ1AsT0FBTyxNQUFPLENBQUVBLENBQUFBLElBQUksQ0FBQzVCLElBQUlzQyxFQUFFUixJQUFJLENBQUNyQixFQUFDLEVBQUdpQixJQUFJLEtBQU01QixDQUFBQSxFQUFFeUMsSUFBSSxDQUFDdkMsRUFBRTJCLEtBQUssR0FBRzdCLEVBQUVDLE1BQU0sS0FBS3NDLENBQUFBLEdBQUlULElBQUksQ0FBQztRQUN2RixFQUFFLE9BQU8vQixHQUFHO1lBQ1ZhLElBQUksTUFBTVQsSUFBSUo7UUFDaEIsU0FBVTtZQUNSLElBQUk7Z0JBQ0YsSUFBSSxDQUFDK0IsS0FBSyxRQUFRbkIsRUFBRXVCLE1BQU0sSUFBS0gsQ0FBQUEsSUFBSXBCLEVBQUV1QixNQUFNLElBQUlsQixPQUFPZSxPQUFPQSxDQUFBQSxHQUFJO1lBQ25FLFNBQVU7Z0JBQ1IsSUFBSW5CLEdBQUcsTUFBTVQ7WUFDZjtRQUNGO1FBQ0EsT0FBT0g7SUFDVDtBQUNGO0FBQ0EsU0FBUzBDO0lBQ1AsTUFBTSxJQUFJakMsVUFBVTtBQUN0QjtBQUNBLFNBQVNrQztJQUNQLE1BQU0sSUFBSWxDLFVBQVU7QUFDdEI7QUFDQSxTQUFTbUMsZUFBZTdDLENBQUMsRUFBRUcsQ0FBQztJQUMxQixPQUFPRyxnQkFBZ0JOLE1BQU11QyxzQkFBc0J2QyxHQUFHRyxNQUFNdUIsNEJBQTRCMUIsR0FBR0csTUFBTXdDO0FBQ25HO0FBQ0EsU0FBU0csbUJBQW1COUMsQ0FBQztJQUMzQixPQUFPUSxtQkFBbUJSLE1BQU1xQyxpQkFBaUJyQyxNQUFNMEIsNEJBQTRCMUIsTUFBTTRDO0FBQzNGO0FBQ0EsU0FBU0csYUFBYW5DLENBQUMsRUFBRVosQ0FBQztJQUN4QixJQUFJLFlBQVksT0FBT1ksS0FBSyxDQUFDQSxHQUFHLE9BQU9BO0lBQ3ZDLElBQUlULElBQUlTLENBQUMsQ0FBQ1ksT0FBT3dCLFdBQVcsQ0FBQztJQUM3QixJQUFJQyxjQUFjOUMsR0FBRztRQUNuQixJQUFJc0MsSUFBSXRDLEVBQUU4QixJQUFJLENBQUNyQixHQUFHWjtRQUNsQixJQUFJLFlBQVksT0FBT3lDLEdBQUcsT0FBT0E7UUFDakMsTUFBTSxJQUFJL0IsVUFBVTtJQUN0QjtJQUNBLE9BQU8sT0FBVUU7QUFDbkI7QUFDQSxTQUFTTyxlQUFlUCxDQUFDO0lBQ3ZCLElBQUk2QixJQUFJTSxhQUFhbkMsR0FBRztJQUN4QixPQUFPLFlBQVksT0FBTzZCLElBQUlBLElBQUlBLElBQUk7QUFDeEM7QUFDQSxTQUFTVSxRQUFRdEMsQ0FBQztJQUNoQjtJQUVBLE9BQU9zQyxVQUFVLGNBQWMsT0FBTzNCLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVVosQ0FBQztRQUM5RixPQUFPLE9BQU9BO0lBQ2hCLElBQUksU0FBVUEsQ0FBQztRQUNiLE9BQU9BLEtBQUssY0FBYyxPQUFPVyxVQUFVWCxFQUFFdUMsV0FBVyxLQUFLNUIsVUFBVVgsTUFBTVcsT0FBT0YsU0FBUyxHQUFHLFdBQVcsT0FBT1Q7SUFDcEgsR0FBR3NDLFFBQVF0QztBQUNiO0FBQ0EsU0FBU2EsNEJBQTRCMUIsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZDLElBQUlELEdBQUc7UUFDTCxJQUFJLFlBQVksT0FBT0EsR0FBRyxPQUFPRCxrQkFBa0JDLEdBQUdDO1FBQ3RELElBQUlXLElBQUksRUFBQyxHQUFFeUMsUUFBUSxDQUFDcEIsSUFBSSxDQUFDakMsR0FBR3NELEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDdEMsT0FBTyxhQUFhMUMsS0FBS1osRUFBRW9ELFdBQVcsSUFBS3hDLENBQUFBLElBQUlaLEVBQUVvRCxXQUFXLENBQUNHLElBQUksR0FBRyxVQUFVM0MsS0FBSyxVQUFVQSxJQUFJUCxNQUFNaUMsSUFBSSxDQUFDdEMsS0FBSyxnQkFBZ0JZLEtBQUssMkNBQTJDNEMsSUFBSSxDQUFDNUMsS0FBS2Isa0JBQWtCQyxHQUFHQyxLQUFLZ0Q7SUFDdk47QUFDRjtBQUVBLElBQUlRLFVBQVUsS0FBa0IsR0FBYyxPQUFPQyxDQUFNQSxFQUFFLCtCQUErQjtBQUU1RixJQUFJQyxZQUFZRixVQUFVQSxRQUFRRSxTQUFTLEdBQUc7QUFDOUNGLFVBQVVBLFFBQVFHLFFBQVEsR0FBRztBQUM3QixJQUFJQyxZQUFZVixRQUFRO0FBQ3hCLElBQUlXLFlBQVlYLFFBQVEsQ0FBQztBQUN6QixJQUFJWSxXQUFXWixRQUFRLFlBQWE7QUFDcEMsSUFBSWEsZ0JBQWdCLE9BQU9DLGdCQUFnQixjQUFjLGNBQWNkLFFBQVFjO0FBQy9FLElBQUlDLGNBQWMsU0FBU0EsWUFBWUMsR0FBRztJQUN4QyxPQUFPQSxPQUFPQSxJQUFJQyxjQUFjLElBQUlDLEtBQUtGLElBQUlDLGNBQWMsSUFBSUQsSUFBSUMsY0FBYyxLQUFLO0FBQ3hGO0FBRUEsSUFBSUUsU0FBUyxTQUFTQSxPQUFPSCxHQUFHO0lBQzlCLE9BQU9BLE9BQU8sUUFBUWhCLFFBQVFnQixRQUFRTjtBQUN4QztBQUNBLElBQUlRLE9BQU8sU0FBU0UsR0FBR0osR0FBRztJQUN4QixPQUFPQSxPQUFPLFFBQVFoQixRQUFRZ0IsU0FBU0o7QUFDekM7QUFDQSxJQUFJUyxRQUFRLFNBQVNBLE1BQU1MLEdBQUc7SUFDNUIsT0FBTyxDQUFDTSxvQkFBb0JOLFFBQVM5RCxDQUFBQSxNQUFNRSxPQUFPLEdBQUdGLE1BQU1FLE9BQU8sQ0FBQzRELE9BQU9BLE9BQU8sUUFBUUEsZUFBZTlELEtBQUk7QUFDOUc7QUFDQSxJQUFJcUUsY0FBYyxTQUFTQSxZQUFZUCxHQUFHO0lBQ3hDLE9BQU9BLE9BQU8sUUFBUWhCLFFBQVFnQixTQUFTTCxhQUFhLENBQUNVLE1BQU1MLFFBQVFBLElBQUlmLFdBQVcsS0FBS25DO0FBQ3pGO0FBQ0EsSUFBSTBELFNBQVMsU0FBU0EsT0FBT1IsR0FBRztJQUM5QixPQUFPQSxPQUFPLFFBQVFoQixRQUFRZ0IsU0FBU0w7QUFDekM7QUFDQSxJQUFJYyxXQUFXLFNBQVNDLE9BQU9WLEdBQUc7SUFDaEMsT0FBT0EsT0FBTyxRQUFRaEIsUUFBUWdCLFNBQVNoQixRQUFRLE1BQU0sQ0FBQzJCLE1BQU1YO0FBQzlEO0FBQ0EsSUFBSVksVUFBVSxTQUFTQSxRQUFRWixHQUFHO0lBQ2hDLE9BQU9TLFNBQVNULFFBQVFhLEtBQUtDLEtBQUssQ0FBQ2QsU0FBU0E7QUFDOUM7QUFDQSxJQUFJZSxjQUFjLFNBQVNBLFlBQVlmLEdBQUc7SUFDeEMsSUFBSSxnQkFBZ0JILGVBQWU7UUFDakMsT0FBT2Y7SUFDVCxPQUFPO1FBQ0wsT0FBTyxRQUFRa0IsT0FBT0EsZUFBZUY7SUFDdkM7QUFDRjtBQUNBLElBQUlRLHNCQUFzQixTQUFTQSxvQkFBb0JOLEdBQUc7SUFDeEQsT0FBT2dCLFFBQVFoQixRQUFRaUIsV0FBV2pCO0FBQ3BDO0FBQ0EsSUFBSWdCLFVBQVUsU0FBU0EsUUFBUWhCLEdBQUc7SUFDaEMsT0FBT0QsWUFBWUMsU0FBUyxnQkFBZ0JBLElBQUlrQixRQUFRLENBQUNDLE1BQU07QUFDakU7QUFDQSxJQUFJRixhQUFhLFNBQVNBLFdBQVdqQixHQUFHO0lBQ3RDLE9BQU9ELFlBQVlDLFNBQVMsZ0JBQWdCLENBQUNBLElBQUlrQixRQUFRLENBQUNDLE1BQU07QUFDbEU7QUFDQSxJQUFJQyxPQUFPLFNBQVNBLEtBQUtwQixHQUFHO0lBQzFCLE9BQU9ELFlBQVlDLFNBQVM7QUFDOUI7QUFDQSxJQUFJcUIsYUFBYSxTQUFTQSxXQUFXckIsR0FBRztJQUN0QyxPQUFPRCxZQUFZQyxTQUFTO0FBQzlCO0FBQ0EsSUFBSXNCLFFBQVEsU0FBU0EsTUFBTXRCLEdBQUc7SUFDNUIsT0FBT0QsWUFBWUMsU0FBUztBQUM5QjtBQUNBLElBQUl1QixjQUFjLFNBQVNBLFlBQVl2QixHQUFHO0lBQ3hDLElBQUlBLFFBQVFsQixhQUFha0IsUUFBUSxNQUFNO1FBQ3JDLGdCQUFnQjtRQUNoQixPQUFPO0lBQ1QsT0FBTyxJQUFJQSxRQUFRLE1BQU1BLElBQUl3QixLQUFLLENBQUMsVUFBVTtRQUMzQyxPQUFPLE1BQU0sd0JBQXdCO0lBQ3ZDO0lBQ0EsT0FBTyxPQUFPLDBDQUEwQztBQUMxRDtBQUNBLElBQUlDLGFBQWEsU0FBU0EsV0FBV3pCLEdBQUc7SUFDdEMsSUFBSSxPQUFPRixnQkFBZ0IsYUFBYTtRQUN0QyxPQUFPLE9BQU8sOENBQThDO0lBQzlELE9BQU87UUFDTCxPQUFPRSxlQUFlRjtJQUN4QjtBQUNGO0FBQ0EsSUFBSTRCLGNBQWMsU0FBU0EsWUFBWTFCLEdBQUc7SUFDeEMsT0FBT08sWUFBWVAsUUFBUVMsU0FBU1QsSUFBSTJCLEVBQUUsS0FBS2xCLFNBQVNULElBQUk0QixFQUFFLEtBQUtuQixTQUFTVCxJQUFJNkIsRUFBRSxLQUFLcEIsU0FBU1QsSUFBSThCLEVBQUU7QUFDeEc7QUFDQSxJQUFJQyxVQUFVLFNBQVNBLFFBQVEvQixHQUFHO0lBQ2hDLE9BQU9RLE9BQU9SLFFBQVFFLEtBQUtGLElBQUlnQyxJQUFJO0FBQ3JDO0FBQ0EsSUFBSUMsS0FBSyxTQUFTQTtJQUNoQixPQUFPekMsYUFBYUEsVUFBVTBDLFNBQVMsQ0FBQ1YsS0FBSyxDQUFDO0FBQ2hELEdBQUcsMENBQTBDO0FBRTdDLElBQUlXLFVBQVUsU0FBU0EsUUFBUS9CLEVBQUUsRUFBRWdDLEtBQUs7SUFDdEMsSUFBSSxDQUFDQSxPQUFPO1FBQ1ZBLFFBQVEsU0FBU0E7WUFDZixJQUFJQyxVQUFVdEcsTUFBTSxLQUFLLEdBQUc7Z0JBQzFCLE9BQU9zRyxTQUFTLENBQUMsRUFBRTtZQUNyQixPQUFPLElBQUlBLFVBQVV0RyxNQUFNLEtBQUssR0FBRztnQkFDakMsT0FBTztZQUNUO1lBQ0EsSUFBSXVHLE9BQU8sRUFBRTtZQUNiLElBQUssSUFBSWhFLElBQUksR0FBR0EsSUFBSStELFVBQVV0RyxNQUFNLEVBQUV1QyxJQUFLO2dCQUN6Q2dFLEtBQUsvRCxJQUFJLENBQUM4RCxTQUFTLENBQUMvRCxFQUFFO1lBQ3hCO1lBQ0EsT0FBT2dFLEtBQUtDLElBQUksQ0FBQztRQUNuQjtJQUNGO0lBQ0EsSUFBSUMsY0FBYyxTQUFTQztRQUN6QixJQUFJQyxRQUFPLElBQUk7UUFDZixJQUFJSixPQUFPRDtRQUNYLElBQUlNO1FBQ0osSUFBSUMsSUFBSVIsTUFBTVMsS0FBSyxDQUFDSCxPQUFNSjtRQUMxQixJQUFJUSxRQUFRTixZQUFZTSxLQUFLO1FBQzdCLElBQUksQ0FBRUgsQ0FBQUEsTUFBTUcsS0FBSyxDQUFDRixFQUFFLEdBQUc7WUFDckJELE1BQU1HLEtBQUssQ0FBQ0YsRUFBRSxHQUFHeEMsR0FBR3lDLEtBQUssQ0FBQ0gsT0FBTUo7UUFDbEM7UUFDQSxPQUFPSztJQUNUO0lBQ0FILFlBQVlNLEtBQUssR0FBRyxDQUFDO0lBQ3JCLE9BQU9OO0FBQ1Q7QUFFQSxJQUFJTyxhQUFhWixRQUFRLFNBQVVhLEdBQUc7SUFDcEMsT0FBT0EsSUFBSUMsT0FBTyxDQUFDLFlBQVksU0FBVUMsQ0FBQztRQUN4QyxPQUFPLE1BQU1BLEVBQUVDLFdBQVc7SUFDNUI7QUFDRjtBQUNBLElBQUlDLGFBQWFqQixRQUFRLFNBQVVhLEdBQUc7SUFDcEMsT0FBT0EsSUFBSUMsT0FBTyxDQUFDLFVBQVUsU0FBVUMsQ0FBQztRQUN0QyxPQUFPQSxDQUFDLENBQUMsRUFBRSxDQUFDRyxXQUFXO0lBQ3pCO0FBQ0Y7QUFDQSxJQUFJQyxlQUFlbkIsUUFBUSxTQUFVb0IsTUFBTSxFQUFFUCxHQUFHO0lBQzlDLE9BQU9PLFNBQVNQLEdBQUcsQ0FBQyxFQUFFLENBQUNLLFdBQVcsS0FBS0wsSUFBSVEsU0FBUyxDQUFDO0FBQ3ZELEdBQUcsU0FBVUQsTUFBTSxFQUFFUCxHQUFHO0lBQ3RCLE9BQU9PLFNBQVMsTUFBTVA7QUFDeEI7QUFDQSxJQUFJUyxhQUFhLFNBQVNBLFdBQVdULEdBQUc7SUFDdEMsSUFBSXpCLFlBQVl5QixNQUFNO1FBQ3BCLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPQSxJQUFJVSxNQUFNLENBQUMsR0FBR0wsV0FBVyxLQUFLTCxJQUFJUSxTQUFTLENBQUM7QUFDckQ7QUFDQSxJQUFJRyxXQUFXLFNBQVNBLFNBQVN4RCxNQUFNLEVBQUV5RCxNQUFNO0lBQzdDLE9BQU96RCxPQUFPaEIsS0FBSyxDQUFDLENBQUMsSUFBSXlFLE9BQU83SCxNQUFNLE1BQU02SDtBQUM5QztBQUVBLElBQUlsRCxTQUFTO0FBQ2IsSUFBSW1ELE9BQU8sZ0JBQWdCbkQsU0FBUyxvQkFBb0JBLFNBQVMsb0JBQW9CQSxTQUFTLHVCQUF1QkEsU0FBUztBQUM5SCxJQUFJb0QsaUJBQWlCLGtCQUFrQnBELFNBQVMsc0JBQXNCQSxTQUFTLHNCQUFzQkEsU0FBUyx5QkFBeUJBLFNBQVM7QUFDaEosSUFBSXFELE9BQU8sZ0JBQWdCckQsU0FBUyxnQkFBZ0JBLFNBQVMsbUJBQW1CQSxTQUFTLHNCQUFzQkEsU0FBUztBQUN4SCxJQUFJc0QsaUJBQWlCLGtCQUFrQnRELFNBQVMsa0JBQWtCQSxTQUFTLHFCQUFxQkEsU0FBUyx3QkFBd0JBLFNBQVM7QUFDMUksSUFBSXVELE9BQU87QUFDWCxJQUFJQyxPQUFPO0FBRVgsSUFBSUMsWUFBWSxTQUFTQSxVQUFVckksQ0FBQyxFQUFFc0ksQ0FBQztJQUNyQyxJQUFJdEksSUFBSXNJLEdBQUc7UUFDVCxPQUFPLENBQUM7SUFDVixPQUFPLElBQUl0SSxJQUFJc0ksR0FBRztRQUNoQixPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBQ0EsSUFBSUMsYUFBYSxTQUFTQSxXQUFXdkksQ0FBQyxFQUFFc0ksQ0FBQztJQUN2QyxPQUFPLENBQUMsSUFBSUQsVUFBVXJJLEdBQUdzSTtBQUMzQjtBQUVBLElBQUlFLFNBQVN4SCxPQUFPeUgsTUFBTSxJQUFJLE9BQU96SCxPQUFPeUgsTUFBTSxDQUFDQyxJQUFJLENBQUMxSCxVQUFVLFNBQVUySCxHQUFHO0lBQzdFLElBQUluQyxPQUFPRDtJQUNYLElBQUssSUFBSS9ELElBQUksR0FBR0EsSUFBSWdFLEtBQUt2RyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3BDLElBQUkwQixNQUFNc0MsSUFBSSxDQUFDaEUsRUFBRTtRQUNqQixJQUFJMEIsT0FBTyxNQUFNO1lBQ2Y7UUFDRjtRQUNBLElBQUkwRSxPQUFPNUgsT0FBTzRILElBQUksQ0FBQzFFO1FBQ3ZCLElBQUssSUFBSTJFLElBQUksR0FBR0EsSUFBSUQsS0FBSzNJLE1BQU0sRUFBRTRJLElBQUs7WUFDcEMsSUFBSS9CLElBQUk4QixJQUFJLENBQUNDLEVBQUU7WUFDZkYsR0FBRyxDQUFDN0IsRUFBRSxHQUFHNUMsR0FBRyxDQUFDNEMsRUFBRTtRQUNqQjtJQUNGO0lBQ0EsT0FBTzZCO0FBQ1Q7QUFFQSxxQ0FBcUM7QUFDckMsSUFBSUcsWUFBWSxTQUFTQSxVQUFVQyxHQUFHO0lBQ3BDLElBQUksQ0FBRUEsQ0FBQUEsSUFBSTlJLE1BQU0sS0FBSyxLQUFLOEksSUFBSTlJLE1BQU0sS0FBSyxNQUFNOEksR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLO1FBQzdEO0lBQ0Y7SUFDQSxJQUFJQyxXQUFXRCxJQUFJOUksTUFBTSxLQUFLO0lBQzlCLElBQUlGLEdBQUdrSixHQUFHWDtJQUNWLElBQUlZLE9BQU87SUFDWCxJQUFJRixVQUFVO1FBQ1pqSixJQUFJb0osU0FBU0osR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsRUFBRUc7UUFDOUJELElBQUlFLFNBQVNKLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEVBQUVHO1FBQzlCWixJQUFJYSxTQUFTSixHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxFQUFFRztJQUNoQyxPQUFPO1FBQ0xuSixJQUFJb0osU0FBU0osR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsRUFBRUc7UUFDOUJELElBQUlFLFNBQVNKLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEVBQUVHO1FBQzlCWixJQUFJYSxTQUFTSixHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxFQUFFRztJQUNoQztJQUNBLE9BQU87UUFBQ25KO1FBQUdrSjtRQUFHWDtLQUFFO0FBQ2xCO0FBRUEseURBQXlEO0FBQ3pELElBQUljLFlBQVksU0FBU0EsVUFBVUMsR0FBRztJQUNwQyxJQUFJeEM7SUFDSixJQUFJeUMsR0FBRzNILEdBQUdZLEdBQUd2QyxHQUFHRCxHQUFHa0osR0FBR1g7SUFDdEIsU0FBU2lCLFFBQVFDLENBQUMsRUFBRUMsQ0FBQyxFQUFFOUksQ0FBQztRQUN0QixJQUFJQSxJQUFJLEdBQUdBLEtBQUs7UUFDaEIsSUFBSUEsSUFBSSxHQUFHQSxLQUFLO1FBQ2hCLElBQUlBLElBQUksSUFBSSxHQUFHLE9BQU82SSxJQUFJLENBQUNDLElBQUlELENBQUFBLElBQUssSUFBSTdJO1FBQ3hDLElBQUlBLElBQUksSUFBSSxHQUFHLE9BQU84STtRQUN0QixJQUFJOUksSUFBSSxJQUFJLEdBQUcsT0FBTzZJLElBQUksQ0FBQ0MsSUFBSUQsQ0FBQUEsSUFBTSxLQUFJLElBQUk3SSxDQUFBQSxJQUFLO1FBQ2xELE9BQU82STtJQUNUO0lBQ0EsSUFBSUUsS0FBSSxJQUFJQyxPQUFPLE1BQU0xQixPQUFPLEtBQUsyQixJQUFJLENBQUNQO0lBQzFDLElBQUlLLElBQUc7UUFDTCxVQUFVO1FBQ1ZKLElBQUlILFNBQVNPLEVBQUMsQ0FBQyxFQUFFO1FBQ2pCLElBQUlKLElBQUksR0FBRztZQUNUQSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUlBLElBQUksR0FBRSxJQUFLO1FBQzdCLE9BQU8sSUFBSUEsSUFBSSxLQUFLO1lBQ2xCQSxJQUFJQSxJQUFJO1FBQ1Y7UUFDQUEsS0FBSyxLQUFLLHNCQUFzQjtRQUVoQzNILElBQUlrSSxXQUFXSCxFQUFDLENBQUMsRUFBRTtRQUNuQixJQUFJL0gsSUFBSSxLQUFLQSxJQUFJLEtBQUs7WUFDcEI7UUFDRixFQUFFLHlCQUF5QjtRQUMzQkEsSUFBSUEsSUFBSSxLQUFLLHNCQUFzQjtRQUVuQ1ksSUFBSXNILFdBQVdILEVBQUMsQ0FBQyxFQUFFO1FBQ25CLElBQUluSCxJQUFJLEtBQUtBLElBQUksS0FBSztZQUNwQjtRQUNGLEVBQUUsd0JBQXdCO1FBQzFCQSxJQUFJQSxJQUFJLEtBQUssc0JBQXNCO1FBRW5DdkMsSUFBSTBKLEVBQUMsQ0FBQyxFQUFFO1FBQ1IsSUFBSTFKLE1BQU1nRCxXQUFXO1lBQ25CaEQsSUFBSTZKLFdBQVc3SjtZQUNmLElBQUlBLElBQUksS0FBS0EsSUFBSSxHQUFHO2dCQUNsQjtZQUNGLEVBQUUsa0JBQWtCO1FBQ3RCO1FBRUEsc0JBQXNCO1FBQ3RCLG9IQUFvSDtRQUNwSCxJQUFJMkIsTUFBTSxHQUFHO1lBQ1g1QixJQUFJa0osSUFBSVgsSUFBSXZELEtBQUsrRSxLQUFLLENBQUN2SCxJQUFJLE1BQU0sYUFBYTtRQUNoRCxPQUFPO1lBQ0wsSUFBSWtILElBQUlsSCxJQUFJLE1BQU1BLElBQUssS0FBSVosQ0FBQUEsSUFBS1ksSUFBSVosSUFBSVksSUFBSVo7WUFDNUMsSUFBSTZILElBQUksSUFBSWpILElBQUlrSDtZQUNoQjFKLElBQUlnRixLQUFLK0UsS0FBSyxDQUFDLE1BQU1QLFFBQVFDLEdBQUdDLEdBQUdILElBQUksSUFBSTtZQUMzQ0wsSUFBSWxFLEtBQUsrRSxLQUFLLENBQUMsTUFBTVAsUUFBUUMsR0FBR0MsR0FBR0g7WUFDbkNoQixJQUFJdkQsS0FBSytFLEtBQUssQ0FBQyxNQUFNUCxRQUFRQyxHQUFHQyxHQUFHSCxJQUFJLElBQUk7UUFDN0M7UUFDQXpDLE1BQU07WUFBQzlHO1lBQUdrSjtZQUFHWDtZQUFHdEk7U0FBRTtJQUNwQjtJQUNBLE9BQU82RztBQUNUO0FBRUEseURBQXlEO0FBQ3pELElBQUlrRCxZQUFZLFNBQVNBLFVBQVVDLEdBQUc7SUFDcEMsSUFBSW5EO0lBQ0osSUFBSTZDLEtBQUksSUFBSUMsT0FBTyxNQUFNNUIsT0FBTyxLQUFLNkIsSUFBSSxDQUFDSTtJQUMxQyxJQUFJTixJQUFHO1FBQ0w3QyxNQUFNLEVBQUU7UUFDUixJQUFJb0QsUUFBUSxFQUFFO1FBQ2QsSUFBSyxJQUFJekgsSUFBSSxHQUFHQSxLQUFLLEdBQUdBLElBQUs7WUFDM0IsSUFBSTBILFVBQVVSLEVBQUMsQ0FBQ2xILEVBQUU7WUFDbEIsSUFBSTBILE9BQU8sQ0FBQ0EsUUFBUWpLLE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSztnQkFDdkNnSyxLQUFLLENBQUN6SCxFQUFFLEdBQUc7WUFDYjtZQUNBMEgsVUFBVUwsV0FBV0s7WUFDckIsSUFBSUQsS0FBSyxDQUFDekgsRUFBRSxFQUFFO2dCQUNaMEgsVUFBVUEsVUFBVSxNQUFNLEtBQUssd0JBQXdCO1lBQ3pEO1lBQ0EsSUFBSUEsVUFBVSxLQUFLQSxVQUFVLEtBQUs7Z0JBQ2hDO1lBQ0YsRUFBRSx3QkFBd0I7WUFFMUJyRCxJQUFJcEUsSUFBSSxDQUFDc0MsS0FBS0MsS0FBSyxDQUFDa0Y7UUFDdEI7UUFDQSxJQUFJQyxrQkFBa0JGLEtBQUssQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBQyxFQUFFO1FBQ3RELElBQUlHLFlBQVlILEtBQUssQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBQyxFQUFFLElBQUlBLEtBQUssQ0FBQyxFQUFFO1FBQ2hELElBQUlFLG1CQUFtQixDQUFDQyxXQUFXO1lBQ2pDO1FBQ0YsRUFBRSx1Q0FBdUM7UUFFekMsSUFBSUMsUUFBUVgsRUFBQyxDQUFDLEVBQUU7UUFDaEIsSUFBSVcsVUFBVXJILFdBQVc7WUFDdkJxSCxRQUFRUixXQUFXUTtZQUNuQixJQUFJQSxRQUFRLEtBQUtBLFFBQVEsR0FBRztnQkFDMUI7WUFDRixFQUFFLHNCQUFzQjtZQUV4QnhELElBQUlwRSxJQUFJLENBQUM0SDtRQUNYO0lBQ0Y7SUFDQSxPQUFPeEQ7QUFDVDtBQUNBLElBQUl5RCxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxLQUFLO0lBQ2xELE9BQU9DLE1BQU0sQ0FBQ0QsTUFBTWxELFdBQVcsR0FBRztBQUNwQztBQUNBLElBQUlvRCxjQUFjLFNBQVNBLFlBQVlGLEtBQUs7SUFDMUMsT0FBTyxDQUFDaEcsTUFBTWdHLFNBQVNBLFFBQVEsSUFBRyxLQUFNRCxnQkFBZ0JDLFVBQVV6QixVQUFVeUIsVUFBVVIsVUFBVVEsVUFBVW5CLFVBQVVtQjtBQUN0SDtBQUNBLElBQUlDLFNBQVM7SUFDWCx1QkFBdUI7SUFDdkJFLGFBQWE7UUFBQztRQUFHO1FBQUc7UUFBRztLQUFFO0lBQ3pCLGlCQUFpQjtJQUVqQixrQkFBa0I7SUFDbEJDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsY0FBYztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzdCQyxNQUFNO1FBQUM7UUFBRztRQUFLO0tBQUk7SUFDbkJDLFlBQVk7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMzQkMsT0FBTztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3RCQyxPQUFPO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDdEJDLFFBQVE7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN2QkMsT0FBTztRQUFDO1FBQUc7UUFBRztLQUFFO0lBQ2hCQyxnQkFBZ0I7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMvQkMsTUFBTTtRQUFDO1FBQUc7UUFBRztLQUFJO0lBQ2pCQyxZQUFZO1FBQUM7UUFBSztRQUFJO0tBQUk7SUFDMUJDLE9BQU87UUFBQztRQUFLO1FBQUk7S0FBRztJQUNwQkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzFCQyxXQUFXO1FBQUM7UUFBSTtRQUFLO0tBQUk7SUFDekJDLFlBQVk7UUFBQztRQUFLO1FBQUs7S0FBRTtJQUN6QkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFHO0lBQ3pCQyxPQUFPO1FBQUM7UUFBSztRQUFLO0tBQUc7SUFDckJDLGdCQUFnQjtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQy9CQyxVQUFVO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDekJDLFNBQVM7UUFBQztRQUFLO1FBQUk7S0FBRztJQUN0QkMsTUFBTTtRQUFDO1FBQUc7UUFBSztLQUFJO0lBQ25CQyxVQUFVO1FBQUM7UUFBRztRQUFHO0tBQUk7SUFDckJDLFVBQVU7UUFBQztRQUFHO1FBQUs7S0FBSTtJQUN2QkMsZUFBZTtRQUFDO1FBQUs7UUFBSztLQUFHO0lBQzdCQyxVQUFVO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDekJDLFdBQVc7UUFBQztRQUFHO1FBQUs7S0FBRTtJQUN0QkMsVUFBVTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3pCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDMUJDLGFBQWE7UUFBQztRQUFLO1FBQUc7S0FBSTtJQUMxQkMsZ0JBQWdCO1FBQUM7UUFBSTtRQUFLO0tBQUc7SUFDN0JDLFlBQVk7UUFBQztRQUFLO1FBQUs7S0FBRTtJQUN6QkMsWUFBWTtRQUFDO1FBQUs7UUFBSTtLQUFJO0lBQzFCQyxTQUFTO1FBQUM7UUFBSztRQUFHO0tBQUU7SUFDcEJDLFlBQVk7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMzQkMsY0FBYztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzdCQyxlQUFlO1FBQUM7UUFBSTtRQUFJO0tBQUk7SUFDNUJDLGVBQWU7UUFBQztRQUFJO1FBQUk7S0FBRztJQUMzQkMsZUFBZTtRQUFDO1FBQUk7UUFBSTtLQUFHO0lBQzNCQyxlQUFlO1FBQUM7UUFBRztRQUFLO0tBQUk7SUFDNUJDLFlBQVk7UUFBQztRQUFLO1FBQUc7S0FBSTtJQUN6QkMsVUFBVTtRQUFDO1FBQUs7UUFBSTtLQUFJO0lBQ3hCQyxhQUFhO1FBQUM7UUFBRztRQUFLO0tBQUk7SUFDMUJDLFNBQVM7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN4QkMsU0FBUztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3hCQyxZQUFZO1FBQUM7UUFBSTtRQUFLO0tBQUk7SUFDMUJDLFdBQVc7UUFBQztRQUFLO1FBQUk7S0FBRztJQUN4QkMsYUFBYTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzVCQyxhQUFhO1FBQUM7UUFBSTtRQUFLO0tBQUc7SUFDMUJDLFNBQVM7UUFBQztRQUFLO1FBQUc7S0FBSTtJQUN0QkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzFCQyxZQUFZO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDM0JDLE1BQU07UUFBQztRQUFLO1FBQUs7S0FBRTtJQUNuQkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFHO0lBQ3pCQyxNQUFNO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDckJDLE1BQU07UUFBQztRQUFLO1FBQUs7S0FBSTtJQUNyQkMsT0FBTztRQUFDO1FBQUc7UUFBSztLQUFFO0lBQ2xCQyxhQUFhO1FBQUM7UUFBSztRQUFLO0tBQUc7SUFDM0JDLFVBQVU7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN6QkMsU0FBUztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3hCQyxXQUFXO1FBQUM7UUFBSztRQUFJO0tBQUc7SUFDeEJDLFFBQVE7UUFBQztRQUFJO1FBQUc7S0FBSTtJQUNwQkMsT0FBTztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3RCQyxPQUFPO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDdEJDLFVBQVU7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN6QkMsZUFBZTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzlCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUU7SUFDeEJDLGNBQWM7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUM3QkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzFCQyxZQUFZO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDM0JDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsc0JBQXNCO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDckNDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsWUFBWTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzNCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDMUJDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsYUFBYTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzVCQyxlQUFlO1FBQUM7UUFBSTtRQUFLO0tBQUk7SUFDN0JDLGNBQWM7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUM3QkMsZ0JBQWdCO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDL0JDLGdCQUFnQjtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQy9CQyxnQkFBZ0I7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMvQkMsYUFBYTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzVCQyxNQUFNO1FBQUM7UUFBRztRQUFLO0tBQUU7SUFDakJDLFdBQVc7UUFBQztRQUFJO1FBQUs7S0FBRztJQUN4QkMsT0FBTztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3RCQyxTQUFTO1FBQUM7UUFBSztRQUFHO0tBQUk7SUFDdEJDLFFBQVE7UUFBQztRQUFLO1FBQUc7S0FBRTtJQUNuQkMsa0JBQWtCO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDakNDLFlBQVk7UUFBQztRQUFHO1FBQUc7S0FBSTtJQUN2QkMsY0FBYztRQUFDO1FBQUs7UUFBSTtLQUFJO0lBQzVCQyxjQUFjO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDN0JDLGdCQUFnQjtRQUFDO1FBQUk7UUFBSztLQUFJO0lBQzlCQyxpQkFBaUI7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUNoQ0MsbUJBQW1CO1FBQUM7UUFBRztRQUFLO0tBQUk7SUFDaENDLGlCQUFpQjtRQUFDO1FBQUk7UUFBSztLQUFJO0lBQy9CQyxpQkFBaUI7UUFBQztRQUFLO1FBQUk7S0FBSTtJQUMvQkMsY0FBYztRQUFDO1FBQUk7UUFBSTtLQUFJO0lBQzNCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDMUJDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsVUFBVTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3pCQyxhQUFhO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDNUJDLE1BQU07UUFBQztRQUFHO1FBQUc7S0FBSTtJQUNqQkMsU0FBUztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3hCQyxPQUFPO1FBQUM7UUFBSztRQUFLO0tBQUU7SUFDcEJDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBRztJQUN6QkMsUUFBUTtRQUFDO1FBQUs7UUFBSztLQUFFO0lBQ3JCQyxXQUFXO1FBQUM7UUFBSztRQUFJO0tBQUU7SUFDdkJDLFFBQVE7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN2QkMsZUFBZTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzlCQyxXQUFXO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDMUJDLGVBQWU7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUM5QkMsZUFBZTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzlCQyxZQUFZO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDM0JDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsTUFBTTtRQUFDO1FBQUs7UUFBSztLQUFHO0lBQ3BCQyxNQUFNO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDckJDLE1BQU07UUFBQztRQUFLO1FBQUs7S0FBSTtJQUNyQkMsWUFBWTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzNCQyxRQUFRO1FBQUM7UUFBSztRQUFHO0tBQUk7SUFDckJDLEtBQUs7UUFBQztRQUFLO1FBQUc7S0FBRTtJQUNoQkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzFCQyxXQUFXO1FBQUM7UUFBSTtRQUFLO0tBQUk7SUFDekJDLGFBQWE7UUFBQztRQUFLO1FBQUk7S0FBRztJQUMxQkMsUUFBUTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3ZCQyxZQUFZO1FBQUM7UUFBSztRQUFLO0tBQUc7SUFDMUJDLFVBQVU7UUFBQztRQUFJO1FBQUs7S0FBRztJQUN2QkMsVUFBVTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3pCQyxRQUFRO1FBQUM7UUFBSztRQUFJO0tBQUc7SUFDckJDLFFBQVE7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN2QkMsU0FBUztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3hCQyxXQUFXO1FBQUM7UUFBSztRQUFJO0tBQUk7SUFDekJDLFdBQVc7UUFBQztRQUFLO1FBQUs7S0FBSTtJQUMxQkMsV0FBVztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzFCQyxNQUFNO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDckJDLGFBQWE7UUFBQztRQUFHO1FBQUs7S0FBSTtJQUMxQkMsV0FBVztRQUFDO1FBQUk7UUFBSztLQUFJO0lBQ3pCQyxLQUFLO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDcEJDLE1BQU07UUFBQztRQUFHO1FBQUs7S0FBSTtJQUNuQkMsU0FBUztRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3hCQyxRQUFRO1FBQUM7UUFBSztRQUFJO0tBQUc7SUFDckJDLFdBQVc7UUFBQztRQUFJO1FBQUs7S0FBSTtJQUN6QkMsUUFBUTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQ3ZCQyxPQUFPO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDdEJDLE9BQU87UUFBQztRQUFLO1FBQUs7S0FBSTtJQUN0QkMsWUFBWTtRQUFDO1FBQUs7UUFBSztLQUFJO0lBQzNCQyxRQUFRO1FBQUM7UUFBSztRQUFLO0tBQUU7SUFDckJDLGFBQWE7UUFBQztRQUFLO1FBQUs7S0FBRztBQUM3QjtBQUVBLGlEQUFpRDtBQUNqRCxJQUFJQyxTQUFTLFNBQVNBLE9BQU9DLE9BQU87SUFDbEMsSUFBSTdQLE1BQU02UCxRQUFRQyxHQUFHO0lBQ3JCLElBQUlwTCxPQUFPbUwsUUFBUW5MLElBQUk7SUFDdkIsSUFBSXJHLElBQUlxRyxLQUFLM0ksTUFBTTtJQUNuQixJQUFLLElBQUl1QyxJQUFJLEdBQUdBLElBQUlELEdBQUdDLElBQUs7UUFDMUIsSUFBSXJCLE1BQU15SCxJQUFJLENBQUNwRyxFQUFFO1FBQ2pCLElBQUlpQyxZQUFZdEQsTUFBTTtZQUNwQixNQUFNOFMsTUFBTTtRQUNkO1FBQ0EsSUFBSXpSLElBQUlvRyxLQUFLM0ksTUFBTSxHQUFHLEdBQUc7WUFDdkIsOEJBQThCO1lBQzlCLElBQUlpRSxHQUFHLENBQUMvQyxJQUFJLElBQUksTUFBTTtnQkFDcEIrQyxHQUFHLENBQUMvQyxJQUFJLEdBQUcsQ0FBQztZQUNkO1lBQ0ErQyxNQUFNQSxHQUFHLENBQUMvQyxJQUFJO1FBQ2hCLE9BQU87WUFDTCxnQkFBZ0I7WUFDaEIrQyxHQUFHLENBQUMvQyxJQUFJLEdBQUc0UyxRQUFRbFMsS0FBSztRQUMxQjtJQUNGO0FBQ0Y7QUFFQSwyREFBMkQ7QUFDM0QsSUFBSXFTLFNBQVMsU0FBU0EsT0FBT0gsT0FBTztJQUNsQyxJQUFJN1AsTUFBTTZQLFFBQVFDLEdBQUc7SUFDckIsSUFBSXBMLE9BQU9tTCxRQUFRbkwsSUFBSTtJQUN2QixJQUFJckcsSUFBSXFHLEtBQUszSSxNQUFNO0lBQ25CLElBQUssSUFBSXVDLElBQUksR0FBR0EsSUFBSUQsR0FBR0MsSUFBSztRQUMxQixJQUFJckIsTUFBTXlILElBQUksQ0FBQ3BHLEVBQUU7UUFDakIsSUFBSWlDLFlBQVl0RCxNQUFNO1lBQ3BCLE1BQU04UyxNQUFNO1FBQ2Q7UUFDQS9QLE1BQU1BLEdBQUcsQ0FBQy9DLElBQUk7UUFDZCxJQUFJK0MsT0FBTyxNQUFNO1lBQ2YsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLElBQUlpUSxpQkFBaUIsT0FBT0MsZUFBZSxjQUFjQSxhQUFhLE1BQWtCLEdBQWMzUSxDQUFNQSxHQUFHLE9BQU80USxXQUFXLGNBQWNBLFNBQVMsT0FBT3pOLFNBQVMsY0FBY0EsT0FBTyxDQUFDO0FBRTlMLFNBQVMwTix3QkFBeUJDLENBQUM7SUFDbEMsT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxJQUFJeFQsT0FBT0ssU0FBUyxDQUFDb1QsY0FBYyxDQUFDelMsSUFBSSxDQUFDdVMsR0FBRyxhQUFhQSxDQUFDLENBQUMsVUFBVSxHQUFHQTtBQUNqRztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3QkMsR0FFRCxJQUFJRztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxxQkFBcUIsT0FBT0Q7SUFDaENDLHNCQUFzQjtJQUN0QixTQUFTRSxTQUFTaFQsS0FBSztRQUNyQixJQUFJaVQsT0FBTyxPQUFPalQ7UUFDbEIsT0FBT0EsU0FBUyxRQUFTaVQsQ0FBQUEsUUFBUSxZQUFZQSxRQUFRLFVBQVM7SUFDaEU7SUFFQUosYUFBYUc7SUFDYixPQUFPSDtBQUNSO0FBRUEsZ0RBQWdELEdBRWhELElBQUlLO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHdCQUF3QixPQUFPRDtJQUNuQ0MseUJBQXlCO0lBQ3pCLElBQUlFLGFBQWEsT0FBT2Ysa0JBQWtCLFlBQVlBLGtCQUFrQkEsZUFBZW5ULE1BQU0sS0FBS0EsVUFBVW1UO0lBRTVHWSxjQUFjRztJQUNkLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxrQkFBa0IsT0FBT0Q7SUFDN0JDLG1CQUFtQjtJQUNuQixJQUFJRixhQUFhRDtJQUVqQixpQ0FBaUMsR0FDakMsSUFBSUssV0FBVyxPQUFPMU8sUUFBUSxZQUFZQSxRQUFRQSxLQUFLNUYsTUFBTSxLQUFLQSxVQUFVNEY7SUFFNUUsOENBQThDLEdBQzlDLElBQUkyTyxPQUFPTCxjQUFjSSxZQUFZRSxTQUFTO0lBRTlDTCxRQUFRSTtJQUNSLE9BQU9KO0FBQ1I7QUFFQSxJQUFJTTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxnQkFBZ0IsT0FBT0Q7SUFDM0JDLGlCQUFpQjtJQUNqQixJQUFJSCxPQUFPRjtJQUVYOzs7Ozs7Ozs7Ozs7Ozs7RUFlQyxHQUNELElBQUlPLE1BQU07UUFDUixPQUFPTCxLQUFLTSxJQUFJLENBQUNELEdBQUc7SUFDdEI7SUFFQUgsUUFBUUc7SUFDUixPQUFPSDtBQUNSO0FBRUEsaURBQWlELEdBRWpELElBQUlLO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELDZCQUE2QixPQUFPRDtJQUN4Q0MsOEJBQThCO0lBQzlCLElBQUlFLGVBQWU7SUFFbkI7Ozs7Ozs7RUFPQyxHQUNELFNBQVNDLGdCQUFnQjdSLE1BQU07UUFDN0IsSUFBSThSLFFBQVE5UixPQUFPcEUsTUFBTTtRQUV6QixNQUFPa1csV0FBV0YsYUFBYTFTLElBQUksQ0FBQ2MsT0FBT3VELE1BQU0sQ0FBQ3VPLFFBQVMsQ0FBQztRQUM1RCxPQUFPQTtJQUNUO0lBRUFMLG1CQUFtQkk7SUFDbkIsT0FBT0o7QUFDUjtBQUVBLElBQUlNO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHNCQUFzQixPQUFPRDtJQUNqQ0MsdUJBQXVCO0lBQ3ZCLElBQUlILGtCQUFrQkY7SUFFdEIsc0NBQXNDLEdBQ3RDLElBQUlPLGNBQWM7SUFFbEI7Ozs7OztFQU1DLEdBQ0QsU0FBU0MsU0FBU25TLE1BQU07UUFDdEIsT0FBT0EsU0FDSEEsT0FBT2hCLEtBQUssQ0FBQyxHQUFHNlMsZ0JBQWdCN1IsVUFBVSxHQUFHOEMsT0FBTyxDQUFDb1AsYUFBYSxNQUNsRWxTO0lBQ047SUFFQStSLFlBQVlJO0lBQ1osT0FBT0o7QUFDUjtBQUVBLElBQUlLO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELG9CQUFvQixPQUFPRDtJQUMvQkMscUJBQXFCO0lBQ3JCLElBQUluQixPQUFPRjtJQUVYLCtCQUErQixHQUMvQixJQUFJOVQsVUFBU2dVLEtBQUtoVSxNQUFNO0lBRXhCa1YsVUFBVWxWO0lBQ1YsT0FBT2tWO0FBQ1I7QUFFQSxJQUFJRztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx1QkFBdUIsT0FBT0Q7SUFDbENDLHdCQUF3QjtJQUN4QixJQUFJdFYsVUFBU29WO0lBRWIseUNBQXlDLEdBQ3pDLElBQUlJLGNBQWMvVixPQUFPSyxTQUFTO0lBRWxDLDhDQUE4QyxHQUM5QyxJQUFJb1QsaUJBQWlCc0MsWUFBWXRDLGNBQWM7SUFFL0M7Ozs7RUFJQyxHQUNELElBQUl1Qyx1QkFBdUJELFlBQVkzVCxRQUFRO0lBRS9DLCtCQUErQixHQUMvQixJQUFJNlQsaUJBQWlCMVYsVUFBU0EsUUFBTzJWLFdBQVcsR0FBR2xVO0lBRW5EOzs7Ozs7RUFNQyxHQUNELFNBQVNtVSxVQUFVdFYsS0FBSztRQUN0QixJQUFJdVYsUUFBUTNDLGVBQWV6UyxJQUFJLENBQUNILE9BQU9vVixpQkFDbkNJLE1BQU14VixLQUFLLENBQUNvVixlQUFlO1FBRS9CLElBQUk7WUFDRnBWLEtBQUssQ0FBQ29WLGVBQWUsR0FBR2pVO1lBQ3hCLElBQUlzVSxXQUFXO1FBQ2pCLEVBQUUsT0FBT3BYLEdBQUcsQ0FBQztRQUViLElBQUlxWCxTQUFTUCxxQkFBcUJoVixJQUFJLENBQUNIO1FBQ3ZDLElBQUl5VixVQUFVO1lBQ1osSUFBSUYsT0FBTztnQkFDVHZWLEtBQUssQ0FBQ29WLGVBQWUsR0FBR0k7WUFDMUIsT0FBTztnQkFDTCxPQUFPeFYsS0FBSyxDQUFDb1YsZUFBZTtZQUM5QjtRQUNGO1FBQ0EsT0FBT007SUFDVDtJQUVBWCxhQUFhTztJQUNiLE9BQU9QO0FBQ1I7QUFFQSx5Q0FBeUMsR0FFekMsSUFBSVk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsNEJBQTRCLE9BQU9EO0lBQ3ZDQyw2QkFBNkI7SUFDN0IsSUFBSVYsY0FBYy9WLE9BQU9LLFNBQVM7SUFFbEM7Ozs7RUFJQyxHQUNELElBQUkyVix1QkFBdUJELFlBQVkzVCxRQUFRO0lBRS9DOzs7Ozs7RUFNQyxHQUNELFNBQVN1VSxlQUFlOVYsS0FBSztRQUMzQixPQUFPbVYscUJBQXFCaFYsSUFBSSxDQUFDSDtJQUNuQztJQUVBMlYsa0JBQWtCRztJQUNsQixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsd0JBQXdCLE9BQU9EO0lBQ25DQyx5QkFBeUI7SUFDekIsSUFBSXRXLFVBQVNvVixrQkFDVFEsWUFBWUwscUJBQ1phLGlCQUFpQkQ7SUFFckIseUNBQXlDLEdBQ3pDLElBQUlLLFVBQVUsaUJBQ1ZDLGVBQWU7SUFFbkIsK0JBQStCLEdBQy9CLElBQUlmLGlCQUFpQjFWLFVBQVNBLFFBQU8yVixXQUFXLEdBQUdsVTtJQUVuRDs7Ozs7O0VBTUMsR0FDRCxTQUFTaVYsV0FBV3BXLEtBQUs7UUFDdkIsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCLE9BQU9BLFVBQVVtQixZQUFZZ1YsZUFBZUQ7UUFDOUM7UUFDQSxPQUFPLGtCQUFtQmQsa0JBQWtCalcsT0FBT2EsU0FDL0NzVixVQUFVdFYsU0FDVjhWLGVBQWU5VjtJQUNyQjtJQUVBK1YsY0FBY0s7SUFDZCxPQUFPTDtBQUNSO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBRUQsSUFBSU07QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQseUJBQXlCLE9BQU9EO0lBQ3BDQywwQkFBMEI7SUFDMUIsU0FBU0UsYUFBYXhXLEtBQUs7UUFDekIsT0FBT0EsU0FBUyxRQUFRLE9BQU9BLFNBQVM7SUFDMUM7SUFFQXFXLGlCQUFpQkc7SUFDakIsT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHFCQUFxQixPQUFPRDtJQUNoQ0Msc0JBQXNCO0lBQ3RCLElBQUlOLGFBQWFILHNCQUNiTyxlQUFlRDtJQUVuQix5Q0FBeUMsR0FDekMsSUFBSUssWUFBWTtJQUVoQjs7Ozs7Ozs7Ozs7Ozs7OztFQWdCQyxHQUNELFNBQVNDLFNBQVM3VyxLQUFLO1FBQ3JCLE9BQU8sT0FBT0EsU0FBUyxZQUNwQndXLGFBQWF4VyxVQUFVb1csV0FBV3BXLFVBQVU0VztJQUNqRDtJQUVBSCxhQUFhSTtJQUNiLE9BQU9KO0FBQ1I7QUFFQSxJQUFJSztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxxQkFBcUIsT0FBT0Q7SUFDaENDLHNCQUFzQjtJQUN0QixJQUFJcEMsV0FBV0Ysb0JBQ1h6QixXQUFXRCxtQkFDWDhELFdBQVdGO0lBRWYsdURBQXVELEdBQ3ZELElBQUlNLE1BQU0sSUFBSTtJQUVkLHlEQUF5RCxHQUN6RCxJQUFJQyxhQUFhO0lBRWpCLHlDQUF5QyxHQUN6QyxJQUFJQyxhQUFhO0lBRWpCLHdDQUF3QyxHQUN4QyxJQUFJQyxZQUFZO0lBRWhCLCtEQUErRCxHQUMvRCxJQUFJQyxlQUFlL1A7SUFFbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFzQkMsR0FDRCxTQUFTZ1EsU0FBU3RYLEtBQUs7UUFDckIsSUFBSSxPQUFPQSxTQUFTLFVBQVU7WUFDNUIsT0FBT0E7UUFDVDtRQUNBLElBQUk2VyxTQUFTN1csUUFBUTtZQUNuQixPQUFPaVg7UUFDVDtRQUNBLElBQUlqRSxTQUFTaFQsUUFBUTtZQUNuQixJQUFJdVgsUUFBUSxPQUFPdlgsTUFBTXdYLE9BQU8sSUFBSSxhQUFheFgsTUFBTXdYLE9BQU8sS0FBS3hYO1lBQ25FQSxRQUFRZ1QsU0FBU3VFLFNBQVVBLFFBQVEsS0FBTUE7UUFDM0M7UUFDQSxJQUFJLE9BQU92WCxTQUFTLFVBQVU7WUFDNUIsT0FBT0EsVUFBVSxJQUFJQSxRQUFRLENBQUNBO1FBQ2hDO1FBQ0FBLFFBQVEyVSxTQUFTM1U7UUFDakIsSUFBSXlYLFdBQVdOLFdBQVd6VixJQUFJLENBQUMxQjtRQUMvQixPQUFPLFlBQWFvWCxVQUFVMVYsSUFBSSxDQUFDMUIsU0FDL0JxWCxhQUFhclgsTUFBTXdCLEtBQUssQ0FBQyxJQUFJaVcsV0FBVyxJQUFJLEtBQzNDUCxXQUFXeFYsSUFBSSxDQUFDMUIsU0FBU2lYLE1BQU0sQ0FBQ2pYO0lBQ3ZDO0lBRUE4VyxhQUFhUTtJQUNiLE9BQU9SO0FBQ1I7QUFFQSxJQUFJWTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxxQkFBcUIsT0FBT0Q7SUFDaENDLHNCQUFzQjtJQUN0QixJQUFJM0UsV0FBV0QsbUJBQ1hnQixNQUFNRCxjQUNOd0QsV0FBV047SUFFZiw2QkFBNkIsR0FDN0IsSUFBSWEsa0JBQWtCO0lBRXRCLHNGQUFzRixHQUN0RixJQUFJQyxZQUFZNVUsS0FBSzZVLEdBQUcsRUFDcEJDLFlBQVk5VSxLQUFLK1UsR0FBRztJQUV4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFxREMsR0FDRCxTQUFTQyxTQUFTQyxJQUFJLEVBQUVDLElBQUksRUFBRWxHLE9BQU87UUFDbkMsSUFBSW1HLFVBQ0FDLFVBQ0FDLFNBQ0E3QyxRQUNBOEMsU0FDQUMsY0FDQUMsaUJBQWlCLEdBQ2pCQyxVQUFVLE9BQ1ZDLFNBQVMsT0FDVEMsV0FBVztRQUVmLElBQUksT0FBT1YsUUFBUSxZQUFZO1lBQzdCLE1BQU0sSUFBSXZaLFVBQVVpWjtRQUN0QjtRQUNBTyxPQUFPZCxTQUFTYyxTQUFTO1FBQ3pCLElBQUlwRixTQUFTZCxVQUFVO1lBQ3JCeUcsVUFBVSxDQUFDLENBQUN6RyxRQUFReUcsT0FBTztZQUMzQkMsU0FBUyxhQUFhMUc7WUFDdEJxRyxVQUFVSyxTQUFTZCxVQUFVUixTQUFTcEYsUUFBUXFHLE9BQU8sS0FBSyxHQUFHSCxRQUFRRztZQUNyRU0sV0FBVyxjQUFjM0csVUFBVSxDQUFDLENBQUNBLFFBQVEyRyxRQUFRLEdBQUdBO1FBQzFEO1FBRUEsU0FBU0MsV0FBV0MsSUFBSTtZQUN0QixJQUFJcFUsT0FBTzBULFVBQ1BXLFVBQVVWO1lBRWRELFdBQVdDLFdBQVduWDtZQUN0QnVYLGlCQUFpQks7WUFDakJyRCxTQUFTeUMsS0FBS2pULEtBQUssQ0FBQzhULFNBQVNyVTtZQUM3QixPQUFPK1E7UUFDVDtRQUVBLFNBQVN1RCxZQUFZRixJQUFJO1lBQ3ZCLDZCQUE2QjtZQUM3QkwsaUJBQWlCSztZQUNqQix5Q0FBeUM7WUFDekNQLFVBQVVVLFdBQVdDLGNBQWNmO1lBQ25DLDJCQUEyQjtZQUMzQixPQUFPTyxVQUFVRyxXQUFXQyxRQUFRckQ7UUFDdEM7UUFFQSxTQUFTMEQsY0FBY0wsSUFBSTtZQUN6QixJQUFJTSxvQkFBb0JOLE9BQU9OLGNBQzNCYSxzQkFBc0JQLE9BQU9MLGdCQUM3QmEsY0FBY25CLE9BQU9pQjtZQUV6QixPQUFPVCxTQUNIWixVQUFVdUIsYUFBYWhCLFVBQVVlLHVCQUNqQ0M7UUFDTjtRQUVBLFNBQVNDLGFBQWFULElBQUk7WUFDeEIsSUFBSU0sb0JBQW9CTixPQUFPTixjQUMzQmEsc0JBQXNCUCxPQUFPTDtZQUVqQyx1RUFBdUU7WUFDdkUsdUVBQXVFO1lBQ3ZFLDZEQUE2RDtZQUM3RCxPQUFRRCxpQkFBaUJ0WCxhQUFja1kscUJBQXFCakIsUUFDekRpQixvQkFBb0IsS0FBT1QsVUFBVVUsdUJBQXVCZjtRQUNqRTtRQUVBLFNBQVNZO1lBQ1AsSUFBSUosT0FBT2hGO1lBQ1gsSUFBSXlGLGFBQWFULE9BQU87Z0JBQ3RCLE9BQU9VLGFBQWFWO1lBQ3RCO1lBQ0EscUJBQXFCO1lBQ3JCUCxVQUFVVSxXQUFXQyxjQUFjQyxjQUFjTDtRQUNuRDtRQUVBLFNBQVNVLGFBQWFWLElBQUk7WUFDeEJQLFVBQVVyWDtZQUVWLGdFQUFnRTtZQUNoRSwyQkFBMkI7WUFDM0IsSUFBSTBYLFlBQVlSLFVBQVU7Z0JBQ3hCLE9BQU9TLFdBQVdDO1lBQ3BCO1lBQ0FWLFdBQVdDLFdBQVduWDtZQUN0QixPQUFPdVU7UUFDVDtRQUVBLFNBQVNnRTtZQUNQLElBQUlsQixZQUFZclgsV0FBVztnQkFDekJ3WSxhQUFhbkI7WUFDZjtZQUNBRSxpQkFBaUI7WUFDakJMLFdBQVdJLGVBQWVILFdBQVdFLFVBQVVyWDtRQUNqRDtRQUVBLFNBQVN5WTtZQUNQLE9BQU9wQixZQUFZclgsWUFBWXVVLFNBQVMrRCxhQUFhMUY7UUFDdkQ7UUFFQSxTQUFTOEY7WUFDUCxJQUFJZCxPQUFPaEYsT0FDUCtGLGFBQWFOLGFBQWFUO1lBRTlCVixXQUFXM1Q7WUFDWDRULFdBQVcsSUFBSTtZQUNmRyxlQUFlTTtZQUVmLElBQUllLFlBQVk7Z0JBQ2QsSUFBSXRCLFlBQVlyWCxXQUFXO29CQUN6QixPQUFPOFgsWUFBWVI7Z0JBQ3JCO2dCQUNBLElBQUlHLFFBQVE7b0JBQ1Ysc0NBQXNDO29CQUN0Q2UsYUFBYW5CO29CQUNiQSxVQUFVVSxXQUFXQyxjQUFjZjtvQkFDbkMsT0FBT1UsV0FBV0w7Z0JBQ3BCO1lBQ0Y7WUFDQSxJQUFJRCxZQUFZclgsV0FBVztnQkFDekJxWCxVQUFVVSxXQUFXQyxjQUFjZjtZQUNyQztZQUNBLE9BQU8xQztRQUNUO1FBQ0FtRSxVQUFVSCxNQUFNLEdBQUdBO1FBQ25CRyxVQUFVRCxLQUFLLEdBQUdBO1FBQ2xCLE9BQU9DO0lBQ1Q7SUFFQW5DLGFBQWFRO0lBQ2IsT0FBT1I7QUFDUjtBQUVBLElBQUlxQyxrQkFBa0JuQztBQUN0QixJQUFJTSxXQUFXLFdBQVcsR0FBRXpGLHdCQUF3QnNIO0FBRXBELElBQUlDLGdCQUFnQnJZLFVBQVVBLFFBQVFzWSxXQUFXLEdBQUc7QUFDcEQsSUFBSUMsT0FBT0YsaUJBQWlCQSxjQUFjakcsR0FBRyxHQUFHO0lBQzlDLE9BQU9pRyxjQUFjakcsR0FBRztBQUMxQixJQUFJO0lBQ0YsT0FBT0MsS0FBS0QsR0FBRztBQUNqQjtBQUNBLElBQUlvRyxNQUFNO0lBQ1IsSUFBSXhZLFNBQVM7UUFDWCxJQUFJQSxRQUFReVkscUJBQXFCLEVBQUU7WUFDakMsT0FBTyxTQUFVM1gsRUFBRTtnQkFDakJkLFFBQVF5WSxxQkFBcUIsQ0FBQzNYO1lBQ2hDO1FBQ0YsT0FBTyxJQUFJZCxRQUFRMFksd0JBQXdCLEVBQUU7WUFDM0MsT0FBTyxTQUFVNVgsRUFBRTtnQkFDakJkLFFBQVEwWSx3QkFBd0IsQ0FBQzVYO1lBQ25DO1FBQ0YsT0FBTyxJQUFJZCxRQUFRMlksMkJBQTJCLEVBQUU7WUFDOUMsT0FBTyxTQUFVN1gsRUFBRTtnQkFDakJkLFFBQVEyWSwyQkFBMkIsQ0FBQzdYO1lBQ3RDO1FBQ0YsT0FBTyxJQUFJZCxRQUFRNFksdUJBQXVCLEVBQUU7WUFDMUMsT0FBTyxTQUFVOVgsRUFBRTtnQkFDakJkLFFBQVE0WSx1QkFBdUIsQ0FBQzlYO1lBQ2xDO1FBQ0Y7SUFDRjtJQUNBLE9BQU8sU0FBVUEsRUFBRTtRQUNqQixJQUFJQSxJQUFJO1lBQ055VyxXQUFXO2dCQUNUelcsR0FBR3lYO1lBQ0wsR0FBRyxPQUFPO1FBQ1o7SUFDRjtBQUNGO0FBQ0EsSUFBSUUsd0JBQXdCLFNBQVNBLHNCQUFzQjNYLEVBQUU7SUFDM0QsT0FBTzBYLElBQUkxWDtBQUNiO0FBQ0EsSUFBSStYLGlCQUFpQk47QUFFckIsSUFBSU8sb0JBQW9CO0FBQ3hCLElBQUlDLElBQUksT0FBTyw0QkFBNEI7QUFDM0MsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJqYixRQUFRO0lBQ3ZELElBQUlrYixPQUFPblcsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHK1Y7SUFDL0UsbUJBQW1CO0lBQ25CLElBQUlLLE9BQU9EO0lBQ1gsSUFBSUU7SUFDSixPQUFTO1FBQ1BBLFFBQVFwYixTQUFTUyxJQUFJO1FBQ3JCLElBQUkyYSxNQUFNaGIsSUFBSSxFQUFFO1lBQ2Q7UUFDRjtRQUNBK2EsT0FBT0EsT0FBT0osSUFBSUssTUFBTS9hLEtBQUssR0FBRztJQUNsQztJQUNBLE9BQU84YTtBQUNUO0FBQ0EsSUFBSUUsVUFBVSxTQUFTQSxRQUFRQyxHQUFHO0lBQ2hDLElBQUlKLE9BQU9uVyxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUcrVjtJQUMvRSxtQkFBbUI7SUFDbkIsT0FBT0ksT0FBT0gsSUFBSU8sTUFBTTtBQUMxQjtBQUNBLElBQUlDLGFBQWEsU0FBU0EsV0FBV0QsR0FBRztJQUN0QyxJQUFJSixPQUFPblcsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHaVc7SUFDL0UsbUJBQW1CO0lBQ25CLE9BQU8sQ0FBQ0UsUUFBUSxLQUFLQSxPQUFPSSxNQUFNO0FBQ3BDO0FBQ0EsSUFBSUUsZ0JBQWdCLFNBQVNBLGNBQWNDLEtBQUssRUFBRUMsS0FBSztJQUNyRCxPQUFPRCxRQUFRLFdBQVdDO0FBQzVCO0FBQ0EsSUFBSUMscUJBQXFCLFNBQVNBLG1CQUFtQkMsTUFBTTtJQUN6RCxPQUFPQSxNQUFNLENBQUMsRUFBRSxHQUFHLFdBQVdBLE1BQU0sQ0FBQyxFQUFFO0FBQ3pDO0FBQ0EsSUFBSUMsYUFBYSxTQUFTQSxXQUFXQyxPQUFPLEVBQUVDLE9BQU87SUFDbkQsT0FBTztRQUFDVixRQUFRUyxPQUFPLENBQUMsRUFBRSxFQUFFQyxPQUFPLENBQUMsRUFBRTtRQUFHUixXQUFXTyxPQUFPLENBQUMsRUFBRSxFQUFFQyxPQUFPLENBQUMsRUFBRTtLQUFFO0FBQzlFO0FBQ0EsSUFBSUMsZ0JBQWdCLFNBQVNBLGNBQWNDLElBQUksRUFBRWYsSUFBSTtJQUNuRCxJQUFJRSxRQUFRO1FBQ1YvYSxPQUFPO1FBQ1BELE1BQU07SUFDUjtJQUNBLElBQUlZLElBQUk7SUFDUixJQUFJdkMsU0FBU3dkLEtBQUt4ZCxNQUFNO0lBQ3hCLElBQUl1QixXQUFXO1FBQ2JTLE1BQU0sU0FBU0E7WUFDYixJQUFJTyxJQUFJdkMsUUFBUTtnQkFDZDJjLE1BQU0vYSxLQUFLLEdBQUc0YixJQUFJLENBQUNqYixJQUFJO1lBQ3pCLE9BQU87Z0JBQ0xvYSxNQUFNaGIsSUFBSSxHQUFHO1lBQ2Y7WUFDQSxPQUFPZ2I7UUFDVDtJQUNGO0lBQ0EsT0FBT0gsaUJBQWlCamIsVUFBVWtiO0FBQ3BDO0FBQ0EsSUFBSWdCLGFBQWEsU0FBU0EsV0FBV3hXLEdBQUcsRUFBRXdWLElBQUk7SUFDNUMsSUFBSUUsUUFBUTtRQUNWL2EsT0FBTztRQUNQRCxNQUFNO0lBQ1I7SUFDQSxJQUFJWSxJQUFJO0lBQ1IsSUFBSXZDLFNBQVNpSCxJQUFJakgsTUFBTTtJQUN2QixJQUFJdUIsV0FBVztRQUNiUyxNQUFNLFNBQVNBO1lBQ2IsSUFBSU8sSUFBSXZDLFFBQVE7Z0JBQ2QyYyxNQUFNL2EsS0FBSyxHQUFHcUYsSUFBSXlXLFVBQVUsQ0FBQ25iO1lBQy9CLE9BQU87Z0JBQ0xvYSxNQUFNaGIsSUFBSSxHQUFHO1lBQ2Y7WUFDQSxPQUFPZ2I7UUFDVDtJQUNGO0lBQ0EsT0FBT0gsaUJBQWlCamIsVUFBVWtiO0FBQ3BDO0FBQ0EsSUFBSWtCLGNBQWMsU0FBU0E7SUFDekIsT0FBT0MsaUJBQWlCdFg7QUFDMUI7QUFDQSxJQUFJc1gsbUJBQW1CLFNBQVNBLGlCQUFpQkMsSUFBSTtJQUNuRCxJQUFJbkI7SUFDSixJQUFLLElBQUluYSxJQUFJLEdBQUdBLElBQUlzYixLQUFLN2QsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJMEUsTUFBTTRXLElBQUksQ0FBQ3RiLEVBQUU7UUFDakIsSUFBSUEsTUFBTSxHQUFHO1lBQ1htYSxPQUFPZSxXQUFXeFc7UUFDcEIsT0FBTztZQUNMeVYsT0FBT2UsV0FBV3hXLEtBQUt5VjtRQUN6QjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLFNBQVNvQixZQUFZeEosQ0FBQyxFQUFFeUosQ0FBQyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsWUFBWTtJQUN2RCxJQUFJQyxlQUFlRCxlQUFlcFosS0FBS3NaLEVBQUUsR0FBRztJQUM1QyxJQUFJQyxXQUFXdlosS0FBS3daLEdBQUcsQ0FBQ0gsZ0JBQWlCN0osQ0FBQUEsSUFBSTBKLE9BQU0sSUFBS2xaLEtBQUt5WixHQUFHLENBQUNKLGdCQUFpQkosQ0FBQUEsSUFBSUUsT0FBTSxJQUFLRDtJQUNqRyxJQUFJUSxXQUFXMVosS0FBS3laLEdBQUcsQ0FBQ0osZ0JBQWlCN0osQ0FBQUEsSUFBSTBKLE9BQU0sSUFBS2xaLEtBQUt3WixHQUFHLENBQUNILGdCQUFpQkosQ0FBQUEsSUFBSUUsT0FBTSxJQUFLQTtJQUNqRyxPQUFPO1FBQ0wzSixHQUFHK0o7UUFDSE4sR0FBR1M7SUFDTDtBQUNGO0FBQ0EsSUFBSUMsdUJBQXVCLFNBQVNBLHFCQUFxQm5LLENBQUMsRUFBRXlKLENBQUMsRUFBRVcsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUNyRixPQUFPO1FBQ0x2SyxHQUFHLENBQUNBLElBQUlvSyxJQUFHLElBQUtFLFFBQVFGO1FBQ3hCWCxHQUFHLENBQUNBLElBQUlZLElBQUcsSUFBS0UsUUFBUUY7SUFDMUI7QUFDRjtBQUNBLFNBQVNHLHNCQUFzQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVkLFlBQVk7SUFDbkQsSUFBSUEsaUJBQWlCLEdBQUcsT0FBT2E7SUFDL0IsSUFBSWYsVUFBVSxDQUFDZ0IsSUFBSXBaLEVBQUUsR0FBR29aLElBQUluWixFQUFFLElBQUk7SUFDbEMsSUFBSW9ZLFVBQVUsQ0FBQ2UsSUFBSWxaLEVBQUUsR0FBR2taLElBQUlqWixFQUFFLElBQUk7SUFDbEMsSUFBSTZZLFFBQVFJLElBQUlDLENBQUMsR0FBR0QsSUFBSTNWLENBQUM7SUFDekIsSUFBSXdWLFFBQVEsSUFBSUQ7SUFDaEIsSUFBSU0sVUFBVXBCLFlBQVlpQixJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUMsRUFBRUMsU0FBU0MsU0FBU0M7SUFDMUQsSUFBSWlCLFNBQVNWLHFCQUFxQlMsUUFBUTVLLENBQUMsRUFBRTRLLFFBQVFuQixDQUFDLEVBQUVDLFNBQVNDLFNBQVNXLE9BQU9DO0lBQ2pGLE9BQU87UUFDTHZLLEdBQUc2SyxPQUFPN0ssQ0FBQztRQUNYeUosR0FBR29CLE9BQU9wQixDQUFDO0lBQ2I7QUFDRjtBQUVBLElBQUlxQixrQkFBa0I7QUFDdEIsSUFBSUMsZ0JBQWdCQyxRQUFRQyxJQUFJLElBQUk7QUFDcEMsSUFBSUMsaUJBQWlCRixRQUFRRyxLQUFLLElBQUk7QUFDdEMsSUFBSUMsWUFBWUMsT0FBT0MsZ0JBQWdCLElBQUk7QUFDM0MsSUFBSUMsVUFBVSxTQUFTQTtJQUNyQixPQUFPO0FBQ1Q7QUFDQSxJQUFJQyxVQUFVLFNBQVNBO0lBQ3JCLE9BQU87QUFDVDtBQUNBLElBQUlDLFVBQVUsU0FBU0E7SUFDckIsT0FBTztBQUNUO0FBQ0EsSUFBSUMsU0FBUyxTQUFTQyxRQUFRO0FBQzlCLElBQUlDLFFBQVEsU0FBU0EsTUFBTUMsR0FBRztJQUM1QixNQUFNLElBQUluTSxNQUFNbU07QUFDbEI7QUFDQSxJQUFJQyxXQUFXLFNBQVNBLFNBQVNDLE9BQU87SUFDdEMsSUFBSUEsWUFBWXRkLFdBQVc7UUFDekJxYyxrQkFBa0IsQ0FBQyxDQUFDaUI7SUFDdEIsT0FBTztRQUNMLE9BQU9qQjtJQUNUO0FBQ0Y7QUFDQSxJQUFJRyxPQUFPLFNBQVNBLEtBQUtZLEdBQUc7SUFDMUIsSUFBSSxDQUFDQyxZQUFZO1FBQ2Y7SUFDRjtJQUNBLElBQUlmLGVBQWU7UUFDakJDLFFBQVFDLElBQUksQ0FBQ1k7SUFDZixPQUFPO1FBQ0xiLFFBQVFnQixHQUFHLENBQUNIO1FBQ1osSUFBSVgsZ0JBQWdCO1lBQ2xCRixRQUFRRyxLQUFLO1FBQ2Y7SUFDRjtBQUNGO0FBQ0EsSUFBSWMsUUFBUSxTQUFTQSxNQUFNdGMsR0FBRztJQUM1QixPQUFPc0UsT0FBTyxDQUFDLEdBQUd0RTtBQUNwQjtBQUVBLHNDQUFzQztBQUN0QyxJQUFJdWMsT0FBTyxTQUFTQSxLQUFLdmMsR0FBRztJQUMxQixJQUFJQSxPQUFPLE1BQU07UUFDZixPQUFPQTtJQUNUO0lBQ0EsSUFBSUssTUFBTUwsTUFBTTtRQUNkLE9BQU9BLElBQUliLEtBQUs7SUFDbEIsT0FBTyxJQUFJb0IsWUFBWVAsTUFBTTtRQUMzQixPQUFPc2MsTUFBTXRjO0lBQ2YsT0FBTztRQUNMLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLElBQUl3YyxZQUFZLFNBQVNBLFVBQVVDLEdBQUc7SUFDcEMsT0FBT0EsSUFBSXRkLEtBQUs7QUFDbEI7QUFDQSxJQUFJdWQsT0FBTyxTQUFTQSxLQUFLNWdCLENBQUMsRUFBRXNJLEVBQUUsZ0JBQWdCLEdBQWpCO0lBQzNCLElBQ0EsVUFBVTtJQUNWQSxJQUFJdEksSUFBSSxJQUNSLG9DQUFvQztJQUNwQ0EsTUFBTSxJQUNOLEVBQUU7SUFDRnNJLEtBQUt0SSxJQUFJLEtBQUssR0FBRyxvQ0FBb0M7T0FHckQsK0JBRCtCO0lBQzlCQSxDQUFBQSxJQUFJLEdBQUcsbUJBQW1CO09BRTNCLHdDQUF3QztJQUN4QyxJQUFJK0UsS0FBSzhiLE1BQU0sS0FBTTdnQixDQUFBQSxJQUFJLEtBQUssS0FBSyxFQUFHLCtEQUErRDtJQUFsRSxJQUNqQyxFQUFFLGVBQWU7SUFBakIsRUFDQW9ELFFBQVEsQ0FBQyxNQUFNLElBQUksb0RBQW9EOztJQUV6RSxPQUFPa0Y7QUFDVDtBQUNBLElBQUl3WSxxQkFBcUIsQ0FBQztBQUMxQixJQUFJQyxvQkFBb0IsU0FBU0E7SUFDL0IsT0FBT0Q7QUFDVDtBQUNBLElBQUlFLGFBQWEsU0FBU0MsU0FBU0MsU0FBUztJQUMxQyxJQUFJdFksT0FBTzVILE9BQU80SCxJQUFJLENBQUNzWTtJQUN2QixPQUFPLFNBQVVDLElBQUk7UUFDbkIsSUFBSUMsYUFBYSxDQUFDO1FBQ2xCLElBQUssSUFBSTVlLElBQUksR0FBR0EsSUFBSW9HLEtBQUszSSxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUlyQixNQUFNeUgsSUFBSSxDQUFDcEcsRUFBRTtZQUNqQixJQUFJNmUsU0FBU0YsUUFBUSxPQUFPbmUsWUFBWW1lLElBQUksQ0FBQ2hnQixJQUFJO1lBQ2pEaWdCLFVBQVUsQ0FBQ2pnQixJQUFJLEdBQUdrZ0IsV0FBV3JlLFlBQVlrZSxTQUFTLENBQUMvZixJQUFJLEdBQUdrZ0I7UUFDNUQ7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFDQSxJQUFJRSxrQkFBa0IsU0FBU0EsZ0JBQWdCWCxHQUFHLEVBQUVZLEdBQUcsRUFBRUMsT0FBTztJQUM5RCxJQUFLLElBQUloZixJQUFJbWUsSUFBSTFnQixNQUFNLEdBQUcsR0FBR3VDLEtBQUssR0FBR0EsSUFBSztRQUN4QyxJQUFJbWUsR0FBRyxDQUFDbmUsRUFBRSxLQUFLK2UsS0FBSztZQUNsQlosSUFBSWMsTUFBTSxDQUFDamYsR0FBRztRQUNoQjtJQUNGO0FBQ0Y7QUFDQSxJQUFJa2YsYUFBYSxTQUFTQSxXQUFXZixHQUFHO0lBQ3RDQSxJQUFJYyxNQUFNLENBQUMsR0FBR2QsSUFBSTFnQixNQUFNO0FBQzFCO0FBQ0EsSUFBSXdDLE9BQU8sU0FBU0EsS0FBS2tlLEdBQUcsRUFBRWdCLFFBQVE7SUFDcEMsSUFBSyxJQUFJbmYsSUFBSSxHQUFHQSxJQUFJbWYsU0FBUzFoQixNQUFNLEVBQUV1QyxJQUFLO1FBQ3hDLElBQUlvZixLQUFLRCxRQUFRLENBQUNuZixFQUFFO1FBQ3BCbWUsSUFBSWxlLElBQUksQ0FBQ21mO0lBQ1g7QUFDRjtBQUNBLElBQUlDLHNCQUFzQixTQUFTQSxvQkFBb0IzZCxHQUFHLEVBQUU0ZCxRQUFRLEVBQUVyYSxNQUFNO0lBQzFFLElBQUlBLFFBQVE7UUFDVnFhLFdBQVd0YSxhQUFhQyxRQUFRcWEsV0FBVyxnREFBZ0Q7SUFDN0Y7SUFDQSxPQUFPNWQsR0FBRyxDQUFDNGQsU0FBUztBQUN0QjtBQUNBLElBQUlDLHNCQUFzQixTQUFTQSxvQkFBb0I3ZCxHQUFHLEVBQUU0ZCxRQUFRLEVBQUVyYSxNQUFNLEVBQUU1RixLQUFLO0lBQ2pGLElBQUk0RixRQUFRO1FBQ1ZxYSxXQUFXdGEsYUFBYUMsUUFBUXFhLFdBQVcsZ0RBQWdEO0lBQzdGO0lBQ0E1ZCxHQUFHLENBQUM0ZCxTQUFTLEdBQUdqZ0I7QUFDbEI7QUFFQSxjQUFjLEdBQ2QsSUFBSW1nQixZQUFZLFdBQVcsR0FBRTtJQUMzQixTQUFTQTtRQUNQeGhCLGdCQUFnQixJQUFJLEVBQUV3aEI7UUFDdEIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQztJQUNmO0lBQ0EsT0FBTzdnQixhQUFhNGdCLFdBQVc7UUFBQztZQUM5QjdnQixLQUFLO1lBQ0xVLE9BQU8sU0FBU3FnQixJQUFJL2dCLEdBQUcsRUFBRWdoQixHQUFHO2dCQUMxQixJQUFJLENBQUNGLElBQUksQ0FBQzlnQixJQUFJLEdBQUdnaEI7Z0JBQ2pCLE9BQU8sSUFBSTtZQUNiO1FBQ0Y7UUFBRztZQUNEaGhCLEtBQUs7WUFDTFUsT0FBTyxTQUFTdWdCLFFBQVFqaEIsR0FBRztnQkFDekIsSUFBSSxDQUFDOGdCLElBQUksQ0FBQzlnQixJQUFJLEdBQUc2QjtnQkFDakIsT0FBTyxJQUFJO1lBQ2I7UUFDRjtRQUFHO1lBQ0Q3QixLQUFLO1lBQ0xVLE9BQU8sU0FBU3dnQjtnQkFDZCxJQUFJLENBQUNKLElBQUksR0FBRyxDQUFDO1lBQ2Y7UUFDRjtRQUFHO1lBQ0Q5Z0IsS0FBSztZQUNMVSxPQUFPLFNBQVN5Z0IsSUFBSW5oQixHQUFHO2dCQUNyQixPQUFPLElBQUksQ0FBQzhnQixJQUFJLENBQUM5Z0IsSUFBSSxLQUFLNkI7WUFDNUI7UUFDRjtRQUFHO1lBQ0Q3QixLQUFLO1lBQ0xVLE9BQU8sU0FBUzBnQixJQUFJcGhCLEdBQUc7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDOGdCLElBQUksQ0FBQzlnQixJQUFJO1lBQ3ZCO1FBQ0Y7S0FBRTtBQUNKO0FBQ0EsSUFBSXFoQixRQUFRLE9BQU9DLFFBQVEsY0FBY0EsTUFBTVQ7QUFFL0MsY0FBYyxHQUVkLElBQUlVLFFBQVE7QUFDWixJQUFJQyxZQUFZLFdBQVcsR0FBRTtJQUMzQixTQUFTQSxVQUFVQyxnQkFBZ0I7UUFDakNwaUIsZ0JBQWdCLElBQUksRUFBRW1pQjtRQUN0QixJQUFJLENBQUNWLElBQUksR0FBR2poQixPQUFPNmhCLE1BQU0sQ0FBQztRQUMxQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUlGLG9CQUFvQixNQUFNO1lBQzVCLElBQUlqQztZQUNKLElBQUlpQyxpQkFBaUJ6ZSxjQUFjLElBQUksUUFBUXllLGlCQUFpQnplLGNBQWMsT0FBTyxJQUFJLENBQUNBLGNBQWMsSUFBSTtnQkFDMUd3YyxNQUFNaUMsaUJBQWlCRyxPQUFPO1lBQ2hDLE9BQU87Z0JBQ0xwQyxNQUFNaUM7WUFDUjtZQUNBLElBQUssSUFBSXBnQixJQUFJLEdBQUdBLElBQUltZSxJQUFJMWdCLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ25DLElBQUksQ0FBQ3dnQixHQUFHLENBQUNyQyxHQUFHLENBQUNuZSxFQUFFO1lBQ2pCO1FBQ0Y7SUFDRjtJQUNBLE9BQU9wQixhQUFhdWhCLFdBQVc7UUFBQztZQUM5QnhoQixLQUFLO1lBQ0xVLE9BQU8sU0FBU3NDO2dCQUNkLE9BQU87WUFDVDtRQUNGO1FBQUc7WUFDRGhELEtBQUs7WUFDTFUsT0FBTyxTQUFTbWhCLElBQUliLEdBQUc7Z0JBQ3JCLElBQUl2aEIsSUFBSSxJQUFJLENBQUNxaEIsSUFBSTtnQkFDakIsSUFBSXJoQixDQUFDLENBQUN1aEIsSUFBSSxLQUFLLEdBQUc7b0JBQ2hCdmhCLENBQUMsQ0FBQ3VoQixJQUFJLEdBQUc7b0JBQ1QsSUFBSSxDQUFDVyxJQUFJO2dCQUNYO1lBQ0Y7UUFDRjtRQUFHO1lBQ0QzaEIsS0FBSztZQUNMVSxPQUFPLFNBQVN1Z0IsUUFBUUQsR0FBRztnQkFDekIsSUFBSXZoQixJQUFJLElBQUksQ0FBQ3FoQixJQUFJO2dCQUNqQixJQUFJcmhCLENBQUMsQ0FBQ3VoQixJQUFJLEtBQUssR0FBRztvQkFDaEJ2aEIsQ0FBQyxDQUFDdWhCLElBQUksR0FBRztvQkFDVCxJQUFJLENBQUNXLElBQUk7Z0JBQ1g7WUFDRjtRQUNGO1FBQUc7WUFDRDNoQixLQUFLO1lBQ0xVLE9BQU8sU0FBU3dnQjtnQkFDZCxJQUFJLENBQUNKLElBQUksR0FBR2poQixPQUFPNmhCLE1BQU0sQ0FBQztZQUM1QjtRQUNGO1FBQUc7WUFDRDFoQixLQUFLO1lBQ0xVLE9BQU8sU0FBU3lnQixJQUFJSCxHQUFHO2dCQUNyQixPQUFPLElBQUksQ0FBQ0YsSUFBSSxDQUFDRSxJQUFJLEtBQUs7WUFDNUI7UUFDRjtRQUFHO1lBQ0RoaEIsS0FBSztZQUNMVSxPQUFPLFNBQVNraEI7Z0JBQ2QsSUFBSUUsUUFBUSxJQUFJO2dCQUNoQixPQUFPamlCLE9BQU80SCxJQUFJLENBQUMsSUFBSSxDQUFDcVosSUFBSSxFQUFFaUIsTUFBTSxDQUFDLFNBQVUvaEIsR0FBRztvQkFDaEQsT0FBTzhoQixNQUFNWCxHQUFHLENBQUNuaEI7Z0JBQ25CO1lBQ0Y7UUFDRjtRQUFHO1lBQ0RBLEtBQUs7WUFDTFUsT0FBTyxTQUFTc2hCLFFBQVFDLFFBQVEsRUFBRXZJLE9BQU87Z0JBQ3ZDLE9BQU8sSUFBSSxDQUFDa0ksT0FBTyxHQUFHSSxPQUFPLENBQUNDLFVBQVV2STtZQUMxQztRQUNGO0tBQUU7QUFDSjtBQUNBLElBQUl3SSxRQUFRLENBQUMsT0FBT0MsUUFBUSxjQUFjLGNBQWNwZ0IsUUFBUW9nQixJQUFHLE1BQU9aLFFBQVFZLE1BQU1YO0FBRXhGLCtCQUErQjtBQUMvQixJQUFJWSxVQUFVLFNBQVNBLFFBQVFDLEVBQUUsRUFBRUMsTUFBTTtJQUN2QyxJQUFJQyxVQUFVbmQsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2xGLElBQUlpZCxPQUFPeGdCLGFBQWF5Z0IsV0FBV3pnQixhQUFhLENBQUNzQyxLQUFLa2UsS0FBSztRQUN6RHJELE1BQU07UUFDTjtJQUNGO0lBQ0EsSUFBSXdELFFBQVFGLE9BQU9FLEtBQUs7SUFFeEIsc0RBQXNEO0lBQ3RELElBQUlBLFNBQVMsTUFBTTtRQUNqQixJQUFJRixPQUFPRyxJQUFJLElBQUlILE9BQU9HLElBQUksQ0FBQ0MsTUFBTSxJQUFJLFFBQVFKLE9BQU9HLElBQUksQ0FBQ0UsTUFBTSxJQUFJLE1BQU07WUFDM0VILFFBQVE7UUFDVixPQUFPO1lBQ0xBLFFBQVE7UUFDVjtJQUNGO0lBRUEsaUJBQWlCO0lBQ2pCLElBQUlBLFVBQVUsV0FBV0EsVUFBVSxTQUFTO1FBQzFDeEQsTUFBTSxtRUFBbUV3RCxRQUFRO1FBQ2pGO0lBQ0Y7SUFFQSxzREFBc0Q7SUFDdEQsSUFBSSxDQUFDMWpCLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSTtJQUVkLDZEQUE2RDtJQUM3RCxJQUFJOGpCLEtBQUssSUFBSSxDQUFDM2UsUUFBUSxHQUFHO1FBQ3ZCb2UsSUFBSUE7UUFDSm5lLFFBQVE7UUFDUiwrQkFBK0I7UUFDL0J1ZSxNQUFNSCxPQUFPRyxJQUFJLElBQUksQ0FBQztRQUN0QixjQUFjO1FBQ2RJLFVBQVVQLE9BQU9PLFFBQVEsSUFBSTtZQUMzQnpQLEdBQUc7WUFDSHlKLEdBQUc7UUFDTDtRQUNBLHVCQUF1QjtRQUN2QmlHLFdBQVdqaEI7UUFDWCx3RkFBd0Y7UUFDeEZraEIsWUFBWWxoQjtRQUNabWhCLGFBQWFuaEI7UUFDYm9oQixxQkFBcUI7UUFDckIsNEZBQTRGO1FBQzVGQyxXQUFXLEVBQUU7UUFDYiwyQkFBMkI7UUFDM0JWLE9BQU9BO1FBQ1AsNkJBQTZCO1FBQzdCVyxPQUFPLENBQUM7UUFDUixpQ0FBaUM7UUFDakNDLFFBQVEsQ0FBQztRQUNULDBEQUEwRDtRQUMxREMsV0FBVyxFQUFFO1FBQ2IseUNBQXlDO1FBQ3pDQyxXQUFXLENBQUM7UUFDWiwwQ0FBMEM7UUFDMUNDLFNBQVM7UUFDVCxxRkFBcUY7UUFDckZDLFVBQVVsQixPQUFPa0IsUUFBUSxHQUFHLE9BQU87UUFDbkMsd0JBQXdCO1FBQ3hCQyxZQUFZbkIsT0FBT21CLFVBQVUsS0FBSzVoQixZQUFZLE9BQU95Z0IsT0FBT21CLFVBQVUsR0FBRyxPQUFPO1FBQ2hGLDBCQUEwQjtRQUMxQkMsUUFBUXBCLE9BQU9vQixNQUFNLEdBQUcsT0FBTztRQUMvQixrREFBa0Q7UUFDbERDLFNBQVM7UUFDVCw0RUFBNEU7UUFDNUVDLFdBQVd0QixPQUFPc0IsU0FBUyxLQUFLL2hCLFlBQVksT0FBT3lnQixPQUFPc0IsU0FBUyxHQUFHLE9BQU87UUFDN0UscUNBQXFDO1FBQ3JDQyxVQUFVdkIsT0FBT3VCLFFBQVEsS0FBS2hpQixZQUFZMmdCLFVBQVUsVUFBVSxPQUFPLFFBQVFGLE9BQU91QixRQUFRLEdBQUcsT0FBTztRQUN0RyxzREFBc0Q7UUFDdERDLFFBQVE7UUFDUixzREFBc0Q7UUFDdERDLFNBQVMsSUFBSTdCO1FBQ2IsNEJBQTRCO1FBQzVCOEIsV0FBVztZQUNULDBDQUEwQztZQUMxQ0MsU0FBUyxFQUFFO1lBQ1hDLE9BQU8sRUFBRTtRQUNYO1FBQ0FDLFVBQVUsQ0FBQztRQUNYLHFEQUFxRDtRQUNyREMsU0FBUzlCLE9BQU84QixPQUFPLElBQUksQ0FBQztRQUM1QixrQkFBa0I7UUFDbEJDLE9BQU8sRUFBRTtRQUNULDJCQUEyQjtRQUMzQkMsVUFBVSxFQUFFO1FBQ1osb0JBQW9CO1FBQ3BCQyxRQUFRakMsT0FBT2lDLE1BQU0sSUFBSWpDLE9BQU9pQyxNQUFNLENBQUNDLE1BQU0sS0FBS2xDLE9BQU9pQyxNQUFNLEdBQUc7UUFDbEUsYUFBYTtRQUNiRSxnQkFBZ0IsQ0FBQztRQUNqQix5Q0FBeUM7UUFDekNDLGVBQWU7UUFDZix3Q0FBd0M7UUFDeENDLFNBQVM7UUFDVCxvQ0FBb0M7UUFDcENDLGNBQWM7WUFDWnhSLEdBQUc7WUFDSHlKLEdBQUc7UUFDTDtRQUNBLHVEQUF1RDtRQUN2RGdJLFlBQVk7UUFDWiw0Q0FBNEM7UUFDNUNDLGVBQWU7UUFDZixrREFBa0Q7UUFDbERDLGFBQWE7WUFDWCx5QkFBeUI7WUFDekJDLEtBQUs7WUFDTHRDLFFBQVE7WUFDUkMsUUFBUTtZQUNSc0MsTUFBTTtRQUNSO1FBQ0FDLGFBQWE7WUFDWCw4QkFBOEI7WUFDOUJ4QyxRQUFRO1lBQ1JDLFFBQVE7WUFDUixjQUFjO1lBQ2QsY0FBYztRQUNoQjtJQUNGO0lBQ0EsSUFBSUMsR0FBR0MsUUFBUSxDQUFDelAsQ0FBQyxJQUFJLE1BQU07UUFDekJ3UCxHQUFHQyxRQUFRLENBQUN6UCxDQUFDLEdBQUc7SUFDbEI7SUFDQSxJQUFJd1AsR0FBR0MsUUFBUSxDQUFDaEcsQ0FBQyxJQUFJLE1BQU07UUFDekIrRixHQUFHQyxRQUFRLENBQUNoRyxDQUFDLEdBQUc7SUFDbEI7SUFFQSwwQ0FBMEM7SUFDMUMsSUFBSXlGLE9BQU82QyxnQkFBZ0IsRUFBRTtRQUMzQixJQUFJQyxPQUFPOUMsT0FBTzZDLGdCQUFnQjtRQUNsQyxJQUFJRSxNQUFNaEQsR0FBR2dELEdBQUc7UUFDaEIsSUFBSUMsT0FBT2pELEdBQUdpRCxJQUFJO1FBQ2xCMUMsR0FBR0MsUUFBUSxHQUFHO1lBQ1p6UCxHQUFHLENBQUNnUyxLQUFLaFMsQ0FBQyxHQUFHaVMsSUFBSWpTLENBQUMsSUFBSWtTO1lBQ3RCekksR0FBRyxDQUFDdUksS0FBS3ZJLENBQUMsR0FBR3dJLElBQUl4SSxDQUFDLElBQUl5STtRQUN4QjtJQUNGO0lBQ0EsSUFBSXZCLFVBQVUsRUFBRTtJQUNoQixJQUFJM2dCLE1BQU1rZixPQUFPeUIsT0FBTyxHQUFHO1FBQ3pCQSxVQUFVekIsT0FBT3lCLE9BQU87SUFDMUIsT0FBTyxJQUFJN2dCLE9BQU9vZixPQUFPeUIsT0FBTyxHQUFHO1FBQ2pDQSxVQUFVekIsT0FBT3lCLE9BQU8sQ0FBQ3dCLEtBQUssQ0FBQztJQUNqQztJQUNBLElBQUssSUFBSWxrQixJQUFJLEdBQUdELElBQUkyaUIsUUFBUWpsQixNQUFNLEVBQUV1QyxJQUFJRCxHQUFHQyxJQUFLO1FBQzlDLElBQUlta0IsTUFBTXpCLE9BQU8sQ0FBQzFpQixFQUFFO1FBQ3BCLElBQUksQ0FBQ21rQixPQUFPQSxRQUFRLElBQUk7WUFDdEI7UUFDRjtRQUNBNUMsR0FBR21CLE9BQU8sQ0FBQ2xDLEdBQUcsQ0FBQzJEO0lBQ2pCO0lBQ0EsSUFBSSxDQUFDQyxhQUFhO0lBQ2xCLElBQUlsRCxZQUFZMWdCLGFBQWEwZ0IsU0FBUztRQUNwQyxJQUFJLENBQUNBLE9BQU87SUFDZDtJQUNBLElBQUltRCxTQUFTcEQsT0FBT2EsS0FBSyxJQUFJYixPQUFPcUQsR0FBRztJQUN2QyxJQUFJRCxRQUFRO1FBQ1ZySCxLQUFLO1FBQ0wsSUFBSSxDQUFDOEUsS0FBSyxDQUFDdUM7SUFDYjtBQUNGO0FBRUEsSUFBSUUsZUFBZSxTQUFTQSxhQUFhdEQsTUFBTTtJQUM3Q0EsU0FBUztRQUNQdUQsS0FBS3ZELE9BQU91RCxHQUFHLElBQUksQ0FBQ3ZELE9BQU93RCxHQUFHO1FBQzlCQSxLQUFLeEQsT0FBT3dELEdBQUcsSUFBSSxDQUFDeEQsT0FBT3VELEdBQUc7SUFDaEM7SUFFQSwrQkFBK0I7SUFDL0IsT0FBTyxTQUFTRSxTQUFTQyxLQUFLLEVBQUU3aUIsRUFBRSxFQUFFOGlCLFFBQVE7UUFDMUMsSUFBSXJUO1FBQ0osSUFBSXRQLFlBQVkwaUIsVUFBVSxDQUFDM2lCLG9CQUFvQjJpQixRQUFRO1lBQ3JEcFQsVUFBVW9UO1lBQ1ZBLFFBQVFwVCxRQUFRb1QsS0FBSyxJQUFJcFQsUUFBUXdCLElBQUk7WUFDckNqUixLQUFLeVAsUUFBUXNULEtBQUs7WUFDbEJELFdBQVdyVCxRQUFRcVQsUUFBUTtRQUM3QjtRQUNBQSxXQUFXN2dCLFVBQVV0RyxNQUFNLEtBQUssS0FBSyxDQUFDbUUsS0FBS0UsTUFBTUEsS0FBSzhpQjtRQUN0RDlpQixLQUFLRixLQUFLRSxNQUFNQSxLQUFLLFlBQWE7UUFDbEMsSUFBSWtmLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtRQUN6QixJQUFJcGMsSUFBSStmLFFBQVE5aUIsT0FBTzhpQixTQUFTLElBQUksQ0FBQ2pFLE1BQU0sQ0FBQ2lFLFNBQVNBO1FBQ3JELElBQUlHLElBQUksRUFBRTtRQUNWLElBQUlDLGlCQUFpQixFQUFFO1FBQ3ZCLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJQyxXQUFXLENBQUM7UUFDaEIsSUFBSUMsSUFBSSxDQUFDO1FBQ1QsSUFBSTdlLElBQUk7UUFDUixJQUFJOGU7UUFDSixJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDQyxPQUFPLElBQzlCQyxRQUFRRixjQUFjRSxLQUFLLEVBQzNCdEMsUUFBUW9DLGNBQWNwQyxLQUFLO1FBRTdCLFlBQVk7UUFDWixJQUFLLElBQUloakIsSUFBSSxHQUFHQSxJQUFJNEUsRUFBRW5ILE1BQU0sRUFBRXVDLElBQUs7WUFDakMsSUFBSXVsQixLQUFLM2dCLENBQUMsQ0FBQzVFLEVBQUU7WUFDYixJQUFJd2xCLE9BQU9ELEdBQUdFLEVBQUU7WUFDaEIsSUFBSUYsR0FBR3BDLE1BQU0sSUFBSTtnQkFDZjJCLEVBQUVZLE9BQU8sQ0FBQ0g7Z0JBQ1YsSUFBSXRFLE9BQU91RCxHQUFHLEVBQUU7b0JBQ2RVLENBQUMsQ0FBQ00sS0FBSyxHQUFHO29CQUNWVCxlQUFlOWtCLElBQUksQ0FBQ3NsQjtnQkFDdEI7Z0JBQ0FOLFFBQVEsQ0FBQ08sS0FBSyxHQUFHO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJRyxRQUFRLFNBQVNBO1lBQ2pCLElBQUkvZ0IsSUFBSXFjLE9BQU91RCxHQUFHLEdBQUdNLEVBQUVjLEtBQUssS0FBS2QsRUFBRWUsR0FBRztZQUN0QyxJQUFJQyxNQUFNbGhCLEVBQUU2Z0IsRUFBRTtZQUNkLElBQUl4RSxPQUFPd0QsR0FBRyxFQUFFO2dCQUNkLElBQUlTLENBQUMsQ0FBQ1ksSUFBSSxFQUFFO29CQUNWLE9BQU8sR0FBRyxXQUFXO2dCQUN2QjtnQkFDQVosQ0FBQyxDQUFDWSxJQUFJLEdBQUc7Z0JBQ1RmLGVBQWU5a0IsSUFBSSxDQUFDMkU7WUFDdEI7WUFDQSxJQUFJbWhCLFFBQVFkLFFBQVEsQ0FBQ2EsSUFBSTtZQUN6QixJQUFJRSxXQUFXaEIsV0FBVyxDQUFDYyxJQUFJO1lBQy9CLElBQUlHLE1BQU1ELFlBQVksT0FBT0EsU0FBUzNFLE1BQU0sS0FBSztZQUNqRCxJQUFJbGIsTUFBTTZmLFlBQVksT0FBT0EsU0FBUzFFLE1BQU0sS0FBSztZQUNqRCxJQUFJNEUsV0FBV0YsWUFBWSxPQUFPeGxCLFlBQVlvRSxFQUFFdWhCLElBQUksQ0FBQ0YsT0FBTzlmLEdBQUcsQ0FBQyxFQUFFLEdBQUc4ZixHQUFHLENBQUMsRUFBRTtZQUMzRSxJQUFJNWhCO1lBQ0pBLE1BQU12QyxHQUFHOEMsR0FBR29oQixVQUFVRSxVQUFVN2YsS0FBSzBmO1lBQ3JDLElBQUkxaEIsUUFBUSxNQUFNO2dCQUNoQjhnQixRQUFRdmdCO2dCQUNSLE9BQU8sR0FBRyxRQUFRO1lBQ3BCO1lBQ0EsSUFBSVAsUUFBUSxPQUFPO2dCQUNqQixPQUFPLEdBQUcsUUFBUTtZQUNwQjtZQUNBLElBQUkraEIsVUFBVXhoQixFQUFFeWhCLGNBQWMsR0FBRzNGLE1BQU0sQ0FBQyxTQUFVaGpCLENBQUM7Z0JBQ2pELE9BQU8sQ0FBQyxDQUFDa25CLFlBQVlsbkIsRUFBRTJqQixNQUFNLEdBQUc4RSxJQUFJLENBQUN2aEIsRUFBQyxLQUFNb2UsTUFBTWxELEdBQUcsQ0FBQ3BpQjtZQUN4RDtZQUNBLElBQUssSUFBSTRvQixNQUFNLEdBQUdBLE1BQU1GLFFBQVEzb0IsTUFBTSxFQUFFNm9CLE1BQU87Z0JBQzdDLElBQUk1b0IsSUFBSTBvQixPQUFPLENBQUNFLElBQUk7Z0JBQ3BCLElBQUk1SixJQUFJaGYsRUFBRXFuQixjQUFjLEdBQUdyRSxNQUFNLENBQUMsU0FBVS9pQixDQUFDO29CQUMzQyxPQUFPLENBQUNBLEVBQUV3b0IsSUFBSSxDQUFDdmhCLE1BQU0wZ0IsTUFBTXhGLEdBQUcsQ0FBQ25pQjtnQkFDakM7Z0JBQ0EsSUFBSTRvQixNQUFNN0osRUFBRStJLEVBQUU7Z0JBQ2QsSUFBSS9JLEVBQUVqZixNQUFNLEtBQUssS0FBSyxDQUFDeW5CLENBQUMsQ0FBQ3FCLElBQUksRUFBRTtvQkFDN0I3SixJQUFJQSxDQUFDLENBQUMsRUFBRTtvQkFDUm9JLEVBQUU3a0IsSUFBSSxDQUFDeWM7b0JBQ1AsSUFBSXVFLE9BQU91RCxHQUFHLEVBQUU7d0JBQ2RVLENBQUMsQ0FBQ3FCLElBQUksR0FBRzt3QkFDVHhCLGVBQWU5a0IsSUFBSSxDQUFDeWM7b0JBQ3RCO29CQUNBc0ksV0FBVyxDQUFDdUIsSUFBSSxHQUFHN29CO29CQUNuQnVuQixRQUFRLENBQUNzQixJQUFJLEdBQUd0QixRQUFRLENBQUNhLElBQUksR0FBRztnQkFDbEM7WUFDRjtRQUNGLEdBQ0FVO1FBQ0YsTUFBTzFCLEVBQUVybkIsTUFBTSxLQUFLLEVBQUc7WUFDckIrb0IsT0FBT2I7WUFDUCxJQUFJYSxTQUFTLEdBQUc7WUFDaEIsSUFBSUEsU0FBUyxHQUFHO1FBQ2xCO1FBQ0EsSUFBSUMsZ0JBQWdCekYsR0FBR3JlLFVBQVU7UUFDakMsSUFBSyxJQUFJK2pCLEtBQUssR0FBR0EsS0FBSzNCLGVBQWV0bkIsTUFBTSxFQUFFaXBCLEtBQU07WUFDakQsSUFBSUMsT0FBTzVCLGNBQWMsQ0FBQzJCLEdBQUc7WUFDN0IsSUFBSUUsT0FBTzVCLFdBQVcsQ0FBQzJCLEtBQUtsQixFQUFFLEdBQUc7WUFDakMsSUFBSW1CLFFBQVEsTUFBTTtnQkFDaEJILGNBQWN4bUIsSUFBSSxDQUFDMm1CO1lBQ3JCO1lBQ0FILGNBQWN4bUIsSUFBSSxDQUFDMG1CO1FBQ3JCO1FBQ0EsT0FBTztZQUNMRSxNQUFNN0YsR0FBR3JlLFVBQVUsQ0FBQzhqQjtZQUNwQnRCLE9BQU9uRSxHQUFHcmUsVUFBVSxDQUFDd2lCO1FBQ3ZCO0lBQ0Y7QUFDRjtBQUVBLDhCQUE4QjtBQUM5QixJQUFJMkIsV0FBVztJQUNiQyxvQkFBb0J4QyxhQUFhO1FBQy9CQyxLQUFLO0lBQ1A7SUFDQXdDLGtCQUFrQnpDLGFBQWE7UUFDN0JFLEtBQUs7SUFDUDtBQUNGO0FBRUEsaUNBQWlDO0FBQ2pDcUMsU0FBU3RDLEdBQUcsR0FBR3NDLFNBQVNDLGtCQUFrQjtBQUMxQ0QsU0FBU3JDLEdBQUcsR0FBR3FDLFNBQVNFLGdCQUFnQjtBQUV4QyxJQUFJQyxTQUFTO0lBQUNDLFNBQVMsQ0FBQztBQUFDO0FBRXpCLElBQUlDLFNBQVNGLE9BQU9DLE9BQU87QUFFM0IsSUFBSUU7QUFFSixTQUFTQztJQUNSLElBQUlELG1CQUFtQixPQUFPSCxPQUFPQyxPQUFPO0lBQzVDRSxvQkFBb0I7SUFDbkIsVUFBVUUsTUFBTSxFQUFFSixPQUFPO1FBQ3pCLGtDQUFrQztRQUNqQztZQUNDLElBQUlLLE1BQU1DLFlBQVlobEIsT0FBT2lsQixTQUFTQyxTQUFTQyxVQUFVQyxhQUFhQyxhQUFhQyxRQUFReFEsS0FBS3lRLFVBQVVDLFdBQVdDLFlBQVlDLFdBQVdDO1lBRTVJM2xCLFFBQVFELEtBQUtDLEtBQUssRUFBRThVLE1BQU0vVSxLQUFLK1UsR0FBRztZQUdsQzs7S0FFQyxHQUVEa1EsYUFBYSxTQUFTelYsQ0FBQyxFQUFFeUosQ0FBQztnQkFDeEIsSUFBSXpKLElBQUl5SixHQUFHO29CQUNULE9BQU8sQ0FBQztnQkFDVjtnQkFDQSxJQUFJekosSUFBSXlKLEdBQUc7b0JBQ1QsT0FBTztnQkFDVDtnQkFDQSxPQUFPO1lBQ1Q7WUFHQTs7Ozs7OztLQU9DLEdBRURzTSxTQUFTLFNBQVN0cUIsQ0FBQyxFQUFFdVUsQ0FBQyxFQUFFcVcsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEdBQUc7Z0JBQ2pDLElBQUlDO2dCQUNKLElBQUlILE1BQU0sTUFBTTtvQkFDZEEsS0FBSztnQkFDUDtnQkFDQSxJQUFJRSxPQUFPLE1BQU07b0JBQ2ZBLE1BQU1kO2dCQUNSO2dCQUNBLElBQUlZLEtBQUssR0FBRztvQkFDVixNQUFNLElBQUkzVyxNQUFNO2dCQUNsQjtnQkFDQSxJQUFJNFcsTUFBTSxNQUFNO29CQUNkQSxLQUFLN3FCLEVBQUVDLE1BQU07Z0JBQ2Y7Z0JBQ0EsTUFBTzJxQixLQUFLQyxHQUFJO29CQUNkRSxNQUFNL2xCLE1BQU0sQ0FBQzRsQixLQUFLQyxFQUFDLElBQUs7b0JBQ3hCLElBQUlDLElBQUl2VyxHQUFHdlUsQ0FBQyxDQUFDK3FCLElBQUksSUFBSSxHQUFHO3dCQUN0QkYsS0FBS0U7b0JBQ1AsT0FBTzt3QkFDTEgsS0FBS0csTUFBTTtvQkFDYjtnQkFDRjtnQkFDQSxPQUFRLEVBQUUsQ0FBQ3RKLE1BQU0sQ0FBQzFhLEtBQUssQ0FBQy9HLEdBQUc7b0JBQUM0cUI7b0JBQUlBLEtBQUtBO2lCQUFHLENBQUNJLE1BQU0sQ0FBQ3pXLEtBQUtBO1lBQ3ZEO1lBR0E7O0tBRUMsR0FFRDRWLFdBQVcsU0FBUzVsQixLQUFLLEVBQUUwbUIsSUFBSSxFQUFFSCxHQUFHO2dCQUNsQyxJQUFJQSxPQUFPLE1BQU07b0JBQ2ZBLE1BQU1kO2dCQUNSO2dCQUNBemxCLE1BQU05QixJQUFJLENBQUN3b0I7Z0JBQ1gsT0FBT1AsVUFBVW5tQixPQUFPLEdBQUdBLE1BQU10RSxNQUFNLEdBQUcsR0FBRzZxQjtZQUMvQztZQUdBOztLQUVDLEdBRURaLFVBQVUsU0FBUzNsQixLQUFLLEVBQUV1bUIsR0FBRztnQkFDM0IsSUFBSUksU0FBU0M7Z0JBQ2IsSUFBSUwsT0FBTyxNQUFNO29CQUNmQSxNQUFNZDtnQkFDUjtnQkFDQWtCLFVBQVUzbUIsTUFBTThqQixHQUFHO2dCQUNuQixJQUFJOWpCLE1BQU10RSxNQUFNLEVBQUU7b0JBQ2hCa3JCLGFBQWE1bUIsS0FBSyxDQUFDLEVBQUU7b0JBQ3JCQSxLQUFLLENBQUMsRUFBRSxHQUFHMm1CO29CQUNYUCxRQUFRcG1CLE9BQU8sR0FBR3VtQjtnQkFDcEIsT0FBTztvQkFDTEssYUFBYUQ7Z0JBQ2Y7Z0JBQ0EsT0FBT0M7WUFDVDtZQUdBOzs7Ozs7Ozs7S0FTQyxHQUVEZCxjQUFjLFNBQVM5bEIsS0FBSyxFQUFFMG1CLElBQUksRUFBRUgsR0FBRztnQkFDckMsSUFBSUs7Z0JBQ0osSUFBSUwsT0FBTyxNQUFNO29CQUNmQSxNQUFNZDtnQkFDUjtnQkFDQW1CLGFBQWE1bUIsS0FBSyxDQUFDLEVBQUU7Z0JBQ3JCQSxLQUFLLENBQUMsRUFBRSxHQUFHMG1CO2dCQUNYTixRQUFRcG1CLE9BQU8sR0FBR3VtQjtnQkFDbEIsT0FBT0s7WUFDVDtZQUdBOztLQUVDLEdBRURmLGNBQWMsU0FBUzdsQixLQUFLLEVBQUUwbUIsSUFBSSxFQUFFSCxHQUFHO2dCQUNyQyxJQUFJTTtnQkFDSixJQUFJTixPQUFPLE1BQU07b0JBQ2ZBLE1BQU1kO2dCQUNSO2dCQUNBLElBQUl6bEIsTUFBTXRFLE1BQU0sSUFBSTZxQixJQUFJdm1CLEtBQUssQ0FBQyxFQUFFLEVBQUUwbUIsUUFBUSxHQUFHO29CQUMzQ0csT0FBTzt3QkFBQzdtQixLQUFLLENBQUMsRUFBRTt3QkFBRTBtQjtxQkFBSyxFQUFFQSxPQUFPRyxJQUFJLENBQUMsRUFBRSxFQUFFN21CLEtBQUssQ0FBQyxFQUFFLEdBQUc2bUIsSUFBSSxDQUFDLEVBQUU7b0JBQzNEVCxRQUFRcG1CLE9BQU8sR0FBR3VtQjtnQkFDcEI7Z0JBQ0EsT0FBT0c7WUFDVDtZQUdBOztLQUVDLEdBRURoQixVQUFVLFNBQVMxbEIsS0FBSyxFQUFFdW1CLEdBQUc7Z0JBQzNCLElBQUl0b0IsR0FBRzBtQixJQUFJbUMsTUFBTUMsT0FBT0MsVUFBVUM7Z0JBQ2xDLElBQUlWLE9BQU8sTUFBTTtvQkFDZkEsTUFBTWQ7Z0JBQ1I7Z0JBQ0FzQixRQUFRLENBQUM7b0JBQ1BFLFlBQVksRUFBRTtvQkFDZCxJQUFLLElBQUlDLEtBQUssR0FBR0wsT0FBT3BtQixNQUFNVCxNQUFNdEUsTUFBTSxHQUFHLElBQUksS0FBS21yQixPQUFPSyxLQUFLTCxPQUFPSyxLQUFLTCxNQUFNLEtBQUtBLE9BQU9LLE9BQU9BLEtBQUs7d0JBQUVELFVBQVUvb0IsSUFBSSxDQUFDZ3BCO29CQUFLO29CQUNsSSxPQUFPRDtnQkFDVCxHQUFHemtCLEtBQUssQ0FBQyxJQUFJLEVBQUUya0IsT0FBTztnQkFDdEJILFdBQVcsRUFBRTtnQkFDYixJQUFLckMsS0FBSyxHQUFHbUMsT0FBT0MsTUFBTXJyQixNQUFNLEVBQUVpcEIsS0FBS21DLE1BQU1uQyxLQUFNO29CQUNqRDFtQixJQUFJOG9CLEtBQUssQ0FBQ3BDLEdBQUc7b0JBQ2JxQyxTQUFTOW9CLElBQUksQ0FBQ2tvQixRQUFRcG1CLE9BQU8vQixHQUFHc29CO2dCQUNsQztnQkFDQSxPQUFPUztZQUNUO1lBR0E7OztLQUdDLEdBRURkLGFBQWEsU0FBU2xtQixLQUFLLEVBQUUwbUIsSUFBSSxFQUFFSCxHQUFHO2dCQUNwQyxJQUFJOUw7Z0JBQ0osSUFBSThMLE9BQU8sTUFBTTtvQkFDZkEsTUFBTWQ7Z0JBQ1I7Z0JBQ0FoTCxNQUFNemEsTUFBTW9uQixPQUFPLENBQUNWO2dCQUNwQixJQUFJak0sUUFBUSxDQUFDLEdBQUc7b0JBQ2Q7Z0JBQ0Y7Z0JBQ0EwTCxVQUFVbm1CLE9BQU8sR0FBR3lhLEtBQUs4TDtnQkFDekIsT0FBT0gsUUFBUXBtQixPQUFPeWEsS0FBSzhMO1lBQzdCO1lBR0E7O0tBRUMsR0FFRFAsV0FBVyxTQUFTaG1CLEtBQUssRUFBRXBFLENBQUMsRUFBRTJxQixHQUFHO2dCQUMvQixJQUFJYyxNQUFNclUsUUFBUTJSLElBQUltQyxNQUFNRDtnQkFDNUIsSUFBSU4sT0FBTyxNQUFNO29CQUNmQSxNQUFNZDtnQkFDUjtnQkFDQXpTLFNBQVNoVCxNQUFNbEIsS0FBSyxDQUFDLEdBQUdsRDtnQkFDeEIsSUFBSSxDQUFDb1gsT0FBT3RYLE1BQU0sRUFBRTtvQkFDbEIsT0FBT3NYO2dCQUNUO2dCQUNBMFMsUUFBUTFTLFFBQVF1VDtnQkFDaEJNLE9BQU83bUIsTUFBTWxCLEtBQUssQ0FBQ2xEO2dCQUNuQixJQUFLK29CLEtBQUssR0FBR21DLE9BQU9ELEtBQUtuckIsTUFBTSxFQUFFaXBCLEtBQUttQyxNQUFNbkMsS0FBTTtvQkFDaEQwQyxPQUFPUixJQUFJLENBQUNsQyxHQUFHO29CQUNma0IsWUFBWTdTLFFBQVFxVSxNQUFNZDtnQkFDNUI7Z0JBQ0EsT0FBT3ZULE9BQU9zVSxJQUFJLENBQUNmLEtBQUtZLE9BQU87WUFDakM7WUFHQTs7S0FFQyxHQUVEbEIsWUFBWSxTQUFTam1CLEtBQUssRUFBRXBFLENBQUMsRUFBRTJxQixHQUFHO2dCQUNoQyxJQUFJYyxNQUFNRSxLQUFLdlUsUUFBUTJSLElBQUl1QyxJQUFJSixNQUFNRCxNQUFNRSxPQUFPQztnQkFDbEQsSUFBSVQsT0FBTyxNQUFNO29CQUNmQSxNQUFNZDtnQkFDUjtnQkFDQSxJQUFJN3BCLElBQUksTUFBTW9FLE1BQU10RSxNQUFNLEVBQUU7b0JBQzFCc1gsU0FBU2hULE1BQU1sQixLQUFLLENBQUMsR0FBR2xELEdBQUcwckIsSUFBSSxDQUFDZjtvQkFDaEMsSUFBSSxDQUFDdlQsT0FBT3RYLE1BQU0sRUFBRTt3QkFDbEIsT0FBT3NYO29CQUNUO29CQUNBdVUsTUFBTXZVLE1BQU0sQ0FBQ0EsT0FBT3RYLE1BQU0sR0FBRyxFQUFFO29CQUMvQm1yQixPQUFPN21CLE1BQU1sQixLQUFLLENBQUNsRDtvQkFDbkIsSUFBSytvQixLQUFLLEdBQUdtQyxPQUFPRCxLQUFLbnJCLE1BQU0sRUFBRWlwQixLQUFLbUMsTUFBTW5DLEtBQU07d0JBQ2hEMEMsT0FBT1IsSUFBSSxDQUFDbEMsR0FBRzt3QkFDZixJQUFJNEIsSUFBSWMsTUFBTUUsT0FBTyxHQUFHOzRCQUN0QnhCLE9BQU8vUyxRQUFRcVUsTUFBTSxHQUFHLE1BQU1kOzRCQUM5QnZULE9BQU84USxHQUFHOzRCQUNWeUQsTUFBTXZVLE1BQU0sQ0FBQ0EsT0FBT3RYLE1BQU0sR0FBRyxFQUFFO3dCQUNqQztvQkFDRjtvQkFDQSxPQUFPc1g7Z0JBQ1Q7Z0JBQ0EwUyxRQUFRMWxCLE9BQU91bUI7Z0JBQ2ZTLFdBQVcsRUFBRTtnQkFDYixJQUFLRSxLQUFLLEdBQUdILFFBQVF4UixJQUFJM1osR0FBR29FLE1BQU10RSxNQUFNLEdBQUcsS0FBS3FyQixRQUFRRyxLQUFLSCxRQUFRRyxLQUFLSCxPQUFPLEtBQUtBLFFBQVEsRUFBRUcsS0FBSyxFQUFFQSxHQUFJO29CQUN6R0YsU0FBUzlvQixJQUFJLENBQUN5bkIsUUFBUTNsQixPQUFPdW1CO2dCQUMvQjtnQkFDQSxPQUFPUztZQUNUO1lBRUFiLFlBQVksU0FBU25tQixLQUFLLEVBQUV3bkIsUUFBUSxFQUFFL00sR0FBRyxFQUFFOEwsR0FBRztnQkFDNUMsSUFBSWtCLFNBQVN0RyxRQUFRdUc7Z0JBQ3JCLElBQUluQixPQUFPLE1BQU07b0JBQ2ZBLE1BQU1kO2dCQUNSO2dCQUNBZ0MsVUFBVXpuQixLQUFLLENBQUN5YSxJQUFJO2dCQUNwQixNQUFPQSxNQUFNK00sU0FBVTtvQkFDckJFLFlBQVksTUFBTyxLQUFNO29CQUN6QnZHLFNBQVNuaEIsS0FBSyxDQUFDMG5CLFVBQVU7b0JBQ3pCLElBQUluQixJQUFJa0IsU0FBU3RHLFVBQVUsR0FBRzt3QkFDNUJuaEIsS0FBSyxDQUFDeWEsSUFBSSxHQUFHMEc7d0JBQ2IxRyxNQUFNaU47d0JBQ047b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7Z0JBQ0EsT0FBTzFuQixLQUFLLENBQUN5YSxJQUFJLEdBQUdnTjtZQUN0QjtZQUVBckIsVUFBVSxTQUFTcG1CLEtBQUssRUFBRXlhLEdBQUcsRUFBRThMLEdBQUc7Z0JBQ2hDLElBQUlvQixVQUFVQyxRQUFRSCxTQUFTSSxVQUFVTDtnQkFDekMsSUFBSWpCLE9BQU8sTUFBTTtvQkFDZkEsTUFBTWQ7Z0JBQ1I7Z0JBQ0FtQyxTQUFTNW5CLE1BQU10RSxNQUFNO2dCQUNyQjhyQixXQUFXL007Z0JBQ1hnTixVQUFVem5CLEtBQUssQ0FBQ3lhLElBQUk7Z0JBQ3BCa04sV0FBVyxJQUFJbE4sTUFBTTtnQkFDckIsTUFBT2tOLFdBQVdDLE9BQVE7b0JBQ3hCQyxXQUFXRixXQUFXO29CQUN0QixJQUFJRSxXQUFXRCxVQUFVLENBQUVyQixDQUFBQSxJQUFJdm1CLEtBQUssQ0FBQzJuQixTQUFTLEVBQUUzbkIsS0FBSyxDQUFDNm5CLFNBQVMsSUFBSSxJQUFJO3dCQUNyRUYsV0FBV0U7b0JBQ2I7b0JBQ0E3bkIsS0FBSyxDQUFDeWEsSUFBSSxHQUFHemEsS0FBSyxDQUFDMm5CLFNBQVM7b0JBQzVCbE4sTUFBTWtOO29CQUNOQSxXQUFXLElBQUlsTixNQUFNO2dCQUN2QjtnQkFDQXphLEtBQUssQ0FBQ3lhLElBQUksR0FBR2dOO2dCQUNiLE9BQU90QixVQUFVbm1CLE9BQU93bkIsVUFBVS9NLEtBQUs4TDtZQUN6QztZQUVBZixPQUFPO2dCQUNMQSxLQUFLdG5CLElBQUksR0FBRzBuQjtnQkFFWkosS0FBSzFCLEdBQUcsR0FBRzZCO2dCQUVYSCxLQUFLNWlCLE9BQU8sR0FBR2tqQjtnQkFFZk4sS0FBS3NDLE9BQU8sR0FBR2pDO2dCQUVmTCxLQUFLRSxPQUFPLEdBQUdBO2dCQUVmRixLQUFLVSxVQUFVLEdBQUdBO2dCQUVsQlYsS0FBS1EsUUFBUSxHQUFHQTtnQkFFaEJSLEtBQUtTLFNBQVMsR0FBR0E7Z0JBRWpCLFNBQVNULEtBQUtlLEdBQUc7b0JBQ2YsSUFBSSxDQUFDQSxHQUFHLEdBQUdBLE9BQU8sT0FBT0EsTUFBTWQ7b0JBQy9CLElBQUksQ0FBQ2xDLEtBQUssR0FBRyxFQUFFO2dCQUNqQjtnQkFFQWlDLEtBQUsxb0IsU0FBUyxDQUFDb0IsSUFBSSxHQUFHLFNBQVM4UixDQUFDO29CQUM5QixPQUFPNFYsU0FBUyxJQUFJLENBQUNyQyxLQUFLLEVBQUV2VCxHQUFHLElBQUksQ0FBQ3VXLEdBQUc7Z0JBQ3pDO2dCQUVBZixLQUFLMW9CLFNBQVMsQ0FBQ2duQixHQUFHLEdBQUc7b0JBQ25CLE9BQU82QixRQUFRLElBQUksQ0FBQ3BDLEtBQUssRUFBRSxJQUFJLENBQUNnRCxHQUFHO2dCQUNyQztnQkFFQWYsS0FBSzFvQixTQUFTLENBQUNpckIsSUFBSSxHQUFHO29CQUNwQixPQUFPLElBQUksQ0FBQ3hFLEtBQUssQ0FBQyxFQUFFO2dCQUN0QjtnQkFFQWlDLEtBQUsxb0IsU0FBUyxDQUFDa3JCLFFBQVEsR0FBRyxTQUFTaFksQ0FBQztvQkFDbEMsT0FBTyxJQUFJLENBQUN1VCxLQUFLLENBQUM2RCxPQUFPLENBQUNwWCxPQUFPLENBQUM7Z0JBQ3BDO2dCQUVBd1YsS0FBSzFvQixTQUFTLENBQUM4RixPQUFPLEdBQUcsU0FBU29OLENBQUM7b0JBQ2pDLE9BQU84VixZQUFZLElBQUksQ0FBQ3ZDLEtBQUssRUFBRXZULEdBQUcsSUFBSSxDQUFDdVcsR0FBRztnQkFDNUM7Z0JBRUFmLEtBQUsxb0IsU0FBUyxDQUFDZ3JCLE9BQU8sR0FBRyxTQUFTOVgsQ0FBQztvQkFDakMsT0FBTzZWLFlBQVksSUFBSSxDQUFDdEMsS0FBSyxFQUFFdlQsR0FBRyxJQUFJLENBQUN1VyxHQUFHO2dCQUM1QztnQkFFQWYsS0FBSzFvQixTQUFTLENBQUM0b0IsT0FBTyxHQUFHO29CQUN2QixPQUFPQSxRQUFRLElBQUksQ0FBQ25DLEtBQUssRUFBRSxJQUFJLENBQUNnRCxHQUFHO2dCQUNyQztnQkFFQWYsS0FBSzFvQixTQUFTLENBQUNvcEIsVUFBVSxHQUFHLFNBQVNsVyxDQUFDO29CQUNwQyxPQUFPa1csV0FBVyxJQUFJLENBQUMzQyxLQUFLLEVBQUV2VCxHQUFHLElBQUksQ0FBQ3VXLEdBQUc7Z0JBQzNDO2dCQUVBZixLQUFLMW9CLFNBQVMsQ0FBQ2doQixLQUFLLEdBQUc7b0JBQ3JCLE9BQU8sSUFBSSxDQUFDeUYsS0FBSyxHQUFHLEVBQUU7Z0JBQ3hCO2dCQUVBaUMsS0FBSzFvQixTQUFTLENBQUNtckIsS0FBSyxHQUFHO29CQUNyQixPQUFPLElBQUksQ0FBQzFFLEtBQUssQ0FBQzduQixNQUFNLEtBQUs7Z0JBQy9CO2dCQUVBOHBCLEtBQUsxb0IsU0FBUyxDQUFDeWhCLElBQUksR0FBRztvQkFDcEIsT0FBTyxJQUFJLENBQUNnRixLQUFLLENBQUM3bkIsTUFBTTtnQkFDMUI7Z0JBRUE4cEIsS0FBSzFvQixTQUFTLENBQUNtZixLQUFLLEdBQUc7b0JBQ3JCLElBQUlpTTtvQkFDSkEsT0FBTyxJQUFJMUM7b0JBQ1gwQyxLQUFLM0UsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDemtCLEtBQUssQ0FBQztvQkFDOUIsT0FBT29wQjtnQkFDVDtnQkFFQTFDLEtBQUsxb0IsU0FBUyxDQUFDMGhCLE9BQU8sR0FBRztvQkFDdkIsT0FBTyxJQUFJLENBQUMrRSxLQUFLLENBQUN6a0IsS0FBSyxDQUFDO2dCQUMxQjtnQkFFQTBtQixLQUFLMW9CLFNBQVMsQ0FBQ3FyQixNQUFNLEdBQUczQyxLQUFLMW9CLFNBQVMsQ0FBQ29CLElBQUk7Z0JBRTNDc25CLEtBQUsxb0IsU0FBUyxDQUFDc3JCLEdBQUcsR0FBRzVDLEtBQUsxb0IsU0FBUyxDQUFDaXJCLElBQUk7Z0JBRXhDdkMsS0FBSzFvQixTQUFTLENBQUN1ckIsS0FBSyxHQUFHN0MsS0FBSzFvQixTQUFTLENBQUNpckIsSUFBSTtnQkFFMUN2QyxLQUFLMW9CLFNBQVMsQ0FBQ2loQixHQUFHLEdBQUd5SCxLQUFLMW9CLFNBQVMsQ0FBQ2tyQixRQUFRO2dCQUU1Q3hDLEtBQUsxb0IsU0FBUyxDQUFDb2YsSUFBSSxHQUFHc0osS0FBSzFvQixTQUFTLENBQUNtZixLQUFLO2dCQUUxQyxPQUFPdUo7WUFFVDtZQUVDLFVBQVN4VSxJQUFJLEVBQUVzWCxPQUFPO2dCQUNyQjtvQkFDRSxPQUFPL0MsT0FBT0osT0FBTyxHQUFHbUQ7Z0JBQzFCO1lBQ0YsR0FBRyxJQUFJLEVBQUU7Z0JBQ1AsT0FBTzlDO1lBQ1Q7UUFFRixHQUFHL25CLElBQUksQ0FBQzJuQjtJQUNULEdBQUdGO0lBQ0gsT0FBT0EsT0FBT0MsT0FBTztBQUN0QjtBQUVBLElBQUkrQztBQUNKLElBQUlLO0FBRUosU0FBU0M7SUFDUixJQUFJRCxpQkFBaUIsT0FBT0w7SUFDNUJLLGtCQUFrQjtJQUNsQkwsT0FBTzVDO0lBQ1AsT0FBTzRDO0FBQ1I7QUFFQSxJQUFJTyxjQUFjRDtBQUNsQixJQUFJaEQsT0FBTyxXQUFXLEdBQUV6Vix3QkFBd0IwWTtBQUVoRCxJQUFJQyxtQkFBbUJqTSxXQUFXO0lBQ2hDekwsTUFBTTtJQUNOMlgsUUFBUSxTQUFTQSxPQUFPOUQsSUFBSTtRQUMxQixPQUFPO0lBQ1Q7SUFDQWhDLFVBQVU7QUFDWjtBQUNBLElBQUkrRixXQUFXO0lBQ2JDLFVBQVUsU0FBU0EsU0FBU3JaLE9BQU87UUFDakMsSUFBSSxDQUFDdFAsWUFBWXNQLFVBQVU7WUFDekIsSUFBSXZOLE9BQU9EO1lBQ1h3TixVQUFVO2dCQUNSd0IsTUFBTS9PLElBQUksQ0FBQyxFQUFFO2dCQUNiMG1CLFFBQVExbUIsSUFBSSxDQUFDLEVBQUU7Z0JBQ2Y0Z0IsVUFBVTVnQixJQUFJLENBQUMsRUFBRTtZQUNuQjtRQUNGO1FBQ0EsSUFBSTZtQixvQkFBb0JKLGlCQUFpQmxaLFVBQ3ZDd0IsT0FBTzhYLGtCQUFrQjlYLElBQUksRUFDN0IyWCxTQUFTRyxrQkFBa0JILE1BQU0sRUFDakM5RixXQUFXaUcsa0JBQWtCakcsUUFBUTtRQUN2QyxJQUFJa0csT0FBTyxJQUFJO1FBQ2YsSUFBSUMsV0FBV0w7UUFDZixJQUFJckosU0FBU3hmLE9BQU9rUixRQUFRLElBQUksQ0FBQzJOLE1BQU0sQ0FBQzNOLEtBQUssQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO1FBQzFELElBQUlpWSxPQUFPLENBQUM7UUFDWixJQUFJQyxPQUFPLENBQUM7UUFDWixJQUFJQyxZQUFZLENBQUM7UUFDakIsSUFBSTlGLGdCQUFnQixJQUFJLENBQUNDLE9BQU8sSUFDOUJDLFFBQVFGLGNBQWNFLEtBQUssRUFDM0J0QyxRQUFRb0MsY0FBY3BDLEtBQUs7UUFDN0JBLE1BQU1tSSxTQUFTLENBQUMsU0FBVXBNLEdBQUc7WUFDM0IsT0FBT0EsSUFBSXFNLE1BQU07UUFDbkI7UUFDQSxJQUFJQyxVQUFVLFNBQVNBLFFBQVExRSxJQUFJO1lBQ2pDLE9BQU9xRSxJQUFJLENBQUNyRSxLQUFLbEIsRUFBRSxHQUFHO1FBQ3hCO1FBQ0EsSUFBSTZGLFVBQVUsU0FBU0EsUUFBUTNFLElBQUksRUFBRTRFLENBQUM7WUFDcENQLElBQUksQ0FBQ3JFLEtBQUtsQixFQUFFLEdBQUcsR0FBRzhGO1lBQ2xCekcsRUFBRW1ELFVBQVUsQ0FBQ3RCO1FBQ2Y7UUFDQSxJQUFJN0IsSUFBSSxJQUFJeUMsS0FBSyxTQUFVL3BCLENBQUMsRUFBRXNJLENBQUM7WUFDN0IsT0FBT3VsQixRQUFRN3RCLEtBQUs2dEIsUUFBUXZsQjtRQUM5QjtRQUNBLElBQUssSUFBSTlGLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7WUFDckMsSUFBSTJtQixPQUFPckIsS0FBSyxDQUFDdGxCLEVBQUU7WUFDbkJnckIsSUFBSSxDQUFDckUsS0FBS2xCLEVBQUUsR0FBRyxHQUFHa0IsS0FBS1IsSUFBSSxDQUFDOUUsVUFBVSxJQUFJbUs7WUFDMUMxRyxFQUFFN2tCLElBQUksQ0FBQzBtQjtRQUNUO1FBQ0EsSUFBSThFLGNBQWMsU0FBU0EsWUFBWWxzQixDQUFDLEVBQUVxRixDQUFDO1lBQ3pDLElBQUk4bUIsTUFBTSxDQUFDOUcsV0FBV3JsQixFQUFFb3NCLE9BQU8sQ0FBQy9tQixLQUFLckYsRUFBRXFzQixTQUFTLENBQUNobkIsRUFBQyxFQUFHaW5CLFNBQVMsQ0FBQzdJO1lBQy9ELElBQUk4SSxtQkFBbUJOO1lBQ3ZCLElBQUlPO1lBQ0osSUFBSyxJQUFJckYsS0FBSyxHQUFHQSxLQUFLZ0YsSUFBSWp1QixNQUFNLEVBQUVpcEIsS0FBTTtnQkFDdEMsSUFBSUUsT0FBTzhFLEdBQUcsQ0FBQ2hGLEdBQUc7Z0JBQ2xCLElBQUlzRixVQUFVakIsU0FBU25FO2dCQUN2QixJQUFJb0YsVUFBVUYsb0JBQW9CLENBQUNDLGNBQWM7b0JBQy9DRCxtQkFBbUJFO29CQUNuQkQsZUFBZW5GO2dCQUNqQjtZQUNGO1lBQ0EsT0FBTztnQkFDTEEsTUFBTW1GO2dCQUNOZixNQUFNYztZQUNSO1FBQ0Y7UUFDQSxNQUFPaEgsRUFBRXhFLElBQUksS0FBSyxFQUFHO1lBQ25CLElBQUkvZ0IsSUFBSXVsQixFQUFFZSxHQUFHO1lBQ2IsSUFBSW9HLGVBQWVaLFFBQVE5ckI7WUFDM0IsSUFBSTJzQixNQUFNM3NCLEVBQUVrbUIsRUFBRTtZQUNkeUYsU0FBUyxDQUFDZ0IsSUFBSSxHQUFHRDtZQUNqQixJQUFJQSxpQkFBaUJULFVBQVU7Z0JBQzdCO1lBQ0Y7WUFDQSxJQUFJVyxZQUFZNXNCLEVBQUU2c0IsWUFBWSxHQUFHUCxTQUFTLENBQUN2RztZQUMzQyxJQUFLLElBQUlnQixNQUFNLEdBQUdBLE1BQU02RixVQUFVMXVCLE1BQU0sRUFBRTZvQixNQUFPO2dCQUMvQyxJQUFJMWhCLElBQUl1bkIsU0FBUyxDQUFDN0YsSUFBSTtnQkFDdEIsSUFBSStGLE1BQU16bkIsRUFBRTZnQixFQUFFO2dCQUNkLElBQUk2RyxRQUFRYixZQUFZbHNCLEdBQUdxRjtnQkFDM0IsSUFBSTJuQixNQUFNTixlQUFlSyxNQUFNdEIsSUFBSTtnQkFDbkMsSUFBSXVCLE1BQU1sQixRQUFRem1CLElBQUk7b0JBQ3BCMG1CLFFBQVExbUIsR0FBRzJuQjtvQkFDWHRCLElBQUksQ0FBQ29CLElBQUksR0FBRzt3QkFDVjFGLE1BQU1wbkI7d0JBQ05xbkIsTUFBTTBGLE1BQU0xRixJQUFJO29CQUNsQjtnQkFDRjtZQUNGLEVBQUUsTUFBTTtRQUNWLEVBQUUsUUFBUTtRQUVWLE9BQU87WUFDTDRGLFlBQVksU0FBU0EsV0FBVzdGLElBQUk7Z0JBQ2xDLElBQUlyRixTQUFTemYsT0FBTzhrQixRQUFRckIsTUFBTTVFLE1BQU0sQ0FBQ2lHLEtBQUssQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO2dCQUMzRCxPQUFPdUUsU0FBUyxDQUFDNUosT0FBT21FLEVBQUUsR0FBRztZQUMvQjtZQUNBZ0gsUUFBUSxTQUFTQSxPQUFPOUYsSUFBSTtnQkFDMUIsSUFBSXJGLFNBQVN6ZixPQUFPOGtCLFFBQVFyQixNQUFNNUUsTUFBTSxDQUFDaUcsS0FBSyxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7Z0JBQzNELElBQUkrRixJQUFJLEVBQUU7Z0JBQ1YsSUFBSW50QixJQUFJK2hCO2dCQUNSLElBQUk0SyxNQUFNM3NCLEVBQUVrbUIsRUFBRTtnQkFDZCxJQUFJbkUsT0FBTzdqQixNQUFNLEdBQUcsR0FBRztvQkFDckJpdkIsRUFBRWhILE9BQU8sQ0FBQ3BFO29CQUNWLE1BQU8ySixJQUFJLENBQUNpQixJQUFJLENBQUU7d0JBQ2hCLElBQUlsbEIsSUFBSWlrQixJQUFJLENBQUNpQixJQUFJO3dCQUNqQlEsRUFBRWhILE9BQU8sQ0FBQzFlLEVBQUU0ZixJQUFJO3dCQUNoQjhGLEVBQUVoSCxPQUFPLENBQUMxZSxFQUFFMmYsSUFBSTt3QkFDaEJwbkIsSUFBSXlILEVBQUUyZixJQUFJO3dCQUNWdUYsTUFBTTNzQixFQUFFa21CLEVBQUU7b0JBQ1o7Z0JBQ0Y7Z0JBQ0EsT0FBT3FGLEtBQUs2QixLQUFLLENBQUNEO1lBQ3BCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSUUsV0FBVztJQUNiLDJFQUEyRTtJQUMzRSw2Q0FBNkM7SUFDN0NDLFNBQVMsU0FBU0EsUUFBUTlCLFFBQVE7UUFDaENBLFdBQVdBLFlBQVksU0FBVW5FLElBQUk7WUFDbkMsT0FBTztRQUNUO1FBQ0EsSUFBSXhCLGdCQUFnQixJQUFJLENBQUNDLE9BQU8sSUFDOUJDLFFBQVFGLGNBQWNFLEtBQUssRUFDM0J0QyxRQUFRb0MsY0FBY3BDLEtBQUs7UUFDN0IsSUFBSThKLFdBQVd4SCxNQUFNN25CLE1BQU07UUFDM0IsSUFBSXN2QixTQUFTLElBQUludkIsTUFBTWt2QjtRQUN2QixJQUFJRSxJQUFJMUgsT0FBTyx1RUFBdUU7UUFFdEYsSUFBSTJILGVBQWUsU0FBU0EsYUFBYWxPLEdBQUc7WUFDMUMsSUFBSyxJQUFJL2UsSUFBSSxHQUFHQSxJQUFJK3NCLE9BQU90dkIsTUFBTSxFQUFFdUMsSUFBSztnQkFDdEMsSUFBSThxQixPQUFPaUMsTUFBTSxDQUFDL3NCLEVBQUU7Z0JBQ3BCLElBQUk4cUIsS0FBS2hMLEdBQUcsQ0FBQ2YsTUFBTTtvQkFDakIsT0FBTy9lO2dCQUNUO1lBQ0Y7UUFDRjtRQUVBLGlDQUFpQztRQUNqQyxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSThzQixVQUFVOXNCLElBQUs7WUFDakMrc0IsTUFBTSxDQUFDL3NCLEVBQUUsR0FBRyxJQUFJLENBQUMyc0IsS0FBSyxDQUFDckgsS0FBSyxDQUFDdGxCLEVBQUU7UUFDakM7UUFDQSxJQUFJMHNCLElBQUkxSixNQUFNcUcsSUFBSSxDQUFDLFNBQVU3ckIsQ0FBQyxFQUFFc0ksQ0FBQztZQUMvQixPQUFPaWxCLFNBQVN2dEIsS0FBS3V0QixTQUFTamxCO1FBQ2hDO1FBQ0EsSUFBSyxJQUFJNGdCLEtBQUssR0FBR0EsS0FBS2dHLEVBQUVqdkIsTUFBTSxFQUFFaXBCLEtBQU07WUFDcEMsSUFBSUUsT0FBTzhGLENBQUMsQ0FBQ2hHLEdBQUc7WUFDaEIsSUFBSW5uQixJQUFJcW5CLEtBQUt2RixNQUFNLEVBQUUsQ0FBQyxFQUFFO1lBQ3hCLElBQUl6YyxJQUFJZ2lCLEtBQUt0RixNQUFNLEVBQUUsQ0FBQyxFQUFFO1lBQ3hCLElBQUk0TCxZQUFZRCxhQUFhMXRCO1lBQzdCLElBQUk0dEIsWUFBWUYsYUFBYXJvQjtZQUM3QixJQUFJd29CLE9BQU9MLE1BQU0sQ0FBQ0csVUFBVTtZQUM1QixJQUFJRyxPQUFPTixNQUFNLENBQUNJLFVBQVU7WUFDNUIsSUFBSUQsY0FBY0MsV0FBVztnQkFDM0JILEVBQUVNLEtBQUssQ0FBQzFHO2dCQUVSLDhCQUE4QjtnQkFDOUJ3RyxLQUFLRSxLQUFLLENBQUNEO2dCQUNYTixPQUFPOU4sTUFBTSxDQUFDa08sV0FBVztZQUMzQjtRQUNGO1FBQ0EsT0FBT0g7SUFDVDtBQUNGO0FBRUEsSUFBSU8sZ0JBQWdCL08sV0FBVztJQUM3QnpMLE1BQU07SUFDTnlhLE1BQU07SUFDTjlDLFFBQVEsU0FBU0EsT0FBTzlELElBQUk7UUFDMUIsT0FBTztJQUNUO0lBQ0E2RyxXQUFXLFNBQVNBLFVBQVU3RyxJQUFJO1FBQ2hDLE9BQU87SUFDVDtJQUNBaEMsVUFBVTtBQUNaO0FBQ0EsSUFBSThJLFdBQVc7SUFDYiw2Q0FBNkM7SUFDN0NDLE9BQU8sU0FBU0EsTUFBTXBjLE9BQU87UUFDM0IsSUFBSXlQLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUk0TSxpQkFBaUJMLGNBQWNoYyxVQUNqQ3dCLE9BQU82YSxlQUFlN2EsSUFBSSxFQUMxQnlhLE9BQU9JLGVBQWVKLElBQUksRUFDMUJDLFlBQVlHLGVBQWVILFNBQVMsRUFDcEM3SSxXQUFXZ0osZUFBZWhKLFFBQVEsRUFDbEM4RixTQUFTa0QsZUFBZWxELE1BQU07UUFDaEMzWCxPQUFPaU8sR0FBR3JlLFVBQVUsQ0FBQ29RLEtBQUssQ0FBQyxFQUFFO1FBQzdCeWEsT0FBT3hNLEdBQUdyZSxVQUFVLENBQUM2cUIsS0FBSyxDQUFDLEVBQUU7UUFDN0IsSUFBSUssTUFBTTlhLEtBQUswUyxFQUFFO1FBQ2pCLElBQUlxSSxNQUFNTixLQUFLL0gsRUFBRTtRQUNqQixJQUFJc0ksU0FBUyxDQUFDO1FBQ2QsSUFBSUMsU0FBUyxDQUFDO1FBQ2QsSUFBSUMsZUFBZSxDQUFDO1FBQ3BCLElBQUlDLFVBQVUsSUFBSTNHLEtBQUssU0FBVS9wQixDQUFDLEVBQUVzSSxDQUFDO1lBQ25DLE9BQU9rb0IsTUFBTSxDQUFDeHdCLEVBQUVpb0IsRUFBRSxHQUFHLEdBQUd1SSxNQUFNLENBQUNsb0IsRUFBRTJmLEVBQUUsR0FBRztRQUN4QztRQUNBLElBQUkwSSxhQUFhLElBQUl0TjtRQUNyQixJQUFJdU4sV0FBVyxDQUFDO1FBQ2hCLElBQUlDLGVBQWUsQ0FBQztRQUNwQixJQUFJQyxlQUFlLFNBQVNBLGFBQWF2UCxHQUFHLEVBQUUwRyxFQUFFO1lBQzlDeUksUUFBUWp1QixJQUFJLENBQUM4ZTtZQUNib1AsV0FBVzNOLEdBQUcsQ0FBQ2lGO1FBQ2pCO1FBQ0EsSUFBSThJLE1BQU1DO1FBQ1YsSUFBSUMsaUJBQWlCLFNBQVNBO1lBQzVCRixPQUFPTCxRQUFRckksR0FBRztZQUNsQjJJLFNBQVNELEtBQUs5SSxFQUFFO1lBQ2hCMEksVUFBVSxDQUFDLFNBQVMsQ0FBQ0s7UUFDdkI7UUFDQSxJQUFJRSxjQUFjLFNBQVNBLFlBQVlqSixFQUFFO1lBQ3ZDLE9BQU8wSSxXQUFXck8sR0FBRyxDQUFDMkY7UUFDeEI7UUFDQTZJLGFBQWF2YixNQUFNOGE7UUFDbkJFLE1BQU0sQ0FBQ0YsSUFBSSxHQUFHO1FBQ2RHLE1BQU0sQ0FBQ0gsSUFBSSxHQUFHSixVQUFVMWE7UUFFeEIsVUFBVTtRQUNWLElBQUk0YixRQUFRO1FBRVosWUFBWTtRQUNaLE1BQU9ULFFBQVE1TixJQUFJLEtBQUssRUFBRztZQUN6Qm1PO1lBQ0FFO1lBRUEsNENBQTRDO1lBQzVDLElBQUlILFdBQVdWLEtBQUs7Z0JBQ2xCLElBQUlqSCxPQUFPLEVBQUU7Z0JBQ2IsSUFBSStILFdBQVdwQjtnQkFDZixJQUFJcUIsYUFBYWY7Z0JBQ2pCLElBQUlnQixXQUFXVCxZQUFZLENBQUNRLFdBQVc7Z0JBQ3ZDLE9BQVM7b0JBQ1BoSSxLQUFLbkIsT0FBTyxDQUFDa0o7b0JBQ2IsSUFBSUUsWUFBWSxNQUFNO3dCQUNwQmpJLEtBQUtuQixPQUFPLENBQUNvSjtvQkFDZjtvQkFDQUYsV0FBV1IsUUFBUSxDQUFDUyxXQUFXO29CQUMvQixJQUFJRCxZQUFZLE1BQU07d0JBQ3BCO29CQUNGO29CQUNBQyxhQUFhRCxTQUFTbkosRUFBRTtvQkFDeEJxSixXQUFXVCxZQUFZLENBQUNRLFdBQVc7Z0JBQ3JDO2dCQUNBLE9BQU87b0JBQ0wxSixPQUFPO29CQUNQNEosVUFBVWhCLE1BQU0sQ0FBQ1MsT0FBTztvQkFDeEIzSCxNQUFNLElBQUksQ0FBQzhGLEtBQUssQ0FBQzlGO29CQUNqQjhILE9BQU9BO2dCQUNUO1lBQ0Y7WUFFQSw4QkFBOEI7WUFDOUJWLFlBQVksQ0FBQ08sT0FBTyxHQUFHO1lBRXZCLHNDQUFzQztZQUN0QyxnREFBZ0Q7WUFDaEQsSUFBSXBJLFVBQVVtSSxLQUFLM3JCLFFBQVEsQ0FBQ29nQixLQUFLO1lBQ2pDLElBQUssSUFBSWhqQixJQUFJLEdBQUdBLElBQUlvbUIsUUFBUTNvQixNQUFNLEVBQUV1QyxJQUFLO2dCQUN2QyxJQUFJdEMsSUFBSTBvQixPQUFPLENBQUNwbUIsRUFBRTtnQkFFbEIsc0NBQXNDO2dCQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDZ3ZCLGdCQUFnQixDQUFDdHhCLEVBQUUrbkIsRUFBRSxLQUFLO29CQUNsQztnQkFDRjtnQkFFQSw4Q0FBOEM7Z0JBQzlDLElBQUliLFlBQVlsbkIsRUFBRTBqQixJQUFJLENBQUMsY0FBY29OLFFBQVE7b0JBQzNDO2dCQUNGO2dCQUNBLElBQUlTLE9BQU92eEIsRUFBRTJqQixNQUFNO2dCQUNuQixJQUFJNk4sT0FBT3h4QixFQUFFNGpCLE1BQU07Z0JBQ25CLElBQUk1RSxJQUFJdVMsS0FBS3hKLEVBQUUsT0FBTytJLFNBQVNTLE9BQU9DO2dCQUN0QyxJQUFJQyxNQUFNelMsRUFBRStJLEVBQUU7Z0JBRWQsc0NBQXNDO2dCQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDdUosZ0JBQWdCLENBQUNHLE1BQU07b0JBQy9CO2dCQUNGO2dCQUVBLHFDQUFxQztnQkFDckMsSUFBSWxCLFlBQVksQ0FBQ2tCLElBQUksRUFBRTtvQkFDckI7Z0JBQ0Y7Z0JBRUEsaUNBQWlDO2dCQUNqQyxJQUFJQyxZQUFZckIsTUFBTSxDQUFDUyxPQUFPLEdBQUc5RCxPQUFPaHRCO2dCQUV4QywrQkFBK0I7Z0JBQy9CLDZCQUE2QjtnQkFDN0IsS0FBSztnQkFDTCxpREFBaUQ7Z0JBRWpELG1CQUFtQjtnQkFDbkIsSUFBSSxDQUFDZ3hCLFlBQVlTLE1BQU07b0JBQ3JCcEIsTUFBTSxDQUFDb0IsSUFBSSxHQUFHQztvQkFDZHBCLE1BQU0sQ0FBQ21CLElBQUksR0FBR0MsWUFBWTNCLFVBQVUvUTtvQkFDcEM0UixhQUFhNVIsR0FBR3lTO29CQUNoQmYsUUFBUSxDQUFDZSxJQUFJLEdBQUdaO29CQUNoQkYsWUFBWSxDQUFDYyxJQUFJLEdBQUd6eEI7b0JBQ3BCO2dCQUNGO2dCQUVBLGdEQUFnRDtnQkFDaEQsSUFBSTB4QixZQUFZckIsTUFBTSxDQUFDb0IsSUFBSSxFQUFFO29CQUMzQnBCLE1BQU0sQ0FBQ29CLElBQUksR0FBR0M7b0JBQ2RwQixNQUFNLENBQUNtQixJQUFJLEdBQUdDLFlBQVkzQixVQUFVL1E7b0JBQ3BDMFIsUUFBUSxDQUFDZSxJQUFJLEdBQUdaO29CQUNoQkYsWUFBWSxDQUFDYyxJQUFJLEdBQUd6eEI7Z0JBQ3RCO1lBQ0YsRUFBRSwwQkFBMEI7UUFDOUIsRUFBRSxtQkFBbUI7UUFFckIseURBQXlEO1FBQ3pELE9BQU87WUFDTHluQixPQUFPO1lBQ1A0SixVQUFVdnVCO1lBQ1ZxbUIsTUFBTXJtQjtZQUNObXVCLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGLEdBQUcsU0FBUztBQUVaLElBQUlVLHdCQUF3QjdRLFdBQVc7SUFDckNrTSxRQUFRLFNBQVNBLE9BQU85RCxJQUFJO1FBQzFCLE9BQU87SUFDVDtJQUNBaEMsVUFBVTtBQUNaO0FBQ0EsSUFBSTBLLFdBQVc7SUFDYiw2Q0FBNkM7SUFDN0NDLGVBQWUsU0FBU0EsY0FBY2hlLE9BQU87UUFDM0MsSUFBSXlQLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUl3Tyx3QkFBd0JILHNCQUFzQjlkLFVBQ2hEbVosU0FBUzhFLHNCQUFzQjlFLE1BQU0sRUFDckM5RixXQUFXNEssc0JBQXNCNUssUUFBUTtRQUMzQyxJQUFJbUcsV0FBV0w7UUFDZixJQUFJdEYsZ0JBQWdCLElBQUksQ0FBQ0MsT0FBTyxJQUM5QkMsUUFBUUYsY0FBY0UsS0FBSyxFQUMzQnRDLFFBQVFvQyxjQUFjcEMsS0FBSztRQUM3QixJQUFJeU0sSUFBSW5LLE1BQU03bkIsTUFBTTtRQUNwQixJQUFJaXlCLE1BQU1ELElBQUlBO1FBQ2QsSUFBSXRHLFVBQVUsU0FBU0EsUUFBUXhDLElBQUk7WUFDakMsT0FBT3JCLE1BQU02RCxPQUFPLENBQUN4QztRQUN2QjtRQUNBLElBQUlnSixVQUFVLFNBQVNBLFFBQVEzdkIsQ0FBQztZQUM5QixPQUFPc2xCLEtBQUssQ0FBQ3RsQixFQUFFO1FBQ2pCO1FBRUEsNkJBQTZCO1FBQzdCLElBQUlnckIsT0FBTyxJQUFJcHRCLE1BQU04eEI7UUFDckIsSUFBSyxJQUFJL3hCLElBQUksR0FBR0EsSUFBSSt4QixLQUFLL3hCLElBQUs7WUFDNUIsSUFBSTBJLElBQUkxSSxJQUFJOHhCO1lBQ1osSUFBSXp2QixJQUFJLENBQUNyQyxJQUFJMEksQ0FBQUEsSUFBS29wQjtZQUNsQixJQUFJenZCLE1BQU1xRyxHQUFHO2dCQUNYMmtCLElBQUksQ0FBQ3J0QixFQUFFLEdBQUc7WUFDWixPQUFPO2dCQUNMcXRCLElBQUksQ0FBQ3J0QixFQUFFLEdBQUc2dEI7WUFDWjtRQUNGO1FBRUEsaURBQWlEO1FBQ2pELDZCQUE2QjtRQUM3QixJQUFJL3JCLE9BQU8sSUFBSTdCLE1BQU04eEI7UUFDckIsSUFBSUUsV0FBVyxJQUFJaHlCLE1BQU04eEI7UUFFekIsZ0JBQWdCO1FBQ2hCLElBQUssSUFBSWhKLEtBQUssR0FBR0EsS0FBSzFELE1BQU12bEIsTUFBTSxFQUFFaXBCLEtBQU07WUFDeEMsSUFBSUUsT0FBTzVELEtBQUssQ0FBQzBELEdBQUc7WUFDcEIsSUFBSVQsTUFBTVcsS0FBS3ZGLE1BQU0sRUFBRSxDQUFDLEVBQUU7WUFDMUIsSUFBSWxiLE1BQU15Z0IsS0FBS3RGLE1BQU0sRUFBRSxDQUFDLEVBQUU7WUFDMUIsSUFBSTJFLFFBQVE5ZixLQUFLO2dCQUNmO1lBQ0YsRUFBRSxnQkFBZ0I7WUFFbEIsSUFBSWhILElBQUlncUIsUUFBUWxEO1lBQ2hCLElBQUk5bkIsSUFBSWdyQixRQUFRaGpCO1lBQ2hCLElBQUkwcEIsS0FBSzF3QixJQUFJc3dCLElBQUl0eEIsR0FBRyx5QkFBeUI7WUFDN0MsSUFBSTZ0QixVQUFVakIsU0FBU25FO1lBRXZCLDZEQUE2RDtZQUM3RCxJQUFJb0UsSUFBSSxDQUFDNkUsR0FBRyxHQUFHN0QsU0FBUztnQkFDdEJoQixJQUFJLENBQUM2RSxHQUFHLEdBQUc3RDtnQkFDWHZzQixJQUFJLENBQUNvd0IsR0FBRyxHQUFHMXhCO2dCQUNYeXhCLFFBQVEsQ0FBQ0MsR0FBRyxHQUFHako7WUFDakI7WUFFQSwrQ0FBK0M7WUFDL0MsSUFBSSxDQUFDaEMsVUFBVTtnQkFDYixJQUFJa0wsS0FBSzN4QixJQUFJc3hCLElBQUl0d0IsR0FBRyx5QkFBeUI7Z0JBRTdDLElBQUksQ0FBQ3lsQixZQUFZb0csSUFBSSxDQUFDOEUsR0FBRyxHQUFHOUQsU0FBUztvQkFDbkNoQixJQUFJLENBQUM4RSxHQUFHLEdBQUc5RDtvQkFDWHZzQixJQUFJLENBQUNxd0IsR0FBRyxHQUFHM3dCO29CQUNYeXdCLFFBQVEsQ0FBQ0UsR0FBRyxHQUFHbEo7Z0JBQ2pCO1lBQ0Y7UUFDRjtRQUVBLFlBQVk7UUFDWixJQUFLLElBQUl0aUIsSUFBSSxHQUFHQSxJQUFJbXJCLEdBQUduckIsSUFBSztZQUMxQixJQUFLLElBQUlnaUIsTUFBTSxHQUFHQSxNQUFNbUosR0FBR25KLE1BQU87Z0JBQ2hDLElBQUl5SixLQUFLekosTUFBTW1KLElBQUluckI7Z0JBQ25CLElBQUssSUFBSTJrQixLQUFLLEdBQUdBLEtBQUt3RyxHQUFHeEcsS0FBTTtvQkFDN0IsSUFBSStHLEtBQUsxSixNQUFNbUosSUFBSXhHO29CQUNuQixJQUFJZ0gsS0FBSzNyQixJQUFJbXJCLElBQUl4RztvQkFDakIsSUFBSStCLElBQUksQ0FBQytFLEdBQUcsR0FBRy9FLElBQUksQ0FBQ2lGLEdBQUcsR0FBR2pGLElBQUksQ0FBQ2dGLEdBQUcsRUFBRTt3QkFDbENoRixJQUFJLENBQUNnRixHQUFHLEdBQUdoRixJQUFJLENBQUMrRSxHQUFHLEdBQUcvRSxJQUFJLENBQUNpRixHQUFHO3dCQUM5Qnh3QixJQUFJLENBQUN1d0IsR0FBRyxHQUFHdndCLElBQUksQ0FBQ3N3QixHQUFHO29CQUNyQjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJRyxZQUFZLFNBQVNBLFVBQVVuUixHQUFHO1lBQ3BDLE9BQU8sQ0FBQ2xkLE9BQU9rZCxPQUFPaUMsR0FBR04sTUFBTSxDQUFDM0IsT0FBT0EsR0FBRSxDQUFFLENBQUMsRUFBRTtRQUNoRDtRQUNBLElBQUlvUixnQkFBZ0IsU0FBU0EsY0FBY3BSLEdBQUc7WUFDNUMsT0FBT29LLFFBQVErRyxVQUFVblI7UUFDM0I7UUFDQSxJQUFJcVIsTUFBTTtZQUNSckIsVUFBVSxTQUFTQSxTQUFTbHZCLElBQUksRUFBRXd3QixFQUFFO2dCQUNsQyxJQUFJcndCLElBQUltd0IsY0FBY3R3QjtnQkFDdEIsSUFBSXdHLElBQUk4cEIsY0FBY0U7Z0JBQ3RCLE9BQU9yRixJQUFJLENBQUNockIsSUFBSXl2QixJQUFJcHBCLEVBQUU7WUFDeEI7WUFDQXdnQixNQUFNLFNBQVNBLEtBQUtobkIsSUFBSSxFQUFFd3dCLEVBQUU7Z0JBQzFCLElBQUlyd0IsSUFBSW13QixjQUFjdHdCO2dCQUN0QixJQUFJd0csSUFBSThwQixjQUFjRTtnQkFDdEIsSUFBSUMsV0FBV1gsUUFBUTN2QjtnQkFDdkIsSUFBSUEsTUFBTXFHLEdBQUc7b0JBQ1gsT0FBT2lxQixTQUFTM3RCLFVBQVU7Z0JBQzVCO2dCQUNBLElBQUlsRCxJQUFJLENBQUNPLElBQUl5dkIsSUFBSXBwQixFQUFFLElBQUksTUFBTTtvQkFDM0IsT0FBTzJhLEdBQUdyZSxVQUFVO2dCQUN0QjtnQkFDQSxJQUFJa2tCLE9BQU83RixHQUFHcmUsVUFBVTtnQkFDeEIsSUFBSXNvQixPQUFPanJCO2dCQUNYLElBQUk0bUI7Z0JBQ0pDLEtBQUt5RyxLQUFLLENBQUNnRDtnQkFDWCxNQUFPdHdCLE1BQU1xRyxFQUFHO29CQUNkNGtCLE9BQU9qckI7b0JBQ1BBLElBQUlQLElBQUksQ0FBQ08sSUFBSXl2QixJQUFJcHBCLEVBQUU7b0JBQ25CdWdCLE9BQU9nSixRQUFRLENBQUMzRSxPQUFPd0UsSUFBSXp2QixFQUFFO29CQUM3QjZtQixLQUFLeUcsS0FBSyxDQUFDMUc7b0JBQ1hDLEtBQUt5RyxLQUFLLENBQUNxQyxRQUFRM3ZCO2dCQUNyQjtnQkFDQSxPQUFPNm1CO1lBQ1Q7UUFDRjtRQUNBLE9BQU91SjtJQUNULEVBQUUsZ0JBQWdCO0FBQ3BCLEdBQUcsU0FBUztBQUVaLElBQUlHLHNCQUFzQi9SLFdBQVc7SUFDbkNrTSxRQUFRLFNBQVNBLE9BQU85RCxJQUFJO1FBQzFCLE9BQU87SUFDVDtJQUNBaEMsVUFBVTtJQUNWN1IsTUFBTTtBQUNSO0FBQ0EsSUFBSXlkLFdBQVc7SUFDYiw2Q0FBNkM7SUFDN0NDLGFBQWEsU0FBU0EsWUFBWWxmLE9BQU87UUFDdkMsSUFBSWtQLFFBQVEsSUFBSTtRQUNoQixJQUFJaVEsdUJBQXVCSCxvQkFBb0JoZixVQUM3Q21aLFNBQVNnRyxxQkFBcUJoRyxNQUFNLEVBQ3BDOUYsV0FBVzhMLHFCQUFxQjlMLFFBQVEsRUFDeEM3UixPQUFPMmQscUJBQXFCM2QsSUFBSTtRQUNsQyxJQUFJZ1ksV0FBV0w7UUFDZixJQUFJSSxPQUFPLElBQUk7UUFDZixJQUFJOUosS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSW9FLGdCQUFnQixJQUFJLENBQUNDLE9BQU8sSUFDOUJyQyxRQUFRb0MsY0FBY3BDLEtBQUssRUFDM0JzQyxRQUFRRixjQUFjRSxLQUFLO1FBQzdCLElBQUl3SCxXQUFXeEgsTUFBTTduQixNQUFNO1FBQzNCLElBQUlrekIsVUFBVSxJQUFJM1E7UUFDbEIsSUFBSTRRLHlCQUF5QjtRQUM3QixJQUFJQyx1QkFBdUIsRUFBRTtRQUM3QjlkLE9BQU9pTyxHQUFHcmUsVUFBVSxDQUFDb1EsS0FBSyxDQUFDLEVBQUUsRUFBRSwwQkFBMEI7UUFFekRpUSxNQUFNbUksU0FBUyxDQUFDLFNBQVV2RSxJQUFJO1lBQzVCLE9BQU9BLEtBQUt3RSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSTBGLFdBQVc5TixNQUFNdmxCLE1BQU07UUFDM0IsSUFBSXN6QixVQUFVLFNBQVNBLFFBQVFwSyxJQUFJO1lBQ2pDLElBQUlqbEIsTUFBTWl2QixRQUFRNVEsR0FBRyxDQUFDNEcsS0FBS2xCLEVBQUU7WUFDN0IsSUFBSSxDQUFDL2pCLEtBQUs7Z0JBQ1JBLE1BQU0sQ0FBQztnQkFDUGl2QixRQUFRalIsR0FBRyxDQUFDaUgsS0FBS2xCLEVBQUUsSUFBSS9qQjtZQUN6QjtZQUNBLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJc3ZCLGdCQUFnQixTQUFTQSxjQUFjWCxFQUFFO1lBQzNDLE9BQU8sQ0FBQ3h1QixPQUFPd3VCLE1BQU1yUCxHQUFHaVEsQ0FBQyxDQUFDWixNQUFNQSxFQUFDLENBQUUsQ0FBQyxFQUFFO1FBQ3hDO1FBQ0EsSUFBSTdELGFBQWEsU0FBU0EsV0FBVzZELEVBQUU7WUFDckMsT0FBT1UsUUFBUUMsY0FBY1gsS0FBS3JGLElBQUk7UUFDeEM7UUFDQSxJQUFJeUIsU0FBUyxTQUFTQSxPQUFPNEQsRUFBRTtZQUM3QixJQUFJYSxZQUFZbnRCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBR2dQO1lBQ3BGLElBQUlvZSxNQUFNSCxjQUFjWDtZQUN4QixJQUFJeEosT0FBTyxFQUFFO1lBQ2IsSUFBSUYsT0FBT3dLO1lBQ1gsT0FBUztnQkFDUCxJQUFJeEssUUFBUSxNQUFNO29CQUNoQixPQUFPbEcsTUFBTWtNLEtBQUs7Z0JBQ3BCO2dCQUNBLElBQUl5RSxXQUFXTCxRQUFRcEssT0FDckJDLE9BQU93SyxTQUFTeEssSUFBSSxFQUNwQnlLLE9BQU9ELFNBQVNDLElBQUk7Z0JBQ3RCeEssS0FBS25CLE9BQU8sQ0FBQ2lCLElBQUksQ0FBQyxFQUFFO2dCQUNwQixJQUFJQSxLQUFLUixJQUFJLENBQUMrSyxjQUFjckssS0FBS3BwQixNQUFNLEdBQUcsR0FBRztvQkFDM0M7Z0JBQ0Y7Z0JBQ0EsSUFBSW1wQixRQUFRLE1BQU07b0JBQ2hCQyxLQUFLbkIsT0FBTyxDQUFDa0I7Z0JBQ2Y7Z0JBQ0FELE9BQU8wSztZQUNUO1lBQ0EsT0FBT3ZHLEtBQUs2QixLQUFLLENBQUM5RjtRQUNwQjtRQUVBLHVDQUF1QztRQUN2QyxJQUFLLElBQUk3bUIsSUFBSSxHQUFHQSxJQUFJOHNCLFVBQVU5c0IsSUFBSztZQUNqQyxJQUFJMm1CLE9BQU9yQixLQUFLLENBQUN0bEIsRUFBRTtZQUNuQixJQUFJc3hCLE9BQU9QLFFBQVFwSztZQUNuQixJQUFJQSxLQUFLUixJQUFJLENBQUNwVCxPQUFPO2dCQUNuQnVlLEtBQUt0RyxJQUFJLEdBQUc7WUFDZCxPQUFPO2dCQUNMc0csS0FBS3RHLElBQUksR0FBR1E7WUFDZDtZQUNBOEYsS0FBS0QsSUFBSSxHQUFHO1lBQ1pDLEtBQUsxSyxJQUFJLEdBQUc7UUFDZDtRQUVBLG1CQUFtQjtRQUNuQixJQUFJMkssZUFBZTtRQUNuQixJQUFJQywwQkFBMEIsU0FBU0Esd0JBQXdCQyxLQUFLLEVBQUVDLEtBQUssRUFBRTlLLElBQUksRUFBRStLLEtBQUssRUFBRUMsS0FBSyxFQUFFbEgsTUFBTTtZQUNyRyxJQUFJTSxPQUFPMkcsTUFBTTNHLElBQUksR0FBR047WUFDeEIsSUFBSU0sT0FBTzRHLE1BQU01RyxJQUFJLElBQUksQ0FBQ3BFLEtBQUtULElBQUksQ0FBQ3dMLE1BQU0vSyxJQUFJLEdBQUc7Z0JBQy9DZ0wsTUFBTTVHLElBQUksR0FBR0E7Z0JBQ2I0RyxNQUFNUCxJQUFJLEdBQUdJO2dCQUNiRyxNQUFNaEwsSUFBSSxHQUFHQTtnQkFDYjJLLGVBQWU7WUFDakI7UUFDRjtRQUNBLElBQUssSUFBSTdLLEtBQUssR0FBR0EsS0FBS29HLFVBQVVwRyxLQUFNO1lBQ3BDNkssZUFBZTtZQUNmLElBQUssSUFBSTd6QixJQUFJLEdBQUdBLElBQUlvekIsVUFBVXB6QixJQUFLO2dCQUNqQyxJQUFJa3BCLE9BQU81RCxLQUFLLENBQUN0bEIsRUFBRTtnQkFDbkIsSUFBSXVvQixNQUFNVyxLQUFLdkYsTUFBTTtnQkFDckIsSUFBSWxiLE1BQU15Z0IsS0FBS3RGLE1BQU07Z0JBQ3JCLElBQUkwSyxVQUFVakIsU0FBU25FO2dCQUN2QixJQUFJaUwsVUFBVWQsUUFBUTlLO2dCQUN0QixJQUFJNkwsVUFBVWYsUUFBUTVxQjtnQkFDdEJxckIsd0JBQXdCdkwsS0FBSzlmLEtBQUt5Z0IsTUFBTWlMLFNBQVNDLFNBQVM5RjtnQkFFMUQsdUVBQXVFO2dCQUN2RSxJQUFJLENBQUNwSCxVQUFVO29CQUNiNE0sd0JBQXdCcnJCLEtBQUs4ZixLQUFLVyxNQUFNa0wsU0FBU0QsU0FBUzdGO2dCQUM1RDtZQUNGO1lBQ0EsSUFBSSxDQUFDdUYsY0FBYztnQkFDakI7WUFDRjtRQUNGO1FBQ0EsSUFBSUEsY0FBYztZQUNoQixtQ0FBbUM7WUFDbkMsSUFBSVEseUJBQXlCLEVBQUU7WUFDL0IsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUtsQixVQUFVa0IsS0FBTTtnQkFDcEMsSUFBSUMsUUFBUWpQLEtBQUssQ0FBQ2dQLEdBQUc7Z0JBQ3JCLElBQUlFLE9BQU9ELE1BQU01USxNQUFNO2dCQUN2QixJQUFJOFEsT0FBT0YsTUFBTTNRLE1BQU07Z0JBQ3ZCLElBQUk4USxXQUFXckgsU0FBU2tIO2dCQUN4QixJQUFJSSxVQUFVdEIsUUFBUW1CLE1BQU1sSCxJQUFJO2dCQUNoQyxJQUFJc0gsVUFBVXZCLFFBQVFvQixNQUFNbkgsSUFBSTtnQkFDaEMsSUFBSXFILFVBQVVELFdBQVdFLFdBQVcsQ0FBQzFOLFlBQVkwTixVQUFVRixXQUFXQyxTQUFTO29CQUM3RSxJQUFJLENBQUN6Qix3QkFBd0I7d0JBQzNCNVQsS0FBSzt3QkFDTDRULHlCQUF5QjtvQkFDM0I7b0JBQ0EsSUFBSXJmLFFBQVFnaEIsd0JBQXdCLEtBQUssT0FBTzt3QkFDOUMsSUFBSUMsZ0JBQWdCLEVBQUU7d0JBQ3RCLElBQUlILFVBQVVELFdBQVdFLFNBQVM7NEJBQ2hDRSxjQUFjdnlCLElBQUksQ0FBQ2l5Qjt3QkFDckI7d0JBQ0EsSUFBSSxDQUFDdE4sWUFBWTBOLFVBQVVGLFdBQVdDLFNBQVM7NEJBQzdDRyxjQUFjdnlCLElBQUksQ0FBQ2t5Qjt3QkFDckI7d0JBQ0EsSUFBSU0sbUJBQW1CRCxjQUFjLzBCLE1BQU07d0JBQzNDLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJODBCLGtCQUFrQjkwQixJQUFLOzRCQUN6QyxJQUFJKzBCLFFBQVFGLGFBQWEsQ0FBQzcwQixFQUFFOzRCQUM1QixJQUFJZzFCLFFBQVE7Z0NBQUNEOzZCQUFNOzRCQUNuQkMsTUFBTTF5QixJQUFJLENBQUM4d0IsUUFBUTJCLE9BQU85TCxJQUFJOzRCQUM5QixJQUFJZ00sUUFBUTdCLFFBQVEyQixPQUFPckIsSUFBSTs0QkFDL0IsTUFBT3NCLE1BQU14SixPQUFPLENBQUN5SixXQUFXLENBQUMsRUFBRztnQ0FDbENELE1BQU0xeUIsSUFBSSxDQUFDMnlCO2dDQUNYRCxNQUFNMXlCLElBQUksQ0FBQzh3QixRQUFRNkIsT0FBT2hNLElBQUk7Z0NBQzlCZ00sUUFBUTdCLFFBQVE2QixPQUFPdkIsSUFBSTs0QkFDN0I7NEJBQ0FzQixRQUFRQSxNQUFNOXhCLEtBQUssQ0FBQzh4QixNQUFNeEosT0FBTyxDQUFDeUo7NEJBQ2xDLElBQUlDLGFBQWFGLEtBQUssQ0FBQyxFQUFFLENBQUNsTixFQUFFOzRCQUM1QixJQUFJcU4sZ0JBQWdCOzRCQUNwQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUosTUFBTWwxQixNQUFNLEVBQUVzMUIsS0FBSyxFQUFHO2dDQUN4QyxJQUFJSixLQUFLLENBQUNJLEVBQUUsQ0FBQ3ROLEVBQUUsS0FBS29OLFlBQVk7b0NBQzlCQSxhQUFhRixLQUFLLENBQUNJLEVBQUUsQ0FBQ3ROLEVBQUU7b0NBQ3hCcU4sZ0JBQWdCQztnQ0FDbEI7NEJBQ0Y7NEJBQ0FKLFFBQVFBLE1BQU05eEIsS0FBSyxDQUFDaXlCLGVBQWV0SyxNQUFNLENBQUNtSyxNQUFNOXhCLEtBQUssQ0FBQyxHQUFHaXlCOzRCQUN6REgsTUFBTTF5QixJQUFJLENBQUMweUIsS0FBSyxDQUFDLEVBQUU7NEJBQ25CLElBQUlLLFVBQVVMLE1BQU1uaEIsR0FBRyxDQUFDLFNBQVU0TixFQUFFO2dDQUNsQyxPQUFPQSxHQUFHcUcsRUFBRTs0QkFDZCxHQUFHeGhCLElBQUksQ0FBQzs0QkFDUixJQUFJOHRCLHVCQUF1QjVJLE9BQU8sQ0FBQzZKLGFBQWEsQ0FBQyxHQUFHO2dDQUNsRG5DLHFCQUFxQjV3QixJQUFJLENBQUM2cUIsS0FBSzZCLEtBQUssQ0FBQ2dHO2dDQUNyQ1osdUJBQXVCOXhCLElBQUksQ0FBQyt5Qjs0QkFDOUI7d0JBQ0Y7b0JBQ0YsT0FBTzt3QkFDTDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxPQUFPO1lBQ0x4RyxZQUFZQTtZQUNaQyxRQUFRQTtZQUNSbUUsd0JBQXdCQTtZQUN4QkMsc0JBQXNCQTtRQUN4QjtJQUNGLEVBQUUsY0FBYztBQUNsQixHQUFHLFNBQVM7QUFFWixJQUFJb0MsUUFBUTF3QixLQUFLMndCLElBQUksQ0FBQztBQUV0QixrREFBa0Q7QUFDbEQsbUNBQW1DO0FBQ25DLDZEQUE2RDtBQUM3RCxJQUFJQyxXQUFXLFNBQVNBLFNBQVNDLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxjQUFjO0lBQ2pFLElBQUlBLGVBQWU3MUIsTUFBTSxLQUFLLEdBQUc7UUFDL0JrZ0IsTUFBTTtJQUNSO0lBQ0EsSUFBSTRWLFdBQVdELGNBQWMsQ0FBQ0YsVUFBVTtJQUN4QyxJQUFJSSxXQUFXRCxRQUFRLENBQUMsRUFBRTtJQUMxQixJQUFJRSxXQUFXRixRQUFRLENBQUMsRUFBRTtJQUMxQixJQUFJRyxhQUFhTCxPQUFPLENBQUNHLFNBQVM7SUFDbEMsSUFBSUcsYUFBYU4sT0FBTyxDQUFDSSxTQUFTO0lBQ2xDLElBQUlHLFdBQVdOLGdCQUFnQixlQUFlO0lBRTlDLHFEQUFxRDtJQUNyRCxJQUFLLElBQUl0ekIsSUFBSTR6QixTQUFTbjJCLE1BQU0sR0FBRyxHQUFHdUMsS0FBSyxHQUFHQSxJQUFLO1FBQzdDLElBQUk0bUIsT0FBT2dOLFFBQVEsQ0FBQzV6QixFQUFFO1FBQ3RCLElBQUlpbUIsTUFBTVcsSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSXpnQixNQUFNeWdCLElBQUksQ0FBQyxFQUFFO1FBQ2pCLElBQUl5TSxPQUFPLENBQUNwTixJQUFJLEtBQUt5TixjQUFjTCxPQUFPLENBQUNsdEIsSUFBSSxLQUFLd3RCLGNBQWNOLE9BQU8sQ0FBQ3BOLElBQUksS0FBSzBOLGNBQWNOLE9BQU8sQ0FBQ2x0QixJQUFJLEtBQUt1dEIsWUFBWTtZQUM1SEUsU0FBUzNVLE1BQU0sQ0FBQ2pmLEdBQUc7UUFDckI7SUFDRjtJQUVBLGtFQUFrRTtJQUNsRSxJQUFLLElBQUkwbUIsS0FBSyxHQUFHQSxLQUFLa04sU0FBU24yQixNQUFNLEVBQUVpcEIsS0FBTTtRQUMzQyxJQUFJdUwsUUFBUTJCLFFBQVEsQ0FBQ2xOLEdBQUc7UUFDeEIsSUFBSXVMLEtBQUssQ0FBQyxFQUFFLEtBQUswQixZQUFZO1lBQzNCLGVBQWU7WUFDZkMsUUFBUSxDQUFDbE4sR0FBRyxHQUFHdUwsTUFBTXB4QixLQUFLLElBQUksT0FBTztZQUNyQyt5QixRQUFRLENBQUNsTixHQUFHLENBQUMsRUFBRSxHQUFHZ047UUFDcEIsT0FBTyxJQUFJekIsS0FBSyxDQUFDLEVBQUUsS0FBSzBCLFlBQVk7WUFDbEMsZUFBZTtZQUNmQyxRQUFRLENBQUNsTixHQUFHLEdBQUd1TCxNQUFNcHhCLEtBQUssSUFBSSxPQUFPO1lBQ3JDK3lCLFFBQVEsQ0FBQ2xOLEdBQUcsQ0FBQyxFQUFFLEdBQUdnTjtRQUNwQjtJQUNGO0lBRUEsK0NBQStDO0lBQy9DLElBQUssSUFBSXBOLE1BQU0sR0FBR0EsTUFBTStNLFFBQVE1MUIsTUFBTSxFQUFFNm9CLE1BQU87UUFDN0MsSUFBSStNLE9BQU8sQ0FBQy9NLElBQUksS0FBS3FOLFlBQVk7WUFDL0JOLE9BQU8sQ0FBQy9NLElBQUksR0FBR29OO1FBQ2pCO0lBQ0Y7SUFDQSxPQUFPRTtBQUNUO0FBRUEsa0VBQWtFO0FBQ2xFLElBQUlDLGdCQUFnQixTQUFTQSxjQUFjQyxXQUFXLEVBQUVSLGNBQWMsRUFBRWhULElBQUksRUFBRXlULFNBQVM7SUFDckYsTUFBT3pULE9BQU95VCxVQUFXO1FBQ3ZCLDBCQUEwQjtRQUMxQixJQUFJWCxZQUFZN3dCLEtBQUtDLEtBQUssQ0FBQ0QsS0FBSzhiLE1BQU0sS0FBS2lWLGVBQWU3MUIsTUFBTTtRQUVoRSwrQkFBK0I7UUFDL0I2MUIsaUJBQWlCSCxTQUFTQyxXQUFXVSxhQUFhUjtRQUNsRGhUO0lBQ0Y7SUFDQSxPQUFPZ1Q7QUFDVDtBQUNBLElBQUlVLFdBQVc7SUFDYixrREFBa0Q7SUFDbEQsbURBQW1EO0lBQ25EQyxhQUFhLFNBQVNBO1FBQ3BCLElBQUl4VCxRQUFRLElBQUk7UUFDaEIsSUFBSTJFLGdCQUFnQixJQUFJLENBQUNDLE9BQU8sSUFDOUJDLFFBQVFGLGNBQWNFLEtBQUssRUFDM0J0QyxRQUFRb0MsY0FBY3BDLEtBQUs7UUFDN0JBLE1BQU1tSSxTQUFTLENBQUMsU0FBVXZFLElBQUk7WUFDNUIsT0FBT0EsS0FBS3dFLE1BQU07UUFDcEI7UUFDQSxJQUFJMEIsV0FBV3hILE1BQU03bkIsTUFBTTtRQUMzQixJQUFJcXpCLFdBQVc5TixNQUFNdmxCLE1BQU07UUFDM0IsSUFBSXkyQixVQUFVM3hCLEtBQUs0eEIsSUFBSSxDQUFDNXhCLEtBQUs2eEIsR0FBRyxDQUFDN3hCLEtBQUt3YixHQUFHLENBQUMrTyxZQUFZdnFCLEtBQUs4eEIsR0FBRyxFQUFFO1FBQ2hFLElBQUlDLFdBQVcveEIsS0FBS0MsS0FBSyxDQUFDc3FCLFdBQVdtRztRQUNyQyxJQUFJbkcsV0FBVyxHQUFHO1lBQ2hCblAsTUFBTTtZQUNOLE9BQU9uZDtRQUNUO1FBRUEsd0NBQXdDO1FBQ3hDLDBFQUEwRTtRQUMxRSxJQUFJK3pCLGNBQWMsRUFBRTtRQUNwQixJQUFLLElBQUl2MEIsSUFBSSxHQUFHQSxJQUFJOHdCLFVBQVU5d0IsSUFBSztZQUNqQyxJQUFJdEMsSUFBSXNsQixLQUFLLENBQUNoakIsRUFBRTtZQUNoQnUwQixZQUFZdDBCLElBQUksQ0FBQztnQkFBQ0Q7Z0JBQUdzbEIsTUFBTTZELE9BQU8sQ0FBQ3pyQixFQUFFMmpCLE1BQU07Z0JBQUtpRSxNQUFNNkQsT0FBTyxDQUFDenJCLEVBQUU0akIsTUFBTTthQUFJO1FBQzVFO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUlrVCxhQUFhaEo7UUFDakIsSUFBSWlKLG9CQUFvQixFQUFFO1FBQzFCLElBQUlDLGdCQUFnQixJQUFJOTJCLE1BQU1rdkI7UUFFOUIsOEJBQThCO1FBQzlCLElBQUlnSCxjQUFjLElBQUlsMkIsTUFBTWt2QjtRQUM1QixJQUFJNkgsZUFBZSxJQUFJLzJCLE1BQU1rdkI7UUFDN0IsSUFBSThILGVBQWUsU0FBU0EsYUFBYS8wQixJQUFJLEVBQUV3d0IsRUFBRTtZQUMvQyxJQUFLLElBQUl3RSxNQUFNLEdBQUdBLE1BQU0vSCxVQUFVK0gsTUFBTztnQkFDdkN4RSxFQUFFLENBQUN3RSxJQUFJLEdBQUdoMUIsSUFBSSxDQUFDZzFCLElBQUk7WUFDckI7UUFDRjtRQUVBLFlBQVk7UUFDWixJQUFLLElBQUlDLE9BQU8sR0FBR0EsUUFBUVosU0FBU1ksT0FBUTtZQUMxQyw0QkFBNEI7WUFDNUIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1qSSxVQUFVaUksTUFBTztnQkFDdkNqQixXQUFXLENBQUNpQixJQUFJLEdBQUdBO1lBQ3JCO1lBRUEsNkNBQTZDO1lBQzdDLElBQUlDLGFBQWFuQixjQUFjQyxhQUFhUyxZQUFZMXpCLEtBQUssSUFBSWlzQixVQUFVd0g7WUFDM0UsSUFBSVcsY0FBY0QsV0FBV24wQixLQUFLLElBQUksT0FBTztZQUU3Qyw0Q0FBNEM7WUFDNUMrekIsYUFBYWQsYUFBYWE7WUFFMUIsOENBQThDO1lBQzlDLElBQUlPLE9BQU9yQixjQUFjQyxhQUFha0IsWUFBWVYsVUFBVTtZQUM1RCxJQUFJYSxPQUFPdEIsY0FBY2MsY0FBY00sYUFBYVgsVUFBVTtZQUU5RCwrQ0FBK0M7WUFDL0MsSUFBSVksS0FBS3ozQixNQUFNLElBQUkwM0IsS0FBSzEzQixNQUFNLElBQUl5M0IsS0FBS3ozQixNQUFNLEdBQUcrMkIsWUFBWTtnQkFDMURBLGFBQWFVLEtBQUt6M0IsTUFBTTtnQkFDeEJnM0Isb0JBQW9CUztnQkFDcEJOLGFBQWFkLGFBQWFZO1lBQzVCLE9BQU8sSUFBSVMsS0FBSzEzQixNQUFNLElBQUl5M0IsS0FBS3ozQixNQUFNLElBQUkwM0IsS0FBSzEzQixNQUFNLEdBQUcrMkIsWUFBWTtnQkFDakVBLGFBQWFXLEtBQUsxM0IsTUFBTTtnQkFDeEJnM0Isb0JBQW9CVTtnQkFDcEJQLGFBQWFELGNBQWNEO1lBQzdCO1FBQ0YsRUFBRSxtQkFBbUI7UUFFckIsbUJBQW1CO1FBQ25CLElBQUlVLE1BQU0sSUFBSSxDQUFDekksS0FBSyxDQUFDOEgsa0JBQWtCampCLEdBQUcsQ0FBQyxTQUFVOVQsQ0FBQztZQUNwRCxPQUFPc2xCLEtBQUssQ0FBQ3RsQixDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3BCO1FBQ0EsSUFBSWcyQixhQUFhLElBQUksQ0FBQy9HLEtBQUs7UUFDM0IsSUFBSWdILGFBQWEsSUFBSSxDQUFDaEgsS0FBSztRQUUzQixvQ0FBb0M7UUFDcEMsSUFBSTBJLHVCQUF1QlgsYUFBYSxDQUFDLEVBQUU7UUFDM0MsSUFBSyxJQUFJWSxNQUFNLEdBQUdBLE1BQU1aLGNBQWNqM0IsTUFBTSxFQUFFNjNCLE1BQU87WUFDbkQsSUFBSUMsY0FBY2IsYUFBYSxDQUFDWSxJQUFJO1lBQ3BDLElBQUkzTyxPQUFPckIsS0FBSyxDQUFDZ1EsSUFBSTtZQUNyQixJQUFJQyxnQkFBZ0JGLHNCQUFzQjtnQkFDeEMzQixXQUFXcEcsS0FBSyxDQUFDM0c7WUFDbkIsT0FBTztnQkFDTGdOLFdBQVdyRyxLQUFLLENBQUMzRztZQUNuQjtRQUNGO1FBRUEsc0VBQXNFO1FBQ3RFLElBQUk2TyxxQkFBcUIsU0FBU0EsbUJBQW1CQyxNQUFNO1lBQ3pELElBQUlDLFlBQVlqVixNQUFNa00sS0FBSztZQUMzQjhJLE9BQU85VSxPQUFPLENBQUMsU0FBVWdHLElBQUk7Z0JBQzNCK08sVUFBVXBJLEtBQUssQ0FBQzNHO2dCQUNoQkEsS0FBS04sY0FBYyxHQUFHMUYsT0FBTyxDQUFDLFNBQVVpRyxJQUFJO29CQUMxQyxrRUFBa0U7b0JBQ2xFLElBQUluRyxNQUFNc0osUUFBUSxDQUFDbkQsU0FBUyxDQUFDd08sSUFBSXJMLFFBQVEsQ0FBQ25ELE9BQU87d0JBQy9DOE8sVUFBVXBJLEtBQUssQ0FBQzFHO29CQUNsQjtnQkFDRjtZQUNGO1lBQ0EsT0FBTzhPO1FBQ1Q7UUFDQSxJQUFJQyxhQUFhO1lBQUNILG1CQUFtQjlCO1lBQWE4QixtQkFBbUI3QjtTQUFZO1FBQ2pGLElBQUl0dkIsTUFBTTtZQUNSK3dCLEtBQUtBO1lBQ0xPLFlBQVlBO1lBQ1osc0VBQXNFO1lBQ3RFLCtDQUErQztZQUMvQ2pDLFlBQVlBO1lBQ1pDLFlBQVlBO1FBQ2Q7UUFDQSxPQUFPdHZCO0lBQ1Q7QUFDRixHQUFHLFNBQVM7QUFFWixJQUFJdXhCO0FBQ0osSUFBSUMsZUFBZSxTQUFTQSxhQUFhN3VCLENBQUM7SUFDeEMsT0FBTztRQUNMK0ssR0FBRy9LLEVBQUUrSyxDQUFDO1FBQ055SixHQUFHeFUsRUFBRXdVLENBQUM7SUFDUjtBQUNGO0FBQ0EsSUFBSXNhLDRCQUE0QixTQUFTQyx3QkFBd0IvdUIsQ0FBQyxFQUFFaWQsSUFBSSxFQUFFRCxHQUFHO0lBQzNFLE9BQU87UUFDTGpTLEdBQUcvSyxFQUFFK0ssQ0FBQyxHQUFHa1MsT0FBT0QsSUFBSWpTLENBQUM7UUFDckJ5SixHQUFHeFUsRUFBRXdVLENBQUMsR0FBR3lJLE9BQU9ELElBQUl4SSxDQUFDO0lBQ3ZCO0FBQ0Y7QUFDQSxJQUFJd2EsMEJBQTBCLFNBQVNBLHdCQUF3Qmh2QixDQUFDLEVBQUVpZCxJQUFJLEVBQUVELEdBQUc7SUFDekUsT0FBTztRQUNMalMsR0FBRyxDQUFDL0ssRUFBRStLLENBQUMsR0FBR2lTLElBQUlqUyxDQUFDLElBQUlrUztRQUNuQnpJLEdBQUcsQ0FBQ3hVLEVBQUV3VSxDQUFDLEdBQUd3SSxJQUFJeEksQ0FBQyxJQUFJeUk7SUFDckI7QUFDRjtBQUNBLElBQUlnUyxjQUFjLFNBQVNBLFlBQVk5WCxHQUFHO0lBQ3hDLE9BQU87UUFDTHBNLEdBQUdvTSxHQUFHLENBQUMsRUFBRTtRQUNUM0MsR0FBRzJDLEdBQUcsQ0FBQyxFQUFFO0lBQ1g7QUFDRjtBQUNBLElBQUk3RyxNQUFNLFNBQVNBLElBQUk2RyxHQUFHO0lBQ3hCLElBQUkrWCxRQUFRbnlCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNoRixJQUFJb3RCLE1BQU1wdEIsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHb2EsSUFBSTFnQixNQUFNO0lBQ3hGLElBQUk2WixNQUFNa1U7SUFDVixJQUFLLElBQUl4ckIsSUFBSWsyQixPQUFPbDJCLElBQUlteEIsS0FBS254QixJQUFLO1FBQ2hDLElBQUkyZixNQUFNeEIsR0FBRyxDQUFDbmUsRUFBRTtRQUNoQixJQUFJbTJCLFNBQVN4VyxNQUFNO1lBQ2pCckksTUFBTS9VLEtBQUsrVSxHQUFHLENBQUNxSSxLQUFLckk7UUFDdEI7SUFDRjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJRixNQUFNLFNBQVNBLElBQUkrRyxHQUFHO0lBQ3hCLElBQUkrWCxRQUFRbnlCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNoRixJQUFJb3RCLE1BQU1wdEIsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHb2EsSUFBSTFnQixNQUFNO0lBQ3hGLElBQUkyWixNQUFNLENBQUNvVTtJQUNYLElBQUssSUFBSXhyQixJQUFJazJCLE9BQU9sMkIsSUFBSW14QixLQUFLbnhCLElBQUs7UUFDaEMsSUFBSTJmLE1BQU14QixHQUFHLENBQUNuZSxFQUFFO1FBQ2hCLElBQUltMkIsU0FBU3hXLE1BQU07WUFDakJ2SSxNQUFNN1UsS0FBSzZVLEdBQUcsQ0FBQ3VJLEtBQUt2STtRQUN0QjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLElBQUlnZixPQUFPLFNBQVNBLEtBQUtqWSxHQUFHO0lBQzFCLElBQUkrWCxRQUFRbnlCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNoRixJQUFJb3RCLE1BQU1wdEIsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHb2EsSUFBSTFnQixNQUFNO0lBQ3hGLElBQUk0NEIsUUFBUTtJQUNaLElBQUkxNEIsSUFBSTtJQUNSLElBQUssSUFBSXFDLElBQUlrMkIsT0FBT2wyQixJQUFJbXhCLEtBQUtueEIsSUFBSztRQUNoQyxJQUFJMmYsTUFBTXhCLEdBQUcsQ0FBQ25lLEVBQUU7UUFDaEIsSUFBSW0yQixTQUFTeFcsTUFBTTtZQUNqQjBXLFNBQVMxVztZQUNUaGlCO1FBQ0Y7SUFDRjtJQUNBLE9BQU8wNEIsUUFBUTE0QjtBQUNqQjtBQUNBLElBQUkyNEIsU0FBUyxTQUFTQSxPQUFPblksR0FBRztJQUM5QixJQUFJK1gsUUFBUW55QixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDaEYsSUFBSW90QixNQUFNcHRCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBR29hLElBQUkxZ0IsTUFBTTtJQUN4RixJQUFJd2dCLE9BQU9sYSxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDL0UsSUFBSXNsQixPQUFPdGxCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUMvRSxJQUFJd3lCLGVBQWV4eUIsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3ZGLElBQUlrYSxNQUFNO1FBQ1JFLE1BQU1BLElBQUl0ZCxLQUFLLENBQUNxMUIsT0FBTy9FO0lBQ3pCLE9BQU87UUFDTCxJQUFJQSxNQUFNaFQsSUFBSTFnQixNQUFNLEVBQUU7WUFDcEIwZ0IsSUFBSWMsTUFBTSxDQUFDa1MsS0FBS2hULElBQUkxZ0IsTUFBTSxHQUFHMHpCO1FBQy9CO1FBQ0EsSUFBSStFLFFBQVEsR0FBRztZQUNiL1gsSUFBSWMsTUFBTSxDQUFDLEdBQUdpWDtRQUNoQjtJQUNGO0lBRUEseUZBQXlGO0lBQ3pGLElBQUlNLE1BQU0sR0FBRyxnQ0FBZ0M7SUFDN0MsSUFBSyxJQUFJeDJCLElBQUltZSxJQUFJMWdCLE1BQU0sR0FBRyxHQUFHdUMsS0FBSyxHQUFHQSxJQUFLO1FBQ3hDLElBQUk0RSxJQUFJdVosR0FBRyxDQUFDbmUsRUFBRTtRQUNkLElBQUl1MkIsY0FBYztZQUNoQixJQUFJLENBQUNKLFNBQVN2eEIsSUFBSTtnQkFDaEJ1WixHQUFHLENBQUNuZSxFQUFFLEdBQUcsQ0FBQ3dyQjtnQkFDVmdMO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsb0RBQW9EO1lBQ3BEclksSUFBSWMsTUFBTSxDQUFDamYsR0FBRztRQUNoQjtJQUNGO0lBQ0EsSUFBSXFwQixNQUFNO1FBQ1JsTCxJQUFJa0wsSUFBSSxDQUFDLFNBQVU3ckIsQ0FBQyxFQUFFc0ksQ0FBQztZQUNyQixPQUFPdEksSUFBSXNJO1FBQ2IsSUFBSSw0REFBNEQ7SUFDbEU7SUFDQSxJQUFJMndCLE1BQU10WSxJQUFJMWdCLE1BQU07SUFDcEIsSUFBSThxQixNQUFNaG1CLEtBQUtDLEtBQUssQ0FBQ2kwQixNQUFNO0lBQzNCLElBQUlBLE1BQU0sTUFBTSxHQUFHO1FBQ2pCLE9BQU90WSxHQUFHLENBQUNvSyxNQUFNLElBQUlpTyxJQUFJO0lBQzNCLE9BQU87UUFDTCxPQUFPLENBQUNyWSxHQUFHLENBQUNvSyxNQUFNLElBQUlpTyxJQUFJLEdBQUdyWSxHQUFHLENBQUNvSyxNQUFNaU8sSUFBSSxJQUFJO0lBQ2pEO0FBQ0Y7QUFDQSxJQUFJRSxVQUFVLFNBQVNBLFFBQVFDLEdBQUc7SUFDaEMsT0FBT3AwQixLQUFLc1osRUFBRSxHQUFHOGEsTUFBTTtBQUN6QjtBQUNBLElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJDLEtBQUssRUFBRUMsS0FBSztJQUMzRCxPQUFPdjBCLEtBQUt3MEIsS0FBSyxDQUFDRCxPQUFPRCxTQUFTdDBCLEtBQUtzWixFQUFFLEdBQUc7QUFDOUM7QUFDQSxJQUFJbWIsT0FBT3owQixLQUFLeTBCLElBQUksSUFBSSxTQUFVcjVCLENBQUM7SUFDakMsT0FBTzRFLEtBQUt3YixHQUFHLENBQUNwZ0IsS0FBSzRFLEtBQUt3YixHQUFHLENBQUM7QUFDaEM7QUFDQSxJQUFJa1osU0FBUyxTQUFTQSxPQUFPbGxCLENBQUM7SUFDNUIsSUFBSUEsSUFBSSxHQUFHO1FBQ1QsT0FBTztJQUNULE9BQU8sSUFBSUEsSUFBSSxHQUFHO1FBQ2hCLE9BQU8sQ0FBQztJQUNWLE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUNBLElBQUlpWixPQUFPLFNBQVNBLEtBQUtrTSxFQUFFLEVBQUVDLEVBQUU7SUFDN0IsT0FBTzUwQixLQUFLMndCLElBQUksQ0FBQ2tFLE9BQU9GLElBQUlDO0FBQzlCO0FBQ0EsSUFBSUMsU0FBUyxTQUFTQSxPQUFPRixFQUFFLEVBQUVDLEVBQUU7SUFDakMsSUFBSUUsS0FBS0YsR0FBR3BsQixDQUFDLEdBQUdtbEIsR0FBR25sQixDQUFDO0lBQ3BCLElBQUl1bEIsS0FBS0gsR0FBRzNiLENBQUMsR0FBRzBiLEdBQUcxYixDQUFDO0lBQ3BCLE9BQU82YixLQUFLQSxLQUFLQyxLQUFLQTtBQUN4QjtBQUNBLElBQUlDLHNCQUFzQixTQUFTQSxvQkFBb0IzeUIsQ0FBQztJQUN0RCxJQUFJbkgsU0FBU21ILEVBQUVuSCxNQUFNO0lBRXJCLGlDQUFpQztJQUNqQyxJQUFJNDRCLFFBQVE7SUFDWixJQUFLLElBQUlyMkIsSUFBSSxHQUFHQSxJQUFJdkMsUUFBUXVDLElBQUs7UUFDL0JxMkIsU0FBU3p4QixDQUFDLENBQUM1RSxFQUFFO0lBQ2Y7SUFFQSw4Q0FBOEM7SUFDOUMsSUFBSyxJQUFJMG1CLEtBQUssR0FBR0EsS0FBS2pwQixRQUFRaXBCLEtBQU07UUFDbEM5aEIsQ0FBQyxDQUFDOGhCLEdBQUcsR0FBRzloQixDQUFDLENBQUM4aEIsR0FBRyxHQUFHMlA7SUFDbEI7SUFDQSxPQUFPenhCO0FBQ1Q7QUFFQSxrRUFBa0U7QUFDbEUsSUFBSTR5QixZQUFZLFNBQVNBLFVBQVVDLEVBQUUsRUFBRVAsRUFBRSxFQUFFQyxFQUFFLEVBQUVoNUIsQ0FBQztJQUM5QyxPQUFPLENBQUMsSUFBSUEsQ0FBQUEsSUFBTSxLQUFJQSxDQUFBQSxJQUFLczVCLEtBQUssSUFBSyxLQUFJdDVCLENBQUFBLElBQUtBLElBQUkrNEIsS0FBSy80QixJQUFJQSxJQUFJZzVCO0FBQ2pFO0FBQ0EsSUFBSU8sY0FBYyxTQUFTQSxZQUFZRCxFQUFFLEVBQUVQLEVBQUUsRUFBRUMsRUFBRSxFQUFFaDVCLENBQUM7SUFDbEQsT0FBTztRQUNMNFQsR0FBR3lsQixVQUFVQyxHQUFHMWxCLENBQUMsRUFBRW1sQixHQUFHbmxCLENBQUMsRUFBRW9sQixHQUFHcGxCLENBQUMsRUFBRTVUO1FBQy9CcWQsR0FBR2djLFVBQVVDLEdBQUdqYyxDQUFDLEVBQUUwYixHQUFHMWIsQ0FBQyxFQUFFMmIsR0FBRzNiLENBQUMsRUFBRXJkO0lBQ2pDO0FBQ0Y7QUFDQSxJQUFJdzVCLFNBQVMsU0FBU0EsT0FBT0YsRUFBRSxFQUFFUCxFQUFFLEVBQUUvNEIsQ0FBQyxFQUFFb3RCLENBQUM7SUFDdkMsSUFBSXFNLE1BQU07UUFDUjdsQixHQUFHbWxCLEdBQUdubEIsQ0FBQyxHQUFHMGxCLEdBQUcxbEIsQ0FBQztRQUNkeUosR0FBRzBiLEdBQUcxYixDQUFDLEdBQUdpYyxHQUFHamMsQ0FBQztJQUNoQjtJQUNBLElBQUlxYyxVQUFVN00sS0FBS3lNLElBQUlQO0lBQ3ZCLElBQUlZLFVBQVU7UUFDWi9sQixHQUFHNmxCLElBQUk3bEIsQ0FBQyxHQUFHOGxCO1FBQ1hyYyxHQUFHb2MsSUFBSXBjLENBQUMsR0FBR3FjO0lBQ2I7SUFDQTE1QixJQUFJQSxLQUFLLE9BQU8sSUFBSUE7SUFDcEJvdEIsSUFBSUEsS0FBSyxPQUFPQSxJQUFJcHRCLElBQUkwNUI7SUFDeEIsT0FBTztRQUNMOWxCLEdBQUcwbEIsR0FBRzFsQixDQUFDLEdBQUcrbEIsUUFBUS9sQixDQUFDLEdBQUd3WjtRQUN0Qi9QLEdBQUdpYyxHQUFHamMsQ0FBQyxHQUFHc2MsUUFBUXRjLENBQUMsR0FBRytQO0lBQ3hCO0FBQ0Y7QUFDQSxJQUFJd00sUUFBUSxTQUFTQSxNQUFNemdCLEdBQUcsRUFBRXFJLEdBQUcsRUFBRXZJLEdBQUc7SUFDdEMsT0FBTzdVLEtBQUs2VSxHQUFHLENBQUNFLEtBQUsvVSxLQUFLK1UsR0FBRyxDQUFDRixLQUFLdUk7QUFDckM7QUFFQSw4REFBOEQ7QUFDOUQsSUFBSXFZLGtCQUFrQixTQUFTQSxnQkFBZ0JDLEVBQUU7SUFDL0MsSUFBSUEsTUFBTSxNQUFNO1FBQ2QsT0FBTztZQUNMNTBCLElBQUltb0I7WUFDSmpvQixJQUFJaW9CO1lBQ0psb0IsSUFBSSxDQUFDa29CO1lBQ0xob0IsSUFBSSxDQUFDZ29CO1lBQ0w5TyxHQUFHO1lBQ0g1VixHQUFHO1FBQ0w7SUFDRixPQUFPLElBQUlteEIsR0FBRzUwQixFQUFFLElBQUksUUFBUTQwQixHQUFHMTBCLEVBQUUsSUFBSSxNQUFNO1FBQ3pDLElBQUkwMEIsR0FBRzMwQixFQUFFLElBQUksUUFBUTIwQixHQUFHejBCLEVBQUUsSUFBSSxRQUFReTBCLEdBQUczMEIsRUFBRSxJQUFJMjBCLEdBQUc1MEIsRUFBRSxJQUFJNDBCLEdBQUd6MEIsRUFBRSxJQUFJeTBCLEdBQUcxMEIsRUFBRSxFQUFFO1lBQ3RFLE9BQU87Z0JBQ0xGLElBQUk0MEIsR0FBRzUwQixFQUFFO2dCQUNURSxJQUFJMDBCLEdBQUcxMEIsRUFBRTtnQkFDVEQsSUFBSTIwQixHQUFHMzBCLEVBQUU7Z0JBQ1RFLElBQUl5MEIsR0FBR3owQixFQUFFO2dCQUNUa1osR0FBR3ViLEdBQUczMEIsRUFBRSxHQUFHMjBCLEdBQUc1MEIsRUFBRTtnQkFDaEJ5RCxHQUFHbXhCLEdBQUd6MEIsRUFBRSxHQUFHeTBCLEdBQUcxMEIsRUFBRTtZQUNsQjtRQUNGLE9BQU8sSUFBSTAwQixHQUFHdmIsQ0FBQyxJQUFJLFFBQVF1YixHQUFHbnhCLENBQUMsSUFBSSxRQUFRbXhCLEdBQUd2YixDQUFDLElBQUksS0FBS3ViLEdBQUdueEIsQ0FBQyxJQUFJLEdBQUc7WUFDakUsT0FBTztnQkFDTHpELElBQUk0MEIsR0FBRzUwQixFQUFFO2dCQUNURSxJQUFJMDBCLEdBQUcxMEIsRUFBRTtnQkFDVEQsSUFBSTIwQixHQUFHNTBCLEVBQUUsR0FBRzQwQixHQUFHdmIsQ0FBQztnQkFDaEJsWixJQUFJeTBCLEdBQUcxMEIsRUFBRSxHQUFHMDBCLEdBQUdueEIsQ0FBQztnQkFDaEI0VixHQUFHdWIsR0FBR3ZiLENBQUM7Z0JBQ1A1VixHQUFHbXhCLEdBQUdueEIsQ0FBQztZQUNUO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSW94QixrQkFBa0IsU0FBU0EsZ0JBQWdCRCxFQUFFO0lBQy9DLE9BQU87UUFDTDUwQixJQUFJNDBCLEdBQUc1MEIsRUFBRTtRQUNUQyxJQUFJMjBCLEdBQUczMEIsRUFBRTtRQUNUb1osR0FBR3ViLEdBQUd2YixDQUFDO1FBQ1BuWixJQUFJMDBCLEdBQUcxMEIsRUFBRTtRQUNUQyxJQUFJeTBCLEdBQUd6MEIsRUFBRTtRQUNUc0QsR0FBR214QixHQUFHbnhCLENBQUM7SUFDVDtBQUNGO0FBQ0EsSUFBSXF4QixtQkFBbUIsU0FBU0EsaUJBQWlCRixFQUFFO0lBQ2pEQSxHQUFHNTBCLEVBQUUsR0FBR21vQjtJQUNSeU0sR0FBRzEwQixFQUFFLEdBQUdpb0I7SUFDUnlNLEdBQUczMEIsRUFBRSxHQUFHLENBQUNrb0I7SUFDVHlNLEdBQUd6MEIsRUFBRSxHQUFHLENBQUNnb0I7SUFDVHlNLEdBQUd2YixDQUFDLEdBQUc7SUFDUHViLEdBQUdueEIsQ0FBQyxHQUFHO0FBQ1Q7QUFDQSxJQUFJc3hCLG9CQUFvQixTQUFTQSxrQkFBa0JDLEdBQUcsRUFBRUMsR0FBRztJQUN6RCw2QkFBNkI7SUFFN0JELElBQUloMUIsRUFBRSxHQUFHZCxLQUFLK1UsR0FBRyxDQUFDK2dCLElBQUloMUIsRUFBRSxFQUFFaTFCLElBQUlqMUIsRUFBRTtJQUNoQ2cxQixJQUFJLzBCLEVBQUUsR0FBR2YsS0FBSzZVLEdBQUcsQ0FBQ2loQixJQUFJLzBCLEVBQUUsRUFBRWcxQixJQUFJaDFCLEVBQUU7SUFDaEMrMEIsSUFBSTNiLENBQUMsR0FBRzJiLElBQUkvMEIsRUFBRSxHQUFHKzBCLElBQUloMUIsRUFBRTtJQUN2QmcxQixJQUFJOTBCLEVBQUUsR0FBR2hCLEtBQUsrVSxHQUFHLENBQUMrZ0IsSUFBSTkwQixFQUFFLEVBQUUrMEIsSUFBSS8wQixFQUFFO0lBQ2hDODBCLElBQUk3MEIsRUFBRSxHQUFHakIsS0FBSzZVLEdBQUcsQ0FBQ2loQixJQUFJNzBCLEVBQUUsRUFBRTgwQixJQUFJOTBCLEVBQUU7SUFDaEM2MEIsSUFBSXZ4QixDQUFDLEdBQUd1eEIsSUFBSTcwQixFQUFFLEdBQUc2MEIsSUFBSTkwQixFQUFFO0FBQ3pCO0FBQ0EsSUFBSWcxQiwyQkFBMkIsU0FBU0EseUJBQXlCTixFQUFFLEVBQUVsbUIsQ0FBQyxFQUFFeUosQ0FBQztJQUN2RXljLEdBQUc1MEIsRUFBRSxHQUFHZCxLQUFLK1UsR0FBRyxDQUFDMmdCLEdBQUc1MEIsRUFBRSxFQUFFME87SUFDeEJrbUIsR0FBRzMwQixFQUFFLEdBQUdmLEtBQUs2VSxHQUFHLENBQUM2Z0IsR0FBRzMwQixFQUFFLEVBQUV5TztJQUN4QmttQixHQUFHdmIsQ0FBQyxHQUFHdWIsR0FBRzMwQixFQUFFLEdBQUcyMEIsR0FBRzUwQixFQUFFO0lBQ3BCNDBCLEdBQUcxMEIsRUFBRSxHQUFHaEIsS0FBSytVLEdBQUcsQ0FBQzJnQixHQUFHMTBCLEVBQUUsRUFBRWlZO0lBQ3hCeWMsR0FBR3owQixFQUFFLEdBQUdqQixLQUFLNlUsR0FBRyxDQUFDNmdCLEdBQUd6MEIsRUFBRSxFQUFFZ1k7SUFDeEJ5YyxHQUFHbnhCLENBQUMsR0FBR214QixHQUFHejBCLEVBQUUsR0FBR3kwQixHQUFHMTBCLEVBQUU7QUFDdEI7QUFDQSxJQUFJaTFCLG9CQUFvQixTQUFTQSxrQkFBa0JQLEVBQUU7SUFDbkQsSUFBSVEsVUFBVTEwQixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDbEZrMEIsR0FBRzUwQixFQUFFLElBQUlvMUI7SUFDVFIsR0FBRzMwQixFQUFFLElBQUltMUI7SUFDVFIsR0FBRzEwQixFQUFFLElBQUlrMUI7SUFDVFIsR0FBR3owQixFQUFFLElBQUlpMUI7SUFDVFIsR0FBR3ZiLENBQUMsR0FBR3ViLEdBQUczMEIsRUFBRSxHQUFHMjBCLEdBQUc1MEIsRUFBRTtJQUNwQjQwQixHQUFHbnhCLENBQUMsR0FBR214QixHQUFHejBCLEVBQUUsR0FBR3kwQixHQUFHMTBCLEVBQUU7SUFDcEIsT0FBTzAwQjtBQUNUO0FBQ0EsSUFBSVMseUJBQXlCLFNBQVNBLHVCQUF1QlQsRUFBRTtJQUM3RCxJQUFJUSxVQUFVMTBCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUFDO0tBQUU7SUFDckYsSUFBSW9tQixLQUFLd08sT0FBT0MsUUFBUUM7SUFDeEIsSUFBSUosUUFBUWg3QixNQUFNLEtBQUssR0FBRztRQUN4QjBzQixNQUFNd08sUUFBUUMsU0FBU0MsT0FBT0osT0FBTyxDQUFDLEVBQUU7SUFDMUMsT0FBTyxJQUFJQSxRQUFRaDdCLE1BQU0sS0FBSyxHQUFHO1FBQy9CMHNCLE1BQU15TyxTQUFTSCxPQUFPLENBQUMsRUFBRTtRQUN6QkksT0FBT0YsUUFBUUYsT0FBTyxDQUFDLEVBQUU7SUFDM0IsT0FBTyxJQUFJQSxRQUFRaDdCLE1BQU0sS0FBSyxHQUFHO1FBQy9CLElBQUlxN0IsV0FBVzE0QixlQUFlcTRCLFNBQVM7UUFDdkN0TyxNQUFNMk8sUUFBUSxDQUFDLEVBQUU7UUFDakJILFFBQVFHLFFBQVEsQ0FBQyxFQUFFO1FBQ25CRixTQUFTRSxRQUFRLENBQUMsRUFBRTtRQUNwQkQsT0FBT0MsUUFBUSxDQUFDLEVBQUU7SUFDcEI7SUFDQWIsR0FBRzUwQixFQUFFLElBQUl3MUI7SUFDVFosR0FBRzMwQixFQUFFLElBQUlxMUI7SUFDVFYsR0FBRzEwQixFQUFFLElBQUk0bUI7SUFDVDhOLEdBQUd6MEIsRUFBRSxJQUFJbzFCO0lBQ1RYLEdBQUd2YixDQUFDLEdBQUd1YixHQUFHMzBCLEVBQUUsR0FBRzIwQixHQUFHNTBCLEVBQUU7SUFDcEI0MEIsR0FBR254QixDQUFDLEdBQUdteEIsR0FBR3owQixFQUFFLEdBQUd5MEIsR0FBRzEwQixFQUFFO0lBQ3BCLE9BQU8wMEI7QUFDVDtBQUVBLG9DQUFvQztBQUNwQyxJQUFJYyxvQkFBb0IsU0FBU0Esa0JBQWtCVixHQUFHLEVBQUVDLEdBQUc7SUFDekRELElBQUloMUIsRUFBRSxHQUFHaTFCLElBQUlqMUIsRUFBRTtJQUNmZzFCLElBQUk5MEIsRUFBRSxHQUFHKzBCLElBQUkvMEIsRUFBRTtJQUNmODBCLElBQUkvMEIsRUFBRSxHQUFHZzFCLElBQUloMUIsRUFBRTtJQUNmKzBCLElBQUk3MEIsRUFBRSxHQUFHODBCLElBQUk5MEIsRUFBRTtJQUNmNjBCLElBQUkzYixDQUFDLEdBQUcyYixJQUFJLzBCLEVBQUUsR0FBRyswQixJQUFJaDFCLEVBQUU7SUFDdkJnMUIsSUFBSXZ4QixDQUFDLEdBQUd1eEIsSUFBSTcwQixFQUFFLEdBQUc2MEIsSUFBSTkwQixFQUFFO0FBQ3pCO0FBQ0EsSUFBSXkxQix5QkFBeUIsU0FBU0EsdUJBQXVCWCxHQUFHLEVBQUVDLEdBQUc7SUFDbkUsaUNBQWlDO0lBQ2pDLElBQUlELElBQUloMUIsRUFBRSxHQUFHaTFCLElBQUloMUIsRUFBRSxFQUFFO1FBQ25CLE9BQU87SUFDVDtJQUNBLElBQUlnMUIsSUFBSWoxQixFQUFFLEdBQUdnMUIsSUFBSS8wQixFQUFFLEVBQUU7UUFDbkIsT0FBTztJQUNUO0lBRUEsZ0NBQWdDO0lBQ2hDLElBQUkrMEIsSUFBSS8wQixFQUFFLEdBQUdnMUIsSUFBSWoxQixFQUFFLEVBQUU7UUFDbkIsT0FBTztJQUNUO0lBQ0EsSUFBSWkxQixJQUFJaDFCLEVBQUUsR0FBRyswQixJQUFJaDFCLEVBQUUsRUFBRTtRQUNuQixPQUFPO0lBQ1Q7SUFFQSwyQkFBMkI7SUFDM0IsSUFBSWcxQixJQUFJNzBCLEVBQUUsR0FBRzgwQixJQUFJLzBCLEVBQUUsRUFBRTtRQUNuQixPQUFPO0lBQ1Q7SUFDQSxJQUFJKzBCLElBQUk5MEIsRUFBRSxHQUFHNjBCLElBQUk5MEIsRUFBRSxFQUFFO1FBQ25CLE9BQU87SUFDVDtJQUVBLDJCQUEyQjtJQUMzQixJQUFJODBCLElBQUk5MEIsRUFBRSxHQUFHKzBCLElBQUk5MEIsRUFBRSxFQUFFO1FBQ25CLE9BQU87SUFDVDtJQUNBLElBQUk4MEIsSUFBSS8wQixFQUFFLEdBQUc4MEIsSUFBSTcwQixFQUFFLEVBQUU7UUFDbkIsT0FBTztJQUNUO0lBRUEsb0NBQW9DO0lBQ3BDLE9BQU87QUFDVDtBQUNBLElBQUl5MUIsZ0JBQWdCLFNBQVNBLGNBQWNoQixFQUFFLEVBQUVsbUIsQ0FBQyxFQUFFeUosQ0FBQztJQUNqRCxPQUFPeWMsR0FBRzUwQixFQUFFLElBQUkwTyxLQUFLQSxLQUFLa21CLEdBQUczMEIsRUFBRSxJQUFJMjBCLEdBQUcxMEIsRUFBRSxJQUFJaVksS0FBS0EsS0FBS3ljLEdBQUd6MEIsRUFBRTtBQUM3RDtBQUNBLElBQUkwMUIscUJBQXFCLFNBQVNBLG1CQUFtQmpCLEVBQUUsRUFBRWtCLEVBQUU7SUFDekQsT0FBT0YsY0FBY2hCLElBQUlrQixHQUFHcG5CLENBQUMsRUFBRW9uQixHQUFHM2QsQ0FBQztBQUNyQztBQUNBLElBQUk0ZCwyQkFBMkIsU0FBU0EseUJBQXlCZixHQUFHLEVBQUVDLEdBQUc7SUFDdkUsT0FBT1csY0FBY1osS0FBS0MsSUFBSWoxQixFQUFFLEVBQUVpMUIsSUFBSS8wQixFQUFFLEtBQUswMUIsY0FBY1osS0FBS0MsSUFBSWgxQixFQUFFLEVBQUVnMUIsSUFBSTkwQixFQUFFO0FBQ2hGO0FBQ0EsSUFBSTYxQixRQUFRLENBQUN6RCxjQUFjcnpCLEtBQUs4MkIsS0FBSyxNQUFNLFFBQVF6RCxnQkFBZ0JwMUIsWUFBWW8xQixjQUFjLFNBQVU3akIsQ0FBQyxFQUFFeUosQ0FBQztJQUN6RyxPQUFPalosS0FBSzJ3QixJQUFJLENBQUNuaEIsSUFBSUEsSUFBSXlKLElBQUlBO0FBQy9CO0FBQ0EsU0FBUzhkLGVBQWVDLE9BQU8sRUFBRWhPLENBQUM7SUFDaEMsSUFBSWdPLFFBQVE5N0IsTUFBTSxHQUFHLEdBQUc7UUFDdEIsTUFBTSxJQUFJZ1UsTUFBTTtJQUNsQjtJQUNBLFVBQVU7SUFDVixJQUFJK08sTUFBTSxTQUFTQSxJQUFJaGpCLENBQUMsRUFBRXNJLENBQUM7UUFDekIsT0FBTztZQUNMaU0sR0FBR3ZVLEVBQUV1VSxDQUFDLEdBQUdqTSxFQUFFaU0sQ0FBQztZQUNaeUosR0FBR2hlLEVBQUVnZSxDQUFDLEdBQUcxVixFQUFFMFYsQ0FBQztRQUNkO0lBQ0Y7SUFDQSxJQUFJZ2UsTUFBTSxTQUFTQSxJQUFJaDhCLENBQUMsRUFBRXNJLENBQUM7UUFDekIsT0FBTztZQUNMaU0sR0FBR3ZVLEVBQUV1VSxDQUFDLEdBQUdqTSxFQUFFaU0sQ0FBQztZQUNaeUosR0FBR2hlLEVBQUVnZSxDQUFDLEdBQUcxVixFQUFFMFYsQ0FBQztRQUNkO0lBQ0Y7SUFDQSxJQUFJaWUsUUFBUSxTQUFTQSxNQUFNNzBCLENBQUMsRUFBRXpGLENBQUM7UUFDN0IsT0FBTztZQUNMNFMsR0FBR25OLEVBQUVtTixDQUFDLEdBQUc1UztZQUNUcWMsR0FBRzVXLEVBQUU0VyxDQUFDLEdBQUdyYztRQUNYO0lBQ0Y7SUFDQSxJQUFJdTZCLFFBQVEsU0FBU0EsTUFBTW42QixDQUFDLEVBQUVxRixDQUFDO1FBQzdCLE9BQU9yRixFQUFFd1MsQ0FBQyxHQUFHbk4sRUFBRTRXLENBQUMsR0FBR2pjLEVBQUVpYyxDQUFDLEdBQUc1VyxFQUFFbU4sQ0FBQztJQUM5QjtJQUNBLElBQUk0bkIsWUFBWSxTQUFTQSxVQUFVLzBCLENBQUM7UUFDbEMsSUFBSTZ4QixNQUFNNEMsTUFBTXowQixFQUFFbU4sQ0FBQyxFQUFFbk4sRUFBRTRXLENBQUM7UUFDeEIsT0FBT2liLFFBQVEsSUFBSTtZQUNqQjFrQixHQUFHO1lBQ0h5SixHQUFHO1FBQ0wsSUFBSTtZQUNGekosR0FBR25OLEVBQUVtTixDQUFDLEdBQUcwa0I7WUFDVGpiLEdBQUc1VyxFQUFFNFcsQ0FBQyxHQUFHaWI7UUFDWDtJQUNGO0lBQ0EsK0JBQStCO0lBQy9CLElBQUltRCxhQUFhLFNBQVNBLFdBQVdDLEdBQUc7UUFDdEMsSUFBSTdNLElBQUk7UUFDUixJQUFLLElBQUlodEIsSUFBSSxHQUFHQSxJQUFJNjVCLElBQUlwOEIsTUFBTSxFQUFFdUMsSUFBSztZQUNuQyxJQUFJZ0gsSUFBSTZ5QixHQUFHLENBQUM3NUIsRUFBRSxFQUNaaUgsSUFBSTR5QixHQUFHLENBQUMsQ0FBQzc1QixJQUFJLEtBQUs2NUIsSUFBSXA4QixNQUFNLENBQUM7WUFDL0J1dkIsS0FBS2htQixFQUFFK0ssQ0FBQyxHQUFHOUssRUFBRXVVLENBQUMsR0FBR3ZVLEVBQUU4SyxDQUFDLEdBQUcvSyxFQUFFd1UsQ0FBQztRQUM1QjtRQUNBLE9BQU93UixJQUFJO0lBQ2I7SUFDQSwwQ0FBMEM7SUFDMUMsSUFBSThNLGlCQUFpQixTQUFTQSxlQUFlNUMsRUFBRSxFQUFFQyxFQUFFLEVBQUU0QyxFQUFFLEVBQUVDLEVBQUU7UUFDekQsSUFBSXo4QixJQUFJaThCLElBQUlyQyxJQUFJRDtRQUNoQixJQUFJLzNCLElBQUlxNkIsSUFBSVEsSUFBSUQ7UUFDaEIsSUFBSUUsUUFBUVAsTUFBTW44QixHQUFHNEI7UUFDckIsSUFBSW9ELEtBQUsyM0IsR0FBRyxDQUFDRCxTQUFTLE1BQU07WUFDMUIsK0NBQStDO1lBQy9DLE9BQU96WixJQUFJMFcsSUFBSXVDLE1BQU1sOEIsR0FBRztRQUMxQjtRQUNBLElBQUlZLElBQUl1N0IsTUFBTUYsSUFBSU8sSUFBSTdDLEtBQUsvM0IsS0FBSzg2QjtRQUNoQyxPQUFPelosSUFBSTBXLElBQUl1QyxNQUFNbDhCLEdBQUdZO0lBQzFCO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUkwN0IsTUFBTU4sUUFBUS9uQixHQUFHLENBQUMsU0FBVXhLLENBQUM7UUFDL0IsT0FBTztZQUNMK0ssR0FBRy9LLEVBQUUrSyxDQUFDO1lBQ055SixHQUFHeFUsRUFBRXdVLENBQUM7UUFDUjtJQUNGO0lBQ0EsSUFBSW9lLFdBQVdDLE9BQU8sR0FBR0EsSUFBSTNRLE9BQU87SUFDcEMsSUFBSXZyQixJQUFJazhCLElBQUlwOEIsTUFBTTtJQUNsQix3Q0FBd0M7SUFDeEMsSUFBSTA4QixVQUFVLEVBQUU7SUFDaEIsSUFBSyxJQUFJbjZCLElBQUksR0FBR0EsSUFBSXJDLEdBQUdxQyxJQUFLO1FBQzFCLElBQUlnSCxJQUFJNnlCLEdBQUcsQ0FBQzc1QixFQUFFLEVBQ1ppSCxJQUFJNHlCLEdBQUcsQ0FBQyxDQUFDNzVCLElBQUksS0FBS3JDLEVBQUU7UUFDdEIsSUFBSWlwQixPQUFPNFMsSUFBSXZ5QixHQUFHRDtRQUNsQixxREFBcUQ7UUFDckQsd0NBQXdDO1FBQ3hDLElBQUlvekIsTUFBTVQsVUFBVTtZQUNsQjVuQixHQUFHNlUsS0FBS3BMLENBQUM7WUFDVEEsR0FBRyxDQUFDb0wsS0FBSzdVLENBQUM7UUFDWjtRQUNBb29CLFFBQVFsNkIsSUFBSSxDQUFDbTZCO0lBQ2Y7SUFFQSxxQkFBcUI7SUFDckIsSUFBSUMsY0FBY0YsUUFBUTNvQixHQUFHLENBQUMsU0FBVThvQixHQUFHLEVBQUV0NkIsQ0FBQztRQUM1QyxJQUFJazNCLEtBQUsxVyxJQUFJcVosR0FBRyxDQUFDNzVCLEVBQUUsRUFBRXk1QixNQUFNYSxLQUFLL087UUFDaEMsSUFBSTRMLEtBQUszVyxJQUFJcVosR0FBRyxDQUFDLENBQUM3NUIsSUFBSSxLQUFLckMsRUFBRSxFQUFFODdCLE1BQU1hLEtBQUsvTztRQUMxQyxPQUFPO1lBQ0wyTCxJQUFJQTtZQUNKQyxJQUFJQTtRQUNOO0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckMsSUFBSW9ELFdBQVcsRUFBRTtJQUNqQixJQUFLLElBQUlqVSxNQUFNLEdBQUdBLE1BQU0zb0IsR0FBRzJvQixNQUFPO1FBQ2hDLElBQUlOLFdBQVdxVSxXQUFXLENBQUMsQ0FBQy9ULE1BQU0sSUFBSTNvQixDQUFBQSxJQUFLQSxFQUFFO1FBQzdDLElBQUk2OEIsV0FBV0gsV0FBVyxDQUFDL1QsSUFBSTtRQUMvQixJQUFJbVUsS0FBS1gsZUFBZTlULFNBQVNrUixFQUFFLEVBQUVsUixTQUFTbVIsRUFBRSxFQUFFcUQsU0FBU3RELEVBQUUsRUFBRXNELFNBQVNyRCxFQUFFO1FBQzFFb0QsU0FBU3Q2QixJQUFJLENBQUN3NkI7SUFDaEI7SUFDQSxPQUFPRjtBQUNUO0FBQ0EsU0FBU0csU0FBU2IsR0FBRyxFQUFFcGUsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRUMsV0FBVztJQUNqRSxJQUFJQyxPQUFPQyxnQkFBZ0JsQixLQUFLcGUsU0FBU0MsU0FBU2lmLE9BQU9DO0lBQ3pELElBQUlJLGVBQWUxQixlQUFld0IsTUFBTUQ7SUFDeEMsSUFBSTVDLEtBQUtEO0lBQ1RnRCxhQUFhcmEsT0FBTyxDQUFDLFNBQVV3WSxFQUFFO1FBQy9CLE9BQU9aLHlCQUF5Qk4sSUFBSWtCLEdBQUdwbkIsQ0FBQyxFQUFFb25CLEdBQUczZCxDQUFDO0lBQ2hEO0lBQ0EsT0FBT3ljO0FBQ1Q7QUFDQSxJQUFJZ0QsOEJBQThCLFNBQVNBLDRCQUE0QmxwQixDQUFDLEVBQUV5SixDQUFDLEVBQUUwZixLQUFLLEVBQUVDLEtBQUssRUFBRVIsS0FBSyxFQUFFQyxNQUFNLEVBQUVuQyxPQUFPO0lBQy9HLElBQUkyQyxTQUFTcjNCLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNqRixJQUFJczNCLGVBQWVELFdBQVcsU0FBU0Usd0JBQXdCWCxPQUFPQyxVQUFVUTtJQUNoRixJQUFJRyxZQUFZWixRQUFRO0lBQ3hCLElBQUlhLGFBQWFaLFNBQVM7SUFDMUJTLGVBQWU5NEIsS0FBSytVLEdBQUcsQ0FBQytqQixjQUFjRSxXQUFXQztJQUNqRCxJQUFJQyxVQUFVSixpQkFBaUJFLFdBQzdCRyxXQUFXTCxpQkFBaUJHO0lBRTlCLGtEQUFrRDtJQUNsRCxJQUFJRztJQUVKLDZCQUE2QjtJQUM3QixJQUFJRixTQUFTO1FBQ1gsSUFBSUcsWUFBWVYsUUFBUUssWUFBWUYsZUFBZTVDO1FBQ25ELElBQUlvRCxZQUFZVixRQUFRSyxhQUFhL0M7UUFDckMsSUFBSXFELFVBQVVaLFFBQVFLLFlBQVlGLGVBQWU1QztRQUNqRCxJQUFJc0QsVUFBVUY7UUFDZEYsNEJBQTRCSyxxQkFBcUJqcUIsR0FBR3lKLEdBQUcwZixPQUFPQyxPQUFPUyxXQUFXQyxXQUFXQyxTQUFTQyxTQUFTO1FBQzdHLElBQUlKLDBCQUEwQmwrQixNQUFNLEdBQUcsR0FBRztZQUN4QyxPQUFPaytCO1FBQ1Q7SUFDRjtJQUVBLCtCQUErQjtJQUMvQixJQUFJRCxVQUFVO1FBQ1osSUFBSU8sY0FBY2YsUUFBUUssWUFBWTlDO1FBQ3RDLElBQUl5RCxjQUFjZixRQUFRSyxhQUFhSCxlQUFlNUM7UUFDdEQsSUFBSTBELFlBQVlGO1FBQ2hCLElBQUlHLFlBQVlqQixRQUFRSyxhQUFhSCxlQUFlNUM7UUFDcERrRCw0QkFBNEJLLHFCQUFxQmpxQixHQUFHeUosR0FBRzBmLE9BQU9DLE9BQU9jLGFBQWFDLGFBQWFDLFdBQVdDLFdBQVc7UUFDckgsSUFBSVQsMEJBQTBCbCtCLE1BQU0sR0FBRyxHQUFHO1lBQ3hDLE9BQU9rK0I7UUFDVDtJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDLElBQUlGLFNBQVM7UUFDWCxJQUFJWSxlQUFlbkIsUUFBUUssWUFBWUYsZUFBZTVDO1FBQ3RELElBQUk2RCxlQUFlbkIsUUFBUUssYUFBYS9DO1FBQ3hDLElBQUk4RCxhQUFhckIsUUFBUUssWUFBWUYsZUFBZTVDO1FBQ3BELElBQUkrRCxhQUFhRjtRQUNqQlgsNEJBQTRCSyxxQkFBcUJqcUIsR0FBR3lKLEdBQUcwZixPQUFPQyxPQUFPa0IsY0FBY0MsY0FBY0MsWUFBWUMsWUFBWTtRQUN6SCxJQUFJYiwwQkFBMEJsK0IsTUFBTSxHQUFHLEdBQUc7WUFDeEMsT0FBT2srQjtRQUNUO0lBQ0Y7SUFFQSw4QkFBOEI7SUFDOUIsSUFBSUQsVUFBVTtRQUNaLElBQUllLGFBQWF2QixRQUFRSyxZQUFZOUM7UUFDckMsSUFBSWlFLGFBQWF2QixRQUFRSyxhQUFhSCxlQUFlNUM7UUFDckQsSUFBSWtFLFdBQVdGO1FBQ2YsSUFBSUcsV0FBV3pCLFFBQVFLLGFBQWFILGVBQWU1QztRQUNuRGtELDRCQUE0QksscUJBQXFCanFCLEdBQUd5SixHQUFHMGYsT0FBT0MsT0FBT3NCLFlBQVlDLFlBQVlDLFVBQVVDLFVBQVU7UUFDakgsSUFBSWpCLDBCQUEwQmwrQixNQUFNLEdBQUcsR0FBRztZQUN4QyxPQUFPaytCO1FBQ1Q7SUFDRjtJQUVBLHdDQUF3QztJQUN4QyxJQUFJa0I7SUFFSixXQUFXO0lBQ1g7UUFDRSxJQUFJQyxpQkFBaUI1QixRQUFRSyxZQUFZRjtRQUN6QyxJQUFJMEIsaUJBQWlCNUIsUUFBUUssYUFBYUg7UUFDMUN3QixtQkFBbUJHLG9CQUFvQmpyQixHQUFHeUosR0FBRzBmLE9BQU9DLE9BQU8yQixnQkFBZ0JDLGdCQUFnQjFCLGVBQWU1QztRQUUxRyxrRUFBa0U7UUFDbEUsSUFBSW9FLGlCQUFpQnAvQixNQUFNLEdBQUcsS0FBS28vQixnQkFBZ0IsQ0FBQyxFQUFFLElBQUlDLGtCQUFrQkQsZ0JBQWdCLENBQUMsRUFBRSxJQUFJRSxnQkFBZ0I7WUFDakgsT0FBTztnQkFBQ0YsZ0JBQWdCLENBQUMsRUFBRTtnQkFBRUEsZ0JBQWdCLENBQUMsRUFBRTthQUFDO1FBQ25EO0lBQ0Y7SUFFQSxZQUFZO0lBQ1o7UUFDRSxJQUFJSSxrQkFBa0IvQixRQUFRSyxZQUFZRjtRQUMxQyxJQUFJNkIsa0JBQWtCL0IsUUFBUUssYUFBYUg7UUFDM0N3QixtQkFBbUJHLG9CQUFvQmpyQixHQUFHeUosR0FBRzBmLE9BQU9DLE9BQU84QixpQkFBaUJDLGlCQUFpQjdCLGVBQWU1QztRQUU1RyxrRUFBa0U7UUFDbEUsSUFBSW9FLGlCQUFpQnAvQixNQUFNLEdBQUcsS0FBS28vQixnQkFBZ0IsQ0FBQyxFQUFFLElBQUlJLG1CQUFtQkosZ0JBQWdCLENBQUMsRUFBRSxJQUFJSyxpQkFBaUI7WUFDbkgsT0FBTztnQkFBQ0wsZ0JBQWdCLENBQUMsRUFBRTtnQkFBRUEsZ0JBQWdCLENBQUMsRUFBRTthQUFDO1FBQ25EO0lBQ0Y7SUFFQSxlQUFlO0lBQ2Y7UUFDRSxJQUFJTSxxQkFBcUJqQyxRQUFRSyxZQUFZRjtRQUM3QyxJQUFJK0IscUJBQXFCakMsUUFBUUssYUFBYUg7UUFDOUN3QixtQkFBbUJHLG9CQUFvQmpyQixHQUFHeUosR0FBRzBmLE9BQU9DLE9BQU9nQyxvQkFBb0JDLG9CQUFvQi9CLGVBQWU1QztRQUVsSCxrRUFBa0U7UUFDbEUsSUFBSW9FLGlCQUFpQnAvQixNQUFNLEdBQUcsS0FBS28vQixnQkFBZ0IsQ0FBQyxFQUFFLElBQUlNLHNCQUFzQk4sZ0JBQWdCLENBQUMsRUFBRSxJQUFJTyxvQkFBb0I7WUFDekgsT0FBTztnQkFBQ1AsZ0JBQWdCLENBQUMsRUFBRTtnQkFBRUEsZ0JBQWdCLENBQUMsRUFBRTthQUFDO1FBQ25EO0lBQ0Y7SUFFQSxjQUFjO0lBQ2Q7UUFDRSxJQUFJUSxvQkFBb0JuQyxRQUFRSyxZQUFZRjtRQUM1QyxJQUFJaUMsb0JBQW9CbkMsUUFBUUssYUFBYUg7UUFDN0N3QixtQkFBbUJHLG9CQUFvQmpyQixHQUFHeUosR0FBRzBmLE9BQU9DLE9BQU9rQyxtQkFBbUJDLG1CQUFtQmpDLGVBQWU1QztRQUVoSCxrRUFBa0U7UUFDbEUsSUFBSW9FLGlCQUFpQnAvQixNQUFNLEdBQUcsS0FBS28vQixnQkFBZ0IsQ0FBQyxFQUFFLElBQUlRLHFCQUFxQlIsZ0JBQWdCLENBQUMsRUFBRSxJQUFJUyxtQkFBbUI7WUFDdkgsT0FBTztnQkFBQ1QsZ0JBQWdCLENBQUMsRUFBRTtnQkFBRUEsZ0JBQWdCLENBQUMsRUFBRTthQUFDO1FBQ25EO0lBQ0Y7SUFDQSxPQUFPLEVBQUUsRUFBRSxhQUFhO0FBQzFCO0FBQ0EsSUFBSVUsaUJBQWlCLFNBQVNBLGVBQWV4ckIsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFZ2lCLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsU0FBUztJQUM5RSxJQUFJei9CLElBQUl5L0I7SUFDUixJQUFJdjZCLEtBQUtkLEtBQUsrVSxHQUFHLENBQUNrbUIsS0FBS0U7SUFDdkIsSUFBSXA2QixLQUFLZixLQUFLNlUsR0FBRyxDQUFDb21CLEtBQUtFO0lBQ3ZCLElBQUluNkIsS0FBS2hCLEtBQUsrVSxHQUFHLENBQUNtbUIsS0FBS0U7SUFDdkIsSUFBSW42QixLQUFLakIsS0FBSzZVLEdBQUcsQ0FBQ3FtQixLQUFLRTtJQUN2QixPQUFPdDZCLEtBQUtsRixLQUFLNFQsS0FBS0EsS0FBS3pPLEtBQUtuRixLQUFLb0YsS0FBS3BGLEtBQUtxZCxLQUFLQSxLQUFLaFksS0FBS3JGO0FBQ2hFO0FBQ0EsSUFBSTAvQixtQkFBbUIsU0FBU0EsaUJBQWlCOXJCLENBQUMsRUFBRXlKLENBQUMsRUFBRW5ZLEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUUsRUFBRXM2QixFQUFFLEVBQUVDLEVBQUUsRUFBRUgsU0FBUztJQUN0RixJQUFJM0YsS0FBSztRQUNQNTBCLElBQUlkLEtBQUsrVSxHQUFHLENBQUNqVSxJQUFJeTZCLElBQUl4NkIsTUFBTXM2QjtRQUMzQnQ2QixJQUFJZixLQUFLNlUsR0FBRyxDQUFDL1QsSUFBSXk2QixJQUFJeDZCLE1BQU1zNkI7UUFDM0JyNkIsSUFBSWhCLEtBQUsrVSxHQUFHLENBQUMvVCxJQUFJdzZCLElBQUl2NkIsTUFBTW82QjtRQUMzQnA2QixJQUFJakIsS0FBSzZVLEdBQUcsQ0FBQzdULElBQUl3NkIsSUFBSXY2QixNQUFNbzZCO0lBQzdCO0lBRUEsMkVBQTJFO0lBQzNFLElBQUk3ckIsSUFBSWttQixHQUFHNTBCLEVBQUUsSUFBSTBPLElBQUlrbUIsR0FBRzMwQixFQUFFLElBQUlrWSxJQUFJeWMsR0FBRzEwQixFQUFFLElBQUlpWSxJQUFJeWMsR0FBR3owQixFQUFFLEVBQUU7UUFDcEQsd0NBQXdDO1FBQ3hDLE9BQU87SUFDVCxPQUFPO1FBQ0wsMENBQTBDO1FBQzFDLE9BQU87SUFDVDtBQUNGO0FBQ0EsSUFBSXc2QixpQkFBaUIsU0FBU0EsZUFBZXhnQyxDQUFDLEVBQUVzSSxDQUFDLEVBQUVpdEIsQ0FBQyxFQUFFcFQsR0FBRztJQUN2RG9ULEtBQUtwVDtJQUNMLElBQUlwaUIsSUFBSXVJLElBQUlBLElBQUksSUFBSXRJLElBQUl1MUI7SUFDeEIsSUFBSXgxQixJQUFJLEdBQUc7UUFDVCxPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUkwZ0MsUUFBUTE3QixLQUFLMndCLElBQUksQ0FBQzMxQjtJQUN0QixJQUFJMDhCLFFBQVEsSUFBSXo4QjtJQUNoQixJQUFJMGdDLFFBQVEsQ0FBQyxDQUFDcDRCLElBQUltNEIsS0FBSSxJQUFLaEU7SUFDM0IsSUFBSWtFLFFBQVEsQ0FBQyxDQUFDcjRCLElBQUltNEIsS0FBSSxJQUFLaEU7SUFDM0IsT0FBTztRQUFDaUU7UUFBT0M7S0FBTTtBQUN2QjtBQUNBLElBQUlDLGFBQWEsU0FBU0EsV0FBVzVnQyxDQUFDLEVBQUVzSSxDQUFDLEVBQUVpdEIsQ0FBQyxFQUFFeEgsQ0FBQyxFQUFFeFcsTUFBTTtJQUNyRCxnRkFBZ0Y7SUFDaEYsd0RBQXdEO0lBRXhELDZEQUE2RDtJQUM3RCxzRUFBc0U7SUFFdEUsSUFBSXNwQixVQUFVO0lBRWQsNkVBQTZFO0lBQzdFLElBQUk3Z0MsTUFBTSxHQUFHO1FBQ1hBLElBQUk2Z0M7SUFDTjtJQUNBdjRCLEtBQUt0STtJQUNMdTFCLEtBQUt2MUI7SUFDTCt0QixLQUFLL3RCO0lBQ0wsSUFBSThnQyxjQUFjcjNCLEdBQUcxSixHQUFHZ2hDLE1BQU1wL0IsR0FBR2hCLEdBQUdxZ0MsT0FBT0M7SUFDM0N4M0IsSUFBSSxDQUFDLE1BQU04ckIsSUFBSWp0QixJQUFJQSxDQUFBQSxJQUFLO0lBQ3hCdkksSUFBSSxDQUFFLFFBQU9ndUIsQ0FBQUEsSUFBS3psQixJQUFLLE9BQU1pdEIsSUFBSSxNQUFPanRCLENBQUFBLElBQUlBLENBQUFBLENBQUM7SUFDN0N2SSxLQUFLO0lBQ0wrZ0MsZUFBZXIzQixJQUFJQSxJQUFJQSxJQUFJMUosSUFBSUE7SUFDL0J3WCxNQUFNLENBQUMsRUFBRSxHQUFHO0lBQ1p5cEIsUUFBUTE0QixJQUFJO0lBQ1osSUFBSXc0QixlQUFlLEdBQUc7UUFDcEJuL0IsSUFBSTVCLElBQUlnRixLQUFLMndCLElBQUksQ0FBQ29MO1FBQ2xCbi9CLElBQUlBLElBQUksSUFBSSxDQUFDb0QsS0FBSzZ4QixHQUFHLENBQUMsQ0FBQ2oxQixHQUFHLE1BQU0sT0FBT29ELEtBQUs2eEIsR0FBRyxDQUFDajFCLEdBQUcsTUFBTTtRQUN6RGhCLElBQUlaLElBQUlnRixLQUFLMndCLElBQUksQ0FBQ29MO1FBQ2xCbmdDLElBQUlBLElBQUksSUFBSSxDQUFDb0UsS0FBSzZ4QixHQUFHLENBQUMsQ0FBQ2oyQixHQUFHLE1BQU0sT0FBT29FLEtBQUs2eEIsR0FBRyxDQUFDajJCLEdBQUcsTUFBTTtRQUN6RDRXLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQ3lwQixRQUFRci9CLElBQUloQjtRQUN6QnFnQyxTQUFTLENBQUNyL0IsSUFBSWhCLENBQUFBLElBQUs7UUFDbkI0VyxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUN5cEI7UUFDekJBLFFBQVFqOEIsS0FBSzJ3QixJQUFJLENBQUMsT0FBUSxFQUFDLzBCLElBQUlnQixDQUFBQSxJQUFLO1FBQ3BDNFYsTUFBTSxDQUFDLEVBQUUsR0FBR3lwQjtRQUNaenBCLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQ3lwQjtRQUNiO0lBQ0Y7SUFDQXpwQixNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHO0lBQ3hCLElBQUl1cEIsaUJBQWlCLEdBQUc7UUFDdEJHLE1BQU1saEMsSUFBSSxJQUFJLENBQUNnRixLQUFLNnhCLEdBQUcsQ0FBQyxDQUFDNzJCLEdBQUcsTUFBTSxPQUFPZ0YsS0FBSzZ4QixHQUFHLENBQUM3MkIsR0FBRyxNQUFNO1FBQzNEd1gsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDeXBCLFFBQVEsTUFBTUM7UUFDM0IxcEIsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFFMHBCLENBQUFBLE1BQU1ELEtBQUk7UUFDcEM7SUFDRjtJQUNBdjNCLElBQUksQ0FBQ0E7SUFDTHMzQixPQUFPdDNCLElBQUlBLElBQUlBO0lBQ2ZzM0IsT0FBT2g4QixLQUFLbThCLElBQUksQ0FBQ25oQyxJQUFJZ0YsS0FBSzJ3QixJQUFJLENBQUNxTDtJQUMvQkUsTUFBTSxNQUFNbDhCLEtBQUsyd0IsSUFBSSxDQUFDanNCO0lBQ3RCOE4sTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDeXBCLFFBQVFDLE1BQU1sOEIsS0FBS3daLEdBQUcsQ0FBQ3dpQixPQUFPO0lBQzNDeHBCLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQ3lwQixRQUFRQyxNQUFNbDhCLEtBQUt3WixHQUFHLENBQUMsQ0FBQ3dpQixPQUFPLE1BQU1oOEIsS0FBS3NaLEVBQUUsSUFBSTtJQUM3RDlHLE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQ3lwQixRQUFRQyxNQUFNbDhCLEtBQUt3WixHQUFHLENBQUMsQ0FBQ3dpQixPQUFPLE1BQU1oOEIsS0FBS3NaLEVBQUUsSUFBSTtJQUM3RDtBQUNGO0FBQ0EsSUFBSThpQiwwQkFBMEIsU0FBU0Esd0JBQXdCNXNCLENBQUMsRUFBRXlKLENBQUMsRUFBRW5ZLEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUUsRUFBRXM2QixFQUFFLEVBQUVDLEVBQUU7SUFDekYsNkRBQTZEO0lBQzdELGlEQUFpRDtJQUVqRCw4REFBOEQ7SUFDOUQsa0RBQWtEO0lBQ2xELGtDQUFrQztJQUVsQyxJQUFJdmdDLElBQUksTUFBTTZGLEtBQUtBLEtBQUssSUFBSUEsS0FBS0MsS0FBSyxJQUFJRCxLQUFLeTZCLEtBQUssSUFBSXg2QixLQUFLQSxLQUFLLElBQUlBLEtBQUt3NkIsS0FBS0EsS0FBS0EsS0FBS3Y2QixLQUFLQSxLQUFLLElBQUlBLEtBQUtDLEtBQUssSUFBSUQsS0FBS3c2QixLQUFLLElBQUl2NkIsS0FBS0EsS0FBSyxJQUFJQSxLQUFLdTZCLEtBQUtBLEtBQUtBO0lBQ2pLLElBQUlqNEIsSUFBSSxNQUFNLElBQUl6QyxLQUFLQyxLQUFLLElBQUlELEtBQUtBLEtBQUssSUFBSUEsS0FBS3k2QixLQUFLLElBQUl4NkIsS0FBS0EsS0FBSyxJQUFJQSxLQUFLdzZCLEtBQUssSUFBSXY2QixLQUFLQyxLQUFLLElBQUlELEtBQUtBLEtBQUssSUFBSUEsS0FBS3c2QixLQUFLLElBQUl2NkIsS0FBS0EsS0FBSyxJQUFJQSxLQUFLdTZCO0lBQ3JKLElBQUloTCxJQUFJLE1BQU0sSUFBSTF2QixLQUFLQSxLQUFLLElBQUlBLEtBQUtDLEtBQUtELEtBQUt5NkIsS0FBS3o2QixLQUFLME8sSUFBSSxJQUFJek8sS0FBS0EsS0FBSyxJQUFJQSxLQUFLeU8sSUFBSStyQixLQUFLL3JCLElBQUksSUFBSXhPLEtBQUtBLEtBQUssSUFBSUEsS0FBS0MsS0FBS0QsS0FBS3c2QixLQUFLeDZCLEtBQUtpWSxJQUFJLElBQUloWSxLQUFLQSxLQUFLLElBQUlBLEtBQUtnWSxJQUFJdWlCLEtBQUt2aUI7SUFDaEwsSUFBSStQLElBQUksTUFBTWxvQixLQUFLQyxLQUFLRCxLQUFLQSxLQUFLQSxLQUFLME8sSUFBSXpPLEtBQUt5TyxJQUFJeE8sS0FBS0MsS0FBS0QsS0FBS0EsS0FBS0EsS0FBS2lZLElBQUloWSxLQUFLZ1k7SUFFdEYsZ0ZBQWdGO0lBRWhGLElBQUltSixRQUFRLEVBQUU7SUFFZCxrQ0FBa0M7SUFDbEN5WixXQUFXNWdDLEdBQUdzSSxHQUFHaXRCLEdBQUd4SCxHQUFHNUc7SUFDdkIsSUFBSWlhLGdCQUFnQjtJQUNwQixJQUFJM2QsU0FBUyxFQUFFO0lBQ2YsSUFBSyxJQUFJdE4sUUFBUSxHQUFHQSxRQUFRLEdBQUdBLFNBQVMsRUFBRztRQUN6QyxJQUFJcFIsS0FBSzIzQixHQUFHLENBQUN2VixLQUFLLENBQUNoUixRQUFRLEVBQUUsSUFBSWlyQixpQkFBaUJqYSxLQUFLLENBQUNoUixNQUFNLElBQUksS0FBS2dSLEtBQUssQ0FBQ2hSLE1BQU0sSUFBSSxLQUFLO1lBQzFGc04sT0FBT2hoQixJQUFJLENBQUMwa0IsS0FBSyxDQUFDaFIsTUFBTTtRQUMxQjtJQUNGO0lBQ0FzTixPQUFPaGhCLElBQUksQ0FBQztJQUNaZ2hCLE9BQU9oaEIsSUFBSSxDQUFDO0lBQ1osSUFBSTQrQixxQkFBcUIsQ0FBQztJQUMxQixJQUFJQyxNQUFNQyxNQUFNQztJQUNoQixJQUFLLElBQUloL0IsSUFBSSxHQUFHQSxJQUFJaWhCLE9BQU94akIsTUFBTSxFQUFFdUMsSUFBSztRQUN0QzgrQixPQUFPdjhCLEtBQUs2eEIsR0FBRyxDQUFDLE1BQU1uVCxNQUFNLENBQUNqaEIsRUFBRSxFQUFFLE9BQU9xRCxLQUFLLE1BQU8sS0FBSTRkLE1BQU0sQ0FBQ2poQixFQUFFLElBQUlpaEIsTUFBTSxDQUFDamhCLEVBQUUsR0FBR3NELEtBQUsyZCxNQUFNLENBQUNqaEIsRUFBRSxHQUFHaWhCLE1BQU0sQ0FBQ2poQixFQUFFLEdBQUc4OUI7UUFDOUdpQixPQUFPeDhCLEtBQUs2eEIsR0FBRyxDQUFDLElBQUluVCxNQUFNLENBQUNqaEIsRUFBRSxFQUFFLE9BQU91RCxLQUFLLElBQUssT0FBTTBkLE1BQU0sQ0FBQ2poQixFQUFFLElBQUlpaEIsTUFBTSxDQUFDamhCLEVBQUUsR0FBR3dELEtBQUt5ZCxNQUFNLENBQUNqaEIsRUFBRSxHQUFHaWhCLE1BQU0sQ0FBQ2poQixFQUFFLEdBQUcrOUI7UUFDNUdpQixjQUFjejhCLEtBQUs2eEIsR0FBRyxDQUFDMEssT0FBTy9zQixHQUFHLEtBQUt4UCxLQUFLNnhCLEdBQUcsQ0FBQzJLLE9BQU92akIsR0FBRztRQUN6RCw0RUFBNEU7UUFDNUUsSUFBSXFqQixzQkFBc0IsR0FBRztZQUMzQixJQUFJRyxjQUFjSCxvQkFBb0I7Z0JBQ3BDQSxxQkFBcUJHO1lBQ3ZCO1FBQ0YsT0FBTztZQUNMSCxxQkFBcUJHO1FBQ3ZCO0lBQ0Y7SUFDQSxPQUFPSDtBQUNUO0FBQ0EsSUFBSUkscUJBQXFCLFNBQVNBLG1CQUFtQmx0QixDQUFDLEVBQUV5SixDQUFDLEVBQUVuWSxFQUFFLEVBQUVFLEVBQUUsRUFBRUQsRUFBRSxFQUFFRSxFQUFFO0lBQ3ZFLElBQUkwN0IsU0FBUztRQUFDbnRCLElBQUkxTztRQUFJbVksSUFBSWpZO0tBQUc7SUFDN0IsSUFBSTQ3QixPQUFPO1FBQUM3N0IsS0FBS0Q7UUFBSUcsS0FBS0Q7S0FBRztJQUM3QixJQUFJNjdCLFNBQVNELElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFO0lBQ2xELElBQUlFLFFBQVFILE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFO0lBQ3pELElBQUlJLGFBQWFKLE1BQU0sQ0FBQyxFQUFFLEdBQUdDLElBQUksQ0FBQyxFQUFFLEdBQUdELE1BQU0sQ0FBQyxFQUFFLEdBQUdDLElBQUksQ0FBQyxFQUFFO0lBQzFELElBQUlJLFFBQVFELGFBQWFBLGFBQWFGO0lBQ3RDLElBQUlFLGFBQWEsR0FBRztRQUNsQixPQUFPRDtJQUNUO0lBQ0EsSUFBSUUsUUFBUUgsUUFBUTtRQUNsQixPQUFPLENBQUNydEIsSUFBSXpPLEVBQUMsSUFBTXlPLENBQUFBLElBQUl6TyxFQUFDLElBQUssQ0FBQ2tZLElBQUloWSxFQUFDLElBQU1nWSxDQUFBQSxJQUFJaFksRUFBQztJQUNoRDtJQUNBLE9BQU82N0IsUUFBUUU7QUFDakI7QUFDQSxJQUFJQywyQkFBMkIsU0FBU0EseUJBQXlCenRCLENBQUMsRUFBRXlKLENBQUMsRUFBRWlrQixNQUFNO0lBQzNFLElBQUlwOEIsSUFBSUUsSUFBSUQsSUFBSUU7SUFDaEIsSUFBSXU2QjtJQUVKLDhDQUE4QztJQUM5QyxJQUFJMkIsS0FBSztJQUNULGdCQUFnQjtJQUNoQixJQUFLLElBQUkxL0IsSUFBSSxHQUFHQSxJQUFJeS9CLE9BQU9oaUMsTUFBTSxHQUFHLEdBQUd1QyxJQUFLO1FBQzFDcUQsS0FBS284QixNQUFNLENBQUN6L0IsSUFBSSxFQUFFO1FBQ2xCdUQsS0FBS2s4QixNQUFNLENBQUN6L0IsSUFBSSxJQUFJLEVBQUU7UUFDdEIsSUFBSUEsSUFBSSxJQUFJeS9CLE9BQU9oaUMsTUFBTSxHQUFHLEdBQUc7WUFDN0I2RixLQUFLbThCLE1BQU0sQ0FBQyxDQUFDei9CLElBQUksS0FBSyxFQUFFO1lBQ3hCd0QsS0FBS2k4QixNQUFNLENBQUMsQ0FBQ3ovQixJQUFJLEtBQUssSUFBSSxFQUFFO1FBQzlCLE9BQU87WUFDTHNELEtBQUttOEIsTUFBTSxDQUFDLENBQUN6L0IsSUFBSSxJQUFJeS9CLE9BQU9oaUMsTUFBTSxHQUFHLEtBQUssRUFBRTtZQUM1QytGLEtBQUtpOEIsTUFBTSxDQUFDLENBQUN6L0IsSUFBSSxJQUFJeS9CLE9BQU9oaUMsTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFO1FBQ2xEO1FBQ0EsSUFBSTRGLE1BQU0wTyxLQUFLek8sTUFBTXlPO2FBQVUsSUFBSTFPLE1BQU0wTyxLQUFLQSxLQUFLek8sTUFBTUQsTUFBTTBPLEtBQUtBLEtBQUt6TyxJQUFJO1lBQzNFeTZCLEtBQUssQ0FBQ2hzQixJQUFJMU8sRUFBQyxJQUFNQyxDQUFBQSxLQUFLRCxFQUFDLElBQU1HLENBQUFBLEtBQUtELEVBQUMsSUFBS0E7WUFDeEMsSUFBSXc2QixLQUFLdmlCLEdBQUc7Z0JBQ1Zra0I7WUFDRjtRQUVBLGdCQUFnQjtRQUNoQixVQUFVO1FBQ1YsSUFBSTtRQUNOLE9BQU87WUFDTDtRQUNGO0lBQ0Y7SUFDQSxJQUFJQSxLQUFLLE1BQU0sR0FBRztRQUNoQixPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBQ0EsSUFBSUMscUJBQXFCLFNBQVNBLG1CQUFtQjV0QixDQUFDLEVBQUV5SixDQUFDLEVBQUVva0IsVUFBVSxFQUFFbmtCLE9BQU8sRUFBRUMsT0FBTyxFQUFFaWYsS0FBSyxFQUFFQyxNQUFNLEVBQUVpRixTQUFTLEVBQUVwSCxPQUFPO0lBQ3hILElBQUlxSCxvQkFBb0IsSUFBSWxpQyxNQUFNZ2lDLFdBQVduaUMsTUFBTTtJQUVuRCx1QkFBdUI7SUFDdkIsSUFBSXNpQztJQUNKLElBQUlGLFNBQVMsQ0FBQyxFQUFFLElBQUksTUFBTTtRQUN4QkUsUUFBUXg5QixLQUFLeTlCLElBQUksQ0FBQ0gsU0FBUyxDQUFDLEVBQUUsR0FBR0EsU0FBUyxDQUFDLEVBQUU7UUFDN0MsSUFBSUEsU0FBUyxDQUFDLEVBQUUsR0FBRyxHQUFHO1lBQ3BCRSxRQUFRQSxRQUFReDlCLEtBQUtzWixFQUFFLEdBQUc7UUFDNUIsT0FBTztZQUNMa2tCLFFBQVEsQ0FBQ0EsUUFBUXg5QixLQUFLc1osRUFBRSxHQUFHO1FBQzdCO0lBQ0YsT0FBTztRQUNMa2tCLFFBQVFGO0lBQ1Y7SUFDQSxJQUFJOWpCLE1BQU14WixLQUFLd1osR0FBRyxDQUFDLENBQUNna0I7SUFDcEIsSUFBSS9qQixNQUFNelosS0FBS3laLEdBQUcsQ0FBQyxDQUFDK2pCO0lBRXBCLHlDQUF5QztJQUN6QyxJQUFLLElBQUkvL0IsSUFBSSxHQUFHQSxJQUFJOC9CLGtCQUFrQnJpQyxNQUFNLEdBQUcsR0FBR3VDLElBQUs7UUFDckQ4L0IsaUJBQWlCLENBQUM5L0IsSUFBSSxFQUFFLEdBQUcyNkIsUUFBUSxJQUFLaUYsQ0FBQUEsVUFBVSxDQUFDNS9CLElBQUksRUFBRSxHQUFHK2IsTUFBTTZqQixVQUFVLENBQUM1L0IsSUFBSSxJQUFJLEVBQUUsR0FBR2djLEdBQUU7UUFDNUY4akIsaUJBQWlCLENBQUM5L0IsSUFBSSxJQUFJLEVBQUUsR0FBRzQ2QixTQUFTLElBQUtnRixDQUFBQSxVQUFVLENBQUM1L0IsSUFBSSxJQUFJLEVBQUUsR0FBRytiLE1BQU02akIsVUFBVSxDQUFDNS9CLElBQUksRUFBRSxHQUFHZ2MsR0FBRTtRQUNqRzhqQixpQkFBaUIsQ0FBQzkvQixJQUFJLEVBQUUsSUFBSXliO1FBQzVCcWtCLGlCQUFpQixDQUFDOS9CLElBQUksSUFBSSxFQUFFLElBQUkwYjtJQUNsQztJQUNBLElBQUkrakI7SUFDSixJQUFJaEgsVUFBVSxHQUFHO1FBQ2YsSUFBSXdILGtCQUFrQkMsY0FBY0osbUJBQW1CLENBQUNySDtRQUN4RGdILFNBQVNVLFVBQVVGO0lBQ3JCLE9BQU87UUFDTFIsU0FBU0s7SUFDWDtJQUNBLE9BQU9OLHlCQUF5Qnp0QixHQUFHeUosR0FBR2lrQjtBQUN4QztBQUNBLElBQUlXLDBCQUEwQixTQUFTQSx3QkFBd0JydUIsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFb2tCLFVBQVUsRUFBRW5rQixPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTSxFQUFFeUYsT0FBTztJQUN2SCxJQUFJQyxtQkFBbUIsSUFBSTFpQyxNQUFNZ2lDLFdBQVduaUMsTUFBTSxHQUFHO0lBQ3JELElBQUssSUFBSXVDLElBQUksR0FBR0EsSUFBSXFnQyxRQUFRNWlDLE1BQU0sRUFBRXVDLElBQUs7UUFDdkMsSUFBSXVnQyxTQUFTRixPQUFPLENBQUNyZ0MsRUFBRTtRQUN2QnNnQyxnQkFBZ0IsQ0FBQ3RnQyxJQUFJLElBQUksRUFBRSxHQUFHdWdDLE9BQU9DLE1BQU07UUFDM0NGLGdCQUFnQixDQUFDdGdDLElBQUksSUFBSSxFQUFFLEdBQUd1Z0MsT0FBT0UsTUFBTTtRQUMzQ0gsZ0JBQWdCLENBQUN0Z0MsSUFBSSxJQUFJLEVBQUUsR0FBR3VnQyxPQUFPRyxLQUFLO1FBQzFDSixnQkFBZ0IsQ0FBQ3RnQyxJQUFJLElBQUksRUFBRSxHQUFHdWdDLE9BQU9JLEtBQUs7UUFDMUMsSUFBSUMsa0JBQWtCcitCLEtBQUs2eEIsR0FBRyxDQUFDbU0sT0FBT00sRUFBRSxHQUFHOXVCLEdBQUcsS0FBS3hQLEtBQUs2eEIsR0FBRyxDQUFDbU0sT0FBT3ZmLEVBQUUsR0FBR3hGLEdBQUc7UUFDM0UsSUFBSW9sQixtQkFBbUJyK0IsS0FBSzZ4QixHQUFHLENBQUNtTSxPQUFPbkYsTUFBTSxFQUFFLElBQUk7WUFDakQsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPb0UseUJBQXlCenRCLEdBQUd5SixHQUFHOGtCO0FBQ3hDO0FBQ0EsSUFBSUgsWUFBWSxTQUFTQSxVQUFVVyxPQUFPO0lBQ3hDLElBQUlDLFdBQVcsSUFBSW5qQyxNQUFNa2pDLFFBQVFyakMsTUFBTSxHQUFHO0lBQzFDLElBQUl1akMsbUJBQW1CQyxtQkFBbUJDLGlCQUFpQkM7SUFDM0QsSUFBSUMsZ0JBQWdCQyxnQkFBZ0JDLGNBQWNDO0lBQ2xELElBQUssSUFBSXZoQyxJQUFJLEdBQUdBLElBQUk4Z0MsUUFBUXJqQyxNQUFNLEdBQUcsR0FBR3VDLElBQUs7UUFDM0NnaEMsb0JBQW9CRixPQUFPLENBQUM5Z0MsSUFBSSxFQUFFO1FBQ2xDaWhDLG9CQUFvQkgsT0FBTyxDQUFDOWdDLElBQUksSUFBSSxFQUFFO1FBQ3RDa2hDLGtCQUFrQkosT0FBTyxDQUFDOWdDLElBQUksSUFBSSxFQUFFO1FBQ3BDbWhDLGtCQUFrQkwsT0FBTyxDQUFDOWdDLElBQUksSUFBSSxFQUFFO1FBQ3BDLElBQUlBLElBQUk4Z0MsUUFBUXJqQyxNQUFNLEdBQUcsSUFBSSxHQUFHO1lBQzlCMmpDLGlCQUFpQk4sT0FBTyxDQUFDLENBQUM5Z0MsSUFBSSxLQUFLLEVBQUU7WUFDckNxaEMsaUJBQWlCUCxPQUFPLENBQUMsQ0FBQzlnQyxJQUFJLEtBQUssSUFBSSxFQUFFO1lBQ3pDc2hDLGVBQWVSLE9BQU8sQ0FBQyxDQUFDOWdDLElBQUksS0FBSyxJQUFJLEVBQUU7WUFDdkN1aEMsZUFBZVQsT0FBTyxDQUFDLENBQUM5Z0MsSUFBSSxLQUFLLElBQUksRUFBRTtRQUN6QyxPQUFPO1lBQ0xvaEMsaUJBQWlCTixPQUFPLENBQUMsRUFBRTtZQUMzQk8saUJBQWlCUCxPQUFPLENBQUMsRUFBRTtZQUMzQlEsZUFBZVIsT0FBTyxDQUFDLEVBQUU7WUFDekJTLGVBQWVULE9BQU8sQ0FBQyxFQUFFO1FBQzNCO1FBQ0EsSUFBSVUsZUFBZXhGLHFCQUFxQmdGLG1CQUFtQkMsbUJBQW1CQyxpQkFBaUJDLGlCQUFpQkMsZ0JBQWdCQyxnQkFBZ0JDLGNBQWNDLGNBQWM7UUFDNUtSLFFBQVEsQ0FBQy9nQyxJQUFJLEVBQUUsR0FBR3doQyxZQUFZLENBQUMsRUFBRTtRQUNqQ1QsUUFBUSxDQUFDL2dDLElBQUksSUFBSSxFQUFFLEdBQUd3aEMsWUFBWSxDQUFDLEVBQUU7SUFDdkM7SUFDQSxPQUFPVDtBQUNUO0FBQ0EsSUFBSWIsZ0JBQWdCLFNBQVNBLGNBQWNULE1BQU0sRUFBRWdDLEdBQUc7SUFDcEQsSUFBSXhCLGtCQUFrQixJQUFJcmlDLE1BQU02aEMsT0FBT2hpQyxNQUFNLEdBQUc7SUFDaEQsSUFBSWlrQyxlQUFlQyxlQUFlQyxZQUFZQztJQUM5QyxJQUFLLElBQUk3aEMsSUFBSSxHQUFHQSxJQUFJeS9CLE9BQU9oaUMsTUFBTSxHQUFHLEdBQUd1QyxJQUFLO1FBQzFDMGhDLGdCQUFnQmpDLE1BQU0sQ0FBQ3ovQixJQUFJLEVBQUU7UUFDN0IyaEMsZ0JBQWdCbEMsTUFBTSxDQUFDei9CLElBQUksSUFBSSxFQUFFO1FBQ2pDLElBQUlBLElBQUl5L0IsT0FBT2hpQyxNQUFNLEdBQUcsSUFBSSxHQUFHO1lBQzdCbWtDLGFBQWFuQyxNQUFNLENBQUMsQ0FBQ3ovQixJQUFJLEtBQUssRUFBRTtZQUNoQzZoQyxhQUFhcEMsTUFBTSxDQUFDLENBQUN6L0IsSUFBSSxLQUFLLElBQUksRUFBRTtRQUN0QyxPQUFPO1lBQ0w0aEMsYUFBYW5DLE1BQU0sQ0FBQyxFQUFFO1lBQ3RCb0MsYUFBYXBDLE1BQU0sQ0FBQyxFQUFFO1FBQ3hCO1FBRUEsMkVBQTJFO1FBRTNFLDZCQUE2QjtRQUU3QixJQUFJcUMsVUFBVUQsYUFBYUY7UUFDM0IsSUFBSUksVUFBVSxDQUFFSCxDQUFBQSxhQUFhRixhQUFZO1FBRXpDLFlBQVk7UUFDWixJQUFJTSxlQUFlei9CLEtBQUsyd0IsSUFBSSxDQUFDNE8sVUFBVUEsVUFBVUMsVUFBVUE7UUFDM0QsSUFBSUUsb0JBQW9CSCxVQUFVRTtRQUNsQyxJQUFJRSxvQkFBb0JILFVBQVVDO1FBQ2xDL0IsZUFBZSxDQUFDamdDLElBQUksRUFBRSxHQUFHMGhDLGdCQUFnQk8sb0JBQW9CUjtRQUM3RHhCLGVBQWUsQ0FBQ2pnQyxJQUFJLElBQUksRUFBRSxHQUFHMmhDLGdCQUFnQk8sb0JBQW9CVDtRQUNqRXhCLGVBQWUsQ0FBQ2pnQyxJQUFJLElBQUksRUFBRSxHQUFHNGhDLGFBQWFLLG9CQUFvQlI7UUFDOUR4QixlQUFlLENBQUNqZ0MsSUFBSSxJQUFJLEVBQUUsR0FBRzZoQyxhQUFhSyxvQkFBb0JUO0lBQ2hFO0lBQ0EsT0FBT3hCO0FBQ1Q7QUFDQSxJQUFJa0MsdUJBQXVCLFNBQVNBLHFCQUFxQnB3QixDQUFDLEVBQUV5SixDQUFDLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFMG1CLGNBQWMsRUFBRUMsY0FBYztJQUM3RyxJQUFJeEwsUUFBUXBiLFVBQVUxSjtJQUN0QixJQUFJK2tCLFFBQVFwYixVQUFVRjtJQUN0QnFiLFNBQVN1TDtJQUNUdEwsU0FBU3VMO0lBQ1QsSUFBSTVMLE1BQU1sMEIsS0FBSzJ3QixJQUFJLENBQUMyRCxRQUFRQSxRQUFRQyxRQUFRQTtJQUM1QyxJQUFJd0wsWUFBWTdMLE1BQU07SUFDdEIsSUFBSTZMLFlBQVksR0FBRztRQUNqQixPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlDLGdCQUFnQkQsWUFBWTdMO0lBQ2hDLE9BQU87UUFBRWhiLENBQUFBLFVBQVUxSixDQUFBQSxJQUFLd3dCLGdCQUFnQnh3QjtRQUFJMkosQ0FBQUEsVUFBVUYsQ0FBQUEsSUFBSyttQixnQkFBZ0IvbUI7S0FBRTtBQUMvRTtBQUNBLElBQUlnbkIsaUJBQWlCLFNBQVNBLGVBQWV6d0IsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFbWYsS0FBSyxFQUFFQyxNQUFNLEVBQUVuZixPQUFPLEVBQUVDLE9BQU8sRUFBRStjLE9BQU87SUFDekYxbUIsS0FBSzBKO0lBQ0xELEtBQUtFO0lBQ0wzSixLQUFLNG9CLFFBQVEsSUFBSWxDO0lBQ2pCamQsS0FBS29mLFNBQVMsSUFBSW5DO0lBQ2xCLE9BQU8xbUIsSUFBSUEsSUFBSXlKLElBQUlBLEtBQUs7QUFDMUI7QUFFQSx1RUFBdUU7QUFDdkUsSUFBSXdoQixzQkFBc0IsU0FBU0Esb0JBQW9CMzVCLEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUUsRUFBRWlZLE9BQU8sRUFBRUMsT0FBTyxFQUFFMGYsTUFBTTtJQUM3Rix3Q0FBd0M7SUFDeEMsSUFBSTdQLElBQUk7UUFBQ2pvQixLQUFLRDtRQUFJRyxLQUFLRDtLQUFHLEVBQUUsMkJBQTJCO0lBQ3ZELElBQUlqRSxJQUFJO1FBQUMrRCxLQUFLb1k7UUFBU2xZLEtBQUttWTtLQUFRO0lBQ3BDLElBQUlsZSxJQUFJK3RCLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO0lBQ2pDLElBQUl6bEIsSUFBSSxJQUFLeEcsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR2lzQixDQUFDLENBQUMsRUFBRSxHQUFHanNCLENBQUMsQ0FBQyxFQUFFLEdBQUdpc0IsQ0FBQyxDQUFDLEVBQUU7SUFDdEMsSUFBSXdILElBQUl6ekIsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBRzg3QixTQUFTQTtJQUM3QyxJQUFJa0QsZUFBZXg0QixJQUFJQSxJQUFJLElBQUl0SSxJQUFJdTFCO0lBQ25DLElBQUl1TCxlQUFlLEdBQUc7UUFDcEIsT0FBTyxFQUFFO0lBQ1g7SUFDQSxJQUFJbUUsS0FBSyxDQUFDLENBQUMzOEIsSUFBSXZELEtBQUsyd0IsSUFBSSxDQUFDb0wsYUFBWSxJQUFNLEtBQUk5Z0MsQ0FBQUE7SUFDL0MsSUFBSWtsQyxLQUFLLENBQUMsQ0FBQzU4QixJQUFJdkQsS0FBSzJ3QixJQUFJLENBQUNvTCxhQUFZLElBQU0sS0FBSTlnQyxDQUFBQTtJQUMvQyxJQUFJbWxDLE9BQU9wZ0MsS0FBSytVLEdBQUcsQ0FBQ21yQixJQUFJQztJQUN4QixJQUFJRSxPQUFPcmdDLEtBQUs2VSxHQUFHLENBQUNxckIsSUFBSUM7SUFDeEIsSUFBSUcsZ0JBQWdCLEVBQUU7SUFDdEIsSUFBSUYsUUFBUSxLQUFLQSxRQUFRLEdBQUc7UUFDMUJFLGNBQWM1aUMsSUFBSSxDQUFDMGlDO0lBQ3JCO0lBQ0EsSUFBSUMsUUFBUSxLQUFLQSxRQUFRLEdBQUc7UUFDMUJDLGNBQWM1aUMsSUFBSSxDQUFDMmlDO0lBQ3JCO0lBQ0EsSUFBSUMsY0FBY3BsQyxNQUFNLEtBQUssR0FBRztRQUM5QixPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlxbEMsb0JBQW9CRCxhQUFhLENBQUMsRUFBRSxHQUFHdFgsQ0FBQyxDQUFDLEVBQUUsR0FBR2xvQjtJQUNsRCxJQUFJMC9CLG9CQUFvQkYsYUFBYSxDQUFDLEVBQUUsR0FBR3RYLENBQUMsQ0FBQyxFQUFFLEdBQUdob0I7SUFDbEQsSUFBSXMvQixjQUFjcGxDLE1BQU0sR0FBRyxHQUFHO1FBQzVCLElBQUlvbEMsYUFBYSxDQUFDLEVBQUUsSUFBSUEsYUFBYSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxPQUFPO2dCQUFDQztnQkFBbUJDO2FBQWtCO1FBQy9DLE9BQU87WUFDTCxJQUFJQyxtQkFBbUJILGFBQWEsQ0FBQyxFQUFFLEdBQUd0WCxDQUFDLENBQUMsRUFBRSxHQUFHbG9CO1lBQ2pELElBQUk0L0IsbUJBQW1CSixhQUFhLENBQUMsRUFBRSxHQUFHdFgsQ0FBQyxDQUFDLEVBQUUsR0FBR2hvQjtZQUNqRCxPQUFPO2dCQUFDdS9CO2dCQUFtQkM7Z0JBQW1CQztnQkFBa0JDO2FBQWlCO1FBQ25GO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFBQ0g7WUFBbUJDO1NBQWtCO0lBQy9DO0FBQ0Y7QUFDQSxJQUFJRyxhQUFhLFNBQVNBLFdBQVcxbEMsQ0FBQyxFQUFFc0ksQ0FBQyxFQUFFaXRCLENBQUM7SUFDMUMsSUFBSWp0QixLQUFLdEksS0FBS0EsS0FBS3UxQixLQUFLQSxLQUFLdjFCLEtBQUtBLEtBQUtzSSxHQUFHO1FBQ3hDLE9BQU90STtJQUNULE9BQU8sSUFBSUEsS0FBS3NJLEtBQUtBLEtBQUtpdEIsS0FBS0EsS0FBS2p0QixLQUFLQSxLQUFLdEksR0FBRztRQUMvQyxPQUFPc0k7SUFDVCxPQUFPO1FBQ0wsT0FBT2l0QjtJQUNUO0FBQ0Y7QUFFQSxtREFBbUQ7QUFDbkQsSUFBSWlKLHVCQUF1QixTQUFTQSxxQkFBcUIzNEIsRUFBRSxFQUFFRSxFQUFFLEVBQUVELEVBQUUsRUFBRUUsRUFBRSxFQUFFczZCLEVBQUUsRUFBRUMsRUFBRSxFQUFFb0YsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLGFBQWE7SUFDcEcsSUFBSUMsT0FBT2pnQyxLQUFLeTZCO0lBQ2hCLElBQUl5RixPQUFPamdDLEtBQUtEO0lBQ2hCLElBQUltZ0MsT0FBT0wsS0FBS3JGO0lBQ2hCLElBQUkyRixPQUFPbGdDLEtBQUt3NkI7SUFDaEIsSUFBSTJGLE9BQU9sZ0MsS0FBS0Q7SUFDaEIsSUFBSW9nQyxPQUFPUCxLQUFLckY7SUFDaEIsSUFBSTZGLE9BQU9KLE9BQU9DLE9BQU9FLE9BQU9MO0lBQ2hDLElBQUlPLE9BQU9OLE9BQU9FLE9BQU9DLE9BQU9KO0lBQ2hDLElBQUlRLE1BQU1ILE9BQU9KLE9BQU9DLE9BQU9FO0lBQy9CLElBQUlJLFFBQVEsR0FBRztRQUNiLElBQUlDLEtBQUtILE9BQU9FO1FBQ2hCLElBQUlFLEtBQUtILE9BQU9DO1FBQ2hCLElBQUlHLGdCQUFnQjtRQUNwQixJQUFJQyxPQUFPLElBQUlEO1FBQ2YsSUFBSUUsT0FBTyxJQUFJRjtRQUNmLElBQUlDLFFBQVFILE1BQU1BLE1BQU1JLFFBQVFELFFBQVFGLE1BQU1BLE1BQU1HLE1BQU07WUFDeEQsT0FBTztnQkFBQzlnQyxLQUFLMGdDLEtBQUtSO2dCQUFNaGdDLEtBQUt3Z0MsS0FBS0w7YUFBSztRQUN6QyxPQUFPO1lBQ0wsSUFBSSxDQUFDTCxlQUFlO2dCQUNsQixPQUFPLEVBQUU7WUFDWCxPQUFPO2dCQUNMLE9BQU87b0JBQUNoZ0MsS0FBSzBnQyxLQUFLUjtvQkFBTWhnQyxLQUFLd2dDLEtBQUtMO2lCQUFLO1lBQ3pDO1FBQ0Y7SUFDRixPQUFPO1FBQ0wsSUFBSUUsU0FBUyxLQUFLQyxTQUFTLEdBQUc7WUFDNUIsK0NBQStDO1lBRS9DLGdDQUFnQztZQUNoQyxJQUFJWCxXQUFXNy9CLElBQUlDLElBQUk2L0IsUUFBUUEsSUFBSTtnQkFDakMsT0FBTztvQkFBQ0E7b0JBQUlDO2lCQUFHO1lBQ2pCO1lBRUEsbUNBQW1DO1lBQ25DLElBQUlGLFdBQVc3L0IsSUFBSUMsSUFBSXc2QixRQUFRQSxJQUFJO2dCQUNqQyxPQUFPO29CQUFDQTtvQkFBSUM7aUJBQUc7WUFDakI7WUFFQSx5QkFBeUI7WUFDekIsSUFBSW1GLFdBQVdwRixJQUFJcUYsSUFBSTcvQixRQUFRQSxJQUFJO2dCQUNqQyxPQUFPO29CQUFDQTtvQkFBSUU7aUJBQUc7WUFDakI7WUFDQSxPQUFPLEVBQUU7UUFDWCxPQUFPO1lBQ0wsMkJBQTJCO1lBQzNCLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7QUFDRjtBQUNBLElBQUl1M0Isa0JBQWtCLFNBQVNBLGdCQUFnQjBFLE1BQU0sRUFBRWhrQixPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTTtJQUNwRixJQUFJdjJCLE1BQU0sRUFBRTtJQUNaLElBQUkrL0IsUUFBUXpKLFFBQVE7SUFDcEIsSUFBSTBKLFFBQVF6SixTQUFTO0lBQ3JCLElBQUk3b0IsSUFBSTBKO0lBQ1IsSUFBSUQsSUFBSUU7SUFDUnJYLElBQUlwRSxJQUFJLENBQUM7UUFDUDhSLEdBQUdBLElBQUlxeUIsUUFBUTNFLE1BQU0sQ0FBQyxFQUFFO1FBQ3hCamtCLEdBQUdBLElBQUk2b0IsUUFBUTVFLE1BQU0sQ0FBQyxFQUFFO0lBQzFCO0lBQ0EsSUFBSyxJQUFJei9CLElBQUksR0FBR0EsSUFBSXkvQixPQUFPaGlDLE1BQU0sR0FBRyxHQUFHdUMsSUFBSztRQUMxQ3FFLElBQUlwRSxJQUFJLENBQUM7WUFDUDhSLEdBQUdBLElBQUlxeUIsUUFBUTNFLE1BQU0sQ0FBQ3ovQixJQUFJLEVBQUU7WUFDNUJ3YixHQUFHQSxJQUFJNm9CLFFBQVE1RSxNQUFNLENBQUN6L0IsSUFBSSxJQUFJLEVBQUU7UUFDbEM7SUFDRjtJQUNBLE9BQU9xRTtBQUNUO0FBRUEsMEZBQTBGO0FBQzFGLDZDQUE2QztBQUM3QyxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLHNDQUFzQztBQUN0QyxJQUFJaWdDLHVCQUF1QixTQUFTQSxxQkFBcUJ2eUIsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFb2tCLFVBQVUsRUFBRW5rQixPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTSxFQUFFbkMsT0FBTztJQUNqSCxJQUFJOEwsZ0JBQWdCLEVBQUU7SUFDdEIsSUFBSS9DO0lBQ0osSUFBSTFCLG9CQUFvQixJQUFJbGlDLE1BQU1naUMsV0FBV25pQyxNQUFNO0lBQ25ELElBQUkrbUMsY0FBYztJQUNsQixJQUFJN0osU0FBUyxNQUFNO1FBQ2pCNkosY0FBYztJQUNoQjtJQUNBLElBQUkvRTtJQUNKLElBQUkrRSxhQUFhO1FBQ2YsSUFBSyxJQUFJeGtDLElBQUksR0FBR0EsSUFBSTgvQixrQkFBa0JyaUMsTUFBTSxHQUFHLEdBQUd1QyxJQUFLO1lBQ3JEOC9CLGlCQUFpQixDQUFDOS9CLElBQUksRUFBRSxHQUFHNC9CLFVBQVUsQ0FBQzUvQixJQUFJLEVBQUUsR0FBRzI2QixRQUFRbGY7WUFDdkRxa0IsaUJBQWlCLENBQUM5L0IsSUFBSSxJQUFJLEVBQUUsR0FBRzQvQixVQUFVLENBQUM1L0IsSUFBSSxJQUFJLEVBQUUsR0FBRzQ2QixTQUFTbGY7UUFDbEU7UUFDQSxJQUFJK2MsVUFBVSxHQUFHO1lBQ2YsSUFBSXdILGtCQUFrQkMsY0FBY0osbUJBQW1CLENBQUNySDtZQUN4RGdILFNBQVNVLFVBQVVGO1FBQ3JCLE9BQU87WUFDTFIsU0FBU0s7UUFDWDtJQUNGLE9BQU87UUFDTEwsU0FBU0c7SUFDWDtJQUNBLElBQUk2RSxVQUFVQyxVQUFVQyxPQUFPQztJQUMvQixJQUFLLElBQUkvUCxNQUFNLEdBQUdBLE1BQU00SyxPQUFPaGlDLE1BQU0sR0FBRyxHQUFHbzNCLE1BQU87UUFDaEQ0UCxXQUFXaEYsTUFBTSxDQUFDNUssTUFBTSxFQUFFO1FBQzFCNlAsV0FBV2pGLE1BQU0sQ0FBQzVLLE1BQU0sSUFBSSxFQUFFO1FBQzlCLElBQUlBLE1BQU00SyxPQUFPaGlDLE1BQU0sR0FBRyxJQUFJLEdBQUc7WUFDL0JrbkMsUUFBUWxGLE1BQU0sQ0FBQyxDQUFDNUssTUFBTSxLQUFLLEVBQUU7WUFDN0IrUCxRQUFRbkYsTUFBTSxDQUFDLENBQUM1SyxNQUFNLEtBQUssSUFBSSxFQUFFO1FBQ25DLE9BQU87WUFDTDhQLFFBQVFsRixNQUFNLENBQUMsRUFBRTtZQUNqQm1GLFFBQVFuRixNQUFNLENBQUMsRUFBRTtRQUNuQjtRQUNBK0IsZUFBZXhGLHFCQUFxQmpxQixHQUFHeUosR0FBR0MsU0FBU0MsU0FBUytvQixVQUFVQyxVQUFVQyxPQUFPQztRQUN2RixJQUFJcEQsYUFBYS9qQyxNQUFNLEtBQUssR0FBRztZQUM3QjhtQyxjQUFjdGtDLElBQUksQ0FBQ3VoQyxZQUFZLENBQUMsRUFBRSxFQUFFQSxZQUFZLENBQUMsRUFBRTtRQUNyRDtJQUNGO0lBQ0EsT0FBTytDO0FBQ1Q7QUFDQSxJQUFJTSw0QkFBNEIsU0FBU0EsMEJBQTBCOXlCLENBQUMsRUFBRXlKLENBQUMsRUFBRW9rQixVQUFVLEVBQUVua0IsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRW5DLE9BQU8sRUFBRTRILE9BQU87SUFDcEksSUFBSWtFLGdCQUFnQixFQUFFO0lBQ3RCLElBQUkvQztJQUNKLElBQUlzRCxRQUFRLElBQUlsbkMsTUFBTWdpQyxXQUFXbmlDLE1BQU0sR0FBRztJQUMxQzRpQyxRQUFRMWYsT0FBTyxDQUFDLFNBQVU0ZixNQUFNLEVBQUV2Z0MsQ0FBQztRQUNqQyxJQUFJQSxNQUFNLEdBQUc7WUFDWDhrQyxLQUFLLENBQUNBLE1BQU1ybkMsTUFBTSxHQUFHLEVBQUUsR0FBRzhpQyxPQUFPQyxNQUFNO1lBQ3ZDc0UsS0FBSyxDQUFDQSxNQUFNcm5DLE1BQU0sR0FBRyxFQUFFLEdBQUc4aUMsT0FBT0UsTUFBTTtRQUN6QyxPQUFPO1lBQ0xxRSxLQUFLLENBQUM5a0MsSUFBSSxJQUFJLEVBQUUsR0FBR3VnQyxPQUFPQyxNQUFNO1lBQ2hDc0UsS0FBSyxDQUFDOWtDLElBQUksSUFBSSxFQUFFLEdBQUd1Z0MsT0FBT0UsTUFBTTtRQUNsQztRQUNBcUUsS0FBSyxDQUFDOWtDLElBQUksRUFBRSxHQUFHdWdDLE9BQU9HLEtBQUs7UUFDM0JvRSxLQUFLLENBQUM5a0MsSUFBSSxJQUFJLEVBQUUsR0FBR3VnQyxPQUFPSSxLQUFLO1FBQy9CYSxlQUFleEUsb0JBQW9CanJCLEdBQUd5SixHQUFHQyxTQUFTQyxTQUFTNmtCLE9BQU9NLEVBQUUsRUFBRU4sT0FBT3ZmLEVBQUUsRUFBRXVmLE9BQU9uRixNQUFNO1FBQzlGLElBQUlvRyxhQUFhL2pDLE1BQU0sS0FBSyxHQUFHO1lBQzdCOG1DLGNBQWN0a0MsSUFBSSxDQUFDdWhDLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFO1FBQ3JEO0lBQ0Y7SUFDQSxJQUFLLElBQUl4aEMsSUFBSSxHQUFHQSxJQUFJOGtDLE1BQU1ybkMsTUFBTSxHQUFHLEdBQUd1QyxJQUFLO1FBQ3pDd2hDLGVBQWV4RixxQkFBcUJqcUIsR0FBR3lKLEdBQUdDLFNBQVNDLFNBQVNvcEIsS0FBSyxDQUFDOWtDLElBQUksRUFBRSxFQUFFOGtDLEtBQUssQ0FBQzlrQyxJQUFJLElBQUksRUFBRSxFQUFFOGtDLEtBQUssQ0FBQzlrQyxJQUFJLElBQUksRUFBRSxFQUFFOGtDLEtBQUssQ0FBQzlrQyxJQUFJLElBQUksRUFBRSxFQUFFO1FBQ2hJLElBQUl3aEMsYUFBYS9qQyxNQUFNLEtBQUssR0FBRztZQUM3QjhtQyxjQUFjdGtDLElBQUksQ0FBQ3VoQyxZQUFZLENBQUMsRUFBRSxFQUFFQSxZQUFZLENBQUMsRUFBRTtRQUNyRDtJQUNGO0lBQ0EsSUFBSStDLGNBQWM5bUMsTUFBTSxHQUFHLEdBQUc7UUFDNUIsSUFBSXNuQyxxQkFBcUI7WUFBQ1IsYUFBYSxDQUFDLEVBQUU7WUFBRUEsYUFBYSxDQUFDLEVBQUU7U0FBQztRQUM3RCxJQUFJUyx3QkFBd0J6aUMsS0FBSzZ4QixHQUFHLENBQUMyUSxrQkFBa0IsQ0FBQyxFQUFFLEdBQUdoekIsR0FBRyxLQUFLeFAsS0FBSzZ4QixHQUFHLENBQUMyUSxrQkFBa0IsQ0FBQyxFQUFFLEdBQUd2cEIsR0FBRztRQUN6RyxJQUFLLElBQUl1WixNQUFNLEdBQUdBLE1BQU13UCxjQUFjOW1DLE1BQU0sR0FBRyxHQUFHczNCLE1BQU87WUFDdkQsSUFBSTZMLGtCQUFrQnIrQixLQUFLNnhCLEdBQUcsQ0FBQ21RLGFBQWEsQ0FBQ3hQLE1BQU0sRUFBRSxHQUFHaGpCLEdBQUcsS0FBS3hQLEtBQUs2eEIsR0FBRyxDQUFDbVEsYUFBYSxDQUFDeFAsTUFBTSxJQUFJLEVBQUUsR0FBR3ZaLEdBQUc7WUFDekcsSUFBSW9sQixtQkFBbUJvRSx1QkFBdUI7Z0JBQzVDRCxrQkFBa0IsQ0FBQyxFQUFFLEdBQUdSLGFBQWEsQ0FBQ3hQLE1BQU0sRUFBRTtnQkFDOUNnUSxrQkFBa0IsQ0FBQyxFQUFFLEdBQUdSLGFBQWEsQ0FBQ3hQLE1BQU0sSUFBSSxFQUFFO2dCQUNsRGlRLHdCQUF3QnBFO1lBQzFCO1FBQ0Y7UUFDQSxPQUFPbUU7SUFDVDtJQUNBLE9BQU9SO0FBQ1Q7QUFDQSxJQUFJVSxzQkFBc0IsU0FBU0Esb0JBQW9CekQsWUFBWSxFQUFFdEMsTUFBTSxFQUFFZ0csTUFBTTtJQUNqRixJQUFJQyxPQUFPO1FBQUMzRCxZQUFZLENBQUMsRUFBRSxHQUFHdEMsTUFBTSxDQUFDLEVBQUU7UUFBRXNDLFlBQVksQ0FBQyxFQUFFLEdBQUd0QyxNQUFNLENBQUMsRUFBRTtLQUFDO0lBQ3JFLElBQUl6aEMsU0FBUzhFLEtBQUsyd0IsSUFBSSxDQUFDaVMsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUU7SUFDNUQsSUFBSUMsV0FBVyxDQUFDM25DLFNBQVN5bkMsTUFBSyxJQUFLem5DO0lBQ25DLElBQUkybkMsV0FBVyxHQUFHO1FBQ2hCQSxXQUFXO0lBQ2I7SUFDQSxPQUFPO1FBQUNsRyxNQUFNLENBQUMsRUFBRSxHQUFHa0csV0FBV0QsSUFBSSxDQUFDLEVBQUU7UUFBRWpHLE1BQU0sQ0FBQyxFQUFFLEdBQUdrRyxXQUFXRCxJQUFJLENBQUMsRUFBRTtLQUFDO0FBQ3pFO0FBQ0EsSUFBSUUsb0NBQW9DLFNBQVNBLGtDQUFrQ0MsS0FBSyxFQUFFQyxlQUFlO0lBQ3ZHLElBQUk5RixTQUFTK0YsdUJBQXVCRixPQUFPQztJQUMzQzlGLFNBQVNnRyxtQkFBbUJoRztJQUM1QixPQUFPQTtBQUNUO0FBQ0EsSUFBSWdHLHFCQUFxQixTQUFTQSxtQkFBbUJoRyxNQUFNO0lBQ3pELElBQUkxdEIsR0FBR3lKO0lBQ1AsSUFBSThwQixRQUFRN0YsT0FBT2hpQyxNQUFNLEdBQUc7SUFDNUIsSUFBSWlvQyxPQUFPbGEsVUFDVG1hLE9BQU9uYSxVQUNQb2EsT0FBTyxDQUFDcGEsVUFDUnFhLE9BQU8sQ0FBQ3JhO0lBQ1YsSUFBSyxJQUFJeHJCLElBQUksR0FBR0EsSUFBSXNsQyxPQUFPdGxDLElBQUs7UUFDOUIrUixJQUFJMHRCLE1BQU0sQ0FBQyxJQUFJei9CLEVBQUU7UUFDakJ3YixJQUFJaWtCLE1BQU0sQ0FBQyxJQUFJei9CLElBQUksRUFBRTtRQUNyQjBsQyxPQUFPbmpDLEtBQUsrVSxHQUFHLENBQUNvdUIsTUFBTTN6QjtRQUN0QjZ6QixPQUFPcmpDLEtBQUs2VSxHQUFHLENBQUN3dUIsTUFBTTd6QjtRQUN0QjR6QixPQUFPcGpDLEtBQUsrVSxHQUFHLENBQUNxdUIsTUFBTW5xQjtRQUN0QnFxQixPQUFPdGpDLEtBQUs2VSxHQUFHLENBQUN5dUIsTUFBTXJxQjtJQUN4QjtJQUVBLGtCQUFrQjtJQUNsQixJQUFJc3FCLEtBQUssSUFBS0YsQ0FBQUEsT0FBT0YsSUFBRztJQUN4QixJQUFJSyxLQUFLLElBQUtGLENBQUFBLE9BQU9GLElBQUc7SUFDeEIsSUFBSyxJQUFJclEsTUFBTSxHQUFHQSxNQUFNZ1EsT0FBT2hRLE1BQU87UUFDcEN2akIsSUFBSTB0QixNQUFNLENBQUMsSUFBSW5LLElBQUksR0FBR21LLE1BQU0sQ0FBQyxJQUFJbkssSUFBSSxHQUFHd1E7UUFDeEN0cUIsSUFBSWlrQixNQUFNLENBQUMsSUFBSW5LLE1BQU0sRUFBRSxHQUFHbUssTUFBTSxDQUFDLElBQUluSyxNQUFNLEVBQUUsR0FBR3lRO1FBQ2hETCxPQUFPbmpDLEtBQUsrVSxHQUFHLENBQUNvdUIsTUFBTTN6QjtRQUN0QjZ6QixPQUFPcmpDLEtBQUs2VSxHQUFHLENBQUN3dUIsTUFBTTd6QjtRQUN0QjR6QixPQUFPcGpDLEtBQUsrVSxHQUFHLENBQUNxdUIsTUFBTW5xQjtRQUN0QnFxQixPQUFPdGpDLEtBQUs2VSxHQUFHLENBQUN5dUIsTUFBTXJxQjtJQUN4QjtJQUNBLElBQUltcUIsT0FBTyxDQUFDLEdBQUc7UUFDYixJQUFLLElBQUlLLE1BQU0sR0FBR0EsTUFBTVYsT0FBT1UsTUFBTztZQUNwQ3hxQixJQUFJaWtCLE1BQU0sQ0FBQyxJQUFJdUcsTUFBTSxFQUFFLEdBQUd2RyxNQUFNLENBQUMsSUFBSXVHLE1BQU0sRUFBRSxHQUFJLEVBQUMsSUFBSUwsSUFBRztRQUMzRDtJQUNGO0lBQ0EsT0FBT2xHO0FBQ1Q7QUFDQSxJQUFJK0YseUJBQXlCLFNBQVNBLHVCQUF1QkYsS0FBSyxFQUFFQyxlQUFlO0lBQ2pGLElBQUlVLFlBQVksTUFBTVgsUUFBUSxJQUFJL2lDLEtBQUtzWixFQUFFO0lBQ3pDLElBQUlxcUIsYUFBYVosUUFBUSxNQUFNLElBQUkvaUMsS0FBS3NaLEVBQUUsR0FBRyxNQUFNb3FCLFlBQVksTUFBTTFqQyxLQUFLc1osRUFBRSxHQUFHO0lBQy9FcXFCLGNBQWNYO0lBQ2QsSUFBSTlGLFNBQVMsSUFBSTdoQyxNQUFNMG5DLFFBQVE7SUFDL0IsSUFBSWE7SUFDSixJQUFLLElBQUlubUMsSUFBSSxHQUFHQSxJQUFJc2xDLE9BQU90bEMsSUFBSztRQUM5Qm1tQyxlQUFlbm1DLElBQUlpbUMsWUFBWUM7UUFDL0J6RyxNQUFNLENBQUMsSUFBSXovQixFQUFFLEdBQUd1QyxLQUFLd1osR0FBRyxDQUFDb3FCLGVBQWUsSUFBSTtRQUM1QzFHLE1BQU0sQ0FBQyxJQUFJei9CLElBQUksRUFBRSxHQUFHdUMsS0FBS3laLEdBQUcsQ0FBQyxDQUFDbXFCLGVBQWUsSUFBSTtJQUNuRDtJQUNBLE9BQU8xRztBQUNUO0FBRUEsaUZBQWlGO0FBQ2pGLElBQUluRSwwQkFBMEIsU0FBU0Esd0JBQXdCWCxLQUFLLEVBQUVDLE1BQU07SUFDMUUsT0FBT3I0QixLQUFLK1UsR0FBRyxDQUFDcWpCLFFBQVEsR0FBR0MsU0FBUyxHQUFHO0FBQ3pDO0FBRUEseUJBQXlCO0FBQ3pCLElBQUl3TCx3QkFBd0IsU0FBU0Esc0JBQXNCekwsS0FBSyxFQUFFQyxNQUFNO0lBQ3RFLE9BQU9yNEIsS0FBSytVLEdBQUcsQ0FBQ3FqQixRQUFRLElBQUlDLFNBQVMsSUFBSTtBQUMzQztBQUNBLElBQUl5TCw4QkFBOEIsU0FBU0E7SUFDekMsT0FBTztBQUNUO0FBQ0EsSUFBSUMsdUJBQXVCLFNBQVNBLHFCQUFxQjdPLEVBQUUsRUFBRVAsRUFBRSxFQUFFQyxFQUFFO0lBQ2pFLE9BQU87UUFBQ00sS0FBSyxJQUFJUCxLQUFLQztRQUFJLElBQUtELENBQUFBLEtBQUtPLEVBQUM7UUFBSUE7S0FBRztBQUM5QztBQUVBLHFHQUFxRztBQUNyRyxJQUFJOE8sMEJBQTBCLFNBQVNBLHdCQUF3QjVMLEtBQUssRUFBRUMsTUFBTTtJQUMxRSxPQUFPO1FBQ0w0TCxjQUFjamtDLEtBQUsrVSxHQUFHLENBQUMsSUFBSSxPQUFPc2pCO1FBQ2xDNkwsYUFBYWxrQyxLQUFLK1UsR0FBRyxDQUFDLEtBQUssT0FBT3FqQjtRQUNsQytMLGlCQUFpQjtJQUNuQjtBQUNGO0FBRUEseUVBQXlFO0FBQ3pFLG1GQUFtRjtBQUNuRixzQ0FBc0M7QUFDdEMsU0FBU0MsdUJBQXVCQyxLQUFLLEVBQUVDLEtBQUs7SUFDMUMsU0FBU0MsUUFBUXZOLE9BQU87UUFDdEIsSUFBSXdOLE9BQU8sRUFBRTtRQUNiLElBQUssSUFBSS9tQyxJQUFJLEdBQUdBLElBQUl1NUIsUUFBUTk3QixNQUFNLEVBQUV1QyxJQUFLO1lBQ3ZDLElBQUlrM0IsS0FBS3FDLE9BQU8sQ0FBQ3Y1QixFQUFFO1lBQ25CLElBQUltM0IsS0FBS29DLE9BQU8sQ0FBQyxDQUFDdjVCLElBQUksS0FBS3U1QixRQUFROTdCLE1BQU0sQ0FBQztZQUMxQyxJQUFJbXBCLE9BQU87Z0JBQ1Q3VSxHQUFHb2xCLEdBQUdwbEIsQ0FBQyxHQUFHbWxCLEdBQUdubEIsQ0FBQztnQkFDZHlKLEdBQUcyYixHQUFHM2IsQ0FBQyxHQUFHMGIsR0FBRzFiLENBQUM7WUFDaEI7WUFDQSxJQUFJd3JCLFNBQVM7Z0JBQ1hqMUIsR0FBRyxDQUFDNlUsS0FBS3BMLENBQUM7Z0JBQ1ZBLEdBQUdvTCxLQUFLN1UsQ0FBQztZQUNYO1lBQ0EsSUFBSXRVLFNBQVM4RSxLQUFLMndCLElBQUksQ0FBQzhULE9BQU9qMUIsQ0FBQyxHQUFHaTFCLE9BQU9qMUIsQ0FBQyxHQUFHaTFCLE9BQU94ckIsQ0FBQyxHQUFHd3JCLE9BQU94ckIsQ0FBQztZQUNoRXVyQixLQUFLOW1DLElBQUksQ0FBQztnQkFDUjhSLEdBQUdpMUIsT0FBT2oxQixDQUFDLEdBQUd0VTtnQkFDZCtkLEdBQUd3ckIsT0FBT3hyQixDQUFDLEdBQUcvZDtZQUNoQjtRQUNGO1FBQ0EsT0FBT3NwQztJQUNUO0lBQ0EsU0FBU0UsUUFBUTFOLE9BQU8sRUFBRTJOLElBQUk7UUFDNUIsSUFBSTV2QixNQUFNa1U7UUFDVixJQUFJcFUsTUFBTSxDQUFDb1U7UUFDWCxJQUFJMmIsWUFBWXJvQywyQkFBMkJ5NkIsVUFDekM2TjtRQUNGLElBQUk7WUFDRixJQUFLRCxVQUFVaG9DLENBQUMsSUFBSSxDQUFDLENBQUNpb0MsUUFBUUQsVUFBVXhwQyxDQUFDLEVBQUMsRUFBR3lCLElBQUksRUFBRztnQkFDbEQsSUFBSWlvQyxRQUFRRCxNQUFNL25DLEtBQUs7Z0JBQ3ZCLElBQUlpb0MsYUFBYUQsTUFBTXQxQixDQUFDLEdBQUdtMUIsS0FBS24xQixDQUFDLEdBQUdzMUIsTUFBTTdyQixDQUFDLEdBQUcwckIsS0FBSzFyQixDQUFDO2dCQUNwRGxFLE1BQU0vVSxLQUFLK1UsR0FBRyxDQUFDQSxLQUFLZ3dCO2dCQUNwQmx3QixNQUFNN1UsS0FBSzZVLEdBQUcsQ0FBQ0EsS0FBS2t3QjtZQUN0QjtRQUNGLEVBQUUsT0FBT0MsS0FBSztZQUNaSixVQUFVenBDLENBQUMsQ0FBQzZwQztRQUNkLFNBQVU7WUFDUkosVUFBVTduQyxDQUFDO1FBQ2I7UUFDQSxPQUFPO1lBQ0xnWSxLQUFLQTtZQUNMRixLQUFLQTtRQUNQO0lBQ0Y7SUFDQSxTQUFTb3dCLFNBQVNDLEtBQUssRUFBRUMsS0FBSztRQUM1QixPQUFPLENBQUVELENBQUFBLE1BQU1yd0IsR0FBRyxHQUFHc3dCLE1BQU1wd0IsR0FBRyxJQUFJb3dCLE1BQU10d0IsR0FBRyxHQUFHcXdCLE1BQU1ud0IsR0FBRztJQUN6RDtJQUNBLElBQUl5dkIsT0FBTyxFQUFFLENBQUN2ZSxNQUFNLENBQUNub0IsbUJBQW1CeW1DLFFBQVFGLFNBQVN2bUMsbUJBQW1CeW1DLFFBQVFEO0lBQ3BGLElBQUljLGFBQWE3b0MsMkJBQTJCaW9DLE9BQzFDYTtJQUNGLElBQUk7UUFDRixJQUFLRCxXQUFXeG9DLENBQUMsSUFBSSxDQUFDLENBQUN5b0MsU0FBU0QsV0FBV2hxQyxDQUFDLEVBQUMsRUFBR3lCLElBQUksRUFBRztZQUNyRCxJQUFJOG5DLE9BQU9VLE9BQU92b0MsS0FBSztZQUN2QixJQUFJb29DLFFBQVFSLFFBQVFMLE9BQU9NO1lBQzNCLElBQUlRLFFBQVFULFFBQVFKLE9BQU9LO1lBQzNCLElBQUksQ0FBQ00sU0FBU0MsT0FBT0MsUUFBUTtnQkFDM0IsT0FBTyxPQUFPLCtDQUErQztZQUMvRDtRQUNGO0lBQ0YsRUFBRSxPQUFPSCxLQUFLO1FBQ1pJLFdBQVdqcUMsQ0FBQyxDQUFDNnBDO0lBQ2YsU0FBVTtRQUNSSSxXQUFXcm9DLENBQUM7SUFDZDtJQUNBLE9BQU8sTUFBTSxxQkFBcUI7QUFDcEM7QUFFQSxJQUFJdW9DLG1CQUFtQnJwQixXQUFXO0lBQ2hDc3BCLGVBQWU7SUFDZkMsV0FBVztJQUNYQyxZQUFZO0lBQ1p0ZCxRQUFRLFNBQVNBLE9BQU85RCxJQUFJO1FBQzFCLE9BQU87SUFDVDtBQUNGO0FBQ0EsSUFBSXFoQixXQUFXO0lBQ2JDLFVBQVUsU0FBU0EsU0FBUzMyQixPQUFPO1FBQ2pDLElBQUk0MkIsb0JBQW9CTixpQkFBaUJ0MkIsVUFDdkN1MkIsZ0JBQWdCSyxrQkFBa0JMLGFBQWEsRUFDL0NDLFlBQVlJLGtCQUFrQkosU0FBUyxFQUN2Q0MsYUFBYUcsa0JBQWtCSCxVQUFVLEVBQ3pDdGQsU0FBU3lkLGtCQUFrQnpkLE1BQU07UUFDbkMsSUFBSTFKLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtRQUN6QixJQUFJb0UsZ0JBQWdCLElBQUksQ0FBQ0MsT0FBTyxJQUM5QkMsUUFBUUYsY0FBY0UsS0FBSyxFQUMzQnRDLFFBQVFvQyxjQUFjcEMsS0FBSztRQUM3QixJQUFJOEosV0FBV3hILE1BQU03bkIsTUFBTTtRQUMzQixJQUFJMnFDLGNBQWN0YixXQUFXQTtRQUM3QixJQUFJZ0UsV0FBVzlOLE1BQU12bEIsTUFBTTtRQUUzQix3Q0FBd0M7UUFDeEMsb0RBQW9EO1FBQ3BELGtEQUFrRDtRQUNsRCxJQUFJNHFDLFNBQVMsSUFBSXpxQyxNQUFNd3FDO1FBQ3ZCLElBQUlFLFlBQVksSUFBSTFxQyxNQUFNa3ZCO1FBQzFCLElBQUl5YixpQkFBaUIsQ0FBQyxJQUFJVCxhQUFZLElBQUtoYjtRQUUzQyxxQkFBcUI7UUFDckIsSUFBSyxJQUFJOXNCLElBQUksR0FBR0EsSUFBSThzQixVQUFVOXNCLElBQUs7WUFDakMsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxJQUFJeW1CLFVBQVV6bUIsSUFBSztnQkFDakMsSUFBSTFJLElBQUlxQyxJQUFJOHNCLFdBQVd6bUI7Z0JBQ3ZCZ2lDLE1BQU0sQ0FBQzFxQyxFQUFFLEdBQUc7WUFDZDtZQUNBMnFDLFNBQVMsQ0FBQ3RvQyxFQUFFLEdBQUc7UUFDakI7UUFFQSxxQkFBcUI7UUFDckIsSUFBSyxJQUFJMG1CLEtBQUssR0FBR0EsS0FBS29LLFVBQVVwSyxLQUFNO1lBQ3BDLElBQUlFLE9BQU81RCxLQUFLLENBQUMwRCxHQUFHO1lBQ3BCLElBQUk4aEIsUUFBUTVoQixLQUFLeEYsSUFBSSxDQUFDO1lBQ3RCLElBQUlxbkIsUUFBUTdoQixLQUFLeEYsSUFBSSxDQUFDO1lBRXRCLG9DQUFvQztZQUNwQyxJQUFJb25CLFVBQVVDLE9BQU87Z0JBQ25CO1lBQ0Y7WUFDQSxJQUFJdHBDLElBQUltbUIsTUFBTW9qQixTQUFTLENBQUNGO1lBQ3hCLElBQUlycUMsSUFBSW1uQixNQUFNb2pCLFNBQVMsQ0FBQ0Q7WUFDeEIsSUFBSS9yQixJQUFJZ08sT0FBTzlEO1lBQ2YsSUFBSStoQixLQUFLeHFDLElBQUkydUIsV0FBVzN0QjtZQUV4QixnQkFBZ0I7WUFDaEJrcEMsTUFBTSxDQUFDTSxHQUFHLElBQUlqc0I7WUFFZCxvQkFBb0I7WUFDcEI0ckIsU0FBUyxDQUFDbnBDLEVBQUUsSUFBSXVkO1FBQ2xCO1FBRUEscURBQXFEO1FBQ3JELG9EQUFvRDtRQUNwRCxJQUFJMVYsSUFBSSxNQUFNOGxCLFdBQVd5YixnQkFBZ0IsWUFBWTtRQUVyRCxvQ0FBb0M7UUFDcEMsSUFBSyxJQUFJdGYsS0FBSyxHQUFHQSxLQUFLNkQsVUFBVTdELEtBQU07WUFDcEMsSUFBSXFmLFNBQVMsQ0FBQ3JmLEdBQUcsS0FBSyxHQUFHO2dCQUN2QixnRkFBZ0Y7Z0JBQ2hGLElBQUssSUFBSTNDLE1BQU0sR0FBR0EsTUFBTXdHLFVBQVV4RyxNQUFPO29CQUN2QyxJQUFJc2lCLE1BQU10aUIsTUFBTXdHLFdBQVc3RDtvQkFDM0JvZixNQUFNLENBQUNPLElBQUksR0FBRzVoQztnQkFDaEI7WUFDRixPQUFPO2dCQUNMLCtEQUErRDtnQkFDL0QsSUFBSyxJQUFJNnRCLE1BQU0sR0FBR0EsTUFBTS9ILFVBQVUrSCxNQUFPO29CQUN2QyxJQUFJZ1UsTUFBTWhVLE1BQU0vSCxXQUFXN0Q7b0JBQzNCb2YsTUFBTSxDQUFDUSxJQUFJLEdBQUdSLE1BQU0sQ0FBQ1EsSUFBSSxHQUFHUCxTQUFTLENBQUNyZixHQUFHLEdBQUdzZjtnQkFDOUM7WUFDRjtRQUNGO1FBRUEsa0RBQWtEO1FBQ2xELElBQUlPLGNBQWMsSUFBSWxyQyxNQUFNa3ZCO1FBQzVCLElBQUlpYyxPQUFPLElBQUluckMsTUFBTWt2QjtRQUNyQixJQUFJa2M7UUFFSixpQ0FBaUM7UUFDakMsaUVBQWlFO1FBQ2pFLElBQUssSUFBSWpVLE1BQU0sR0FBR0EsTUFBTWpJLFVBQVVpSSxNQUFPO1lBQ3ZDK1QsV0FBVyxDQUFDL1QsSUFBSSxHQUFHO1FBQ3JCO1FBQ0EsSUFBSyxJQUFJRCxPQUFPLEdBQUdBLE9BQU9rVCxZQUFZbFQsT0FBUTtZQUM1QywwQkFBMEI7WUFDMUIsSUFBSyxJQUFJUSxNQUFNLEdBQUdBLE1BQU14SSxVQUFVd0ksTUFBTztnQkFDdkN5VCxJQUFJLENBQUN6VCxJQUFJLEdBQUc7WUFDZDtZQUVBLHVDQUF1QztZQUN2QyxJQUFLLElBQUkwUSxNQUFNLEdBQUdBLE1BQU1sWixVQUFVa1osTUFBTztnQkFDdkMsSUFBSyxJQUFJaUQsTUFBTSxHQUFHQSxNQUFNbmMsVUFBVW1jLE1BQU87b0JBQ3ZDLElBQUlDLE1BQU1sRCxNQUFNbFosV0FBV21jO29CQUMzQkYsSUFBSSxDQUFDL0MsSUFBSSxJQUFJcUMsTUFBTSxDQUFDYSxJQUFJLEdBQUdKLFdBQVcsQ0FBQ0csSUFBSTtnQkFDN0M7WUFDRjtZQUNBMVIsb0JBQW9Cd1I7WUFDcEJDLFdBQVdGO1lBQ1hBLGNBQWNDO1lBQ2RBLE9BQU9DO1lBQ1AsSUFBSUcsT0FBTztZQUNYLHNEQUFzRDtZQUN0RCxJQUFLLElBQUlDLE1BQU0sR0FBR0EsTUFBTXRjLFVBQVVzYyxNQUFPO2dCQUN2QyxJQUFJQyxRQUFRTCxRQUFRLENBQUNJLElBQUksR0FBR04sV0FBVyxDQUFDTSxJQUFJO2dCQUM1Q0QsUUFBUUUsUUFBUUE7WUFDbEI7WUFFQSxtRUFBbUU7WUFDbkUsSUFBSUYsT0FBT3BCLFdBQVc7Z0JBQ3BCO1lBQ0Y7UUFDRjtRQUVBLG1CQUFtQjtRQUNuQixJQUFJM1gsTUFBTTtZQUNSa1osTUFBTSxTQUFTQSxLQUFLM2lCLElBQUk7Z0JBQ3RCQSxPQUFPM0YsR0FBR3JlLFVBQVUsQ0FBQ2drQixLQUFLLENBQUMsRUFBRTtnQkFDN0IsT0FBT21pQixXQUFXLENBQUN4akIsTUFBTTZELE9BQU8sQ0FBQ3hDLE1BQU07WUFDekM7UUFDRjtRQUNBLE9BQU95SjtJQUNULEVBQUUsV0FBVztBQUNmLEdBQUcsU0FBUztBQUVaLElBQUltWixhQUFhL3FCLFdBQVc7SUFDMUJ6TCxNQUFNO0lBQ04yWCxRQUFRLFNBQVNBLE9BQU85RCxJQUFJO1FBQzFCLE9BQU87SUFDVDtJQUNBaEMsVUFBVTtJQUNWL2MsT0FBTztBQUNUO0FBQ0EsSUFBSTJoQyxXQUFXO0lBQ2JDLDRCQUE0QixTQUFTQSwyQkFBMkJsNEIsT0FBTztRQUNyRUEsVUFBVWc0QixXQUFXaDRCO1FBQ3JCLElBQUl5UCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJc0UsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSXdILFdBQVd4SCxNQUFNN25CLE1BQU07UUFDM0IsSUFBSSxDQUFDOFQsUUFBUXFULFFBQVEsRUFBRTtZQUNyQixJQUFJOGtCLFVBQVUsQ0FBQztZQUNmLElBQUlDLFlBQVk7WUFDaEIsSUFBSyxJQUFJM3BDLElBQUksR0FBR0EsSUFBSThzQixVQUFVOXNCLElBQUs7Z0JBQ2pDLElBQUkybUIsT0FBT3JCLEtBQUssQ0FBQ3RsQixFQUFFO2dCQUVuQiwyRUFBMkU7Z0JBQzNFdVIsUUFBUXdCLElBQUksR0FBRzRUO2dCQUNmLElBQUlpakIsYUFBYSxJQUFJLENBQUNDLGdCQUFnQixDQUFDdDRCO2dCQUN2QyxJQUFJbzRCLFlBQVlDLFdBQVdFLE1BQU0sRUFBRTtvQkFDakNILFlBQVlDLFdBQVdFLE1BQU07Z0JBQy9CO2dCQUNBSixPQUFPLENBQUMvaUIsS0FBS2xCLEVBQUUsR0FBRyxHQUFHbWtCLFdBQVdFLE1BQU07WUFDeEM7WUFDQSxPQUFPO2dCQUNMQSxRQUFRLFNBQVNBLE9BQU9uakIsSUFBSTtvQkFDMUIsSUFBSWdqQixjQUFjLEdBQUc7d0JBQ25CLE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSTluQyxPQUFPOGtCLE9BQU87d0JBQ2hCLDRCQUE0Qjt3QkFDNUJBLE9BQU8zRixHQUFHTixNQUFNLENBQUNpRztvQkFDbkI7b0JBQ0EsT0FBTytpQixPQUFPLENBQUMvaUIsS0FBS2xCLEVBQUUsR0FBRyxHQUFHa2tCO2dCQUM5QjtZQUNGO1FBQ0YsT0FBTztZQUNMLElBQUlJLFlBQVksQ0FBQztZQUNqQixJQUFJQyxhQUFhLENBQUM7WUFDbEIsSUFBSUMsY0FBYztZQUNsQixJQUFJQyxlQUFlO1lBQ25CLElBQUssSUFBSXhqQixLQUFLLEdBQUdBLEtBQUtvRyxVQUFVcEcsS0FBTTtnQkFDcEMsSUFBSWtNLFFBQVF0TixLQUFLLENBQUNvQixHQUFHO2dCQUNyQixJQUFJakIsS0FBS21OLE1BQU1uTixFQUFFO2dCQUVqQiwyRUFBMkU7Z0JBQzNFbFUsUUFBUXdCLElBQUksR0FBRzZmO2dCQUNmLElBQUl1WCxjQUFjLElBQUksQ0FBQ04sZ0JBQWdCLENBQUN0NEI7Z0JBQ3hDLElBQUkwNEIsY0FBY0UsWUFBWUMsUUFBUSxFQUFFSCxjQUFjRSxZQUFZQyxRQUFRO2dCQUMxRSxJQUFJRixlQUFlQyxZQUFZRSxTQUFTLEVBQUVILGVBQWVDLFlBQVlFLFNBQVM7Z0JBQzlFTixTQUFTLENBQUN0a0IsR0FBRyxHQUFHMGtCLFlBQVlDLFFBQVE7Z0JBQ3BDSixVQUFVLENBQUN2a0IsR0FBRyxHQUFHMGtCLFlBQVlFLFNBQVM7WUFDeEM7WUFDQSxPQUFPO2dCQUNMRCxVQUFVLFNBQVNBLFNBQVN6akIsSUFBSTtvQkFDOUIsSUFBSXNqQixlQUFlLEdBQUc7d0JBQ3BCLE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSXBvQyxPQUFPOGtCLE9BQU87d0JBQ2hCLDRCQUE0Qjt3QkFDNUJBLE9BQU8zRixHQUFHTixNQUFNLENBQUNpRztvQkFDbkI7b0JBQ0EsT0FBT29qQixTQUFTLENBQUNwakIsS0FBS2xCLEVBQUUsR0FBRyxHQUFHd2tCO2dCQUNoQztnQkFDQUksV0FBVyxTQUFTQSxVQUFVMWpCLElBQUk7b0JBQ2hDLElBQUl1akIsaUJBQWlCLEdBQUc7d0JBQ3RCLE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSXJvQyxPQUFPOGtCLE9BQU87d0JBQ2hCLDRCQUE0Qjt3QkFDNUJBLE9BQU8zRixHQUFHTixNQUFNLENBQUNpRztvQkFDbkI7b0JBQ0EsT0FBT3FqQixVQUFVLENBQUNyakIsS0FBS2xCLEVBQUUsR0FBRyxHQUFHeWtCO2dCQUNqQztZQUNGO1FBQ0Y7SUFDRjtJQUNBLDZCQUE2QjtJQUU3QixtREFBbUQ7SUFDbkQsaUZBQWlGO0lBQ2pGLCtCQUErQjtJQUMvQkwsa0JBQWtCLFNBQVNBLGlCQUFpQnQ0QixPQUFPO1FBQ2pEQSxVQUFVZzRCLFdBQVdoNEI7UUFDckIsSUFBSXlQLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUlzcEIsY0FBYyxJQUFJO1FBQ3RCLElBQUlDLFdBQVdoNUIsU0FDYndCLE9BQU93M0IsU0FBU3gzQixJQUFJLEVBQ3BCMlgsU0FBUzZmLFNBQVM3ZixNQUFNLEVBQ3hCOUYsV0FBVzJsQixTQUFTM2xCLFFBQVEsRUFDNUIvYyxRQUFRMGlDLFNBQVMxaUMsS0FBSztRQUN4QmtMLE9BQU9pTyxHQUFHcmUsVUFBVSxDQUFDb1EsS0FBSyxDQUFDLEVBQUU7UUFDN0IsSUFBSSxDQUFDNlIsVUFBVTtZQUNiLElBQUk0bEIsWUFBWXozQixLQUFLc1QsY0FBYyxHQUFHbWIsWUFBWSxDQUFDOEk7WUFDbkQsSUFBSWhtQyxJQUFJa21DLFVBQVUvc0MsTUFBTTtZQUN4QixJQUFJMEIsSUFBSTtZQUVSLHdCQUF3QjtZQUN4QixJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSXdxQyxVQUFVL3NDLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3pDYixLQUFLdXJCLE9BQU84ZixTQUFTLENBQUN4cUMsRUFBRTtZQUMxQjtZQUNBLE9BQU87Z0JBQ0w4cEMsUUFBUXZuQyxLQUFLNnhCLEdBQUcsQ0FBQzl2QixHQUFHLElBQUl1RCxTQUFTdEYsS0FBSzZ4QixHQUFHLENBQUNqMUIsR0FBRzBJO1lBQy9DO1FBQ0YsT0FBTztZQUNMLElBQUltYixRQUFRalEsS0FBS3NULGNBQWM7WUFDL0IsSUFBSW9rQixXQUFXem5CLE1BQU10QyxNQUFNLENBQUMsU0FBVWtHLElBQUk7Z0JBQ3hDLE9BQU9BLEtBQUt0RixNQUFNLEdBQUc2RSxJQUFJLENBQUNwVCxTQUFTdTNCLFlBQVl4cUIsR0FBRyxDQUFDOEc7WUFDckQ7WUFDQSxJQUFJOGpCLFdBQVcxbkIsTUFBTXRDLE1BQU0sQ0FBQyxTQUFVa0csSUFBSTtnQkFDeEMsT0FBT0EsS0FBS3ZGLE1BQU0sR0FBRzhFLElBQUksQ0FBQ3BULFNBQVN1M0IsWUFBWXhxQixHQUFHLENBQUM4RztZQUNyRDtZQUNBLElBQUkrakIsT0FBT0YsU0FBU2h0QyxNQUFNO1lBQzFCLElBQUltdEMsUUFBUUYsU0FBU2p0QyxNQUFNO1lBQzNCLElBQUlvdEMsT0FBTztZQUNYLElBQUlDLFFBQVE7WUFFWixpQ0FBaUM7WUFDakMsSUFBSyxJQUFJeGtCLE1BQU0sR0FBR0EsTUFBTW1rQixTQUFTaHRDLE1BQU0sRUFBRTZvQixNQUFPO2dCQUM5Q3VrQixRQUFRbmdCLE9BQU8rZixRQUFRLENBQUNua0IsSUFBSTtZQUM5QjtZQUVBLGlDQUFpQztZQUNqQyxJQUFLLElBQUl1TyxNQUFNLEdBQUdBLE1BQU02VixTQUFTanRDLE1BQU0sRUFBRW8zQixNQUFPO2dCQUM5Q2lXLFNBQVNwZ0IsT0FBT2dnQixRQUFRLENBQUM3VixJQUFJO1lBQy9CO1lBQ0EsT0FBTztnQkFDTHVWLFVBQVU3bkMsS0FBSzZ4QixHQUFHLENBQUN1VyxNQUFNLElBQUk5aUMsU0FBU3RGLEtBQUs2eEIsR0FBRyxDQUFDeVcsTUFBTWhqQztnQkFDckR3aUMsV0FBVzluQyxLQUFLNnhCLEdBQUcsQ0FBQ3dXLE9BQU8sSUFBSS9pQyxTQUFTdEYsS0FBSzZ4QixHQUFHLENBQUMwVyxPQUFPampDO1lBQzFEO1FBQ0Y7SUFDRixFQUFFLG1CQUFtQjtBQUN2QixHQUFHLFNBQVM7QUFFWixpQ0FBaUM7QUFDakMyaEMsU0FBU3VCLEVBQUUsR0FBR3ZCLFNBQVNLLGdCQUFnQjtBQUN2Q0wsU0FBU3dCLEdBQUcsR0FBR3hCLFNBQVN5QiwwQkFBMEIsR0FBR3pCLFNBQVNDLDBCQUEwQjtBQUV4RixJQUFJeUIsYUFBYTFzQixXQUFXO0lBQzFCMnNCLFVBQVU7SUFDVnpnQixRQUFRLFNBQVNBO1FBQ2YsT0FBTztJQUNUO0lBQ0E5RixVQUFVO0lBQ1Y3UixNQUFNO0FBQ1I7QUFDQSxJQUFJcTRCLFdBQVc7SUFDYkMsK0JBQStCLFNBQVNBLDhCQUE4Qjk1QixPQUFPO1FBQzNFLElBQUltTixZQUFZd3NCLFdBQVczNUIsVUFDekI0NUIsV0FBV3pzQixVQUFVeXNCLFFBQVEsRUFDN0J6Z0IsU0FBU2hNLFVBQVVnTSxNQUFNLEVBQ3pCOUYsV0FBV2xHLFVBQVVrRyxRQUFRO1FBQy9CLElBQUk1RCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJc3FCLGNBQWMsQ0FBQztRQUNuQixJQUFJQyxlQUFlO1FBQ25CLElBQUlqbUIsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSWttQixLQUFLLElBQUksQ0FBQ2pjLGFBQWEsQ0FBQztZQUMxQjdFLFFBQVFBO1lBQ1I5RixVQUFVQTtRQUNaO1FBRUEsa0VBQWtFO1FBQ2xFLElBQUssSUFBSTVrQixJQUFJLEdBQUdBLElBQUlzbEIsTUFBTTduQixNQUFNLEVBQUV1QyxJQUFLO1lBQ3JDLElBQUl5ckMsZ0JBQWdCO1lBQ3BCLElBQUlDLFNBQVNwbUIsS0FBSyxDQUFDdGxCLEVBQUU7WUFDckIsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxJQUFJaWYsTUFBTTduQixNQUFNLEVBQUU0SSxJQUFLO2dCQUNyQyxJQUFJckcsTUFBTXFHLEdBQUc7b0JBQ1gsSUFBSWtsQixJQUFJaWdCLEdBQUd6YyxRQUFRLENBQUMyYyxRQUFRcG1CLEtBQUssQ0FBQ2pmLEVBQUU7b0JBQ3BDLElBQUk4a0MsVUFBVTt3QkFDWk0saUJBQWlCLElBQUlsZ0I7b0JBQ3ZCLE9BQU87d0JBQ0xrZ0IsaUJBQWlCbGdCO29CQUNuQjtnQkFDRjtZQUNGO1lBQ0EsSUFBSSxDQUFDNGYsVUFBVTtnQkFDYk0sZ0JBQWdCLElBQUlBO1lBQ3RCO1lBQ0EsSUFBSUYsZUFBZUUsZUFBZTtnQkFDaENGLGVBQWVFO1lBQ2pCO1lBQ0FILFdBQVcsQ0FBQ0ksT0FBT2ptQixFQUFFLEdBQUcsR0FBR2dtQjtRQUM3QjtRQUNBLE9BQU87WUFDTEUsV0FBVyxTQUFTQSxVQUFVaGxCLElBQUk7Z0JBQ2hDLElBQUk0a0IsZ0JBQWdCLEdBQUc7b0JBQ3JCLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSTFwQyxPQUFPOGtCLE9BQU87b0JBQ2hCLDRCQUE0QjtvQkFDNUJBLE9BQU8zRixHQUFHTixNQUFNLENBQUNpRyxLQUFLLENBQUMsRUFBRSxDQUFDbEIsRUFBRTtnQkFDOUIsT0FBTztvQkFDTCxpQkFBaUI7b0JBQ2pCa0IsT0FBT0EsS0FBS2xCLEVBQUU7Z0JBQ2hCO2dCQUNBLE9BQU82bEIsV0FBVyxDQUFDM2tCLEtBQUssR0FBRzRrQjtZQUM3QjtRQUNGO0lBQ0Y7SUFDQSw2Q0FBNkM7SUFDN0NLLHFCQUFxQixTQUFTQSxvQkFBb0JyNkIsT0FBTztRQUN2RCxJQUFJczZCLGFBQWFYLFdBQVczNUIsVUFDMUJ3QixPQUFPODRCLFdBQVc5NEIsSUFBSSxFQUN0QjJYLFNBQVNtaEIsV0FBV25oQixNQUFNLEVBQzFCOUYsV0FBV2luQixXQUFXam5CLFFBQVEsRUFDOUJ1bUIsV0FBV1UsV0FBV1YsUUFBUTtRQUNoQ3A0QixPQUFPLElBQUksQ0FBQzJOLE1BQU0sQ0FBQzNOLEtBQUssQ0FBQyxFQUFFO1FBRTNCLHNEQUFzRDtRQUN0RCxJQUFJNlgsV0FBVyxJQUFJLENBQUNBLFFBQVEsQ0FBQztZQUMzQjdYLE1BQU1BO1lBQ04yWCxRQUFRQTtZQUNSOUYsVUFBVUE7UUFDWjtRQUNBLElBQUlrbkIsZ0JBQWdCO1FBQ3BCLElBQUl4bUIsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSyxJQUFJdGxCLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7WUFDckMsSUFBSXJDLElBQUkybkIsS0FBSyxDQUFDdGxCLEVBQUU7WUFDaEIsSUFBSSxDQUFDckMsRUFBRXdvQixJQUFJLENBQUNwVCxPQUFPO2dCQUNqQixJQUFJd1ksSUFBSVgsU0FBUzRCLFVBQVUsQ0FBQzd1QjtnQkFDNUIsSUFBSXd0QyxVQUFVO29CQUNaVyxpQkFBaUIsSUFBSXZnQjtnQkFDdkIsT0FBTztvQkFDTHVnQixpQkFBaUJ2Z0I7Z0JBQ25CO1lBQ0Y7UUFDRjtRQUNBLE9BQU80ZixXQUFXVyxnQkFBZ0IsSUFBSUE7SUFDeEMsRUFBRSxzQkFBc0I7QUFDMUIsR0FBRyxTQUFTO0FBRVosaUNBQWlDO0FBQ2pDVixTQUFTVyxFQUFFLEdBQUdYLFNBQVNRLG1CQUFtQjtBQUMxQ1IsU0FBU1ksR0FBRyxHQUFHWixTQUFTYSw2QkFBNkIsR0FBR2IsU0FBU0MsNkJBQTZCO0FBRTlGLElBQUlhLGFBQWExdEIsV0FBVztJQUMxQmtNLFFBQVE7SUFDUjlGLFVBQVU7QUFDWjtBQUNBLElBQUl1bkIsV0FBVztJQUNiLG1KQUFtSjtJQUNuSkMsdUJBQXVCLFNBQVNBLHNCQUFzQjc2QixPQUFPO1FBQzNELElBQUltTixZQUFZd3RCLFdBQVczNkIsVUFDekJxVCxXQUFXbEcsVUFBVWtHLFFBQVEsRUFDN0I4RixTQUFTaE0sVUFBVWdNLE1BQU07UUFDM0IsSUFBSTJoQixXQUFXM2hCLFVBQVU7UUFDekIsSUFBSTFKLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBRWhCLFdBQVc7UUFDWCxJQUFJa0UsSUFBSSxJQUFJLENBQUNJLEtBQUs7UUFDbEIsSUFBSTBILElBQUksQ0FBQztRQUNULElBQUlzZixLQUFLLENBQUM7UUFDVixJQUFJbDFCLE1BQU07UUFDVixJQUFJbTFCLElBQUk7WUFDTjdzQixLQUFLLFNBQVNBLElBQUkvZ0IsR0FBRyxFQUFFZ2hCLEdBQUc7Z0JBQ3hCMnNCLEVBQUUsQ0FBQzN0QyxJQUFJLEdBQUdnaEI7Z0JBQ1YsSUFBSUEsTUFBTXZJLEtBQUs7b0JBQ2JBLE1BQU11STtnQkFDUjtZQUNGO1lBQ0FJLEtBQUssU0FBU0EsSUFBSXBoQixHQUFHO2dCQUNuQixPQUFPMnRDLEVBQUUsQ0FBQzN0QyxJQUFJO1lBQ2hCO1FBQ0Y7UUFFQSw2Q0FBNkM7UUFDN0MsSUFBSyxJQUFJcUIsSUFBSSxHQUFHQSxJQUFJa2xCLEVBQUV6bkIsTUFBTSxFQUFFdUMsSUFBSztZQUNqQyxJQUFJNEUsSUFBSXNnQixDQUFDLENBQUNsbEIsRUFBRTtZQUNaLElBQUlxc0IsTUFBTXpuQixFQUFFNmdCLEVBQUU7WUFDZCxJQUFJYixVQUFVO2dCQUNab0ksQ0FBQyxDQUFDWCxJQUFJLEdBQUd6bkIsRUFBRTRuQyxRQUFRLEdBQUdsbkIsS0FBSyxJQUFJLDZCQUE2QjtZQUM5RCxPQUFPO2dCQUNMMEgsQ0FBQyxDQUFDWCxJQUFJLEdBQUd6bkIsRUFBRTZuQyxnQkFBZ0IsR0FBR25uQixLQUFLLElBQUksOEJBQThCO1lBQ3ZFO1lBQ0FpbkIsRUFBRTdzQixHQUFHLENBQUMyTSxLQUFLO1FBQ2I7UUFDQSxJQUFJMUcsUUFBUSxTQUFTQTtZQUNuQixJQUFJa0ksTUFBTTNJLENBQUMsQ0FBQy9sQixFQUFFLENBQUNzbUIsRUFBRTtZQUNqQixJQUFJaUgsSUFBSSxFQUFFLEVBQUUsUUFBUTtZQUNwQixJQUFJZ2dCLElBQUksQ0FBQztZQUNULElBQUlqbUMsSUFBSSxDQUFDO1lBQ1QsSUFBSThrQixJQUFJLENBQUM7WUFDVCxJQUFJekcsSUFBSSxJQUFJeUMsS0FBSyxTQUFVL3BCLENBQUMsRUFBRXNJLENBQUM7Z0JBQzdCLE9BQU95bEIsQ0FBQyxDQUFDL3RCLEVBQUUsR0FBRyt0QixDQUFDLENBQUN6bEIsRUFBRTtZQUNwQixJQUFJLFFBQVE7WUFFWixvQkFBb0I7WUFDcEIsSUFBSyxJQUFJNGdCLEtBQUssR0FBR0EsS0FBS3hCLEVBQUV6bkIsTUFBTSxFQUFFaXBCLEtBQU07Z0JBQ3BDLElBQUlpbUIsT0FBT3puQixDQUFDLENBQUN3QixHQUFHLENBQUNqQixFQUFFO2dCQUNuQmluQixDQUFDLENBQUNDLEtBQUssR0FBRyxFQUFFO2dCQUNabG1DLENBQUMsQ0FBQ2ttQyxLQUFLLEdBQUc7Z0JBQ1ZwaEIsQ0FBQyxDQUFDb2hCLEtBQUssR0FBR25oQjtZQUNaO1lBQ0Eva0IsQ0FBQyxDQUFDb25CLElBQUksR0FBRyxHQUFHLFFBQVE7WUFDcEJ0QyxDQUFDLENBQUNzQyxJQUFJLEdBQUcsR0FBRyxnQkFBZ0I7WUFFNUIvSSxFQUFFN2tCLElBQUksQ0FBQzR0QjtZQUNQLE1BQU8sQ0FBQy9JLEVBQUVrRixLQUFLLEdBQUk7Z0JBQ2pCLElBQUk0aUIsS0FBSzluQixFQUFFZSxHQUFHO2dCQUNkNkcsRUFBRXpzQixJQUFJLENBQUMyc0M7Z0JBQ1AsSUFBSVAsVUFBVTtvQkFDWixJQUFLLElBQUlobUMsSUFBSSxHQUFHQSxJQUFJMm1CLENBQUMsQ0FBQzRmLEdBQUcsQ0FBQ252QyxNQUFNLEVBQUU0SSxJQUFLO3dCQUNyQyxJQUFJcVcsSUFBSXNRLENBQUMsQ0FBQzRmLEdBQUcsQ0FBQ3ZtQyxFQUFFO3dCQUNoQixJQUFJd21DLE9BQU83ckIsR0FBRzhyQixjQUFjLENBQUNGO3dCQUM3QixJQUFJaG1CLE9BQU9wbUI7d0JBQ1gsSUFBSXFzQyxLQUFLbGhCLE9BQU8sQ0FBQ2pQLEdBQUdqZixNQUFNLEdBQUcsR0FBRzs0QkFDOUJtcEIsT0FBT2ltQixLQUFLbGhCLE9BQU8sQ0FBQ2pQLEVBQUUsQ0FBQyxFQUFFO3dCQUMzQixPQUFPOzRCQUNMa0ssT0FBT2xLLEVBQUVpUCxPQUFPLENBQUNraEIsS0FBSyxDQUFDLEVBQUU7d0JBQzNCO3dCQUNBLElBQUlFLGFBQWFyaUIsT0FBTzlEO3dCQUN4QmxLLElBQUlBLEVBQUUrSSxFQUFFO3dCQUNSLElBQUk4RixDQUFDLENBQUM3TyxFQUFFLEdBQUc2TyxDQUFDLENBQUNxaEIsR0FBRyxHQUFHRyxZQUFZOzRCQUM3QnhoQixDQUFDLENBQUM3TyxFQUFFLEdBQUc2TyxDQUFDLENBQUNxaEIsR0FBRyxHQUFHRzs0QkFDZixJQUFJam9CLEVBQUVRLEtBQUssQ0FBQzZELE9BQU8sQ0FBQ3pNLEtBQUssR0FBRztnQ0FDMUIsa0JBQWtCO2dDQUNsQm9JLEVBQUU3a0IsSUFBSSxDQUFDeWM7NEJBQ1QsT0FBTztnQ0FDTCwrQkFBK0I7Z0NBQy9Cb0ksRUFBRW1ELFVBQVUsQ0FBQ3ZMOzRCQUNmOzRCQUNBalcsQ0FBQyxDQUFDaVcsRUFBRSxHQUFHOzRCQUNQZ3dCLENBQUMsQ0FBQ2h3QixFQUFFLEdBQUcsRUFBRTt3QkFDWDt3QkFDQSxJQUFJNk8sQ0FBQyxDQUFDN08sRUFBRSxJQUFJNk8sQ0FBQyxDQUFDcWhCLEdBQUcsR0FBR0csWUFBWTs0QkFDOUJ0bUMsQ0FBQyxDQUFDaVcsRUFBRSxHQUFHalcsQ0FBQyxDQUFDaVcsRUFBRSxHQUFHalcsQ0FBQyxDQUFDbW1DLEdBQUc7NEJBQ25CRixDQUFDLENBQUNod0IsRUFBRSxDQUFDemMsSUFBSSxDQUFDMnNDO3dCQUNaO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wsSUFBSyxJQUFJM2pCLEtBQUssR0FBR0EsS0FBSytELENBQUMsQ0FBQzRmLEdBQUcsQ0FBQ252QyxNQUFNLEVBQUV3ckIsS0FBTTt3QkFDeEMsSUFBSStqQixLQUFLaGdCLENBQUMsQ0FBQzRmLEdBQUcsQ0FBQzNqQixHQUFHLENBQUN4RCxFQUFFO3dCQUNyQixJQUFJOEYsQ0FBQyxDQUFDeWhCLEdBQUcsSUFBSXhoQixVQUFVOzRCQUNyQjFHLEVBQUU3a0IsSUFBSSxDQUFDK3NDOzRCQUNQemhCLENBQUMsQ0FBQ3loQixHQUFHLEdBQUd6aEIsQ0FBQyxDQUFDcWhCLEdBQUcsR0FBRzt3QkFDbEI7d0JBQ0EsSUFBSXJoQixDQUFDLENBQUN5aEIsR0FBRyxJQUFJemhCLENBQUMsQ0FBQ3FoQixHQUFHLEdBQUcsR0FBRzs0QkFDdEJubUMsQ0FBQyxDQUFDdW1DLEdBQUcsR0FBR3ZtQyxDQUFDLENBQUN1bUMsR0FBRyxHQUFHdm1DLENBQUMsQ0FBQ21tQyxHQUFHOzRCQUNyQkYsQ0FBQyxDQUFDTSxHQUFHLENBQUMvc0MsSUFBSSxDQUFDMnNDO3dCQUNiO29CQUNGO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJbHZDLElBQUksQ0FBQztZQUNULElBQUssSUFBSTRvQixNQUFNLEdBQUdBLE1BQU1wQixFQUFFem5CLE1BQU0sRUFBRTZvQixNQUFPO2dCQUN2QzVvQixDQUFDLENBQUN3bkIsQ0FBQyxDQUFDb0IsSUFBSSxDQUFDYixFQUFFLEdBQUcsR0FBRztZQUNuQjtZQUNBLE1BQU9pSCxFQUFFanZCLE1BQU0sR0FBRyxFQUFHO2dCQUNuQixJQUFJd3ZDLE1BQU12Z0IsRUFBRTdHLEdBQUc7Z0JBQ2YsSUFBSyxJQUFJb2pCLE1BQU0sR0FBR0EsTUFBTXlELENBQUMsQ0FBQ08sSUFBSSxDQUFDeHZDLE1BQU0sRUFBRXdyQyxNQUFPO29CQUM1QyxJQUFJaUUsTUFBTVIsQ0FBQyxDQUFDTyxJQUFJLENBQUNoRSxJQUFJO29CQUNyQnZyQyxDQUFDLENBQUN3dkMsSUFBSSxHQUFHeHZDLENBQUMsQ0FBQ3d2QyxJQUFJLEdBQUd6bUMsQ0FBQyxDQUFDeW1DLElBQUksR0FBR3ptQyxDQUFDLENBQUN3bUMsSUFBSSxHQUFJLEtBQUl2dkMsQ0FBQyxDQUFDdXZDLElBQUk7Z0JBQ2pEO2dCQUNBLElBQUlBLE9BQU8vbkIsQ0FBQyxDQUFDL2xCLEVBQUUsQ0FBQ3NtQixFQUFFLElBQUk7b0JBQ3BCOG1CLEVBQUU3c0IsR0FBRyxDQUFDdXRCLEtBQUtWLEVBQUV4c0IsR0FBRyxDQUFDa3RCLE9BQU92dkMsQ0FBQyxDQUFDdXZDLElBQUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUNBLElBQUssSUFBSTl0QyxJQUFJLEdBQUdBLElBQUkrbEIsRUFBRXpuQixNQUFNLEVBQUUwQixJQUFLO1lBQ2pDd21CO1FBQ0Y7UUFDQSxJQUFJdGhCLE1BQU07WUFDUjhvQyxhQUFhLFNBQVNBLFlBQVl4bUIsSUFBSTtnQkFDcEMsSUFBSWxCLEtBQUt6RSxHQUFHcmUsVUFBVSxDQUFDZ2tCLE1BQU1sQixFQUFFO2dCQUMvQixPQUFPOG1CLEVBQUV4c0IsR0FBRyxDQUFDMEY7WUFDZjtZQUNBMm5CLHVCQUF1QixTQUFTQSxzQkFBc0J6bUIsSUFBSTtnQkFDeEQsSUFBSXZQLE9BQU8sR0FBRztvQkFDWixPQUFPO2dCQUNUO2dCQUNBLElBQUlxTyxLQUFLekUsR0FBR3JlLFVBQVUsQ0FBQ2drQixNQUFNbEIsRUFBRTtnQkFDL0IsT0FBTzhtQixFQUFFeHNCLEdBQUcsQ0FBQzBGLE1BQU1yTztZQUNyQjtRQUNGO1FBRUEsUUFBUTtRQUNSL1MsSUFBSWdwQyxxQkFBcUIsR0FBR2hwQyxJQUFJK29DLHFCQUFxQjtRQUNyRCxPQUFPL29DO0lBQ1QsRUFBRSx3QkFBd0I7QUFDNUIsR0FBRyxTQUFTO0FBRVosaUNBQWlDO0FBQ2pDOG5DLFNBQVNtQixFQUFFLEdBQUduQixTQUFTQyxxQkFBcUI7QUFFNUMsNkNBQTZDO0FBQzdDLDJEQUEyRDtBQUczRCxpQ0FBaUMsR0FDakMsSUFBSW1CLGFBQWEvdUIsV0FBVztJQUMxQmd2QixjQUFjO0lBQ2QsNEVBQTRFO0lBQzVFQyxlQUFlO0lBQ2Ysd0ZBQXdGO0lBQ3hGQyxZQUFZO0lBQ1osMEZBQTBGO0lBQzFGQyxlQUFlO0lBQ2Ysb0VBQW9FO0lBQ3BFQyxZQUFZO1FBQ1osK0VBQStFO1FBQy9FLFNBQVVobkIsSUFBSTtZQUNaLE9BQU87UUFDVDtLQUFFO0FBQ0o7QUFDQSxpQkFBaUIsR0FFakIsSUFBSWluQixlQUFlLFNBQVNDLFdBQVd2OEIsT0FBTztJQUM1QyxPQUFPZzhCLFdBQVdoOEI7QUFDcEI7QUFDQSxpQkFBaUIsR0FFakIsSUFBSXc4QixrQkFBa0IsU0FBU0MsY0FBY3BuQixJQUFJLEVBQUVnbkIsVUFBVTtJQUMzRCxJQUFJdlgsUUFBUTtJQUNaLElBQUssSUFBSXIyQixJQUFJLEdBQUdBLElBQUk0dEMsV0FBV253QyxNQUFNLEVBQUV1QyxJQUFLO1FBQzFDcTJCLFNBQVN1WCxVQUFVLENBQUM1dEMsRUFBRSxDQUFDNG1CO0lBQ3pCO0lBQ0EsT0FBT3lQO0FBQ1Q7QUFDQSxJQUFJNFgsV0FBVyxTQUFTQSxTQUFTQyxDQUFDLEVBQUV2d0MsQ0FBQyxFQUFFZ2lCLEdBQUc7SUFDeEMsSUFBSyxJQUFJM2YsSUFBSSxHQUFHQSxJQUFJckMsR0FBR3FDLElBQUs7UUFDMUJrdUMsQ0FBQyxDQUFDbHVDLElBQUlyQyxJQUFJcUMsRUFBRSxHQUFHMmY7SUFDakI7QUFDRjtBQUNBLElBQUlnYSxZQUFZLFNBQVNBLFVBQVV1VSxDQUFDLEVBQUV2d0MsQ0FBQztJQUNyQyxJQUFJd3dDO0lBQ0osSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU16d0MsR0FBR3l3QyxNQUFPO1FBQ2hDRCxNQUFNO1FBQ04sSUFBSyxJQUFJRSxNQUFNLEdBQUdBLE1BQU0xd0MsR0FBRzB3QyxNQUFPO1lBQ2hDRixPQUFPRCxDQUFDLENBQUNHLE1BQU0xd0MsSUFBSXl3QyxJQUFJO1FBQ3pCO1FBQ0EsSUFBSyxJQUFJRSxPQUFPLEdBQUdBLE9BQU8zd0MsR0FBRzJ3QyxPQUFRO1lBQ25DSixDQUFDLENBQUNJLE9BQU8zd0MsSUFBSXl3QyxJQUFJLEdBQUdGLENBQUMsQ0FBQ0ksT0FBTzN3QyxJQUFJeXdDLElBQUksR0FBR0Q7UUFDMUM7SUFDRjtBQUNGO0FBRUEsdUNBQXVDO0FBQ3ZDLElBQUlJLFFBQVEsU0FBU0EsTUFBTXZoQixDQUFDLEVBQUV3aEIsQ0FBQyxFQUFFN3dDLENBQUM7SUFDaEMsSUFBSTR1QyxJQUFJLElBQUkzdUMsTUFBTUQsSUFBSUE7SUFDdEIsSUFBSyxJQUFJcUMsSUFBSSxHQUFHQSxJQUFJckMsR0FBR3FDLElBQUs7UUFDMUIsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxJQUFJMUksR0FBRzBJLElBQUs7WUFDMUJrbUMsQ0FBQyxDQUFDdnNDLElBQUlyQyxJQUFJMEksRUFBRSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSyxJQUFJL0IsSUFBSSxHQUFHQSxJQUFJM0csR0FBRzJHLElBQUs7WUFDMUIsSUFBSyxJQUFJMmtCLEtBQUssR0FBR0EsS0FBS3RyQixHQUFHc3JCLEtBQU07Z0JBQzdCc2pCLENBQUMsQ0FBQ3ZzQyxJQUFJckMsSUFBSXNyQixHQUFHLElBQUkrRCxDQUFDLENBQUNodEIsSUFBSXJDLElBQUkyRyxFQUFFLEdBQUdrcUMsQ0FBQyxDQUFDbHFDLElBQUkzRyxJQUFJc3JCLEdBQUc7WUFDL0M7UUFDRjtJQUNGO0lBQ0EsT0FBT3NqQjtBQUNUO0FBQ0EsSUFBSWtDLFNBQVMsU0FBU0EsT0FBT1AsQ0FBQyxFQUFFdndDLENBQUMsRUFBRTZ2QyxhQUFhLFdBQVcsR0FBWjtJQUM3QyxJQUFJa0IsS0FBS1IsRUFBRXJ0QyxLQUFLLENBQUM7SUFDakIsSUFBSyxJQUFJbUcsSUFBSSxHQUFHQSxJQUFJd21DLGNBQWN4bUMsSUFBSztRQUNyQ2tuQyxJQUFJSyxNQUFNTCxHQUFHUSxJQUFJL3dDO0lBQ25CO0lBQ0EsT0FBT3V3QztBQUNUO0FBQ0EsSUFBSVMsVUFBVSxTQUFTQSxRQUFRVCxDQUFDLEVBQUV2d0MsQ0FBQyxFQUFFOHZDLGNBQWMsT0FBTyxHQUFSO0lBQ2hELElBQUlpQixLQUFLLElBQUk5d0MsTUFBTUQsSUFBSUE7SUFFdkIsd0JBQXdCO0lBQ3hCLElBQUssSUFBSXFDLElBQUksR0FBR0EsSUFBSXJDLElBQUlBLEdBQUdxQyxJQUFLO1FBQzlCMHVDLEVBQUUsQ0FBQzF1QyxFQUFFLEdBQUd1QyxLQUFLNnhCLEdBQUcsQ0FBQzhaLENBQUMsQ0FBQ2x1QyxFQUFFLEVBQUV5dEM7SUFDekI7SUFDQTlULFVBQVUrVSxJQUFJL3dDO0lBQ2QsT0FBTyt3QztBQUNUO0FBQ0EsSUFBSUUsZUFBZSxTQUFTQSxhQUFhVixDQUFDLEVBQUVRLEVBQUUsRUFBRUcsRUFBRSxFQUFFQyxXQUFXO0lBQzdELHdEQUF3RDtJQUN4RCxJQUFLLElBQUk5dUMsSUFBSSxHQUFHQSxJQUFJNnVDLElBQUk3dUMsSUFBSztRQUMzQixJQUFJK3VDLEtBQUt4c0MsS0FBSytFLEtBQUssQ0FBQzRtQyxDQUFDLENBQUNsdUMsRUFBRSxHQUFHdUMsS0FBSzZ4QixHQUFHLENBQUMsSUFBSTBhLGdCQUFnQnZzQyxLQUFLNnhCLEdBQUcsQ0FBQyxJQUFJMGEsY0FBYywyQ0FBMkM7UUFDOUgsSUFBSUUsS0FBS3pzQyxLQUFLK0UsS0FBSyxDQUFDb25DLEVBQUUsQ0FBQzF1QyxFQUFFLEdBQUd1QyxLQUFLNnhCLEdBQUcsQ0FBQyxJQUFJMGEsZ0JBQWdCdnNDLEtBQUs2eEIsR0FBRyxDQUFDLElBQUkwYTtRQUN0RSxJQUFJQyxPQUFPQyxJQUFJO1lBQ2IsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxJQUFJQyxXQUFXLFNBQVNocEMsT0FBT2lvQyxDQUFDLEVBQUV2d0MsQ0FBQyxFQUFFMm5CLEtBQUssRUFBRXRFLEVBQUU7SUFDNUMsSUFBSWt1QixXQUFXLEVBQUU7SUFDakIsSUFBSyxJQUFJbHZDLElBQUksR0FBR0EsSUFBSXJDLEdBQUdxQyxJQUFLO1FBQzFCLElBQUltdkMsVUFBVSxFQUFFO1FBQ2hCLElBQUssSUFBSTlvQyxJQUFJLEdBQUdBLElBQUkxSSxHQUFHMEksSUFBSztZQUMxQiw0RUFBNEU7WUFDNUUsSUFBSTlELEtBQUsrRSxLQUFLLENBQUM0bUMsQ0FBQyxDQUFDbHVDLElBQUlyQyxJQUFJMEksRUFBRSxHQUFHLFFBQVEsT0FBTyxHQUFHO2dCQUM5QzhvQyxRQUFRbHZDLElBQUksQ0FBQ3FsQixLQUFLLENBQUNqZixFQUFFO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJOG9DLFFBQVExeEMsTUFBTSxLQUFLLEdBQUc7WUFDeEJ5eEMsU0FBU2p2QyxJQUFJLENBQUMrZ0IsR0FBR3JlLFVBQVUsQ0FBQ3dzQztRQUM5QjtJQUNGO0lBQ0EsT0FBT0Q7QUFDVDtBQUNBLElBQUlFLGNBQWMsU0FBU0EsWUFBWUMsRUFBRSxFQUFFQyxFQUFFO0lBQzNDLElBQUssSUFBSXR2QyxJQUFJLEdBQUdBLElBQUlxdkMsR0FBRzV4QyxNQUFNLEVBQUV1QyxJQUFLO1FBQ2xDLElBQUksQ0FBQ3N2QyxFQUFFLENBQUN0dkMsRUFBRSxJQUFJcXZDLEVBQUUsQ0FBQ3J2QyxFQUFFLENBQUN5bEIsRUFBRSxPQUFPNnBCLEVBQUUsQ0FBQ3R2QyxFQUFFLENBQUN5bEIsRUFBRSxJQUFJO1lBQ3ZDLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsSUFBSThwQixtQkFBbUIsU0FBU0EsaUJBQWlCTCxRQUFRO0lBQ3ZELElBQUssSUFBSWx2QyxJQUFJLEdBQUdBLElBQUlrdkMsU0FBU3p4QyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3hDLElBQUssSUFBSXFHLElBQUksR0FBR0EsSUFBSTZvQyxTQUFTenhDLE1BQU0sRUFBRTRJLElBQUs7WUFDeEMsSUFBSXJHLEtBQUtxRyxLQUFLK29DLFlBQVlGLFFBQVEsQ0FBQ2x2QyxFQUFFLEVBQUVrdkMsUUFBUSxDQUFDN29DLEVBQUUsR0FBRztnQkFDbkQ2b0MsU0FBU2p3QixNQUFNLENBQUM1WSxHQUFHO1lBQ3JCO1FBQ0Y7SUFDRjtJQUNBLE9BQU82b0M7QUFDVDtBQUNBLElBQUlNLG1CQUFtQixTQUFTQSxpQkFBaUJqK0IsT0FBTztJQUN0RCxJQUFJK1QsUUFBUSxJQUFJLENBQUNBLEtBQUs7SUFDdEIsSUFBSXRDLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBQ3RCLElBQUloQyxLQUFLLElBQUksQ0FBQ0EsRUFBRTtJQUVoQiwrQkFBK0I7SUFDL0IsSUFBSXJDLE9BQU9rdkIsYUFBYXQ4QjtJQUV4Qiw4Q0FBOEM7SUFDOUMsSUFBSWsrQixjQUFjLENBQUM7SUFDbkIsSUFBSyxJQUFJenZDLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7UUFDckN5dkMsV0FBVyxDQUFDbnFCLEtBQUssQ0FBQ3RsQixFQUFFLENBQUN5bEIsRUFBRSxHQUFHLEdBQUd6bEI7SUFDL0I7SUFFQSxtRkFBbUY7SUFDbkYsSUFBSXJDLElBQUkybkIsTUFBTTduQixNQUFNLEVBQ2xCb3hDLEtBQUtseEMsSUFBSUE7SUFDWCxJQUFJdXdDLElBQUksSUFBSXR3QyxNQUFNaXhDLEtBQ2hCSDtJQUNGLElBQUssSUFBSWhvQixLQUFLLEdBQUdBLEtBQUttb0IsSUFBSW5vQixLQUFNO1FBQzlCd25CLENBQUMsQ0FBQ3huQixHQUFHLEdBQUc7SUFDVjtJQUNBLElBQUssSUFBSWhwQixJQUFJLEdBQUdBLElBQUlzbEIsTUFBTXZsQixNQUFNLEVBQUVDLElBQUs7UUFDckMsSUFBSWtwQixPQUFPNUQsS0FBSyxDQUFDdGxCLEVBQUU7UUFDbkIsSUFBSTRvQixNQUFNbXBCLFdBQVcsQ0FBQzdvQixLQUFLdkYsTUFBTSxHQUFHb0UsRUFBRSxHQUFHO1FBQ3pDLElBQUlwZixJQUFJb3BDLFdBQVcsQ0FBQzdvQixLQUFLdEYsTUFBTSxHQUFHbUUsRUFBRSxHQUFHO1FBQ3ZDLElBQUlpcUIsTUFBTTNCLGdCQUFnQm5uQixNQUFNakksS0FBS2l2QixVQUFVO1FBQy9DTSxDQUFDLENBQUM1bkIsTUFBTTNvQixJQUFJMEksRUFBRSxJQUFJcXBDLEtBQUssdUNBQXVDO1FBQzlEeEIsQ0FBQyxDQUFDN25DLElBQUkxSSxJQUFJMm9CLElBQUksSUFBSW9wQjtJQUNwQjtJQUVBLGlDQUFpQztJQUVqQyw2RUFBNkU7SUFDN0V6QixTQUFTQyxHQUFHdndDLEdBQUdnaEIsS0FBSyt1QixVQUFVO0lBRTlCLDhCQUE4QjtJQUM5Qi9ULFVBQVV1VSxHQUFHdndDO0lBQ2IsSUFBSWd5QyxnQkFBZ0I7SUFDcEIsSUFBSTNILGFBQWE7SUFDakIsTUFBTzJILGlCQUFpQjNILGFBQWFycEIsS0FBS2d2QixhQUFhLENBQUU7UUFDdkRnQyxnQkFBZ0I7UUFFaEIsVUFBVTtRQUNWakIsS0FBS0QsT0FBT1AsR0FBR3Z3QyxHQUFHZ2hCLEtBQUs2dUIsWUFBWTtRQUVuQyxVQUFVO1FBQ1ZVLElBQUlTLFFBQVFELElBQUkvd0MsR0FBR2doQixLQUFLOHVCLGFBQWE7UUFFckMseURBQXlEO1FBQ3pELElBQUksQ0FBQ21CLGFBQWFWLEdBQUdRLElBQUlHLElBQUksSUFBSTtZQUMvQmMsZ0JBQWdCO1FBQ2xCO1FBQ0EzSDtJQUNGO0lBRUEsNkJBQTZCO0lBQzdCLElBQUlrSCxXQUFXRCxTQUFTZixHQUFHdndDLEdBQUcybkIsT0FBT3RFO0lBRXJDLGtFQUFrRTtJQUNsRWt1QixXQUFXSyxpQkFBaUJMO0lBQzVCLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJVSxxQkFBcUI7SUFDdkJKLGtCQUFrQkE7SUFDbEJLLEtBQUtMO0FBQ1A7QUFFQSxvREFBb0Q7QUFDcEQsK0RBQStEO0FBRS9ELElBQUlNLGFBQWEsU0FBU0MsU0FBU2grQixDQUFDO0lBQ2xDLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJaStCLFVBQVUsU0FBU0EsUUFBUWhwQyxDQUFDLEVBQUVDLENBQUM7SUFDakMsT0FBTzFFLEtBQUsyM0IsR0FBRyxDQUFDanpCLElBQUlEO0FBQ3RCO0FBQ0EsSUFBSWlwQyxhQUFhLFNBQVNBLFdBQVc1WixLQUFLLEVBQUVydkIsQ0FBQyxFQUFFQyxDQUFDO0lBQzlDLE9BQU9vdkIsUUFBUTJaLFFBQVFocEMsR0FBR0M7QUFDNUI7QUFDQSxJQUFJaXBDLGlCQUFpQixTQUFTQSxlQUFlN1osS0FBSyxFQUFFcnZCLENBQUMsRUFBRUMsQ0FBQztJQUN0RCxPQUFPb3ZCLFFBQVE5ekIsS0FBSzZ4QixHQUFHLENBQUNudEIsSUFBSUQsR0FBRztBQUNqQztBQUNBLElBQUlrc0IsT0FBTyxTQUFTQSxLQUFLbmhCLENBQUM7SUFDeEIsT0FBT3hQLEtBQUsyd0IsSUFBSSxDQUFDbmhCO0FBQ25CO0FBQ0EsSUFBSW8rQixhQUFhLFNBQVNBLFdBQVdDLFVBQVUsRUFBRXBwQyxDQUFDLEVBQUVDLENBQUM7SUFDbkQsT0FBTzFFLEtBQUs2VSxHQUFHLENBQUNnNUIsWUFBWUosUUFBUWhwQyxHQUFHQztBQUN6QztBQUNBLElBQUlvcEMsY0FBYyxTQUFTQSxZQUFZNXlDLE1BQU0sRUFBRTZ5QyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFM3JCLEtBQUs7SUFDcEUsSUFBSTRyQixPQUFPMXNDLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRytyQztJQUMvRSxJQUFJenJDLE1BQU1tc0M7SUFDVixJQUFJeHBDLEdBQUdDO0lBQ1AsSUFBSyxJQUFJeXBDLE1BQU0sR0FBR0EsTUFBTWp6QyxRQUFRaXpDLE1BQU87UUFDckMxcEMsSUFBSXNwQyxLQUFLSTtRQUNUenBDLElBQUlzcEMsS0FBS0c7UUFDVHJzQyxNQUFNd2dCLE1BQU14Z0IsS0FBSzJDLEdBQUdDO0lBQ3RCO0lBQ0EsT0FBT3dwQyxLQUFLcHNDO0FBQ2Q7QUFDQSxJQUFJc3NDLFlBQVk7SUFDZEMsV0FBVyxTQUFTQSxVQUFVbnpDLE1BQU0sRUFBRTZ5QyxJQUFJLEVBQUVDLElBQUk7UUFDOUMsSUFBSTl5QyxVQUFVLEdBQUc7WUFDZixPQUFPNHlDLFlBQVk1eUMsUUFBUTZ5QyxNQUFNQyxNQUFNLEdBQUdMLGdCQUFnQmhkO1FBQzVELE9BQU87WUFDTCxxREFBcUQ7WUFDckQsT0FBT21kLFlBQVk1eUMsUUFBUTZ5QyxNQUFNQyxNQUFNLEdBQUdOO1FBQzVDO0lBQ0Y7SUFDQVksa0JBQWtCLFNBQVNBLGlCQUFpQnB6QyxNQUFNLEVBQUU2eUMsSUFBSSxFQUFFQyxJQUFJO1FBQzVELE9BQU9GLFlBQVk1eUMsUUFBUTZ5QyxNQUFNQyxNQUFNLEdBQUdMO0lBQzVDO0lBQ0FZLFdBQVcsU0FBU0EsVUFBVXJ6QyxNQUFNLEVBQUU2eUMsSUFBSSxFQUFFQyxJQUFJO1FBQzlDLE9BQU9GLFlBQVk1eUMsUUFBUTZ5QyxNQUFNQyxNQUFNLEdBQUdOO0lBQzVDO0lBQ0E3NEIsS0FBSyxTQUFTQSxJQUFJM1osTUFBTSxFQUFFNnlDLElBQUksRUFBRUMsSUFBSTtRQUNsQyxPQUFPRixZQUFZNXlDLFFBQVE2eUMsTUFBTUMsTUFBTSxDQUFDL2tCLFVBQVUya0I7SUFDcEQ7QUFDRjtBQUVBLHVEQUF1RDtBQUN2RFEsU0FBUyxDQUFDLG9CQUFvQixHQUFHQSxTQUFTLENBQUMsbUJBQW1CO0FBQzlEQSxTQUFTLENBQUMsbUJBQW1CLEdBQUdBLFNBQVMsQ0FBQyxtQkFBbUI7QUFDN0QsU0FBU0ksbUJBQW9CQyxNQUFNLEVBQUV2ekMsTUFBTSxFQUFFNnlDLElBQUksRUFBRUMsSUFBSSxFQUFFVSxLQUFLLEVBQUVDLEtBQUs7SUFDbkUsSUFBSUM7SUFDSixJQUFJdnZDLEtBQUtvdkMsU0FBUztRQUNoQkcsT0FBT0g7SUFDVCxPQUFPO1FBQ0xHLE9BQU9SLFNBQVMsQ0FBQ0ssT0FBTyxJQUFJTCxVQUFVQyxTQUFTO0lBQ2pEO0lBQ0EsSUFBSW56QyxXQUFXLEtBQUttRSxLQUFLb3ZDLFNBQVM7UUFDaEMsT0FBT0csS0FBS0YsT0FBT0M7SUFDckIsT0FBTztRQUNMLE9BQU9DLEtBQUsxekMsUUFBUTZ5QyxNQUFNQyxNQUFNVSxPQUFPQztJQUN6QztBQUNGO0FBRUEsSUFBSUUsYUFBYTV5QixXQUFXO0lBQzFCbGEsR0FBRztJQUNINEMsR0FBRztJQUNIbXFDLHNCQUFzQjtJQUN0QnRpQixVQUFVO0lBQ1Y0ZSxlQUFlO0lBQ2ZDLFlBQVksRUFBRTtJQUNkMEQsVUFBVTtJQUNWQyxlQUFlO0FBQ2pCO0FBQ0EsSUFBSUMsZUFBZSxTQUFTMUQsV0FBV3Y4QixPQUFPO0lBQzVDLE9BQU82L0IsV0FBVzcvQjtBQUNwQjtBQUVBLElBQUk4WixVQUFVLFNBQVNBLFFBQVEvWSxJQUFJLEVBQUVxVSxJQUFJLEVBQUU4cUIsUUFBUSxFQUFFN0QsVUFBVSxFQUFFOEQsSUFBSTtJQUNuRSxJQUFJQyxVQUFVRCxTQUFTO0lBQ3ZCLElBQUlwQixPQUFPcUIsVUFBVSxTQUFVM3hDLENBQUM7UUFDOUIsT0FBT3l4QyxRQUFRLENBQUN6eEMsRUFBRTtJQUNwQixJQUFJLFNBQVVBLENBQUM7UUFDYixPQUFPNHRDLFVBQVUsQ0FBQzV0QyxFQUFFLENBQUN5eEM7SUFDdkI7SUFDQSxJQUFJbEIsT0FBTyxTQUFTQSxLQUFLdndDLENBQUM7UUFDeEIsT0FBTzR0QyxVQUFVLENBQUM1dEMsRUFBRSxDQUFDMm1CO0lBQ3ZCO0lBQ0EsSUFBSXNxQixRQUFRUTtJQUNaLElBQUlQLFFBQVF2cUI7SUFDWixPQUFPb3FCLG1CQUFtQnorQixNQUFNczdCLFdBQVdud0MsTUFBTSxFQUFFNnlDLE1BQU1DLE1BQU1VLE9BQU9DO0FBQ3hFO0FBQ0EsSUFBSVUsa0JBQWtCLFNBQVNBLGdCQUFnQnRzQixLQUFLLEVBQUVoaEIsQ0FBQyxFQUFFc3BDLFVBQVU7SUFDakUsSUFBSWlFLE9BQU9qRSxXQUFXbndDLE1BQU07SUFDNUIsSUFBSTZaLE1BQU0sSUFBSTFaLE1BQU1pMEM7SUFDcEIsSUFBSXo2QixNQUFNLElBQUl4WixNQUFNaTBDO0lBQ3BCLElBQUlDLFlBQVksSUFBSWwwQyxNQUFNMEc7SUFDMUIsSUFBSW10QyxXQUFXO0lBRWYsb0RBQW9EO0lBQ3BELElBQUssSUFBSXp4QyxJQUFJLEdBQUdBLElBQUk2eEMsTUFBTTd4QyxJQUFLO1FBQzdCc1gsR0FBRyxDQUFDdFgsRUFBRSxHQUFHc2xCLE1BQU1oTyxHQUFHLENBQUNzMkIsVUFBVSxDQUFDNXRDLEVBQUUsRUFBRVgsS0FBSztRQUN2QytYLEdBQUcsQ0FBQ3BYLEVBQUUsR0FBR3NsQixNQUFNbE8sR0FBRyxDQUFDdzJCLFVBQVUsQ0FBQzV0QyxFQUFFLEVBQUVYLEtBQUs7SUFDekM7SUFFQSxpRUFBaUU7SUFDakUsSUFBSyxJQUFJMHpCLElBQUksR0FBR0EsSUFBSXp1QixHQUFHeXVCLElBQUs7UUFDMUIwZSxXQUFXLEVBQUU7UUFDYixJQUFLLElBQUkvcUIsS0FBSyxHQUFHQSxLQUFLbXJCLE1BQU1uckIsS0FBTTtZQUNoQytxQixRQUFRLENBQUMvcUIsR0FBRyxHQUFHbmtCLEtBQUs4YixNQUFNLEtBQU1qSCxDQUFBQSxHQUFHLENBQUNzUCxHQUFHLEdBQUdwUCxHQUFHLENBQUNvUCxHQUFHLElBQUlwUCxHQUFHLENBQUNvUCxHQUFHLEVBQUUsdUJBQXVCO1FBQ3ZGO1FBQ0FvckIsU0FBUyxDQUFDL2UsRUFBRSxHQUFHMGU7SUFDakI7SUFDQSxPQUFPSztBQUNUO0FBQ0EsSUFBSUMsV0FBVyxTQUFTQSxTQUFTcHJCLElBQUksRUFBRW1yQixTQUFTLEVBQUUvaUIsUUFBUSxFQUFFNmUsVUFBVSxFQUFFdDdCLElBQUk7SUFDMUUsSUFBSWdGLE1BQU1rVTtJQUNWLElBQUk3WCxRQUFRO0lBQ1osSUFBSyxJQUFJM1QsSUFBSSxHQUFHQSxJQUFJOHhDLFVBQVVyMEMsTUFBTSxFQUFFdUMsSUFBSztRQUN6QyxJQUFJZ3JCLE9BQU9LLFFBQVEwRCxVQUFVcEksTUFBTW1yQixTQUFTLENBQUM5eEMsRUFBRSxFQUFFNHRDLFlBQVl0N0I7UUFDN0QsSUFBSTBZLE9BQU8xVCxLQUFLO1lBQ2RBLE1BQU0wVDtZQUNOclgsUUFBUTNUO1FBQ1Y7SUFDRjtJQUNBLE9BQU8yVDtBQUNUO0FBQ0EsSUFBSXErQixlQUFlLFNBQVNBLGFBQWFQLFFBQVEsRUFBRW5zQixLQUFLLEVBQUUyc0IsVUFBVTtJQUNsRSxJQUFJOUMsVUFBVSxFQUFFO0lBQ2hCLElBQUl4b0IsT0FBTztJQUNYLElBQUssSUFBSWhwQixJQUFJLEdBQUdBLElBQUkybkIsTUFBTTduQixNQUFNLEVBQUVFLElBQUs7UUFDckNncEIsT0FBT3JCLEtBQUssQ0FBQzNuQixFQUFFO1FBQ2YsSUFBSXMwQyxVQUFVLENBQUN0ckIsS0FBS2xCLEVBQUUsR0FBRyxLQUFLZ3NCLFVBQVU7WUFDdEMsMEVBQTBFO1lBQzFFdEMsUUFBUWx2QyxJQUFJLENBQUMwbUI7UUFDZjtJQUNGO0lBQ0EsT0FBT3dvQjtBQUNUO0FBQ0EsSUFBSStDLHNCQUFzQixTQUFTQSxvQkFBb0JuRCxFQUFFLEVBQUVDLEVBQUUsRUFBRXFDLG9CQUFvQjtJQUNqRixPQUFPOXVDLEtBQUsyM0IsR0FBRyxDQUFDOFUsS0FBS0QsT0FBT3NDO0FBQzlCO0FBQ0EsSUFBSWMsd0JBQXdCLFNBQVNBLHNCQUFzQnBELEVBQUUsRUFBRUMsRUFBRSxFQUFFcUMsb0JBQW9CO0lBQ3JGLElBQUssSUFBSXJ4QyxJQUFJLEdBQUdBLElBQUkrdUMsR0FBR3R4QyxNQUFNLEVBQUV1QyxJQUFLO1FBQ2xDLElBQUssSUFBSXFHLElBQUksR0FBR0EsSUFBSTBvQyxFQUFFLENBQUMvdUMsRUFBRSxDQUFDdkMsTUFBTSxFQUFFNEksSUFBSztZQUNyQyxJQUFJOGlDLE9BQU81bUMsS0FBSzIzQixHQUFHLENBQUM2VSxFQUFFLENBQUMvdUMsRUFBRSxDQUFDcUcsRUFBRSxHQUFHMm9DLEVBQUUsQ0FBQ2h2QyxFQUFFLENBQUNxRyxFQUFFO1lBQ3ZDLElBQUk4aUMsT0FBT2tJLHNCQUFzQjtnQkFDL0IsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLElBQUllLGFBQWEsU0FBU0EsV0FBV3pyQixJQUFJLEVBQUUwckIsT0FBTyxFQUFFMTBDLENBQUM7SUFDbkQsSUFBSyxJQUFJcUMsSUFBSSxHQUFHQSxJQUFJckMsR0FBR3FDLElBQUs7UUFDMUIsSUFBSTJtQixTQUFTMHJCLE9BQU8sQ0FBQ3J5QyxFQUFFLEVBQUUsT0FBTztJQUNsQztJQUNBLE9BQU87QUFDVDtBQUNBLElBQUlzeUMsZ0JBQWdCLFNBQVNBLGNBQWNodEIsS0FBSyxFQUFFaGhCLENBQUM7SUFDakQsSUFBSSt0QyxVQUFVLElBQUl6MEMsTUFBTTBHO0lBRXhCLHNFQUFzRTtJQUN0RSw4RUFBOEU7SUFDOUUsSUFBSWdoQixNQUFNN25CLE1BQU0sR0FBRyxJQUFJO1FBQ3JCLDZDQUE2QztRQUM3QyxJQUFLLElBQUl1QyxJQUFJLEdBQUdBLElBQUlzRSxHQUFHdEUsSUFBSztZQUMxQixJQUFJMm1CLE9BQU9yQixLQUFLLENBQUMvaUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLOGIsTUFBTSxLQUFLaUgsTUFBTTduQixNQUFNLEVBQUU7WUFFMUQsaUdBQWlHO1lBQ2pHLDBDQUEwQztZQUMxQyxNQUFPMjBDLFdBQVd6ckIsTUFBTTByQixTQUFTcnlDLEdBQUk7Z0JBQ25DMm1CLE9BQU9yQixLQUFLLENBQUMvaUIsS0FBS0MsS0FBSyxDQUFDRCxLQUFLOGIsTUFBTSxLQUFLaUgsTUFBTTduQixNQUFNLEVBQUU7WUFDeEQ7WUFDQTQwQyxPQUFPLENBQUNyeUMsRUFBRSxHQUFHMm1CO1FBQ2Y7SUFDRixPQUFPO1FBQ0wsc0ZBQXNGO1FBQ3RGLElBQUssSUFBSUwsTUFBTSxHQUFHQSxNQUFNaGlCLEdBQUdnaUIsTUFBTztZQUNoQytyQixPQUFPLENBQUMvckIsSUFBSSxHQUFHaEIsS0FBSyxDQUFDL2lCLEtBQUtDLEtBQUssQ0FBQ0QsS0FBSzhiLE1BQU0sS0FBS2lILE1BQU03bkIsTUFBTSxFQUFFO1FBQ2hFO0lBQ0Y7SUFDQSxPQUFPNDBDO0FBQ1Q7QUFDQSxJQUFJRSxXQUFXLFNBQVNBLFNBQVNDLGtCQUFrQixFQUFFckQsT0FBTyxFQUFFdkIsVUFBVTtJQUN0RSxJQUFJNkUsT0FBTztJQUNYLElBQUssSUFBSTkwQyxJQUFJLEdBQUdBLElBQUl3eEMsUUFBUTF4QyxNQUFNLEVBQUVFLElBQUs7UUFDdkM4MEMsUUFBUXBuQixRQUFRLGFBQWE4akIsT0FBTyxDQUFDeHhDLEVBQUUsRUFBRTYwQyxvQkFBb0I1RSxZQUFZO0lBQzNFO0lBQ0EsT0FBTzZFO0FBQ1Q7QUFDQSxJQUFJQyxTQUFTLFNBQVNBLE9BQU9uaEMsT0FBTztJQUNsQyxJQUFJeVAsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSXNFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBQ3RCLElBQUlxQixPQUFPO0lBRVgsb0VBQW9FO0lBQ3BFLElBQUloSSxPQUFPNnlCLGFBQWFqZ0M7SUFFeEIsMEJBQTBCO0lBQzFCLElBQUkyOUIsV0FBVyxJQUFJdHhDLE1BQU0rZ0IsS0FBS3JhLENBQUM7SUFDL0IsSUFBSTJ0QyxhQUFhLENBQUM7SUFDbEIsSUFBSUg7SUFFSix3Q0FBd0M7SUFDeEMsSUFBSW56QixLQUFLMnlCLFFBQVEsRUFBRTtRQUNqQixJQUFJLE9BQU8zeUIsS0FBSzR5QixhQUFhLEtBQUssVUFBVTtZQUMxQyxvREFBb0Q7WUFDcEQ1eUIsS0FBSzR5QixhQUFhO1lBQ2xCTyxZQUFZRixnQkFBZ0J0c0IsT0FBTzNHLEtBQUtyYSxDQUFDLEVBQUVxYSxLQUFLaXZCLFVBQVU7UUFDNUQsT0FBTyxJQUFJbHRDLFFBQVFpZSxLQUFLNHlCLGFBQWEsTUFBTSxVQUFVO1lBQ25ETyxZQUFZbnpCLEtBQUs0eUIsYUFBYTtRQUNoQyxPQUFPO1lBQ0xPLFlBQVlGLGdCQUFnQnRzQixPQUFPM0csS0FBS3JhLENBQUMsRUFBRXFhLEtBQUtpdkIsVUFBVTtRQUM1RDtJQUNGLE9BQU87UUFDTGtFLFlBQVlGLGdCQUFnQnRzQixPQUFPM0csS0FBS3JhLENBQUMsRUFBRXFhLEtBQUtpdkIsVUFBVTtJQUM1RDtJQUNBLElBQUkrQixnQkFBZ0I7SUFDcEIsSUFBSTNILGFBQWE7SUFDakIsTUFBTzJILGlCQUFpQjNILGFBQWFycEIsS0FBS2d2QixhQUFhLENBQUU7UUFDdkQsK0NBQStDO1FBQy9DLElBQUssSUFBSWh3QyxJQUFJLEdBQUdBLElBQUkybkIsTUFBTTduQixNQUFNLEVBQUVFLElBQUs7WUFDckNncEIsT0FBT3JCLEtBQUssQ0FBQzNuQixFQUFFO1lBQ2YscUVBQXFFO1lBQ3JFczBDLFVBQVUsQ0FBQ3RyQixLQUFLbEIsRUFBRSxHQUFHLEdBQUdzc0IsU0FBU3ByQixNQUFNbXJCLFdBQVduekIsS0FBS29RLFFBQVEsRUFBRXBRLEtBQUtpdkIsVUFBVSxFQUFFO1FBQ3BGO1FBRUEsMERBQTBEO1FBQzFEK0IsZ0JBQWdCO1FBQ2hCLElBQUssSUFBSTVjLElBQUksR0FBR0EsSUFBSXBVLEtBQUtyYSxDQUFDLEVBQUV5dUIsSUFBSztZQUMvQiw0Q0FBNEM7WUFDNUMsSUFBSW9jLFVBQVU2QyxhQUFhamYsR0FBR3pOLE9BQU8yc0I7WUFDckMsSUFBSTlDLFFBQVExeEMsTUFBTSxLQUFLLEdBQUc7Z0JBRXhCO1lBQ0Y7WUFFQSx1RUFBdUU7WUFDdkUsSUFBSW8wQyxPQUFPbHpCLEtBQUtpdkIsVUFBVSxDQUFDbndDLE1BQU07WUFDakMsSUFBSWcwQyxXQUFXSyxTQUFTLENBQUMvZSxFQUFFLEVBQUUsdUNBQXVDO1lBQ3BFLElBQUk0ZixjQUFjLElBQUkvMEMsTUFBTWkwQztZQUM1QixJQUFJMUQsTUFBTSxJQUFJdndDLE1BQU1pMEM7WUFDcEIsSUFBSyxJQUFJdG1CLElBQUksR0FBR0EsSUFBSXNtQixNQUFNdG1CLElBQUs7Z0JBQzdCNGlCLEdBQUcsQ0FBQzVpQixFQUFFLEdBQUc7Z0JBQ1QsSUFBSyxJQUFJdnJCLElBQUksR0FBR0EsSUFBSW12QyxRQUFRMXhDLE1BQU0sRUFBRXVDLElBQUs7b0JBQ3ZDMm1CLE9BQU93b0IsT0FBTyxDQUFDbnZDLEVBQUU7b0JBQ2pCbXVDLEdBQUcsQ0FBQzVpQixFQUFFLElBQUk1TSxLQUFLaXZCLFVBQVUsQ0FBQ3JpQixFQUFFLENBQUM1RTtnQkFDL0I7Z0JBQ0Fnc0IsV0FBVyxDQUFDcG5CLEVBQUUsR0FBRzRpQixHQUFHLENBQUM1aUIsRUFBRSxHQUFHNGpCLFFBQVExeEMsTUFBTTtnQkFFeEMsZ0ZBQWdGO2dCQUNoRixJQUFJLENBQUN5MEMsb0JBQW9CUyxXQUFXLENBQUNwbkIsRUFBRSxFQUFFa21CLFFBQVEsQ0FBQ2xtQixFQUFFLEVBQUU1TSxLQUFLMHlCLG9CQUFvQixHQUFHO29CQUNoRjFCLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUNBbUMsU0FBUyxDQUFDL2UsRUFBRSxHQUFHNGY7WUFDZnpELFFBQVEsQ0FBQ25jLEVBQUUsR0FBRy9SLEdBQUdyZSxVQUFVLENBQUN3c0M7UUFDOUI7UUFDQW5IO0lBQ0Y7SUFDQSxPQUFPa0g7QUFDVDtBQUNBLElBQUkwRCxXQUFXLFNBQVNBLFNBQVNyaEMsT0FBTztJQUN0QyxJQUFJeVAsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSXNFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBQ3RCLElBQUlxQixPQUFPO0lBQ1gsSUFBSWhJLE9BQU82eUIsYUFBYWpnQztJQUV4Qiw0QkFBNEI7SUFDNUIsSUFBSTI5QixXQUFXLElBQUl0eEMsTUFBTStnQixLQUFLcmEsQ0FBQztJQUMvQixJQUFJK3RDO0lBQ0osSUFBSUosYUFBYSxDQUFDO0lBQ2xCLElBQUlZO0lBQ0osSUFBSUMsV0FBVyxJQUFJbDFDLE1BQU0rZ0IsS0FBS3JhLENBQUMsR0FBRyw4Q0FBOEM7SUFFaEYsK0JBQStCO0lBQy9CLElBQUlxYSxLQUFLMnlCLFFBQVEsRUFBRTtRQUNqQixJQUFJLE9BQU8zeUIsS0FBSzR5QixhQUFhLEtBQUs7YUFBaUIsSUFBSTd3QyxRQUFRaWUsS0FBSzR5QixhQUFhLE1BQU0sVUFBVTtZQUMvRmMsVUFBVTF6QixLQUFLNHlCLGFBQWE7UUFDOUIsT0FBTztZQUNMYyxVQUFVQyxjQUFjaHRCLE9BQU8zRyxLQUFLcmEsQ0FBQztRQUN2QztJQUNGLE9BQU87UUFDTCt0QyxVQUFVQyxjQUFjaHRCLE9BQU8zRyxLQUFLcmEsQ0FBQztJQUN2QztJQUNBLElBQUlxckMsZ0JBQWdCO0lBQ3BCLElBQUkzSCxhQUFhO0lBQ2pCLE1BQU8ySCxpQkFBaUIzSCxhQUFhcnBCLEtBQUtndkIsYUFBYSxDQUFFO1FBQ3ZELDZDQUE2QztRQUM3QyxJQUFLLElBQUlod0MsSUFBSSxHQUFHQSxJQUFJMm5CLE1BQU03bkIsTUFBTSxFQUFFRSxJQUFLO1lBQ3JDZ3BCLE9BQU9yQixLQUFLLENBQUMzbkIsRUFBRTtZQUNmLHFFQUFxRTtZQUNyRXMwQyxVQUFVLENBQUN0ckIsS0FBS2xCLEVBQUUsR0FBRyxHQUFHc3NCLFNBQVNwckIsTUFBTTByQixTQUFTMXpCLEtBQUtvUSxRQUFRLEVBQUVwUSxLQUFLaXZCLFVBQVUsRUFBRTtRQUNsRjtRQUNBK0IsZ0JBQWdCO1FBQ2hCLHlFQUF5RTtRQUN6RSxvRUFBb0U7UUFDcEUsSUFBSyxJQUFJem9DLEtBQUksR0FBR0EsS0FBSW1yQyxRQUFRNTBDLE1BQU0sRUFBRXlKLEtBQUs7WUFDdkMsMkNBQTJDO1lBQzNDLElBQUlpb0MsVUFBVTZDLGFBQWE5cUMsSUFBR29lLE9BQU8yc0I7WUFDckMsSUFBSTlDLFFBQVExeEMsTUFBTSxLQUFLLEdBQUc7Z0JBRXhCO1lBQ0Y7WUFDQXExQyxRQUFRLENBQUM1ckMsR0FBRSxHQUFHcXJDLFNBQVNGLE9BQU8sQ0FBQ25yQyxHQUFFLEVBQUVpb0MsU0FBU3h3QixLQUFLaXZCLFVBQVUsR0FBRyxnQkFBZ0I7WUFFOUUsbUVBQW1FO1lBQ25FLElBQUssSUFBSWpGLEtBQUssR0FBR0EsS0FBS3dHLFFBQVExeEMsTUFBTSxFQUFFa3JDLEtBQU07Z0JBQzFDa0ssVUFBVU4sU0FBU3BELE9BQU8sQ0FBQ3hHLEdBQUcsRUFBRXdHLFNBQVN4d0IsS0FBS2l2QixVQUFVO2dCQUN4RCxJQUFJaUYsVUFBVUMsUUFBUSxDQUFDNXJDLEdBQUUsRUFBRTtvQkFDekI0ckMsUUFBUSxDQUFDNXJDLEdBQUUsR0FBRzJyQztvQkFDZFIsT0FBTyxDQUFDbnJDLEdBQUUsR0FBR2lvQyxPQUFPLENBQUN4RyxHQUFHO29CQUN4QmdILGdCQUFnQjtnQkFDbEI7WUFDRjtZQUNBVCxRQUFRLENBQUNob0MsR0FBRSxHQUFHOFosR0FBR3JlLFVBQVUsQ0FBQ3dzQztRQUM5QjtRQUNBbkg7SUFDRjtJQUNBLE9BQU9rSDtBQUNUO0FBQ0EsSUFBSTZELGtCQUFrQixTQUFTQSxnQkFBZ0JqQixTQUFTLEVBQUV4c0IsS0FBSyxFQUFFMHRCLENBQUMsRUFBRXRvQixNQUFNLEVBQUUvTCxJQUFJO0lBQzlFLElBQUlzMEIsV0FBV0M7SUFDZixJQUFLLElBQUl2MUMsSUFBSSxHQUFHQSxJQUFJMm5CLE1BQU03bkIsTUFBTSxFQUFFRSxJQUFLO1FBQ3JDLElBQUssSUFBSW8xQixJQUFJLEdBQUdBLElBQUkrZSxVQUFVcjBDLE1BQU0sRUFBRXMxQixJQUFLO1lBQ3pDckksTUFBTSxDQUFDL3NCLEVBQUUsQ0FBQ28xQixFQUFFLEdBQUd4d0IsS0FBSzZ4QixHQUFHLENBQUM0ZSxDQUFDLENBQUNyMUMsRUFBRSxDQUFDbzFCLEVBQUUsRUFBRXBVLEtBQUt6WCxDQUFDO1FBQ3pDO0lBQ0Y7SUFDQSxJQUFLLElBQUlpc0MsS0FBSyxHQUFHQSxLQUFLckIsVUFBVXIwQyxNQUFNLEVBQUUwMUMsS0FBTTtRQUM1QyxJQUFLLElBQUl6QyxNQUFNLEdBQUdBLE1BQU0veEIsS0FBS2l2QixVQUFVLENBQUNud0MsTUFBTSxFQUFFaXpDLE1BQU87WUFDckR1QyxZQUFZO1lBQ1pDLGNBQWM7WUFDZCxJQUFLLElBQUl0SyxNQUFNLEdBQUdBLE1BQU10akIsTUFBTTduQixNQUFNLEVBQUVtckMsTUFBTztnQkFDM0NxSyxhQUFhdm9CLE1BQU0sQ0FBQ2tlLElBQUksQ0FBQ3VLLEdBQUcsR0FBR3gwQixLQUFLaXZCLFVBQVUsQ0FBQzhDLElBQUksQ0FBQ3ByQixLQUFLLENBQUNzakIsSUFBSTtnQkFDOURzSyxlQUFleG9CLE1BQU0sQ0FBQ2tlLElBQUksQ0FBQ3VLLEdBQUc7WUFDaEM7WUFDQXJCLFNBQVMsQ0FBQ3FCLEdBQUcsQ0FBQ3pDLElBQUksR0FBR3VDLFlBQVlDO1FBQ25DO0lBQ0Y7QUFDRjtBQUNBLElBQUlFLG1CQUFtQixTQUFTQSxpQkFBaUJKLENBQUMsRUFBRUssRUFBRSxFQUFFdkIsU0FBUyxFQUFFeHNCLEtBQUssRUFBRTNHLElBQUk7SUFDNUUscUJBQXFCO0lBQ3JCLElBQUssSUFBSTNlLElBQUksR0FBR0EsSUFBSWd6QyxFQUFFdjFDLE1BQU0sRUFBRXVDLElBQUs7UUFDakNxekMsRUFBRSxDQUFDcnpDLEVBQUUsR0FBR2d6QyxDQUFDLENBQUNoekMsRUFBRSxDQUFDYSxLQUFLO0lBQ3BCO0lBQ0EsSUFBSXN0QyxLQUFLOEUsV0FBV0M7SUFDcEIsSUFBSTllLE1BQU0sSUFBS3pWLENBQUFBLEtBQUt6WCxDQUFDLEdBQUc7SUFDeEIsSUFBSyxJQUFJNnJCLElBQUksR0FBR0EsSUFBSStlLFVBQVVyMEMsTUFBTSxFQUFFczFCLElBQUs7UUFDekMsSUFBSyxJQUFJcDFCLElBQUksR0FBR0EsSUFBSTJuQixNQUFNN25CLE1BQU0sRUFBRUUsSUFBSztZQUNyQ3d3QyxNQUFNO1lBQ04sSUFBSyxJQUFJN3BDLElBQUksR0FBR0EsSUFBSXd0QyxVQUFVcjBDLE1BQU0sRUFBRTZHLElBQUs7Z0JBQ3pDLDhCQUE4QjtnQkFDOUIydUMsWUFBWTVuQixRQUFRMU0sS0FBS29RLFFBQVEsRUFBRXpKLEtBQUssQ0FBQzNuQixFQUFFLEVBQUVtMEMsU0FBUyxDQUFDL2UsRUFBRSxFQUFFcFUsS0FBS2l2QixVQUFVLEVBQUU7Z0JBQzVFc0YsY0FBYzduQixRQUFRMU0sS0FBS29RLFFBQVEsRUFBRXpKLEtBQUssQ0FBQzNuQixFQUFFLEVBQUVtMEMsU0FBUyxDQUFDeHRDLEVBQUUsRUFBRXFhLEtBQUtpdkIsVUFBVSxFQUFFO2dCQUM5RU8sT0FBTzVyQyxLQUFLNnhCLEdBQUcsQ0FBQzZlLFlBQVlDLGFBQWE5ZTtZQUMzQztZQUNBNGUsQ0FBQyxDQUFDcjFDLEVBQUUsQ0FBQ28xQixFQUFFLEdBQUcsSUFBSW9iO1FBQ2hCO0lBQ0Y7QUFDRjtBQUNBLElBQUltRixXQUFXLFNBQVNydEMsT0FBT3FmLEtBQUssRUFBRTB0QixDQUFDLEVBQUVyMEIsSUFBSSxFQUFFcUMsRUFBRTtJQUMvQyxJQUFJa3VCLFdBQVcsSUFBSXR4QyxNQUFNK2dCLEtBQUtyYSxDQUFDO0lBQy9CLElBQUssSUFBSXl1QixJQUFJLEdBQUdBLElBQUltYyxTQUFTenhDLE1BQU0sRUFBRXMxQixJQUFLO1FBQ3hDbWMsUUFBUSxDQUFDbmMsRUFBRSxHQUFHLEVBQUU7SUFDbEI7SUFDQSxJQUFJM2I7SUFDSixJQUFJekQ7SUFDSixJQUFLLElBQUloVyxJQUFJLEdBQUdBLElBQUlxMUMsRUFBRXYxQyxNQUFNLEVBQUVFLElBQUs7UUFDakMsb0NBQW9DO1FBQ3BDeVosTUFBTSxDQUFDb1U7UUFDUDdYLFFBQVEsQ0FBQztRQUNULCtEQUErRDtRQUMvRCxJQUFLLElBQUk0L0IsTUFBTSxHQUFHQSxNQUFNUCxDQUFDLENBQUMsRUFBRSxDQUFDdjFDLE1BQU0sRUFBRTgxQyxNQUFPO1lBQzFDLElBQUlQLENBQUMsQ0FBQ3IxQyxFQUFFLENBQUM0MUMsSUFBSSxHQUFHbjhCLEtBQUs7Z0JBQ25CQSxNQUFNNDdCLENBQUMsQ0FBQ3IxQyxFQUFFLENBQUM0MUMsSUFBSTtnQkFDZjUvQixRQUFRNC9CO1lBQ1Y7UUFDRjtRQUNBckUsUUFBUSxDQUFDdjdCLE1BQU0sQ0FBQzFULElBQUksQ0FBQ3FsQixLQUFLLENBQUMzbkIsRUFBRTtJQUMvQjtJQUVBLDhDQUE4QztJQUM5QyxJQUFLLElBQUk2MUMsTUFBTSxHQUFHQSxNQUFNdEUsU0FBU3p4QyxNQUFNLEVBQUUrMUMsTUFBTztRQUM5Q3RFLFFBQVEsQ0FBQ3NFLElBQUksR0FBR3h5QixHQUFHcmUsVUFBVSxDQUFDdXNDLFFBQVEsQ0FBQ3NFLElBQUk7SUFDN0M7SUFDQSxPQUFPdEU7QUFDVDtBQUNBLElBQUl1RSxjQUFjLFNBQVNBLFlBQVlsaUMsT0FBTztJQUM1QyxJQUFJeVAsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSXNFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBQ3RCLElBQUkzRyxPQUFPNnlCLGFBQWFqZ0M7SUFFeEIsZ0NBQWdDO0lBQ2hDLElBQUkyOUI7SUFDSixJQUFJNEM7SUFDSixJQUFJa0I7SUFDSixJQUFJSztJQUNKLElBQUkzb0I7SUFFSixnQ0FBZ0M7SUFDaEMyb0IsS0FBSyxJQUFJejFDLE1BQU0wbkIsTUFBTTduQixNQUFNO0lBQzNCLElBQUssSUFBSXVDLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7UUFDckMsZUFBZTtRQUNmcXpDLEVBQUUsQ0FBQ3J6QyxFQUFFLEdBQUcsSUFBSXBDLE1BQU0rZ0IsS0FBS3JhLENBQUM7SUFDMUI7SUFDQTB1QyxJQUFJLElBQUlwMUMsTUFBTTBuQixNQUFNN25CLE1BQU07SUFDMUIsSUFBSyxJQUFJbzNCLE1BQU0sR0FBR0EsTUFBTXZQLE1BQU03bkIsTUFBTSxFQUFFbzNCLE1BQU87UUFDM0MsZUFBZTtRQUNmbWUsQ0FBQyxDQUFDbmUsSUFBSSxHQUFHLElBQUlqM0IsTUFBTStnQixLQUFLcmEsQ0FBQztJQUMzQjtJQUNBLElBQUssSUFBSXl3QixNQUFNLEdBQUdBLE1BQU16UCxNQUFNN25CLE1BQU0sRUFBRXMzQixNQUFPO1FBQzNDLElBQUlzQixRQUFRO1FBQ1osSUFBSyxJQUFJaHdCLElBQUksR0FBR0EsSUFBSXNZLEtBQUtyYSxDQUFDLEVBQUUrQixJQUFLO1lBQy9CMnNDLENBQUMsQ0FBQ2plLElBQUksQ0FBQzF1QixFQUFFLEdBQUc5RCxLQUFLOGIsTUFBTTtZQUN2QmdZLFNBQVMyYyxDQUFDLENBQUNqZSxJQUFJLENBQUMxdUIsRUFBRTtRQUNwQjtRQUNBLElBQUssSUFBSTRpQixLQUFLLEdBQUdBLEtBQUt0SyxLQUFLcmEsQ0FBQyxFQUFFMmtCLEtBQU07WUFDbEMrcEIsQ0FBQyxDQUFDamUsSUFBSSxDQUFDOUwsR0FBRyxHQUFHK3BCLENBQUMsQ0FBQ2plLElBQUksQ0FBQzlMLEdBQUcsR0FBR29OO1FBQzVCO0lBQ0Y7SUFDQXliLFlBQVksSUFBSWwwQyxNQUFNK2dCLEtBQUtyYSxDQUFDO0lBQzVCLElBQUssSUFBSWd4QixNQUFNLEdBQUdBLE1BQU0zVyxLQUFLcmEsQ0FBQyxFQUFFZ3hCLE1BQU87UUFDckN3YyxTQUFTLENBQUN4YyxJQUFJLEdBQUcsSUFBSTEzQixNQUFNK2dCLEtBQUtpdkIsVUFBVSxDQUFDbndDLE1BQU07SUFDbkQ7SUFDQWl0QixTQUFTLElBQUk5c0IsTUFBTTBuQixNQUFNN25CLE1BQU07SUFDL0IsSUFBSyxJQUFJdW9DLE1BQU0sR0FBR0EsTUFBTTFnQixNQUFNN25CLE1BQU0sRUFBRXVvQyxNQUFPO1FBQzNDLGVBQWU7UUFDZnRiLE1BQU0sQ0FBQ3NiLElBQUksR0FBRyxJQUFJcG9DLE1BQU0rZ0IsS0FBS3JhLENBQUM7SUFDaEM7SUFDQSxlQUFlO0lBRWYsSUFBSXFyQyxnQkFBZ0I7SUFDcEIsSUFBSTNILGFBQWE7SUFDakIsTUFBTzJILGlCQUFpQjNILGFBQWFycEIsS0FBS2d2QixhQUFhLENBQUU7UUFDdkRnQyxnQkFBZ0I7UUFFaEIsaURBQWlEO1FBQ2pEb0QsZ0JBQWdCakIsV0FBV3hzQixPQUFPMHRCLEdBQUd0b0IsUUFBUS9MO1FBRTdDLHlDQUF5QztRQUN6Q3kwQixpQkFBaUJKLEdBQUdLLElBQUl2QixXQUFXeHNCLE9BQU8zRztRQUUxQyxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDd3pCLHNCQUFzQmEsR0FBR0ssSUFBSTEwQixLQUFLMHlCLG9CQUFvQixHQUFHO1lBQzVEMUIsZ0JBQWdCO1FBQ2xCO1FBQ0EzSDtJQUNGO0lBRUEscURBQXFEO0lBQ3JEa0gsV0FBV29FLFNBQVNodUIsT0FBTzB0QixHQUFHcjBCLE1BQU1xQztJQUNwQyxPQUFPO1FBQ0xrdUIsVUFBVUE7UUFDVndFLG9CQUFvQlY7SUFDdEI7QUFDRjtBQUNBLElBQUlXLGNBQWM7SUFDaEJqQixRQUFRQTtJQUNSRSxVQUFVQTtJQUNWYSxhQUFhQTtJQUNiRyxLQUFLSDtBQUNQO0FBRUEsNkNBQTZDO0FBQzdDLHlEQUF5RDtBQUV6RCxJQUFJSSxhQUFhcjFCLFdBQVc7SUFDMUJ1USxVQUFVO0lBQ1YsbUNBQW1DO0lBQ25DK2tCLFNBQVM7SUFDVCw4RUFBOEU7SUFDOUVwQyxNQUFNO0lBQ04sZ0VBQWdFO0lBQ2hFcUMsV0FBV3ZvQjtJQUNYLHlCQUF5QjtJQUN6QixnSEFBZ0g7SUFDaEh3b0IsZUFBZTtJQUNmLHFEQUFxRDtJQUNyREMsaUJBQWlCO0lBQ2pCLDJFQUEyRTtJQUMzRXJHLFlBQVksRUFBRSxDQUFDLDBCQUEwQjtBQUMzQztBQUNBLElBQUlzRyxpQkFBaUI7SUFDbkIsVUFBVTtJQUNWLFlBQVk7QUFDZDtBQUNBLElBQUlDLGVBQWUsU0FBU3JHLFdBQVd2OEIsT0FBTztJQUM1QyxJQUFJb04sT0FBT2sxQixXQUFXdGlDO0lBQ3RCLElBQUk2aUMsaUJBQWlCRixjQUFjLENBQUN2MUIsS0FBS20xQixPQUFPLENBQUM7SUFDakQsSUFBSU0sa0JBQWtCLE1BQU07UUFDMUJ6MUIsS0FBS20xQixPQUFPLEdBQUdNO0lBQ2pCO0lBQ0EsT0FBT3oxQjtBQUNUO0FBQ0EsSUFBSTAxQixlQUFlLFNBQVNBLGFBQWFuRixRQUFRLEVBQUV2N0IsS0FBSyxFQUFFMmdDLEtBQUssRUFBRUMsSUFBSSxFQUFFNTFCLElBQUk7SUFDekUsNkNBQTZDO0lBQzdDLElBQUk2MUIsU0FBUztJQUNiLElBQUlsOUIsTUFBTWtVO0lBQ1YsSUFBSVI7SUFDSixJQUFJeXBCLFFBQVE5MUIsS0FBS2l2QixVQUFVO0lBQzNCLElBQUl2aUIsVUFBVSxTQUFTQSxRQUFRcXBCLEVBQUUsRUFBRTdGLEVBQUU7UUFDbkMsT0FBT2tDLG1CQUFtQnB5QixLQUFLb1EsUUFBUSxFQUFFMGxCLE1BQU1oM0MsTUFBTSxFQUFFLFNBQVV1QyxDQUFDO1lBQ2hFLE9BQU95MEMsS0FBSyxDQUFDejBDLEVBQUUsQ0FBQzAwQztRQUNsQixHQUFHLFNBQVUxMEMsQ0FBQztZQUNaLE9BQU95MEMsS0FBSyxDQUFDejBDLEVBQUUsQ0FBQzZ1QztRQUNsQixHQUFHNkYsSUFBSTdGO0lBQ1Q7SUFDQSxJQUFLLElBQUk3dUMsSUFBSSxHQUFHQSxJQUFJa3ZDLFNBQVN6eEMsTUFBTSxFQUFFdUMsSUFBSztRQUN4QyxJQUFJckIsTUFBTXV3QyxRQUFRLENBQUNsdkMsRUFBRSxDQUFDckIsR0FBRztRQUN6QixJQUFJZzJDLFFBQVFMLEtBQUssQ0FBQzMxQyxJQUFJLENBQUM0MUMsSUFBSSxDQUFDNTFDLElBQUksQ0FBQztRQUNqQyxJQUFJZzJDLFFBQVFyOUIsS0FBSztZQUNmazlCLFNBQVM3MUM7WUFDVDJZLE1BQU1xOUI7UUFDUjtJQUNGO0lBQ0EsSUFBSWgyQixLQUFLK3lCLElBQUksS0FBSyxlQUFlcDZCLE9BQU9xSCxLQUFLbzFCLFNBQVMsSUFBSXAxQixLQUFLK3lCLElBQUksS0FBSyxnQkFBZ0J4QyxTQUFTenhDLE1BQU0sS0FBSyxHQUFHO1FBQzdHLE9BQU87SUFDVDtJQUNBLElBQUk0eEMsS0FBSzE3QixLQUFLLENBQUM2Z0MsT0FBTztJQUN0QixJQUFJbEYsS0FBSzM3QixLQUFLLENBQUM0Z0MsSUFBSSxDQUFDQyxPQUFPLENBQUM7SUFDNUIsSUFBSUk7SUFFSiw2QkFBNkI7SUFDN0IsSUFBSWoyQixLQUFLK3lCLElBQUksS0FBSyxjQUFjO1FBQzlCa0QsU0FBUztZQUNQL2IsTUFBTXdXO1lBQ04xVyxPQUFPMlc7WUFDUDN3QyxLQUFLMHdDLEdBQUcxd0MsR0FBRztRQUNiO0lBQ0YsT0FBTztRQUNMaTJDLFNBQVM7WUFDUHYxQyxPQUFPZ3dDLEdBQUdod0MsS0FBSyxDQUFDbXBCLE1BQU0sQ0FBQzhtQixHQUFHandDLEtBQUs7WUFDL0JWLEtBQUswd0MsR0FBRzF3QyxHQUFHO1FBQ2I7SUFDRjtJQUNBdXdDLFFBQVEsQ0FBQ0csR0FBRzE3QixLQUFLLENBQUMsR0FBR2loQztJQUNyQjFGLFNBQVNqd0IsTUFBTSxDQUFDcXdCLEdBQUczN0IsS0FBSyxFQUFFO0lBQzFCQSxLQUFLLENBQUMwN0IsR0FBRzF3QyxHQUFHLENBQUMsR0FBR2kyQztJQUVoQiwyQ0FBMkM7SUFDM0MsSUFBSyxJQUFJbHVCLEtBQUssR0FBR0EsS0FBS3dvQixTQUFTenhDLE1BQU0sRUFBRWlwQixLQUFNO1FBQzNDLElBQUltdUIsTUFBTTNGLFFBQVEsQ0FBQ3hvQixHQUFHO1FBQ3RCLElBQUkyb0IsR0FBRzF3QyxHQUFHLEtBQUtrMkMsSUFBSWwyQyxHQUFHLEVBQUU7WUFDdEJxc0IsT0FBT1E7UUFDVCxPQUFPLElBQUk3TSxLQUFLbTFCLE9BQU8sS0FBSyxPQUFPO1lBQ2pDOW9CLE9BQU9zcEIsS0FBSyxDQUFDakYsR0FBRzF3QyxHQUFHLENBQUMsQ0FBQ2syQyxJQUFJbDJDLEdBQUcsQ0FBQztZQUM3QixJQUFJMjFDLEtBQUssQ0FBQ2pGLEdBQUcxd0MsR0FBRyxDQUFDLENBQUNrMkMsSUFBSWwyQyxHQUFHLENBQUMsR0FBRzIxQyxLQUFLLENBQUNoRixHQUFHM3dDLEdBQUcsQ0FBQyxDQUFDazJDLElBQUlsMkMsR0FBRyxDQUFDLEVBQUU7Z0JBQ25EcXNCLE9BQU9zcEIsS0FBSyxDQUFDaEYsR0FBRzN3QyxHQUFHLENBQUMsQ0FBQ2syQyxJQUFJbDJDLEdBQUcsQ0FBQztZQUMvQjtRQUNGLE9BQU8sSUFBSWdnQixLQUFLbTFCLE9BQU8sS0FBSyxPQUFPO1lBQ2pDOW9CLE9BQU9zcEIsS0FBSyxDQUFDakYsR0FBRzF3QyxHQUFHLENBQUMsQ0FBQ2syQyxJQUFJbDJDLEdBQUcsQ0FBQztZQUM3QixJQUFJMjFDLEtBQUssQ0FBQ2pGLEdBQUcxd0MsR0FBRyxDQUFDLENBQUNrMkMsSUFBSWwyQyxHQUFHLENBQUMsR0FBRzIxQyxLQUFLLENBQUNoRixHQUFHM3dDLEdBQUcsQ0FBQyxDQUFDazJDLElBQUlsMkMsR0FBRyxDQUFDLEVBQUU7Z0JBQ25EcXNCLE9BQU9zcEIsS0FBSyxDQUFDaEYsR0FBRzN3QyxHQUFHLENBQUMsQ0FBQ2syQyxJQUFJbDJDLEdBQUcsQ0FBQztZQUMvQjtRQUNGLE9BQU8sSUFBSWdnQixLQUFLbTFCLE9BQU8sS0FBSyxRQUFRO1lBQ2xDOW9CLE9BQU8sQ0FBQ3NwQixLQUFLLENBQUNqRixHQUFHMXdDLEdBQUcsQ0FBQyxDQUFDazJDLElBQUlsMkMsR0FBRyxDQUFDLEdBQUcwd0MsR0FBRy91QixJQUFJLEdBQUdnMEIsS0FBSyxDQUFDaEYsR0FBRzN3QyxHQUFHLENBQUMsQ0FBQ2syQyxJQUFJbDJDLEdBQUcsQ0FBQyxHQUFHMndDLEdBQUdodkIsSUFBSSxJQUFLK3VCLENBQUFBLEdBQUcvdUIsSUFBSSxHQUFHZ3ZCLEdBQUdodkIsSUFBSTtRQUNuRyxPQUFPO1lBQ0wsSUFBSTNCLEtBQUsreUIsSUFBSSxLQUFLLGNBQWMxbUIsT0FBT0ssUUFBUXdwQixJQUFJeDFDLEtBQUssRUFBRWd3QyxHQUFHaHdDLEtBQUs7aUJBQU8yckIsT0FBT0ssUUFBUXdwQixJQUFJeDFDLEtBQUssQ0FBQyxFQUFFLEVBQUVnd0MsR0FBR2h3QyxLQUFLLENBQUMsRUFBRTtRQUNuSDtRQUNBaTFDLEtBQUssQ0FBQ2pGLEdBQUcxd0MsR0FBRyxDQUFDLENBQUNrMkMsSUFBSWwyQyxHQUFHLENBQUMsR0FBRzIxQyxLQUFLLENBQUNPLElBQUlsMkMsR0FBRyxDQUFDLENBQUMwd0MsR0FBRzF3QyxHQUFHLENBQUMsR0FBR3FzQixNQUFNLCtCQUErQjtJQUN6RjtJQUVBLHFCQUFxQjtJQUNyQixJQUFLLElBQUkxRSxNQUFNLEdBQUdBLE1BQU00b0IsU0FBU3p4QyxNQUFNLEVBQUU2b0IsTUFBTztRQUM5QyxJQUFJd3VCLE9BQU81RixRQUFRLENBQUM1b0IsSUFBSSxDQUFDM25CLEdBQUc7UUFDNUIsSUFBSTQxQyxJQUFJLENBQUNPLEtBQUssS0FBS3pGLEdBQUcxd0MsR0FBRyxJQUFJNDFDLElBQUksQ0FBQ08sS0FBSyxLQUFLeEYsR0FBRzN3QyxHQUFHLEVBQUU7WUFDbEQsSUFBSXVsQyxPQUFPNFE7WUFDWCxJQUFLLElBQUl6dUMsSUFBSSxHQUFHQSxJQUFJNm9DLFNBQVN6eEMsTUFBTSxFQUFFNEksSUFBSztnQkFDeEMsSUFBSTB1QyxPQUFPN0YsUUFBUSxDQUFDN29DLEVBQUUsQ0FBQzFILEdBQUc7Z0JBQzFCLElBQUkyMUMsS0FBSyxDQUFDUSxLQUFLLENBQUNDLEtBQUssR0FBR1QsS0FBSyxDQUFDUSxLQUFLLENBQUM1USxLQUFLLEVBQUU7b0JBQ3pDQSxPQUFPNlE7Z0JBQ1Q7WUFDRjtZQUNBUixJQUFJLENBQUNPLEtBQUssR0FBRzVRO1FBQ2Y7UUFDQWdMLFFBQVEsQ0FBQzVvQixJQUFJLENBQUMzUyxLQUFLLEdBQUcyUztJQUN4QjtJQUVBLHlDQUF5QztJQUN6QytvQixHQUFHMXdDLEdBQUcsR0FBRzJ3QyxHQUFHM3dDLEdBQUcsR0FBRzB3QyxHQUFHMTdCLEtBQUssR0FBRzI3QixHQUFHMzdCLEtBQUssR0FBRztJQUN4QyxPQUFPO0FBQ1Q7QUFDQSxJQUFJcWhDLGtCQUFrQixTQUFTQyxlQUFlbGlDLElBQUksRUFBRW9MLEdBQUcsRUFBRTZDLEVBQUU7SUFDekQsSUFBSSxDQUFDak8sTUFBTTtJQUNYLElBQUlBLEtBQUsxVCxLQUFLLEVBQUU7UUFDZDhlLElBQUlsZSxJQUFJLENBQUM4UyxLQUFLMVQsS0FBSztJQUNyQixPQUFPO1FBQ0wsSUFBSTBULEtBQUs4bEIsSUFBSSxFQUFFbWMsZ0JBQWdCamlDLEtBQUs4bEIsSUFBSSxFQUFFMWE7UUFDMUMsSUFBSXBMLEtBQUs0bEIsS0FBSyxFQUFFcWMsZ0JBQWdCamlDLEtBQUs0bEIsS0FBSyxFQUFFeGE7SUFDOUM7QUFDRjtBQUNBLElBQUkrMkIsbUJBQW1CLFNBQVNDLGdCQUFnQnBpQyxJQUFJLEVBQUVpTyxFQUFFO0lBQ3RELElBQUksQ0FBQ2pPLE1BQU0sT0FBTztJQUNsQixJQUFJQSxLQUFLOGxCLElBQUksSUFBSTlsQixLQUFLNGxCLEtBQUssRUFBRTtRQUMzQixJQUFJeWMsVUFBVUYsaUJBQWlCbmlDLEtBQUs4bEIsSUFBSSxFQUFFN1g7UUFDMUMsSUFBSXEwQixXQUFXSCxpQkFBaUJuaUMsS0FBSzRsQixLQUFLLEVBQUUzWDtRQUM1QyxJQUFJMkYsT0FBTzNGLEdBQUdSLEdBQUcsQ0FBQztZQUNoQlcsT0FBTztZQUNQQyxNQUFNO2dCQUNKcUUsSUFBSTJ2QixVQUFVLE1BQU1DO1lBQ3RCO1FBQ0Y7UUFDQXIwQixHQUFHUixHQUFHLENBQUM7WUFDTFcsT0FBTztZQUNQQyxNQUFNO2dCQUNKQyxRQUFRK3pCO2dCQUNSOXpCLFFBQVFxRixLQUFLbEIsRUFBRTtZQUNqQjtRQUNGO1FBQ0F6RSxHQUFHUixHQUFHLENBQUM7WUFDTFcsT0FBTztZQUNQQyxNQUFNO2dCQUNKQyxRQUFRZzBCO2dCQUNSL3pCLFFBQVFxRixLQUFLbEIsRUFBRTtZQUNqQjtRQUNGO1FBQ0EsT0FBT2tCLEtBQUtsQixFQUFFO0lBQ2hCLE9BQU8sSUFBSTFTLEtBQUsxVCxLQUFLLEVBQUU7UUFDckIsT0FBTzBULEtBQUsxVCxLQUFLLENBQUNvbUIsRUFBRTtJQUN0QjtBQUNGO0FBQ0EsSUFBSTZ2Qix5QkFBeUIsU0FBU0Msc0JBQXNCeGlDLElBQUksRUFBRXpPLENBQUMsRUFBRTBjLEVBQUU7SUFDckUsSUFBSSxDQUFDak8sTUFBTSxPQUFPLEVBQUU7SUFDcEIsSUFBSThsQixPQUFPLEVBQUUsRUFDWEYsUUFBUSxFQUFFLEVBQ1Y2YyxTQUFTLEVBQUU7SUFDYixJQUFJbHhDLE1BQU0sR0FBRztRQUNYLDhEQUE4RDtRQUM5RCxJQUFJeU8sS0FBSzhsQixJQUFJLEVBQUVtYyxnQkFBZ0JqaUMsS0FBSzhsQixJQUFJLEVBQUVBO1FBQzFDLElBQUk5bEIsS0FBSzRsQixLQUFLLEVBQUVxYyxnQkFBZ0JqaUMsS0FBSzRsQixLQUFLLEVBQUVBO1FBQzVDNmMsU0FBUzNjLEtBQUtyUSxNQUFNLENBQUNtUTtRQUNyQixPQUFPO1lBQUMzWCxHQUFHcmUsVUFBVSxDQUFDNnlDO1NBQVE7SUFDaEMsT0FBTyxJQUFJbHhDLE1BQU0sR0FBRztRQUNsQixjQUFjO1FBRWQsSUFBSXlPLEtBQUsxVCxLQUFLLEVBQUU7WUFDZCxZQUFZO1lBQ1osT0FBTztnQkFBQzJoQixHQUFHcmUsVUFBVSxDQUFDb1EsS0FBSzFULEtBQUs7YUFBRTtRQUNwQyxPQUFPO1lBQ0wsSUFBSTBULEtBQUs4bEIsSUFBSSxFQUFFbWMsZ0JBQWdCamlDLEtBQUs4bEIsSUFBSSxFQUFFQTtZQUMxQyxJQUFJOWxCLEtBQUs0bEIsS0FBSyxFQUFFcWMsZ0JBQWdCamlDLEtBQUs0bEIsS0FBSyxFQUFFQTtZQUM1QyxPQUFPO2dCQUFDM1gsR0FBR3JlLFVBQVUsQ0FBQ2syQjtnQkFBTzdYLEdBQUdyZSxVQUFVLENBQUNnMkI7YUFBTztRQUNwRDtJQUNGLE9BQU87UUFDTCxJQUFJNWxCLEtBQUsxVCxLQUFLLEVBQUU7WUFDZCxPQUFPO2dCQUFDMmhCLEdBQUdyZSxVQUFVLENBQUNvUSxLQUFLMVQsS0FBSzthQUFFO1FBQ3BDLE9BQU87WUFDTCxJQUFJMFQsS0FBSzhsQixJQUFJLEVBQUVBLE9BQU95Yyx1QkFBdUJ2aUMsS0FBSzhsQixJQUFJLEVBQUV2MEIsSUFBSSxHQUFHMGM7WUFDL0QsSUFBSWpPLEtBQUs0bEIsS0FBSyxFQUFFQSxRQUFRMmMsdUJBQXVCdmlDLEtBQUs0bEIsS0FBSyxFQUFFcjBCLElBQUksR0FBRzBjO1lBQ2xFLE9BQU82WCxLQUFLclEsTUFBTSxDQUFDbVE7UUFDckI7SUFDRjtBQUNGO0FBRUEsSUFBSThjLHlCQUF5QixTQUFTQSx1QkFBdUJsa0MsT0FBTztJQUNsRSxJQUFJeVAsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSXNFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBRXRCLG1FQUFtRTtJQUNuRSxJQUFJM0csT0FBT3cxQixhQUFhNWlDO0lBQ3hCLElBQUlrakMsUUFBUTkxQixLQUFLaXZCLFVBQVU7SUFDM0IsSUFBSXZpQixVQUFVLFNBQVNBLFFBQVFxcEIsRUFBRSxFQUFFN0YsRUFBRTtRQUNuQyxPQUFPa0MsbUJBQW1CcHlCLEtBQUtvUSxRQUFRLEVBQUUwbEIsTUFBTWgzQyxNQUFNLEVBQUUsU0FBVXVDLENBQUM7WUFDaEUsT0FBT3kwQyxLQUFLLENBQUN6MEMsRUFBRSxDQUFDMDBDO1FBQ2xCLEdBQUcsU0FBVTEwQyxDQUFDO1lBQ1osT0FBT3kwQyxLQUFLLENBQUN6MEMsRUFBRSxDQUFDNnVDO1FBQ2xCLEdBQUc2RixJQUFJN0Y7SUFDVDtJQUVBLCtCQUErQjtJQUMvQixJQUFJSyxXQUFXLEVBQUU7SUFDakIsSUFBSW9GLFFBQVEsRUFBRSxFQUFFLDBDQUEwQztJQUMxRCxJQUFJQyxPQUFPLEVBQUUsRUFBRSxtQ0FBbUM7SUFDbEQsSUFBSTVnQyxRQUFRLEVBQUUsRUFBRSw4QkFBOEI7SUFFOUMsK0VBQStFO0lBQy9FLElBQUssSUFBSWhXLElBQUksR0FBR0EsSUFBSTJuQixNQUFNN25CLE1BQU0sRUFBRUUsSUFBSztRQUNyQyxJQUFJd3hDLFVBQVU7WUFDWjl2QyxPQUFPc2YsS0FBSyt5QixJQUFJLEtBQUssZUFBZXBzQixLQUFLLENBQUMzbkIsRUFBRSxHQUFHO2dCQUFDMm5CLEtBQUssQ0FBQzNuQixFQUFFO2FBQUM7WUFDekRnQixLQUFLaEI7WUFDTGdXLE9BQU9oVztRQUNUO1FBQ0F1eEMsUUFBUSxDQUFDdnhDLEVBQUUsR0FBR3d4QztRQUNkeDdCLEtBQUssQ0FBQ2hXLEVBQUUsR0FBR3d4QztRQUNYbUYsS0FBSyxDQUFDMzJDLEVBQUUsR0FBRyxFQUFFO1FBQ2I0MkMsSUFBSSxDQUFDNTJDLEVBQUUsR0FBRztJQUNaO0lBRUEsdURBQXVEO0lBQ3ZELElBQUssSUFBSXFDLElBQUksR0FBR0EsSUFBSWt2QyxTQUFTenhDLE1BQU0sRUFBRXVDLElBQUs7UUFDeEMsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxLQUFLckcsR0FBR3FHLElBQUs7WUFDM0IsSUFBSTJrQixPQUFPeHFCO1lBQ1gsSUFBSW1lLEtBQUsreUIsSUFBSSxLQUFLLGNBQWM7Z0JBQzlCLHlDQUF5QztnQkFDekMxbUIsT0FBT2hyQixNQUFNcUcsSUFBSW1sQixXQUFXSCxRQUFRNmpCLFFBQVEsQ0FBQ2x2QyxFQUFFLENBQUNYLEtBQUssRUFBRTZ2QyxRQUFRLENBQUM3b0MsRUFBRSxDQUFDaEgsS0FBSztZQUMxRSxPQUFPO2dCQUNMMnJCLE9BQU9ockIsTUFBTXFHLElBQUltbEIsV0FBV0gsUUFBUTZqQixRQUFRLENBQUNsdkMsRUFBRSxDQUFDWCxLQUFLLENBQUMsRUFBRSxFQUFFNnZDLFFBQVEsQ0FBQzdvQyxFQUFFLENBQUNoSCxLQUFLLENBQUMsRUFBRTtZQUNoRjtZQUNBaTFDLEtBQUssQ0FBQ3QwQyxFQUFFLENBQUNxRyxFQUFFLEdBQUcya0I7WUFDZHNwQixLQUFLLENBQUNqdUMsRUFBRSxDQUFDckcsRUFBRSxHQUFHZ3JCO1lBQ2QsSUFBSUEsT0FBT3NwQixLQUFLLENBQUN0MEMsRUFBRSxDQUFDdTBDLElBQUksQ0FBQ3YwQyxFQUFFLENBQUMsRUFBRTtnQkFDNUJ1MEMsSUFBSSxDQUFDdjBDLEVBQUUsR0FBR3FHLEdBQUcsd0RBQXdEO1lBQ3ZFO1FBQ0Y7SUFDRjtJQUVBLDBFQUEwRTtJQUMxRSx1R0FBdUc7SUFDdkcsSUFBSXV1QyxTQUFTUCxhQUFhbkYsVUFBVXY3QixPQUFPMmdDLE9BQU9DLE1BQU01MUI7SUFDeEQsTUFBT2kyQixPQUFRO1FBQ2JBLFNBQVNQLGFBQWFuRixVQUFVdjdCLE9BQU8yZ0MsT0FBT0MsTUFBTTUxQjtJQUN0RDtJQUNBLElBQUkrMkI7SUFFSiwyRUFBMkU7SUFDM0UseUNBQXlDO0lBQ3pDLElBQUkvMkIsS0FBSyt5QixJQUFJLEtBQUssY0FBYztRQUM5QmdFLGNBQWNKLHVCQUF1QnBHLFFBQVEsQ0FBQyxFQUFFLEVBQUV2d0IsS0FBS3MxQixlQUFlLEVBQUVqekI7UUFDeEUsSUFBSXJDLEtBQUtxMUIsYUFBYSxFQUFFa0IsaUJBQWlCaEcsUUFBUSxDQUFDLEVBQUUsRUFBRWx1QjtJQUN4RCxPQUFPO1FBQ0wsMkNBQTJDO1FBRTNDMDBCLGNBQWMsSUFBSTkzQyxNQUFNc3hDLFNBQVN6eEMsTUFBTTtRQUN2Q3l4QyxTQUFTdnVCLE9BQU8sQ0FBQyxTQUFVd3VCLE9BQU8sRUFBRW52QyxDQUFDO1lBQ25DLHlDQUF5QztZQUN6Q212QyxRQUFReHdDLEdBQUcsR0FBR3d3QyxRQUFReDdCLEtBQUssR0FBRztZQUM5QitoQyxXQUFXLENBQUMxMUMsRUFBRSxHQUFHZ2hCLEdBQUdyZSxVQUFVLENBQUN3c0MsUUFBUTl2QyxLQUFLO1FBQzlDO0lBQ0Y7SUFDQSxPQUFPcTJDO0FBQ1Q7QUFDQSxJQUFJQywyQkFBMkI7SUFDN0JGLHdCQUF3QkE7SUFDeEJHLEtBQUtIO0FBQ1A7QUFFQSw2Q0FBNkM7QUFDN0MsaUVBQWlFO0FBRWpFLElBQUlJLGFBQWFyM0IsV0FBVztJQUMxQnVRLFVBQVU7SUFDViwwREFBMEQ7SUFDMUQrbUIsWUFBWTtJQUNaLHNEQUFzRDtJQUN0REMsU0FBUztJQUNULGtDQUFrQztJQUNsQ3BJLGVBQWU7SUFDZixrQ0FBa0M7SUFDbENxSSxlQUFlO0lBQ2Ysa0VBQWtFO0lBQ2xFcEksWUFBWSxFQUVYO0FBQ0g7QUFDQSxJQUFJRSxhQUFhLFNBQVNBLFdBQVd2OEIsT0FBTztJQUMxQyxJQUFJMGtDLE1BQU0xa0MsUUFBUXdrQyxPQUFPO0lBQ3pCLElBQUlHLE9BQU8za0MsUUFBUXVrQyxVQUFVO0lBQzdCLElBQUksQ0FBRSxRQUFPRyxPQUFPQSxNQUFNLElBQUk7UUFDNUJ0NEIsTUFBTSx5Q0FBeUM2SyxNQUFNLENBQUN5dEI7SUFDeEQ7SUFDQSxJQUFJRSxhQUFhO1FBQUM7UUFBVTtRQUFRO1FBQU87S0FBTTtJQUNqRCxJQUFJLENBQUVBLENBQUFBLFdBQVdDLElBQUksQ0FBQyxTQUFVeHhDLENBQUM7UUFDL0IsT0FBT0EsTUFBTXN4QztJQUNmLE1BQU0vekMsU0FBUyt6QyxLQUFJLEdBQUk7UUFDckJ2NEIsTUFBTSw4QkFBOEI2SyxNQUFNLENBQUMydEIsV0FBVzNrQyxHQUFHLENBQUMsU0FBVXhLLENBQUM7WUFDbkUsT0FBTyxJQUFJd2hCLE1BQU0sQ0FBQ3hoQixHQUFHO1FBQ3ZCLEdBQUcvQyxJQUFJLENBQUMsT0FBTyx5QkFBeUJ1a0IsTUFBTSxDQUFDMHRCO0lBQ2pEO0lBQ0EsT0FBT0wsV0FBV3RrQztBQUNwQjtBQUVBLElBQUl5OEIsZ0JBQWdCLFNBQVNBLGNBQWMxN0IsSUFBSSxFQUFFb2lDLEVBQUUsRUFBRTdGLEVBQUUsRUFBRWpCLFVBQVU7SUFDakUsSUFBSXlJLE9BQU8sU0FBU0EsS0FBSzE0QyxDQUFDLEVBQUVxQyxDQUFDO1FBQzNCLE9BQU80dEMsVUFBVSxDQUFDNXRDLEVBQUUsQ0FBQ3JDO0lBQ3ZCO0lBRUEsaUZBQWlGO0lBQ2pGLE9BQU8sQ0FBQ296QyxtQkFBbUJ6K0IsTUFBTXM3QixXQUFXbndDLE1BQU0sRUFBRSxTQUFVdUMsQ0FBQztRQUM3RCxPQUFPcTJDLEtBQUszQixJQUFJMTBDO0lBQ2xCLEdBQUcsU0FBVUEsQ0FBQztRQUNaLE9BQU9xMkMsS0FBS3hILElBQUk3dUM7SUFDbEIsR0FBRzAwQyxJQUFJN0Y7QUFDVDtBQUNBLElBQUl5SCxnQkFBZ0IsU0FBU0EsY0FBYzVwQixDQUFDLEVBQUVvcEIsVUFBVTtJQUN0RCw0Q0FBNEM7SUFDNUMsSUFBSTl1QyxJQUFJO0lBQ1IsSUFBSTh1QyxlQUFlLFVBQVU7UUFDM0I5dUMsSUFBSXN2QixPQUFPNUo7SUFDYixPQUFPLElBQUlvcEIsZUFBZSxRQUFRO1FBQ2hDOXVDLElBQUlvdkIsS0FBSzFKO0lBQ1gsT0FBTyxJQUFJb3BCLGVBQWUsT0FBTztRQUMvQjl1QyxJQUFJc1EsSUFBSW9WO0lBQ1YsT0FBTyxJQUFJb3BCLGVBQWUsT0FBTztRQUMvQjl1QyxJQUFJb1EsSUFBSXNWO0lBQ1YsT0FBTztRQUNMLDJDQUEyQztRQUMzQzFsQixJQUFJOHVDO0lBQ047SUFDQSxPQUFPOXVDO0FBQ1Q7QUFDQSxJQUFJdXZDLGdCQUFnQixTQUFTQSxjQUFjNTRDLENBQUMsRUFBRTY0QyxDQUFDLEVBQUV4cEIsQ0FBQztJQUNoRCxJQUFJeXBCLFVBQVUsRUFBRTtJQUNoQixJQUFLLElBQUl6MkMsSUFBSSxHQUFHQSxJQUFJckMsR0FBR3FDLElBQUs7UUFDMUIsSUFBSXcyQyxDQUFDLENBQUN4MkMsSUFBSXJDLElBQUlxQyxFQUFFLEdBQUdndEIsQ0FBQyxDQUFDaHRCLElBQUlyQyxJQUFJcUMsRUFBRSxHQUFHLEdBQUc7WUFDbkN5MkMsUUFBUXgyQyxJQUFJLENBQUNEO1FBQ2Y7SUFDRjtJQUNBLE9BQU95MkM7QUFDVDtBQUNBLElBQUlDLGlCQUFpQixTQUFTQSxlQUFlLzRDLENBQUMsRUFBRSt1QixDQUFDLEVBQUVpcUIsU0FBUztJQUMxRCxJQUFJekgsV0FBVyxFQUFFO0lBQ2pCLElBQUssSUFBSWx2QyxJQUFJLEdBQUdBLElBQUlyQyxHQUFHcUMsSUFBSztRQUMxQixJQUFJMlQsUUFBUSxDQUFDO1FBQ2IsSUFBSXlELE1BQU0sQ0FBQ29VO1FBQ1gsSUFBSyxJQUFJb3JCLEtBQUssR0FBR0EsS0FBS0QsVUFBVWw1QyxNQUFNLEVBQUVtNUMsS0FBTTtZQUM1QyxJQUFJbDVDLElBQUlpNUMsU0FBUyxDQUFDQyxHQUFHO1lBQ3JCLElBQUlscUIsQ0FBQyxDQUFDMXNCLElBQUlyQyxJQUFJRCxFQUFFLEdBQUcwWixLQUFLO2dCQUN0QnpELFFBQVFqVztnQkFDUjBaLE1BQU1zVixDQUFDLENBQUMxc0IsSUFBSXJDLElBQUlELEVBQUU7WUFDcEI7UUFDRjtRQUNBLElBQUlpVyxRQUFRLEdBQUc7WUFDYnU3QixTQUFTanZDLElBQUksQ0FBQzBUO1FBQ2hCO0lBQ0Y7SUFDQSxJQUFLLElBQUlrakMsTUFBTSxHQUFHQSxNQUFNRixVQUFVbDVDLE1BQU0sRUFBRW81QyxNQUFPO1FBQy9DM0gsUUFBUSxDQUFDeUgsU0FBUyxDQUFDRSxJQUFJLENBQUMsR0FBR0YsU0FBUyxDQUFDRSxJQUFJO0lBQzNDO0lBQ0EsT0FBTzNIO0FBQ1Q7QUFDQSxJQUFJanBDLFNBQVMsU0FBU0EsT0FBT3RJLENBQUMsRUFBRSt1QixDQUFDLEVBQUVpcUIsU0FBUztJQUMxQyxJQUFJekgsV0FBV3dILGVBQWUvNEMsR0FBRyt1QixHQUFHaXFCO0lBQ3BDLElBQUssSUFBSUMsS0FBSyxHQUFHQSxLQUFLRCxVQUFVbDVDLE1BQU0sRUFBRW01QyxLQUFNO1FBQzVDLElBQUlFLEtBQUssRUFBRTtRQUNYLElBQUssSUFBSS9qQixJQUFJLEdBQUdBLElBQUltYyxTQUFTenhDLE1BQU0sRUFBRXMxQixJQUFLO1lBQ3hDLElBQUltYyxRQUFRLENBQUNuYyxFQUFFLEtBQUs0akIsU0FBUyxDQUFDQyxHQUFHLEVBQUU7Z0JBQ2pDRSxHQUFHNzJDLElBQUksQ0FBQzh5QjtZQUNWO1FBQ0Y7UUFDQSxJQUFJZ2tCLE9BQU8sQ0FBQztRQUNaLElBQUlDLFNBQVMsQ0FBQ3hyQjtRQUNkLElBQUssSUFBSXhyQixJQUFJLEdBQUdBLElBQUk4MkMsR0FBR3I1QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ2xDLElBQUltdUMsTUFBTTtZQUNWLElBQUssSUFBSTluQyxJQUFJLEdBQUdBLElBQUl5d0MsR0FBR3I1QyxNQUFNLEVBQUU0SSxJQUFLO2dCQUNsQzhuQyxPQUFPemhCLENBQUMsQ0FBQ29xQixFQUFFLENBQUN6d0MsRUFBRSxHQUFHMUksSUFBSW01QyxFQUFFLENBQUM5MkMsRUFBRSxDQUFDO1lBQzdCO1lBQ0EsSUFBSW11QyxNQUFNNkksUUFBUTtnQkFDaEJELE9BQU8vMkM7Z0JBQ1BnM0MsU0FBUzdJO1lBQ1g7UUFDRjtRQUNBd0ksU0FBUyxDQUFDQyxHQUFHLEdBQUdFLEVBQUUsQ0FBQ0MsS0FBSztJQUMxQjtJQUNBN0gsV0FBV3dILGVBQWUvNEMsR0FBRyt1QixHQUFHaXFCO0lBQ2hDLE9BQU96SDtBQUNUO0FBQ0EsSUFBSStILHNCQUFzQixTQUFTQSxvQkFBb0IxbEMsT0FBTztJQUM1RCxJQUFJeVAsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSXNFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBQ3RCLElBQUkzRyxPQUFPbXZCLFdBQVd2OEI7SUFFdEIsOENBQThDO0lBQzlDLElBQUlrK0IsY0FBYyxDQUFDO0lBQ25CLElBQUssSUFBSXp2QyxJQUFJLEdBQUdBLElBQUlzbEIsTUFBTTduQixNQUFNLEVBQUV1QyxJQUFLO1FBQ3JDeXZDLFdBQVcsQ0FBQ25xQixLQUFLLENBQUN0bEIsRUFBRSxDQUFDeWxCLEVBQUUsR0FBRyxHQUFHemxCO0lBQy9CO0lBRUEsdUNBQXVDO0lBRXZDLElBQUlyQyxHQUFHLHdCQUF3QjtJQUMvQixJQUFJa3hDLElBQUksbUJBQW1CO0lBQzNCLElBQUluaUIsR0FBRywrQkFBK0I7SUFDdEMsSUFBSTFsQixHQUFHLGlFQUFpRTtJQUN4RSxJQUFJd3ZDLEdBQUcsbUNBQW1DO0lBQzFDLElBQUl4cEIsR0FBRyxpQ0FBaUM7SUFFeENydkIsSUFBSTJuQixNQUFNN25CLE1BQU07SUFDaEJveEMsS0FBS2x4QyxJQUFJQTtJQUVULDJDQUEyQztJQUMzQyt1QixJQUFJLElBQUk5dUIsTUFBTWl4QztJQUNkLElBQUssSUFBSW5vQixLQUFLLEdBQUdBLEtBQUttb0IsSUFBSW5vQixLQUFNO1FBQzlCZ0csQ0FBQyxDQUFDaEcsR0FBRyxHQUFHLENBQUM4RSxVQUFVLCtEQUErRDtJQUNwRjtJQUNBLElBQUssSUFBSWxGLE1BQU0sR0FBR0EsTUFBTTNvQixHQUFHMm9CLE1BQU87UUFDaEMsSUFBSyxJQUFJamdCLElBQUksR0FBR0EsSUFBSTFJLEdBQUcwSSxJQUFLO1lBQzFCLElBQUlpZ0IsUUFBUWpnQixHQUFHO2dCQUNicW1CLENBQUMsQ0FBQ3BHLE1BQU0zb0IsSUFBSTBJLEVBQUUsR0FBRzJuQyxjQUFjcnZCLEtBQUtvUSxRQUFRLEVBQUV6SixLQUFLLENBQUNnQixJQUFJLEVBQUVoQixLQUFLLENBQUNqZixFQUFFLEVBQUVzWSxLQUFLaXZCLFVBQVU7WUFDckY7UUFDRjtJQUNGO0lBRUEseUNBQXlDO0lBQ3pDNW1DLElBQUlzdkMsY0FBYzVwQixHQUFHL04sS0FBS20zQixVQUFVO0lBQ3BDLElBQUssSUFBSWpoQixNQUFNLEdBQUdBLE1BQU1sM0IsR0FBR2szQixNQUFPO1FBQ2hDbkksQ0FBQyxDQUFDbUksTUFBTWwzQixJQUFJazNCLElBQUksR0FBRzd0QjtJQUNyQjtJQUVBLHFDQUFxQztJQUNyQ3d2QyxJQUFJLElBQUk1NEMsTUFBTWl4QztJQUNkLElBQUssSUFBSTlaLE1BQU0sR0FBR0EsTUFBTThaLElBQUk5WixNQUFPO1FBQ2pDeWhCLENBQUMsQ0FBQ3poQixJQUFJLEdBQUc7SUFDWDtJQUVBLG1DQUFtQztJQUNuQy9ILElBQUksSUFBSXB2QixNQUFNaXhDO0lBQ2QsSUFBSyxJQUFJdlosTUFBTSxHQUFHQSxNQUFNdVosSUFBSXZaLE1BQU87UUFDakN0SSxDQUFDLENBQUNzSSxJQUFJLEdBQUc7SUFDWDtJQUNBLElBQUk0aEIsTUFBTSxJQUFJdDVDLE1BQU1EO0lBQ3BCLElBQUl3NUMsS0FBSyxJQUFJdjVDLE1BQU1EO0lBQ25CLElBQUl5NUMsS0FBSyxJQUFJeDVDLE1BQU1EO0lBQ25CLElBQUssSUFBSXFvQyxNQUFNLEdBQUdBLE1BQU1yb0MsR0FBR3FvQyxNQUFPO1FBQ2hDa1IsR0FBRyxDQUFDbFIsSUFBSSxHQUFHO1FBQ1htUixFQUFFLENBQUNuUixJQUFJLEdBQUc7UUFDVm9SLEVBQUUsQ0FBQ3BSLElBQUksR0FBRztJQUNaO0lBQ0EsSUFBSXRvQyxJQUFJLElBQUlFLE1BQU1ELElBQUlnaEIsS0FBS3EzQixhQUFhO0lBQ3hDLElBQUssSUFBSTVNLE1BQU0sR0FBR0EsTUFBTTFyQyxFQUFFRCxNQUFNLEVBQUUyckMsTUFBTztRQUN2QzFyQyxDQUFDLENBQUMwckMsSUFBSSxHQUFHO0lBQ1g7SUFDQSxJQUFJdFU7SUFDSixJQUFLQSxPQUFPLEdBQUdBLE9BQU9uVyxLQUFLZ3ZCLGFBQWEsRUFBRTdZLE9BQVE7UUFDaEQsd0JBQXdCO1FBRXhCLGlDQUFpQztRQUNqQyxJQUFLLElBQUl1aUIsTUFBTSxHQUFHQSxNQUFNMTVDLEdBQUcwNUMsTUFBTztZQUNoQyxJQUFJamdDLE1BQU0sQ0FBQ29VLFVBQ1Q4ckIsT0FBTyxDQUFDOXJCLFVBQ1J1ckIsT0FBTyxDQUFDLEdBQ1JRLEtBQUs7WUFDUCxJQUFLLElBQUl0dUIsS0FBSyxHQUFHQSxLQUFLdHJCLEdBQUdzckIsS0FBTTtnQkFDN0JpdUIsR0FBRyxDQUFDanVCLEdBQUcsR0FBR3V0QixDQUFDLENBQUNhLE1BQU0xNUMsSUFBSXNyQixHQUFHO2dCQUN6QnN1QixLQUFLdnFCLENBQUMsQ0FBQ3FxQixNQUFNMTVDLElBQUlzckIsR0FBRyxHQUFHeUQsQ0FBQyxDQUFDMnFCLE1BQU0xNUMsSUFBSXNyQixHQUFHO2dCQUN0QyxJQUFJc3VCLE1BQU1uZ0MsS0FBSztvQkFDYmtnQyxPQUFPbGdDO29CQUNQQSxNQUFNbWdDO29CQUNOUixPQUFPOXRCO2dCQUNULE9BQU8sSUFBSXN1QixLQUFLRCxNQUFNO29CQUNwQkEsT0FBT0M7Z0JBQ1Q7WUFDRjtZQUNBLElBQUssSUFBSXRPLE1BQU0sR0FBR0EsTUFBTXRyQyxHQUFHc3JDLE1BQU87Z0JBQ2hDdU4sQ0FBQyxDQUFDYSxNQUFNMTVDLElBQUlzckMsSUFBSSxHQUFHLENBQUMsSUFBSXRxQixLQUFLbzNCLE9BQU8sSUFBS3JwQixDQUFBQSxDQUFDLENBQUMycUIsTUFBTTE1QyxJQUFJc3JDLElBQUksR0FBRzd4QixHQUFFLElBQUt1SCxLQUFLbzNCLE9BQU8sR0FBR21CLEdBQUcsQ0FBQ2pPLElBQUk7WUFDNUY7WUFDQXVOLENBQUMsQ0FBQ2EsTUFBTTE1QyxJQUFJbzVDLEtBQUssR0FBRyxDQUFDLElBQUlwNEIsS0FBS28zQixPQUFPLElBQUtycEIsQ0FBQUEsQ0FBQyxDQUFDMnFCLE1BQU0xNUMsSUFBSW81QyxLQUFLLEdBQUdPLElBQUcsSUFBSzM0QixLQUFLbzNCLE9BQU8sR0FBR21CLEdBQUcsQ0FBQ0gsS0FBSztRQUNoRztRQUVBLCtCQUErQjtRQUMvQixJQUFLLElBQUlTLE1BQU0sR0FBR0EsTUFBTTc1QyxHQUFHNjVDLE1BQU87WUFDaEMsSUFBSXJKLE1BQU07WUFDVixJQUFLLElBQUlzSixNQUFNLEdBQUdBLE1BQU05NUMsR0FBRzg1QyxNQUFPO2dCQUNoQ1AsR0FBRyxDQUFDTyxJQUFJLEdBQUd6cUIsQ0FBQyxDQUFDeXFCLE1BQU05NUMsSUFBSTY1QyxJQUFJO2dCQUMzQkwsRUFBRSxDQUFDTSxJQUFJLEdBQUdsMUMsS0FBSzZVLEdBQUcsQ0FBQyxHQUFHby9CLENBQUMsQ0FBQ2lCLE1BQU05NUMsSUFBSTY1QyxJQUFJO2dCQUN0Q3JKLE9BQU9nSixFQUFFLENBQUNNLElBQUk7WUFDaEI7WUFDQXRKLE9BQU9nSixFQUFFLENBQUNLLElBQUk7WUFDZEwsRUFBRSxDQUFDSyxJQUFJLEdBQUdoQixDQUFDLENBQUNnQixNQUFNNzVDLElBQUk2NUMsSUFBSTtZQUMxQnJKLE9BQU9nSixFQUFFLENBQUNLLElBQUk7WUFDZCxJQUFLLElBQUlFLE1BQU0sR0FBR0EsTUFBTS81QyxHQUFHKzVDLE1BQU87Z0JBQ2hDMXFCLENBQUMsQ0FBQzBxQixNQUFNLzVDLElBQUk2NUMsSUFBSSxHQUFHLENBQUMsSUFBSTc0QixLQUFLbzNCLE9BQU8sSUFBSXh6QyxLQUFLK1UsR0FBRyxDQUFDLEdBQUc2MkIsTUFBTWdKLEVBQUUsQ0FBQ08sSUFBSSxJQUFJLzRCLEtBQUtvM0IsT0FBTyxHQUFHbUIsR0FBRyxDQUFDUSxJQUFJO1lBQzlGO1lBQ0ExcUIsQ0FBQyxDQUFDd3FCLE1BQU03NUMsSUFBSTY1QyxJQUFJLEdBQUcsQ0FBQyxJQUFJNzRCLEtBQUtvM0IsT0FBTyxJQUFLNUgsQ0FBQUEsTUFBTWdKLEVBQUUsQ0FBQ0ssSUFBSSxJQUFJNzRCLEtBQUtvM0IsT0FBTyxHQUFHbUIsR0FBRyxDQUFDTSxJQUFJO1FBQ25GO1FBRUEsd0JBQXdCO1FBQ3hCLElBQUl6OUIsSUFBSTtRQUNSLElBQUssSUFBSTQ5QixPQUFPLEdBQUdBLE9BQU9oNkMsR0FBR2c2QyxPQUFRO1lBQ25DLElBQUlDLElBQUk1cUIsQ0FBQyxDQUFDMnFCLE9BQU9oNkMsSUFBSWc2QyxLQUFLLEdBQUduQixDQUFDLENBQUNtQixPQUFPaDZDLElBQUlnNkMsS0FBSyxHQUFHLElBQUksSUFBSTtZQUMxRGo2QyxDQUFDLENBQUNvM0IsT0FBT25XLEtBQUtxM0IsYUFBYSxHQUFHcjRDLElBQUlnNkMsS0FBSyxHQUFHQztZQUMxQzc5QixLQUFLNjlCO1FBQ1A7UUFDQSxJQUFJNzlCLElBQUksS0FBTSthLENBQUFBLFFBQVFuVyxLQUFLcTNCLGFBQWEsR0FBRyxLQUFLbGhCLFFBQVFuVyxLQUFLZ3ZCLGFBQWEsR0FBRyxJQUFJO1lBQy9FLElBQUlrSyxPQUFPO1lBQ1gsSUFBSyxJQUFJQyxPQUFPLEdBQUdBLE9BQU9uNkMsR0FBR202QyxPQUFRO2dCQUNuQ1YsRUFBRSxDQUFDVSxLQUFLLEdBQUc7Z0JBQ1gsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1wNUIsS0FBS3EzQixhQUFhLEVBQUUrQixNQUFPO29CQUNqRFgsRUFBRSxDQUFDVSxLQUFLLElBQUlwNkMsQ0FBQyxDQUFDcTZDLE1BQU1wNkMsSUFBSW02QyxLQUFLO2dCQUMvQjtnQkFDQSxJQUFJVixFQUFFLENBQUNVLEtBQUssS0FBSyxLQUFLVixFQUFFLENBQUNVLEtBQUssS0FBS241QixLQUFLcTNCLGFBQWEsRUFBRTtvQkFDckQ2QjtnQkFDRjtZQUNGO1lBQ0EsSUFBSUEsU0FBU2w2QyxHQUFHO2dCQUVkO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsdUNBQXVDO0lBQ3ZDLElBQUlxNkMsbUJBQW1CekIsY0FBYzU0QyxHQUFHNjRDLEdBQUd4cEI7SUFFM0MsMkJBQTJCO0lBQzNCLElBQUlpckIsaUJBQWlCaHlDLE9BQU90SSxHQUFHK3VCLEdBQUdzckI7SUFDbEMsSUFBSTlJLFdBQVcsQ0FBQztJQUNoQixJQUFLLElBQUluYyxJQUFJLEdBQUdBLElBQUlpbEIsaUJBQWlCdjZDLE1BQU0sRUFBRXMxQixJQUFLO1FBQ2hEbWMsUUFBUSxDQUFDOEksZ0JBQWdCLENBQUNqbEIsRUFBRSxDQUFDLEdBQUcsRUFBRTtJQUNwQztJQUNBLElBQUssSUFBSW1sQixPQUFPLEdBQUdBLE9BQU81eUIsTUFBTTduQixNQUFNLEVBQUV5NkMsT0FBUTtRQUM5QyxJQUFJMTdCLE1BQU1pekIsV0FBVyxDQUFDbnFCLEtBQUssQ0FBQzR5QixLQUFLLENBQUN6eUIsRUFBRSxHQUFHO1FBQ3ZDLElBQUkweUIsZUFBZUYsY0FBYyxDQUFDejdCLElBQUk7UUFDdEMsSUFBSTI3QixnQkFBZ0IsTUFBTTtZQUN4QixzRkFBc0Y7WUFDdEZqSixRQUFRLENBQUNpSixhQUFhLENBQUNsNEMsSUFBSSxDQUFDcWxCLEtBQUssQ0FBQzR5QixLQUFLO1FBQ3pDO0lBQ0Y7SUFDQSxJQUFJeEMsY0FBYyxJQUFJOTNDLE1BQU1vNkMsaUJBQWlCdjZDLE1BQU07SUFDbkQsSUFBSyxJQUFJMDFDLEtBQUssR0FBR0EsS0FBSzZFLGlCQUFpQnY2QyxNQUFNLEVBQUUwMUMsS0FBTTtRQUNuRHVDLFdBQVcsQ0FBQ3ZDLEdBQUcsR0FBR255QixHQUFHcmUsVUFBVSxDQUFDdXNDLFFBQVEsQ0FBQzhJLGdCQUFnQixDQUFDN0UsR0FBRyxDQUFDO0lBQ2hFO0lBQ0EsT0FBT3VDO0FBQ1Q7QUFDQSxJQUFJMEMsd0JBQXdCO0lBQzFCbkIscUJBQXFCQTtJQUNyQm9CLElBQUlwQjtBQUNOO0FBRUEsSUFBSXFCLHFCQUFxQjk1QixXQUFXO0lBQ2xDekwsTUFBTXZTO0lBQ05va0IsVUFBVTtBQUNaO0FBQ0EsSUFBSTJ6QixXQUFXO0lBQ2JDLFlBQVksU0FBU0EsV0FBV2puQyxPQUFPO1FBQ3JDLElBQUksQ0FBQ3RQLFlBQVlzUCxVQUFVO1lBQ3pCLElBQUl2TixPQUFPRDtZQUNYd04sVUFBVTtnQkFDUndCLE1BQU0vTyxJQUFJLENBQUMsRUFBRTtnQkFDYjRnQixVQUFVNWdCLElBQUksQ0FBQyxFQUFFO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJeTBDLHNCQUFzQkgsbUJBQW1CL21DLFVBQzNDd0IsT0FBTzBsQyxvQkFBb0IxbEMsSUFBSSxFQUMvQjZSLFdBQVc2ekIsb0JBQW9CN3pCLFFBQVE7UUFDekMsSUFBSWtHLE9BQU8sSUFBSTtRQUNmLElBQUk0dEIsUUFBUTtRQUNaLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUk5bEMsTUFBTThsQyxjQUFjaDNDLE9BQU9rUixRQUFRLElBQUksQ0FBQzJOLE1BQU0sQ0FBQzNOLEtBQUssQ0FBQyxFQUFFLENBQUMwUyxFQUFFLEtBQUsxUyxJQUFJLENBQUMsRUFBRSxDQUFDMFMsRUFBRTtRQUM3RSxJQUFJSCxRQUFRLENBQUM7UUFDYixJQUFJdEMsUUFBUSxDQUFDO1FBQ2IsSUFBSTRCLFVBQVU7WUFDWmtHLEtBQUtuSyxPQUFPLENBQUMsU0FBVTVCLEdBQUc7Z0JBQ3hCLElBQUkwRyxLQUFLMUcsSUFBSTBHLEVBQUU7Z0JBQ2YsSUFBSTFHLElBQUlvRSxNQUFNLElBQUk7b0JBQ2hCLElBQUkyMUIsTUFBTS81QixJQUFJcXJCLFFBQVEsQ0FBQztvQkFDdkIsSUFBSTJPLE9BQU9oNkIsSUFBSXNyQixTQUFTLENBQUM7b0JBQ3pCLElBQUkyTyxLQUFLRixNQUFNQztvQkFDZixJQUFJRSxLQUFLRixPQUFPRDtvQkFDaEIsSUFBSUUsTUFBTSxHQUFHO3dCQUNYLElBQUlMLE9BQU9ELFFBQVE7NkJBQVVDLFFBQVFsekI7b0JBQ3ZDLE9BQU8sSUFBSXd6QixNQUFNLEdBQUc7d0JBQ2xCLElBQUlMLFFBQVFGLFFBQVE7NkJBQVVFLFNBQVNuekI7b0JBQ3pDLE9BQU8sSUFBSXd6QixLQUFLLEtBQUtELEtBQUssR0FBRzt3QkFDM0JOLFFBQVE7b0JBQ1Y7b0JBQ0FwekIsS0FBSyxDQUFDRyxHQUFHLEdBQUcsRUFBRTtvQkFDZDFHLElBQUl5dEIsUUFBUSxHQUFHN3JCLE9BQU8sQ0FBQyxTQUFVampCLENBQUM7d0JBQ2hDLElBQUlBLEVBQUV3N0MsTUFBTSxJQUFJNXpCLEtBQUssQ0FBQ0csR0FBRyxDQUFDeGxCLElBQUksQ0FBQ3ZDLEVBQUUrbkIsRUFBRTtvQkFDckM7Z0JBQ0YsT0FBTztvQkFDTHpDLEtBQUssQ0FBQ3lDLEdBQUcsR0FBRzt3QkFBQ2psQjt3QkFBV3VlLElBQUl1QyxNQUFNLEdBQUdtRSxFQUFFO3FCQUFHO2dCQUM1QztZQUNGO1FBQ0YsT0FBTztZQUNMcUYsS0FBS25LLE9BQU8sQ0FBQyxTQUFVNUIsR0FBRztnQkFDeEIsSUFBSTBHLEtBQUsxRyxJQUFJMEcsRUFBRTtnQkFDZixJQUFJMUcsSUFBSW9FLE1BQU0sSUFBSTtvQkFDaEIsSUFBSW9JLElBQUl4TSxJQUFJK3FCLE1BQU0sQ0FBQztvQkFDbkIsSUFBSXZlLElBQUksR0FBRzt3QkFDVCxJQUFJLENBQUNvdEIsT0FBT0EsUUFBUWx6Qjs2QkFBUSxJQUFJLENBQUNtekIsUUFBUUEsU0FBU256Qjs2QkFBUWl6QixRQUFRO29CQUNwRTtvQkFDQXB6QixLQUFLLENBQUNHLEdBQUcsR0FBRyxFQUFFO29CQUNkMUcsSUFBSXNILGNBQWMsR0FBRzFGLE9BQU8sQ0FBQyxTQUFVampCLENBQUM7d0JBQ3RDLE9BQU80bkIsS0FBSyxDQUFDRyxHQUFHLENBQUN4bEIsSUFBSSxDQUFDdkMsRUFBRStuQixFQUFFO29CQUM1QjtnQkFDRixPQUFPO29CQUNMekMsS0FBSyxDQUFDeUMsR0FBRyxHQUFHO3dCQUFDMUcsSUFBSXNDLE1BQU0sR0FBR29FLEVBQUU7d0JBQUkxRyxJQUFJdUMsTUFBTSxHQUFHbUUsRUFBRTtxQkFBRztnQkFDcEQ7WUFDRjtRQUNGO1FBQ0EsSUFBSTFRLFNBQVM7WUFDWG9RLE9BQU87WUFDUGcwQixPQUFPMzRDO1FBQ1Q7UUFDQSxJQUFJazRDLE9BQU8sT0FBTzNqQzthQUFZLElBQUk2akMsVUFBVUQsT0FBTztZQUNqRCxJQUFJL3pCLFVBQVU7Z0JBQ1osSUFBSWkwQixlQUFlRCxVQUFVQyxhQUFhO29CQUN4QyxPQUFPOWpDO2dCQUNUO2dCQUNBOGpDLGNBQWNEO1lBQ2hCLE9BQU87Z0JBQ0wsSUFBSUMsZUFBZUQsVUFBVUMsZUFBZUYsU0FBU0UsYUFBYTtvQkFDaEUsT0FBTzlqQztnQkFDVCxPQUFPLElBQUksQ0FBQzhqQyxhQUFhO29CQUN2QkEsY0FBY0Q7Z0JBQ2hCO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSSxDQUFDQyxhQUFhQSxjQUFjL3RCLElBQUksQ0FBQyxFQUFFLENBQUNyRixFQUFFO1FBQzVDO1FBQ0EsSUFBSTJ6QixPQUFPLFNBQVNBLEtBQUt4MEMsQ0FBQztZQUN4QixJQUFJeTBDLGNBQWN6MEM7WUFDbEIsSUFBSTAwQyxVQUFVO2dCQUFDMTBDO2FBQUU7WUFDakIsSUFBSTIwQyxLQUFLQyxTQUFTQztZQUNsQixNQUFPbjBCLEtBQUssQ0FBQyt6QixZQUFZLENBQUM1N0MsTUFBTSxDQUFFO2dCQUNoQzg3QyxNQUFNajBCLEtBQUssQ0FBQyt6QixZQUFZLENBQUN6ekIsS0FBSztnQkFDOUI0ekIsVUFBVXgyQixLQUFLLENBQUN1MkIsSUFBSSxDQUFDLEVBQUU7Z0JBQ3ZCRSxVQUFVejJCLEtBQUssQ0FBQ3UyQixJQUFJLENBQUMsRUFBRTtnQkFDdkIsSUFBSUYsZUFBZUksU0FBUztvQkFDMUJuMEIsS0FBSyxDQUFDbTBCLFFBQVEsR0FBR24wQixLQUFLLENBQUNtMEIsUUFBUSxDQUFDLzRCLE1BQU0sQ0FBQyxTQUFVaGpCLENBQUM7d0JBQ2hELE9BQU9BLEtBQUs2N0M7b0JBQ2Q7b0JBQ0FGLGNBQWNJO2dCQUNoQixPQUFPLElBQUksQ0FBQzcwQixZQUFZeTBCLGVBQWVHLFNBQVM7b0JBQzlDbDBCLEtBQUssQ0FBQ2swQixRQUFRLEdBQUdsMEIsS0FBSyxDQUFDazBCLFFBQVEsQ0FBQzk0QixNQUFNLENBQUMsU0FBVWhqQixDQUFDO3dCQUNoRCxPQUFPQSxLQUFLNjdDO29CQUNkO29CQUNBRixjQUFjRztnQkFDaEI7Z0JBQ0FGLFFBQVE1ekIsT0FBTyxDQUFDNnpCO2dCQUNoQkQsUUFBUTV6QixPQUFPLENBQUMyekI7WUFDbEI7WUFDQSxPQUFPQztRQUNUO1FBQ0EsSUFBSUgsUUFBUSxFQUFFO1FBQ2QsSUFBSUcsVUFBVSxFQUFFO1FBQ2hCQSxVQUFVRixLQUFLUDtRQUNmLE1BQU9TLFFBQVE3N0MsTUFBTSxJQUFJLEVBQUc7WUFDMUIsSUFBSTZuQixLQUFLLENBQUNnMEIsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDNzdDLE1BQU0sSUFBSSxHQUFHO2dCQUNqQzA3QyxNQUFNenpCLE9BQU8sQ0FBQ29GLEtBQUtnaUIsY0FBYyxDQUFDd00sUUFBUTF6QixLQUFLO2dCQUMvQ3V6QixNQUFNenpCLE9BQU8sQ0FBQ29GLEtBQUtnaUIsY0FBYyxDQUFDd00sUUFBUTF6QixLQUFLO1lBQ2pELE9BQU87Z0JBQ0wwekIsVUFBVUYsS0FBS0UsUUFBUTF6QixLQUFLLElBQUk0QyxNQUFNLENBQUM4d0I7WUFDekM7UUFDRjtRQUNBSCxNQUFNenpCLE9BQU8sQ0FBQ29GLEtBQUtnaUIsY0FBYyxDQUFDd00sUUFBUTF6QixLQUFLLE1BQU0sYUFBYTtRQUVsRSxJQUFLLElBQUkyRixLQUFLakcsTUFBTztZQUNuQixJQUFJQSxLQUFLLENBQUNpRyxFQUFFLENBQUM5dEIsTUFBTSxFQUFFO2dCQUNuQixPQUFPc1g7WUFDVDtRQUNGO1FBQ0FBLE9BQU9vUSxLQUFLLEdBQUc7UUFDZnBRLE9BQU9va0MsS0FBSyxHQUFHLElBQUksQ0FBQ3hzQixLQUFLLENBQUN3c0IsT0FBTztRQUNqQyxPQUFPcGtDO0lBQ1Q7QUFDRjtBQUVBLElBQUkya0MsNEJBQTRCLFNBQVNBO0lBQ3ZDLElBQUk1dUIsT0FBTyxJQUFJO0lBQ2YsSUFBSXhGLFFBQVEsQ0FBQztJQUNiLElBQUlHLEtBQUs7SUFDVCxJQUFJazBCLFlBQVk7SUFDaEIsSUFBSWhrQixhQUFhLEVBQUU7SUFDbkIsSUFBSWlrQixRQUFRLEVBQUU7SUFDZCxJQUFJQyxlQUFlLENBQUM7SUFDcEIsSUFBSUMsaUJBQWlCLFNBQVNBLGVBQWUvbkMsQ0FBQyxFQUFFeUosQ0FBQztRQUMvQyxJQUFJeGIsSUFBSTQ1QyxNQUFNbjhDLE1BQU0sR0FBRztRQUN2QixJQUFJczhDLFNBQVMsRUFBRTtRQUNmLElBQUlya0IsWUFBWTVLLEtBQUs2QixLQUFLO1FBQzFCLE1BQU9pdEIsS0FBSyxDQUFDNTVDLEVBQUUsQ0FBQytSLENBQUMsSUFBSUEsS0FBSzZuQyxLQUFLLENBQUM1NUMsRUFBRSxDQUFDd2IsQ0FBQyxJQUFJQSxFQUFHO1lBQ3pDdStCLE9BQU85NUMsSUFBSSxDQUFDMjVDLE1BQU0vekIsR0FBRyxHQUFHZSxJQUFJO1lBQzVCNW1CO1FBQ0Y7UUFDQSs1QyxPQUFPOTVDLElBQUksQ0FBQzI1QyxNQUFNL3pCLEdBQUcsR0FBR2UsSUFBSTtRQUM1Qm16QixPQUFPcDVCLE9BQU8sQ0FBQyxTQUFVaUcsSUFBSTtZQUMzQixJQUFJN0IsaUJBQWlCNkIsS0FBSzdCLGNBQWMsR0FBR3ljLFlBQVksQ0FBQzFXO1lBQ3hENEssVUFBVXBJLEtBQUssQ0FBQzFHO1lBQ2hCN0IsZUFBZXBFLE9BQU8sQ0FBQyxTQUFVZ0csSUFBSTtnQkFDbkMsSUFBSXF6QixTQUFTcnpCLEtBQUtsQixFQUFFO2dCQUNwQixJQUFJWSxpQkFBaUJNLEtBQUtOLGNBQWMsR0FBR21iLFlBQVksQ0FBQzFXO2dCQUN4RDRLLFVBQVVwSSxLQUFLLENBQUMzRztnQkFDaEIsSUFBSSxDQUFDckIsS0FBSyxDQUFDMDBCLE9BQU8sQ0FBQ0MsU0FBUyxFQUFFO29CQUM1QnZrQixVQUFVcEksS0FBSyxDQUFDakg7Z0JBQ2xCLE9BQU87b0JBQ0xxUCxVQUFVcEksS0FBSyxDQUFDakgsZUFBZTNGLE1BQU0sQ0FBQyxTQUFVa0csSUFBSTt3QkFDbEQsT0FBT0EsS0FBS3dFLE1BQU07b0JBQ3BCO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBdUssV0FBVzExQixJQUFJLENBQUN5MUI7SUFDbEI7SUFDQSxJQUFJd2tCLHFCQUFxQixTQUFTQyxrQkFBa0JwbkMsSUFBSSxFQUFFc21DLFdBQVcsRUFBRW4yQixNQUFNO1FBQzNFLElBQUluUSxTQUFTbVEsUUFBUXkyQixhQUFhO1FBQ2xDcjBCLEtBQUssQ0FBQyt6QixZQUFZLEdBQUc7WUFDbkI1ekIsSUFBSUE7WUFDSjIwQixLQUFLMzBCO1lBQ0x3MEIsV0FBVztRQUNiO1FBQ0EsSUFBSWozQixRQUFROEgsS0FBS2dpQixjQUFjLENBQUN1TSxhQUFhaHpCLGNBQWMsR0FBR21iLFlBQVksQ0FBQzFXO1FBQzNFLElBQUk5SCxNQUFNMUMsSUFBSSxPQUFPLEdBQUc7WUFDdEJxVixXQUFXMTFCLElBQUksQ0FBQzZxQixLQUFLNkIsS0FBSyxDQUFDN0IsS0FBS2dpQixjQUFjLENBQUN1TTtRQUNqRCxPQUFPO1lBQ0wsSUFBSWdCLFVBQVVDLFVBQVVDLGFBQWFDO1lBQ3JDeDNCLE1BQU1yQyxPQUFPLENBQUMsU0FBVWlHLElBQUk7Z0JBQzFCeXpCLFdBQVd6ekIsS0FBS3ZGLE1BQU0sR0FBR29FLEVBQUU7Z0JBQzNCNjBCLFdBQVcxekIsS0FBS3RGLE1BQU0sR0FBR21FLEVBQUU7Z0JBQzNCODBCLGNBQWNGLGFBQWFoQixjQUFjaUIsV0FBV0Q7Z0JBQ3BELElBQUlFLGdCQUFnQnIzQixRQUFRO29CQUMxQnMzQixTQUFTNXpCLEtBQUtuQixFQUFFO29CQUNoQixJQUFJLENBQUNvMEIsWUFBWSxDQUFDVyxPQUFPLEVBQUU7d0JBQ3pCWCxZQUFZLENBQUNXLE9BQU8sR0FBRzt3QkFDdkJaLE1BQU0zNUMsSUFBSSxDQUFDOzRCQUNUOFIsR0FBR3NuQzs0QkFDSDc5QixHQUFHKytCOzRCQUNIM3pCLE1BQU1BO3dCQUNSO29CQUNGO29CQUNBLElBQUksQ0FBRTJ6QixDQUFBQSxlQUFlajFCLEtBQUksR0FBSTt3QkFDM0I0MEIsbUJBQW1Cbm5DLE1BQU13bkMsYUFBYWxCO3dCQUN0Qy96QixLQUFLLENBQUMrekIsWUFBWSxDQUFDZSxHQUFHLEdBQUc3M0MsS0FBSytVLEdBQUcsQ0FBQ2dPLEtBQUssQ0FBQyt6QixZQUFZLENBQUNlLEdBQUcsRUFBRTkwQixLQUFLLENBQUNpMUIsWUFBWSxDQUFDSCxHQUFHO3dCQUNoRixJQUFJOTBCLEtBQUssQ0FBQyt6QixZQUFZLENBQUM1ekIsRUFBRSxJQUFJSCxLQUFLLENBQUNpMUIsWUFBWSxDQUFDSCxHQUFHLEVBQUU7NEJBQ25EOTBCLEtBQUssQ0FBQyt6QixZQUFZLENBQUNZLFNBQVMsR0FBRzs0QkFDL0JILGVBQWVULGFBQWFrQjt3QkFDOUI7b0JBQ0YsT0FBTzt3QkFDTGoxQixLQUFLLENBQUMrekIsWUFBWSxDQUFDZSxHQUFHLEdBQUc3M0MsS0FBSytVLEdBQUcsQ0FBQ2dPLEtBQUssQ0FBQyt6QixZQUFZLENBQUNlLEdBQUcsRUFBRTkwQixLQUFLLENBQUNpMUIsWUFBWSxDQUFDOTBCLEVBQUU7b0JBQ2pGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0FxRixLQUFLbkssT0FBTyxDQUFDLFNBQVU1QixHQUFHO1FBQ3hCLElBQUlBLElBQUlvRSxNQUFNLElBQUk7WUFDaEIsSUFBSTYyQixTQUFTajdCLElBQUkwRyxFQUFFO1lBQ25CLElBQUksQ0FBRXUwQixDQUFBQSxVQUFVMTBCLEtBQUksR0FBSTtnQkFDdEJxMEIsWUFBWTtnQkFDWk8sbUJBQW1CRixRQUFRQTtnQkFDM0IxMEIsS0FBSyxDQUFDMDBCLE9BQU8sQ0FBQ0MsU0FBUyxHQUFHTixZQUFZO1lBQ3hDO1FBQ0Y7SUFDRjtJQUNBLElBQUljLGNBQWNqOEMsT0FBTzRILElBQUksQ0FBQ2tmLE9BQU81RSxNQUFNLENBQUMsU0FBVStFLEVBQUU7UUFDdEQsT0FBT0gsS0FBSyxDQUFDRyxHQUFHLENBQUN3MEIsU0FBUztJQUM1QixHQUFHem9DLEdBQUcsQ0FBQyxTQUFVaVUsRUFBRTtRQUNqQixPQUFPcUYsS0FBS2dpQixjQUFjLENBQUNybkI7SUFDN0I7SUFDQSxPQUFPO1FBQ0wyUCxLQUFLdEssS0FBSzZCLEtBQUssQ0FBQzh0QjtRQUNoQjlrQixZQUFZQTtJQUNkO0FBQ0Y7QUFDQSxJQUFJK2tCLDhCQUE4QjtJQUNoQ2hCLDJCQUEyQkE7SUFDM0JpQixNQUFNakI7SUFDTmtCLEtBQUtsQjtJQUNMbUIscUNBQXFDbkI7QUFDdkM7QUFFQSxJQUFJb0IsMEJBQTBCLFNBQVNBO0lBQ3JDLElBQUlod0IsT0FBTyxJQUFJO0lBQ2YsSUFBSXhGLFFBQVEsQ0FBQztJQUNiLElBQUkzUixRQUFRO0lBQ1osSUFBSWdpQixhQUFhLEVBQUU7SUFDbkIsSUFBSWlrQixRQUFRLEVBQUU7SUFDZCxJQUFJeGtCLE1BQU10SyxLQUFLNkIsS0FBSyxDQUFDN0I7SUFDckIsSUFBSWl3QiwyQkFBMkIsU0FBU0Msd0JBQXdCQyxZQUFZO1FBQzFFckIsTUFBTTM1QyxJQUFJLENBQUNnN0M7UUFDWDMxQixLQUFLLENBQUMyMUIsYUFBYSxHQUFHO1lBQ3BCdG5DLE9BQU9BO1lBQ1B5bUMsS0FBS3ptQztZQUNMdW5DLFVBQVU7UUFDWjtRQUNBLElBQUk3MEIsaUJBQWlCeUUsS0FBS2dpQixjQUFjLENBQUNtTyxjQUFjNTBCLGNBQWMsR0FBR21iLFlBQVksQ0FBQzFXO1FBQ3JGekUsZUFBZTFGLE9BQU8sQ0FBQyxTQUFVaUcsSUFBSTtZQUNuQyxJQUFJdTBCLGVBQWV2MEIsS0FBS3RGLE1BQU0sR0FBR21FLEVBQUU7WUFDbkMsSUFBSTAxQixpQkFBaUJGLGNBQWM7Z0JBQ2pDLElBQUksQ0FBRUUsQ0FBQUEsZ0JBQWdCNzFCLEtBQUksR0FBSTtvQkFDNUJ5MUIseUJBQXlCSTtnQkFDM0I7Z0JBQ0EsSUFBSSxDQUFDNzFCLEtBQUssQ0FBQzYxQixhQUFhLENBQUNELFFBQVEsRUFBRTtvQkFDakM1MUIsS0FBSyxDQUFDMjFCLGFBQWEsQ0FBQ2IsR0FBRyxHQUFHNzNDLEtBQUsrVSxHQUFHLENBQUNnTyxLQUFLLENBQUMyMUIsYUFBYSxDQUFDYixHQUFHLEVBQUU5MEIsS0FBSyxDQUFDNjFCLGFBQWEsQ0FBQ2YsR0FBRztnQkFDckY7WUFDRjtRQUNGO1FBQ0EsSUFBSTkwQixLQUFLLENBQUMyMUIsYUFBYSxDQUFDdG5DLEtBQUssS0FBSzJSLEtBQUssQ0FBQzIxQixhQUFhLENBQUNiLEdBQUcsRUFBRTtZQUN6RCxJQUFJZ0IsaUJBQWlCdHdCLEtBQUs2QixLQUFLO1lBQy9CLE9BQVM7Z0JBQ1AsSUFBSXF0QixTQUFTSixNQUFNL3pCLEdBQUc7Z0JBQ3RCdTFCLGVBQWU5dEIsS0FBSyxDQUFDeEMsS0FBS2dpQixjQUFjLENBQUNrTjtnQkFDekMxMEIsS0FBSyxDQUFDMDBCLE9BQU8sQ0FBQ0ksR0FBRyxHQUFHOTBCLEtBQUssQ0FBQzIxQixhQUFhLENBQUN0bkMsS0FBSztnQkFDN0MyUixLQUFLLENBQUMwMEIsT0FBTyxDQUFDa0IsUUFBUSxHQUFHO2dCQUN6QixJQUFJbEIsV0FBV2lCLGNBQWM7b0JBQzNCO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJSSxpQkFBaUJELGVBQWV4dkIsU0FBUyxDQUFDd3ZCO1lBQzlDLElBQUkxbEIsWUFBWTBsQixlQUFlOXRCLEtBQUssQ0FBQyt0QjtZQUNyQzFsQixXQUFXMTFCLElBQUksQ0FBQ3kxQjtZQUNoQk4sTUFBTUEsSUFBSWttQixVQUFVLENBQUM1bEI7UUFDdkI7SUFDRjtJQUNBNUssS0FBS25LLE9BQU8sQ0FBQyxTQUFVNUIsR0FBRztRQUN4QixJQUFJQSxJQUFJb0UsTUFBTSxJQUFJO1lBQ2hCLElBQUk2MkIsU0FBU2o3QixJQUFJMEcsRUFBRTtZQUNuQixJQUFJLENBQUV1MEIsQ0FBQUEsVUFBVTEwQixLQUFJLEdBQUk7Z0JBQ3RCeTFCLHlCQUF5QmY7WUFDM0I7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMNWtCLEtBQUtBO1FBQ0xPLFlBQVlBO0lBQ2Q7QUFDRjtBQUNBLElBQUk0bEIsNEJBQTRCO0lBQzlCVCx5QkFBeUJBO0lBQ3pCVSxLQUFLVjtJQUNMVyxNQUFNWDtJQUNOWSxtQ0FBbUNaO0FBQ3JDO0FBRUEsSUFBSWEsV0FBVyxDQUFDO0FBQ2hCO0lBQUM3MEI7SUFBVTZEO0lBQVVpQztJQUFVYztJQUFVNEI7SUFBVWtCO0lBQVV3RDtJQUFVaVU7SUFBVXVCO0lBQVU0QjtJQUFVZTtJQUFVeUQ7SUFBb0IrRDtJQUFhZ0M7SUFBMEJ5QztJQUF1Qkc7SUFBVW1DO0lBQTZCYTtDQUEwQixDQUFDNTZCLE9BQU8sQ0FBQyxTQUFVaTdCLEtBQUs7SUFDeFI1MUMsT0FBTzIxQyxVQUFVQztBQUNuQjtBQUVBOzs7O0FBSUEsR0FFQSxzQ0FBc0MsR0FDdEMsSUFBSUMsZ0JBQWdCLEdBQUcseUJBQXlCO0FBQ2hELElBQUlDLGtCQUFrQixHQUFHLHlCQUF5QjtBQUNsRCxJQUFJQyxpQkFBaUIsR0FBRyx5QkFBeUI7QUFFakQsZ0NBQWdDLEdBQ2hDLElBQUlDLE9BQU8sU0FBU0MsSUFBSUMsUUFBUTtJQUM5Qiw0REFBNEQsR0FDNUQsSUFBSSxDQUFFLEtBQUksWUFBWUYsSUFBRyxHQUFJLE9BQU8sSUFBSUEsS0FBS0U7SUFFN0MsdUJBQXVCLEdBQ3ZCLElBQUksQ0FBQ3oyQixFQUFFLEdBQUc7SUFDVixJQUFJLENBQUMwMkIsS0FBSyxHQUFHTixlQUFlLG1CQUFtQjtJQUMvQyxJQUFJLENBQUNPLFlBQVksR0FBRzU3QyxXQUFXLG1CQUFtQixJQUFHLGdDQUFnQztJQUNyRixJQUFJLENBQUM2N0MsWUFBWSxHQUFHNzdDLFdBQVcsbUJBQW1CLElBQUcsZ0NBQWdDO0lBQ3JGLElBQUksQ0FBQzg3QyxXQUFXLEdBQUcsRUFBRSxFQUFFLHNCQUFzQjtJQUM3QyxJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFLEVBQUUsc0JBQXNCO0lBRTVDLCtDQUErQyxHQUMvQyxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNYOTRDLE1BQU0sSUFBSSxDQUFDQSxJQUFJLENBQUN3QyxJQUFJLENBQUMsSUFBSTtJQUMzQjtJQUVBLHdDQUF3QyxHQUN4QyxJQUFJLE9BQU9nMkMsYUFBYSxZQUFZQSxTQUFTMThDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDaTlDLE9BQU8sQ0FBQ3YyQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQ3cyQyxNQUFNLENBQUN4MkMsSUFBSSxDQUFDLElBQUk7QUFDeEc7QUFFQSx5QkFBeUIsR0FDekI4MUMsS0FBS245QyxTQUFTLEdBQUc7SUFDZiwrQkFBK0IsR0FDL0I0OUMsU0FBUyxTQUFTQSxRQUFRcDlDLEtBQUs7UUFDN0IsT0FBT3M5QyxRQUFRLElBQUksRUFBRWIsaUJBQWlCLGdCQUFnQno4QztJQUN4RDtJQUNBcTlDLFFBQVEsU0FBU0EsT0FBT3I5QyxLQUFLO1FBQzNCLE9BQU9zOUMsUUFBUSxJQUFJLEVBQUVaLGdCQUFnQixnQkFBZ0IxOEM7SUFDdkQ7SUFDQSxtREFBbUQsR0FDbkRxRSxNQUFNLFNBQVNBLEtBQUs0NEMsV0FBVyxFQUFFQyxVQUFVO1FBQ3pDLElBQUlLLE9BQU8sSUFBSTtRQUNmLElBQUluOUMsT0FBTyxJQUFJdThDLFFBQVEseUJBQXlCO1FBQ2hEWSxLQUFLTixXQUFXLENBQUNyOEMsSUFBSSxDQUFDNDhDLFNBQVNQLGFBQWE3OEMsTUFBTSxhQUFhLCtCQUErQjtRQUM5Rm05QyxLQUFLTCxVQUFVLENBQUN0OEMsSUFBSSxDQUFDNDhDLFNBQVNOLFlBQVk5OEMsTUFBTSxZQUFZLCtCQUErQjtRQUMzRnE5QyxRQUFRRjtRQUNSLE9BQU9uOUMsS0FBSys4QyxLQUFLLEVBQUUsOEJBQThCO0lBQ25EO0FBQ0Y7QUFFQSx1QkFBdUIsR0FDdkIsSUFBSUcsVUFBVSxTQUFTQSxRQUFRQyxJQUFJLEVBQUVULEtBQUssRUFBRXI3QyxJQUFJLEVBQUV6QixLQUFLO0lBQ3JELElBQUl1OUMsS0FBS1QsS0FBSyxLQUFLTixlQUFlO1FBQ2hDZSxLQUFLVCxLQUFLLEdBQUdBLE9BQU8sb0NBQW9DO1FBQ3hEUyxJQUFJLENBQUM5N0MsS0FBSyxHQUFHekIsT0FBTyxvQ0FBb0M7UUFDeER5OUMsUUFBUUY7SUFDVjtJQUNBLE9BQU9BO0FBQ1Q7QUFFQSwwQkFBMEIsR0FDMUIsSUFBSUUsVUFBVSxTQUFTQSxRQUFRRixJQUFJO0lBQ2pDLElBQUlBLEtBQUtULEtBQUssS0FBS0wsaUJBQWlCaUIsaUJBQWlCSCxNQUFNLGVBQWVBLEtBQUtSLFlBQVk7U0FBTyxJQUFJUSxLQUFLVCxLQUFLLEtBQUtKLGdCQUFnQmdCLGlCQUFpQkgsTUFBTSxjQUFjQSxLQUFLUCxZQUFZO0FBQzdMO0FBRUEsd0NBQXdDLEdBQ3hDLElBQUlVLG1CQUFtQixTQUFTQSxpQkFBaUJILElBQUksRUFBRTk3QyxJQUFJLEVBQUV6QixLQUFLO0lBQ2hFLDZCQUE2QixHQUM3QiwyQkFBMkIsR0FFM0IsOEJBQThCLEdBQzlCLElBQUl1OUMsSUFBSSxDQUFDOTdDLEtBQUssQ0FBQ3JELE1BQU0sS0FBSyxHQUFHO0lBRTdCLDZDQUE2QyxHQUM3QyxJQUFJdS9DLFdBQVdKLElBQUksQ0FBQzk3QyxLQUFLO0lBQ3pCODdDLElBQUksQ0FBQzk3QyxLQUFLLEdBQUcsRUFBRSxFQUFFLG9DQUFvQztJQUNyRCxJQUFJMFcsT0FBTyxTQUFTQTtRQUNsQixJQUFLLElBQUl4WCxJQUFJLEdBQUdBLElBQUlnOUMsU0FBU3YvQyxNQUFNLEVBQUV1QyxJQUFLZzlDLFFBQVEsQ0FBQ2g5QyxFQUFFLENBQUNYLFFBQVEseUJBQXlCO0lBQ3pGO0lBRUEsc0NBQXNDLEdBQUcsOEJBQThCLEdBQ3ZFLElBQUksT0FBTzQ5QyxpQkFBaUIsWUFBWUEsYUFBYXpsQztTQUFXZSxXQUFXZixNQUFNO0FBQ25GO0FBRUEsa0NBQWtDLEdBQ2xDLElBQUlxbEMsV0FBVyxTQUFTQSxTQUFTSyxFQUFFLEVBQUV6OUMsSUFBSSxFQUFFdXhDLE1BQU07SUFDL0MsT0FBTyxTQUFVM3hDLEtBQUs7UUFDcEIsSUFBSSxPQUFPNjlDLE9BQU8sWUFBWSwyQ0FBMkMsR0FDdkV6OUMsSUFBSSxDQUFDdXhDLE9BQU8sQ0FBQ3h4QyxJQUFJLENBQUNDLE1BQU1KLFFBQVEsb0NBQW9DO2FBQU87WUFDM0UsSUFBSTBWO1lBQ0osSUFBSTtnQkFDRkEsU0FBU21vQyxHQUFHNzlDO1lBQ2QsRUFBcUQsT0FBTzNCLEdBQUc7Z0JBQzdEK0IsS0FBS2k5QyxNQUFNLENBQUNoL0MsSUFBSSwyQkFBMkI7Z0JBQzNDO1lBQ0Y7WUFDQXkvQyxTQUFTMTlDLE1BQU1zVixTQUFTLDJCQUEyQjtRQUNyRDtJQUNGO0FBQ0Y7QUFFQSxvQ0FBb0MsR0FBRyx1QkFBdUIsR0FDOUQsSUFBSW9vQyxXQUFXLFNBQVNDLFFBQVEzNUMsT0FBTyxFQUFFc08sQ0FBQztJQUN4Qyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FDeEQsSUFBSXRPLFlBQVlzTyxLQUFLdE8sUUFBUSs0QyxLQUFLLEtBQUt6cUMsR0FBRztRQUN4Q3RPLFFBQVFpNUMsTUFBTSxDQUFDLElBQUl6K0MsVUFBVTtRQUM3QjtJQUNGO0lBRUE7NERBQzBELEdBQzFELElBQUl5RjtJQUNKLElBQUloRCxRQUFRcVIsT0FBTyxZQUFZQSxNQUFNLFFBQVEsT0FBT0EsTUFBTSxZQUFZO1FBQ3BFLElBQUk7WUFDRnJPLE9BQU9xTyxFQUFFck8sSUFBSTtRQUNmLEVBQXFDLE9BQU9oRyxHQUFHO1lBQzdDK0YsUUFBUWk1QyxNQUFNLENBQUNoL0MsSUFBSSwyQkFBMkI7WUFDOUM7UUFDRjtJQUNGO0lBRUE7aURBQytDLEdBQy9DLElBQUksT0FBT2dHLFNBQVMsWUFBWTtRQUM5QixJQUFJMjVDLFdBQVc7UUFDZixJQUFJO1lBQ0YsaUNBQWlDLEdBQUcsMkJBQTJCLEdBQy9EMzVDLEtBQUtsRSxJQUFJLENBQUN1UyxHQUFHLG9CQUFvQixHQUFHLDZCQUE2QixHQUNqRSxTQUFVeUosQ0FBQztnQkFDVCxJQUFJNmhDLFVBQVU7Z0JBQ2RBLFdBQVcsTUFBTSw2QkFBNkI7Z0JBQzlDLElBQUk3aEMsTUFBTXpKLEdBQUcsdUJBQXVCLEdBQ2xDdE8sUUFBUWk1QyxNQUFNLENBQUMsSUFBSXorQyxVQUFVO3FCQUFpQ2svQyxTQUFTMTVDLFNBQVMrWDtZQUNwRixHQUFHLG1CQUFtQixHQUFHLDZCQUE2QixHQUN0RCxTQUFVamUsQ0FBQztnQkFDVCxJQUFJOC9DLFVBQVU7Z0JBQ2RBLFdBQVcsTUFBTSw2QkFBNkI7Z0JBQzlDNTVDLFFBQVFpNUMsTUFBTSxDQUFDbi9DO1lBQ2pCO1FBQ0YsRUFBRSxPQUFPRyxHQUFHO1lBQ1YsSUFBSSxDQUFDMi9DLFVBQVUsNkJBQTZCLEdBQzFDNTVDLFFBQVFpNUMsTUFBTSxDQUFDaC9DLElBQUksNkJBQTZCO1FBQ3BEO1FBQ0E7SUFDRjtJQUVBLHlCQUF5QixHQUN6QitGLFFBQVFnNUMsT0FBTyxDQUFDMXFDLElBQUksa0NBQWtDO0FBQ3hEO0FBRUEsa0NBQWtDO0FBQ2xDaXFDLEtBQUtyNEIsR0FBRyxHQUFHLFNBQVUyNUIsRUFBRTtJQUNyQixPQUFPLElBQUl0QixLQUFLLFNBQVV1QixVQUFVLEVBQUVDLFNBQVM7UUFDN0MsSUFBSUMsT0FBTyxJQUFJNy9DLE1BQU0wL0MsR0FBRzcvQyxNQUFNO1FBQzlCLElBQUlpZ0QsWUFBWTtRQUNoQixJQUFJakIsVUFBVSxTQUFTQSxRQUFRejhDLENBQUMsRUFBRTJmLEdBQUc7WUFDbkM4OUIsSUFBSSxDQUFDejlDLEVBQUUsR0FBRzJmO1lBQ1YrOUI7WUFDQSxJQUFJQSxjQUFjSixHQUFHNy9DLE1BQU0sRUFBRTtnQkFDM0I4L0MsV0FBV0U7WUFDYjtRQUNGO1FBQ0EsSUFBSyxJQUFJejlDLElBQUksR0FBR0EsSUFBSXM5QyxHQUFHNy9DLE1BQU0sRUFBRXVDLElBQUs7WUFDakMsVUFBVUEsQ0FBQztnQkFDVixJQUFJZ0gsSUFBSXMyQyxFQUFFLENBQUN0OUMsRUFBRTtnQkFDYixJQUFJMjlDLFlBQVkzMkMsS0FBSyxRQUFRQSxFQUFFdEQsSUFBSSxJQUFJO2dCQUN2QyxJQUFJaTZDLFdBQVc7b0JBQ2IzMkMsRUFBRXRELElBQUksQ0FBQyxTQUFVaWMsR0FBRzt3QkFDbEI4OEIsUUFBUXo4QyxHQUFHMmY7b0JBQ2IsR0FBRyxTQUFVNG5CLEdBQUc7d0JBQ2RpVyxVQUFValc7b0JBQ1o7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJNW5CLE1BQU0zWTtvQkFDVnkxQyxRQUFRejhDLEdBQUcyZjtnQkFDYjtZQUNGLEdBQUczZjtRQUNMO0lBQ0Y7QUFDRjtBQUNBZzhDLEtBQUtvQixPQUFPLEdBQUcsU0FBVXo5QixHQUFHO0lBQzFCLE9BQU8sSUFBSXE4QixLQUFLLFNBQVVvQixPQUFPLEVBQUVWLE1BQU07UUFDdkNVLFFBQVF6OUI7SUFDVjtBQUNGO0FBQ0FxOEIsS0FBS1UsTUFBTSxHQUFHLFNBQVUvOEIsR0FBRztJQUN6QixPQUFPLElBQUlxOEIsS0FBSyxTQUFVb0IsT0FBTyxFQUFFVixNQUFNO1FBQ3ZDQSxPQUFPLzhCO0lBQ1Q7QUFDRjtBQUNBLElBQUlpK0IsWUFBWSxPQUFPQyxZQUFZLGNBQWNBLFVBQVU3QixNQUFNLCtCQUErQjtBQUVoRyxJQUFJOEIsWUFBWSxTQUFTQSxVQUFVeDhCLE1BQU0sRUFBRTNDLElBQUksRUFBRW8vQixLQUFLO0lBQ3BELElBQUlDLFNBQVNsN0MsS0FBS3dlO0lBQ2xCLElBQUkyOEIsUUFBUSxDQUFDRDtJQUNiLElBQUl6OEIsS0FBSyxJQUFJLENBQUMzZSxRQUFRLEdBQUdvRCxPQUFPO1FBQzlCazRDLFVBQVU7SUFDWixHQUFHdi9CLE1BQU1vL0I7SUFDVHg4QixHQUFHRCxNQUFNLEdBQUdBO0lBQ1pDLEdBQUdPLEtBQUssR0FBR1AsR0FBR08sS0FBSyxJQUFJUCxHQUFHK0MsR0FBRztJQUM3Qi9DLEdBQUc0OEIsT0FBTyxHQUFHO0lBQ2I1OEIsR0FBRzY4QixPQUFPLEdBQUc7SUFDYjc4QixHQUFHODhCLE1BQU0sR0FBRztJQUNaOThCLEdBQUcrOEIsUUFBUSxHQUFHO0lBQ2QvOEIsR0FBR2c5QixRQUFRLEdBQUc7SUFDZGg5QixHQUFHaTlCLFNBQVMsR0FBRyxFQUFFO0lBQ2pCajlCLEdBQUdrOUIsTUFBTSxHQUFHLEVBQUU7SUFDZCxJQUFJbDlCLEdBQUdtOUIsUUFBUSxJQUFJOThDLEtBQUsyZixHQUFHbTlCLFFBQVEsR0FBRztRQUNwQ245QixHQUFHaTlCLFNBQVMsQ0FBQ3YrQyxJQUFJLENBQUNzaEIsR0FBR205QixRQUFRO0lBQy9CO0lBQ0EsSUFBSVQsT0FBTztRQUNULElBQUl6aEMsTUFBTThFLE9BQU9FLFFBQVE7UUFDekJELEdBQUdvOUIsYUFBYSxHQUFHcDlCLEdBQUdvOUIsYUFBYSxJQUFJO1lBQ3JDNXNDLEdBQUd5SyxJQUFJekssQ0FBQztZQUNSeUosR0FBR2dCLElBQUloQixDQUFDO1FBQ1Y7UUFDQStGLEdBQUdxOUIsVUFBVSxHQUFHcjlCLEdBQUdxOUIsVUFBVSxJQUFJdDlCLE9BQU9OLEVBQUUsR0FBR2MsS0FBSyxHQUFHKzhCLHNCQUFzQixDQUFDdjlCLFFBQVFDLEdBQUdPLEtBQUs7SUFDOUY7SUFDQSxJQUFJazhCLFFBQVE7UUFDVixJQUFJaDZCLE1BQU0xQyxPQUFPMEMsR0FBRztRQUNwQnpDLEdBQUd1OUIsUUFBUSxHQUFHO1lBQ1ovc0MsR0FBR2lTLElBQUlqUyxDQUFDO1lBQ1J5SixHQUFHd0ksSUFBSXhJLENBQUM7UUFDVjtRQUNBK0YsR0FBR3c5QixTQUFTLEdBQUd6OUIsT0FBTzJDLElBQUk7SUFDNUI7SUFFQSxzQ0FBc0M7SUFDdEMsSUFBSSxDQUFDeG1CLE1BQU0sR0FBRztJQUNkLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSTtBQUNoQjtBQUNBLElBQUl1aEQsUUFBUWxCLFVBQVVqL0MsU0FBUztBQUMvQm1ILE9BQU9nNUMsT0FBTztJQUNacjlDLGdCQUFnQixTQUFTQTtRQUN2QixPQUFPO0lBQ1Q7SUFDQXM5QyxNQUFNLFNBQVNBO1FBQ2IsSUFBSTE5QixLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSSxDQUFDMmUsR0FBRzg4QixNQUFNLEVBQUU7WUFDZCxrQ0FBa0M7WUFDbEMsSUFBSXAzQztZQUNKLElBQUlpNEMsT0FBTzM5QixHQUFHRCxNQUFNLENBQUMxZSxRQUFRLENBQUMrZixTQUFTO1lBQ3ZDLElBQUlwQixHQUFHc0IsS0FBSyxFQUFFO2dCQUNaNWIsSUFBSWk0QyxLQUFLcjhCLEtBQUs7WUFDaEIsT0FBTztnQkFDTDViLElBQUlpNEMsS0FBS3Q4QixPQUFPO1lBQ2xCO1lBQ0EzYixFQUFFaEgsSUFBSSxDQUFDLElBQUk7WUFFWCxpQ0FBaUM7WUFDakMsSUFBSStCLG9CQUFvQnVmLEdBQUdELE1BQU0sR0FBRztnQkFDbENDLEdBQUdELE1BQU0sQ0FBQ04sRUFBRSxHQUFHbStCLGtCQUFrQixDQUFDNTlCLEdBQUdELE1BQU07WUFDN0M7WUFDQUMsR0FBRzg4QixNQUFNLEdBQUc7UUFDZDtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLE1BQU0sU0FBU0E7UUFDYixJQUFJNzlCLEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUV0QixhQUFhO1FBQ2IsSUFBSTJlLEdBQUdnOUIsUUFBUSxLQUFLLEdBQUc7WUFDckJoOUIsR0FBR2c5QixRQUFRLEdBQUc7UUFDaEI7UUFDQWg5QixHQUFHNjhCLE9BQU8sR0FBRztRQUNiNzhCLEdBQUc0OEIsT0FBTyxHQUFHLE9BQU8sd0NBQXdDO1FBQzVENThCLEdBQUc4OUIsT0FBTyxHQUFHO1FBQ2IsSUFBSSxDQUFDSixJQUFJO1FBRVQsaURBQWlEO1FBRWpELE9BQU8sSUFBSTtJQUNiO0lBQ0FiLFNBQVMsU0FBU0E7UUFDaEIsT0FBTyxJQUFJLENBQUN4N0MsUUFBUSxDQUFDdzdDLE9BQU87SUFDOUI7SUFDQTc1QyxPQUFPLFNBQVNBO1FBQ2QsSUFBSWdkLEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QjJlLEdBQUcrOEIsUUFBUSxHQUFHO1FBQ2QvOEIsR0FBRzQ4QixPQUFPLEdBQUcsT0FBTyx3Q0FBd0M7UUFDNUQ1OEIsR0FBRzg5QixPQUFPLEdBQUc7UUFDYixJQUFJLENBQUNKLElBQUk7UUFFVCwrREFBK0Q7UUFFL0QsT0FBTyxJQUFJO0lBQ2I7SUFDQVgsVUFBVSxTQUFTQTtRQUNqQixPQUFPLElBQUksQ0FBQzE3QyxRQUFRLENBQUMwN0MsUUFBUTtJQUMvQjtJQUNBZ0IsT0FBTyxTQUFTQTtRQUNkLElBQUkvOUIsS0FBSyxJQUFJLENBQUMzZSxRQUFRO1FBQ3RCMmUsR0FBRzY4QixPQUFPLEdBQUc7UUFDYjc4QixHQUFHNDhCLE9BQU8sR0FBRztRQUNiLE9BQU8sSUFBSTtJQUNiO0lBQ0FvQixNQUFNLFNBQVNBO1FBQ2IsSUFBSWgrQixLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIyZSxHQUFHNjhCLE9BQU8sR0FBRztRQUNiNzhCLEdBQUc0OEIsT0FBTyxHQUFHO1FBQ2I1OEIsR0FBRzg5QixPQUFPLEdBQUcsTUFBTSxzQ0FBc0M7UUFFekQsT0FBTyxJQUFJO0lBQ2I7SUFDQUcsUUFBUSxTQUFTQTtRQUNmLE9BQU8sSUFBSSxDQUFDakIsUUFBUSxDQUFDO0lBQ3ZCO0lBQ0FrQixhQUFhLFNBQVNBO1FBQ3BCLE9BQU8sSUFBSSxDQUFDbEIsUUFBUSxDQUFDO0lBQ3ZCO0lBQ0FubUMsTUFBTSxTQUFTQSxLQUFLamEsQ0FBQztRQUNuQixJQUFJb2pCLEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QixJQUFJekUsTUFBTXFDLFdBQVc7WUFDbkIsT0FBTytnQixHQUFHZzlCLFFBQVEsR0FBR2g5QixHQUFHMjhCLFFBQVE7UUFDbEMsT0FBTztZQUNMLE9BQU8sSUFBSSxDQUFDSyxRQUFRLENBQUNwZ0QsSUFBSW9qQixHQUFHMjhCLFFBQVE7UUFDdEM7SUFDRjtJQUNBSyxVQUFVLFNBQVNBLFNBQVN2M0MsQ0FBQztRQUMzQixJQUFJdWEsS0FBSyxJQUFJLENBQUMzZSxRQUFRO1FBQ3RCLElBQUk4OEMsYUFBYW4rQixHQUFHNjhCLE9BQU87UUFDM0IsSUFBSXAzQyxNQUFNeEcsV0FBVztZQUNuQixPQUFPK2dCLEdBQUdnOUIsUUFBUTtRQUNwQixPQUFPO1lBQ0wsSUFBSW1CLFlBQVk7Z0JBQ2QsSUFBSSxDQUFDSixLQUFLO1lBQ1o7WUFDQS85QixHQUFHZzlCLFFBQVEsR0FBR3YzQztZQUNkdWEsR0FBRzQ4QixPQUFPLEdBQUc7WUFDYixJQUFJdUIsWUFBWTtnQkFDZCxJQUFJLENBQUNOLElBQUk7WUFDWDtRQUNGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQU8sV0FBVyxTQUFTQTtRQUNsQixPQUFPLElBQUksQ0FBQy84QyxRQUFRLENBQUMyN0MsUUFBUSxLQUFLO0lBQ3BDO0lBQ0FyMUIsU0FBUyxTQUFTQTtRQUNoQixJQUFJM0gsS0FBSyxJQUFJLENBQUMzZSxRQUFRO1FBQ3RCLElBQUk4OEMsYUFBYW4rQixHQUFHNjhCLE9BQU87UUFDM0IsSUFBSXNCLFlBQVk7WUFDZCxJQUFJLENBQUNKLEtBQUs7UUFDWjtRQUNBLzlCLEdBQUdnOUIsUUFBUSxHQUFHLElBQUloOUIsR0FBR2c5QixRQUFRO1FBQzdCaDlCLEdBQUc0OEIsT0FBTyxHQUFHO1FBQ2IsSUFBSXlCLE9BQU8sU0FBU0EsS0FBS3BpRCxDQUFDLEVBQUVzSSxDQUFDO1lBQzNCLElBQUkrNUMsTUFBTXQrQixFQUFFLENBQUMvakIsRUFBRTtZQUNmLElBQUlxaUQsT0FBTyxNQUFNO2dCQUNmO1lBQ0Y7WUFDQXQrQixFQUFFLENBQUMvakIsRUFBRSxHQUFHK2pCLEVBQUUsQ0FBQ3piLEVBQUU7WUFDYnliLEVBQUUsQ0FBQ3piLEVBQUUsR0FBRys1QztRQUNWO1FBQ0FELEtBQUssUUFBUTtRQUNiQSxLQUFLLE9BQU87UUFDWkEsS0FBSyxZQUFZO1FBRWpCLGNBQWM7UUFDZCxJQUFJcitCLEdBQUdPLEtBQUssRUFBRTtZQUNaLElBQUssSUFBSTloQixJQUFJLEdBQUdBLElBQUl1aEIsR0FBR08sS0FBSyxDQUFDcmtCLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3hDLElBQUk4L0MsT0FBT3YrQixHQUFHTyxLQUFLLENBQUM5aEIsRUFBRTtnQkFDdEIsSUFBSWMsT0FBT2cvQyxLQUFLaC9DLElBQUk7Z0JBQ3BCLElBQUlpL0MsaUJBQWlCeCtCLEdBQUdxOUIsVUFBVSxDQUFDOTlDLEtBQUs7Z0JBQ3hDeWdCLEdBQUdxOUIsVUFBVSxDQUFDOTlDLEtBQUssR0FBR2cvQztnQkFDdEJ2K0IsR0FBR08sS0FBSyxDQUFDOWhCLEVBQUUsR0FBRysvQztZQUNoQjtRQUNGO1FBQ0EsSUFBSUwsWUFBWTtZQUNkLElBQUksQ0FBQ04sSUFBSTtRQUNYO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQTM3QyxTQUFTLFNBQVNBLFFBQVE2TyxJQUFJO1FBQzVCLElBQUlpUCxLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSXViO1FBQ0osT0FBUTdMO1lBQ04sS0FBSztnQkFDSDZMLE1BQU1vRCxHQUFHazlCLE1BQU07Z0JBQ2Y7WUFDRjtZQUNBLEtBQUs7WUFDTCxLQUFLO2dCQUNIdGdDLE1BQU1vRCxHQUFHaTlCLFNBQVM7UUFDdEI7UUFDQSxPQUFPLElBQUlaLFVBQVUsU0FBVVIsT0FBTyxFQUFFVixNQUFNO1lBQzVDditCLElBQUlsZSxJQUFJLENBQUM7Z0JBQ1BtOUM7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBNEIsTUFBTU4sUUFBUSxHQUFHTSxNQUFNVyxTQUFTO0FBQ2hDWCxNQUFNZ0IsR0FBRyxHQUFHaEIsTUFBTUksSUFBSTtBQUN0QkosTUFBTWlCLE9BQU8sR0FBR2pCLE1BQU1aLE9BQU87QUFFN0IsSUFBSThCLFdBQVc7SUFDYkMsVUFBVSxTQUFTQTtRQUNqQixPQUFPLFNBQVNDO1lBQ2QsSUFBSWg4QyxRQUFPLElBQUk7WUFDZixJQUFJaThDLGtCQUFrQmo4QyxNQUFLM0csTUFBTSxLQUFLK0M7WUFDdEMsSUFBSW1qQixNQUFNMDhCLGtCQUFrQmo4QyxRQUFPO2dCQUFDQTthQUFLLEVBQUUsaUNBQWlDO1lBQzVFLElBQUk0YyxLQUFLLElBQUksQ0FBQ3BlLFFBQVEsQ0FBQ29lLEVBQUUsSUFBSSxJQUFJO1lBQ2pDLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLElBQUk7Z0JBQ3RCLE9BQU87WUFDVDtZQUNBLElBQUl2aEMsTUFBTTRFLEdBQUcsQ0FBQyxFQUFFO1lBQ2hCLElBQUk1RSxLQUFLO2dCQUNQLE9BQU9BLElBQUluYyxRQUFRLENBQUMrZixTQUFTLENBQUNDLE9BQU8sQ0FBQ25sQixNQUFNLEdBQUc7WUFDakQ7UUFDRjtJQUNGO0lBQ0EsV0FBVztJQUVYOGlELFlBQVksU0FBU0E7UUFDbkIsT0FBTyxTQUFTQztZQUNkLElBQUlwOEMsUUFBTyxJQUFJO1lBQ2YsSUFBSWk4QyxrQkFBa0JqOEMsTUFBSzNHLE1BQU0sS0FBSytDO1lBQ3RDLElBQUltakIsTUFBTTA4QixrQkFBa0JqOEMsUUFBTztnQkFBQ0E7YUFBSyxFQUFFLGlDQUFpQztZQUM1RSxJQUFJNGMsS0FBSyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFLElBQUksSUFBSTtZQUNqQyxJQUFJLENBQUNBLEdBQUdzL0IsWUFBWSxJQUFJO2dCQUN0QixPQUFPLElBQUk7WUFDYjtZQUNBLElBQUssSUFBSXRnRCxJQUFJLEdBQUdBLElBQUkyakIsSUFBSWxtQixNQUFNLEVBQUV1QyxJQUFLO2dCQUNuQyxJQUFJK2UsTUFBTTRFLEdBQUcsQ0FBQzNqQixFQUFFO2dCQUNoQitlLElBQUluYyxRQUFRLENBQUMrZixTQUFTLENBQUNFLEtBQUssR0FBRyxFQUFFO1lBQ25DO1lBQ0EsT0FBTyxJQUFJO1FBQ2I7SUFDRjtJQUNBLGFBQWE7SUFFYjQ5QixPQUFPLFNBQVNBO1FBQ2QsT0FBTyxTQUFTQyxVQUFVdG9DLElBQUksRUFBRXNtQyxRQUFRO1lBQ3RDLElBQUkxOUIsS0FBSyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFLElBQUksSUFBSTtZQUNqQyxJQUFJLENBQUNBLEdBQUdzL0IsWUFBWSxJQUFJO2dCQUN0QixPQUFPLElBQUk7WUFDYjtZQUNBLE9BQU8sSUFBSSxDQUFDSyxPQUFPLENBQUM7Z0JBQ2xCRixPQUFPcm9DO2dCQUNQOGxDLFVBQVU5bEM7Z0JBQ1ZzbUMsVUFBVUE7WUFDWjtRQUNGO0lBQ0Y7SUFDQSxRQUFRO0lBRVJrQyxnQkFBZ0IsU0FBU0E7UUFDdkIsT0FBTyxTQUFTQyxtQkFBbUJ6b0MsSUFBSSxFQUFFc21DLFFBQVE7WUFDL0MsSUFBSTE5QixLQUFLLElBQUksQ0FBQ3BlLFFBQVEsQ0FBQ29lLEVBQUUsSUFBSSxJQUFJO1lBQ2pDLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLElBQUk7Z0JBQ3RCLE9BQU8sSUFBSTtZQUNiO1lBQ0EsT0FBTyxJQUFJLENBQUMzOUIsU0FBUyxDQUFDO2dCQUNwQjg5QixPQUFPcm9DO2dCQUNQOGxDLFVBQVU5bEM7Z0JBQ1ZzbUMsVUFBVUE7WUFDWjtRQUNGO0lBQ0Y7SUFDQSxRQUFRO0lBRVIvN0IsV0FBVyxTQUFTQTtRQUNsQixPQUFPLFNBQVNtK0IsY0FBY0MsVUFBVSxFQUFFOS9CLE1BQU07WUFDOUMsSUFBSTdjLFFBQU8sSUFBSTtZQUNmLElBQUlpOEMsa0JBQWtCajhDLE1BQUszRyxNQUFNLEtBQUsrQztZQUN0QyxJQUFJbWpCLE1BQU0wOEIsa0JBQWtCajhDLFFBQU87Z0JBQUNBO2FBQUssRUFBRSxpQ0FBaUM7WUFDNUUsSUFBSTRjLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRSxJQUFJLElBQUk7WUFDakMsSUFBSWc5QixTQUFTLENBQUNxQztZQUNkLElBQUlXLFNBQVMsQ0FBQ2hEO1lBQ2QsSUFBSSxDQUFDaDlCLEdBQUdzL0IsWUFBWSxJQUFJO2dCQUN0QixPQUFPLElBQUk7WUFDYjtZQUNBLElBQUl4K0IsUUFBUWQsR0FBR2MsS0FBSztZQUNwQmkvQixhQUFhLzZDLE9BQU8sQ0FBQyxHQUFHKzZDLFlBQVk5L0I7WUFDcEMsSUFBSWdnQyxrQkFBa0J6aUQsT0FBTzRILElBQUksQ0FBQzI2QyxZQUFZdGpELE1BQU0sS0FBSztZQUN6RCxJQUFJd2pELGlCQUFpQjtnQkFDbkIsT0FBTyxJQUFJbkQsVUFBVW42QixHQUFHLENBQUMsRUFBRSxFQUFFbzlCLGFBQWEscUJBQXFCO1lBQ2pFO1lBQ0EsSUFBSUEsV0FBVzdDLFFBQVEsS0FBSzE5QyxXQUFXO2dCQUNyQ3VnRCxXQUFXN0MsUUFBUSxHQUFHO1lBQ3hCO1lBQ0EsT0FBUTZDLFdBQVc3QyxRQUFRO2dCQUN6QixLQUFLO29CQUNINkMsV0FBVzdDLFFBQVEsR0FBRztvQkFDdEI7Z0JBQ0YsS0FBSztvQkFDSDZDLFdBQVc3QyxRQUFRLEdBQUc7b0JBQ3RCO1lBQ0o7WUFDQSxJQUFJOEMsUUFBUTtnQkFDVkQsV0FBV2ovQixLQUFLLEdBQUdBLE1BQU1vL0IsWUFBWSxDQUFDSCxXQUFXai9CLEtBQUssSUFBSWkvQixXQUFXejhCLEdBQUc7Z0JBQ3hFeThCLFdBQVd6OEIsR0FBRyxHQUFHOWpCO1lBQ25CO1lBQ0EsSUFBSXdnRCxVQUFVRCxXQUFXajlCLGdCQUFnQixJQUFJLE1BQU07Z0JBQ2pELElBQUlDLE9BQU9nOUIsV0FBV2o5QixnQkFBZ0I7Z0JBQ3RDLElBQUlFLE1BQU1oRCxHQUFHZ0QsR0FBRztnQkFDaEIsSUFBSUMsT0FBT2pELEdBQUdpRCxJQUFJO2dCQUNsQjg4QixXQUFXdi9CLFFBQVEsR0FBR3dVLHdCQUF3QmpTLE1BQU1FLE1BQU1EO1lBQzVEO1lBRUEsK0JBQStCO1lBQy9CLElBQUlnNkIsVUFBVStDLFdBQVdJLEtBQUssSUFBSSxNQUFNO2dCQUN0QyxJQUFJQSxRQUFRSixXQUFXSSxLQUFLO2dCQUM1QixJQUFJQyxRQUFRcGdDLEdBQUdnRCxHQUFHO2dCQUNsQis4QixXQUFXLzhCLEdBQUcsR0FBRztvQkFDZmpTLEdBQUdxdkMsTUFBTXJ2QyxDQUFDLEdBQUdvdkMsTUFBTXB2QyxDQUFDO29CQUNwQnlKLEdBQUc0bEMsTUFBTTVsQyxDQUFDLEdBQUcybEMsTUFBTTNsQyxDQUFDO2dCQUN0QjtZQUNGO1lBRUEsZ0NBQWdDO1lBQ2hDLElBQUk2bEMsU0FBU04sV0FBV00sTUFBTSxJQUFJTixXQUFXTyxNQUFNO1lBQ25ELElBQUl0RCxVQUFVcUQsVUFBVSxNQUFNO2dCQUM1QixJQUFJRSxZQUFZdmdDLEdBQUd3Z0MsWUFBWSxDQUFDSCxPQUFPdjJCLElBQUksRUFBRWkyQixXQUFXOThCLElBQUk7Z0JBQzVELElBQUlzOUIsYUFBYSxNQUFNO29CQUNyQlIsV0FBVy84QixHQUFHLEdBQUd1OUI7Z0JBQ25CO1lBQ0Y7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSXZELFVBQVUrQyxXQUFXVSxHQUFHLElBQUksTUFBTTtnQkFDcEMsSUFBSUEsTUFBTVYsV0FBV1UsR0FBRztnQkFDeEIsSUFBSUMsUUFBUTFnQyxHQUFHMmdDLGNBQWMsQ0FBQ0YsSUFBSTMyQixJQUFJLElBQUkyMkIsSUFBSXIrQyxXQUFXLEVBQUVxK0MsSUFBSWhwQixPQUFPO2dCQUN0RSxJQUFJaXBCLFNBQVMsTUFBTTtvQkFDakJYLFdBQVcvOEIsR0FBRyxHQUFHMDlCLE1BQU0xOUIsR0FBRztvQkFDMUIrOEIsV0FBVzk4QixJQUFJLEdBQUd5OUIsTUFBTXo5QixJQUFJO2dCQUM5QjtZQUNGO1lBRUEsdURBQXVEO1lBQ3ZELElBQUkrNUIsVUFBVS83QyxZQUFZOCtDLFdBQVc5OEIsSUFBSSxHQUFHO2dCQUMxQyxJQUFJMjlCLEtBQUs1Z0MsR0FBRzZnQyxpQkFBaUIsQ0FBQ2QsV0FBVzk4QixJQUFJO2dCQUM3QyxJQUFJMjlCLE1BQU0sTUFBTTtvQkFDZCxJQUFJQSxHQUFHRSxNQUFNLEVBQUU7d0JBQ2JmLFdBQVc5OEIsSUFBSSxHQUFHMjlCLEdBQUczOUIsSUFBSTtvQkFDM0I7b0JBQ0EsSUFBSTI5QixHQUFHRyxNQUFNLEVBQUU7d0JBQ2JoQixXQUFXLzhCLEdBQUcsR0FBRzQ5QixHQUFHNTlCLEdBQUc7b0JBQ3pCO2dCQUNGLE9BQU87b0JBQ0wrOEIsV0FBVzk4QixJQUFJLEdBQUcsTUFBTSxnRUFBZ0U7Z0JBQzFGO1lBQ0Y7WUFDQSxPQUFPLElBQUk2NUIsVUFBVW42QixHQUFHLENBQUMsRUFBRSxFQUFFbzlCO1FBQy9CO0lBQ0Y7SUFDQSxVQUFVO0lBRVZKLFNBQVMsU0FBU0E7UUFDaEIsT0FBTyxTQUFTcUIsWUFBWWpCLFVBQVUsRUFBRTkvQixNQUFNO1lBQzVDLElBQUk3YyxRQUFPLElBQUk7WUFDZixJQUFJaThDLGtCQUFrQmo4QyxNQUFLM0csTUFBTSxLQUFLK0M7WUFDdEMsSUFBSW1qQixNQUFNMDhCLGtCQUFrQmo4QyxRQUFPO2dCQUFDQTthQUFLLEVBQUUsaUNBQWlDO1lBQzVFLElBQUk0YyxLQUFLLElBQUksQ0FBQ3BlLFFBQVEsQ0FBQ29lLEVBQUUsSUFBSSxJQUFJO1lBQ2pDLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLElBQUk7Z0JBQ3RCLE9BQU8sSUFBSTtZQUNiO1lBQ0EsSUFBSXIvQixRQUFRO2dCQUNWOC9CLGFBQWEvNkMsT0FBTyxDQUFDLEdBQUcrNkMsWUFBWTkvQjtZQUN0QztZQUVBLHNDQUFzQztZQUN0QyxJQUFLLElBQUlqaEIsSUFBSSxHQUFHQSxJQUFJMmpCLElBQUlsbUIsTUFBTSxFQUFFdUMsSUFBSztnQkFDbkMsSUFBSStlLE1BQU00RSxHQUFHLENBQUMzakIsRUFBRTtnQkFDaEIsSUFBSTZpQixRQUFROUQsSUFBSW9oQyxRQUFRLE1BQU9ZLENBQUFBLFdBQVdsK0IsS0FBSyxLQUFLcmlCLGFBQWF1Z0QsV0FBV2wrQixLQUFLO2dCQUNqRixJQUFJby9CLE1BQU1sakMsSUFBSTRELFNBQVMsQ0FBQ28rQixZQUFZbCtCLFFBQVE7b0JBQzFDQSxPQUFPO2dCQUNULElBQUlyaUI7Z0JBQ0p5aEQsSUFBSTdDLElBQUk7WUFDVjtZQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7UUFDMUI7SUFDRjtJQUNBLFVBQVU7SUFFVkcsTUFBTSxTQUFTQTtRQUNiLE9BQU8sU0FBUzJDLFNBQVMzQixVQUFVLEVBQUU0QixTQUFTO1lBQzVDLElBQUkvOUMsUUFBTyxJQUFJO1lBQ2YsSUFBSWk4QyxrQkFBa0JqOEMsTUFBSzNHLE1BQU0sS0FBSytDO1lBQ3RDLElBQUltakIsTUFBTTA4QixrQkFBa0JqOEMsUUFBTztnQkFBQ0E7YUFBSyxFQUFFLGlDQUFpQztZQUM1RSxJQUFJNGMsS0FBSyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFLElBQUksSUFBSTtZQUNqQyxJQUFJLENBQUNBLEdBQUdzL0IsWUFBWSxJQUFJO2dCQUN0QixPQUFPLElBQUk7WUFDYjtZQUNBLElBQUssSUFBSXRnRCxJQUFJLEdBQUdBLElBQUkyakIsSUFBSWxtQixNQUFNLEVBQUV1QyxJQUFLO2dCQUNuQyxJQUFJK2UsTUFBTTRFLEdBQUcsQ0FBQzNqQixFQUFFO2dCQUNoQixJQUFJdWhCLEtBQUt4QyxJQUFJbmMsUUFBUTtnQkFDckIsSUFBSXcvQyxPQUFPN2dDLEdBQUdvQixTQUFTLENBQUNDLE9BQU87Z0JBQy9CLElBQUssSUFBSXZjLElBQUksR0FBR0EsSUFBSSs3QyxLQUFLM2tELE1BQU0sRUFBRTRJLElBQUs7b0JBQ3BDLElBQUk0N0MsTUFBTUcsSUFBSSxDQUFDLzdDLEVBQUU7b0JBQ2pCLElBQUlnOEMsUUFBUUosSUFBSXIvQyxRQUFRO29CQUN4QixJQUFJdS9DLFdBQVc7d0JBQ2Isc0RBQXNEO3dCQUN0RCw2Q0FBNkM7d0JBQzdDRSxNQUFNbkUsUUFBUSxHQUFHO29CQUNuQjtnQkFDRjtnQkFFQSx1Q0FBdUM7Z0JBQ3ZDLElBQUlxQyxZQUFZO29CQUNkaC9CLEdBQUdvQixTQUFTLENBQUNFLEtBQUssR0FBRyxFQUFFO2dCQUN6QjtnQkFDQSxJQUFJLENBQUNzL0IsV0FBVztvQkFDZDVnQyxHQUFHb0IsU0FBUyxDQUFDQyxPQUFPLEdBQUcsRUFBRTtnQkFDM0I7WUFDRjtZQUVBLHdFQUF3RTtZQUN4RTVCLEdBQUdzaEMsTUFBTSxDQUFDO1lBQ1YsT0FBTyxJQUFJO1FBQ2I7SUFDRixFQUFFLE9BQU87QUFDWCxHQUFHLFNBQVM7QUFFWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUVELElBQUlDO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELG9CQUFvQixPQUFPRDtJQUMvQkMscUJBQXFCO0lBQ3JCLElBQUkxa0QsVUFBVUYsTUFBTUUsT0FBTztJQUUzQnlrRCxZQUFZemtEO0lBQ1osT0FBT3lrRDtBQUNSO0FBRUEsSUFBSUc7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsbUJBQW1CLE9BQU9EO0lBQzlCQyxvQkFBb0I7SUFDcEIsSUFBSTdrRCxVQUFVMmtELGtCQUNWdnNDLFdBQVdGO0lBRWYsd0RBQXdELEdBQ3hELElBQUk2c0MsZUFBZSxvREFDZkMsZ0JBQWdCO0lBRXBCOzs7Ozs7O0VBT0MsR0FDRCxTQUFTQyxNQUFNMWpELEtBQUssRUFBRTZDLE1BQU07UUFDMUIsSUFBSXBFLFFBQVF1QixRQUFRO1lBQ2xCLE9BQU87UUFDVDtRQUNBLElBQUlpVCxPQUFPLE9BQU9qVDtRQUNsQixJQUFJaVQsUUFBUSxZQUFZQSxRQUFRLFlBQVlBLFFBQVEsYUFDaERqVCxTQUFTLFFBQVE2VyxTQUFTN1csUUFBUTtZQUNwQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPeWpELGNBQWMvaEQsSUFBSSxDQUFDMUIsVUFBVSxDQUFDd2pELGFBQWE5aEQsSUFBSSxDQUFDMUIsVUFDcEQ2QyxVQUFVLFFBQVE3QyxTQUFTYixPQUFPMEQ7SUFDdkM7SUFFQXdnRCxTQUFTSztJQUNULE9BQU9MO0FBQ1I7QUFFQSxJQUFJTTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx1QkFBdUIsT0FBT0Q7SUFDbENDLHdCQUF3QjtJQUN4QixJQUFJeHRDLGFBQWFILHNCQUNiakQsV0FBV0Q7SUFFZix5Q0FBeUMsR0FDekMsSUFBSSt3QyxXQUFXLDBCQUNYQyxVQUFVLHFCQUNWQyxTQUFTLDhCQUNUQyxXQUFXO0lBRWY7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnQkMsR0FDRCxTQUFTQyxXQUFXbGtELEtBQUs7UUFDdkIsSUFBSSxDQUFDZ1QsU0FBU2hULFFBQVE7WUFDcEIsT0FBTztRQUNUO1FBQ0Esd0VBQXdFO1FBQ3hFLDhFQUE4RTtRQUM5RSxJQUFJd1YsTUFBTVksV0FBV3BXO1FBQ3JCLE9BQU93VixPQUFPdXVDLFdBQVd2dUMsT0FBT3d1QyxVQUFVeHVDLE9BQU9zdUMsWUFBWXR1QyxPQUFPeXVDO0lBQ3RFO0lBRUFOLGVBQWVPO0lBQ2YsT0FBT1A7QUFDUjtBQUVBLElBQUlRO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHdCQUF3QixPQUFPRDtJQUNuQ0MseUJBQXlCO0lBQ3pCLElBQUkxd0MsT0FBT0Y7SUFFWCwrQ0FBK0MsR0FDL0MsSUFBSTh3QyxhQUFhNXdDLElBQUksQ0FBQyxxQkFBcUI7SUFFM0N5d0MsY0FBY0c7SUFDZCxPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsc0JBQXNCLE9BQU9EO0lBQ2pDQyx1QkFBdUI7SUFDdkIsSUFBSUYsYUFBYUQ7SUFFakIsbURBQW1ELEdBQ25ELElBQUlLLGFBQWM7UUFDaEIsSUFBSTczQixNQUFNLFNBQVM5a0IsSUFBSSxDQUFDdThDLGNBQWNBLFdBQVd2OUMsSUFBSSxJQUFJdTlDLFdBQVd2OUMsSUFBSSxDQUFDNDlDLFFBQVEsSUFBSTtRQUNyRixPQUFPOTNCLE1BQU8sbUJBQW1CQSxNQUFPO0lBQzFDO0lBRUE7Ozs7OztFQU1DLEdBQ0QsU0FBUyszQixTQUFTenNDLElBQUk7UUFDcEIsT0FBTyxDQUFDLENBQUN1c0MsY0FBZUEsY0FBY3ZzQztJQUN4QztJQUVBb3NDLFlBQVlLO0lBQ1osT0FBT0w7QUFDUjtBQUVBLHlDQUF5QyxHQUV6QyxJQUFJTTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxzQkFBc0IsT0FBT0Q7SUFDakNDLHVCQUF1QjtJQUN2QixJQUFJRSxZQUFZcnhDLFNBQVNuVSxTQUFTO0lBRWxDLHdEQUF3RCxHQUN4RCxJQUFJeWxELGVBQWVELFVBQVV6akQsUUFBUTtJQUVyQzs7Ozs7O0VBTUMsR0FDRCxTQUFTMmpELFNBQVMvc0MsSUFBSTtRQUNwQixJQUFJQSxRQUFRLE1BQU07WUFDaEIsSUFBSTtnQkFDRixPQUFPOHNDLGFBQWE5a0QsSUFBSSxDQUFDZ1k7WUFDM0IsRUFBRSxPQUFPOVosR0FBRyxDQUFDO1lBQ2IsSUFBSTtnQkFDRixPQUFROFosT0FBTztZQUNqQixFQUFFLE9BQU85WixHQUFHLENBQUM7UUFDZjtRQUNBLE9BQU87SUFDVDtJQUVBd21ELFlBQVlLO0lBQ1osT0FBT0w7QUFDUjtBQUVBLElBQUlNO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELDBCQUEwQixPQUFPRDtJQUNyQ0MsMkJBQTJCO0lBQzNCLElBQUlsQixhQUFhTCxxQkFDYmUsV0FBV0gsb0JBQ1h6eEMsV0FBV0QsbUJBQ1hteUMsV0FBV0g7SUFFZjs7O0VBR0MsR0FDRCxJQUFJTyxlQUFlO0lBRW5CLCtDQUErQyxHQUMvQyxJQUFJQyxlQUFlO0lBRW5CLHlDQUF5QyxHQUN6QyxJQUFJUCxZQUFZcnhDLFNBQVNuVSxTQUFTLEVBQzlCMFYsY0FBYy9WLE9BQU9LLFNBQVM7SUFFbEMsd0RBQXdELEdBQ3hELElBQUl5bEQsZUFBZUQsVUFBVXpqRCxRQUFRO0lBRXJDLDhDQUE4QyxHQUM5QyxJQUFJcVIsaUJBQWlCc0MsWUFBWXRDLGNBQWM7SUFFL0MsMENBQTBDLEdBQzFDLElBQUk0eUMsYUFBYTE5QyxPQUFPLE1BQ3RCbTlDLGFBQWE5a0QsSUFBSSxDQUFDeVMsZ0JBQWdCdE4sT0FBTyxDQUFDZ2dELGNBQWMsUUFDdkRoZ0QsT0FBTyxDQUFDLDBEQUEwRCxXQUFXO0lBR2hGOzs7Ozs7O0VBT0MsR0FDRCxTQUFTbWdELGFBQWF6bEQsS0FBSztRQUN6QixJQUFJLENBQUNnVCxTQUFTaFQsVUFBVTRrRCxTQUFTNWtELFFBQVE7WUFDdkMsT0FBTztRQUNUO1FBQ0EsSUFBSTBsRCxVQUFVeEIsV0FBV2xrRCxTQUFTd2xELGFBQWFEO1FBQy9DLE9BQU9HLFFBQVFoa0QsSUFBSSxDQUFDd2pELFNBQVNsbEQ7SUFDL0I7SUFFQW1sRCxnQkFBZ0JNO0lBQ2hCLE9BQU9OO0FBQ1I7QUFFQTs7Ozs7OztDQU9DLEdBRUQsSUFBSVE7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsc0JBQXNCLE9BQU9EO0lBQ2pDQyx1QkFBdUI7SUFDdkIsU0FBU0UsU0FBU2pqRCxNQUFNLEVBQUV2RCxHQUFHO1FBQzNCLE9BQU91RCxVQUFVLE9BQU8xQixZQUFZMEIsTUFBTSxDQUFDdkQsSUFBSTtJQUNqRDtJQUVBcW1ELFlBQVlHO0lBQ1osT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHVCQUF1QixPQUFPRDtJQUNsQ0Msd0JBQXdCO0lBQ3hCLElBQUlQLGVBQWVKLHdCQUNmUyxXQUFXRDtJQUVmOzs7Ozs7O0VBT0MsR0FDRCxTQUFTSyxVQUFVcmpELE1BQU0sRUFBRXZELEdBQUc7UUFDNUIsSUFBSVUsUUFBUThsRCxTQUFTampELFFBQVF2RDtRQUM3QixPQUFPbW1ELGFBQWF6bEQsU0FBU0EsUUFBUW1CO0lBQ3ZDO0lBRUE0a0QsYUFBYUc7SUFDYixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsMEJBQTBCLE9BQU9EO0lBQ3JDQywyQkFBMkI7SUFDM0IsSUFBSUYsWUFBWUQ7SUFFaEIsOERBQThELEdBQzlELElBQUlLLGVBQWVKLFVBQVUvbUQsUUFBUTtJQUVyQ2duRCxnQkFBZ0JHO0lBQ2hCLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx1QkFBdUIsT0FBT0Q7SUFDbENDLHdCQUF3QjtJQUN4QixJQUFJRixlQUFlRDtJQUVuQjs7Ozs7O0VBTUMsR0FDRCxTQUFTSztRQUNQLElBQUksQ0FBQ0MsUUFBUSxHQUFHTCxlQUFlQSxhQUFhLFFBQVEsQ0FBQztRQUNyRCxJQUFJLENBQUNybEMsSUFBSSxHQUFHO0lBQ2Q7SUFFQXNsQyxhQUFhRztJQUNiLE9BQU9IO0FBQ1I7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FFRCxJQUFJSztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx3QkFBd0IsT0FBT0Q7SUFDbkNDLHlCQUF5QjtJQUN6QixTQUFTRSxXQUFXem5ELEdBQUc7UUFDckIsSUFBSW9XLFNBQVMsSUFBSSxDQUFDK0ssR0FBRyxDQUFDbmhCLFFBQVEsT0FBTyxJQUFJLENBQUNxbkQsUUFBUSxDQUFDcm5ELElBQUk7UUFDdkQsSUFBSSxDQUFDMmhCLElBQUksSUFBSXZMLFNBQVMsSUFBSTtRQUMxQixPQUFPQTtJQUNUO0lBRUFreEMsY0FBY0c7SUFDZCxPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQscUJBQXFCLE9BQU9EO0lBQ2hDQyxzQkFBc0I7SUFDdEIsSUFBSVgsZUFBZUQ7SUFFbkIsa0RBQWtELEdBQ2xELElBQUljLGlCQUFpQjtJQUVyQix5Q0FBeUMsR0FDekMsSUFBSWp5QyxjQUFjL1YsT0FBT0ssU0FBUztJQUVsQyw4Q0FBOEMsR0FDOUMsSUFBSW9ULGlCQUFpQnNDLFlBQVl0QyxjQUFjO0lBRS9DOzs7Ozs7OztFQVFDLEdBQ0QsU0FBU3cwQyxRQUFROW5ELEdBQUc7UUFDbEIsSUFBSXlpQixPQUFPLElBQUksQ0FBQzRrQyxRQUFRO1FBQ3hCLElBQUlMLGNBQWM7WUFDaEIsSUFBSTV3QyxTQUFTcU0sSUFBSSxDQUFDemlCLElBQUk7WUFDdEIsT0FBT29XLFdBQVd5eEMsaUJBQWlCaG1ELFlBQVl1VTtRQUNqRDtRQUNBLE9BQU85QyxlQUFlelMsSUFBSSxDQUFDNGhCLE1BQU16aUIsT0FBT3lpQixJQUFJLENBQUN6aUIsSUFBSSxHQUFHNkI7SUFDdEQ7SUFFQTZsRCxXQUFXSTtJQUNYLE9BQU9KO0FBQ1I7QUFFQSxJQUFJSztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxxQkFBcUIsT0FBT0Q7SUFDaENDLHNCQUFzQjtJQUN0QixJQUFJaEIsZUFBZUQ7SUFFbkIseUNBQXlDLEdBQ3pDLElBQUlueEMsY0FBYy9WLE9BQU9LLFNBQVM7SUFFbEMsOENBQThDLEdBQzlDLElBQUlvVCxpQkFBaUJzQyxZQUFZdEMsY0FBYztJQUUvQzs7Ozs7Ozs7RUFRQyxHQUNELFNBQVM0MEMsUUFBUWxvRCxHQUFHO1FBQ2xCLElBQUl5aUIsT0FBTyxJQUFJLENBQUM0a0MsUUFBUTtRQUN4QixPQUFPTCxlQUFnQnZrQyxJQUFJLENBQUN6aUIsSUFBSSxLQUFLNkIsWUFBYXlSLGVBQWV6UyxJQUFJLENBQUM0aEIsTUFBTXppQjtJQUM5RTtJQUVBK25ELFdBQVdHO0lBQ1gsT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHFCQUFxQixPQUFPRDtJQUNoQ0Msc0JBQXNCO0lBQ3RCLElBQUlwQixlQUFlRDtJQUVuQixrREFBa0QsR0FDbEQsSUFBSWMsaUJBQWlCO0lBRXJCOzs7Ozs7Ozs7RUFTQyxHQUNELFNBQVNTLFFBQVF0b0QsR0FBRyxFQUFFVSxLQUFLO1FBQ3pCLElBQUkraEIsT0FBTyxJQUFJLENBQUM0a0MsUUFBUTtRQUN4QixJQUFJLENBQUMxbEMsSUFBSSxJQUFJLElBQUksQ0FBQ1IsR0FBRyxDQUFDbmhCLE9BQU8sSUFBSTtRQUNqQ3lpQixJQUFJLENBQUN6aUIsSUFBSSxHQUFHLGdCQUFpQlUsVUFBVW1CLFlBQWFnbUQsaUJBQWlCbm5EO1FBQ3JFLE9BQU8sSUFBSTtJQUNiO0lBRUF5bkQsV0FBV0c7SUFDWCxPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsa0JBQWtCLE9BQU9EO0lBQzdCQyxtQkFBbUI7SUFDbkIsSUFBSXBCLFlBQVlELHFCQUNaTSxhQUFhRCxzQkFDYk0sVUFBVUYsbUJBQ1ZNLFVBQVVELG1CQUNWSyxVQUFVRDtJQUVkOzs7Ozs7RUFNQyxHQUNELFNBQVNLLEtBQUtDLE9BQU87UUFDbkIsSUFBSTN6QyxRQUFRLENBQUMsR0FDVGxXLFNBQVM2cEQsV0FBVyxPQUFPLElBQUlBLFFBQVE3cEQsTUFBTTtRQUVqRCxJQUFJLENBQUNvaUIsS0FBSztRQUNWLE1BQU8sRUFBRWxNLFFBQVFsVyxPQUFRO1lBQ3ZCLElBQUkyYyxRQUFRa3RDLE9BQU8sQ0FBQzN6QyxNQUFNO1lBQzFCLElBQUksQ0FBQytMLEdBQUcsQ0FBQ3RGLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFO1FBQzdCO0lBQ0Y7SUFFQSx5QkFBeUI7SUFDekJpdEMsS0FBS3hvRCxTQUFTLENBQUNnaEIsS0FBSyxHQUFHa21DO0lBQ3ZCc0IsS0FBS3hvRCxTQUFTLENBQUMsU0FBUyxHQUFHdW5EO0lBQzNCaUIsS0FBS3hvRCxTQUFTLENBQUNraEIsR0FBRyxHQUFHMG1DO0lBQ3JCWSxLQUFLeG9ELFNBQVMsQ0FBQ2loQixHQUFHLEdBQUcrbUM7SUFDckJRLEtBQUt4b0QsU0FBUyxDQUFDNmdCLEdBQUcsR0FBR3VuQztJQUVyQkMsUUFBUUc7SUFDUixPQUFPSDtBQUNSO0FBRUE7Ozs7OztDQU1DLEdBRUQsSUFBSUs7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsNEJBQTRCLE9BQU9EO0lBQ3ZDQyw2QkFBNkI7SUFDN0IsU0FBU0U7UUFDUCxJQUFJLENBQUMxQixRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUMxbEMsSUFBSSxHQUFHO0lBQ2Q7SUFFQWluQyxrQkFBa0JHO0lBQ2xCLE9BQU9IO0FBQ1I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUVELElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELGVBQWUsT0FBT0Q7SUFDMUJDLGdCQUFnQjtJQUNoQixTQUFTRSxHQUFHem9ELEtBQUssRUFBRXVYLEtBQUs7UUFDdEIsT0FBT3ZYLFVBQVV1WCxTQUFVdlgsVUFBVUEsU0FBU3VYLFVBQVVBO0lBQzFEO0lBRUErd0MsT0FBT0c7SUFDUCxPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsMEJBQTBCLE9BQU9EO0lBQ3JDQywyQkFBMkI7SUFDM0IsSUFBSUYsS0FBS0Q7SUFFVDs7Ozs7OztFQU9DLEdBQ0QsU0FBU0ssYUFBYW5tRCxLQUFLLEVBQUVwRCxHQUFHO1FBQzlCLElBQUlsQixTQUFTc0UsTUFBTXRFLE1BQU07UUFDekIsTUFBT0EsU0FBVTtZQUNmLElBQUlxcUQsR0FBRy9sRCxLQUFLLENBQUN0RSxPQUFPLENBQUMsRUFBRSxFQUFFa0IsTUFBTTtnQkFDN0IsT0FBT2xCO1lBQ1Q7UUFDRjtRQUNBLE9BQU8sQ0FBQztJQUNWO0lBRUFzcUQsZ0JBQWdCRztJQUNoQixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsNkJBQTZCLE9BQU9EO0lBQ3hDQyw4QkFBOEI7SUFDOUIsSUFBSUYsZUFBZUQ7SUFFbkIseUNBQXlDLEdBQ3pDLElBQUlLLGFBQWExcUQsTUFBTWlCLFNBQVM7SUFFaEMsK0JBQStCLEdBQy9CLElBQUlvZ0IsU0FBU3FwQyxXQUFXcnBDLE1BQU07SUFFOUI7Ozs7Ozs7O0VBUUMsR0FDRCxTQUFTc3BDLGdCQUFnQjVwRCxHQUFHO1FBQzFCLElBQUl5aUIsT0FBTyxJQUFJLENBQUM0a0MsUUFBUSxFQUNwQnJ5QyxRQUFRdTBDLGFBQWE5bUMsTUFBTXppQjtRQUUvQixJQUFJZ1YsUUFBUSxHQUFHO1lBQ2IsT0FBTztRQUNUO1FBQ0EsSUFBSTYwQyxZQUFZcG5DLEtBQUszakIsTUFBTSxHQUFHO1FBQzlCLElBQUlrVyxTQUFTNjBDLFdBQVc7WUFDdEJwbkMsS0FBS3lFLEdBQUc7UUFDVixPQUFPO1lBQ0w1RyxPQUFPemYsSUFBSSxDQUFDNGhCLE1BQU16TixPQUFPO1FBQzNCO1FBQ0EsRUFBRSxJQUFJLENBQUMyTSxJQUFJO1FBQ1gsT0FBTztJQUNUO0lBRUE2bkMsbUJBQW1CSTtJQUNuQixPQUFPSjtBQUNSO0FBRUEsSUFBSU07QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsMEJBQTBCLE9BQU9EO0lBQ3JDQywyQkFBMkI7SUFDM0IsSUFBSVIsZUFBZUQ7SUFFbkI7Ozs7Ozs7O0VBUUMsR0FDRCxTQUFTVyxhQUFhanFELEdBQUc7UUFDdkIsSUFBSXlpQixPQUFPLElBQUksQ0FBQzRrQyxRQUFRLEVBQ3BCcnlDLFFBQVF1MEMsYUFBYTltQyxNQUFNemlCO1FBRS9CLE9BQU9nVixRQUFRLElBQUluVCxZQUFZNGdCLElBQUksQ0FBQ3pOLE1BQU0sQ0FBQyxFQUFFO0lBQy9DO0lBRUE4MEMsZ0JBQWdCRztJQUNoQixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsMEJBQTBCLE9BQU9EO0lBQ3JDQywyQkFBMkI7SUFDM0IsSUFBSVosZUFBZUQ7SUFFbkI7Ozs7Ozs7O0VBUUMsR0FDRCxTQUFTZSxhQUFhcnFELEdBQUc7UUFDdkIsT0FBT3VwRCxhQUFhLElBQUksQ0FBQ2xDLFFBQVEsRUFBRXJuRCxPQUFPLENBQUM7SUFDN0M7SUFFQWtxRCxnQkFBZ0JHO0lBQ2hCLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCwwQkFBMEIsT0FBT0Q7SUFDckNDLDJCQUEyQjtJQUMzQixJQUFJaEIsZUFBZUQ7SUFFbkI7Ozs7Ozs7OztFQVNDLEdBQ0QsU0FBU21CLGFBQWF6cUQsR0FBRyxFQUFFVSxLQUFLO1FBQzlCLElBQUkraEIsT0FBTyxJQUFJLENBQUM0a0MsUUFBUSxFQUNwQnJ5QyxRQUFRdTBDLGFBQWE5bUMsTUFBTXppQjtRQUUvQixJQUFJZ1YsUUFBUSxHQUFHO1lBQ2IsRUFBRSxJQUFJLENBQUMyTSxJQUFJO1lBQ1hjLEtBQUtuaEIsSUFBSSxDQUFDO2dCQUFDdEI7Z0JBQUtVO2FBQU07UUFDeEIsT0FBTztZQUNMK2hCLElBQUksQ0FBQ3pOLE1BQU0sQ0FBQyxFQUFFLEdBQUd0VTtRQUNuQjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBRUE0cEQsZ0JBQWdCRztJQUNoQixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsdUJBQXVCLE9BQU9EO0lBQ2xDQyx3QkFBd0I7SUFDeEIsSUFBSTVCLGlCQUFpQkQsMEJBQ2pCYyxrQkFBa0JGLDJCQUNsQk8sZUFBZUQsd0JBQ2ZLLGVBQWVELHdCQUNmSyxlQUFlRDtJQUVuQjs7Ozs7O0VBTUMsR0FDRCxTQUFTSyxVQUFVbEMsT0FBTztRQUN4QixJQUFJM3pDLFFBQVEsQ0FBQyxHQUNUbFcsU0FBUzZwRCxXQUFXLE9BQU8sSUFBSUEsUUFBUTdwRCxNQUFNO1FBRWpELElBQUksQ0FBQ29pQixLQUFLO1FBQ1YsTUFBTyxFQUFFbE0sUUFBUWxXLE9BQVE7WUFDdkIsSUFBSTJjLFFBQVFrdEMsT0FBTyxDQUFDM3pDLE1BQU07WUFDMUIsSUFBSSxDQUFDK0wsR0FBRyxDQUFDdEYsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUU7UUFDN0I7SUFDRjtJQUVBLDhCQUE4QjtJQUM5Qm92QyxVQUFVM3FELFNBQVMsQ0FBQ2doQixLQUFLLEdBQUc2bkM7SUFDNUI4QixVQUFVM3FELFNBQVMsQ0FBQyxTQUFTLEdBQUcwcEQ7SUFDaENpQixVQUFVM3FELFNBQVMsQ0FBQ2toQixHQUFHLEdBQUc2b0M7SUFDMUJZLFVBQVUzcUQsU0FBUyxDQUFDaWhCLEdBQUcsR0FBR2twQztJQUMxQlEsVUFBVTNxRCxTQUFTLENBQUM2Z0IsR0FBRyxHQUFHMHBDO0lBRTFCQyxhQUFhRztJQUNiLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxpQkFBaUIsT0FBT0Q7SUFDNUJDLGtCQUFrQjtJQUNsQixJQUFJbkUsWUFBWUQscUJBQ1p2eUMsT0FBT0Y7SUFFWCw4REFBOEQsR0FDOUQsSUFBSW9OLE9BQU1zbEMsVUFBVXh5QyxNQUFNO0lBRTFCMDJDLE9BQU94cEM7SUFDUCxPQUFPd3BDO0FBQ1I7QUFFQSxJQUFJRztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCwyQkFBMkIsT0FBT0Q7SUFDdENDLDRCQUE0QjtJQUM1QixJQUFJeEMsT0FBT0QsZ0JBQ1BvQyxZQUFZRCxxQkFDWnRwQyxPQUFNMHBDO0lBRVY7Ozs7OztFQU1DLEdBQ0QsU0FBU0k7UUFDUCxJQUFJLENBQUN6cEMsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDMGxDLFFBQVEsR0FBRztZQUNkLFFBQVEsSUFBSXFCO1lBQ1osT0FBTyxJQUFLcG5DLENBQUFBLFFBQU91cEMsU0FBUTtZQUMzQixVQUFVLElBQUluQztRQUNoQjtJQUNGO0lBRUF1QyxpQkFBaUJHO0lBQ2pCLE9BQU9IO0FBQ1I7QUFFQTs7Ozs7O0NBTUMsR0FFRCxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx1QkFBdUIsT0FBT0Q7SUFDbENDLHdCQUF3QjtJQUN4QixTQUFTRSxVQUFVOXFELEtBQUs7UUFDdEIsSUFBSWlULE9BQU8sT0FBT2pUO1FBQ2xCLE9BQU8sUUFBUyxZQUFZaVQsUUFBUSxZQUFZQSxRQUFRLFlBQVlBLFFBQVEsWUFDdkVqVCxVQUFVLGNBQ1ZBLFVBQVU7SUFDakI7SUFFQTJxRCxhQUFhRztJQUNiLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx3QkFBd0IsT0FBT0Q7SUFDbkNDLHlCQUF5QjtJQUN6QixJQUFJRixZQUFZRDtJQUVoQjs7Ozs7OztFQU9DLEdBQ0QsU0FBU0ssV0FBVy80QyxHQUFHLEVBQUU3UyxHQUFHO1FBQzFCLElBQUl5aUIsT0FBTzVQLElBQUl3MEMsUUFBUTtRQUN2QixPQUFPbUUsVUFBVXhyRCxPQUNieWlCLElBQUksQ0FBQyxPQUFPemlCLE9BQU8sV0FBVyxXQUFXLE9BQU8sR0FDaER5aUIsS0FBSzVQLEdBQUc7SUFDZDtJQUVBNDRDLGNBQWNHO0lBQ2QsT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELDRCQUE0QixPQUFPRDtJQUN2Q0MsNkJBQTZCO0lBQzdCLElBQUlGLGFBQWFEO0lBRWpCOzs7Ozs7OztFQVFDLEdBQ0QsU0FBU0ssZUFBZWhzRCxHQUFHO1FBQ3pCLElBQUlvVyxTQUFTdzFDLFdBQVcsSUFBSSxFQUFFNXJELElBQUksQ0FBQyxTQUFTLENBQUNBO1FBQzdDLElBQUksQ0FBQzJoQixJQUFJLElBQUl2TCxTQUFTLElBQUk7UUFDMUIsT0FBT0E7SUFDVDtJQUVBeTFDLGtCQUFrQkc7SUFDbEIsT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHlCQUF5QixPQUFPRDtJQUNwQ0MsMEJBQTBCO0lBQzFCLElBQUlOLGFBQWFEO0lBRWpCOzs7Ozs7OztFQVFDLEdBQ0QsU0FBU1MsWUFBWXBzRCxHQUFHO1FBQ3RCLE9BQU80ckQsV0FBVyxJQUFJLEVBQUU1ckQsS0FBS29oQixHQUFHLENBQUNwaEI7SUFDbkM7SUFFQWlzRCxlQUFlRztJQUNmLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx5QkFBeUIsT0FBT0Q7SUFDcENDLDBCQUEwQjtJQUMxQixJQUFJVixhQUFhRDtJQUVqQjs7Ozs7Ozs7RUFRQyxHQUNELFNBQVNhLFlBQVl4c0QsR0FBRztRQUN0QixPQUFPNHJELFdBQVcsSUFBSSxFQUFFNXJELEtBQUttaEIsR0FBRyxDQUFDbmhCO0lBQ25DO0lBRUFxc0QsZUFBZUc7SUFDZixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQseUJBQXlCLE9BQU9EO0lBQ3BDQywwQkFBMEI7SUFDMUIsSUFBSWQsYUFBYUQ7SUFFakI7Ozs7Ozs7OztFQVNDLEdBQ0QsU0FBU2lCLFlBQVk1c0QsR0FBRyxFQUFFVSxLQUFLO1FBQzdCLElBQUkraEIsT0FBT21wQyxXQUFXLElBQUksRUFBRTVyRCxNQUN4QjJoQixPQUFPYyxLQUFLZCxJQUFJO1FBRXBCYyxLQUFLMUIsR0FBRyxDQUFDL2dCLEtBQUtVO1FBQ2QsSUFBSSxDQUFDaWhCLElBQUksSUFBSWMsS0FBS2QsSUFBSSxJQUFJQSxPQUFPLElBQUk7UUFDckMsT0FBTyxJQUFJO0lBQ2I7SUFFQThxQyxlQUFlRztJQUNmLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSTtBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxzQkFBc0IsT0FBT0Q7SUFDakNDLHVCQUF1QjtJQUN2QixJQUFJMUIsZ0JBQWdCRCx5QkFDaEJhLGlCQUFpQkQsMEJBQ2pCSyxjQUFjRCx1QkFDZEssY0FBY0QsdUJBQ2RLLGNBQWNEO0lBRWxCOzs7Ozs7RUFNQyxHQUNELFNBQVNLLFNBQVNyRSxPQUFPO1FBQ3ZCLElBQUkzekMsUUFBUSxDQUFDLEdBQ1RsVyxTQUFTNnBELFdBQVcsT0FBTyxJQUFJQSxRQUFRN3BELE1BQU07UUFFakQsSUFBSSxDQUFDb2lCLEtBQUs7UUFDVixNQUFPLEVBQUVsTSxRQUFRbFcsT0FBUTtZQUN2QixJQUFJMmMsUUFBUWt0QyxPQUFPLENBQUMzekMsTUFBTTtZQUMxQixJQUFJLENBQUMrTCxHQUFHLENBQUN0RixLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRTtRQUM3QjtJQUNGO0lBRUEsNkJBQTZCO0lBQzdCdXhDLFNBQVM5c0QsU0FBUyxDQUFDZ2hCLEtBQUssR0FBR2txQztJQUMzQjRCLFNBQVM5c0QsU0FBUyxDQUFDLFNBQVMsR0FBRzhyRDtJQUMvQmdCLFNBQVM5c0QsU0FBUyxDQUFDa2hCLEdBQUcsR0FBR2dyQztJQUN6QlksU0FBUzlzRCxTQUFTLENBQUNpaEIsR0FBRyxHQUFHcXJDO0lBQ3pCUSxTQUFTOXNELFNBQVMsQ0FBQzZnQixHQUFHLEdBQUc2ckM7SUFFekJDLFlBQVlHO0lBQ1osT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELG9CQUFvQixPQUFPRDtJQUMvQkMscUJBQXFCO0lBQ3JCLElBQUlGLFdBQVdEO0lBRWYsNkJBQTZCLEdBQzdCLElBQUl4MEMsa0JBQWtCO0lBRXRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMkNDLEdBQ0QsU0FBU3JULFFBQVEyVCxJQUFJLEVBQUVxbEMsUUFBUTtRQUM3QixJQUFJLE9BQU9ybEMsUUFBUSxjQUFlcWxDLFlBQVksUUFBUSxPQUFPQSxZQUFZLFlBQWE7WUFDcEYsTUFBTSxJQUFJNStDLFVBQVVpWjtRQUN0QjtRQUNBLElBQUk2MEMsV0FBVztZQUNiLElBQUkvbkQsT0FBT0QsV0FDUHBGLE1BQU1rK0MsV0FBV0EsU0FBU3Q0QyxLQUFLLENBQUMsSUFBSSxFQUFFUCxRQUFRQSxJQUFJLENBQUMsRUFBRSxFQUNyRFEsUUFBUXVuRCxTQUFTdm5ELEtBQUs7WUFFMUIsSUFBSUEsTUFBTXNiLEdBQUcsQ0FBQ25oQixNQUFNO2dCQUNsQixPQUFPNkYsTUFBTXViLEdBQUcsQ0FBQ3BoQjtZQUNuQjtZQUNBLElBQUlvVyxTQUFTeUMsS0FBS2pULEtBQUssQ0FBQyxJQUFJLEVBQUVQO1lBQzlCK25ELFNBQVN2bkQsS0FBSyxHQUFHQSxNQUFNa2IsR0FBRyxDQUFDL2dCLEtBQUtvVyxXQUFXdlE7WUFDM0MsT0FBT3VRO1FBQ1Q7UUFDQWczQyxTQUFTdm5ELEtBQUssR0FBRyxJQUFLWCxDQUFBQSxRQUFRbW9ELEtBQUssSUFBSUwsUUFBTztRQUM5QyxPQUFPSTtJQUNUO0lBRUEscUJBQXFCO0lBQ3JCbG9ELFFBQVFtb0QsS0FBSyxHQUFHTDtJQUVoQkMsWUFBWS9uRDtJQUNaLE9BQU8rbkQ7QUFDUjtBQUVBLElBQUlLO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELDJCQUEyQixPQUFPRDtJQUN0Q0MsNEJBQTRCO0lBQzVCLElBQUlyb0QsVUFBVWlvRDtJQUVkLDRDQUE0QyxHQUM1QyxJQUFJTSxtQkFBbUI7SUFFdkI7Ozs7Ozs7RUFPQyxHQUNELFNBQVNDLGNBQWM3MEMsSUFBSTtRQUN6QixJQUFJekMsU0FBU2xSLFFBQVEyVCxNQUFNLFNBQVM3WSxHQUFHO1lBQ3JDLElBQUk2RixNQUFNOGIsSUFBSSxLQUFLOHJDLGtCQUFrQjtnQkFDbkM1bkQsTUFBTXFiLEtBQUs7WUFDYjtZQUNBLE9BQU9saEI7UUFDVDtRQUVBLElBQUk2RixRQUFRdVEsT0FBT3ZRLEtBQUs7UUFDeEIsT0FBT3VRO0lBQ1Q7SUFFQWszQyxpQkFBaUJJO0lBQ2pCLE9BQU9KO0FBQ1I7QUFFQSxJQUFJSztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCwwQkFBMEIsT0FBT0Q7SUFDckNDLDJCQUEyQjtJQUMzQixJQUFJRixnQkFBZ0JGO0lBRXBCLHdEQUF3RCxHQUN4RCxJQUFJTSxhQUFhO0lBRWpCLGlEQUFpRCxHQUNqRCxJQUFJQyxlQUFlO0lBRW5COzs7Ozs7RUFNQyxHQUNELElBQUlDLGVBQWVOLGNBQWMsU0FBU3hxRCxNQUFNO1FBQzlDLElBQUlrVCxTQUFTLEVBQUU7UUFDZixJQUFJbFQsT0FBT3NaLFVBQVUsQ0FBQyxPQUFPLEdBQUcsS0FBSyxLQUFJO1lBQ3ZDcEcsT0FBTzlVLElBQUksQ0FBQztRQUNkO1FBQ0E0QixPQUFPOEMsT0FBTyxDQUFDOG5ELFlBQVksU0FBU3ZwRCxLQUFLLEVBQUVkLE1BQU0sRUFBRXdxRCxLQUFLLEVBQUVDLFNBQVM7WUFDakU5M0MsT0FBTzlVLElBQUksQ0FBQzJzRCxRQUFRQyxVQUFVbG9ELE9BQU8sQ0FBQytuRCxjQUFjLFFBQVN0cUQsVUFBVWM7UUFDekU7UUFDQSxPQUFPNlI7SUFDVDtJQUVBdTNDLGdCQUFnQks7SUFDaEIsT0FBT0w7QUFDUjtBQUVBOzs7Ozs7OztDQVFDLEdBRUQsSUFBSVE7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsc0JBQXNCLE9BQU9EO0lBQ2pDQyx1QkFBdUI7SUFDdkIsU0FBU0UsU0FBU2xyRCxLQUFLLEVBQUVtckQsUUFBUTtRQUMvQixJQUFJdjVDLFFBQVEsQ0FBQyxHQUNUbFcsU0FBU3NFLFNBQVMsT0FBTyxJQUFJQSxNQUFNdEUsTUFBTSxFQUN6Q3NYLFNBQVNuWCxNQUFNSDtRQUVuQixNQUFPLEVBQUVrVyxRQUFRbFcsT0FBUTtZQUN2QnNYLE1BQU0sQ0FBQ3BCLE1BQU0sR0FBR3U1QyxTQUFTbnJELEtBQUssQ0FBQzRSLE1BQU0sRUFBRUEsT0FBTzVSO1FBQ2hEO1FBQ0EsT0FBT2dUO0lBQ1Q7SUFFQSszQyxZQUFZRztJQUNaLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCwwQkFBMEIsT0FBT0Q7SUFDckNDLDJCQUEyQjtJQUMzQixJQUFJcnVELFVBQVNvVixrQkFDVDg0QyxXQUFXRCxvQkFDWGx2RCxVQUFVMmtELGtCQUNWdnNDLFdBQVdGO0lBRWYsdURBQXVELEdBQ3ZELElBQUlzM0MsY0FBY3Z1RCxVQUFTQSxRQUFPRixTQUFTLEdBQUcyQixXQUMxQytzRCxpQkFBaUJELGNBQWNBLFlBQVkxc0QsUUFBUSxHQUFHSjtJQUUxRDs7Ozs7OztFQU9DLEdBQ0QsU0FBU2d0RCxhQUFhbnVELEtBQUs7UUFDekIsMEVBQTBFO1FBQzFFLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJdkIsUUFBUXVCLFFBQVE7WUFDbEIsaUVBQWlFO1lBQ2pFLE9BQU80dEQsU0FBUzV0RCxPQUFPbXVELGdCQUFnQjtRQUN6QztRQUNBLElBQUl0M0MsU0FBUzdXLFFBQVE7WUFDbkIsT0FBT2t1RCxpQkFBaUJBLGVBQWUvdEQsSUFBSSxDQUFDSCxTQUFTO1FBQ3ZEO1FBQ0EsSUFBSTBWLFNBQVUxVixRQUFRO1FBQ3RCLE9BQU8sVUFBVyxPQUFPLElBQUtBLFNBQVUsQ0FBQ21zQixXQUFZLE9BQU96VztJQUM5RDtJQUVBbzRDLGdCQUFnQks7SUFDaEIsT0FBT0w7QUFDUjtBQUVBLElBQUlNO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHFCQUFxQixPQUFPRDtJQUNoQ0Msc0JBQXNCO0lBQ3RCLElBQUlGLGVBQWVIO0lBRW5COzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQW9CQyxHQUNELFNBQVN6c0QsU0FBU3ZCLEtBQUs7UUFDckIsT0FBT0EsU0FBUyxPQUFPLEtBQUttdUQsYUFBYW51RDtJQUMzQztJQUVBb3VELGFBQWE3c0Q7SUFDYixPQUFPNnNEO0FBQ1I7QUFFQSxJQUFJRztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxzQkFBc0IsT0FBT0Q7SUFDakNDLHVCQUF1QjtJQUN2QixJQUFJL3ZELFVBQVUya0Qsa0JBQ1ZNLFFBQVFILGlCQUNSK0osZUFBZUgsd0JBQ2Y1ckQsV0FBVytzRDtJQUVmOzs7Ozs7O0VBT0MsR0FDRCxTQUFTSSxTQUFTMXVELEtBQUssRUFBRTZDLE1BQU07UUFDN0IsSUFBSXBFLFFBQVF1QixRQUFRO1lBQ2xCLE9BQU9BO1FBQ1Q7UUFDQSxPQUFPMGpELE1BQU0xakQsT0FBTzZDLFVBQVU7WUFBQzdDO1NBQU0sR0FBR3N0RCxhQUFhL3JELFNBQVN2QjtJQUNoRTtJQUVBdXVELFlBQVlHO0lBQ1osT0FBT0g7QUFDUjtBQUVBLElBQUlJO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELG1CQUFtQixPQUFPRDtJQUM5QkMsb0JBQW9CO0lBQ3BCLElBQUkvM0MsV0FBV0Y7SUFFZjs7Ozs7O0VBTUMsR0FDRCxTQUFTbTRDLE1BQU05dUQsS0FBSztRQUNsQixJQUFJLE9BQU9BLFNBQVMsWUFBWTZXLFNBQVM3VyxRQUFRO1lBQy9DLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJMFYsU0FBVTFWLFFBQVE7UUFDdEIsT0FBTyxVQUFXLE9BQU8sSUFBS0EsU0FBVSxDQUFDbXNCLFdBQVksT0FBT3pXO0lBQzlEO0lBRUFpNUMsU0FBU0c7SUFDVCxPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQscUJBQXFCLE9BQU9EO0lBQ2hDQyxzQkFBc0I7SUFDdEIsSUFBSU4sV0FBV0Qsb0JBQ1hLLFFBQVFEO0lBRVo7Ozs7Ozs7RUFPQyxHQUNELFNBQVNLLFFBQVFyc0QsTUFBTSxFQUFFMmtCLElBQUk7UUFDM0JBLE9BQU9rbkMsU0FBU2xuQyxNQUFNM2tCO1FBRXRCLElBQUl5UixRQUFRLEdBQ1JsVyxTQUFTb3BCLEtBQUtwcEIsTUFBTTtRQUV4QixNQUFPeUUsVUFBVSxRQUFReVIsUUFBUWxXLE9BQVE7WUFDdkN5RSxTQUFTQSxNQUFNLENBQUNpc0QsTUFBTXRuQyxJQUFJLENBQUNsVCxRQUFRLEVBQUU7UUFDdkM7UUFDQSxPQUFPLFNBQVVBLFNBQVNsVyxTQUFVeUUsU0FBUzFCO0lBQy9DO0lBRUE0dEQsV0FBV0c7SUFDWCxPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsZ0JBQWdCLE9BQU9EO0lBQzNCQyxpQkFBaUI7SUFDakIsSUFBSUYsVUFBVUQ7SUFFZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0JDLEdBQ0QsU0FBU3Z1QyxJQUFJN2QsTUFBTSxFQUFFMmtCLElBQUksRUFBRThuQyxZQUFZO1FBQ3JDLElBQUk1NUMsU0FBUzdTLFVBQVUsT0FBTzFCLFlBQVkrdEQsUUFBUXJzRCxRQUFRMmtCO1FBQzFELE9BQU85UixXQUFXdlUsWUFBWW11RCxlQUFlNTVDO0lBQy9DO0lBRUF5NUMsUUFBUXp1QztJQUNSLE9BQU95dUM7QUFDUjtBQUVBLElBQUlJLGFBQWFGO0FBQ2pCLElBQUkzdUMsTUFBTSxXQUFXLEdBQUVqTyx3QkFBd0I4OEM7QUFFL0MsSUFBSUM7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQsNEJBQTRCLE9BQU9EO0lBQ3ZDQyw2QkFBNkI7SUFDN0IsSUFBSXZKLFlBQVlEO0lBRWhCLElBQUk3bUQsaUJBQWtCO1FBQ3BCLElBQUk7WUFDRixJQUFJK1ksT0FBTyt0QyxVQUFVL21ELFFBQVE7WUFDN0JnWixLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDZCxPQUFPQTtRQUNULEVBQUUsT0FBTzlaLEdBQUcsQ0FBQztJQUNmO0lBRUFteEQsa0JBQWtCcHdEO0lBQ2xCLE9BQU9vd0Q7QUFDUjtBQUVBLElBQUlHO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELDZCQUE2QixPQUFPRDtJQUN4Q0MsOEJBQThCO0lBQzlCLElBQUl4d0QsaUJBQWlCc3dEO0lBRXJCOzs7Ozs7OztFQVFDLEdBQ0QsU0FBU0ksZ0JBQWdCanRELE1BQU0sRUFBRXZELEdBQUcsRUFBRVUsS0FBSztRQUN6QyxJQUFJVixPQUFPLGVBQWVGLGdCQUFnQjtZQUN4Q0EsZUFBZXlELFFBQVF2RCxLQUFLO2dCQUMxQixnQkFBZ0I7Z0JBQ2hCLGNBQWM7Z0JBQ2QsU0FBU1U7Z0JBQ1QsWUFBWTtZQUNkO1FBQ0YsT0FBTztZQUNMNkMsTUFBTSxDQUFDdkQsSUFBSSxHQUFHVTtRQUNoQjtJQUNGO0lBRUEydkQsbUJBQW1CRztJQUNuQixPQUFPSDtBQUNSO0FBRUEsSUFBSUk7QUFDSixJQUFJQztBQUVKLFNBQVNDO0lBQ1IsSUFBSUQseUJBQXlCLE9BQU9EO0lBQ3BDQywwQkFBMEI7SUFDMUIsSUFBSUYsa0JBQWtCRCwyQkFDbEJwSCxLQUFLRDtJQUVULHlDQUF5QyxHQUN6QyxJQUFJdHpDLGNBQWMvVixPQUFPSyxTQUFTO0lBRWxDLDhDQUE4QyxHQUM5QyxJQUFJb1QsaUJBQWlCc0MsWUFBWXRDLGNBQWM7SUFFL0M7Ozs7Ozs7OztFQVNDLEdBQ0QsU0FBU3M5QyxZQUFZcnRELE1BQU0sRUFBRXZELEdBQUcsRUFBRVUsS0FBSztRQUNyQyxJQUFJbXdELFdBQVd0dEQsTUFBTSxDQUFDdkQsSUFBSTtRQUMxQixJQUFJLENBQUVzVCxDQUFBQSxlQUFlelMsSUFBSSxDQUFDMEMsUUFBUXZELFFBQVFtcEQsR0FBRzBILFVBQVVud0QsTUFBSyxLQUN2REEsVUFBVW1CLGFBQWEsQ0FBRTdCLENBQUFBLE9BQU91RCxNQUFLLEdBQUs7WUFDN0NpdEQsZ0JBQWdCanRELFFBQVF2RCxLQUFLVTtRQUMvQjtJQUNGO0lBRUErdkQsZUFBZUc7SUFDZixPQUFPSDtBQUNSO0FBRUEsdURBQXVELEdBRXZELElBQUlLO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHFCQUFxQixPQUFPRDtJQUNoQ0Msc0JBQXNCO0lBQ3RCLElBQUlyeUMsbUJBQW1CO0lBRXZCLDRDQUE0QyxHQUM1QyxJQUFJdXlDLFdBQVc7SUFFZjs7Ozs7OztFQU9DLEdBQ0QsU0FBU0MsUUFBUXh3RCxLQUFLLEVBQUU1QixNQUFNO1FBQzVCLElBQUk2VSxPQUFPLE9BQU9qVDtRQUNsQjVCLFNBQVNBLFVBQVUsT0FBTzRmLG1CQUFtQjVmO1FBRTdDLE9BQU8sQ0FBQyxDQUFDQSxVQUNONlUsQ0FBQUEsUUFBUSxZQUNOQSxRQUFRLFlBQVlzOUMsU0FBUzd1RCxJQUFJLENBQUMxQixNQUFNLEtBQ3RDQSxRQUFRLENBQUMsS0FBS0EsUUFBUSxLQUFLLEtBQUtBLFFBQVE1QjtJQUNqRDtJQUVBZ3lELFdBQVdJO0lBQ1gsT0FBT0o7QUFDUjtBQUVBLElBQUlLO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHFCQUFxQixPQUFPRDtJQUNoQ0Msc0JBQXNCO0lBQ3RCLElBQUlSLGNBQWNELHVCQUNkdkIsV0FBV0Qsb0JBQ1grQixVQUFVRixtQkFDVnQ5QyxXQUFXRCxtQkFDWCs3QyxRQUFRRDtJQUVaOzs7Ozs7Ozs7RUFTQyxHQUNELFNBQVMrQixRQUFRL3RELE1BQU0sRUFBRTJrQixJQUFJLEVBQUV4bkIsS0FBSyxFQUFFNndELFVBQVU7UUFDOUMsSUFBSSxDQUFDNzlDLFNBQVNuUSxTQUFTO1lBQ3JCLE9BQU9BO1FBQ1Q7UUFDQTJrQixPQUFPa25DLFNBQVNsbkMsTUFBTTNrQjtRQUV0QixJQUFJeVIsUUFBUSxDQUFDLEdBQ1RsVyxTQUFTb3BCLEtBQUtwcEIsTUFBTSxFQUNwQitxRCxZQUFZL3FELFNBQVMsR0FDckIweUQsU0FBU2p1RDtRQUViLE1BQU9pdUQsVUFBVSxRQUFRLEVBQUV4OEMsUUFBUWxXLE9BQVE7WUFDekMsSUFBSWtCLE1BQU13dkQsTUFBTXRuQyxJQUFJLENBQUNsVCxNQUFNLEdBQ3ZCeThDLFdBQVcvd0Q7WUFFZixJQUFJVixRQUFRLGVBQWVBLFFBQVEsaUJBQWlCQSxRQUFRLGFBQWE7Z0JBQ3ZFLE9BQU91RDtZQUNUO1lBRUEsSUFBSXlSLFNBQVM2MEMsV0FBVztnQkFDdEIsSUFBSWdILFdBQVdXLE1BQU0sQ0FBQ3h4RCxJQUFJO2dCQUMxQnl4RCxXQUFXRixhQUFhQSxXQUFXVixVQUFVN3dELEtBQUt3eEQsVUFBVTN2RDtnQkFDNUQsSUFBSTR2RCxhQUFhNXZELFdBQVc7b0JBQzFCNHZELFdBQVcvOUMsU0FBU205QyxZQUNoQkEsV0FDQ0ssUUFBUWhwQyxJQUFJLENBQUNsVCxRQUFRLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQztnQkFDeEM7WUFDRjtZQUNBNDdDLFlBQVlZLFFBQVF4eEQsS0FBS3l4RDtZQUN6QkQsU0FBU0EsTUFBTSxDQUFDeHhELElBQUk7UUFDdEI7UUFDQSxPQUFPdUQ7SUFDVDtJQUVBNHRELFdBQVdHO0lBQ1gsT0FBT0g7QUFDUjtBQUVBLElBQUlPO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELGdCQUFnQixPQUFPRDtJQUMzQkMsaUJBQWlCO0lBQ2pCLElBQUlMLFVBQVVEO0lBRWQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTJCQyxHQUNELFNBQVN0d0MsSUFBSXhkLE1BQU0sRUFBRTJrQixJQUFJLEVBQUV4bkIsS0FBSztRQUM5QixPQUFPNkMsVUFBVSxPQUFPQSxTQUFTK3RELFFBQVEvdEQsUUFBUTJrQixNQUFNeG5CO0lBQ3pEO0lBRUFneEQsUUFBUTN3QztJQUNSLE9BQU8yd0M7QUFDUjtBQUVBLElBQUlHLGFBQWFEO0FBQ2pCLElBQUk3d0MsTUFBTSxXQUFXLEdBQUU1Tix3QkFBd0IwK0M7QUFFL0M7Ozs7Ozs7Q0FPQyxHQUVELElBQUlDO0FBQ0osSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHVCQUF1QixPQUFPRDtJQUNsQ0Msd0JBQXdCO0lBQ3hCLFNBQVN4eUMsVUFBVW1ELE1BQU0sRUFBRXRmLEtBQUs7UUFDOUIsSUFBSTRSLFFBQVEsQ0FBQyxHQUNUbFcsU0FBUzRqQixPQUFPNWpCLE1BQU07UUFFMUJzRSxTQUFVQSxDQUFBQSxRQUFRbkUsTUFBTUgsT0FBTTtRQUM5QixNQUFPLEVBQUVrVyxRQUFRbFcsT0FBUTtZQUN2QnNFLEtBQUssQ0FBQzRSLE1BQU0sR0FBRzBOLE1BQU0sQ0FBQzFOLE1BQU07UUFDOUI7UUFDQSxPQUFPNVI7SUFDVDtJQUVBMHVELGFBQWF2eUM7SUFDYixPQUFPdXlDO0FBQ1I7QUFFQSxJQUFJRztBQUNKLElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCxtQkFBbUIsT0FBT0Q7SUFDOUJDLG9CQUFvQjtJQUNwQixJQUFJNUQsV0FBV0Qsb0JBQ1g5dUMsWUFBWXl5QyxxQkFDWjd5RCxVQUFVMmtELGtCQUNWdnNDLFdBQVdGLG1CQUNYMjJDLGVBQWVILHdCQUNmMkIsUUFBUUQsaUJBQ1J0dEQsV0FBVytzRDtJQUVmOzs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JDLEdBQ0QsU0FBU29ELE9BQU8xeEQsS0FBSztRQUNuQixJQUFJdkIsUUFBUXVCLFFBQVE7WUFDbEIsT0FBTzR0RCxTQUFTNXRELE9BQU84dUQ7UUFDekI7UUFDQSxPQUFPajRDLFNBQVM3VyxTQUFTO1lBQUNBO1NBQU0sR0FBRzZlLFVBQVV5dUMsYUFBYS9yRCxTQUFTdkI7SUFDckU7SUFFQXV4RCxXQUFXRztJQUNYLE9BQU9IO0FBQ1I7QUFFQSxJQUFJSSxnQkFBZ0JGO0FBQ3BCLElBQUlDLFNBQVMsV0FBVyxHQUFFai9DLHdCQUF3QmsvQztBQUVsRCxJQUFJQyxXQUFXO0lBQ2Isb0JBQW9CO0lBQ3BCN3ZDLE1BQU0sU0FBU0EsS0FBS0gsTUFBTTtRQUN4QixJQUFJeEMsV0FBVztZQUNieXlDLE9BQU87WUFDUEMsY0FBYztZQUNkQyxjQUFjO1lBQ2RDLGNBQWM7WUFDZEMsY0FBYztZQUNkQyxjQUFjO1lBQ2RDLHNCQUFzQjtZQUN0QkMsZUFBZTtZQUNmQyxlQUFlLENBQUM7WUFDaEIsMkJBQTJCO1lBQzNCQyxhQUFhO1lBQ2JDLFdBQVcsU0FBU0EsVUFBVXh0RCxLQUFJLEdBQUc7WUFDckN5dEQsV0FBVyxTQUFTQSxVQUFVenRELEtBQUksRUFBRTFDLEdBQUcsR0FBRztZQUMxQ293RCxPQUFPLFNBQVNBLE1BQU0xdEQsS0FBSSxHQUFHO1lBQzdCMnRELFFBQVEsU0FBU0EsT0FBTzN0RCxLQUFJO2dCQUMxQixPQUFPO1lBQ1Q7UUFDRjtRQUNBNmMsU0FBU2piLE9BQU8sQ0FBQyxHQUFHeVksVUFBVXdDO1FBQzlCLE9BQU8sU0FBUyt3QyxTQUFTbHhELElBQUksRUFBRXpCLEtBQUs7WUFDbEMsSUFBSTJILElBQUlpYTtZQUNSLElBQUk3YyxRQUFPLElBQUk7WUFDZixJQUFJaThDLGtCQUFrQmo4QyxNQUFLM0csTUFBTSxLQUFLK0M7WUFDdEMsSUFBSW1qQixNQUFNMDhCLGtCQUFrQmo4QyxRQUFPO2dCQUFDQTthQUFLLEVBQUUsaUNBQWlDO1lBQzVFLElBQUl2QixTQUFTdzlDLGtCQUFrQmo4QyxLQUFJLENBQUMsRUFBRSxHQUFHQTtZQUV6QyxvQkFBb0I7WUFDcEIsSUFBSXZDLE9BQU9mLE9BQU87Z0JBQ2hCLHNCQUFzQjtnQkFDdEIsSUFBSW14RCxhQUFhbnhELEtBQUtxb0IsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLDRDQUE0QztnQkFDdkYsSUFBSXRDLE9BQU9vckMsY0FBY2xCLE9BQU9qd0Q7Z0JBRWhDLGVBQWU7Z0JBQ2YsSUFBSWtHLEVBQUVzcUQsWUFBWSxJQUFJanlELFVBQVVtQixXQUFXO29CQUN6QyxNQUFNO29CQUVOLElBQUk2RDtvQkFDSixJQUFJeEIsUUFBUTt3QkFDVm1FLEVBQUU0cUQsU0FBUyxDQUFDL3VEO3dCQUVaLGtFQUFrRTt3QkFDbEUsSUFBSWdrQixRQUFRaGtCLE9BQU9ELFFBQVEsQ0FBQ29FLEVBQUVrcUQsS0FBSyxDQUFDLENBQUNwd0QsS0FBSyxLQUFLTixXQUFXOzRCQUN4RDZELE1BQU0wYixJQUFJbGQsT0FBT0QsUUFBUSxDQUFDb0UsRUFBRWtxRCxLQUFLLENBQUMsRUFBRXJxQzt3QkFDdEMsT0FBTzs0QkFDTHhpQixNQUFNeEIsT0FBT0QsUUFBUSxDQUFDb0UsRUFBRWtxRCxLQUFLLENBQUMsQ0FBQ3B3RCxLQUFLO3dCQUN0QztvQkFDRjtvQkFDQSxPQUFPdUQ7Z0JBRVAsc0JBQXNCO2dCQUN4QixPQUFPLElBQUkyQyxFQUFFcXFELFlBQVksSUFBSWh5RCxVQUFVbUIsV0FBVztvQkFDaEQsTUFBTTtvQkFDTixJQUFJMHhELFFBQVEsQ0FBQ2xyRCxFQUFFMHFELGFBQWEsQ0FBQzV3RCxLQUFLO29CQUNsQyxJQUFJb3hELE9BQU87d0JBQ1QsSUFBSUMsU0FBU3h5RCxrQkFBa0IsQ0FBQyxHQUFHbUIsTUFBTXpCO3dCQUN6QzJILEVBQUU2cUQsU0FBUyxDQUFDenRELE9BQU0rdEQ7d0JBQ2xCLElBQUssSUFBSW55RCxJQUFJLEdBQUdELElBQUk0akIsSUFBSWxtQixNQUFNLEVBQUV1QyxJQUFJRCxHQUFHQyxJQUFLOzRCQUMxQyxJQUFJK2UsTUFBTTRFLEdBQUcsQ0FBQzNqQixFQUFFOzRCQUNoQixJQUFJZ0gsRUFBRStxRCxNQUFNLENBQUNoekMsTUFBTTtnQ0FDakIsSUFBSThILFFBQVFoa0IsT0FBT0QsUUFBUSxDQUFDb0UsRUFBRWtxRCxLQUFLLENBQUMsQ0FBQ3B3RCxLQUFLLEtBQUtOLFdBQVc7b0NBQ3hEa2YsSUFBSVgsSUFBSW5jLFFBQVEsQ0FBQ29FLEVBQUVrcUQsS0FBSyxDQUFDLEVBQUVycUMsTUFBTXhuQjtnQ0FDbkMsT0FBTztvQ0FDTDBmLElBQUluYyxRQUFRLENBQUNvRSxFQUFFa3FELEtBQUssQ0FBQyxDQUFDcHdELEtBQUssR0FBR3pCO2dDQUNoQzs0QkFDRjt3QkFDRjt3QkFFQSwwQkFBMEI7d0JBQzFCLElBQUkySCxFQUFFMnFELFdBQVcsRUFBRTs0QkFDakJ2dEQsTUFBS3V0RCxXQUFXO3dCQUNsQjt3QkFFQSxzQkFBc0I7d0JBQ3RCM3FELEVBQUU4cUQsS0FBSyxDQUFDMXREO3dCQUNSLElBQUk0QyxFQUFFd3FELG9CQUFvQixFQUFFOzRCQUMxQnB0RCxLQUFJLENBQUM0QyxFQUFFeXFELGFBQWEsQ0FBQyxDQUFDenFELEVBQUV1cUQsWUFBWTt3QkFDdEM7b0JBQ0Y7Z0JBQ0Y7WUFFQSwwQkFBMEI7WUFDNUIsT0FBTyxJQUFJdnFELEVBQUVxcUQsWUFBWSxJQUFJcHZELFlBQVluQixPQUFPO2dCQUM5QyxTQUFTO2dCQUNULElBQUlZLE1BQU1aO2dCQUNWLElBQUl3RCxHQUFHTTtnQkFDUCxJQUFJd0IsT0FBTzVILE9BQU80SCxJQUFJLENBQUMxRTtnQkFDdkJzRixFQUFFNnFELFNBQVMsQ0FBQ3p0RCxPQUFNMUM7Z0JBQ2xCLElBQUssSUFBSWdsQixLQUFLLEdBQUdBLEtBQUt0Z0IsS0FBSzNJLE1BQU0sRUFBRWlwQixLQUFNO29CQUN2Q3BpQixJQUFJOEIsSUFBSSxDQUFDc2dCLEdBQUc7b0JBQ1o5aEIsSUFBSWxELEdBQUcsQ0FBQzRDLEVBQUU7b0JBQ1YsSUFBSTh0RCxTQUFTLENBQUNwckQsRUFBRTBxRCxhQUFhLENBQUNwdEQsRUFBRTtvQkFDaEMsSUFBSTh0RCxRQUFRO3dCQUNWLElBQUssSUFBSS9yRCxJQUFJLEdBQUdBLElBQUlzZCxJQUFJbG1CLE1BQU0sRUFBRTRJLElBQUs7NEJBQ25DLElBQUlnc0QsT0FBTzF1QyxHQUFHLENBQUN0ZCxFQUFFOzRCQUNqQixJQUFJVyxFQUFFK3FELE1BQU0sQ0FBQ00sT0FBTztnQ0FDbEJBLEtBQUt6dkQsUUFBUSxDQUFDb0UsRUFBRWtxRCxLQUFLLENBQUMsQ0FBQzVzRCxFQUFFLEdBQUdNOzRCQUM5Qjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFFQSwwQkFBMEI7Z0JBQzFCLElBQUlvQyxFQUFFMnFELFdBQVcsRUFBRTtvQkFDakJ2dEQsTUFBS3V0RCxXQUFXO2dCQUNsQjtnQkFFQSxzQkFBc0I7Z0JBQ3RCM3FELEVBQUU4cUQsS0FBSyxDQUFDMXREO2dCQUNSLElBQUk0QyxFQUFFd3FELG9CQUFvQixFQUFFO29CQUMxQnB0RCxLQUFJLENBQUM0QyxFQUFFeXFELGFBQWEsQ0FBQyxDQUFDenFELEVBQUV1cUQsWUFBWTtnQkFDdEM7WUFFQSwyQkFBMkI7WUFDN0IsT0FBTyxJQUFJdnFELEVBQUVvcUQsWUFBWSxJQUFJeHZELEtBQUtkLE9BQU87Z0JBQ3ZDLGdCQUFnQjtnQkFDaEIsSUFBSWdCLEtBQUtoQjtnQkFDVHNELE1BQUtrdUQsRUFBRSxDQUFDdHJELEVBQUVtcUQsWUFBWSxFQUFFcnZEO1lBRXhCLFVBQVU7WUFDWixPQUFPLElBQUlrRixFQUFFc3FELFlBQVksSUFBSXh3RCxTQUFTTixXQUFXO2dCQUMvQyxtQkFBbUI7Z0JBQ25CLElBQUlnbUI7Z0JBQ0osSUFBSTNqQixRQUFRO29CQUNWbUUsRUFBRTRxRCxTQUFTLENBQUMvdUQ7b0JBQ1oyakIsT0FBTzNqQixPQUFPRCxRQUFRLENBQUNvRSxFQUFFa3FELEtBQUssQ0FBQztnQkFDakM7Z0JBQ0EsT0FBTzFxQztZQUNUO1lBQ0EsT0FBT3BpQixPQUFNLHdCQUF3QjtRQUN2QyxHQUFHLFdBQVc7SUFDaEI7SUFDQSxPQUFPO0lBRVAsb0JBQW9CO0lBQ3BCbXVELFlBQVksU0FBU0EsV0FBV3R4QyxNQUFNO1FBQ3BDLElBQUl4QyxXQUFXO1lBQ2J5eUMsT0FBTztZQUNQbHVELE9BQU87WUFDUHl1RCxlQUFlO1lBQ2ZlLGNBQWM7WUFDZGQsZUFBZSxDQUFDLEVBQUUsMkJBQTJCO1FBQy9DO1FBQ0F6d0MsU0FBU2piLE9BQU8sQ0FBQyxHQUFHeVksVUFBVXdDO1FBQzlCLE9BQU8sU0FBU3d4QyxlQUFlQyxLQUFLO1lBQ2xDLElBQUkxckQsSUFBSWlhO1lBQ1IsSUFBSTdjLFFBQU8sSUFBSTtZQUNmLElBQUlpOEMsa0JBQWtCajhDLE1BQUszRyxNQUFNLEtBQUsrQztZQUN0QyxJQUFJbWpCLE1BQU0wOEIsa0JBQWtCajhDLFFBQU87Z0JBQUNBO2FBQUssRUFBRSxpQ0FBaUM7WUFFNUUseUJBQXlCO1lBQ3pCLElBQUl2QyxPQUFPNndELFFBQVE7Z0JBQ2pCLDZDQUE2QztnQkFDN0MsSUFBSXRzRCxPQUFPc3NELE1BQU14dUMsS0FBSyxDQUFDO2dCQUN2QixJQUFJbmtCLElBQUlxRyxLQUFLM0ksTUFBTTtnQkFDbkIsSUFBSyxJQUFJdUMsSUFBSSxHQUFHQSxJQUFJRCxHQUFHQyxJQUFLO29CQUMxQiw0QkFBNEI7b0JBQzVCLElBQUlyQixNQUFNeUgsSUFBSSxDQUFDcEcsRUFBRTtvQkFDakIsSUFBSWlELFlBQVl0RSxNQUFNO3dCQUNwQjtvQkFDRjtvQkFDQSxJQUFJdXpELFFBQVEsQ0FBQ2xyRCxFQUFFMHFELGFBQWEsQ0FBQy95RCxJQUFJLEVBQUUseUJBQXlCO29CQUM1RCxJQUFJdXpELE9BQU87d0JBQ1QsSUFBSyxJQUFJUyxNQUFNLEdBQUdDLE1BQU1qdkMsSUFBSWxtQixNQUFNLEVBQUVrMUQsTUFBTUMsS0FBS0QsTUFBTzs0QkFDcERodkMsR0FBRyxDQUFDZ3ZDLElBQUksQ0FBQy92RCxRQUFRLENBQUNvRSxFQUFFa3FELEtBQUssQ0FBQyxDQUFDdnlELElBQUksR0FBRzZCO3dCQUNwQztvQkFDRjtnQkFDRjtnQkFDQSxJQUFJd0csRUFBRXdyRCxZQUFZLEVBQUU7b0JBQ2xCcHVELEtBQUksQ0FBQzRDLEVBQUV5cUQsYUFBYSxDQUFDLENBQUN6cUQsRUFBRWhFLEtBQUs7Z0JBQy9CO1lBRUEsZ0JBQWdCO1lBQ2xCLE9BQU8sSUFBSTB2RCxVQUFVbHlELFdBQVc7Z0JBQzlCLHVCQUF1QjtnQkFFdkIsSUFBSyxJQUFJcXlELE9BQU8sR0FBR0MsT0FBT252QyxJQUFJbG1CLE1BQU0sRUFBRW8xRCxPQUFPQyxNQUFNRCxPQUFRO29CQUN6RCxJQUFJRSxpQkFBaUJwdkMsR0FBRyxDQUFDa3ZDLEtBQUssQ0FBQ2p3RCxRQUFRLENBQUNvRSxFQUFFa3FELEtBQUssQ0FBQztvQkFDaEQsSUFBSThCLFFBQVF4MEQsT0FBTzRILElBQUksQ0FBQzJzRDtvQkFDeEIsSUFBSyxJQUFJenNDLE1BQU0sR0FBR0EsTUFBTTBzQyxNQUFNdjFELE1BQU0sRUFBRTZvQixNQUFPO3dCQUMzQyxJQUFJMnNDLE9BQU9ELEtBQUssQ0FBQzFzQyxJQUFJO3dCQUNyQixJQUFJNHNDLG1CQUFtQixDQUFDbHNELEVBQUUwcUQsYUFBYSxDQUFDdUIsS0FBSzt3QkFDN0MsSUFBSUMsa0JBQWtCOzRCQUNwQkgsY0FBYyxDQUFDRSxLQUFLLEdBQUd6eUQ7d0JBQ3pCO29CQUNGO2dCQUNGO2dCQUNBLElBQUl3RyxFQUFFd3JELFlBQVksRUFBRTtvQkFDbEJwdUQsS0FBSSxDQUFDNEMsRUFBRXlxRCxhQUFhLENBQUMsQ0FBQ3pxRCxFQUFFaEUsS0FBSztnQkFDL0I7WUFDRjtZQUNBLE9BQU9vQixPQUFNLG9CQUFvQjtRQUNuQyxHQUFHLFdBQVc7SUFDaEIsRUFBRSxhQUFhO0FBQ2pCLEdBQUcsU0FBUztBQUVaLElBQUkrdUQsV0FBVztJQUNiQyxnQkFBZ0IsU0FBU0EsZUFBZUMsS0FBSztRQUMzQyxJQUFJcnNELElBQUlxc0Q7UUFDUnJzRCxFQUFFc3NELFdBQVcsR0FBR3RzRCxFQUFFdXNELE1BQU0sR0FBR3ZzRCxFQUFFZCxJQUFJLEdBQUdjLEVBQUVzckQsRUFBRTtRQUN4Q3RyRCxFQUFFd3NELFFBQVEsR0FBR3hzRCxFQUFFeXNELE1BQU0sR0FBR3pzRCxFQUFFd3ZCLEdBQUcsR0FBR3h2QixFQUFFMHNELGNBQWM7UUFDaEQxc0QsRUFBRTJzRCxPQUFPLEdBQUczc0QsRUFBRTRzRCxJQUFJO1FBRWxCLHdDQUF3QztRQUN4QzVzRCxFQUFFNnNELEdBQUcsR0FBRzdzRCxFQUFFOHNELFNBQVMsR0FBRyxTQUFVQyxNQUFNLEVBQUVDLFFBQVE7WUFDOUMsSUFBSTV2RCxRQUFPLElBQUk7WUFDZixJQUFJSixPQUFPcEcsTUFBTWlCLFNBQVMsQ0FBQ2dDLEtBQUssQ0FBQ3JCLElBQUksQ0FBQ3VFLFdBQVc7WUFDakQsT0FBTyxJQUFJNjVDLFVBQVUsU0FBVVIsT0FBTyxFQUFFVixNQUFNO2dCQUM1QyxJQUFJOTdCLFdBQVcsU0FBU0EsU0FBU2xqQixDQUFDO29CQUNoQzBHLE1BQUtveUIsR0FBRyxDQUFDanlCLEtBQUssQ0FBQ0gsT0FBTTZ2RDtvQkFDckI3VyxRQUFRMS9DO2dCQUNWO2dCQUNBLElBQUl3MkQsU0FBU2x3RCxLQUFLd2tCLE1BQU0sQ0FBQztvQkFBQzVIO2lCQUFTO2dCQUNuQyxJQUFJcXpDLFVBQVVDLE9BQU8xckMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCcGtCLE1BQUtrdUQsRUFBRSxDQUFDL3RELEtBQUssQ0FBQ0gsT0FBTTh2RDtZQUN0QjtRQUNGO0lBQ0Y7QUFDRixHQUFHLFNBQVM7QUFFWiwrREFBK0Q7QUFDL0QsOEVBQThFO0FBRTlFLElBQUlDLFNBQVMsQ0FBQztBQUNkO0lBQUNqVTtJQUFVK1E7SUFBVWtDO0NBQVMsQ0FBQ3h5QyxPQUFPLENBQUMsU0FBVXpaLEVBQUM7SUFDaERsQixPQUFPbXVELFFBQVFqdEQ7QUFDakI7QUFFQSxJQUFJa3RELFdBQVc7SUFDYnpULFNBQVN3VCxPQUFPeFQsT0FBTztJQUN2QmgrQixXQUFXd3hDLE9BQU94eEMsU0FBUztJQUMzQnc5QixVQUFVZ1UsT0FBT2hVLFFBQVE7SUFDekJJLFlBQVk0VCxPQUFPNVQsVUFBVTtJQUM3QkUsT0FBTzBULE9BQU8xVCxLQUFLO0lBQ25CRyxnQkFBZ0J1VCxPQUFPdlQsY0FBYztJQUNyQ3JCLE1BQU00VSxPQUFPNVUsSUFBSTtBQUNuQjtBQUVBLElBQUk4VSxXQUFXO0lBQ2IzeEMsU0FBUyxTQUFTQSxRQUFRNHhDLFFBQVE7UUFDaEMsSUFBSWx3RCxRQUFPLElBQUk7UUFDZixJQUFJa3dELGFBQWE5ekQsV0FBVztZQUMxQixJQUFJNkQsTUFBTSxFQUFFO1lBQ1pELEtBQUksQ0FBQyxFQUFFLENBQUN4QixRQUFRLENBQUM4ZixPQUFPLENBQUMvQixPQUFPLENBQUMsU0FBVXdELEdBQUc7Z0JBQzVDLE9BQU85ZixJQUFJcEUsSUFBSSxDQUFDa2tCO1lBQ2xCO1lBQ0EsT0FBTzlmO1FBQ1QsT0FBTyxJQUFJLENBQUN0QyxNQUFNdXlELFdBQVc7WUFDM0IsOEJBQThCO1lBQzlCQSxXQUFXLENBQUNBLFlBQVksRUFBQyxFQUFHcHhELEtBQUssQ0FBQyxXQUFXLEVBQUU7UUFDakQ7UUFDQSxJQUFJcXhELFVBQVUsRUFBRTtRQUNoQixJQUFJQyxhQUFhLElBQUkzekMsTUFBTXl6QztRQUUzQiw0QkFBNEI7UUFDNUIsSUFBSyxJQUFJanVELElBQUksR0FBR0EsSUFBSWpDLE1BQUszRyxNQUFNLEVBQUU0SSxJQUFLO1lBQ3BDLElBQUkwWSxNQUFNM2EsS0FBSSxDQUFDaUMsRUFBRTtZQUNqQixJQUFJa2IsS0FBS3hDLElBQUluYyxRQUFRO1lBQ3JCLElBQUk2eEQsYUFBYWx6QyxHQUFHbUIsT0FBTztZQUMzQixJQUFJZ3lDLGFBQWE7WUFFakIsNkNBQTZDO1lBQzdDLElBQUssSUFBSTEwRCxJQUFJLEdBQUdBLElBQUlzMEQsU0FBUzcyRCxNQUFNLEVBQUV1QyxJQUFLO2dCQUN4QyxJQUFJbWtCLE1BQU1td0MsUUFBUSxDQUFDdDBELEVBQUU7Z0JBQ3JCLElBQUkyMEQsY0FBY0YsV0FBVzMwQyxHQUFHLENBQUNxRTtnQkFDakMsSUFBSSxDQUFDd3dDLGFBQWE7b0JBQ2hCRCxhQUFhO29CQUNiO2dCQUNGO1lBQ0Y7WUFFQSxtREFBbUQ7WUFDbkQsSUFBSSxDQUFDQSxZQUFZO2dCQUNmQSxhQUFhRCxXQUFXbjBDLElBQUksS0FBS2cwQyxTQUFTNzJELE1BQU07WUFDbEQ7WUFDQSxJQUFJaTNELFlBQVk7Z0JBQ2RuekMsR0FBR21CLE9BQU8sR0FBRzh4QztnQkFDYkQsUUFBUXQwRCxJQUFJLENBQUM4ZTtZQUNmO1FBQ0Y7UUFFQSw0REFBNEQ7UUFDNUQsSUFBSXcxQyxRQUFROTJELE1BQU0sR0FBRyxHQUFHO1lBQ3RCLElBQUksQ0FBQ2t2QixLQUFLLENBQUM0bkMsU0FBUzVDLFdBQVcsR0FBR2lDLElBQUksQ0FBQztRQUN6QztRQUNBLE9BQU94dkQ7SUFDVDtJQUNBd3dELFVBQVUsU0FBU0EsU0FBU2x5QyxPQUFPO1FBQ2pDLE9BQU8sSUFBSSxDQUFDbXlDLFdBQVcsQ0FBQ255QyxTQUFTO0lBQ25DO0lBQ0FveUMsVUFBVSxTQUFTQSxTQUFTQyxTQUFTO1FBQ25DLElBQUloMkMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixPQUFPQSxPQUFPLFFBQVFBLElBQUluYyxRQUFRLENBQUM4ZixPQUFPLENBQUM1QyxHQUFHLENBQUNpMUM7SUFDakQ7SUFDQUYsYUFBYSxTQUFTQSxZQUFZbnlDLE9BQU8sRUFBRXN5QyxNQUFNO1FBQy9DLElBQUksQ0FBQ2p6RCxNQUFNMmdCLFVBQVU7WUFDbkIsOEJBQThCO1lBQzlCQSxVQUFVQSxRQUFReGYsS0FBSyxDQUFDLFdBQVcsRUFBRTtRQUN2QztRQUNBLElBQUlrQixRQUFPLElBQUk7UUFDZixJQUFJNndELGVBQWVELFdBQVd4MEQ7UUFDOUIsSUFBSSt6RCxVQUFVLEVBQUUsRUFBRSwrQkFBK0I7UUFFakQsSUFBSyxJQUFJdjBELElBQUksR0FBR2sxRCxLQUFLOXdELE1BQUszRyxNQUFNLEVBQUV1QyxJQUFJazFELElBQUlsMUQsSUFBSztZQUM3QyxJQUFJK2UsTUFBTTNhLEtBQUksQ0FBQ3BFLEVBQUU7WUFDakIsSUFBSXkwRCxhQUFhMTFDLElBQUluYyxRQUFRLENBQUM4ZixPQUFPO1lBQ3JDLElBQUlneUMsYUFBYTtZQUNqQixJQUFLLElBQUlydUQsSUFBSSxHQUFHQSxJQUFJcWMsUUFBUWpsQixNQUFNLEVBQUU0SSxJQUFLO2dCQUN2QyxJQUFJOGQsTUFBTXpCLE9BQU8sQ0FBQ3JjLEVBQUU7Z0JBQ3BCLElBQUl5dUQsV0FBV0wsV0FBVzMwQyxHQUFHLENBQUNxRTtnQkFDOUIsSUFBSWd4QyxhQUFhO2dCQUNqQixJQUFJSCxVQUFVQyxnQkFBZ0IsQ0FBQ0gsVUFBVTtvQkFDdkNMLFdBQVdqMEMsR0FBRyxDQUFDMkQ7b0JBQ2ZneEMsYUFBYTtnQkFDZixPQUFPLElBQUksQ0FBQ0gsVUFBVUMsZ0JBQWdCSCxVQUFVO29CQUM5Q0wsVUFBVSxDQUFDLFNBQVMsQ0FBQ3R3QztvQkFDckJneEMsYUFBYTtnQkFDZjtnQkFDQSxJQUFJLENBQUNULGNBQWNTLFlBQVk7b0JBQzdCWixRQUFRdDBELElBQUksQ0FBQzhlO29CQUNiMjFDLGFBQWE7Z0JBQ2Y7WUFDRixFQUFFLGdCQUFnQjtRQUNwQixFQUFFLGFBQWE7UUFFZiw0REFBNEQ7UUFDNUQsSUFBSUgsUUFBUTkyRCxNQUFNLEdBQUcsR0FBRztZQUN0QixJQUFJLENBQUNrdkIsS0FBSyxDQUFDNG5DLFNBQVM1QyxXQUFXLEdBQUdpQyxJQUFJLENBQUM7UUFDekM7UUFDQSxPQUFPeHZEO0lBQ1Q7SUFDQWd4RCxhQUFhLFNBQVNBLFlBQVkxeUMsT0FBTztRQUN2QyxPQUFPLElBQUksQ0FBQ215QyxXQUFXLENBQUNueUMsU0FBUztJQUNuQztJQUNBMnlDLFlBQVksU0FBU0EsV0FBVzN5QyxPQUFPLEVBQUV3N0IsUUFBUTtRQUMvQyxJQUFJOTVDLFFBQU8sSUFBSTtRQUNmLElBQUk4NUMsWUFBWSxNQUFNO1lBQ3BCQSxXQUFXO1FBQ2IsT0FBTyxJQUFJQSxhQUFhLEdBQUc7WUFDekIsT0FBTzk1QyxPQUFNLHVCQUF1QjtRQUN0QztRQUNBQSxNQUFLd3dELFFBQVEsQ0FBQ2x5QztRQUNkbkssV0FBVztZQUNUblUsTUFBS2d4RCxXQUFXLENBQUMxeUM7UUFDbkIsR0FBR3c3QjtRQUNILE9BQU85NUM7SUFDVDtBQUNGO0FBQ0Fpd0QsU0FBU1UsU0FBUyxHQUFHVixTQUFTaUIsVUFBVSxHQUFHakIsU0FBUzN4QyxPQUFPO0FBRTNELCtCQUErQjtBQUMvQixJQUFJNnlDLFNBQVM7SUFDWEMsVUFBVTtJQUNWLDRDQUE0QztJQUM1Q0MsY0FBYztJQUNkLGdEQUFnRDtJQUNoREMsUUFBUTtJQUNSLHFEQUFxRDtJQUNyRDd6RCxRQUFRLHNCQUFzQixNQUFNO0lBQ3BDLDBFQUEwRTtJQUMxRU8sUUFBUUE7SUFDUix3RUFBd0U7SUFDeEV1ekQsTUFBTTtJQUNOLDBFQUEwRTtJQUMxRUMsV0FBVztJQUNYLDBFQUEwRTtJQUMxRUMsWUFBWTtJQUNaQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVDUwQyxPQUFPO0lBQ1A2MEMsY0FBYztJQUNkQyxnQkFBZ0I7QUFDbEI7QUFDQVYsT0FBT1csUUFBUSxHQUFHLHVCQUF1QlgsT0FBT0MsUUFBUSxHQUFHLE9BQU8saUVBQWlFO0FBQ25JRCxPQUFPUixTQUFTLEdBQUcsc0JBQXNCUSxPQUFPQyxRQUFRLEdBQUcsT0FBTyx1RkFBdUY7QUFDekpELE9BQU9sMkQsS0FBSyxHQUFHazJELE9BQU8xekQsTUFBTSxHQUFHLE1BQU0wekQsT0FBT256RCxNQUFNLEVBQUUsNkNBQTZDO0FBQ2pHbXpELE9BQU85dkMsRUFBRSxHQUFHOHZDLE9BQU9XLFFBQVEsRUFBRSwrQ0FBK0M7QUFFM0U7SUFDQyxJQUFJQyxLQUFLQyxJQUFJcDJEO0lBRWIsaUNBQWlDO0lBQ2pDbTJELE1BQU1aLE9BQU9FLFlBQVksQ0FBQ3Z4QyxLQUFLLENBQUM7SUFDaEMsSUFBS2xrQixJQUFJLEdBQUdBLElBQUltMkQsSUFBSTE0RCxNQUFNLEVBQUV1QyxJQUFLO1FBQy9CbzJELEtBQUtELEdBQUcsQ0FBQ24yRCxFQUFFO1FBQ1h1MUQsT0FBT0UsWUFBWSxJQUFJLE9BQU9XO0lBQ2hDO0lBRUEsaUNBQWlDO0lBQ2pDRCxNQUFNWixPQUFPRSxZQUFZLENBQUN2eEMsS0FBSyxDQUFDO0lBQ2hDLElBQUtsa0IsSUFBSSxHQUFHQSxJQUFJbTJELElBQUkxNEQsTUFBTSxFQUFFdUMsSUFBSztRQUMvQm8yRCxLQUFLRCxHQUFHLENBQUNuMkQsRUFBRTtRQUNYLElBQUlvMkQsR0FBR2p0QyxPQUFPLENBQUMsUUFBUSxHQUFHO1lBQ3hCO1FBQ0YsRUFBRSxxQ0FBcUM7UUFDdkMsSUFBSWl0QyxPQUFPLEtBQUs7WUFDZDtRQUNGLEVBQUUsc0NBQXNDO1FBRXhDYixPQUFPRSxZQUFZLElBQUksU0FBU1c7SUFDbEM7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsSUFBSUMsV0FBVyxTQUFTQTtJQUN0QixPQUFPO1FBQ0xDLFFBQVEsRUFBRTtJQUNaO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxJQUFJQyxPQUFPO0lBQ1QsY0FBYyxHQUNkQyxPQUFPO0lBQ1AsNkJBQTZCLEdBQzdCQyxZQUFZO0lBQ1osMkJBQTJCLEdBQzNCQyxRQUFRO0lBQ1IsbUJBQW1CLEdBQ25CQyxjQUFjO0lBQ2QsZUFBZSxHQUNmQyxZQUFZO0lBQ1osZ0JBQWdCLEdBQ2hCQyxXQUFXO0lBQ1gsd0JBQXdCLEdBQ3hCQyxjQUFjO0lBQ2QsbUJBQW1CLEdBQ25CQyxPQUFPO0lBQ1AsY0FBYyxHQUNkQyxJQUFJO0lBQ0osY0FBYyxHQUNkQyxPQUFPO0lBQ1AsdUJBQXVCLEdBQ3ZCQyxpQkFBaUI7SUFDakIsc0JBQXNCLEdBQ3RCQyxlQUFlO0lBQ2YsdUJBQXVCLEdBQ3ZCQyxhQUFhO0lBQ2IsdUJBQXVCLEdBQ3ZCQyxhQUFhO0lBQ2Isd0JBQXdCLEdBQ3hCQyxlQUFlO0lBQ2YscUJBQXFCLEdBQ3JCQyxPQUFPO0lBQ1AsbUJBQW1CLEdBQ25CQyxZQUFZO0lBQ1osc0JBQXNCLEdBQ3RCQyxRQUFRO0lBQ1Isb0JBQW9CLEdBQ3BCQyxVQUFVO0lBQ1YsNEJBQTRCLEdBQzVCQyxnQkFBZ0I7SUFDaEIsdUVBQXVFLEdBQ3ZFQyxNQUFNO0FBQ1I7QUFFQSxJQUFJQyxpQkFBaUI7SUFBQztRQUNwQjdELFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU9BLElBQUlvRCxRQUFRO1FBQ3JCO0lBQ0Y7SUFBRztRQUNENnhDLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU8sQ0FBQ0EsSUFBSW9ELFFBQVE7UUFDdEI7SUFDRjtJQUFHO1FBQ0Q2eEMsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBT0EsSUFBSXFELFVBQVU7UUFDdkI7SUFDRjtJQUFHO1FBQ0Q0eEMsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBTyxDQUFDQSxJQUFJcUQsVUFBVTtRQUN4QjtJQUNGO0lBQUc7UUFDRDR4QyxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJc0QsTUFBTTtRQUNuQjtJQUNGO0lBQUc7UUFDRDJ4QyxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPLENBQUNBLElBQUlzRCxNQUFNO1FBQ3BCO0lBQ0Y7SUFBRztRQUNEMnhDLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU9BLElBQUlnNUMsT0FBTztRQUNwQjtJQUNGO0lBQUc7UUFDRC9ELFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU8sQ0FBQ0EsSUFBSWc1QyxPQUFPO1FBQ3JCO0lBQ0Y7SUFBRztRQUNEL0QsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBT0EsSUFBSTdXLFdBQVc7UUFDeEI7SUFDRjtJQUFHO1FBQ0Q4ckQsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBT0EsSUFBSXVELE9BQU87UUFDcEI7SUFDRjtJQUFHO1FBQ0QweEMsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBTyxDQUFDQSxJQUFJdUQsT0FBTztRQUNyQjtJQUNGO0lBQUc7UUFDRDB4QyxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJbUQsT0FBTztRQUNwQjtJQUNGO0lBQUc7UUFDRDh4QyxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPLENBQUNBLElBQUltRCxPQUFPO1FBQ3JCO0lBQ0Y7SUFBRztRQUNEOHhDLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU9BLElBQUl3RCxTQUFTO1FBQ3RCO0lBQ0Y7SUFBRztRQUNEeXhDLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU8sQ0FBQ0EsSUFBSXdELFNBQVM7UUFDdkI7SUFDRjtJQUFHO1FBQ0R5eEMsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBT0EsSUFBSW9oQyxRQUFRO1FBQ3JCO0lBQ0Y7SUFBRztRQUNENlQsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBTyxDQUFDQSxJQUFJb2hDLFFBQVE7UUFDdEI7SUFDRjtJQUFHO1FBQ0Q2VCxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJaTVDLFFBQVE7UUFDckI7SUFDRjtJQUFHO1FBQ0RoRSxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJazVDLFdBQVc7UUFDeEI7SUFDRjtJQUFHO1FBQ0RqRSxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJbTVDLE9BQU87UUFDcEI7SUFDRjtJQUFHO1FBQ0RsRSxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJbzVDLFFBQVE7UUFDckI7SUFDRjtJQUFHO1FBQ0RuRSxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixPQUFPQSxJQUFJbTVDLE9BQU87UUFDcEI7SUFDRjtJQUFHO1FBQ0RsRSxVQUFVO1FBQ1Y4RCxTQUFTLFNBQVNBLFFBQVEvNEMsR0FBRztZQUMzQixJQUFJQSxJQUFJb0UsTUFBTSxJQUFJO2dCQUNoQixPQUFPcEUsSUFBSWk1QyxRQUFRO1lBQ3JCLE9BQU87Z0JBQ0wsT0FBT2o1QyxJQUFJc0MsTUFBTSxHQUFHMjJDLFFBQVEsTUFBTWo1QyxJQUFJdUMsTUFBTSxHQUFHMDJDLFFBQVE7WUFDekQ7UUFDRjtJQUNGO0lBQUc7UUFDRGhFLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU9BLElBQUlxTSxNQUFNO1FBQ25CO0lBQ0Y7SUFBRztRQUNENG9DLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU9BLElBQUlxNUMsUUFBUTtRQUNyQjtJQUNGO0lBQUc7UUFDRHBFLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU9BLElBQUkwRCxNQUFNO1FBQ25CO0lBQ0Y7SUFBRztRQUNEdXhDLFVBQVU7UUFDVjhELFNBQVMsU0FBU0EsUUFBUS80QyxHQUFHO1lBQzNCLE9BQU8sQ0FBQ0EsSUFBSTBELE1BQU07UUFDcEI7SUFDRjtJQUFHO1FBQ0R1eEMsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBT0EsSUFBSXNFLGFBQWE7UUFDMUI7SUFDRjtJQUFHO1FBQ0Qyd0MsVUFBVTtRQUNWOEQsU0FBUyxTQUFTQSxRQUFRLzRDLEdBQUc7WUFDM0IsT0FBTyxDQUFDQSxJQUFJc0UsYUFBYTtRQUMzQjtJQUNGO0NBQUUsQ0FBQ2dHLElBQUksQ0FBQyxTQUFVN3JCLENBQUMsRUFBRXNJLENBQUM7SUFDcEIsd0ZBQXdGO0lBQ3hGLE9BQU9DLFdBQVd2SSxFQUFFdzJELFFBQVEsRUFBRWx1RCxFQUFFa3VELFFBQVE7QUFDMUM7QUFDQSxJQUFJcUUsU0FBUztJQUNYLElBQUlDLFVBQVUsQ0FBQztJQUNmLElBQUluNUQ7SUFDSixJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSTYzRCxlQUFlcDZELE1BQU0sRUFBRXVDLElBQUs7UUFDOUNiLElBQUkwNEQsY0FBYyxDQUFDNzNELEVBQUU7UUFDckJzNEQsT0FBTyxDQUFDbjVELEVBQUU2MEQsUUFBUSxDQUFDLEdBQUc3MEQsRUFBRTI0RCxPQUFPO0lBQ2pDO0lBQ0EsT0FBT1E7QUFDVDtBQUNBLElBQUlDLHVCQUF1QixTQUFTQSxxQkFBcUJDLEdBQUcsRUFBRXo1QyxHQUFHO0lBQy9ELE9BQU9zNUMsTUFBTSxDQUFDRyxJQUFJLENBQUN6NUM7QUFDckI7QUFDQSxJQUFJMDVDLHFCQUFxQixNQUFNWixlQUFlcm1ELEdBQUcsQ0FBQyxTQUFVclMsQ0FBQztJQUMzRCxPQUFPQSxFQUFFNjBELFFBQVE7QUFDbkIsR0FBRy92RCxJQUFJLENBQUMsT0FBTztBQUVmLGlHQUFpRztBQUNqRyw0REFBNEQ7QUFDNUQsSUFBSXkwRCxpQkFBaUIsU0FBU0EsZUFBZWgwRCxHQUFHO0lBQzlDLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyxJQUFJd0MsT0FBTyxVQUFVb3VELE9BQU9DLFFBQVEsR0FBRyxLQUFLLE1BQU0sU0FBVXR5RCxLQUFLLEVBQUV5MUQsRUFBRTtRQUN0RixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxJQUFJQyxtQkFBbUIsU0FBU0EsaUJBQWlCNUUsUUFBUSxFQUFFNkUsY0FBYyxFQUFFQyxnQkFBZ0I7SUFDekY5RSxRQUFRLENBQUNBLFNBQVN2MkQsTUFBTSxHQUFHLEVBQUUsR0FBR3E3RDtBQUNsQztBQUVBLDRFQUE0RTtBQUM1RSw4RUFBOEU7QUFDOUUsK0NBQStDO0FBQy9DLHVIQUF1SDtBQUN2SCxJQUFJQyxRQUFRO0lBQUM7UUFDWGo0RCxNQUFNO1FBQ04sMkNBQTJDO1FBQzNDazRELE9BQU87UUFDUEMsT0FBTyxNQUFNMUQsT0FBT3AwQyxLQUFLLEdBQUc7UUFDNUIrM0MsVUFBVSxTQUFTQSxTQUFTbEYsUUFBUSxFQUFFZ0YsS0FBSyxFQUFFcHdDLElBQUk7WUFDL0MsSUFBSXV3QyxRQUFRLzRELGVBQWV3b0IsTUFBTSxJQUMvQnpILFFBQVFnNEMsS0FBSyxDQUFDLEVBQUU7WUFDbEJILE1BQU0xQyxNQUFNLENBQUNyMkQsSUFBSSxDQUFDO2dCQUNoQnFTLE1BQU1pa0QsS0FBS0MsS0FBSztnQkFDaEJuM0QsT0FBTzhoQixVQUFVLE1BQU1BLFFBQVFBLFFBQVE7WUFDekM7UUFDRjtJQUNGO0lBQUc7UUFDRHJnQixNQUFNO1FBQ05rNEQsT0FBTztRQUNQQyxPQUFPUjtRQUNQUyxVQUFVLFNBQVNBLFNBQVNsRixRQUFRLEVBQUVnRixLQUFLLEVBQUVJLEtBQUs7WUFDaEQsSUFBSUMsUUFBUWo1RCxlQUFlZzVELE9BQU8sSUFDaENqZCxRQUFRa2QsS0FBSyxDQUFDLEVBQUU7WUFDbEJMLE1BQU0xQyxNQUFNLENBQUNyMkQsSUFBSSxDQUFDO2dCQUNoQnFTLE1BQU1pa0QsS0FBS1EsS0FBSztnQkFDaEIxM0QsT0FBTzg4QztZQUNUO1FBQ0Y7SUFDRjtJQUFHO1FBQ0RyN0MsTUFBTTtRQUNOazRELE9BQU87UUFDUEMsT0FBTyxTQUFTMUQsT0FBTzl2QyxFQUFFLEdBQUc7UUFDNUJ5ekMsVUFBVSxTQUFTQSxTQUFTbEYsUUFBUSxFQUFFZ0YsS0FBSyxFQUFFTSxLQUFLO1lBQ2hELElBQUlDLFFBQVFuNUQsZUFBZWs1RCxPQUFPLElBQ2hDN3pDLEtBQUs4ekMsS0FBSyxDQUFDLEVBQUU7WUFDZlAsTUFBTTFDLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7Z0JBQ2hCcVMsTUFBTWlrRCxLQUFLUyxFQUFFO2dCQUNiMzNELE9BQU9xNUQsZUFBZWp6QztZQUN4QjtRQUNGO0lBQ0Y7SUFBRztRQUNEM2tCLE1BQU07UUFDTms0RCxPQUFPO1FBQ1BDLE9BQU8sU0FBUzFELE9BQU9SLFNBQVMsR0FBRztRQUNuQ21FLFVBQVUsU0FBU0EsU0FBU2xGLFFBQVEsRUFBRWdGLEtBQUssRUFBRVEsS0FBSztZQUNoRCxJQUFJQyxRQUFRcjVELGVBQWVvNUQsT0FBTyxJQUNoQ3pFLFlBQVkwRSxLQUFLLENBQUMsRUFBRTtZQUN0QlQsTUFBTTFDLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7Z0JBQ2hCcVMsTUFBTWlrRCxLQUFLVSxLQUFLO2dCQUNoQjUzRCxPQUFPcTVELGVBQWUzRDtZQUN4QjtRQUNGO0lBQ0Y7SUFBRztRQUNEajBELE1BQU07UUFDTms0RCxPQUFPO1FBQ1BDLE9BQU8sYUFBYTFELE9BQU9XLFFBQVEsR0FBRztRQUN0Q2dELFVBQVUsU0FBU0EsU0FBU2xGLFFBQVEsRUFBRWdGLEtBQUssRUFBRVUsS0FBSztZQUNoRCxJQUFJQyxTQUFTdjVELGVBQWVzNUQsT0FBTyxJQUNqQ3hELFdBQVd5RCxNQUFNLENBQUMsRUFBRTtZQUN0QlgsTUFBTTFDLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7Z0JBQ2hCcVMsTUFBTWlrRCxLQUFLSyxVQUFVO2dCQUNyQjFGLE9BQU93SCxlQUFleEM7WUFDeEI7UUFDRjtJQUNGO0lBQUc7UUFDRHAxRCxNQUFNO1FBQ05rNEQsT0FBTztRQUNQQyxPQUFPLGFBQWExRCxPQUFPVyxRQUFRLEdBQUcsV0FBV1gsT0FBT0UsWUFBWSxHQUFHLFdBQVdGLE9BQU9sMkQsS0FBSyxHQUFHO1FBQ2pHNjVELFVBQVUsU0FBU0EsU0FBU2xGLFFBQVEsRUFBRWdGLEtBQUssRUFBRVksTUFBTTtZQUNqRCxJQUFJQyxTQUFTejVELGVBQWV3NUQsUUFBUSxJQUNsQzFELFdBQVcyRCxNQUFNLENBQUMsRUFBRSxFQUNwQnBFLGVBQWVvRSxNQUFNLENBQUMsRUFBRSxFQUN4Qng2RCxRQUFRdzZELE1BQU0sQ0FBQyxFQUFFO1lBQ25CLElBQUlDLGdCQUFnQixJQUFJM3lELE9BQU8sTUFBTW91RCxPQUFPMXpELE1BQU0sR0FBRyxLQUFLdUYsSUFBSSxDQUFDL0gsVUFBVTtZQUN6RSxJQUFJeTZELGVBQWU7Z0JBQ2pCejZELFFBQVFBLE1BQU02RixTQUFTLENBQUMsR0FBRzdGLE1BQU01QixNQUFNLEdBQUc7WUFDNUMsT0FBTztnQkFDTDRCLFFBQVFnSSxXQUFXaEk7WUFDckI7WUFDQTI1RCxNQUFNMUMsTUFBTSxDQUFDcjJELElBQUksQ0FBQztnQkFDaEJxUyxNQUFNaWtELEtBQUtJLFlBQVk7Z0JBQ3ZCekYsT0FBT3dILGVBQWV4QztnQkFDdEI2RCxVQUFVdEU7Z0JBQ1ZwMkQsT0FBT0E7WUFDVDtRQUNGO0lBQ0Y7SUFBRztRQUNEeUIsTUFBTTtRQUNOazRELE9BQU87UUFDUEMsT0FBTyxhQUFhMUQsT0FBT0csTUFBTSxHQUFHLFdBQVdILE9BQU9XLFFBQVEsR0FBRztRQUNqRWdELFVBQVUsU0FBU0EsU0FBU2xGLFFBQVEsRUFBRWdGLEtBQUssRUFBRWdCLE1BQU07WUFDakQsSUFBSUMsU0FBUzc1RCxlQUFlNDVELFFBQVEsSUFDbEN0RSxTQUFTdUUsTUFBTSxDQUFDLEVBQUUsRUFDbEIvRCxXQUFXK0QsTUFBTSxDQUFDLEVBQUU7WUFDdEJqQixNQUFNMUMsTUFBTSxDQUFDcjJELElBQUksQ0FBQztnQkFDaEJxUyxNQUFNaWtELEtBQUtNLFNBQVM7Z0JBQ3BCM0YsT0FBT3dILGVBQWV4QztnQkFDdEI2RCxVQUFVckU7WUFDWjtRQUNGO0lBQ0Y7SUFBRztRQUNENTBELE1BQU07UUFDTms0RCxPQUFPO1FBQ1BDLE9BQU8sZ0JBQWdCMUQsT0FBT0ksSUFBSSxHQUFHLFdBQVdKLE9BQU9FLFlBQVksR0FBRyxXQUFXRixPQUFPbnpELE1BQU0sR0FBRztRQUNqRzgyRCxVQUFVLFNBQVNBLFNBQVNsRixRQUFRLEVBQUVnRixLQUFLLEVBQUVrQixNQUFNO1lBQ2pELElBQUlDLFNBQVMvNUQsZUFBZTg1RCxRQUFRLElBQ2xDdkUsT0FBT3dFLE1BQU0sQ0FBQyxFQUFFLEVBQ2hCMUUsZUFBZTBFLE1BQU0sQ0FBQyxFQUFFLEVBQ3hCLzNELFNBQVMrM0QsTUFBTSxDQUFDLEVBQUU7WUFDcEJuQixNQUFNMUMsTUFBTSxDQUFDcjJELElBQUksQ0FBQztnQkFDaEJxUyxNQUFNaWtELEtBQUtPLFlBQVk7Z0JBQ3ZCNUYsT0FBT3dILGVBQWUvQztnQkFDdEJvRSxVQUFVdEU7Z0JBQ1ZwMkQsT0FBT2dJLFdBQVdqRjtZQUNwQjtRQUNGO0lBQ0Y7SUFBRztRQUNEdEIsTUFBTTtRQUNOODBELFdBQVc7UUFDWHFELE9BQU8xRCxPQUFPSyxTQUFTO1FBQ3ZCc0QsVUFBVSxTQUFTQSxTQUFTbEYsUUFBUSxFQUFFZ0YsS0FBSztZQUN6QyxJQUFJb0IsaUJBQWlCcEcsU0FBU29HLGNBQWM7WUFDNUMsSUFBSXpnQixZQUFZcWEsU0FBU3JhLFNBQVM7WUFDbEMsSUFBSTBnQixnQkFBZ0JyRyxTQUFTcUcsYUFBYTtZQUMxQyxJQUFJQyxRQUFRdEcsUUFBUSxDQUFDQSxTQUFTdjJELE1BQU0sR0FBRyxFQUFFO1lBQ3pDLElBQUkyOEQsa0JBQWtCLE1BQU07Z0JBQzFCRSxNQUFNdkUsT0FBTyxHQUFHcUU7Z0JBQ2hCcEcsU0FBU29HLGNBQWMsR0FBRztZQUM1QjtZQUNBRSxNQUFNM2dCLFNBQVMsR0FBR0E7WUFDbEIyZ0IsTUFBTUQsYUFBYSxHQUFHQTtZQUN0QnJHLFNBQVNyYSxTQUFTLEdBQUc7WUFDckJxYSxTQUFTcUcsYUFBYSxHQUFHO1lBRXpCLHNCQUFzQjtZQUN0QixJQUFJRSxZQUFZdkcsUUFBUSxDQUFDQSxTQUFTdjJELE1BQU0sR0FBRyxHQUFHNDREO1lBQzlDLE9BQU9rRSxXQUFXLDREQUE0RDtRQUNoRjtJQUNGO0lBQUc7UUFDRHo1RCxNQUFNO1FBQ044MEQsV0FBVztRQUNYcUQsT0FBTzFELE9BQU9TLFlBQVk7UUFDMUJrRCxVQUFVLFNBQVNBLFNBQVNsRixRQUFRLEVBQUVnRixLQUFLO1lBQ3pDLElBQUloRixTQUFTb0csY0FBYyxJQUFJLE1BQU07Z0JBQ25DLGtCQUFrQjtnQkFDbEIsSUFBSUksWUFBWW5FO2dCQUNoQixJQUFJaDFDLFNBQVMyM0M7Z0JBQ2IsSUFBSTEzQyxTQUFTKzBDO2dCQUNibUUsVUFBVWxFLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7b0JBQ3BCcVMsTUFBTWlrRCxLQUFLWSxhQUFhO29CQUN4QjkxQyxRQUFRQTtvQkFDUkMsUUFBUUE7Z0JBQ1Y7Z0JBRUEsc0VBQXNFO2dCQUN0RXMzQyxpQkFBaUI1RSxVQUFVZ0YsT0FBT3dCO2dCQUNsQ3hHLFNBQVNyYSxTQUFTO2dCQUVsQixxRUFBcUU7Z0JBQ3JFLE9BQU9yNEI7WUFDVCxPQUFPO2dCQUNMLGdCQUFnQjtnQkFDaEIsSUFBSW01QyxVQUFVcEU7Z0JBQ2QsSUFBSXFFLFVBQVUxQjtnQkFDZCxJQUFJMkIsVUFBVXRFO2dCQUNkb0UsUUFBUW5FLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7b0JBQ2xCcVMsTUFBTWlrRCxLQUFLYSxXQUFXO29CQUN0Qi8xQyxRQUFRcTVDO29CQUNScDVDLFFBQVFxNUM7Z0JBQ1Y7Z0JBRUEsNkVBQTZFO2dCQUM3RS9CLGlCQUFpQjVFLFVBQVVnRixPQUFPeUI7Z0JBQ2xDekcsU0FBU3JhLFNBQVM7Z0JBQ2xCLE9BQU9naEIsU0FBUywyREFBMkQ7WUFDN0U7UUFDRjtJQUNGO0lBQUc7UUFDRDc1RCxNQUFNO1FBQ044MEQsV0FBVztRQUNYcUQsT0FBTzFELE9BQU9VLGNBQWM7UUFDNUJpRCxVQUFVLFNBQVNBLFNBQVNsRixRQUFRLEVBQUVnRixLQUFLO1lBQ3pDLElBQUloRixTQUFTb0csY0FBYyxJQUFJLE1BQU07Z0JBQ25DLGtCQUFrQjtnQkFDbEIsSUFBSUksWUFBWW5FO2dCQUNoQixJQUFJaDFDLFNBQVMyM0M7Z0JBQ2IsSUFBSTEzQyxTQUFTKzBDO2dCQUNibUUsVUFBVWxFLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7b0JBQ3BCcVMsTUFBTWlrRCxLQUFLVyxlQUFlO29CQUMxQjV4QyxPQUFPO3dCQUFDakU7d0JBQVFDO3FCQUFPO2dCQUN6QjtnQkFFQSxzRUFBc0U7Z0JBQ3RFczNDLGlCQUFpQjVFLFVBQVVnRixPQUFPd0I7Z0JBQ2xDeEcsU0FBU3JhLFNBQVM7Z0JBRWxCLHFFQUFxRTtnQkFDckUsT0FBT3I0QjtZQUNULE9BQU87Z0JBQ0wsZ0JBQWdCO2dCQUNoQixJQUFJczVDLFNBQVN2RTtnQkFDYixJQUFJMXZDLE9BQU9xeUM7Z0JBQ1gsSUFBSTZCLFdBQVd4RTtnQkFDZnVFLE9BQU90RSxNQUFNLENBQUNyMkQsSUFBSSxDQUFDO29CQUNqQnFTLE1BQU1pa0QsS0FBS2UsYUFBYTtvQkFDeEIzd0MsTUFBTUE7b0JBQ05rMEMsVUFBVUE7Z0JBQ1o7Z0JBRUEsNkVBQTZFO2dCQUM3RWpDLGlCQUFpQjVFLFVBQVVnRixPQUFPNEI7Z0JBQ2xDLE9BQU9DLFVBQVUseURBQXlEO1lBQzVFO1FBQ0Y7SUFDRjtJQUFHO1FBQ0QvNUQsTUFBTTtRQUNOODBELFdBQVc7UUFDWHFELE9BQU8xRCxPQUFPTyxLQUFLO1FBQ25Cb0QsVUFBVSxTQUFTQSxTQUFTbEYsUUFBUSxFQUFFZ0YsS0FBSztZQUN6QyxJQUFJaEYsU0FBU29HLGNBQWMsSUFBSSxNQUFNO2dCQUNuQyx1QkFBdUI7Z0JBQ3ZCLElBQUlVLG1CQUFtQnpFO2dCQUN2QixJQUFJUCxRQUFRTztnQkFDWixJQUFJbnpDLFNBQVM4d0MsUUFBUSxDQUFDQSxTQUFTdjJELE1BQU0sR0FBRyxFQUFFO2dCQUMxQ3E5RCxpQkFBaUJ4RSxNQUFNLENBQUNyMkQsSUFBSSxDQUFDO29CQUMzQnFTLE1BQU1pa0QsS0FBS2dCLEtBQUs7b0JBQ2hCcjBDLFFBQVFBO29CQUNSNHlDLE9BQU9BO2dCQUNUO2dCQUVBLHFEQUFxRDtnQkFDckQ4QyxpQkFBaUI1RSxVQUFVZ0YsT0FBTzhCO2dCQUNsQzlHLFNBQVNxRyxhQUFhO2dCQUV0QixvRUFBb0U7Z0JBQ3BFLE9BQU92RTtZQUNULE9BQU8sSUFBSTlCLFNBQVNvRyxjQUFjLEtBQUtwQixPQUFPO2dCQUM1Qyx1QkFBdUI7Z0JBQ3ZCLElBQUkrQixXQUFXMUU7Z0JBQ2YsSUFBSXg5QixPQUFPbTdCLFFBQVEsQ0FBQ0EsU0FBU3YyRCxNQUFNLEdBQUcsRUFBRTtnQkFDeEMsSUFBSWs3QixRQUFRMDlCO2dCQUNaLElBQUlOLFVBQVVNO2dCQUNkLElBQUkyRSxTQUFTM0U7Z0JBQ2IsSUFBSTRFLFVBQVU1RTtnQkFFZCw2QkFBNkI7Z0JBQzdCMEUsU0FBU3pFLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7b0JBQ25CcVMsTUFBTWlrRCxLQUFLb0IsY0FBYztvQkFDekI5K0IsTUFBTUE7b0JBQ05GLE9BQU9BO29CQUNQbzlCLFNBQVNBO2dCQUNYO2dCQUVBLGlGQUFpRjtnQkFDakZBLFFBQVFPLE1BQU0sR0FBRzBDLE1BQU0xQyxNQUFNLEVBQUUsZ0NBQWdDO2dCQUMvRDBDLE1BQU0xQyxNQUFNLEdBQUc7b0JBQUM7d0JBQ2Roa0QsTUFBTWlrRCxLQUFLcUIsSUFBSTtvQkFDakI7aUJBQUUsRUFBRSxnREFBZ0Q7Z0JBRXBELHFCQUFxQjtnQkFDckJxRCxRQUFRM0UsTUFBTSxDQUFDcjJELElBQUksQ0FBQztvQkFDbEJxUyxNQUFNaWtELEtBQUtxQixJQUFJO2dCQUNqQixJQUFJLHFDQUFxQztnQkFDekNqL0IsTUFBTTI5QixNQUFNLENBQUNyMkQsSUFBSSxDQUFDO29CQUNoQnFTLE1BQU1pa0QsS0FBS2tCLE1BQU07b0JBQ2pCLHdDQUF3QztvQkFDeEN2MEMsUUFBUSszQztvQkFDUm5GLE9BQU9rRixPQUFPLGdCQUFnQjtnQkFDaEM7Z0JBQ0FwQyxpQkFBaUI1RSxVQUFVbjdCLE1BQU1raUM7Z0JBRWpDLDBEQUEwRDtnQkFDMUQvRyxTQUFTb0csY0FBYyxHQUFHckU7Z0JBQzFCL0IsU0FBU3FHLGFBQWE7Z0JBQ3RCLE9BQU9XLFFBQVEsd0NBQXdDO1lBQ3pELE9BQU87Z0JBQ0wsZUFBZTtnQkFDZix3QkFBd0I7Z0JBQ3hCLElBQUlFLFdBQVc3RTtnQkFDZixJQUFJOEUsVUFBVTlFO2dCQUNkLElBQUkrRSxZQUFZO29CQUFDO3dCQUNmOW9ELE1BQU1pa0QsS0FBS2tCLE1BQU07d0JBQ2pCdjBDLFFBQVFnNEM7d0JBQ1JwRixPQUFPcUY7b0JBQ1Q7aUJBQUU7Z0JBRUYsaUZBQWlGO2dCQUNqRkQsU0FBUzVFLE1BQU0sR0FBRzBDLE1BQU0xQyxNQUFNLEVBQUUsd0RBQXdEO2dCQUN4RjBDLE1BQU0xQyxNQUFNLEdBQUc4RSxXQUFXLHNCQUFzQjtnQkFFaERwSCxTQUFTcUcsYUFBYTtnQkFDdEIsT0FBT2MsU0FBUyxpQ0FBaUM7WUFDbkQ7UUFDRjtJQUNGO0lBQUc7UUFDRHI2RCxNQUFNO1FBQ044MEQsV0FBVztRQUNYcUQsT0FBTzFELE9BQU9NLFVBQVU7UUFDeEJxRCxVQUFVLFNBQVNBLFNBQVNsRixRQUFRLEVBQUVnRixLQUFLO1lBQ3pDLElBQUloRixTQUFTb0csY0FBYyxJQUFJLE1BQU07Z0JBQ25DLDRCQUE0QjtnQkFDNUIsSUFBSWlCLGFBQWFoRjtnQkFDakIsSUFBSVIsYUFBYVE7Z0JBQ2pCLElBQUlpRixXQUFXdEgsUUFBUSxDQUFDQSxTQUFTdjJELE1BQU0sR0FBRyxFQUFFO2dCQUM1QzQ5RCxXQUFXL0UsTUFBTSxDQUFDcjJELElBQUksQ0FBQztvQkFDckJxUyxNQUFNaWtELEtBQUtpQixVQUFVO29CQUNyQjhELFVBQVVBO29CQUNWekYsWUFBWUE7Z0JBQ2Q7Z0JBRUEscURBQXFEO2dCQUNyRCtDLGlCQUFpQjVFLFVBQVVnRixPQUFPcUM7Z0JBQ2xDckgsU0FBU3FHLGFBQWE7Z0JBRXRCLHlFQUF5RTtnQkFDekUsT0FBT3hFO1lBQ1QsT0FBTyxJQUFJN0IsU0FBU29HLGNBQWMsS0FBS3BCLE9BQU87Z0JBQzVDLHVCQUF1QjtnQkFDdkIsSUFBSStCLFdBQVcxRTtnQkFDZixJQUFJeDlCLE9BQU9tN0IsUUFBUSxDQUFDQSxTQUFTdjJELE1BQU0sR0FBRyxFQUFFO2dCQUN4QyxJQUFJazdCLFFBQVEwOUI7Z0JBQ1osSUFBSU4sVUFBVU07Z0JBQ2QsSUFBSWtGLGNBQWNsRjtnQkFDbEIsSUFBSW1GLFlBQVluRjtnQkFFaEIsNkJBQTZCO2dCQUM3QjBFLFNBQVN6RSxNQUFNLENBQUNyMkQsSUFBSSxDQUFDO29CQUNuQnFTLE1BQU1pa0QsS0FBS29CLGNBQWM7b0JBQ3pCOStCLE1BQU1BO29CQUNORixPQUFPQTtvQkFDUG85QixTQUFTQTtnQkFDWDtnQkFFQSxpRkFBaUY7Z0JBQ2pGQSxRQUFRTyxNQUFNLEdBQUcwQyxNQUFNMUMsTUFBTSxFQUFFLGdDQUFnQztnQkFDL0QwQyxNQUFNMUMsTUFBTSxHQUFHO29CQUFDO3dCQUNkaGtELE1BQU1pa0QsS0FBS3FCLElBQUk7b0JBQ2pCO2lCQUFFLEVBQUUsZ0RBQWdEO2dCQUVwRCxxQkFBcUI7Z0JBQ3JCNEQsVUFBVWxGLE1BQU0sQ0FBQ3IyRCxJQUFJLENBQUM7b0JBQ3BCcVMsTUFBTWlrRCxLQUFLcUIsSUFBSTtnQkFDakIsSUFBSSx1Q0FBdUM7Z0JBQzNDai9CLE1BQU0yOUIsTUFBTSxDQUFDcjJELElBQUksQ0FBQztvQkFDaEJxUyxNQUFNaWtELEtBQUttQixRQUFRO29CQUNuQix3Q0FBd0M7b0JBQ3hDNEQsVUFBVUU7b0JBQ1YzRixZQUFZMEYsWUFBWSxnQkFBZ0I7Z0JBQzFDO2dCQUNBM0MsaUJBQWlCNUUsVUFBVW43QixNQUFNa2lDO2dCQUVqQywwREFBMEQ7Z0JBQzFEL0csU0FBU29HLGNBQWMsR0FBR3JFO2dCQUMxQi9CLFNBQVNxRyxhQUFhO2dCQUN0QixPQUFPa0IsYUFBYSw2Q0FBNkM7WUFDbkUsT0FBTztnQkFDTCxpQkFBaUI7Z0JBQ2pCLHdCQUF3QjtnQkFDeEIsSUFBSUUsYUFBYXBGO2dCQUNqQixJQUFJcUYsZUFBZXJGO2dCQUNuQixJQUFJc0YsWUFBWTtvQkFBQzt3QkFDZnJwRCxNQUFNaWtELEtBQUttQixRQUFRO3dCQUNuQjRELFVBQVVHO3dCQUNWNUYsWUFBWTZGO29CQUNkO2lCQUFFO2dCQUVGLGlGQUFpRjtnQkFDakZELFdBQVduRixNQUFNLEdBQUcwQyxNQUFNMUMsTUFBTSxFQUFFLHdEQUF3RDtnQkFDMUYwQyxNQUFNMUMsTUFBTSxHQUFHcUYsV0FBVyxzQkFBc0I7Z0JBRWhEM0gsU0FBU3FHLGFBQWE7Z0JBQ3RCLE9BQU9xQixjQUFjLGlDQUFpQztZQUN4RDtRQUNGO0lBQ0Y7SUFBRztRQUNENTZELE1BQU07UUFDTjg2RCxVQUFVO1FBQ1YzQyxPQUFPMUQsT0FBT1EsT0FBTztRQUNyQm1ELFVBQVUsU0FBU0EsU0FBU2xGLFFBQVEsRUFBRWdGLEtBQUs7WUFDekMsSUFBSWhGLFNBQVNvRyxjQUFjLElBQUksUUFBUXBHLFNBQVNvRyxjQUFjLEtBQUtwQixPQUFPO2dCQUN4RWg4QyxLQUFLLDBDQUEwQ2czQyxTQUFTcHpELFFBQVEsS0FBSztnQkFDckUsT0FBTztZQUNUO1lBQ0FvekQsU0FBU29HLGNBQWMsR0FBR3BCO1lBQzFCLElBQUk2QyxPQUFPN0gsUUFBUSxDQUFDQSxTQUFTdjJELE1BQU0sR0FBRyxFQUFFO1lBQ3hDLElBQUlxK0QsU0FBU0QsS0FBS3ZGLE1BQU0sQ0FBQyxFQUFFO1lBQzNCLElBQUl5RixVQUFVRCxVQUFVLE9BQU8sT0FBT0EsT0FBT3hwRCxJQUFJO1lBQ2pELElBQUl5cEQsWUFBWXhGLEtBQUtZLGFBQWEsRUFBRTtnQkFDbEMsMkNBQTJDO2dCQUUzQyw4QkFBOEI7Z0JBQzlCMkUsT0FBT3hwRCxJQUFJLEdBQUdpa0QsS0FBS2MsV0FBVztZQUNoQyxPQUFPLElBQUkwRSxZQUFZeEYsS0FBS1csZUFBZSxFQUFFO2dCQUMzQyxrREFBa0Q7Z0JBRWxELDJCQUEyQjtnQkFDM0I0RSxPQUFPeHBELElBQUksR0FBR2lrRCxLQUFLZSxhQUFhO2dCQUNoQ3dFLE9BQU9uMUMsSUFBSSxHQUFHbTFDLE9BQU94MkMsS0FBSyxDQUFDLEVBQUUsRUFBRSx5QkFBeUI7Z0JBQ3hEdzJDLE9BQU9qQixRQUFRLEdBQUdpQixPQUFPeDJDLEtBQUssQ0FBQyxFQUFFO2dCQUVqQyxzQ0FBc0M7Z0JBQ3RDdzJDLE9BQU94MkMsS0FBSyxHQUFHO1lBQ2pCO1FBQ0Y7SUFDRjtDQUFFO0FBQ0Z5ekMsTUFBTXA0QyxPQUFPLENBQUMsU0FBVWpqQixDQUFDO0lBQ3ZCLE9BQU9BLEVBQUVzK0QsUUFBUSxHQUFHLElBQUk3MEQsT0FBTyxNQUFNekosRUFBRXU3RCxLQUFLO0FBQzlDO0FBRUE7Ozs7Q0FJQyxHQUNELElBQUlnRCxjQUFjLFNBQVNBLFlBQVlDLFNBQVM7SUFDOUMsSUFBSUM7SUFDSixJQUFJajVEO0lBQ0osSUFBSXBDO0lBQ0osSUFBSyxJQUFJdUYsSUFBSSxHQUFHQSxJQUFJMHlELE1BQU10N0QsTUFBTSxFQUFFNEksSUFBSztRQUNyQyxJQUFJM0ksSUFBSXE3RCxLQUFLLENBQUMxeUQsRUFBRTtRQUNoQixJQUFJMUksSUFBSUQsRUFBRW9ELElBQUk7UUFDZCxJQUFJb0csS0FBSWcxRCxVQUFVaDVELEtBQUssQ0FBQ3hGLEVBQUVzK0QsUUFBUTtRQUNsQyxJQUFJOTBELE1BQUssTUFBTTtZQUNiaEUsUUFBUWdFO1lBQ1JpMUQsT0FBT3orRDtZQUNQb0QsT0FBT25EO1lBQ1AsSUFBSXkrRCxXQUFXbDFELEVBQUMsQ0FBQyxFQUFFO1lBQ25CZzFELFlBQVlBLFVBQVVoM0QsU0FBUyxDQUFDazNELFNBQVMzK0QsTUFBTTtZQUMvQyxPQUFPLGdEQUFnRDtRQUN6RDtJQUNGO0lBQ0EsT0FBTztRQUNMMCtELE1BQU1BO1FBQ05qNUQsT0FBT0E7UUFDUHBDLE1BQU1BO1FBQ05vN0QsV0FBV0E7SUFDYjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELElBQUlHLG9CQUFvQixTQUFTQSxrQkFBa0JILFNBQVM7SUFDMUQsSUFBSWg1RCxRQUFRZzVELFVBQVVoNUQsS0FBSyxDQUFDO0lBQzVCLElBQUlBLE9BQU87UUFDVCxJQUFJazVELFdBQVdsNUQsS0FBSyxDQUFDLEVBQUU7UUFDdkJnNUQsWUFBWUEsVUFBVWgzRCxTQUFTLENBQUNrM0QsU0FBUzMrRCxNQUFNO0lBQ2pEO0lBQ0EsT0FBT3krRDtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELElBQUlJLFFBQVEsU0FBU0EsTUFBTXRJLFFBQVE7SUFDakMsSUFBSTV2RCxRQUFPLElBQUk7SUFDZixJQUFJODNELFlBQVk5M0QsTUFBS200RCxTQUFTLEdBQUd2STtJQUNqQyxJQUFJd0ksZUFBZXA0RCxLQUFJLENBQUMsRUFBRSxHQUFHaXlEO0lBQzdCanlELE1BQUszRyxNQUFNLEdBQUc7SUFDZHkrRCxZQUFZRyxrQkFBa0JILFlBQVksZ0NBQWdDO0lBRTFFLE9BQVM7UUFDUCxJQUFJTyxXQUFXUixZQUFZQztRQUMzQixJQUFJTyxTQUFTTixJQUFJLElBQUksTUFBTTtZQUN6Qm4vQyxLQUFLLG1CQUFtQmczQyxXQUFXO1lBQ25DLE9BQU87UUFDVCxPQUFPO1lBQ0wsSUFBSWh3RCxPQUFPeTRELFNBQVN2NUQsS0FBSyxDQUFDckMsS0FBSyxDQUFDO1lBRWhDLDZEQUE2RDtZQUM3RCxJQUFJd0QsTUFBTW80RCxTQUFTTixJQUFJLENBQUNqRCxRQUFRLENBQUM5MEQsT0FBTW80RCxjQUFjeDREO1lBQ3JELElBQUlLLFFBQVEsT0FBTztnQkFDakIsT0FBTyxPQUFPLDRCQUE0QjtZQUM1QyxPQUFPLElBQUlBLE9BQU8sTUFBTTtnQkFDdEJtNEQsZUFBZW40RCxLQUFLLDhEQUE4RDtZQUNwRjtRQUNGO1FBQ0E2M0QsWUFBWU8sU0FBU1AsU0FBUztRQUU5QixnREFBZ0Q7UUFDaEQsSUFBSUEsVUFBVWg1RCxLQUFLLENBQUMsVUFBVTtZQUM1QjtRQUNGO0lBQ0Y7SUFDQSxJQUFJbzNELFFBQVFsMkQsS0FBSSxDQUFDQSxNQUFLM0csTUFBTSxHQUFHLEVBQUU7SUFDakMsSUFBSTJHLE1BQUtnMkQsY0FBYyxJQUFJLE1BQU07UUFDL0JFLE1BQU12RSxPQUFPLEdBQUczeEQsTUFBS2cyRCxjQUFjO0lBQ3JDO0lBQ0FFLE1BQU0zZ0IsU0FBUyxHQUFHdjFDLE1BQUt1MUMsU0FBUztJQUNoQzJnQixNQUFNRCxhQUFhLEdBQUdqMkQsTUFBS2kyRCxhQUFhO0lBQ3hDLElBQUssSUFBSXI2RCxJQUFJLEdBQUdBLElBQUlvRSxNQUFLM0csTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJaUgsSUFBSTdDLEtBQUksQ0FBQ3BFLEVBQUU7UUFFZix1SEFBdUg7UUFDdkgsSUFBSWlILEVBQUVvekQsYUFBYSxHQUFHLEtBQUtwekQsRUFBRTB5QyxTQUFTLEdBQUcsR0FBRztZQUMxQzM4QixLQUFLLG1CQUFtQmczQyxXQUFXO1lBQ25DLE9BQU87UUFDVDtRQUNBLElBQUkvc0QsRUFBRTB5QyxTQUFTLEdBQUcsR0FBRztZQUNuQjM4QixLQUFLLG1CQUFtQmczQyxXQUFXO1lBQ25DLE9BQU87UUFDVCxPQUFPLElBQUkvc0QsRUFBRTB5QyxTQUFTLEtBQUssR0FBRztZQUM1QjM4QixLQUFLLG1CQUFtQmczQyxXQUFXO1FBQ3JDO0lBQ0Y7SUFDQSxPQUFPLE1BQU0sVUFBVTtBQUN6QjtBQUVBOzs7O0NBSUMsR0FDRCxJQUFJcHpELFdBQVcsU0FBU0E7SUFDdEIsSUFBSSxJQUFJLENBQUM4N0QsYUFBYSxJQUFJLE1BQU07UUFDOUIsT0FBTyxJQUFJLENBQUNBLGFBQWE7SUFDM0I7SUFDQSxJQUFJQyxRQUFRLFNBQVNBLE1BQU1qN0QsR0FBRztRQUM1QixJQUFJQSxPQUFPLE1BQU07WUFDZixPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLElBQUlrN0QsV0FBVyxTQUFTQSxTQUFTajlDLEdBQUc7UUFDbEMsSUFBSTlkLE9BQU84ZCxNQUFNO1lBQ2YsT0FBTyxNQUFNQSxNQUFNO1FBQ3JCLE9BQU87WUFDTCxPQUFPZzlDLE1BQU1oOUM7UUFDZjtJQUNGO0lBQ0EsSUFBSWs5QyxRQUFRLFNBQVNBLE1BQU1sOUMsR0FBRztRQUM1QixPQUFPLE1BQU1BLE1BQU07SUFDckI7SUFDQSxJQUFJbTlDLGdCQUFnQixTQUFTQSxjQUFjQyxLQUFLLEVBQUVoSCxPQUFPO1FBQ3ZELElBQUl6akQsT0FBT3lxRCxNQUFNenFELElBQUksRUFDbkJqVCxRQUFRMDlELE1BQU0xOUQsS0FBSztRQUNyQixPQUFRaVQ7WUFDTixLQUFLaWtELEtBQUtDLEtBQUs7Z0JBQ2I7b0JBQ0UsSUFBSXIxQyxRQUFRdzdDLE1BQU10OUQ7b0JBQ2xCLE9BQU84aEIsTUFBTWpjLFNBQVMsQ0FBQyxHQUFHaWMsTUFBTTFqQixNQUFNLEdBQUc7Z0JBQzNDO1lBQ0YsS0FBSzg0RCxLQUFLSSxZQUFZO2dCQUNwQjtvQkFDRSxJQUFJekYsUUFBUTZMLE1BQU03TCxLQUFLLEVBQ3JCNkksV0FBV2dELE1BQU1oRCxRQUFRO29CQUMzQixPQUFPLE1BQU03SSxRQUFRMkwsTUFBTUYsTUFBTTVDLGFBQWE2QyxTQUFTdjlELFNBQVM7Z0JBQ2xFO1lBQ0YsS0FBS2szRCxLQUFLTSxTQUFTO2dCQUNqQjtvQkFDRSxJQUFJbUcsWUFBWUQsTUFBTWhELFFBQVEsRUFDNUJrRCxTQUFTRixNQUFNN0wsS0FBSztvQkFDdEIsT0FBTyxNQUFNeUwsTUFBTUssYUFBYUMsU0FBUztnQkFDM0M7WUFDRixLQUFLMUcsS0FBS0ssVUFBVTtnQkFDbEI7b0JBQ0UsSUFBSXNHLFVBQVVILE1BQU03TCxLQUFLO29CQUN6QixPQUFPLE1BQU1nTSxVQUFVO2dCQUN6QjtZQUNGLEtBQUszRyxLQUFLTyxZQUFZO2dCQUNwQjtvQkFDRSxJQUFJcUcsYUFBYUosTUFBTWhELFFBQVEsRUFDN0JxRCxVQUFVTCxNQUFNN0wsS0FBSztvQkFDdkIsT0FBTyxPQUFPa00sVUFBVVAsTUFBTUYsTUFBTVEsZUFBZVAsU0FBU3Y5RCxTQUFTO2dCQUN2RTtZQUNGLEtBQUtrM0QsS0FBS1EsS0FBSztnQkFDYjtvQkFDRSxPQUFPMTNEO2dCQUNUO1lBQ0YsS0FBS2szRCxLQUFLUyxFQUFFO2dCQUNWO29CQUNFLE9BQU8sTUFBTTMzRDtnQkFDZjtZQUNGLEtBQUtrM0QsS0FBS1UsS0FBSztnQkFDYjtvQkFDRSxPQUFPLE1BQU01M0Q7Z0JBQ2Y7WUFDRixLQUFLazNELEtBQUtrQixNQUFNO1lBQ2hCLEtBQUtsQixLQUFLZ0IsS0FBSztnQkFDYjtvQkFDRSxPQUFPOEYsY0FBY04sTUFBTTc1QyxNQUFNLEVBQUU2eUMsV0FBVzhHLE1BQU0sT0FBT1EsY0FBY04sTUFBTWpILEtBQUssRUFBRUM7Z0JBQ3hGO1lBQ0YsS0FBS1EsS0FBS21CLFFBQVE7WUFDbEIsS0FBS25CLEtBQUtpQixVQUFVO2dCQUNsQjtvQkFDRSxPQUFPNkYsY0FBY04sTUFBTXpCLFFBQVEsRUFBRXZGLFdBQVcsTUFBTXNILGNBQWNOLE1BQU1sSCxVQUFVLEVBQUVFO2dCQUN4RjtZQUNGLEtBQUtRLEtBQUtvQixjQUFjO2dCQUN0QjtvQkFDRSxJQUFJMkYsTUFBTUQsY0FBY04sTUFBTWxrQyxJQUFJLEVBQUVrOUI7b0JBQ3BDLElBQUl2OEIsTUFBTTZqQyxjQUFjTixNQUFNaEgsT0FBTyxFQUFFQTtvQkFDdkMsSUFBSXdILE1BQU1GLGNBQWNOLE1BQU1wa0MsS0FBSyxFQUFFbzlCO29CQUNyQyxPQUFPdUgsTUFBT0EsQ0FBQUEsSUFBSTcvRCxNQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUMsSUFBSys3QixNQUFNK2pDO2dCQUNuRDtZQUNGLEtBQUtoSCxLQUFLcUIsSUFBSTtnQkFDWjtvQkFDRSxPQUFPO2dCQUNUO1FBQ0o7SUFDRjtJQUNBLElBQUl5RixnQkFBZ0IsU0FBU0EsY0FBY3JFLEtBQUssRUFBRWpELE9BQU87UUFDdkQsT0FBT2lELE1BQU0xQyxNQUFNLENBQUNrSCxNQUFNLENBQUMsU0FBVTk0RCxHQUFHLEVBQUUrNEQsR0FBRyxFQUFFejlELENBQUM7WUFDOUMsT0FBTzBFLE1BQU9xeEQsQ0FBQUEsWUFBWWlELFNBQVNoNUQsTUFBTSxJQUFJLE1BQU0sRUFBQyxJQUFLODhELGNBQWNXLEtBQUsxSDtRQUM5RSxHQUFHO0lBQ0w7SUFDQSxJQUFJcnhELE1BQU07SUFDVixJQUFLLElBQUkxRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJZzVELFFBQVEsSUFBSSxDQUFDaDVELEVBQUU7UUFDbkIwRSxPQUFPMjRELGNBQWNyRSxPQUFPQSxNQUFNakQsT0FBTztRQUN6QyxJQUFJLElBQUksQ0FBQ3Q0RCxNQUFNLEdBQUcsS0FBS3VDLElBQUksSUFBSSxDQUFDdkMsTUFBTSxHQUFHLEdBQUc7WUFDMUNpSCxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUksQ0FBQ2c0RCxhQUFhLEdBQUdoNEQ7SUFDckIsT0FBT0E7QUFDVDtBQUNBLElBQUlnNUQsVUFBVTtJQUNacEIsT0FBT0E7SUFDUDE3RCxVQUFVQTtBQUNaO0FBRUEsSUFBSSs4RCxTQUFTLFNBQVNBLE9BQU9DLFFBQVEsRUFBRTdELFFBQVEsRUFBRTE2RCxLQUFLO0lBQ3BELElBQUl5NEQ7SUFDSixJQUFJK0YsYUFBYWg4RCxPQUFPKzdEO0lBQ3hCLElBQUlFLGFBQWEzN0QsU0FBU3k3RDtJQUMxQixJQUFJRyxXQUFXbDhELE9BQU94QztJQUN0QixJQUFJMitELFVBQVVDO0lBQ2QsSUFBSUMsa0JBQWtCO0lBQ3RCLElBQUlDLFVBQVU7SUFDZCxJQUFJQyxZQUFZO0lBQ2hCLElBQUlyRSxTQUFTNXdDLE9BQU8sQ0FBQyxRQUFRLEdBQUc7UUFDOUI0d0MsV0FBV0EsU0FBU3AxRCxPQUFPLENBQUMsS0FBSztRQUNqQ3c1RCxVQUFVO0lBQ1o7SUFDQSxJQUFJcEUsU0FBUzV3QyxPQUFPLENBQUMsUUFBUSxHQUFHO1FBQzlCNHdDLFdBQVdBLFNBQVNwMUQsT0FBTyxDQUFDLEtBQUs7UUFDakN1NUQsa0JBQWtCO0lBQ3BCO0lBQ0EsSUFBSUwsY0FBY0UsWUFBWUcsaUJBQWlCO1FBQzdDRixXQUFXLENBQUNILGNBQWMsQ0FBQ0MsYUFBYSxLQUFLLEtBQUtGO1FBQ2xESyxTQUFTLEtBQUs1K0Q7SUFDaEI7SUFFQSxxRkFBcUY7SUFDckYsa0NBQWtDO0lBQ2xDLElBQUk2K0QsaUJBQWlCO1FBQ25CTixXQUFXSSxXQUFXQSxTQUFTbjVELFdBQVc7UUFDMUN4RixRQUFRNCtELFNBQVNBLE9BQU9wNUQsV0FBVztJQUNyQztJQUNBLE9BQVFrMUQ7UUFDTixLQUFLO1lBQ0hqQyxVQUFVa0csU0FBUzcwQyxPQUFPLENBQUM4MEMsV0FBVztZQUN0QztRQUNGLEtBQUs7WUFDSG5HLFVBQVVrRyxTQUFTNzBDLE9BQU8sQ0FBQzgwQyxRQUFRRCxTQUFTdmdFLE1BQU0sR0FBR3dnRSxPQUFPeGdFLE1BQU0sS0FBSztZQUN2RTtRQUNGLEtBQUs7WUFDSHE2RCxVQUFVa0csU0FBUzcwQyxPQUFPLENBQUM4MEMsWUFBWTtZQUN2QztRQUNGLEtBQUs7WUFDSG5HLFVBQVU4RixhQUFhditEO1lBQ3ZCO1FBQ0YsS0FBSztZQUNIKytELFlBQVk7WUFDWnRHLFVBQVU4RixXQUFXditEO1lBQ3JCO1FBQ0YsS0FBSztZQUNIKytELFlBQVk7WUFDWnRHLFVBQVU4RixZQUFZditEO1lBQ3RCO1FBQ0YsS0FBSztZQUNIKytELFlBQVk7WUFDWnRHLFVBQVU4RixXQUFXditEO1lBQ3JCO1FBQ0YsS0FBSztZQUNIKytELFlBQVk7WUFDWnRHLFVBQVU4RixZQUFZditEO1lBQ3RCO1FBQ0Y7WUFDRXk0RCxVQUFVO1lBQ1Y7SUFDSjtJQUVBLG1GQUFtRjtJQUNuRixJQUFJcUcsV0FBWVAsQ0FBQUEsWUFBWSxRQUFRLENBQUNRLFNBQVEsR0FBSTtRQUMvQ3RHLFVBQVUsQ0FBQ0E7SUFDYjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJdUcsVUFBVSxTQUFTQSxRQUFRVCxRQUFRLEVBQUU3RCxRQUFRO0lBQy9DLE9BQVFBO1FBQ04sS0FBSztZQUNILE9BQU82RCxXQUFXLE9BQU87UUFDM0IsS0FBSztZQUNILE9BQU9BLFdBQVcsUUFBUTtRQUM1QixLQUFLO1lBQ0gsT0FBT0EsYUFBYXA5RDtJQUN4QjtBQUNGO0FBQ0EsSUFBSTg5RCxXQUFXLFNBQVNBLFNBQVNWLFFBQVE7SUFDdkMsT0FBT0EsYUFBYXA5RDtBQUN0QjtBQUNBLElBQUkrOUQsU0FBUyxTQUFTbjlDLEtBQUtyQyxHQUFHLEVBQUVteUMsS0FBSztJQUNuQyxPQUFPbnlDLElBQUlxQyxJQUFJLENBQUM4dkM7QUFDbEI7QUFDQSxJQUFJeUUsT0FBTyxTQUFTQSxLQUFLNTJDLEdBQUcsRUFBRW15QyxLQUFLO0lBQ2pDLE9BQU9ueUMsR0FBRyxDQUFDbXlDLE1BQU07QUFDbkI7QUFFQSw0REFBNEQsR0FDNUQsSUFBSWh1RCxRQUFRLEVBQUU7QUFFZDs7OztBQUlBLEdBQ0EsSUFBSXM3RCxZQUFZLFNBQVMxRyxRQUFRa0IsS0FBSyxFQUFFajZDLEdBQUc7SUFDekMsT0FBT2k2QyxNQUFNMUMsTUFBTSxDQUFDbUksS0FBSyxDQUFDLFNBQVVoQixHQUFHO1FBQ3JDLE9BQU92NkQsS0FBSyxDQUFDdTZELElBQUluckQsSUFBSSxDQUFDLENBQUNtckQsS0FBSzErQztJQUM5QjtBQUNGO0FBQ0E3YixLQUFLLENBQUNxekQsS0FBS0MsS0FBSyxDQUFDLEdBQUcsU0FBVXVHLEtBQUssRUFBRWgrQyxHQUFHO0lBQ3RDLElBQUlvQyxRQUFRNDdDLE1BQU0xOUQsS0FBSztJQUN2QixPQUFPOGhCLFVBQVUsT0FBT0EsVUFBVXBDLElBQUlvQyxLQUFLO0FBQzdDO0FBQ0FqZSxLQUFLLENBQUNxekQsS0FBS1EsS0FBSyxDQUFDLEdBQUcsU0FBVWdHLEtBQUssRUFBRWgrQyxHQUFHO0lBQ3RDLElBQUkyL0MsZ0JBQWdCM0IsTUFBTTE5RCxLQUFLO0lBQy9CLE9BQU9rNUQscUJBQXFCbUcsZUFBZTMvQztBQUM3QztBQUNBN2IsS0FBSyxDQUFDcXpELEtBQUtTLEVBQUUsQ0FBQyxHQUFHLFNBQVUrRixLQUFLLEVBQUVoK0MsR0FBRztJQUNuQyxJQUFJMEcsS0FBS3MzQyxNQUFNMTlELEtBQUs7SUFDcEIsT0FBTzBmLElBQUkwRyxFQUFFLE9BQU9BO0FBQ3RCO0FBQ0F2aUIsS0FBSyxDQUFDcXpELEtBQUtVLEtBQUssQ0FBQyxHQUFHLFNBQVU4RixLQUFLLEVBQUVoK0MsR0FBRztJQUN0QyxJQUFJb0YsTUFBTTQ0QyxNQUFNMTlELEtBQUs7SUFDckIsT0FBTzBmLElBQUkrMUMsUUFBUSxDQUFDM3dDO0FBQ3RCO0FBQ0FqaEIsS0FBSyxDQUFDcXpELEtBQUtPLFlBQVksQ0FBQyxHQUFHLFNBQVVpRyxLQUFLLEVBQUVoK0MsR0FBRztJQUM3QyxJQUFJbXlDLFFBQVE2TCxNQUFNN0wsS0FBSyxFQUNyQjZJLFdBQVdnRCxNQUFNaEQsUUFBUSxFQUN6QjE2RCxRQUFRMDlELE1BQU0xOUQsS0FBSztJQUNyQixPQUFPcytELE9BQU9oSSxLQUFLNTJDLEtBQUtteUMsUUFBUTZJLFVBQVUxNkQ7QUFDNUM7QUFDQTZELEtBQUssQ0FBQ3F6RCxLQUFLSSxZQUFZLENBQUMsR0FBRyxTQUFVb0csS0FBSyxFQUFFaCtDLEdBQUc7SUFDN0MsSUFBSW15QyxRQUFRNkwsTUFBTTdMLEtBQUssRUFDckI2SSxXQUFXZ0QsTUFBTWhELFFBQVEsRUFDekIxNkQsUUFBUTA5RCxNQUFNMTlELEtBQUs7SUFDckIsT0FBT3MrRCxPQUFPWSxPQUFPeC9DLEtBQUtteUMsUUFBUTZJLFVBQVUxNkQ7QUFDOUM7QUFDQTZELEtBQUssQ0FBQ3F6RCxLQUFLTSxTQUFTLENBQUMsR0FBRyxTQUFVa0csS0FBSyxFQUFFaCtDLEdBQUc7SUFDMUMsSUFBSW15QyxRQUFRNkwsTUFBTTdMLEtBQUssRUFDckI2SSxXQUFXZ0QsTUFBTWhELFFBQVE7SUFDM0IsT0FBT3NFLFFBQVFFLE9BQU94L0MsS0FBS215QyxRQUFRNkk7QUFDckM7QUFDQTcyRCxLQUFLLENBQUNxekQsS0FBS0ssVUFBVSxDQUFDLEdBQUcsU0FBVW1HLEtBQUssRUFBRWgrQyxHQUFHO0lBQzNDLElBQUlteUMsUUFBUTZMLE1BQU03TCxLQUFLO0lBQ3JCNkwsTUFBTWhELFFBQVE7SUFDaEIsT0FBT3VFLFNBQVNDLE9BQU94L0MsS0FBS215QztBQUM5QjtBQUNBaHVELEtBQUssQ0FBQ3F6RCxLQUFLVyxlQUFlLENBQUMsR0FBRyxTQUFVNkYsS0FBSyxFQUFFaCtDLEdBQUc7SUFDaEQsSUFBSTQvQyxLQUFLNUIsTUFBTXozQyxLQUFLLENBQUMsRUFBRTtJQUN2QixJQUFJczVDLEtBQUs3QixNQUFNejNDLEtBQUssQ0FBQyxFQUFFO0lBQ3ZCLElBQUlXLE1BQU1sSCxJQUFJc0MsTUFBTTtJQUNwQixJQUFJbGIsTUFBTTRZLElBQUl1QyxNQUFNO0lBQ3BCLE9BQU9rOUMsVUFBVUcsSUFBSTE0QyxRQUFRdTRDLFVBQVVJLElBQUl6NEQsUUFBUXE0RCxVQUFVSSxJQUFJMzRDLFFBQVF1NEMsVUFBVUcsSUFBSXg0RDtBQUN6RjtBQUNBakQsS0FBSyxDQUFDcXpELEtBQUtlLGFBQWEsQ0FBQyxHQUFHLFNBQVV5RixLQUFLLEVBQUVoK0MsR0FBRztJQUM5QyxPQUFPeS9DLFVBQVV6QixNQUFNcDJDLElBQUksRUFBRTVILFFBQVFBLElBQUlxTixZQUFZLEdBQUdncUIsSUFBSSxDQUFDLFNBQVV6NEMsQ0FBQztRQUN0RSxPQUFPQSxFQUFFd2xCLE1BQU0sTUFBTXE3QyxVQUFVekIsTUFBTWxDLFFBQVEsRUFBRWw5RDtJQUNqRDtBQUNGO0FBQ0F1RixLQUFLLENBQUNxekQsS0FBS1ksYUFBYSxDQUFDLEdBQUcsU0FBVTRGLEtBQUssRUFBRWgrQyxHQUFHO0lBQzlDLE9BQU95L0MsVUFBVXpCLE1BQU0xN0MsTUFBTSxFQUFFdEMsSUFBSXNDLE1BQU0sT0FBT205QyxVQUFVekIsTUFBTXo3QyxNQUFNLEVBQUV2QyxJQUFJdUMsTUFBTTtBQUNwRjtBQUNBcGUsS0FBSyxDQUFDcXpELEtBQUthLFdBQVcsQ0FBQyxHQUFHLFNBQVUyRixLQUFLLEVBQUVoK0MsR0FBRztJQUM1QyxPQUFPeS9DLFVBQVV6QixNQUFNMTdDLE1BQU0sRUFBRXRDLFFBQVFBLElBQUl5dEIsUUFBUSxHQUFHNEosSUFBSSxDQUFDLFNBQVV6NEMsQ0FBQztRQUNwRSxPQUFPQSxFQUFFd2xCLE1BQU0sTUFBTXE3QyxVQUFVekIsTUFBTXo3QyxNQUFNLEVBQUUzakI7SUFDL0M7QUFDRjtBQUNBdUYsS0FBSyxDQUFDcXpELEtBQUtjLFdBQVcsQ0FBQyxHQUFHLFNBQVUwRixLQUFLLEVBQUVoK0MsR0FBRztJQUM1QyxPQUFPeS9DLFVBQVV6QixNQUFNejdDLE1BQU0sRUFBRXZDLFFBQVFBLElBQUk4L0MsUUFBUSxHQUFHem9CLElBQUksQ0FBQyxTQUFVejRDLENBQUM7UUFDcEUsT0FBT0EsRUFBRXdsQixNQUFNLE1BQU1xN0MsVUFBVXpCLE1BQU0xN0MsTUFBTSxFQUFFMWpCO0lBQy9DO0FBQ0Y7QUFDQXVGLEtBQUssQ0FBQ3F6RCxLQUFLZ0IsS0FBSyxDQUFDLEdBQUcsU0FBVXdGLEtBQUssRUFBRWgrQyxHQUFHO0lBQ3RDLE9BQU95L0MsVUFBVXpCLE1BQU1qSCxLQUFLLEVBQUUvMkMsUUFBUXkvQyxVQUFVekIsTUFBTTc1QyxNQUFNLEVBQUVuRSxJQUFJbUUsTUFBTTtBQUMxRTtBQUNBaGdCLEtBQUssQ0FBQ3F6RCxLQUFLa0IsTUFBTSxDQUFDLEdBQUcsU0FBVXNGLEtBQUssRUFBRWgrQyxHQUFHO0lBQ3ZDLE9BQU95L0MsVUFBVXpCLE1BQU03NUMsTUFBTSxFQUFFbkUsUUFBUUEsSUFBSWtFLFFBQVEsR0FBR216QixJQUFJLENBQUMsU0FBVXJqQixDQUFDO1FBQ3BFLE9BQU95ckMsVUFBVXpCLE1BQU1qSCxLQUFLLEVBQUUvaUM7SUFDaEM7QUFDRjtBQUNBN3ZCLEtBQUssQ0FBQ3F6RCxLQUFLaUIsVUFBVSxDQUFDLEdBQUcsU0FBVXVGLEtBQUssRUFBRWgrQyxHQUFHO0lBQzNDLE9BQU95L0MsVUFBVXpCLE1BQU1sSCxVQUFVLEVBQUU5MkMsUUFBUUEsSUFBSSsvQyxTQUFTLEdBQUcxb0IsSUFBSSxDQUFDLFNBQVU1NEMsQ0FBQztRQUN6RSxPQUFPZ2hFLFVBQVV6QixNQUFNekIsUUFBUSxFQUFFOTlEO0lBQ25DO0FBQ0Y7QUFDQTBGLEtBQUssQ0FBQ3F6RCxLQUFLbUIsUUFBUSxDQUFDLEdBQUcsU0FBVXFGLEtBQUssRUFBRWgrQyxHQUFHO0lBQ3pDLE9BQU95L0MsVUFBVXpCLE1BQU16QixRQUFRLEVBQUV2OEMsUUFBUUEsSUFBSWdnRCxXQUFXLEdBQUczb0IsSUFBSSxDQUFDLFNBQVU3cUIsQ0FBQztRQUN6RSxPQUFPaXpDLFVBQVV6QixNQUFNbEgsVUFBVSxFQUFFdHFDO0lBQ3JDO0FBQ0Y7QUFDQXJvQixLQUFLLENBQUNxekQsS0FBS29CLGNBQWMsQ0FBQyxHQUFHLFNBQVVvRixLQUFLLEVBQUVoK0MsR0FBRztJQUMvQyxPQUFPeS9DLFVBQVV6QixNQUFNaEgsT0FBTyxFQUFFaDNDLFFBQVF5L0MsVUFBVXpCLE1BQU1sa0MsSUFBSSxFQUFFOVosUUFBUXkvQyxVQUFVekIsTUFBTXBrQyxLQUFLLEVBQUU1WjtBQUMvRjtBQUNBN2IsS0FBSyxDQUFDcXpELEtBQUtxQixJQUFJLENBQUMsR0FBRztJQUNqQixPQUFPO0FBQ1Q7QUFDQTEwRCxLQUFLLENBQUNxekQsS0FBS0UsVUFBVSxDQUFDLEdBQUcsU0FBVXNHLEtBQUssRUFBRWgrQyxHQUFHO0lBQzNDLElBQUlwYyxhQUFhbzZELE1BQU0xOUQsS0FBSztJQUM1QixPQUFPc0QsV0FBV21kLEdBQUcsQ0FBQ2Y7QUFDeEI7QUFDQTdiLEtBQUssQ0FBQ3F6RCxLQUFLRyxNQUFNLENBQUMsR0FBRyxTQUFVcUcsS0FBSyxFQUFFaCtDLEdBQUc7SUFDdkMsSUFBSTJCLFNBQVNxOEMsTUFBTTE5RCxLQUFLO0lBQ3hCLE9BQU9xaEIsT0FBTzNCO0FBQ2hCO0FBRUEsZ0NBQWdDO0FBQ2hDLElBQUkyQixTQUFTLFNBQVNBLE9BQU8vZCxVQUFVO0lBQ3JDLElBQUl5QixRQUFPLElBQUk7SUFFZiw4Q0FBOEM7SUFDOUMsSUFBSUEsTUFBSzNHLE1BQU0sS0FBSyxLQUFLMkcsS0FBSSxDQUFDLEVBQUUsQ0FBQ2t5RCxNQUFNLENBQUM3NEQsTUFBTSxLQUFLLEtBQUsyRyxLQUFJLENBQUMsRUFBRSxDQUFDa3lELE1BQU0sQ0FBQyxFQUFFLENBQUNoa0QsSUFBSSxLQUFLaWtELEtBQUtTLEVBQUUsRUFBRTtRQUMxRixPQUFPcjBELFdBQVdtcUMsY0FBYyxDQUFDMW9DLEtBQUksQ0FBQyxFQUFFLENBQUNreUQsTUFBTSxDQUFDLEVBQUUsQ0FBQ2ozRCxLQUFLLEVBQUVzRCxVQUFVO0lBQ3RFO0lBQ0EsSUFBSXE4RCxtQkFBbUIsU0FBU0EsaUJBQWlCdDhELE9BQU87UUFDdEQsSUFBSyxJQUFJMkQsSUFBSSxHQUFHQSxJQUFJakMsTUFBSzNHLE1BQU0sRUFBRTRJLElBQUs7WUFDcEMsSUFBSTJ5RCxRQUFRNTBELEtBQUksQ0FBQ2lDLEVBQUU7WUFDbkIsSUFBSW00RCxVQUFVeEYsT0FBT3QyRCxVQUFVO2dCQUM3QixPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBLElBQUkwQixNQUFLNjZELElBQUksTUFBTSxNQUFNO1FBQ3ZCRCxtQkFBbUIsU0FBU0E7WUFDMUIsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPcjhELFdBQVcrZCxNQUFNLENBQUNzK0M7QUFDM0IsR0FBRyxTQUFTO0FBRVosd0NBQXdDO0FBQ3hDLElBQUlsSCxVQUFVLFNBQVNBLFFBQVEvNEMsR0FBRztJQUNoQyxJQUFJM2EsUUFBTyxJQUFJO0lBQ2YsSUFBSyxJQUFJaUMsSUFBSSxHQUFHQSxJQUFJakMsTUFBSzNHLE1BQU0sRUFBRTRJLElBQUs7UUFDcEMsSUFBSTJ5RCxRQUFRNTBELEtBQUksQ0FBQ2lDLEVBQUU7UUFDbkIsSUFBSW00RCxVQUFVeEYsT0FBT2o2QyxNQUFNO1lBQ3pCLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNULEdBQUcsVUFBVTtBQUViLElBQUltZ0QsV0FBVztJQUNicEgsU0FBU0E7SUFDVHAzQyxRQUFRQTtBQUNWO0FBRUEsSUFBSXkrQyxXQUFXLFNBQVNBLFNBQVNuTCxRQUFRO0lBQ3ZDLElBQUksQ0FBQ3VJLFNBQVMsR0FBR3ZJO0lBQ2pCLElBQUksQ0FBQ29HLGNBQWMsR0FBRztJQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztJQUNyQixJQUFJLENBQUMxZ0IsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ2w4QyxNQUFNLEdBQUc7SUFDZCxJQUFJdTJELFlBQVksUUFBUW55RCxPQUFPbXlELGFBQWFBLFNBQVM5d0QsS0FBSyxDQUFDO1NBQWlCLElBQUlsQixvQkFBb0JneUQsV0FBVztRQUM3RyxJQUFJLENBQUNvTCxRQUFRLENBQUM7WUFDWjlJLFFBQVE7Z0JBQUM7b0JBQ1Boa0QsTUFBTWlrRCxLQUFLRSxVQUFVO29CQUNyQnAzRCxPQUFPMjBELFNBQVNyeEQsVUFBVTtnQkFDNUI7YUFBRTtRQUNKO0lBQ0YsT0FBTyxJQUFJZixLQUFLb3lELFdBQVc7UUFDekIsSUFBSSxDQUFDb0wsUUFBUSxDQUFDO1lBQ1o5SSxRQUFRO2dCQUFDO29CQUNQaGtELE1BQU1pa0QsS0FBS0csTUFBTTtvQkFDakJyM0QsT0FBTzIwRDtnQkFDVDthQUFFO1FBQ0o7SUFDRixPQUFPLElBQUlueUQsT0FBT215RCxXQUFXO1FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNzSSxLQUFLLENBQUN0SSxXQUFXO1lBQ3pCLElBQUksQ0FBQ3FMLE9BQU8sR0FBRztRQUNqQjtJQUNGLE9BQU87UUFDTDFoRCxNQUFNO0lBQ1I7QUFDRjtBQUNBLElBQUkyaEQsUUFBUUgsU0FBU3RnRSxTQUFTO0FBQzlCO0lBQUM2K0Q7SUFBU3dCO0NBQVMsQ0FBQ3YrQyxPQUFPLENBQUMsU0FBVTNaLENBQUM7SUFDckMsT0FBT2hCLE9BQU9zNUQsT0FBT3Q0RDtBQUN2QjtBQUNBczRELE1BQU1MLElBQUksR0FBRztJQUNYLE9BQU8sSUFBSSxDQUFDMUMsU0FBUztBQUN2QjtBQUNBK0MsTUFBTWgvQyxJQUFJLEdBQUc7SUFDWCxPQUFPLElBQUksQ0FBQzdpQixNQUFNO0FBQ3BCO0FBQ0E2aEUsTUFBTXhYLEVBQUUsR0FBRyxTQUFVOW5ELENBQUM7SUFDcEIsT0FBTyxJQUFJLENBQUNBLEVBQUU7QUFDaEI7QUFDQXMvRCxNQUFNQyxRQUFRLEdBQUcsU0FBVUMsUUFBUTtJQUNqQyxPQUFPLENBQUMsSUFBSSxDQUFDSCxPQUFPLElBQUksQ0FBQ0csU0FBU0gsT0FBTyxJQUFJLElBQUksQ0FBQ0osSUFBSSxPQUFPTyxTQUFTUCxJQUFJO0FBQzVFO0FBQ0FLLE1BQU1GLFFBQVEsR0FBRyxTQUFVbjRELENBQUM7SUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQ3hKLE1BQU0sR0FBRyxHQUFHd0o7QUFDeEI7QUFDQXE0RCxNQUFNdEwsUUFBUSxHQUFHc0wsTUFBTTErRCxRQUFRO0FBRS9CLElBQUk2K0QsV0FBVztJQUNiQyxRQUFRLFNBQVNBLE9BQU8xTCxRQUFRO1FBQzlCLElBQUkyTCxTQUFTLElBQUlSLFNBQVNuTDtRQUMxQixPQUFPLElBQUksQ0FBQ3lLLEtBQUssQ0FBQyxTQUFVMS9DLEdBQUc7WUFDN0IsT0FBTzRnRCxPQUFPN0gsT0FBTyxDQUFDLzRDO1FBQ3hCO0lBQ0Y7SUFDQTZnRCxJQUFJLFNBQVNBLEdBQUc1TCxRQUFRO1FBQ3RCLElBQUkyTCxTQUFTLElBQUlSLFNBQVNuTDtRQUMxQixPQUFPLElBQUksQ0FBQzVkLElBQUksQ0FBQyxTQUFVcjNCLEdBQUc7WUFDNUIsT0FBTzRnRCxPQUFPN0gsT0FBTyxDQUFDLzRDO1FBQ3hCO0lBQ0Y7SUFDQXEzQixNQUFNLFNBQVNBLEtBQUt0MEMsRUFBRSxFQUFFdVcsT0FBTztRQUM3QixJQUFLLElBQUlyWSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJcUUsTUFBTSxDQUFDZ1UsVUFBVXZXLEdBQUcsSUFBSSxDQUFDOUIsRUFBRSxFQUFFQSxHQUFHLElBQUksSUFBSThCLEdBQUd5QyxLQUFLLENBQUM4VCxTQUFTO2dCQUFDLElBQUksQ0FBQ3JZLEVBQUU7Z0JBQUVBO2dCQUFHLElBQUk7YUFBQztZQUNoRixJQUFJcUUsS0FBSztnQkFDUCxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBbzZELE9BQU8sU0FBU0EsTUFBTTM4RCxFQUFFLEVBQUV1VyxPQUFPO1FBQy9CLElBQUssSUFBSXJZLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUlxRSxNQUFNLENBQUNnVSxVQUFVdlcsR0FBRyxJQUFJLENBQUM5QixFQUFFLEVBQUVBLEdBQUcsSUFBSSxJQUFJOEIsR0FBR3lDLEtBQUssQ0FBQzhULFNBQVM7Z0JBQUMsSUFBSSxDQUFDclksRUFBRTtnQkFBRUE7Z0JBQUcsSUFBSTthQUFDO1lBQ2hGLElBQUksQ0FBQ3FFLEtBQUs7Z0JBQ1IsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQThoQixNQUFNLFNBQVNBLEtBQUt4akIsVUFBVTtRQUM1Qiw2QkFBNkI7UUFDN0IsSUFBSSxJQUFJLEtBQUtBLFlBQVk7WUFDdkIsT0FBTztRQUNUO1FBQ0FBLGFBQWEsSUFBSSxDQUFDcWUsRUFBRSxHQUFHcmUsVUFBVSxDQUFDQTtRQUNsQyxJQUFJazlELGFBQWEsSUFBSSxDQUFDcGlFLE1BQU07UUFDNUIsSUFBSXFpRSxtQkFBbUJuOUQsV0FBV2xGLE1BQU07UUFFeEMscUJBQXFCO1FBQ3JCLElBQUlvaUUsZUFBZUMsa0JBQWtCO1lBQ25DLE9BQU87UUFDVDtRQUVBLDBCQUEwQjtRQUMxQixJQUFJRCxlQUFlLEdBQUc7WUFDcEIsT0FBTyxJQUFJLENBQUMsRUFBRSxLQUFLbDlELFVBQVUsQ0FBQyxFQUFFO1FBQ2xDO1FBQ0EsT0FBTyxJQUFJLENBQUM4N0QsS0FBSyxDQUFDLFNBQVUxL0MsR0FBRztZQUM3QixPQUFPcGMsV0FBV3FzQixnQkFBZ0IsQ0FBQ2pRLElBQUkwRyxFQUFFO1FBQzNDO0lBQ0Y7SUFDQXM2QyxTQUFTLFNBQVNBLFFBQVFwOUQsVUFBVTtRQUNsQ0EsYUFBYSxJQUFJLENBQUNxZSxFQUFFLEdBQUdyZSxVQUFVLENBQUNBO1FBQ2xDLE9BQU8sSUFBSSxDQUFDeXpDLElBQUksQ0FBQyxTQUFVcjNCLEdBQUc7WUFDNUIsT0FBT3BjLFdBQVdxc0IsZ0JBQWdCLENBQUNqUSxJQUFJMEcsRUFBRTtRQUMzQztJQUNGO0lBQ0F1NkMsaUJBQWlCLFNBQVNBLGdCQUFnQnI5RCxVQUFVO1FBQ2xEQSxhQUFhLElBQUksQ0FBQ3FlLEVBQUUsR0FBR3JlLFVBQVUsQ0FBQ0E7UUFDbEMsSUFBSXM5RCxRQUFRLElBQUksQ0FBQzd6QyxZQUFZO1FBQzdCLE9BQU96cEIsV0FBVzg3RCxLQUFLLENBQUMsU0FBVTEvQyxHQUFHO1lBQ25DLE9BQU9raEQsTUFBTWp4QyxnQkFBZ0IsQ0FBQ2pRLElBQUkwRyxFQUFFO1FBQ3RDO0lBQ0Y7SUFDQXNFLFVBQVUsU0FBU0EsU0FBU3BuQixVQUFVO1FBQ3BDQSxhQUFhLElBQUksQ0FBQ3FlLEVBQUUsR0FBR3JlLFVBQVUsQ0FBQ0E7UUFDbEMsSUFBSXlCLFFBQU8sSUFBSTtRQUNmLE9BQU96QixXQUFXODdELEtBQUssQ0FBQyxTQUFVMS9DLEdBQUc7WUFDbkMsT0FBTzNhLE1BQUs0cUIsZ0JBQWdCLENBQUNqUSxJQUFJMEcsRUFBRTtRQUNyQztJQUNGO0FBQ0Y7QUFDQWc2QyxTQUFTUyxnQkFBZ0IsR0FBR1QsU0FBU08sZUFBZTtBQUNwRFAsU0FBUzMvQyxHQUFHLEdBQUcyL0MsU0FBUzExQyxRQUFRO0FBQ2hDMDFDLFNBQVNVLEtBQUssR0FBR1YsU0FBU1csTUFBTSxHQUFHWCxTQUFTdDVDLElBQUk7QUFFaEQsSUFBSTNoQixRQUFRLFNBQVNBLE1BQU0xQyxFQUFFLEVBQUVoQixJQUFJO0lBQ2pDLE9BQU8sU0FBU3NpQixlQUFlaTlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7UUFDbkQsSUFBSUMsaUJBQWlCSjtRQUNyQixJQUFJdjFDLE9BQU8sSUFBSTtRQUNmLElBQUluc0I7UUFDSixJQUFJOGhFLGtCQUFrQixNQUFNO1lBQzFCOWhFLE1BQU07UUFDUixPQUFPLElBQUlxRCxvQkFBb0J5K0QsbUJBQW1CQSxlQUFlaGpFLE1BQU0sS0FBSyxHQUFHO1lBQzdFa0IsTUFBTThoRSxlQUFlaDdDLEVBQUU7UUFDekI7UUFDQSxJQUFJcUYsS0FBS3J0QixNQUFNLEtBQUssS0FBS2tCLEtBQUs7WUFDNUIsSUFBSTRpQixLQUFLdUosSUFBSSxDQUFDLEVBQUUsQ0FBQ2xvQixRQUFRO1lBQ3pCLElBQUk4OUQsTUFBTW4vQyxHQUFHNkIsY0FBYyxHQUFHN0IsR0FBRzZCLGNBQWMsSUFBSSxDQUFDO1lBQ3BELElBQUl1OUMsS0FBS0QsR0FBRyxDQUFDNS9ELEtBQUssR0FBRzQvRCxHQUFHLENBQUM1L0QsS0FBSyxJQUFJLEVBQUU7WUFDcEMsSUFBSXFaLE9BQU9lLFdBQVd2YztZQUN0QixJQUFJaWlFLFdBQVdELEVBQUUsQ0FBQ3htRCxLQUFLO1lBQ3ZCLElBQUl5bUQsVUFBVTtnQkFDWixPQUFPQTtZQUNULE9BQU87Z0JBQ0wsT0FBT0QsRUFBRSxDQUFDeG1ELEtBQUssR0FBR3JZLEdBQUd0QyxJQUFJLENBQUNzckIsTUFBTXUxQyxNQUFNQyxNQUFNQyxNQUFNQztZQUNwRDtRQUNGLE9BQU87WUFDTCxPQUFPMStELEdBQUd0QyxJQUFJLENBQUNzckIsTUFBTXUxQyxNQUFNQyxNQUFNQyxNQUFNQztRQUN6QztJQUNGO0FBQ0Y7QUFFQSxJQUFJSyxXQUFXO0lBQ2IzOUMsUUFBUSxTQUFTQSxPQUFPOHdDLFFBQVE7UUFDOUIsSUFBSThNLFVBQVUsRUFBRTtRQUVoQixtQ0FBbUM7UUFDbkMsSUFBSSxJQUFJLENBQUNyakUsTUFBTSxLQUFLLEdBQUc7WUFDckIsSUFBSXlsQixTQUFTLElBQUksQ0FBQyxFQUFFLENBQUN0Z0IsUUFBUSxDQUFDc2dCLE1BQU07WUFDcEMsSUFBSUEsUUFBUTtnQkFDVixPQUFPQTtZQUNUO1FBQ0Y7UUFDQSxJQUFLLElBQUlsakIsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtZQUNqQixJQUFJaTdELFVBQVVsOEMsSUFBSW5jLFFBQVEsQ0FBQ3NnQixNQUFNO1lBQ2pDLElBQUkrM0MsU0FBUztnQkFDWDZGLFFBQVE3Z0UsSUFBSSxDQUFDZzdEO1lBQ2Y7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDdHVDLEtBQUssQ0FBQ20wQyxTQUFTLE1BQU1wZ0QsTUFBTSxDQUFDc3pDO0lBQzFDO0lBQ0E4TSxTQUFTLFNBQVNBLFFBQVE5TSxRQUFRO1FBQ2hDLElBQUk4TSxVQUFVLEVBQUU7UUFDaEIsSUFBSWgyQyxPQUFPLElBQUksQ0FBQzVILE1BQU07UUFDdEIsTUFBTzRILEtBQUtpMkMsUUFBUSxHQUFJO1lBQ3RCLElBQUssSUFBSS9nRSxJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO2dCQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO2dCQUNqQjhnRSxRQUFRN2dFLElBQUksQ0FBQzhlO1lBQ2Y7WUFDQStMLE9BQU9BLEtBQUs1SCxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJLENBQUN5SixLQUFLLENBQUNtMEMsU0FBUyxNQUFNcGdELE1BQU0sQ0FBQ3N6QztJQUMxQztJQUNBZ04saUJBQWlCLFNBQVNBLGdCQUFnQmhOLFFBQVE7UUFDaEQsSUFBSThLO1FBQ0osSUFBSyxJQUFJOStELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIsSUFBSThnRSxVQUFVL2hELElBQUkraEQsT0FBTztZQUN6QmhDLFlBQVlBLGFBQWFnQztZQUN6QmhDLFlBQVlBLFVBQVVqekMsU0FBUyxDQUFDaTFDLFVBQVUsMkRBQTJEO1FBQ3ZHO1FBQ0EsT0FBT2hDLFVBQVVwK0MsTUFBTSxDQUFDc3pDO0lBQzFCO0lBQ0FpTixTQUFTLFNBQVNBLFFBQVFqTixRQUFRO1FBQ2hDLE9BQU8sSUFBSSxDQUFDa04sU0FBUyxDQUFDLFNBQVVuaUQsR0FBRztZQUNqQyxPQUFPQSxJQUFJbzVDLFFBQVE7UUFDckIsR0FBR3ozQyxNQUFNLENBQUNzekM7SUFDWjtJQUNBbU4sWUFBWSxTQUFTQSxXQUFXbk4sUUFBUTtRQUN0QyxPQUFPLElBQUksQ0FBQ2tOLFNBQVMsQ0FBQyxTQUFVbmlELEdBQUc7WUFDakMsT0FBT0EsSUFBSW01QyxPQUFPO1FBQ3BCLEdBQUd4M0MsTUFBTSxDQUFDc3pDO0lBQ1o7SUFDQS93QyxVQUFVemUsTUFBTSxTQUFVd3ZELFFBQVE7UUFDaEMsSUFBSS93QyxXQUFXLEVBQUU7UUFDakIsSUFBSyxJQUFJampCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIsSUFBSW9oRSxjQUFjcmlELElBQUluYyxRQUFRLENBQUNxZ0IsUUFBUTtZQUN2QyxJQUFLLElBQUk1YyxJQUFJLEdBQUdBLElBQUkrNkQsWUFBWTNqRSxNQUFNLEVBQUU0SSxJQUFLO2dCQUMzQzRjLFNBQVNoakIsSUFBSSxDQUFDbWhFLFdBQVcsQ0FBQy82RCxFQUFFO1lBQzlCO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQ3NtQixLQUFLLENBQUMxSixVQUFVLE1BQU12QyxNQUFNLENBQUNzekM7SUFDM0MsR0FBRztJQUNIcU4sVUFBVSxTQUFTQSxTQUFTck4sUUFBUTtRQUNsQyxPQUFPLElBQUksQ0FBQzl3QyxNQUFNLEdBQUdELFFBQVEsR0FBR3ErQyxHQUFHLENBQUMsSUFBSSxFQUFFNWdELE1BQU0sQ0FBQ3N6QztJQUNuRDtJQUNBZ0UsVUFBVSxTQUFTQTtRQUNqQixJQUFJajVDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSUEsS0FBSztZQUNQLE9BQU9BLElBQUlvRSxNQUFNLE1BQU1wRSxJQUFJbmMsUUFBUSxDQUFDcWdCLFFBQVEsQ0FBQ3hsQixNQUFNLEtBQUs7UUFDMUQ7SUFDRjtJQUNBdzZELGFBQWEsU0FBU0E7UUFDcEIsSUFBSWw1QyxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ2pCLElBQUlBLEtBQUs7WUFDUCxPQUFPQSxJQUFJb0UsTUFBTSxNQUFNcEUsSUFBSW5jLFFBQVEsQ0FBQ3FnQixRQUFRLENBQUN4bEIsTUFBTSxLQUFLO1FBQzFEO0lBQ0Y7SUFDQXk2RCxTQUFTLFNBQVNBO1FBQ2hCLElBQUluNUMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJQSxLQUFLO1lBQ1AsT0FBT0EsSUFBSW9FLE1BQU0sTUFBTXBFLElBQUluYyxRQUFRLENBQUNzZ0IsTUFBTSxJQUFJO1FBQ2hEO0lBQ0Y7SUFDQWkxQyxVQUFVLFNBQVNBO1FBQ2pCLElBQUlwNUMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJQSxLQUFLO1lBQ1AsT0FBT0EsSUFBSW9FLE1BQU0sTUFBTXBFLElBQUluYyxRQUFRLENBQUNzZ0IsTUFBTSxJQUFJO1FBQ2hEO0lBQ0Y7SUFDQTY3QyxhQUFhLFNBQVNBLFlBQVkvSyxRQUFRO1FBQ3hDLElBQUl1TixXQUFXLEVBQUU7UUFDakIsU0FBUy9nRCxJQUFJc0ssSUFBSTtZQUNmLElBQUssSUFBSTlxQixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO2dCQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO2dCQUNqQnVoRSxTQUFTdGhFLElBQUksQ0FBQzhlO2dCQUNkLElBQUlBLElBQUlrRSxRQUFRLEdBQUc4OUMsUUFBUSxJQUFJO29CQUM3QnZnRCxJQUFJekIsSUFBSWtFLFFBQVE7Z0JBQ2xCO1lBQ0Y7UUFDRjtRQUNBekMsSUFBSSxJQUFJLENBQUN5QyxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDMEosS0FBSyxDQUFDNDBDLFVBQVUsTUFBTTdnRCxNQUFNLENBQUNzekM7SUFDM0M7QUFDRjtBQUNBLFNBQVN3TixnQkFBZ0IxMkMsSUFBSSxFQUFFaHBCLEVBQUUsRUFBRTIvRCxXQUFXLEVBQUVDLGFBQWE7SUFDM0QsSUFBSXo2RCxJQUFJLEVBQUU7SUFDVixJQUFJMDZELE1BQU0sSUFBSTlnRDtJQUNkLElBQUlHLEtBQUs4SixLQUFLOUosRUFBRTtJQUNoQixJQUFJNGdELGVBQWU1Z0QsR0FBRzZnRCxnQkFBZ0I7SUFDdEMsSUFBSyxJQUFJN2hFLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtRQUNqQixJQUFJeWhFLGFBQWE7WUFDZng2RCxFQUFFaEgsSUFBSSxDQUFDOGU7UUFDVCxPQUFPLElBQUk2aUQsY0FBYztZQUN2QkYsY0FBY3o2RCxHQUFHMDZELEtBQUs1aUQ7UUFDeEI7SUFDRjtJQUNBLE1BQU85WCxFQUFFeEosTUFBTSxHQUFHLEVBQUc7UUFDbkIsSUFBSTQwRCxPQUFPcHJELEVBQUUyZSxLQUFLO1FBQ2xCOWpCLEdBQUd1d0Q7UUFDSHNQLElBQUluaEQsR0FBRyxDQUFDNnhDLEtBQUs1c0MsRUFBRTtRQUNmLElBQUltOEMsY0FBYztZQUNoQkYsY0FBY3o2RCxHQUFHMDZELEtBQUt0UDtRQUN4QjtJQUNGO0lBQ0EsT0FBT3ZuQztBQUNUO0FBQ0EsU0FBU2czQyxZQUFZNzZELENBQUMsRUFBRTA2RCxHQUFHLEVBQUU1aUQsR0FBRztJQUM5QixJQUFJQSxJQUFJaTVDLFFBQVEsSUFBSTtRQUNsQixJQUFJLzBDLFdBQVdsRSxJQUFJbmMsUUFBUSxDQUFDcWdCLFFBQVE7UUFDcEMsSUFBSyxJQUFJampCLElBQUksR0FBR0EsSUFBSWlqQixTQUFTeGxCLE1BQU0sRUFBRXVDLElBQUs7WUFDeEMsSUFBSTgxRCxRQUFRN3lDLFFBQVEsQ0FBQ2pqQixFQUFFO1lBQ3ZCLElBQUksQ0FBQzJoRSxJQUFJN2hELEdBQUcsQ0FBQ2cyQyxNQUFNcndDLEVBQUUsS0FBSztnQkFDeEJ4ZSxFQUFFaEgsSUFBSSxDQUFDNjFEO1lBQ1Q7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxxRUFBcUU7QUFDckUsbUJBQW1CO0FBQ25CK0ssU0FBU2tCLFdBQVcsR0FBRyxTQUFVamdFLEVBQUU7SUFDakMsSUFBSTIvRCxjQUFjMTlELFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUN0RixPQUFPeTlELGdCQUFnQixJQUFJLEVBQUUxL0QsSUFBSTIvRCxhQUFhSztBQUNoRDtBQUNBLFNBQVNFLFVBQVUvNkQsQ0FBQyxFQUFFMDZELEdBQUcsRUFBRTVpRCxHQUFHO0lBQzVCLElBQUlBLElBQUltNUMsT0FBTyxJQUFJO1FBQ2pCLElBQUloMUMsU0FBU25FLElBQUluYyxRQUFRLENBQUNzZ0IsTUFBTTtRQUNoQyxJQUFJLENBQUN5K0MsSUFBSTdoRCxHQUFHLENBQUNvRCxPQUFPdUMsRUFBRSxLQUFLO1lBQ3pCeGUsRUFBRWhILElBQUksQ0FBQ2lqQjtRQUNUO0lBQ0Y7QUFDRjtBQUNBMjlDLFNBQVNvQixTQUFTLEdBQUcsU0FBVW5nRSxFQUFFO0lBQy9CLElBQUkyL0QsY0FBYzE5RCxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDdEYsT0FBT3k5RCxnQkFBZ0IsSUFBSSxFQUFFMS9ELElBQUkyL0QsYUFBYU87QUFDaEQ7QUFDQSxTQUFTRSxxQkFBcUJqN0QsQ0FBQyxFQUFFMDZELEdBQUcsRUFBRTVpRCxHQUFHO0lBQ3ZDaWpELFVBQVUvNkQsR0FBRzA2RCxLQUFLNWlEO0lBQ2xCK2lELFlBQVk3NkQsR0FBRzA2RCxLQUFLNWlEO0FBQ3RCO0FBQ0E4aEQsU0FBU3NCLGdCQUFnQixHQUFHLFNBQVVyZ0UsRUFBRTtJQUN0QyxJQUFJMi9ELGNBQWMxOUQsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3RGLE9BQU95OUQsZ0JBQWdCLElBQUksRUFBRTEvRCxJQUFJMi9ELGFBQWFTO0FBQ2hEO0FBRUEsVUFBVTtBQUNWckIsU0FBUy9CLFNBQVMsR0FBRytCLFNBQVNDLE9BQU87QUFFckMsSUFBSXNCLE1BQU1DO0FBQ1ZELE9BQU9DLFdBQVc7SUFDaEJqaEQsTUFBTSt5QyxPQUFPL3lDLElBQUksQ0FBQztRQUNoQjh2QyxPQUFPO1FBQ1BDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxjQUFjO1FBQ2RFLGNBQWM7UUFDZEMsc0JBQXNCO1FBQ3RCQyxlQUFlO1FBQ2ZILGNBQWM7UUFDZEksZUFBZTtZQUNiLE1BQU07WUFDTixVQUFVO1lBQ1YsVUFBVTtZQUNWLFVBQVU7UUFDWjtRQUNBQyxhQUFhO0lBQ2Y7SUFDQVksWUFBWTRCLE9BQU81QixVQUFVLENBQUM7UUFDNUJyQixPQUFPO1FBQ1BsdUQsT0FBTztRQUNQeXVELGVBQWU7UUFDZmUsY0FBYztRQUNkZCxlQUFlO1lBQ2IsTUFBTTtZQUNOLFVBQVU7WUFDVixVQUFVO1lBQ1YsVUFBVTtRQUNaO1FBQ0FDLGFBQWE7SUFDZjtJQUNBNXVDLFNBQVNveEMsT0FBTy95QyxJQUFJLENBQUM7UUFDbkI4dkMsT0FBTztRQUNQQyxjQUFjO1FBQ2RDLGNBQWM7UUFDZEMsY0FBYztRQUNkRSxjQUFjO1FBQ2RDLHNCQUFzQjtRQUN0QkMsZUFBZTtRQUNmSCxjQUFjO1FBQ2RLLGFBQWE7SUFDZjtJQUNBMlEsZUFBZW5PLE9BQU81QixVQUFVLENBQUM7UUFDL0JyQixPQUFPO1FBQ1BsdUQsT0FBTztRQUNQeXVELGVBQWU7UUFDZmUsY0FBYztRQUNkYixhQUFhO0lBQ2Y7SUFDQTd1QyxVQUFVcXhDLE9BQU8veUMsSUFBSSxDQUFDO1FBQ3BCOHZDLE9BQU87UUFDUEUsY0FBYztRQUNkQyxjQUFjO1FBQ2RHLHNCQUFzQjtRQUN0QkYsY0FBYztJQUNoQjtJQUNBaVIsZ0JBQWdCcE8sT0FBTzVCLFVBQVUsQ0FBQztRQUNoQ3JCLE9BQU87UUFDUHNCLGNBQWM7SUFDaEI7SUFDQS9zQyxJQUFJLFNBQVNBO1FBQ1gsSUFBSTFHLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSUEsS0FBSztZQUNQLE9BQU9BLElBQUluYyxRQUFRLENBQUN3ZSxJQUFJLENBQUNxRSxFQUFFO1FBQzdCO0lBQ0Y7QUFDRjtBQUVBLFVBQVU7QUFDVjI4QyxLQUFLL3JCLElBQUksR0FBRytyQixLQUFLaGhELElBQUk7QUFDckJnaEQsS0FBS0ksVUFBVSxHQUFHSixLQUFLN1AsVUFBVTtBQUNqQyxJQUFJbnhDLE9BQU9paEQ7QUFFWCxJQUFJSSxXQUFXLENBQUM7QUFDaEIsU0FBU0MscUJBQXFCOWhELFFBQVE7SUFDcEMsT0FBTyxTQUFVK2hELFlBQVk7UUFDM0IsSUFBSXYrRCxRQUFPLElBQUk7UUFDZixJQUFJdStELGlCQUFpQm5pRSxXQUFXO1lBQzlCbWlFLGVBQWU7UUFDakI7UUFDQSxJQUFJditELE1BQUszRyxNQUFNLEtBQUssR0FBRztZQUNyQjtRQUNGO1FBQ0EsSUFBSTJHLE1BQUsrZSxNQUFNLE1BQU0sQ0FBQy9lLE1BQUs4ZCxPQUFPLElBQUk7WUFDcEMsSUFBSTRuQixTQUFTO1lBQ2IsSUFBSW5qQixPQUFPdmlCLEtBQUksQ0FBQyxFQUFFO1lBQ2xCLElBQUlpaUIsaUJBQWlCTSxLQUFLL2pCLFFBQVEsQ0FBQ29nQixLQUFLO1lBQ3hDLElBQUssSUFBSWhqQixJQUFJLEdBQUdBLElBQUlxbUIsZUFBZTVvQixNQUFNLEVBQUV1QyxJQUFLO2dCQUM5QyxJQUFJNG1CLE9BQU9QLGNBQWMsQ0FBQ3JtQixFQUFFO2dCQUM1QixJQUFJLENBQUMyaUUsZ0JBQWdCLzdDLEtBQUt3RSxNQUFNLElBQUk7b0JBQ2xDO2dCQUNGO2dCQUNBMGUsVUFBVWxwQixTQUFTK0YsTUFBTUM7WUFDM0I7WUFDQSxPQUFPa2pCO1FBQ1QsT0FBTztZQUNMO1FBQ0Y7SUFDRjtBQUNGO0FBQ0E5akMsT0FBT3k4RCxVQUFVO0lBQ2YzNEIsUUFBUTQ0QixxQkFBcUIsU0FBVS83QyxJQUFJLEVBQUVDLElBQUk7UUFDL0MsSUFBSUEsS0FBS3ZGLE1BQU0sR0FBRzhFLElBQUksQ0FBQ1MsS0FBS3RGLE1BQU0sS0FBSztZQUNyQyxPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBQ0E4b0IsVUFBVXM0QixxQkFBcUIsU0FBVS83QyxJQUFJLEVBQUVDLElBQUk7UUFDakQsSUFBSUEsS0FBS3RGLE1BQU0sR0FBRzZFLElBQUksQ0FBQ1EsT0FBTztZQUM1QixPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBQ0EwakIsV0FBV3E0QixxQkFBcUIsU0FBVS83QyxJQUFJLEVBQUVDLElBQUk7UUFDbEQsSUFBSUEsS0FBS3ZGLE1BQU0sR0FBRzhFLElBQUksQ0FBQ1EsT0FBTztZQUM1QixPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFDQSxTQUFTaThDLDJCQUEyQkMsUUFBUSxFQUFFamlELFFBQVE7SUFDcEQsT0FBTyxTQUFVK2hELFlBQVk7UUFDM0IsSUFBSXQrRDtRQUNKLElBQUlpaEIsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSyxJQUFJdGxCLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7WUFDckMsSUFBSStlLE1BQU11RyxLQUFLLENBQUN0bEIsRUFBRTtZQUNsQixJQUFJOHBDLFNBQVMvcUIsR0FBRyxDQUFDOGpELFNBQVMsQ0FBQ0Y7WUFDM0IsSUFBSTc0QixXQUFXdHBDLGFBQWM2RCxDQUFBQSxRQUFRN0QsYUFBYW9nQixTQUFTa3BCLFFBQVF6bEMsSUFBRyxHQUFJO2dCQUN4RUEsTUFBTXlsQztZQUNSO1FBQ0Y7UUFDQSxPQUFPemxDO0lBQ1Q7QUFDRjtBQUNBMkIsT0FBT3k4RCxVQUFVO0lBQ2ZLLFdBQVdGLDJCQUEyQixVQUFVLFNBQVU5NEIsTUFBTSxFQUFFeHlCLEdBQUc7UUFDbkUsT0FBT3d5QixTQUFTeHlCO0lBQ2xCO0lBQ0FxeUIsV0FBV2k1QiwyQkFBMkIsVUFBVSxTQUFVOTRCLE1BQU0sRUFBRTF5QixHQUFHO1FBQ25FLE9BQU8weUIsU0FBUzF5QjtJQUNsQjtJQUNBMnJELGFBQWFILDJCQUEyQixZQUFZLFNBQVU5NEIsTUFBTSxFQUFFeHlCLEdBQUc7UUFDdkUsT0FBT3d5QixTQUFTeHlCO0lBQ2xCO0lBQ0EyeUIsYUFBYTI0QiwyQkFBMkIsWUFBWSxTQUFVOTRCLE1BQU0sRUFBRTF5QixHQUFHO1FBQ3ZFLE9BQU8weUIsU0FBUzF5QjtJQUNsQjtJQUNBNHJELGNBQWNKLDJCQUEyQixhQUFhLFNBQVU5NEIsTUFBTSxFQUFFeHlCLEdBQUc7UUFDekUsT0FBT3d5QixTQUFTeHlCO0lBQ2xCO0lBQ0E0eUIsY0FBYzA0QiwyQkFBMkIsYUFBYSxTQUFVOTRCLE1BQU0sRUFBRTF5QixHQUFHO1FBQ3pFLE9BQU8weUIsU0FBUzF5QjtJQUNsQjtBQUNGO0FBQ0FwUixPQUFPeThELFVBQVU7SUFDZlEsYUFBYSxTQUFTQSxZQUFZTixZQUFZO1FBQzVDLElBQUl0c0MsUUFBUTtRQUNaLElBQUkvUSxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFLLElBQUl0bEIsSUFBSSxHQUFHQSxJQUFJc2xCLE1BQU03bkIsTUFBTSxFQUFFdUMsSUFBSztZQUNyQ3EyQixTQUFTL1EsS0FBSyxDQUFDdGxCLEVBQUUsQ0FBQzhwQyxNQUFNLENBQUM2NEI7UUFDM0I7UUFDQSxPQUFPdHNDO0lBQ1Q7QUFDRjtBQUVBLElBQUk2c0MsTUFBTUM7QUFDVixJQUFJQyxvQkFBb0IsU0FBU0Esa0JBQWtCdDRDLElBQUksRUFBRXU0QyxNQUFNLEVBQUVDLE1BQU07SUFDckUsSUFBSyxJQUFJdGpFLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtRQUNqQixJQUFJLENBQUMrZSxJQUFJc0QsTUFBTSxJQUFJO1lBQ2pCLElBQUlraEQsU0FBU3hrRCxJQUFJbmMsUUFBUSxDQUFDNGUsUUFBUTtZQUNsQyxJQUFJNm5CLFFBQVE7Z0JBQ1Z0M0IsR0FBR3N4RCxPQUFPdHhELENBQUMsSUFBSSxPQUFPc3hELE9BQU90eEQsQ0FBQyxHQUFHd3hELE9BQU94eEQsQ0FBQyxHQUFHO2dCQUM1Q3lKLEdBQUc2bkQsT0FBTzduRCxDQUFDLElBQUksT0FBTzZuRCxPQUFPN25ELENBQUMsR0FBRytuRCxPQUFPL25ELENBQUMsR0FBRztZQUM5QztZQUNBLElBQUl1RCxJQUFJaTVDLFFBQVEsTUFBTSxDQUFFM3VCLENBQUFBLE1BQU10M0IsQ0FBQyxLQUFLLEtBQUtzM0IsTUFBTTd0QixDQUFDLEtBQUssSUFBSTtnQkFDdkR1RCxJQUFJa0UsUUFBUSxHQUFHMkMsS0FBSyxDQUFDeWpCLE9BQU9pNkI7WUFDOUI7WUFDQXZrRCxJQUFJeWtELHFCQUFxQjtRQUMzQjtJQUNGO0FBQ0Y7QUFDQSxJQUFJQyxjQUFjO0lBQ2hCdlMsT0FBTztJQUNQQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsY0FBYztJQUNkRSxjQUFjO0lBQ2RDLHNCQUFzQjtJQUN0QkMsZUFBZTtJQUNmSCxjQUFjO0lBQ2RvUyxXQUFXO1FBQUM7UUFBSztLQUFJO0lBQ3JCOVIsV0FBVyxTQUFTQSxVQUFVN3lDLEdBQUc7UUFDL0JBLElBQUk0a0Qsb0JBQW9CO0lBQzFCO0lBQ0E5UixXQUFXLFNBQVNBLFVBQVUvbUMsSUFBSSxFQUFFdTRDLE1BQU07UUFDeENELGtCQUFrQnQ0QyxNQUFNdTRDLFFBQVE7SUFDbEM7SUFDQXZSLE9BQU8sU0FBU0EsTUFBTWhuQyxJQUFJO1FBQ3hCQSxLQUFLODRDLHdCQUF3QjtJQUMvQjtJQUNBN1IsUUFBUSxTQUFTQSxPQUFPaHpDLEdBQUc7UUFDekIsT0FBTyxDQUFDQSxJQUFJc0QsTUFBTTtJQUNwQjtBQUNGO0FBQ0E2Z0QsT0FBT0MsV0FBVztJQUNoQjNoRCxVQUFVMnlDLE9BQU8veUMsSUFBSSxDQUFDcWlEO0lBQ3RCLDJDQUEyQztJQUMzQ0ksZ0JBQWdCMVAsT0FBTy95QyxJQUFJLENBQUNwYixPQUFPLENBQUMsR0FBR3k5RCxhQUFhO1FBQ2xEclMsY0FBYztRQUNkQyxjQUFjO1FBQ2RHLHNCQUFzQjtRQUN0QkYsY0FBYztRQUNkTyxXQUFXLFNBQVNBLFVBQVUvbUMsSUFBSSxFQUFFdTRDLE1BQU07WUFDeENELGtCQUFrQnQ0QyxNQUFNdTRDLFFBQVE7UUFDbEM7UUFDQXZSLE9BQU8sU0FBU0EsTUFBTWhuQyxJQUFJO1lBQ3hCQSxLQUFLODRDLHdCQUF3QjtRQUMvQjtJQUNGO0lBQ0FFLFdBQVcsU0FBU0EsVUFBVXRuRCxHQUFHLEVBQUU4bUQsTUFBTTtRQUN2QyxJQUFJcmhFLFlBQVl1YSxNQUFNO1lBQ3BCLElBQUk4bUQsUUFBUTtnQkFDVixJQUFJLENBQUNPLGNBQWMsQ0FBQ3JuRDtZQUN0QixPQUFPO2dCQUNMLElBQUksQ0FBQ2dGLFFBQVEsQ0FBQ2hGO1lBQ2hCO1FBQ0YsT0FBTyxJQUFJNWEsS0FBSzRhLE1BQU07WUFDcEIsSUFBSXVuRCxNQUFNdm5EO1lBQ1YsSUFBSXdFLEtBQUssSUFBSSxDQUFDQSxFQUFFO1lBQ2hCQSxHQUFHZ2pELFVBQVU7WUFDYixJQUFLLElBQUloa0UsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7Z0JBQ2pCLElBQUlpa0UsT0FBT3pqRTtnQkFDWCxJQUFJeWpFLE9BQU9GLElBQUlobEQsS0FBSy9lLElBQUk7b0JBQ3RCLElBQUlzakUsUUFBUTt3QkFDVnZrRCxJQUFJOGtELGNBQWMsQ0FBQ0k7b0JBQ3JCLE9BQU87d0JBQ0xsbEQsSUFBSXlDLFFBQVEsQ0FBQ3lpRDtvQkFDZjtnQkFDRjtZQUNGO1lBQ0FqakQsR0FBR2tqRCxRQUFRO1FBQ2I7UUFDQSxPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0lBQ0FDLGlCQUFpQixTQUFTQSxnQkFBZ0IzbkQsR0FBRztRQUMzQyxPQUFPLElBQUksQ0FBQ3NuRCxTQUFTLENBQUN0bkQsS0FBSztJQUM3QjtJQUNBb0osT0FBTyxTQUFTQSxNQUFNOHFCLEdBQUcsRUFBRS93QixHQUFHLEVBQUUyakQsTUFBTTtRQUNwQyxJQUFJajZCO1FBQ0osSUFBSXBuQyxZQUFZeXVDLE1BQU07WUFDcEJySCxRQUFRO2dCQUNOdDNCLEdBQUc1UCxTQUFTdXVDLElBQUkzK0IsQ0FBQyxJQUFJMitCLElBQUkzK0IsQ0FBQyxHQUFHO2dCQUM3QnlKLEdBQUdyWixTQUFTdXVDLElBQUlsMUIsQ0FBQyxJQUFJazFCLElBQUlsMUIsQ0FBQyxHQUFHO1lBQy9CO1lBQ0E4bkQsU0FBUzNqRDtRQUNYLE9BQU8sSUFBSTlkLE9BQU82dUMsUUFBUXZ1QyxTQUFTd2QsTUFBTTtZQUN2QzBwQixRQUFRO2dCQUNOdDNCLEdBQUc7Z0JBQ0h5SixHQUFHO1lBQ0w7WUFDQTZ0QixLQUFLLENBQUNxSCxJQUFJLEdBQUcvd0I7UUFDZjtRQUNBLElBQUkwcEIsU0FBUyxNQUFNO1lBQ2pCLElBQUlyb0IsS0FBSyxJQUFJLENBQUNBLEVBQUU7WUFDaEJBLEdBQUdnakQsVUFBVTtZQUNiLElBQUssSUFBSWhrRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztnQkFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtnQkFFakIsa0VBQWtFO2dCQUNsRSxJQUFJZ2hCLEdBQUc2Z0QsZ0JBQWdCLE1BQU05aUQsSUFBSW01QyxPQUFPLE1BQU1uNUMsSUFBSSsvQyxTQUFTLEdBQUdpQixPQUFPLENBQUMsSUFBSSxHQUFHO29CQUMzRTtnQkFDRjtnQkFDQSxJQUFJdmpELE1BQU11QyxJQUFJeUMsUUFBUTtnQkFDdEIsSUFBSTZoRCxTQUFTO29CQUNYdHhELEdBQUd5SyxJQUFJekssQ0FBQyxHQUFHczNCLE1BQU10M0IsQ0FBQztvQkFDbEJ5SixHQUFHZ0IsSUFBSWhCLENBQUMsR0FBRzZ0QixNQUFNN3RCLENBQUM7Z0JBQ3BCO2dCQUNBLElBQUk4bkQsUUFBUTtvQkFDVnZrRCxJQUFJOGtELGNBQWMsQ0FBQ1I7Z0JBQ3JCLE9BQU87b0JBQ0x0a0QsSUFBSXlDLFFBQVEsQ0FBQzZoRDtnQkFDZjtZQUNGO1lBQ0FyaUQsR0FBR2tqRCxRQUFRO1FBQ2I7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBRSxhQUFhLFNBQVNBLFlBQVkxekIsR0FBRyxFQUFFL3dCLEdBQUc7UUFDeEMsSUFBSTFkLFlBQVl5dUMsTUFBTTtZQUNwQixJQUFJLENBQUM5cUIsS0FBSyxDQUFDOHFCLEtBQUs7UUFDbEIsT0FBTyxJQUFJN3VDLE9BQU82dUMsUUFBUXZ1QyxTQUFTd2QsTUFBTTtZQUN2QyxJQUFJLENBQUNpRyxLQUFLLENBQUM4cUIsS0FBSy93QixLQUFLO1FBQ3ZCO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQSwrREFBK0Q7SUFDL0RtRSxrQkFBa0IsU0FBU0EsaUJBQWlCNHNCLEdBQUcsRUFBRS93QixHQUFHO1FBQ2xELElBQUlaLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSWlDLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUlpRCxPQUFPakQsR0FBR2lELElBQUk7UUFDbEIsSUFBSUQsTUFBTWhELEdBQUdnRCxHQUFHO1FBQ2hCLElBQUlELE9BQU85aEIsWUFBWXl1QyxPQUFPQSxNQUFNbHdDO1FBQ3BDLElBQUk2akUsVUFBVXRnRCxTQUFTdmpCLGFBQWFtZixRQUFRbmYsYUFBYXFCLE9BQU82dUM7UUFDaEUsSUFBSTN4QixPQUFPQSxJQUFJb0UsTUFBTSxJQUFJO1lBQ3ZCLDZEQUE2RDtZQUM3RCxJQUFJa2hELFNBQVM7Z0JBQ1gsSUFBSyxJQUFJcmtFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO29CQUNwQyxJQUFJcXlELE9BQU8sSUFBSSxDQUFDcnlELEVBQUU7b0JBQ2xCLElBQUkyZixRQUFRbmYsV0FBVzt3QkFDckIsb0JBQW9CO3dCQUNwQjZ4RCxLQUFLN3dDLFFBQVEsQ0FBQ2t2QixLQUFLLENBQUMvd0IsTUFBTXFFLEdBQUcsQ0FBQzBzQixJQUFJLElBQUl6c0I7b0JBQ3hDLE9BQU8sSUFBSUYsU0FBU3ZqQixXQUFXO3dCQUM3QixxQkFBcUI7d0JBQ3JCNnhELEtBQUs3d0MsUUFBUSxDQUFDd1Usd0JBQXdCalMsTUFBTUUsTUFBTUQ7b0JBQ3BEO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxVQUFVO2dCQUNWLElBQUl4SCxNQUFNdUMsSUFBSXlDLFFBQVE7Z0JBQ3RCdUMsT0FBTytSLDBCQUEwQnRaLEtBQUt5SCxNQUFNRDtnQkFDNUMsSUFBSTBzQixRQUFRbHdDLFdBQVc7b0JBQ3JCLDBDQUEwQztvQkFDMUMsT0FBT3VqQjtnQkFDVCxPQUFPO29CQUNMLHNDQUFzQztvQkFDdEMsT0FBT0EsSUFBSSxDQUFDMnNCLElBQUk7Z0JBQ2xCO1lBQ0Y7UUFDRixPQUFPLElBQUksQ0FBQzJ6QixTQUFTO1lBQ25CLE9BQU83akUsV0FBVyw0QkFBNEI7UUFDaEQ7UUFDQSxPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0lBQ0EsOENBQThDO0lBQzlDOGpFLGtCQUFrQixTQUFTQSxpQkFBaUI1ekIsR0FBRyxFQUFFL3dCLEdBQUc7UUFDbEQsSUFBSVosTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJaUMsS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSXVqRCxPQUFPdGlFLFlBQVl5dUMsT0FBT0EsTUFBTWx3QztRQUNwQyxJQUFJNmpFLFVBQVVFLFNBQVMvakUsYUFBYW1mLFFBQVFuZixhQUFhcUIsT0FBTzZ1QztRQUNoRSxJQUFJbXhCLG1CQUFtQjdnRCxHQUFHNmdELGdCQUFnQjtRQUMxQyxJQUFJOWlELE9BQU9BLElBQUlvRSxNQUFNLElBQUk7WUFDdkIsNkRBQTZEO1lBQzdELElBQUlraEQsU0FBUztnQkFDWCxJQUFLLElBQUlya0UsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7b0JBQ3BDLElBQUl3a0UsUUFBUSxJQUFJLENBQUN4a0UsRUFBRTtvQkFDbkIsSUFBSWtqQixTQUFTMitDLG1CQUFtQjJDLE1BQU10aEQsTUFBTSxLQUFLO29CQUNqRCxJQUFJdWhELFlBQVl2aEQsVUFBVUEsT0FBT3psQixNQUFNLEdBQUc7b0JBQzFDLElBQUlpbkUsbUJBQW1CRDtvQkFDdkIsSUFBSUEsV0FBVzt3QkFDYnZoRCxTQUFTQSxNQUFNLENBQUMsRUFBRTtvQkFDcEI7b0JBQ0EsSUFBSXloRCxTQUFTRCxtQkFBbUJ4aEQsT0FBTzFCLFFBQVEsS0FBSzt3QkFDbER6UCxHQUFHO3dCQUNIeUosR0FBRztvQkFDTDtvQkFDQSxJQUFJbUUsUUFBUW5mLFdBQVc7d0JBQ3JCLG9CQUFvQjt3QkFDcEJna0UsTUFBTWhqRCxRQUFRLENBQUNrdkIsS0FBSy93QixNQUFNZ2xELE1BQU0sQ0FBQ2owQixJQUFJO29CQUN2QyxPQUFPLElBQUk2ekIsU0FBUy9qRSxXQUFXO3dCQUM3QixxQkFBcUI7d0JBQ3JCZ2tFLE1BQU1oakQsUUFBUSxDQUFDOzRCQUNielAsR0FBR3d5RCxLQUFLeHlELENBQUMsR0FBRzR5RCxPQUFPNXlELENBQUM7NEJBQ3BCeUosR0FBRytvRCxLQUFLL29ELENBQUMsR0FBR21wRCxPQUFPbnBELENBQUM7d0JBQ3RCO29CQUNGO2dCQUNGO1lBQ0YsT0FBTztnQkFDTCxVQUFVO2dCQUNWLElBQUlnQixNQUFNdUMsSUFBSXlDLFFBQVE7Z0JBQ3RCLElBQUl5NUMsVUFBVTRHLG1CQUFtQjlpRCxJQUFJbUUsTUFBTSxLQUFLO2dCQUNoRCxJQUFJMGhELGFBQWEzSixXQUFXQSxRQUFReDlELE1BQU0sR0FBRztnQkFDN0MsSUFBSW9uRSxvQkFBb0JEO2dCQUN4QixJQUFJQSxZQUFZO29CQUNkM0osVUFBVUEsT0FBTyxDQUFDLEVBQUU7Z0JBQ3RCO2dCQUNBLElBQUk2SixVQUFVRCxvQkFBb0I1SixRQUFRejVDLFFBQVEsS0FBSztvQkFDckR6UCxHQUFHO29CQUNIeUosR0FBRztnQkFDTDtnQkFDQStvRCxPQUFPO29CQUNMeHlELEdBQUd5SyxJQUFJekssQ0FBQyxHQUFHK3lELFFBQVEveUQsQ0FBQztvQkFDcEJ5SixHQUFHZ0IsSUFBSWhCLENBQUMsR0FBR3NwRCxRQUFRdHBELENBQUM7Z0JBQ3RCO2dCQUNBLElBQUlrMUIsUUFBUWx3QyxXQUFXO29CQUNyQiwwQ0FBMEM7b0JBQzFDLE9BQU8rakU7Z0JBQ1QsT0FBTztvQkFDTCxzQ0FBc0M7b0JBQ3RDLE9BQU9BLElBQUksQ0FBQzd6QixJQUFJO2dCQUNsQjtZQUNGO1FBQ0YsT0FBTyxJQUFJLENBQUMyekIsU0FBUztZQUNuQixPQUFPN2pFLFdBQVcsNEJBQTRCO1FBQ2hEO1FBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztJQUMxQjtBQUNGO0FBRUEsVUFBVTtBQUNWMGlFLEtBQUs2QixhQUFhLEdBQUc3QixLQUFLNzdCLEtBQUssR0FBRzY3QixLQUFLMWhELFFBQVE7QUFDL0MwaEQsS0FBSzhCLGNBQWMsR0FBRzlCLEtBQUt6akMsTUFBTSxHQUFHeWpDLEtBQUtZLFNBQVM7QUFDbERaLEtBQUsrQixhQUFhLEdBQUcvQixLQUFLcC9DLGdCQUFnQjtBQUMxQ28vQyxLQUFLZ0MsYUFBYSxHQUFHaEMsS0FBS29CLGdCQUFnQjtBQUMxQyxJQUFJOWlELFdBQVcyaEQ7QUFFZixJQUFJZ0MsTUFBTUM7QUFDVkQsT0FBT0MsV0FBVyxDQUFDO0FBQ25CQSxTQUFTQyxtQkFBbUIsR0FBRyxTQUFVOXpELE9BQU87SUFDOUMsSUFBSTBtQixLQUFLLElBQUksQ0FBQzcwQixXQUFXLENBQUNtTztJQUMxQixJQUFJeVAsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSWlELE9BQU9qRCxHQUFHaUQsSUFBSTtJQUNsQixJQUFJRCxNQUFNaEQsR0FBR2dELEdBQUc7SUFDaEIsSUFBSTNnQixLQUFLNDBCLEdBQUc1MEIsRUFBRSxHQUFHNGdCLE9BQU9ELElBQUlqUyxDQUFDO0lBQzdCLElBQUl6TyxLQUFLMjBCLEdBQUczMEIsRUFBRSxHQUFHMmdCLE9BQU9ELElBQUlqUyxDQUFDO0lBQzdCLElBQUl4TyxLQUFLMDBCLEdBQUcxMEIsRUFBRSxHQUFHMGdCLE9BQU9ELElBQUl4SSxDQUFDO0lBQzdCLElBQUloWSxLQUFLeTBCLEdBQUd6MEIsRUFBRSxHQUFHeWdCLE9BQU9ELElBQUl4SSxDQUFDO0lBQzdCLE9BQU87UUFDTG5ZLElBQUlBO1FBQ0pDLElBQUlBO1FBQ0pDLElBQUlBO1FBQ0pDLElBQUlBO1FBQ0prWixHQUFHcFosS0FBS0Q7UUFDUnlELEdBQUd0RCxLQUFLRDtJQUNWO0FBQ0Y7QUFDQTZoRSxTQUFTeEIsd0JBQXdCLEdBQUc7SUFDbEMsSUFBSU4sU0FBU3YvRCxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDakYsSUFBSWlkLEtBQUssSUFBSSxDQUFDQSxFQUFFO0lBQ2hCLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLE1BQU0sQ0FBQ3QvQixHQUFHNmdELGdCQUFnQixJQUFJO1FBQ2hELE9BQU8sSUFBSTtJQUNiO0lBQ0EsSUFBSSxDQUFDSSxTQUFTLENBQUMsU0FBVWxqRCxHQUFHO1FBQzFCLElBQUlBLElBQUlpNUMsUUFBUSxJQUFJO1lBQ2xCLElBQUl6MkMsS0FBS3hDLElBQUluYyxRQUFRO1lBQ3JCMmUsR0FBR0ssbUJBQW1CLEdBQUc7WUFDekJMLEdBQUcrQixPQUFPLEdBQUc7WUFDYixJQUFJLENBQUNnZ0QsUUFBUTtnQkFDWHZrRCxJQUFJdW1ELGFBQWEsQ0FBQztZQUNwQjtRQUNGO0lBQ0Y7SUFDQSxPQUFPLElBQUk7QUFDYjtBQUNBRixTQUFTekIsb0JBQW9CLEdBQUc7SUFDOUIsSUFBSTRCLFFBQVF4aEUsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2hGLElBQUlpZCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtJQUVoQix1RUFBdUU7SUFDdkUsSUFBSSxDQUFDQSxHQUFHcy9CLFlBQVksTUFBTSxDQUFDdC9CLEdBQUc2Z0QsZ0JBQWdCLElBQUk7UUFDaEQsT0FBTyxJQUFJO0lBQ2I7SUFFQSwyRUFBMkU7SUFDM0UsSUFBSSxDQUFDMEQsU0FBU3ZrRCxHQUFHd2tELFFBQVEsSUFBSTtRQUMzQixPQUFPLElBQUk7SUFDYjtJQUNBLFNBQVNDLE9BQU92aUQsTUFBTTtRQUNwQixJQUFJLENBQUNBLE9BQU84MEMsUUFBUSxJQUFJO1lBQ3RCO1FBQ0Y7UUFDQSxJQUFJejJDLEtBQUsyQixPQUFPdGdCLFFBQVE7UUFDeEIsSUFBSXFnQixXQUFXQyxPQUFPRCxRQUFRO1FBQzlCLElBQUl5aUQsZ0JBQWdCeGlELE9BQU95aUQsTUFBTSxDQUFDLDhCQUE4QnRtRSxLQUFLLEtBQUs7UUFDMUUsSUFBSWlZLE1BQU07WUFDUnFqQixPQUFPO2dCQUNMaGIsS0FBS3VELE9BQU95aUQsTUFBTSxDQUFDLGFBQWFDLE9BQU87Z0JBQ3ZDL3NDLE1BQU0zVixPQUFPeWlELE1BQU0sQ0FBQztnQkFDcEJodEMsT0FBT3pWLE9BQU95aUQsTUFBTSxDQUFDO1lBQ3ZCO1lBQ0EvcUMsUUFBUTtnQkFDTmpiLEtBQUt1RCxPQUFPeWlELE1BQU0sQ0FBQyxjQUFjQyxPQUFPO2dCQUN4Q3o3QyxLQUFLakgsT0FBT3lpRCxNQUFNLENBQUM7Z0JBQ25CL3NDLFFBQVExVixPQUFPeWlELE1BQU0sQ0FBQztZQUN4QjtRQUNGO1FBQ0EsSUFBSTF0QyxLQUFLaFYsU0FBUzdmLFdBQVcsQ0FBQztZQUM1QnNpRSxlQUFlQTtZQUNmRyxpQkFBaUI7WUFDakIsOERBQThEO1lBQzlELHlDQUF5QztZQUN6Q0MsVUFBVTtRQUNaO1FBQ0EsSUFBSXRwRCxNQUFNK0UsR0FBR0MsUUFBUTtRQUVyQixtRkFBbUY7UUFDbkYsSUFBSXlXLEdBQUd2YixDQUFDLEtBQUssS0FBS3ViLEdBQUdueEIsQ0FBQyxLQUFLLEdBQUc7WUFDNUJteEIsS0FBSztnQkFDSHZiLEdBQUd3RyxPQUFPeWlELE1BQU0sQ0FBQyxTQUFTQyxPQUFPO2dCQUNqQzkrRCxHQUFHb2MsT0FBT3lpRCxNQUFNLENBQUMsVUFBVUMsT0FBTztZQUNwQztZQUNBM3RDLEdBQUc1MEIsRUFBRSxHQUFHbVosSUFBSXpLLENBQUMsR0FBR2ttQixHQUFHdmIsQ0FBQyxHQUFHO1lBQ3ZCdWIsR0FBRzMwQixFQUFFLEdBQUdrWixJQUFJekssQ0FBQyxHQUFHa21CLEdBQUd2YixDQUFDLEdBQUc7WUFDdkJ1YixHQUFHMTBCLEVBQUUsR0FBR2laLElBQUloQixDQUFDLEdBQUd5YyxHQUFHbnhCLENBQUMsR0FBRztZQUN2Qm14QixHQUFHejBCLEVBQUUsR0FBR2daLElBQUloQixDQUFDLEdBQUd5YyxHQUFHbnhCLENBQUMsR0FBRztRQUN6QjtRQUNBLFNBQVNpL0Qsa0JBQWtCQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsa0JBQWtCO1lBQy9ELElBQUlDLFdBQVc7WUFDZixJQUFJQyxxQkFBcUI7WUFDekIsSUFBSUMsWUFBWUosV0FBV0M7WUFDM0IsSUFBSUYsV0FBVyxLQUFLSyxZQUFZLEdBQUc7Z0JBQ2pDRixXQUFXRixXQUFXSSxZQUFZTDtnQkFDbENJLHFCQUFxQkYscUJBQXFCRyxZQUFZTDtZQUN4RDtZQUNBLE9BQU87Z0JBQ0xHLFVBQVVBO2dCQUNWQyxvQkFBb0JBO1lBQ3RCO1FBQ0Y7UUFDQSxTQUFTRSxxQkFBcUIzckMsS0FBSyxFQUFFQyxNQUFNLEVBQUUyckMsYUFBYSxFQUFFQyxVQUFVO1lBQ3BFLDRDQUE0QztZQUM1QyxJQUFJRCxjQUFjRSxLQUFLLEtBQUssS0FBSztnQkFDL0IsT0FBUUQ7b0JBQ04sS0FBSzt3QkFDSCxPQUFPN3JDLFFBQVEsSUFBSTRyQyxjQUFjWCxPQUFPLEdBQUdqckMsUUFBUTtvQkFDckQsS0FBSzt3QkFDSCxPQUFPQyxTQUFTLElBQUkyckMsY0FBY1gsT0FBTyxHQUFHaHJDLFNBQVM7b0JBQ3ZELEtBQUs7d0JBQ0gsT0FBT0QsUUFBUSxLQUFLQyxTQUFTLElBQUkyckMsY0FBY1gsT0FBTyxHQUFJanJDLENBQUFBLFFBQVFDLE1BQUssSUFBSyxJQUFJO29CQUNsRixLQUFLO3dCQUNILE9BQU9ELFFBQVEsS0FBS0MsU0FBUyxJQUFJRCxRQUFRQyxTQUFTMnJDLGNBQWNYLE9BQU8sR0FBR2hyQyxTQUFTMnJDLGNBQWNYLE9BQU8sR0FBR2pyQyxRQUFRO29CQUNySCxLQUFLO3dCQUNILE9BQU9BLFFBQVEsS0FBS0MsU0FBUyxJQUFJRCxRQUFRQyxTQUFTMnJDLGNBQWNYLE9BQU8sR0FBR2pyQyxRQUFRNHJDLGNBQWNYLE9BQU8sR0FBR2hyQyxTQUFTO29CQUNySDt3QkFDRSxPQUFPO2dCQUNYO1lBQ0YsT0FBTyxJQUFJMnJDLGNBQWNFLEtBQUssS0FBSyxNQUFNO2dCQUN2QyxPQUFPRixjQUFjWCxPQUFPO1lBQzlCLE9BQU87Z0JBQ0wsT0FBTztZQUNUO1FBQ0Y7UUFDQSxJQUFJYyxVQUFVcHZELElBQUlxakIsS0FBSyxDQUFDOUIsSUFBSSxDQUFDeDVCLEtBQUs7UUFDbEMsSUFBSWlZLElBQUlxakIsS0FBSyxDQUFDOUIsSUFBSSxDQUFDNHRDLEtBQUssS0FBSyxRQUFRbnZELElBQUlxakIsS0FBSyxDQUFDaGIsR0FBRyxHQUFHLEdBQUc7WUFDdEQrbUQsVUFBVUEsVUFBVSxNQUFNcHZELElBQUlxakIsS0FBSyxDQUFDaGIsR0FBRztRQUN6QztRQUNBLElBQUlnbkQsV0FBV3J2RCxJQUFJcWpCLEtBQUssQ0FBQ2hDLEtBQUssQ0FBQ3Q1QixLQUFLO1FBQ3BDLElBQUlpWSxJQUFJcWpCLEtBQUssQ0FBQ2hDLEtBQUssQ0FBQzh0QyxLQUFLLEtBQUssUUFBUW52RCxJQUFJcWpCLEtBQUssQ0FBQ2hiLEdBQUcsR0FBRyxHQUFHO1lBQ3ZEZ25ELFdBQVdBLFdBQVcsTUFBTXJ2RCxJQUFJcWpCLEtBQUssQ0FBQ2hiLEdBQUc7UUFDM0M7UUFDQSxJQUFJaW5ELFNBQVN0dkQsSUFBSXNqQixNQUFNLENBQUN6USxHQUFHLENBQUM5cUIsS0FBSztRQUNqQyxJQUFJaVksSUFBSXNqQixNQUFNLENBQUN6USxHQUFHLENBQUNzOEMsS0FBSyxLQUFLLFFBQVFudkQsSUFBSXNqQixNQUFNLENBQUNqYixHQUFHLEdBQUcsR0FBRztZQUN2RGluRCxTQUFTQSxTQUFTLE1BQU10dkQsSUFBSXNqQixNQUFNLENBQUNqYixHQUFHO1FBQ3hDO1FBQ0EsSUFBSWtuRCxZQUFZdnZELElBQUlzakIsTUFBTSxDQUFDaEMsTUFBTSxDQUFDdjVCLEtBQUs7UUFDdkMsSUFBSWlZLElBQUlzakIsTUFBTSxDQUFDaEMsTUFBTSxDQUFDNnRDLEtBQUssS0FBSyxRQUFRbnZELElBQUlzakIsTUFBTSxDQUFDamIsR0FBRyxHQUFHLEdBQUc7WUFDMURrbkQsWUFBWUEsWUFBWSxNQUFNdnZELElBQUlzakIsTUFBTSxDQUFDamIsR0FBRztRQUM5QztRQUNBLElBQUltbkQsaUJBQWlCZixrQkFBa0J6dUQsSUFBSXFqQixLQUFLLENBQUNoYixHQUFHLEdBQUdzWSxHQUFHdmIsQ0FBQyxFQUFFZ3FELFNBQVNDO1FBQ3RFLElBQUlJLFdBQVdELGVBQWVYLFFBQVE7UUFDdEMsSUFBSWEsWUFBWUYsZUFBZVYsa0JBQWtCO1FBQ2pELElBQUlhLGtCQUFrQmxCLGtCQUFrQnp1RCxJQUFJc2pCLE1BQU0sQ0FBQ2piLEdBQUcsR0FBR3NZLEdBQUdueEIsQ0FBQyxFQUFFOC9ELFFBQVFDO1FBQ3ZFLElBQUlLLFVBQVVELGdCQUFnQmQsUUFBUTtRQUN0QyxJQUFJZ0IsYUFBYUYsZ0JBQWdCYixrQkFBa0I7UUFDbkQ3a0QsR0FBR0ksV0FBVyxHQUFHMmtELHFCQUFxQnJ1QyxHQUFHdmIsQ0FBQyxFQUFFdWIsR0FBR254QixDQUFDLEVBQUVvYyxPQUFPeWlELE1BQU0sQ0FBQyxZQUFZemlELE9BQU95aUQsTUFBTSxDQUFDLHVCQUF1QnRtRSxLQUFLO1FBQ3RIa2lCLEdBQUdFLFNBQVMsR0FBR2xmLEtBQUs2VSxHQUFHLENBQUM2Z0IsR0FBR3ZiLENBQUMsRUFBRXBGLElBQUlxakIsS0FBSyxDQUFDaGIsR0FBRztRQUMzQ25ELElBQUl6SyxDQUFDLEdBQUcsQ0FBQyxDQUFDZzFELFdBQVc5dUMsR0FBRzUwQixFQUFFLEdBQUc0MEIsR0FBRzMwQixFQUFFLEdBQUcwakUsU0FBUSxJQUFLO1FBQ2xEemxELEdBQUdHLFVBQVUsR0FBR25mLEtBQUs2VSxHQUFHLENBQUM2Z0IsR0FBR254QixDQUFDLEVBQUV3USxJQUFJc2pCLE1BQU0sQ0FBQ2piLEdBQUc7UUFDN0NuRCxJQUFJaEIsQ0FBQyxHQUFHLENBQUMsQ0FBQzByRCxVQUFVanZDLEdBQUcxMEIsRUFBRSxHQUFHMDBCLEdBQUd6MEIsRUFBRSxHQUFHMmpFLFVBQVMsSUFBSztJQUNwRDtJQUNBLElBQUssSUFBSW5uRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJK2UsTUFBTSxJQUFJLENBQUMvZSxFQUFFO1FBQ2pCLElBQUl1aEIsS0FBS3hDLElBQUluYyxRQUFRO1FBQ3JCLElBQUksQ0FBQzJlLEdBQUdLLG1CQUFtQixJQUFJMmpELE9BQU87WUFDcENFLE9BQU8xbUQ7WUFDUCxJQUFJLENBQUNpQyxHQUFHd2tELFFBQVEsSUFBSTtnQkFDbEJqa0QsR0FBR0ssbUJBQW1CLEdBQUc7WUFDM0I7UUFDRjtJQUNGO0lBQ0EsT0FBTyxJQUFJO0FBQ2I7QUFDQSxJQUFJd2xELFNBQVMsU0FBU0EsT0FBT3IxRCxDQUFDO0lBQzVCLElBQUlBLE1BQU15WixZQUFZelosTUFBTSxDQUFDeVosVUFBVTtRQUNyQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPelo7QUFDVDtBQUNBLElBQUlzMUQsZUFBZSxTQUFTQSxhQUFhdmhFLENBQUMsRUFBRXpDLEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUU7SUFDeEQsb0NBQW9DO0lBQ3BDLElBQUlGLEtBQUtELE9BQU8sS0FBS0csS0FBS0QsT0FBTyxHQUFHO1FBQ2xDO0lBQ0Y7SUFFQSw2QkFBNkI7SUFDN0IsSUFBSUYsTUFBTSxRQUFRRSxNQUFNLFFBQVFELE1BQU0sUUFBUUUsTUFBTSxNQUFNO1FBQ3hEO0lBQ0Y7SUFDQXNDLEVBQUV6QyxFQUFFLEdBQUdBLEtBQUt5QyxFQUFFekMsRUFBRSxHQUFHQSxLQUFLeUMsRUFBRXpDLEVBQUU7SUFDNUJ5QyxFQUFFeEMsRUFBRSxHQUFHQSxLQUFLd0MsRUFBRXhDLEVBQUUsR0FBR0EsS0FBS3dDLEVBQUV4QyxFQUFFO0lBQzVCd0MsRUFBRXZDLEVBQUUsR0FBR0EsS0FBS3VDLEVBQUV2QyxFQUFFLEdBQUdBLEtBQUt1QyxFQUFFdkMsRUFBRTtJQUM1QnVDLEVBQUV0QyxFQUFFLEdBQUdBLEtBQUtzQyxFQUFFdEMsRUFBRSxHQUFHQSxLQUFLc0MsRUFBRXRDLEVBQUU7SUFDNUJzQyxFQUFFNFcsQ0FBQyxHQUFHNVcsRUFBRXhDLEVBQUUsR0FBR3dDLEVBQUV6QyxFQUFFO0lBQ2pCeUMsRUFBRWdCLENBQUMsR0FBR2hCLEVBQUV0QyxFQUFFLEdBQUdzQyxFQUFFdkMsRUFBRTtBQUNuQjtBQUNBLElBQUkrakUsc0JBQXNCLFNBQVNBLG9CQUFvQnhoRSxDQUFDLEVBQUV5aEUsRUFBRTtJQUMxRCxJQUFJQSxNQUFNLE1BQU07UUFDZCxPQUFPemhFO0lBQ1Q7SUFDQSxPQUFPdWhFLGFBQWF2aEUsR0FBR3loRSxHQUFHbGtFLEVBQUUsRUFBRWtrRSxHQUFHaGtFLEVBQUUsRUFBRWdrRSxHQUFHamtFLEVBQUUsRUFBRWlrRSxHQUFHL2pFLEVBQUU7QUFDbkQ7QUFDQSxJQUFJZ2tFLG1CQUFtQixTQUFTQSxpQkFBaUI5bEUsR0FBRyxFQUFFd3ZELEtBQUssRUFBRWpzRCxNQUFNO0lBQ2pFLE9BQU9vYSxvQkFBb0IzZCxLQUFLd3ZELE9BQU9qc0Q7QUFDekM7QUFDQSxJQUFJd2lFLHdCQUF3QixTQUFTQSxzQkFBc0JDLE1BQU0sRUFBRTNvRCxHQUFHLEVBQUU5WixNQUFNO0lBQzVFLElBQUk4WixJQUFJaUMsRUFBRSxHQUFHMm1ELFFBQVEsSUFBSTtRQUN2QjtJQUNGO0lBQ0EsSUFBSXBtRCxLQUFLeEMsSUFBSW5jLFFBQVE7SUFDckIsSUFBSW1mLFNBQVNSLEdBQUdRLE1BQU07SUFDdEIsSUFBSTZsRCxVQUFVN2xELE9BQU84bEQsVUFBVSxHQUFHO0lBQ2xDLElBQUlDLFlBQVkvb0QsSUFBSTRtRCxNQUFNLENBQUMxZ0UsU0FBUyxnQkFBZ0I1RixLQUFLO0lBQ3pELElBQUkwUztJQUNKLElBQUl5SjtJQUNKLElBQUlzc0QsY0FBYyxRQUFRO1FBQ3hCLElBQUk3aUUsV0FBVyxVQUFVO1lBQ3ZCOE0sSUFBSWdRLE9BQU9nbUQsSUFBSTtZQUNmdnNELElBQUl1RyxPQUFPaW1ELElBQUk7UUFDakIsT0FBTyxJQUFJL2lFLFdBQVcsVUFBVTtZQUM5QjhNLElBQUlnUSxPQUFPa21ELElBQUk7WUFDZnpzRCxJQUFJdUcsT0FBT21tRCxJQUFJO1FBQ2pCLE9BQU87WUFDTG4yRCxJQUFJZ1EsT0FBT29tRCxJQUFJO1lBQ2Yzc0QsSUFBSXVHLE9BQU9xbUQsSUFBSTtRQUNqQjtRQUVBLDJDQUEyQztRQUMzQyxJQUFJQyxNQUFNOW1ELEdBQUdzQyxXQUFXLEdBQUd0QyxHQUFHc0MsV0FBVyxJQUFJLENBQUM7UUFDOUMsSUFBSW9VLEtBQUtvd0MsR0FBRyxDQUFDcGpFLE9BQU8sR0FBR29qRSxHQUFHLENBQUNwakUsT0FBTyxJQUFJLENBQUM7UUFDdkNnekIsR0FBRzUwQixFQUFFLEdBQUcwTyxJQUFJNjFEO1FBQ1ozdkMsR0FBRzEwQixFQUFFLEdBQUdpWSxJQUFJb3NEO1FBQ1ozdkMsR0FBRzMwQixFQUFFLEdBQUd5TyxJQUFJNjFEO1FBQ1ozdkMsR0FBR3owQixFQUFFLEdBQUdnWSxJQUFJb3NEO1FBQ1ozdkMsR0FBR3ZiLENBQUMsR0FBR3ViLEdBQUczMEIsRUFBRSxHQUFHMjBCLEdBQUc1MEIsRUFBRTtRQUNwQjQwQixHQUFHbnhCLENBQUMsR0FBR214QixHQUFHejBCLEVBQUUsR0FBR3kwQixHQUFHMTBCLEVBQUU7UUFDcEJpMUIsa0JBQWtCUCxJQUFJO1FBQ3RCb3ZDLGFBQWFLLFFBQVF6dkMsR0FBRzUwQixFQUFFLEVBQUU0MEIsR0FBRzEwQixFQUFFLEVBQUUwMEIsR0FBRzMwQixFQUFFLEVBQUUyMEIsR0FBR3owQixFQUFFO0lBQ2pEO0FBQ0Y7QUFDQSxJQUFJOGtFLHdCQUF3QixTQUFTQSxzQkFBc0JaLE1BQU0sRUFBRTNvRCxHQUFHLEVBQUU5WixNQUFNO0lBQzVFLElBQUk4WixJQUFJaUMsRUFBRSxHQUFHMm1ELFFBQVEsSUFBSTtRQUN2QjtJQUNGO0lBQ0EsSUFBSVk7SUFDSixJQUFJdGpFLFFBQVE7UUFDVnNqRSxhQUFhdGpFLFNBQVM7SUFDeEIsT0FBTztRQUNMc2pFLGFBQWE7SUFDZjtJQUNBLElBQUlobkQsS0FBS3hDLElBQUluYyxRQUFRO0lBQ3JCLElBQUltZixTQUFTUixHQUFHUSxNQUFNO0lBQ3RCLElBQUl5bUQsUUFBUXpwRCxJQUFJNG1ELE1BQU0sQ0FBQzRDLGFBQWEsU0FBU0UsUUFBUTtJQUNyRCxJQUFJRCxPQUFPO1FBQ1QsSUFBSUUsU0FBUzNwRCxJQUFJNG1ELE1BQU0sQ0FBQztRQUN4QixJQUFJZ0QsU0FBUzVwRCxJQUFJNG1ELE1BQU0sQ0FBQztRQUN4QixJQUFJaUQsYUFBYXBCLGlCQUFpQnpsRCxRQUFRLGNBQWM5YztRQUN4RCxJQUFJNGpFLGNBQWNyQixpQkFBaUJ6bEQsUUFBUSxlQUFlOWM7UUFDMUQsSUFBSTZqRSxTQUFTdEIsaUJBQWlCemxELFFBQVEsVUFBVTljO1FBQ2hELElBQUk4akUsU0FBU3ZCLGlCQUFpQnpsRCxRQUFRLFVBQVU5YztRQUNoRCxJQUFJK2pFLFVBQVVqcUQsSUFBSTRtRCxNQUFNLENBQUM0QyxhQUFhLGlCQUFpQjNDLE9BQU87UUFDOUQsSUFBSXFELFVBQVVscUQsSUFBSTRtRCxNQUFNLENBQUM0QyxhQUFhLGlCQUFpQjNDLE9BQU87UUFDOUQsSUFBSTFzQixTQUFTbjZCLElBQUltNkIsTUFBTTtRQUN2QixJQUFJZ3dCLFdBQVducUQsSUFBSTRtRCxNQUFNLENBQUM0QyxhQUFhO1FBQ3ZDLElBQUlZLGVBQWVwcUQsSUFBSTRtRCxNQUFNLENBQUMsc0JBQXNCQyxPQUFPO1FBQzNELElBQUl3RCxjQUFjcnFELElBQUk0bUQsTUFBTSxDQUFDLHFCQUFxQkMsT0FBTztRQUN6RCxJQUFJeUQsa0JBQWtCRCxjQUFjO1FBQ3BDLElBQUkzd0MsVUFBVTFaLElBQUk0bUQsTUFBTSxDQUFDLDJCQUEyQkMsT0FBTztRQUMzRCxJQUFJMEQsZ0JBQWdCLEdBQUcsdURBQXVEO1FBRTlFLElBQUlDLEtBQUtWO1FBQ1QsSUFBSVcsS0FBS1o7UUFDVCxJQUFJYSxPQUFPRCxLQUFLO1FBQ2hCLElBQUlFLE9BQU9ILEtBQUs7UUFDaEIsSUFBSS9yQyxLQUFLRSxLQUFLRCxLQUFLRTtRQUNuQixJQUFJdWIsUUFBUTtZQUNWMWIsTUFBTXNyQyxTQUFTVztZQUNmL3JDLE1BQU1vckMsU0FBU1c7WUFDZmhzQyxNQUFNc3JDLFNBQVNXO1lBQ2YvckMsTUFBTW9yQyxTQUFTVztRQUNqQixPQUFPO1lBQ0wsT0FBUWhCLE9BQU9ycEUsS0FBSztnQkFDbEIsS0FBSztvQkFDSG0rQixNQUFNc3JDLFNBQVNVO29CQUNmOXJDLE1BQU1vckM7b0JBQ047Z0JBQ0YsS0FBSztvQkFDSHRyQyxNQUFNc3JDLFNBQVNXO29CQUNmL3JDLE1BQU1vckMsU0FBU1c7b0JBQ2Y7Z0JBQ0YsS0FBSztvQkFDSGpzQyxNQUFNc3JDO29CQUNOcHJDLE1BQU1vckMsU0FBU1U7b0JBQ2Y7WUFDSjtZQUNBLE9BQVFiLE9BQU90cEUsS0FBSztnQkFDbEIsS0FBSztvQkFDSG8rQixNQUFNc3JDLFNBQVNRO29CQUNmNXJDLE1BQU1vckM7b0JBQ047Z0JBQ0YsS0FBSztvQkFDSHRyQyxNQUFNc3JDLFNBQVNXO29CQUNmL3JDLE1BQU1vckMsU0FBU1c7b0JBQ2Y7Z0JBQ0YsS0FBSztvQkFDSGpzQyxNQUFNc3JDO29CQUNOcHJDLE1BQU1vckMsU0FBU1E7b0JBQ2Y7WUFDSjtRQUNGO1FBRUEsbURBQW1EO1FBQ25ELElBQUlJLFVBQVVYLFVBQVV6bUUsS0FBSzZVLEdBQUcsQ0FBQyt4RCxjQUFjRSxtQkFBbUI1d0MsVUFBVTZ3QztRQUM1RSxJQUFJTSxXQUFXWixVQUFVem1FLEtBQUs2VSxHQUFHLENBQUMreEQsY0FBY0UsbUJBQW1CNXdDLFVBQVU2d0M7UUFDN0UsSUFBSU8sU0FBU1osVUFBVTFtRSxLQUFLNlUsR0FBRyxDQUFDK3hELGNBQWNFLG1CQUFtQjV3QyxVQUFVNndDO1FBQzNFLElBQUlRLFNBQVNiLFVBQVUxbUUsS0FBSzZVLEdBQUcsQ0FBQyt4RCxjQUFjRSxtQkFBbUI1d0MsVUFBVTZ3QztRQUMzRTlyQyxPQUFPbXNDO1FBQ1Bqc0MsT0FBT2tzQztRQUNQbnNDLE9BQU9vc0M7UUFDUGxzQyxPQUFPbXNDO1FBRVAscURBQXFEO1FBQ3JELElBQUlDLFdBQVc5a0UsVUFBVTtRQUN6QixJQUFJb2pFLE1BQU05bUQsR0FBR21DLFdBQVc7UUFDeEIsSUFBSXVVLEtBQUtvd0MsR0FBRyxDQUFDMEIsU0FBUyxHQUFHMUIsR0FBRyxDQUFDMEIsU0FBUyxJQUFJLENBQUM7UUFDM0M5eEMsR0FBRzUwQixFQUFFLEdBQUdtNkI7UUFDUnZGLEdBQUcxMEIsRUFBRSxHQUFHazZCO1FBQ1J4RixHQUFHMzBCLEVBQUUsR0FBR282QjtRQUNSekYsR0FBR3owQixFQUFFLEdBQUdtNkI7UUFDUjFGLEdBQUd2YixDQUFDLEdBQUdnaEIsTUFBTUY7UUFDYnZGLEdBQUdueEIsQ0FBQyxHQUFHNjJCLE1BQU1GO1FBQ2J4RixHQUFHMHhDLE9BQU8sR0FBR0E7UUFDYjF4QyxHQUFHMnhDLFFBQVEsR0FBR0E7UUFDZDN4QyxHQUFHNHhDLE1BQU0sR0FBR0E7UUFDWjV4QyxHQUFHNnhDLE1BQU0sR0FBR0E7UUFDWixJQUFJRSxlQUFlOXdCLFVBQVVnd0IsU0FBU1QsUUFBUSxLQUFLO1FBQ25ELElBQUl3QixZQUFZZixTQUFTdEQsT0FBTyxJQUFJLFFBQVFzRCxTQUFTdEQsT0FBTyxLQUFLO1FBQ2pFLElBQUlvRSxnQkFBZ0JDLFdBQVc7WUFDN0IsSUFBSUMsUUFBUUYsZUFBZXhDLGlCQUFpQmptRCxHQUFHUSxNQUFNLEVBQUUsY0FBYzljLFVBQVVpa0UsU0FBU3RELE9BQU87WUFDL0YsSUFBSTdwRCxNQUFNeFosS0FBS3daLEdBQUcsQ0FBQ211RDtZQUNuQixJQUFJbHVELE1BQU16WixLQUFLeVosR0FBRyxDQUFDa3VEO1lBRW5CLG1EQUFtRDtZQUNuRCxJQUFJQyxLQUFLLENBQUMzc0MsTUFBTUUsR0FBRSxJQUFLO1lBQ3ZCLElBQUkwc0MsS0FBSyxDQUFDM3NDLE1BQU1FLEdBQUUsSUFBSztZQUN2QixJQUFJLENBQUN1YixRQUFRO2dCQUNYLE9BQVF3dkIsT0FBT3JwRSxLQUFLO29CQUNsQixLQUFLO3dCQUNIOHFFLEtBQUt6c0M7d0JBQ0w7b0JBQ0YsS0FBSzt3QkFDSHlzQyxLQUFLM3NDO3dCQUNMO2dCQUNKO2dCQUNBLE9BQVFtckMsT0FBT3RwRSxLQUFLO29CQUNsQixLQUFLO3dCQUNIK3FFLEtBQUt6c0M7d0JBQ0w7b0JBQ0YsS0FBSzt3QkFDSHlzQyxLQUFLM3NDO3dCQUNMO2dCQUNKO1lBQ0Y7WUFDQSxJQUFJNHNDLFNBQVMsU0FBU0EsT0FBT3Q0RCxDQUFDLEVBQUV5SixDQUFDO2dCQUMvQnpKLElBQUlBLElBQUlvNEQ7Z0JBQ1IzdUQsSUFBSUEsSUFBSTR1RDtnQkFDUixPQUFPO29CQUNMcjRELEdBQUdBLElBQUlnSyxNQUFNUCxJQUFJUSxNQUFNbXVEO29CQUN2QjN1RCxHQUFHekosSUFBSWlLLE1BQU1SLElBQUlPLE1BQU1xdUQ7Z0JBQ3pCO1lBQ0Y7WUFDQSxJQUFJRSxRQUFRRCxPQUFPN3NDLEtBQUtDO1lBQ3hCLElBQUk4c0MsUUFBUUYsT0FBTzdzQyxLQUFLRztZQUN4QixJQUFJNnNDLFFBQVFILE9BQU8zc0MsS0FBS0Q7WUFDeEIsSUFBSWd0QyxRQUFRSixPQUFPM3NDLEtBQUtDO1lBQ3hCSCxNQUFNajdCLEtBQUsrVSxHQUFHLENBQUNnekQsTUFBTXY0RCxDQUFDLEVBQUV3NEQsTUFBTXg0RCxDQUFDLEVBQUV5NEQsTUFBTXo0RCxDQUFDLEVBQUUwNEQsTUFBTTE0RCxDQUFDO1lBQ2pEMnJCLE1BQU1uN0IsS0FBSzZVLEdBQUcsQ0FBQ2t6RCxNQUFNdjRELENBQUMsRUFBRXc0RCxNQUFNeDRELENBQUMsRUFBRXk0RCxNQUFNejRELENBQUMsRUFBRTA0RCxNQUFNMTRELENBQUM7WUFDakQwckIsTUFBTWw3QixLQUFLK1UsR0FBRyxDQUFDZ3pELE1BQU05dUQsQ0FBQyxFQUFFK3VELE1BQU0vdUQsQ0FBQyxFQUFFZ3ZELE1BQU1odkQsQ0FBQyxFQUFFaXZELE1BQU1qdkQsQ0FBQztZQUNqRG1pQixNQUFNcDdCLEtBQUs2VSxHQUFHLENBQUNrekQsTUFBTTl1RCxDQUFDLEVBQUUrdUQsTUFBTS91RCxDQUFDLEVBQUVndkQsTUFBTWh2RCxDQUFDLEVBQUVpdkQsTUFBTWp2RCxDQUFDO1FBQ25EO1FBQ0EsSUFBSWt2RCxjQUFjWCxXQUFXO1FBQzdCLElBQUlZLFFBQVF0QyxHQUFHLENBQUNxQyxZQUFZLEdBQUdyQyxHQUFHLENBQUNxQyxZQUFZLElBQUksQ0FBQztRQUNwREMsTUFBTXRuRSxFQUFFLEdBQUdtNkI7UUFDWG10QyxNQUFNcG5FLEVBQUUsR0FBR2s2QjtRQUNYa3RDLE1BQU1ybkUsRUFBRSxHQUFHbzZCO1FBQ1hpdEMsTUFBTW5uRSxFQUFFLEdBQUdtNkI7UUFDWGd0QyxNQUFNanVELENBQUMsR0FBR2doQixNQUFNRjtRQUNoQm10QyxNQUFNN2pFLENBQUMsR0FBRzYyQixNQUFNRjtRQUNoQjRwQyxhQUFhSyxRQUFRbHFDLEtBQUtDLEtBQUtDLEtBQUtDO1FBQ3BDMHBDLGFBQWE5bEQsR0FBR21DLFdBQVcsQ0FBQ0MsR0FBRyxFQUFFNlosS0FBS0MsS0FBS0MsS0FBS0M7SUFDbEQ7SUFDQSxPQUFPK3BDO0FBQ1Q7QUFDQSxJQUFJa0QsMEJBQTBCLFNBQVNBLHdCQUF3QmxELE1BQU0sRUFBRTNvRCxHQUFHO0lBQ3hFLElBQUlBLElBQUlpQyxFQUFFLEdBQUcybUQsUUFBUSxJQUFJO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJa0QsaUJBQWlCOXJELElBQUk0bUQsTUFBTSxDQUFDLG1CQUFtQnRtRSxLQUFLO0lBQ3hELElBQUk4cEUsZUFBZXBxRCxJQUFJNG1ELE1BQU0sQ0FBQyxpQkFBaUJ0bUUsS0FBSztJQUNwRCxJQUFJeXJFLGdCQUFnQi9yRCxJQUFJNG1ELE1BQU0sQ0FBQyxrQkFBa0J0bUUsS0FBSztJQUN0RCxJQUFJMHJFLFlBQVk1QixlQUFlMkI7SUFDL0JFLHNCQUFzQnRELFFBQVEzb0QsS0FBSzhyRCxnQkFBZ0JFLFdBQVcsV0FBV0EsWUFBWTtBQUN2RjtBQUNBLElBQUlDLHdCQUF3QixTQUFTQSxzQkFBc0J0RCxNQUFNLEVBQUUzb0QsR0FBRyxFQUFFa3NELE9BQU8sRUFBRUMsYUFBYSxFQUFFQyxpQkFBaUIsRUFBRUMsZ0JBQWdCO0lBQ2pJLElBQUlILFlBQVksS0FBS0MsaUJBQWlCLEtBQUtDLHNCQUFzQixVQUFVO1FBQ3pFO0lBQ0Y7SUFDQSxJQUFJbnFELEtBQUtqQyxJQUFJaUMsRUFBRTtJQUNmLElBQUlxcUQsUUFBUXRzRCxJQUFJNG1ELE1BQU0sQ0FBQyxTQUFTdG1FLEtBQUs7SUFDckMsSUFBSWlzRSxTQUFTdHFELEdBQUd1cUQsUUFBUSxHQUFHQyxVQUFVLENBQUNILE1BQU07SUFDNUMsSUFBSUksZ0JBQWdCMXNELElBQUl5QyxRQUFRLElBQzlCelAsSUFBSTA1RCxjQUFjMTVELENBQUMsRUFDbkJ5SixJQUFJaXdELGNBQWNqd0QsQ0FBQztJQUNyQixJQUFJa0IsSUFBSXFDLElBQUk0YixLQUFLO0lBQ2pCLElBQUk3ekIsSUFBSWlZLElBQUk2YixNQUFNO0lBQ2xCLElBQUkwd0MsT0FBT0ksY0FBYyxFQUFFO1FBQ3pCLElBQUlQLHNCQUFzQixVQUFVO1lBQ2xDRCxpQkFBaUI7UUFDbkI7UUFDQSxJQUFJUyxNQUFNTCxPQUFPTSxXQUFXLENBQUM3NUQsR0FBR3lKLEdBQUdrQixHQUFHNVYsR0FBR29rRTtRQUN6QzVELG9CQUFvQkksUUFBUWlFO0lBQzlCLE9BQU8sSUFBSVAsb0JBQW9CLFFBQVFBLG1CQUFtQixHQUFHO1FBQzNEMXlDLHVCQUF1Qmd2QyxRQUFRO1lBQUMwRDtZQUFrQkE7WUFBa0JBO1lBQWtCQTtTQUFpQjtJQUN6RztBQUNGO0FBQ0EsSUFBSVMsOEJBQThCLFNBQVNBLDRCQUE0Qm5FLE1BQU0sRUFBRTNvRCxHQUFHO0lBQ2hGLElBQUlBLElBQUlpQyxFQUFFLEdBQUcybUQsUUFBUSxJQUFJO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJbUUsZ0JBQWdCL3NELElBQUk0bUQsTUFBTSxDQUFDLGtCQUFrQnRtRSxLQUFLO0lBQ3RELElBQUkrcEUsY0FBY3JxRCxJQUFJNG1ELE1BQU0sQ0FBQyxnQkFBZ0JDLE9BQU87SUFDcEQsSUFBSW1HLGlCQUFpQmh0RCxJQUFJNG1ELE1BQU0sQ0FBQyxtQkFBbUJ0bUUsS0FBSztJQUN4RDJyRSxzQkFBc0J0RCxRQUFRM29ELEtBQUsrc0QsZUFBZTFDLGFBQWEyQztBQUNqRTtBQUVBLCtEQUErRDtBQUMvRCxJQUFJQyxrQkFBa0IsU0FBU0EsZ0JBQWdCanRELEdBQUcsRUFBRXhOLE9BQU87SUFDekQsSUFBSXlQLEtBQUtqQyxJQUFJbmMsUUFBUSxDQUFDb2UsRUFBRTtJQUN4QixJQUFJcy9CLGVBQWV0L0IsR0FBR3MvQixZQUFZO0lBQ2xDLElBQUlxbkIsV0FBVzNtRCxHQUFHMm1ELFFBQVE7SUFDMUIsSUFBSUQsU0FBUzF2QztJQUNiLElBQUl6VyxLQUFLeEMsSUFBSW5jLFFBQVE7SUFDckIsSUFBSXVnQixTQUFTcEUsSUFBSW9FLE1BQU07SUFDdkIsSUFBSSsxQixTQUFTbjZCLElBQUltNkIsTUFBTTtJQUN2QixJQUFJK3lCLEtBQUtDLEtBQUtDLEtBQUtDLEtBQUssMEJBQTBCO0lBQ2xELElBQUlyNkQsR0FBR3lKLEdBQUcsV0FBVztJQUNyQixJQUFJdUcsU0FBU1IsR0FBR1EsTUFBTTtJQUN0QixJQUFJc3FELGtCQUFrQmxwRCxVQUFVbTlCLGVBQWV2aEMsSUFBSTRtRCxNQUFNLENBQUMsb0JBQW9CQyxPQUFPLEdBQUc7UUFBQztLQUFFO0lBRTNGLCtFQUErRTtJQUMvRSxxRkFBcUY7SUFDckYsSUFBSTBHLGNBQWMsU0FBU0EsWUFBWXZ0RCxHQUFHO1FBQ3hDLE9BQU9BLElBQUk0bUQsTUFBTSxDQUFDLFdBQVd0bUUsS0FBSyxLQUFLO0lBQ3pDO0lBQ0EsSUFBSWt0RSxZQUFZLENBQUNqc0IsZ0JBQWdCZ3NCLFlBQVl2dEQsUUFHekMsRUFBQ202QixVQUFVb3pCLFlBQVl2dEQsSUFBSXNDLE1BQU0sT0FBT2lyRCxZQUFZdnRELElBQUl1QyxNQUFNLEdBQUU7SUFDcEUsSUFBSWlyRCxXQUFXO1FBQ2IsK0RBQStEO1FBQy9ELElBQUlDLGlCQUFpQjtRQUNyQixJQUFJQyxpQkFBaUI7UUFDckIsSUFBSW5zQixnQkFBZ0IvdUMsUUFBUXMwRCxlQUFlLEVBQUU7WUFDM0MyRyxpQkFBaUJ6dEQsSUFBSTRtRCxNQUFNLENBQUMsbUJBQW1CdG1FLEtBQUs7WUFDcEQsSUFBSW10RSxtQkFBbUIsR0FBRztnQkFDeEJDLGlCQUFpQjF0RCxJQUFJNG1ELE1BQU0sQ0FBQyxtQkFBbUJ0bUUsS0FBSztZQUN0RDtRQUNGO1FBQ0EsSUFBSXF0RSxrQkFBa0I7UUFDdEIsSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUlyc0IsZ0JBQWdCL3VDLFFBQVFxN0QsZ0JBQWdCLEVBQUU7WUFDNUNGLGtCQUFrQjN0RCxJQUFJNG1ELE1BQU0sQ0FBQyxvQkFBb0J0bUUsS0FBSztZQUN0RCxJQUFJcXRFLG9CQUFvQixHQUFHO2dCQUN6QkMsa0JBQWtCNXRELElBQUk0bUQsTUFBTSxDQUFDLG9CQUFvQnRtRSxLQUFLO1lBQ3hEO1FBQ0Y7UUFDQSxJQUFJbzVCLFVBQVVsMkIsS0FBSzZVLEdBQUcsQ0FBQ3ExRCxnQkFBZ0JFO1FBQ3ZDLElBQUlqd0QsSUFBSTtRQUNSLElBQUltd0QsUUFBUTtRQUNaLElBQUl2c0IsY0FBYztZQUNoQjVqQyxJQUFJcUMsSUFBSTRtRCxNQUFNLENBQUMsU0FBU0MsT0FBTztZQUMvQmlILFFBQVFud0QsSUFBSTtRQUNkO1FBQ0EsSUFBSXlHLFVBQVU1UixRQUFRdTdELFlBQVksRUFBRTtZQUNsQyxJQUFJdHdELE1BQU11QyxJQUFJeUMsUUFBUTtZQUN0QnpQLElBQUl5SyxJQUFJekssQ0FBQztZQUNUeUosSUFBSWdCLElBQUloQixDQUFDO1lBQ1QsSUFBSXd4QixLQUFLanVCLElBQUlndUQsVUFBVTtZQUN2QixJQUFJM29DLFFBQVE0SSxLQUFLO1lBQ2pCLElBQUlsbUMsSUFBSWlZLElBQUlpdUQsV0FBVztZQUN2QixJQUFJM29DLFFBQVF2OUIsSUFBSTtZQUVoQix5QkFBeUI7WUFDekIseUJBQXlCO1lBRXpCbWxFLE1BQU1sNkQsSUFBSXF5QjtZQUNWOG5DLE1BQU1uNkQsSUFBSXF5QjtZQUNWK25DLE1BQU0zd0QsSUFBSTZvQjtZQUNWK25DLE1BQU01d0QsSUFBSTZvQjtZQUNWZ2pDLGFBQWFLLFFBQVF1RSxLQUFLRSxLQUFLRCxLQUFLRTtZQUNwQyxJQUFJOXJCLGNBQWM7Z0JBQ2hCc3FCLHdCQUF3QmxELFFBQVEzb0Q7WUFDbEM7WUFDQSxJQUFJdWhDLGdCQUFnQi91QyxRQUFRMDdELGVBQWUsSUFBSSxDQUFDdEYsVUFBVTtnQkFDeERpRCx3QkFBd0JsRCxRQUFRM29EO1lBQ2xDO1lBQ0EsSUFBSXVoQyxjQUFjO2dCQUNoQnVyQiw0QkFBNEJuRSxRQUFRM29EO1lBQ3RDO1FBQ0YsT0FBTyxJQUFJbTZCLFVBQVUzbkMsUUFBUTI3RCxZQUFZLEVBQUU7WUFDekMsSUFBSTVzQixnQkFBZ0IsQ0FBQ3FuQixVQUFVO2dCQUM3QixJQUFJd0YsYUFBYXB1RCxJQUFJNG1ELE1BQU0sQ0FBQyxlQUFlOEMsUUFBUTtnQkFFbkQsOENBQThDO2dCQUM5Qyw4Q0FBOEM7Z0JBRTlDd0QsTUFBTTFwRSxLQUFLK1UsR0FBRyxDQUFDeUssT0FBT2dtRCxJQUFJLEVBQUVobUQsT0FBT29tRCxJQUFJLEVBQUVwbUQsT0FBT2ttRCxJQUFJO2dCQUNwRGlFLE1BQU0zcEUsS0FBSzZVLEdBQUcsQ0FBQzJLLE9BQU9nbUQsSUFBSSxFQUFFaG1ELE9BQU9vbUQsSUFBSSxFQUFFcG1ELE9BQU9rbUQsSUFBSTtnQkFDcERrRSxNQUFNNXBFLEtBQUsrVSxHQUFHLENBQUN5SyxPQUFPaW1ELElBQUksRUFBRWptRCxPQUFPcW1ELElBQUksRUFBRXJtRCxPQUFPbW1ELElBQUk7Z0JBQ3BEa0UsTUFBTTdwRSxLQUFLNlUsR0FBRyxDQUFDMkssT0FBT2ltRCxJQUFJLEVBQUVqbUQsT0FBT3FtRCxJQUFJLEVBQUVybUQsT0FBT21tRCxJQUFJO2dCQUVwRCwrQkFBK0I7Z0JBQy9CK0QsT0FBT1k7Z0JBQ1BYLE9BQU9XO2dCQUNQVixPQUFPVTtnQkFDUFQsT0FBT1M7Z0JBQ1B4RixhQUFhSyxRQUFRdUUsS0FBS0UsS0FBS0QsS0FBS0U7Z0JBRXBDLGdCQUFnQjtnQkFDaEIsZ0JBQWdCO2dCQUVoQixJQUFJZSxlQUFlLFlBQVk7b0JBQzdCLElBQUlDLE9BQU9yckQsT0FBT3NyRCxXQUFXO29CQUM3QixJQUFJRCxRQUFRQSxLQUFLM3ZFLE1BQU0sS0FBSyxHQUFHO3dCQUM3Qnd1RSxNQUFNbUIsSUFBSSxDQUFDLEVBQUUsQ0FBQ3I3RCxDQUFDO3dCQUNmbzZELE1BQU1pQixJQUFJLENBQUMsRUFBRSxDQUFDNXhELENBQUM7d0JBQ2Ywd0QsTUFBTWtCLElBQUksQ0FBQyxFQUFFLENBQUNyN0QsQ0FBQzt3QkFDZnE2RCxNQUFNZ0IsSUFBSSxDQUFDLEVBQUUsQ0FBQzV4RCxDQUFDO3dCQUNmLElBQUl5d0QsTUFBTUMsS0FBSzs0QkFDYixJQUFJbmpDLE9BQU9rakM7NEJBQ1hBLE1BQU1DOzRCQUNOQSxNQUFNbmpDO3dCQUNSO3dCQUNBLElBQUlvakMsTUFBTUMsS0FBSzs0QkFDYixJQUFJa0IsUUFBUW5COzRCQUNaQSxNQUFNQzs0QkFDTkEsTUFBTWtCO3dCQUNSO3dCQUNBakcsYUFBYUssUUFBUXVFLE1BQU1ZLE9BQU9WLE1BQU1VLE9BQU9YLE1BQU1XLE9BQU9ULE1BQU1TO29CQUNwRTtnQkFDRixPQUFPLElBQUlNLGVBQWUsWUFBWUEsZUFBZSxzQkFBc0I5bkUsU0FBUzhuRSxZQUFZLGVBQWU5bkUsU0FBUzhuRSxZQUFZLFNBQVM7b0JBQzNJLElBQUl0ekM7b0JBQ0osT0FBUXN6Qzt3QkFDTixLQUFLO3dCQUNMLEtBQUs7NEJBQ0h0ekMsTUFBTTlYLE9BQU93ckQsU0FBUzs0QkFDdEI7d0JBQ0YsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzs0QkFDSDF6QyxNQUFNOVgsT0FBT3lyRCxPQUFPOzRCQUNwQjtvQkFDSjtvQkFDQSxJQUFJM3pDLE9BQU8sTUFBTTt3QkFDZixJQUFLLElBQUl4ekIsSUFBSSxHQUFHQSxJQUFJd3pCLElBQUlwOEIsTUFBTSxFQUFFNEksSUFBSzs0QkFDbkMsSUFBSTh5QixLQUFLVSxHQUFHLENBQUN4ekIsRUFBRTs0QkFDZjRsRSxNQUFNOXlDLEdBQUdwbkIsQ0FBQyxHQUFHODZEOzRCQUNiWCxNQUFNL3lDLEdBQUdwbkIsQ0FBQyxHQUFHODZEOzRCQUNiVixNQUFNaHpDLEdBQUczZCxDQUFDLEdBQUdxeEQ7NEJBQ2JULE1BQU1qekMsR0FBRzNkLENBQUMsR0FBR3F4RDs0QkFDYnhGLGFBQWFLLFFBQVF1RSxLQUFLRSxLQUFLRCxLQUFLRTt3QkFDdEM7b0JBQ0Y7Z0JBQ0YsRUFBRSxtQ0FBbUM7WUFDdkMsT0FBTztnQkFDTCw2QkFBNkI7Z0JBRTdCLDBDQUEwQztnQkFDMUMsMENBQTBDO2dCQUUxQyxJQUFJMTNCLEtBQUszMUIsSUFBSXNDLE1BQU07Z0JBQ25CLElBQUlvc0QsUUFBUS80QixHQUFHbHpCLFFBQVE7Z0JBQ3ZCLElBQUlxdEIsS0FBSzl2QixJQUFJdUMsTUFBTTtnQkFDbkIsSUFBSW9zRCxRQUFRNytCLEdBQUdydEIsUUFBUTtnQkFDdkJ5cUQsTUFBTXdCLE1BQU0xN0QsQ0FBQztnQkFDYm02RCxNQUFNd0IsTUFBTTM3RCxDQUFDO2dCQUNibzZELE1BQU1zQixNQUFNanlELENBQUM7Z0JBQ2I0d0QsTUFBTXNCLE1BQU1seUQsQ0FBQztnQkFDYixJQUFJeXdELE1BQU1DLEtBQUs7b0JBQ2IsSUFBSXlCLFNBQVMxQjtvQkFDYkEsTUFBTUM7b0JBQ05BLE1BQU15QjtnQkFDUjtnQkFDQSxJQUFJeEIsTUFBTUMsS0FBSztvQkFDYixJQUFJd0IsU0FBU3pCO29CQUNiQSxNQUFNQztvQkFDTkEsTUFBTXdCO2dCQUNSO2dCQUVBLCtCQUErQjtnQkFDL0IzQixPQUFPWTtnQkFDUFgsT0FBT1c7Z0JBQ1BWLE9BQU9VO2dCQUNQVCxPQUFPUztnQkFDUHhGLGFBQWFLLFFBQVF1RSxLQUFLRSxLQUFLRCxLQUFLRTtZQUN0QyxFQUFFLDZCQUE2QjtRQUNqQyxFQUFFLFFBQVE7UUFFVix5QkFBeUI7UUFDekIseUJBQXlCO1FBRXpCLElBQUk5ckIsZ0JBQWdCL3VDLFFBQVEyN0QsWUFBWSxJQUFJaDBCLFFBQVE7WUFDbER1dUIsc0JBQXNCQyxRQUFRM29ELEtBQUs7WUFDbkMwb0Qsc0JBQXNCQyxRQUFRM29ELEtBQUs7WUFDbkMwb0Qsc0JBQXNCQyxRQUFRM29ELEtBQUs7WUFDbkMwb0Qsc0JBQXNCQyxRQUFRM29ELEtBQUs7UUFDckM7UUFFQSxRQUFRO1FBQ1IsUUFBUTtRQUVSLElBQUl1aEMsY0FBYztZQUNoQixJQUFJdXRCLFFBQVE5dUQsSUFBSTRtRCxNQUFNLENBQUMsU0FBU3RtRSxLQUFLLEtBQUs7WUFDMUMsSUFBSXd1RSxPQUFPO2dCQUNULElBQUlDLEtBQUsvdUQsSUFBSTRtRCxNQUFNLENBQUMsa0JBQWtCQyxPQUFPO2dCQUM3QyxJQUFJbUksS0FBS2h2RCxJQUFJNG1ELE1BQU0sQ0FBQyxrQkFBa0JDLE9BQU87Z0JBQzdDeUIsYUFBYUssUUFBUUEsT0FBT3JrRSxFQUFFLEdBQUd5cUUsSUFBSXBHLE9BQU9ua0UsRUFBRSxHQUFHd3FFLElBQUlyRyxPQUFPcGtFLEVBQUUsR0FBR3dxRSxJQUFJcEcsT0FBT2xrRSxFQUFFLEdBQUd1cUU7WUFDbkY7UUFDRjtRQUVBLDBEQUEwRDtRQUMxRCxJQUFJQyxTQUFTenNELEdBQUdpQyxVQUFVLEdBQUdqQyxHQUFHaUMsVUFBVSxJQUFJLENBQUM7UUFDL0N1VixrQkFBa0JpMUMsUUFBUXRHO1FBQzFCaHZDLHVCQUF1QnMxQyxRQUFRM0I7UUFDL0I3ekMsa0JBQWtCdzFDLFFBQVEsSUFBSSx1REFBdUQ7UUFFckYsVUFBVTtRQUNWLFVBQVU7UUFFVixJQUFJMXRCLGNBQWM7WUFDaEIyckIsTUFBTXZFLE9BQU9ya0UsRUFBRTtZQUNmNm9FLE1BQU14RSxPQUFPcGtFLEVBQUU7WUFDZjZvRSxNQUFNekUsT0FBT25rRSxFQUFFO1lBQ2Y2b0UsTUFBTTFFLE9BQU9sa0UsRUFBRTtZQUNmNmpFLGFBQWFLLFFBQVF1RSxNQUFNeHpDLFNBQVMwekMsTUFBTTF6QyxTQUFTeXpDLE1BQU16ekMsU0FBUzJ6QyxNQUFNM3pDO1FBQzFFO1FBRUEsMERBQTBEO1FBQzFELElBQUl3MUMsWUFBWTFzRCxHQUFHa0MsYUFBYSxHQUFHbEMsR0FBR2tDLGFBQWEsSUFBSSxDQUFDO1FBQ3hEc1Ysa0JBQWtCazFDLFdBQVd2RztRQUM3Qmh2Qyx1QkFBdUJ1MUMsV0FBVzVCO1FBQ2xDN3pDLGtCQUFrQnkxQyxXQUFXLElBQUksdURBQXVEO1FBRXhGLDBCQUEwQjtRQUMxQiwwQkFBMEI7UUFFMUIsSUFBSUMsV0FBVzNzRCxHQUFHbUMsV0FBVyxHQUFHbkMsR0FBR21DLFdBQVcsSUFBSSxDQUFDO1FBQ25ELElBQUl3cUQsU0FBU3ZxRCxHQUFHLElBQUksTUFBTTtZQUN4QndVLGlCQUFpQisxQyxTQUFTdnFELEdBQUc7UUFDL0IsT0FBTztZQUNMdXFELFNBQVN2cUQsR0FBRyxHQUFHcVU7UUFDakI7UUFDQSxJQUFJc29CLGdCQUFnQi91QyxRQUFRbTBELGFBQWEsRUFBRTtZQUN6QyxJQUFJbjBELFFBQVE0OEQsaUJBQWlCLEVBQUU7Z0JBQzdCN0Ysc0JBQXNCWixRQUFRM29ELEtBQUs7WUFDckM7WUFDQSxJQUFJbTZCLFFBQVE7Z0JBQ1YsSUFBSTNuQyxRQUFRNjhELG1CQUFtQixFQUFFO29CQUMvQjlGLHNCQUFzQlosUUFBUTNvRCxLQUFLO2dCQUNyQztnQkFDQSxJQUFJeE4sUUFBUTg4RCxtQkFBbUIsRUFBRTtvQkFDL0IvRixzQkFBc0JaLFFBQVEzb0QsS0FBSztnQkFDckM7WUFDRjtRQUNGLEVBQUUsMkJBQTJCO0lBQy9CLEVBQUUsZUFBZTtJQUVqQjJvRCxPQUFPcmtFLEVBQUUsR0FBRytqRSxPQUFPTSxPQUFPcmtFLEVBQUU7SUFDNUJxa0UsT0FBT25rRSxFQUFFLEdBQUc2akUsT0FBT00sT0FBT25rRSxFQUFFO0lBQzVCbWtFLE9BQU9wa0UsRUFBRSxHQUFHOGpFLE9BQU9NLE9BQU9wa0UsRUFBRTtJQUM1Qm9rRSxPQUFPbGtFLEVBQUUsR0FBRzRqRSxPQUFPTSxPQUFPbGtFLEVBQUU7SUFDNUJra0UsT0FBT2hyRCxDQUFDLEdBQUcwcUQsT0FBT00sT0FBT3BrRSxFQUFFLEdBQUdva0UsT0FBT3JrRSxFQUFFO0lBQ3ZDcWtFLE9BQU81Z0UsQ0FBQyxHQUFHc2dFLE9BQU9NLE9BQU9sa0UsRUFBRSxHQUFHa2tFLE9BQU9ua0UsRUFBRTtJQUN2QyxJQUFJbWtFLE9BQU9ockQsQ0FBQyxHQUFHLEtBQUtnckQsT0FBTzVnRSxDQUFDLEdBQUcsS0FBS3lsRSxXQUFXO1FBQzdDN3pDLHVCQUF1Qmd2QyxRQUFRMkU7UUFFL0IsbUdBQW1HO1FBQ25HN3pDLGtCQUFrQmt2QyxRQUFRO0lBQzVCO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLElBQUk0RyxTQUFTLFNBQVNBLE9BQU8zdkQsSUFBSTtJQUMvQixJQUFJM2UsSUFBSTtJQUNSLElBQUl1dUUsS0FBSyxTQUFTQSxHQUFHNXVELEdBQUc7UUFDdEIsT0FBTyxDQUFDQSxNQUFNLElBQUksTUFBTTNmO0lBQzFCO0lBQ0EsSUFBSXJCLE1BQU07SUFDVkEsT0FBTzR2RSxHQUFHNXZELEtBQUs2dkQsV0FBVztJQUMxQjd2RSxPQUFPNHZFLEdBQUc1dkQsS0FBS3V1RCxZQUFZO0lBQzNCdnVFLE9BQU80dkUsR0FBRzV2RCxLQUFLK21ELGFBQWE7SUFDNUIvbUUsT0FBTzR2RSxHQUFHNXZELEtBQUt3dkQsaUJBQWlCO0lBQ2hDeHZFLE9BQU80dkUsR0FBRzV2RCxLQUFLeXZELG1CQUFtQjtJQUNsQ3p2RSxPQUFPNHZFLEdBQUc1dkQsS0FBSzB2RCxtQkFBbUI7SUFDbEMxdkUsT0FBTzR2RSxHQUFHNXZELEtBQUtrbkQsZUFBZTtJQUM5QmxuRSxPQUFPNHZFLEdBQUc1dkQsS0FBS3N1RCxlQUFlO0lBQzlCLE9BQU90dUU7QUFDVDtBQUNBLElBQUk4dkUsdUJBQXVCLFNBQVNBLHFCQUFxQjF2RCxHQUFHO0lBQzFELElBQUl4aEIsSUFBSSxTQUFTQSxFQUFFd1UsQ0FBQztRQUNsQixPQUFPeFAsS0FBSytFLEtBQUssQ0FBQ3lLO0lBQ3BCO0lBQ0EsSUFBSWdOLElBQUltNkIsTUFBTSxJQUFJO1FBQ2hCLElBQUloaUIsS0FBS25ZLElBQUlzQyxNQUFNLEdBQUdHLFFBQVE7UUFDOUIsSUFBSTJWLEtBQUtwWSxJQUFJdUMsTUFBTSxHQUFHRSxRQUFRO1FBQzlCLE9BQU94RyxjQUFjO1lBQUN6ZCxFQUFFMjVCLEdBQUdubEIsQ0FBQztZQUFHeFUsRUFBRTI1QixHQUFHMWIsQ0FBQztZQUFHamUsRUFBRTQ1QixHQUFHcGxCLENBQUM7WUFBR3hVLEVBQUU0NUIsR0FBRzNiLENBQUM7U0FBRTtJQUMzRCxPQUFPO1FBQ0wsSUFBSXhVLElBQUkrWCxJQUFJeUMsUUFBUTtRQUNwQixPQUFPeEcsY0FBYztZQUFDemQsRUFBRXlKLEVBQUUrSyxDQUFDO1lBQUd4VSxFQUFFeUosRUFBRXdVLENBQUM7U0FBRTtJQUN2QztBQUNGO0FBQ0EsSUFBSWt6RCx3QkFBd0IsU0FBU0Esc0JBQXNCM3ZELEdBQUcsRUFBRUosSUFBSTtJQUNsRSxJQUFJNEMsS0FBS3hDLElBQUluYyxRQUFRO0lBQ3JCLElBQUlxMUI7SUFDSixJQUFJaWhCLFNBQVNuNkIsSUFBSW02QixNQUFNO0lBQ3ZCLElBQUl2NkMsTUFBTWdnQixRQUFRLE9BQU9nd0QsZUFBZUwsT0FBTzN2RDtJQUMvQyxJQUFJaXdELGVBQWVqd0UsUUFBUWd3RTtJQUMzQixJQUFJcHRELEdBQUcrQixPQUFPLElBQUksTUFBTTtRQUN0QjJVLEtBQUsrekMsZ0JBQWdCanRELEtBQUs4dkQ7UUFDMUJ0dEQsR0FBRytCLE9BQU8sR0FBRzJVO1FBQ2IxVyxHQUFHdXRELGFBQWEsR0FBR0wscUJBQXFCMXZEO0lBQzFDLE9BQU87UUFDTGtaLEtBQUsxVyxHQUFHK0IsT0FBTztJQUNqQjtJQUVBLHdFQUF3RTtJQUN4RSxJQUFJLENBQUNzckQsY0FBYztRQUNqQixJQUFJenJELFNBQVNwRSxJQUFJb0UsTUFBTTtRQUN2QjhVLEtBQUtEO1FBQ0wsSUFBSXJaLEtBQUttdUQsWUFBWSxJQUFJM3BELFVBQVV4RSxLQUFLdXVELFlBQVksSUFBSSxDQUFDL3BELFFBQVE7WUFDL0QsSUFBSXhFLEtBQUtrbkQsZUFBZSxFQUFFO2dCQUN4QnlCLG9CQUFvQnJ2QyxJQUFJMVcsR0FBR2tDLGFBQWE7WUFDMUMsT0FBTztnQkFDTDZqRCxvQkFBb0JydkMsSUFBSTFXLEdBQUdpQyxVQUFVO1lBQ3ZDO1FBQ0Y7UUFDQSxJQUFJN0UsS0FBSyttRCxhQUFhLEVBQUU7WUFDdEIsSUFBSS9tRCxLQUFLd3ZELGlCQUFpQixJQUFLLEVBQUNqMUIsVUFBVXY2QixLQUFLeXZELG1CQUFtQixJQUFJenZELEtBQUswdkQsbUJBQW1CLEdBQUc7Z0JBQy9GL0csb0JBQW9CcnZDLElBQUkxVyxHQUFHbUMsV0FBVyxDQUFDQyxHQUFHO1lBQzVDLE9BQU87Z0JBQ0wsSUFBSWhGLEtBQUt3dkQsaUJBQWlCLEVBQUU7b0JBQzFCN0csb0JBQW9CcnZDLElBQUkxVyxHQUFHbUMsV0FBVyxDQUFDcXJELE9BQU87Z0JBQ2hEO2dCQUNBLElBQUlwd0QsS0FBS3l2RCxtQkFBbUIsRUFBRTtvQkFDNUI5RyxvQkFBb0JydkMsSUFBSTFXLEdBQUdtQyxXQUFXLENBQUNzckQsU0FBUztnQkFDbEQ7Z0JBQ0EsSUFBSXJ3RCxLQUFLMHZELG1CQUFtQixFQUFFO29CQUM1Qi9HLG9CQUFvQnJ2QyxJQUFJMVcsR0FBR21DLFdBQVcsQ0FBQ3VyRCxTQUFTO2dCQUNsRDtZQUNGO1FBQ0Y7UUFDQWgzQyxHQUFHdmIsQ0FBQyxHQUFHdWIsR0FBRzMwQixFQUFFLEdBQUcyMEIsR0FBRzUwQixFQUFFO1FBQ3BCNDBCLEdBQUdueEIsQ0FBQyxHQUFHbXhCLEdBQUd6MEIsRUFBRSxHQUFHeTBCLEdBQUcxMEIsRUFBRTtJQUN0QjtJQUNBLE9BQU8wMEI7QUFDVDtBQUNBLElBQUk0MkMsWUFBWTtJQUNkL0IsY0FBYztJQUNkSSxjQUFjO0lBQ2R4SCxlQUFlO0lBQ2Z5SSxtQkFBbUI7SUFDbkJDLHFCQUFxQjtJQUNyQkMscUJBQXFCO0lBQ3JCeEksaUJBQWlCO0lBQ2pCK0csa0JBQWtCO0lBQ2xCSyxpQkFBaUI7SUFDakJuSCxVQUFVO0FBQ1o7QUFDQSxJQUFJNkksZUFBZUwsT0FBT087QUFDMUIsSUFBSUssZUFBZTF3RCxXQUFXcXdEO0FBQzlCekosU0FBU2hpRSxXQUFXLEdBQUcsU0FBVW1PLE9BQU87SUFDdEMsSUFBSW0yRDtJQUNKLElBQUk1QixXQUFXdjBELFlBQVkvUSxhQUFhK1EsUUFBUXUwRCxRQUFRLEtBQUt0bEUsYUFBYStRLFFBQVF1MEQsUUFBUSxLQUFLO0lBQy9GLElBQUlxSixVQUFVdHJFLFFBQVEsU0FBVWtiLEdBQUc7UUFDakMsSUFBSXdDLEtBQUt4QyxJQUFJbmMsUUFBUTtRQUNyQixPQUFPMmUsR0FBRytCLE9BQU8sSUFBSSxRQUFRL0IsR0FBRzZ0RCxVQUFVLElBQUk3dEQsR0FBR3V0RCxhQUFhLEtBQUtMLHFCQUFxQjF2RDtJQUMxRixHQUFHLFNBQVVBLEdBQUc7UUFDZCxPQUFPQSxJQUFJMEcsRUFBRTtJQUNmO0lBRUEsaUZBQWlGO0lBQ2pGLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcEQsSUFBSXFnRCxZQUFZLElBQUksQ0FBQ3JvRSxNQUFNLEtBQUssS0FBSyxDQUFDMHhFLFFBQVEsSUFBSSxDQUFDLEVBQUUsR0FBRztRQUN0RCxJQUFJNTlELFlBQVkvUSxXQUFXO1lBQ3pCK1EsVUFBVXM5RDtRQUNaLE9BQU87WUFDTHQ5RCxVQUFVMjlELGFBQWEzOUQ7UUFDekI7UUFDQW0yRCxTQUFTZ0gsc0JBQXNCLElBQUksQ0FBQyxFQUFFLEVBQUVuOUQ7SUFDMUMsT0FBTztRQUNMbTJELFNBQVMxdkM7UUFDVHptQixVQUFVQSxXQUFXczlEO1FBQ3JCLElBQUlsd0QsT0FBT3V3RCxhQUFhMzlEO1FBQ3hCLElBQUl1WixPQUFPLElBQUk7UUFDZixJQUFJOUosS0FBSzhKLEtBQUs5SixFQUFFO1FBQ2hCLElBQUlzL0IsZUFBZXQvQixHQUFHcy9CLFlBQVk7UUFFbEMsb0ZBQW9GO1FBQ3BGLElBQUksQ0FBQ3Q5QixLQUFLLEdBQUdyQyxPQUFPLENBQUN3dUQ7UUFDckIsSUFBSSxDQUFDN3BELEtBQUssR0FBRzNFLE9BQU8sQ0FBQ3d1RDtRQUNyQixJQUFJN3VCLGNBQWM7WUFDaEIsSUFBSSxDQUFDK3VCLHdCQUF3QixDQUFDdko7UUFDaEM7UUFDQSxJQUFJLENBQUNuQyxvQkFBb0IsQ0FBQyxDQUFDbUM7UUFDM0IsSUFBSyxJQUFJOWxFLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtZQUNqQixJQUFJbXZFLFFBQVFwd0QsTUFBTTtnQkFDaEJBLElBQUl5a0QscUJBQXFCO1lBQzNCO1lBQ0E4RCxvQkFBb0JJLFFBQVFnSCxzQkFBc0IzdkQsS0FBS0o7UUFDekQ7SUFDRjtJQUNBK29ELE9BQU9ya0UsRUFBRSxHQUFHK2pFLE9BQU9NLE9BQU9ya0UsRUFBRTtJQUM1QnFrRSxPQUFPbmtFLEVBQUUsR0FBRzZqRSxPQUFPTSxPQUFPbmtFLEVBQUU7SUFDNUJta0UsT0FBT3BrRSxFQUFFLEdBQUc4akUsT0FBT00sT0FBT3BrRSxFQUFFO0lBQzVCb2tFLE9BQU9sa0UsRUFBRSxHQUFHNGpFLE9BQU9NLE9BQU9sa0UsRUFBRTtJQUM1QmtrRSxPQUFPaHJELENBQUMsR0FBRzBxRCxPQUFPTSxPQUFPcGtFLEVBQUUsR0FBR29rRSxPQUFPcmtFLEVBQUU7SUFDdkNxa0UsT0FBTzVnRSxDQUFDLEdBQUdzZ0UsT0FBT00sT0FBT2xrRSxFQUFFLEdBQUdra0UsT0FBT25rRSxFQUFFO0lBQ3ZDLE9BQU9ta0U7QUFDVDtBQUNBdEMsU0FBUzVCLHFCQUFxQixHQUFHO0lBQy9CLElBQUssSUFBSXhqRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJdWhCLEtBQUssSUFBSSxDQUFDdmhCLEVBQUUsQ0FBQzRDLFFBQVE7UUFDekIyZSxHQUFHK0IsT0FBTyxHQUFHO1FBQ2IvQixHQUFHdXRELGFBQWEsR0FBRztRQUNuQnZ0RCxHQUFHaUMsVUFBVSxHQUFHO1FBQ2hCakMsR0FBR2tDLGFBQWEsR0FBRztRQUNuQmxDLEdBQUdtQyxXQUFXLENBQUNDLEdBQUcsR0FBRztRQUNyQnBDLEdBQUdtQyxXQUFXLENBQUNyQyxNQUFNLEdBQUc7UUFDeEJFLEdBQUdtQyxXQUFXLENBQUNwQyxNQUFNLEdBQUc7UUFDeEJDLEdBQUdtQyxXQUFXLENBQUNFLElBQUksR0FBRztRQUN0QnJDLEdBQUdtQyxXQUFXLENBQUNzckQsU0FBUyxHQUFHO1FBQzNCenRELEdBQUdtQyxXQUFXLENBQUN1ckQsU0FBUyxHQUFHO1FBQzNCMXRELEdBQUdtQyxXQUFXLENBQUNxckQsT0FBTyxHQUFHO1FBQ3pCeHRELEdBQUdzQyxXQUFXLENBQUN4QyxNQUFNLEdBQUc7UUFDeEJFLEdBQUdzQyxXQUFXLENBQUN2QyxNQUFNLEdBQUc7UUFDeEJDLEdBQUdzQyxXQUFXLENBQUMsYUFBYSxHQUFHO1FBQy9CdEMsR0FBR3NDLFdBQVcsQ0FBQyxhQUFhLEdBQUc7SUFDakM7SUFDQSxJQUFJLENBQUN5aEQsYUFBYSxDQUFDO0lBQ25CLE9BQU8sSUFBSTtBQUNiO0FBRUEsK0RBQStEO0FBQy9ELHNGQUFzRjtBQUN0RiwwR0FBMEc7QUFDMUcsaUdBQWlHO0FBQ2pHRixTQUFTa0ssYUFBYSxHQUFHLFNBQVV4dEUsRUFBRTtJQUNuQyxJQUFJd2pCLFFBQVEsSUFBSSxDQUFDQSxLQUFLO0lBQ3RCLElBQUl0RSxLQUFLLElBQUksQ0FBQ0EsRUFBRTtJQUNoQixJQUFJNmdELG1CQUFtQjdnRCxHQUFHNmdELGdCQUFnQjtJQUMxQyxJQUFJZixVQUFVOS9DLEdBQUdyZSxVQUFVO0lBQzNCLElBQUlrL0Qsa0JBQWtCO1FBQ3BCZixVQUFVeDdDLE1BQU01RSxNQUFNLENBQUMsU0FBVWlHLElBQUk7WUFDbkMsT0FBT0EsS0FBS3F4QyxRQUFRO1FBQ3RCO1FBQ0ExeUMsUUFBUUEsTUFBTWc4QyxHQUFHLENBQUNSO0lBQ3BCO0lBQ0EsSUFBSTcrRCxZQUFZSCxLQUFLO1FBQ25CLElBQUlKLE1BQU1JO1FBQ1ZBLEtBQUssU0FBU0E7WUFDWixPQUFPSjtRQUNUO0lBQ0Y7SUFDQSxJQUFJNnRFLGNBQWMsU0FBU0EsWUFBWTVvRCxJQUFJLEVBQUUzbUIsQ0FBQztRQUM1QyxPQUFPMm1CLEtBQUsvakIsUUFBUSxDQUFDNHNFLFVBQVUsR0FBRzF0RSxHQUFHNmtCLE1BQU0zbUI7SUFDN0M7SUFDQSxJQUFJeXZFLFlBQVksU0FBU0EsVUFBVTlvRCxJQUFJO1FBQ3JDLE9BQU9BLEtBQUsvakIsUUFBUSxDQUFDNHNFLFVBQVU7SUFDakM7SUFDQXh1RCxHQUFHZ2pELFVBQVU7SUFDYjErQyxNQUFNM0UsT0FBTyxDQUFDNHVELGFBQWFwTCxlQUFlLENBQUNyaUU7SUFDM0MsSUFBSSsvRCxrQkFBa0I7UUFDcEJmLFFBQVE4Qyx3QkFBd0I7UUFDaEM5QyxRQUFRMEMscUJBQXFCO1FBQzdCMUMsUUFBUTZDLG9CQUFvQixDQUFDLE9BQU8sOENBQThDO0lBQ3BGO0lBQ0EsSUFBSTFyQyxLQUFLQyxnQkFBZ0IsSUFBSSxDQUFDOTBCLFdBQVcsQ0FBQztRQUN4QzBpRSxVQUFVO0lBQ1o7SUFDQXhnRCxNQUFNNitDLGVBQWUsQ0FBQ3NMO0lBQ3RCLElBQUk1TixrQkFBa0I7UUFDcEJmLFFBQVE4Qyx3QkFBd0I7UUFDaEM5QyxRQUFRMEMscUJBQXFCO1FBQzdCMUMsUUFBUTZDLG9CQUFvQixDQUFDLE9BQU8sOENBQThDO0lBQ3BGO0lBQ0EzaUQsR0FBR2tqRCxRQUFRO0lBQ1gsT0FBT2pzQztBQUNUO0FBQ0FrdEMsS0FBS3VLLFdBQVcsR0FBR3ZLLEtBQUtsdEMsRUFBRSxHQUFHa3RDLEtBQUsvaEUsV0FBVztBQUM3QytoRSxLQUFLd0ssbUJBQW1CLEdBQUd4SyxLQUFLRSxtQkFBbUI7QUFDbkQsSUFBSXFDLFNBQVN0QztBQUViLElBQUl3SyxNQUFNQztBQUNWRCxPQUFPQyxXQUFXLENBQUM7QUFDbkIsSUFBSUMsZUFBZSxTQUFTQSxhQUFhbnhELElBQUk7SUFDM0NBLEtBQUtveEQsYUFBYSxHQUFHNXFFLFdBQVd3WixLQUFLN2QsSUFBSTtJQUN6QzZkLEtBQUtxeEQsUUFBUSxHQUFHLFNBQVNyeEQsS0FBS294RCxhQUFhO0lBQzNDcHhELEtBQUtzeEQsU0FBUyxHQUFHLFVBQVV0eEQsS0FBS294RCxhQUFhO0lBQzdDcHhELEtBQUt1eEQsU0FBUyxHQUFHLFVBQVV2eEQsS0FBS294RCxhQUFhO0lBQzdDcHhELEtBQUt3eEQsa0JBQWtCLEdBQUdockUsV0FBV3daLEtBQUt1eEQsU0FBUztJQUNuRE4sSUFBSSxDQUFDanhELEtBQUs3ZCxJQUFJLENBQUMsR0FBRyxTQUFTc3ZFO1FBQ3pCLElBQUlyeEQsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJd0MsS0FBS3hDLElBQUluYyxRQUFRO1FBQ3JCLElBQUlvZSxLQUFLTyxHQUFHUCxFQUFFO1FBQ2QsSUFBSXMvQixlQUFldC9CLEdBQUdwZSxRQUFRLENBQUMwOUMsWUFBWTtRQUMzQyxJQUFJdmhDLEtBQUs7WUFDUCxJQUFJdWhDLGNBQWM7Z0JBQ2hCLElBQUl2aEMsSUFBSWk1QyxRQUFRLElBQUk7b0JBQ2xCajVDLElBQUk0a0Qsb0JBQW9CO29CQUN4QixPQUFPcGlELEVBQUUsQ0FBQzVDLEtBQUtxeEQsUUFBUSxDQUFDLElBQUk7Z0JBQzlCO2dCQUNBLElBQUl6a0QsSUFBSXhNLElBQUk0bUQsTUFBTSxDQUFDaG5ELEtBQUs3ZCxJQUFJO2dCQUM1QixPQUFReXFCLEVBQUVrOUMsUUFBUTtvQkFDaEIsS0FBSzt3QkFDSDFwRCxJQUFJc3dELHdCQUF3Qjt3QkFDNUIsT0FBTzl0RCxHQUFHUSxNQUFNLENBQUNwRCxLQUFLc3hELFNBQVMsQ0FBQyxJQUFJO29CQUN0Qzt3QkFDRSxPQUFPMWtELEVBQUVxNkMsT0FBTztnQkFDcEI7WUFDRixPQUFPO2dCQUNMLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFDQWdLLElBQUksQ0FBQyxVQUFVanhELEtBQUtveEQsYUFBYSxDQUFDLEdBQUcsU0FBU007UUFDNUMsSUFBSXR4RCxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ2pCLElBQUl3QyxLQUFLeEMsSUFBSW5jLFFBQVE7UUFDckIsSUFBSW9lLEtBQUtPLEdBQUdQLEVBQUU7UUFDZCxJQUFJcy9CLGVBQWV0L0IsR0FBR3BlLFFBQVEsQ0FBQzA5QyxZQUFZO1FBQzNDLElBQUl2aEMsS0FBSztZQUNQLElBQUl1aEMsY0FBYztnQkFDaEIsSUFBSTVQLE1BQU0zeEIsR0FBRyxDQUFDSixLQUFLN2QsSUFBSSxDQUFDO2dCQUN4QixJQUFJd3ZFLFlBQVl2eEQsSUFBSTRtRCxNQUFNLENBQUMsbUJBQW1CdG1FLEtBQUs7Z0JBQ25ELElBQUlreEU7Z0JBQ0osSUFBSUQsY0FBYyxVQUFVO29CQUMxQkMsU0FBU3h4RCxJQUFJNG1ELE1BQU0sQ0FBQyxnQkFBZ0JDLE9BQU8sRUFBRSxxQkFBcUI7Z0JBQ3BFLE9BQU8sSUFBSTBLLGNBQWMsV0FBVztvQkFDbENDLFNBQVMsSUFBSXh4RCxJQUFJNG1ELE1BQU0sQ0FBQyxnQkFBZ0JDLE9BQU87Z0JBQ2pELE9BQU87b0JBQ0wsV0FBVztvQkFDWDJLLFNBQVM7Z0JBQ1g7Z0JBQ0EsSUFBSTkzQyxVQUFVLElBQUkxWixJQUFJMFosT0FBTztnQkFDN0IsT0FBT2lZLE1BQU02L0IsU0FBUzkzQztZQUN4QixPQUFPO2dCQUNMLE9BQU87WUFDVDtRQUNGO0lBQ0Y7SUFDQW0zQyxJQUFJLENBQUMsYUFBYWp4RCxLQUFLb3hELGFBQWEsQ0FBQyxHQUFHLFNBQVNTO1FBQy9DLElBQUl6eEQsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJQSxLQUFLO1lBQ1AsSUFBSXdNLElBQUl4TSxHQUFHLENBQUNKLEtBQUs3ZCxJQUFJLENBQUM7WUFDdEIsT0FBT3lxQixJQUFJLElBQUksQ0FBQ3ZLLEVBQUUsR0FBR2lELElBQUk7UUFDM0I7SUFDRjtJQUNBMnJELElBQUksQ0FBQyxhQUFhanhELEtBQUt3eEQsa0JBQWtCLENBQUMsR0FBRyxTQUFTTTtRQUNwRCxJQUFJMXhELE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSUEsS0FBSztZQUNQLElBQUkyeEQsS0FBSzN4RCxHQUFHLENBQUNKLEtBQUt1eEQsU0FBUyxDQUFDO1lBQzVCLE9BQU9RLEtBQUssSUFBSSxDQUFDMXZELEVBQUUsR0FBR2lELElBQUk7UUFDNUI7SUFDRjtBQUNGO0FBQ0E2ckQsYUFBYTtJQUNYaHZFLE1BQU07QUFDUjtBQUNBZ3ZFLGFBQWE7SUFDWGh2RSxNQUFNO0FBQ1I7QUFDQSt1RSxTQUFTcDNDLE9BQU8sR0FBRztJQUNqQixJQUFJMVosTUFBTSxJQUFJLENBQUMsRUFBRTtJQUNqQixJQUFJd0MsS0FBS3hDLElBQUluYyxRQUFRO0lBQ3JCLElBQUltYyxJQUFJaTVDLFFBQVEsSUFBSTtRQUNsQmo1QyxJQUFJNGtELG9CQUFvQjtRQUN4QixJQUFJcGlELEdBQUdJLFdBQVcsS0FBS25oQixXQUFXO1lBQ2hDLE9BQU8rZ0IsR0FBR0ksV0FBVztRQUN2QixPQUFPO1lBQ0wsT0FBTzVDLElBQUk0bUQsTUFBTSxDQUFDLFdBQVdDLE9BQU87UUFDdEM7SUFDRixPQUFPO1FBQ0wsT0FBTzdtRCxJQUFJNG1ELE1BQU0sQ0FBQyxXQUFXQyxPQUFPO0lBQ3RDO0FBQ0Y7QUFDQWlLLFNBQVNjLFlBQVksR0FBRztJQUN0QixJQUFJNXhELE1BQU0sSUFBSSxDQUFDLEVBQUU7SUFDakIsT0FBT0EsSUFBSTZiLE1BQU0sS0FBSyxJQUFJN2IsSUFBSTBaLE9BQU87QUFDdkM7QUFDQW8zQyxTQUFTZSxXQUFXLEdBQUc7SUFDckIsSUFBSTd4RCxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ2pCLE9BQU9BLElBQUk0YixLQUFLLEtBQUssSUFBSTViLElBQUkwWixPQUFPO0FBQ3RDO0FBQ0EsSUFBSW80QyxjQUFjaEI7QUFFbEIsSUFBSWlCLFNBQVMsU0FBU0EsT0FBTy94RCxHQUFHLEVBQUVvbUMsUUFBUTtJQUN4QyxJQUFJcG1DLElBQUltNkIsTUFBTSxNQUFNbjZCLElBQUlneUQsWUFBWSxJQUFJO1FBQ3RDLE9BQU81ckIsU0FBU3BtQztJQUNsQjtBQUNGO0FBQ0EsSUFBSWl5RCx5QkFBeUIsU0FBU0EsdUJBQXVCanlELEdBQUcsRUFBRWt5RCxRQUFRO0lBQ3hFLElBQUlseUQsSUFBSW02QixNQUFNLE1BQU1uNkIsSUFBSWd5RCxZQUFZLElBQUk7UUFDdEMsSUFBSS92RCxLQUFLakMsSUFBSWlDLEVBQUU7UUFDZixPQUFPOFUsMEJBQTBCbTdDLFNBQVNseUQsTUFBTWlDLEdBQUdpRCxJQUFJLElBQUlqRCxHQUFHZ0QsR0FBRztJQUNuRTtBQUNGO0FBQ0EsSUFBSWt0RCwwQkFBMEIsU0FBU0Esd0JBQXdCbnlELEdBQUcsRUFBRW95RCxTQUFTO0lBQzNFLElBQUlweUQsSUFBSW02QixNQUFNLE1BQU1uNkIsSUFBSWd5RCxZQUFZLElBQUk7UUFDdEMsSUFBSS92RCxLQUFLakMsSUFBSWlDLEVBQUU7UUFDZixJQUFJZ0QsTUFBTWhELEdBQUdnRCxHQUFHO1FBQ2hCLElBQUlDLE9BQU9qRCxHQUFHaUQsSUFBSTtRQUNsQixPQUFPa3RELFVBQVVweUQsS0FBS3ZOLEdBQUcsQ0FBQyxTQUFVeEssQ0FBQztZQUNuQyxPQUFPOHVCLDBCQUEwQjl1QixHQUFHaWQsTUFBTUQ7UUFDNUM7SUFDRjtBQUNGO0FBQ0EsSUFBSW90RCxnQkFBZ0IsU0FBU0EsY0FBY3J5RCxHQUFHO0lBQzVDLE9BQU9BLElBQUl3c0QsUUFBUSxHQUFHOEYsZ0JBQWdCLENBQUN0eUQ7QUFDekM7QUFDQSxJQUFJdXlELGdCQUFnQixTQUFTQSxjQUFjdnlELEdBQUc7SUFDNUMsT0FBT0EsSUFBSXdzRCxRQUFRLEdBQUdnRyxnQkFBZ0IsQ0FBQ3h5RDtBQUN6QztBQUNBLElBQUl5eUQsaUJBQWlCLFNBQVNBLGVBQWV6eUQsR0FBRztJQUM5QyxPQUFPQSxJQUFJd3NELFFBQVEsR0FBR2tHLGlCQUFpQixDQUFDMXlEO0FBQzFDO0FBQ0EsSUFBSTJ5RCxpQkFBaUIsU0FBU0EsZUFBZTN5RCxHQUFHO0lBQzlDLE9BQU9BLElBQUl3c0QsUUFBUSxHQUFHb0csaUJBQWlCLENBQUM1eUQ7QUFDMUM7QUFDQSxJQUFJNnlELFdBQVcsU0FBU0EsU0FBUzd5RCxHQUFHO0lBQ2xDLE9BQU9BLElBQUl3c0QsUUFBUSxHQUFHc0csZUFBZSxDQUFDOXlEO0FBQ3hDO0FBQ0EsSUFBSThhLE1BQU07SUFDUnUzQyxlQUFlO1FBQ2JyeEQsS0FBS3F4RDtRQUNMVSxNQUFNO0lBQ1I7SUFDQVIsZUFBZTtRQUNidnhELEtBQUt1eEQ7UUFDTFEsTUFBTTtJQUNSO0lBQ0FOLGdCQUFnQjtRQUNkenhELEtBQUt5eEQ7SUFDUDtJQUNBRSxnQkFBZ0I7UUFDZDN4RCxLQUFLMnhEO0lBQ1A7SUFDQUUsVUFBVTtRQUNSN3hELEtBQUs2eEQ7SUFDUDtBQUNGO0FBQ0EsSUFBSUcsZUFBZSxTQUFTQSxhQUFhanhFLElBQUk7SUFDM0MsT0FBTyxhQUFhQSxJQUFJLENBQUMsRUFBRSxDQUFDaUUsV0FBVyxLQUFLakUsS0FBS2t4RSxNQUFNLENBQUM7QUFDMUQ7QUFDQSxJQUFJQyxhQUFhenpFLE9BQU80SCxJQUFJLENBQUN5ekIsS0FBSzJqQyxNQUFNLENBQUMsU0FBVTk3RCxHQUFHLEVBQUVaLElBQUk7SUFDMUQsSUFBSW94RSxPQUFPcjRDLEdBQUcsQ0FBQy80QixLQUFLO0lBQ3BCLElBQUlxeEUsUUFBUUosYUFBYWp4RTtJQUN6QlksR0FBRyxDQUFDWixLQUFLLEdBQUc7UUFDVixPQUFPZ3dFLE9BQU8sSUFBSSxFQUFFb0IsS0FBS255RCxHQUFHO0lBQzlCO0lBQ0EsSUFBSW15RCxLQUFLSixJQUFJLEVBQUU7UUFDYnB3RSxHQUFHLENBQUN5d0UsTUFBTSxHQUFHO1lBQ1gsT0FBT2pCLHdCQUF3QixJQUFJLEVBQUVnQixLQUFLbnlELEdBQUc7UUFDL0M7SUFDRixPQUFPO1FBQ0xyZSxHQUFHLENBQUN5d0UsTUFBTSxHQUFHO1lBQ1gsT0FBT25CLHVCQUF1QixJQUFJLEVBQUVrQixLQUFLbnlELEdBQUc7UUFDOUM7SUFDRjtJQUNBLE9BQU9yZTtBQUNULEdBQUcsQ0FBQztBQUVKLElBQUkwd0UsYUFBYXBzRSxPQUFPLENBQUMsR0FBR3diLFVBQVVrbUQsUUFBUW1KLGFBQWFvQjtBQUUzRDs7Ozs7O0FBTUEsR0FFQSxJQUFJSSxRQUFRLFNBQVNBLE1BQU1wc0QsR0FBRyxFQUFFMjFCLEtBQUs7SUFDbkMsSUFBSSxDQUFDMDJCLE9BQU8sQ0FBQ3JzRCxLQUFLMjFCO0FBQ3BCO0FBQ0EsU0FBUzIyQjtJQUNQLE9BQU87QUFDVDtBQUNBLFNBQVNDO0lBQ1AsT0FBTztBQUNUO0FBRUEsb0ZBQW9GO0FBQ3BGSCxNQUFNeHpFLFNBQVMsR0FBRztJQUNoQjhDLGdCQUFnQixTQUFTQTtRQUN2QixPQUFPO0lBQ1Q7SUFDQTJ3RSxTQUFTLFNBQVNBLFFBQVFyc0QsR0FBRyxFQUFFMjFCLEtBQUs7UUFDbEMsSUFBSSxDQUFDNjJCLDZCQUE2QixHQUFHLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsSUFBSSxDQUFDQyxrQkFBa0IsR0FBR0o7UUFDM0YsSUFBSXRzRCxPQUFPLFFBQVFBLElBQUkyc0QsY0FBYyxFQUFFO1lBQ3JDLHVCQUF1QjtZQUN2QixJQUFJLENBQUN0Z0UsSUFBSSxHQUFHMlQsSUFBSTNULElBQUk7WUFFcEIsb0VBQW9FO1lBQ3BFLCtEQUErRDtZQUMvRCxJQUFJLENBQUNxZ0Usa0JBQWtCLEdBQUcxc0QsSUFBSTRzRCxnQkFBZ0IsR0FBR0wsYUFBYUQ7UUFDaEUsT0FBTyxJQUFJdHNELE9BQU8sUUFBUUEsSUFBSTNULElBQUksRUFBRTtZQUNsQyw0Q0FBNEM7WUFDNUNzcEMsUUFBUTMxQjtRQUNWLE9BQU87WUFDTCxlQUFlO1lBQ2YsSUFBSSxDQUFDM1QsSUFBSSxHQUFHMlQ7UUFDZDtRQUVBLDJEQUEyRDtRQUMzRCxJQUFJMjFCLFNBQVMsTUFBTTtZQUNqQixnREFBZ0Q7WUFDaEQsSUFBSSxDQUFDazNCLGFBQWEsR0FBR2wzQixNQUFNazNCLGFBQWE7WUFDeEMsSUFBSSxDQUFDeGdFLElBQUksR0FBR3NwQyxNQUFNdHBDLElBQUksSUFBSSxPQUFPc3BDLE1BQU10cEMsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSTtZQUN2RCxJQUFJLENBQUMwTyxFQUFFLEdBQUc0NkIsTUFBTTU2QixFQUFFO1lBQ2xCLElBQUksQ0FBQ00sTUFBTSxHQUFHczZCLE1BQU10NkIsTUFBTTtZQUMxQixJQUFJLENBQUNFLFFBQVEsR0FBR282QixNQUFNcDZCLFFBQVE7WUFDOUIsSUFBSSxDQUFDc0MsZ0JBQWdCLEdBQUc4M0IsTUFBTTkzQixnQkFBZ0I7WUFDOUMsSUFBSSxDQUFDaXZELFNBQVMsR0FBR24zQixNQUFNbTNCLFNBQVM7WUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUdwM0IsTUFBTW8zQixNQUFNO1FBQzVCO1FBQ0EsSUFBSSxJQUFJLENBQUNoeUQsRUFBRSxJQUFJLFFBQVEsSUFBSSxDQUFDUSxRQUFRLElBQUksUUFBUSxJQUFJLENBQUNzQyxnQkFBZ0IsSUFBSSxNQUFNO1lBQzdFLDBEQUEwRDtZQUMxRCxJQUFJdEgsTUFBTSxJQUFJLENBQUNnRixRQUFRO1lBQ3ZCLElBQUl5QyxPQUFPLElBQUksQ0FBQ2pELEVBQUUsQ0FBQ2lELElBQUk7WUFDdkIsSUFBSUQsTUFBTSxJQUFJLENBQUNoRCxFQUFFLENBQUNnRCxHQUFHO1lBQ3JCLElBQUksQ0FBQ0YsZ0JBQWdCLEdBQUc7Z0JBQ3RCL1IsR0FBR3lLLElBQUl6SyxDQUFDLEdBQUdrUyxPQUFPRCxJQUFJalMsQ0FBQztnQkFDdkJ5SixHQUFHZ0IsSUFBSWhCLENBQUMsR0FBR3lJLE9BQU9ELElBQUl4SSxDQUFDO1lBQ3pCO1FBQ0Y7UUFFQSx3REFBd0Q7UUFDeEQsSUFBSSxDQUFDeTNELFNBQVMsR0FBR2h0RCxPQUFPQSxJQUFJZ3RELFNBQVMsSUFBSTUvRCxLQUFLRCxHQUFHO0lBQ25EO0lBQ0F3L0QsZ0JBQWdCLFNBQVNBO1FBQ3ZCLElBQUksQ0FBQ0Qsa0JBQWtCLEdBQUdIO1FBQzFCLElBQUk5MEUsSUFBSSxJQUFJLENBQUNvMUUsYUFBYTtRQUMxQixJQUFJLENBQUNwMUUsR0FBRztZQUNOO1FBQ0Y7UUFFQSx3REFBd0Q7UUFDeEQsSUFBSUEsRUFBRWsxRSxjQUFjLEVBQUU7WUFDcEJsMUUsRUFBRWsxRSxjQUFjO1FBQ2xCO0lBQ0Y7SUFDQU0saUJBQWlCLFNBQVNBO1FBQ3hCLElBQUksQ0FBQ1Isb0JBQW9CLEdBQUdGO1FBQzVCLElBQUk5MEUsSUFBSSxJQUFJLENBQUNvMUUsYUFBYTtRQUMxQixJQUFJLENBQUNwMUUsR0FBRztZQUNOO1FBQ0Y7UUFFQSx5REFBeUQ7UUFDekQsSUFBSUEsRUFBRXcxRSxlQUFlLEVBQUU7WUFDckJ4MUUsRUFBRXcxRSxlQUFlO1FBQ25CO0lBQ0Y7SUFDQUMsMEJBQTBCLFNBQVNBO1FBQ2pDLElBQUksQ0FBQ1YsNkJBQTZCLEdBQUdEO1FBQ3JDLElBQUksQ0FBQ1UsZUFBZTtJQUN0QjtJQUNBUCxvQkFBb0JKO0lBQ3BCRyxzQkFBc0JIO0lBQ3RCRSwrQkFBK0JGO0FBQ2pDO0FBRUEsSUFBSWEsYUFBYSwyQkFBMkIsNERBQTREO0FBQ3hHLElBQUlDLHFCQUFxQixNQUFNLHNGQUFzRjtBQUVySCxJQUFJQyxhQUFhO0lBQ2ZDLGtCQUFrQixTQUFTQSxpQkFBaUJDLEVBQUUsRUFBRUMsRUFBRTtRQUNoRCxPQUFPRCxPQUFPQztJQUNoQjtJQUNBQyxjQUFjLFNBQVNBO1FBRXJCLE9BQU87SUFDVDtJQUNBQyxnQkFBZ0IsU0FBU0Esa0JBQ3RCO0lBQ0hDLGlCQUFpQixTQUFTQSxnQkFBZ0JDLFFBQVEsc0JBQXNCLEdBQXZCO1FBQy9DLE9BQU9BO0lBQ1Q7SUFDQUMsWUFBWSxTQUFTQSxjQUNsQjtJQUNIQyxXQUFXLFNBQVNBLGFBQ2pCO0lBQ0hDLFFBQVEsU0FBU0E7UUFFZixPQUFPO0lBQ1Q7SUFDQTl3RCxRQUFRLFNBQVNBO1FBRWYsT0FBTztJQUNUO0lBQ0Eyd0QsU0FBUztBQUNYO0FBQ0EsSUFBSUksZUFBZXoxRSxPQUFPNEgsSUFBSSxDQUFDa3RFO0FBQy9CLElBQUlZLFlBQVksQ0FBQztBQUNqQixTQUFTQztJQUNQLElBQUl4MUQsT0FBTzVhLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBR213RTtJQUMvRSxJQUFJTCxVQUFVOXZFLFVBQVV0RyxNQUFNLEdBQUcsSUFBSXNHLFNBQVMsQ0FBQyxFQUFFLEdBQUd2RDtJQUNwRCw4RUFBOEU7SUFDOUUsSUFBSyxJQUFJUixJQUFJLEdBQUdBLElBQUlpMEUsYUFBYXgyRSxNQUFNLEVBQUV1QyxJQUFLO1FBQzVDLElBQUlyQixNQUFNczFFLFlBQVksQ0FBQ2owRSxFQUFFO1FBQ3pCLElBQUksQ0FBQ3JCLElBQUksR0FBR2dnQixJQUFJLENBQUNoZ0IsSUFBSSxJQUFJMjBFLFVBQVUsQ0FBQzMwRSxJQUFJO0lBQzFDO0lBQ0EsSUFBSSxDQUFDazFFLE9BQU8sR0FBR0EsV0FBVyxJQUFJLENBQUNBLE9BQU87SUFDdEMsSUFBSSxDQUFDaHlELFNBQVMsR0FBRyxFQUFFO0lBQ25CLElBQUksQ0FBQ3V5RCxRQUFRLEdBQUc7QUFDbEI7QUFDQSxJQUFJcHRFLElBQUltdEUsUUFBUXQxRSxTQUFTO0FBQ3pCLElBQUl3MUUsZUFBZSxTQUFTQSxhQUFhandFLEtBQUksRUFBRWt3RSxPQUFPLEVBQUV2Z0IsTUFBTSxFQUFFd2dCLFNBQVMsRUFBRTN6RCxRQUFRLEVBQUU0ekQsSUFBSSxFQUFFQyxhQUFhO0lBQ3RHLElBQUk3eUUsS0FBSzJ5RSxZQUFZO1FBQ25CM3pELFdBQVcyekQ7UUFDWEEsWUFBWTtJQUNkO0lBQ0EsSUFBSUUsZUFBZTtRQUNqQixJQUFJRCxRQUFRLE1BQU07WUFDaEJBLE9BQU9DO1FBQ1QsT0FBTztZQUNMRCxPQUFPeHVFLE9BQU8sQ0FBQyxHQUFHd3VFLE1BQU1DO1FBQzFCO0lBQ0Y7SUFDQSxJQUFJQyxZQUFZM3lFLE1BQU1neUQsVUFBVUEsU0FBU0EsT0FBTzd2QyxLQUFLLENBQUM7SUFDdEQsSUFBSyxJQUFJbGtCLElBQUksR0FBR0EsSUFBSTAwRSxVQUFVajNFLE1BQU0sRUFBRXVDLElBQUs7UUFDekMsSUFBSTIwRSxNQUFNRCxTQUFTLENBQUMxMEUsRUFBRTtRQUN0QixJQUFJaUQsWUFBWTB4RSxNQUFNO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJenhFLFFBQVF5eEUsSUFBSXp4RSxLQUFLLENBQUNrd0UsYUFBYSxtQkFBbUI7UUFFdEQsSUFBSWx3RSxPQUFPO1lBQ1QsSUFBSW9QLE9BQU9wUCxLQUFLLENBQUMsRUFBRTtZQUNuQixJQUFJNnZFLFlBQVk3dkUsS0FBSyxDQUFDLEVBQUUsR0FBR0EsS0FBSyxDQUFDLEVBQUUsR0FBRztZQUN0QyxJQUFJbUIsTUFBTWl3RSxRQUFRbHdFLE9BQU11d0UsS0FBS3JpRSxNQUFNeWdFLFdBQVd3QixXQUFXM3pELFVBQVU0ekQ7WUFDbkUsSUFBSW53RSxRQUFRLE9BQU87Z0JBQ2pCO1lBQ0YsRUFBRSxzQkFBc0I7UUFDMUI7SUFDRjtBQUNGO0FBQ0EsSUFBSXV3RSxlQUFlLFNBQVNBLGFBQWF4d0UsS0FBSSxFQUFFMUMsR0FBRztJQUNoRDBDLE1BQUt1dkUsY0FBYyxDQUFDdnZFLE1BQUt5dkUsT0FBTyxFQUFFbnlFO0lBQ2xDLE9BQU8sSUFBSTJ3RSxNQUFNM3dFLElBQUk0USxJQUFJLEVBQUU1UTtBQUM3QjtBQUNBLElBQUltekUsa0JBQWtCLFNBQVNBLGdCQUFnQnp3RSxLQUFJLEVBQUVrd0UsT0FBTyxFQUFFdmdCLE1BQU07SUFDbEUsSUFBSS93RCxNQUFNK3dELFNBQVM7UUFDakJ1Z0IsUUFBUWx3RSxPQUFNMnZEO1FBQ2Q7SUFDRixPQUFPLElBQUk5eEQsWUFBWTh4RCxTQUFTO1FBQzlCdWdCLFFBQVFsd0UsT0FBTXd3RSxhQUFheHdFLE9BQU0ydkQ7UUFDakM7SUFDRjtJQUNBLElBQUkyZ0IsWUFBWTN5RSxNQUFNZ3lELFVBQVVBLFNBQVNBLE9BQU83dkMsS0FBSyxDQUFDO0lBQ3RELElBQUssSUFBSWxrQixJQUFJLEdBQUdBLElBQUkwMEUsVUFBVWozRSxNQUFNLEVBQUV1QyxJQUFLO1FBQ3pDLElBQUkyMEUsTUFBTUQsU0FBUyxDQUFDMTBFLEVBQUU7UUFDdEIsSUFBSWlELFlBQVkweEUsTUFBTTtZQUNwQjtRQUNGO1FBQ0EsSUFBSXp4RSxRQUFReXhFLElBQUl6eEUsS0FBSyxDQUFDa3dFLGFBQWEsbUJBQW1CO1FBRXRELElBQUlsd0UsT0FBTztZQUNULElBQUlvUCxPQUFPcFAsS0FBSyxDQUFDLEVBQUU7WUFDbkIsSUFBSTZ2RSxZQUFZN3ZFLEtBQUssQ0FBQyxFQUFFLEdBQUdBLEtBQUssQ0FBQyxFQUFFLEdBQUc7WUFDdEMsSUFBSTR4RSxXQUFXRixhQUFheHdFLE9BQU07Z0JBQ2hDa08sTUFBTUE7Z0JBQ055Z0UsV0FBV0E7Z0JBQ1h6eEQsUUFBUWxkLE1BQUt5dkUsT0FBTztZQUN0QjtZQUNBUyxRQUFRbHdFLE9BQU0wd0U7UUFDaEI7SUFDRjtBQUNGO0FBQ0E5dEUsRUFBRXNyRCxFQUFFLEdBQUd0ckQsRUFBRXNzRCxXQUFXLEdBQUcsU0FBVVMsTUFBTSxFQUFFd2dCLFNBQVMsRUFBRTN6RCxRQUFRLEVBQUU0ekQsSUFBSSxFQUFFQyxhQUFhO0lBQy9FSixhQUFhLElBQUksRUFBRSxTQUFVandFLEtBQUksRUFBRXBCLEtBQUssRUFBRXNQLElBQUksRUFBRXlnRSxTQUFTLEVBQUV3QixTQUFTLEVBQUUzekQsUUFBUSxFQUFFNHpELElBQUk7UUFDbEYsSUFBSTV5RSxLQUFLZ2YsV0FBVztZQUNsQnhjLE1BQUt5ZCxTQUFTLENBQUM1aEIsSUFBSSxDQUFDO2dCQUNsQitDLE9BQU9BO2dCQUNQLG9CQUFvQjtnQkFDcEI0ZCxVQUFVQTtnQkFDVixrQkFBa0I7Z0JBQ2xCdE8sTUFBTUE7Z0JBQ04sZ0NBQWdDO2dCQUNoQ3lnRSxXQUFXQTtnQkFDWCxvQ0FBb0M7Z0JBQ3BDd0IsV0FBV0E7Z0JBQ1gsaURBQWlEO2dCQUNqREMsTUFBTUEsS0FBSywyQkFBMkI7WUFDeEM7UUFDRjtJQUNGLEdBQUd6Z0IsUUFBUXdnQixXQUFXM3pELFVBQVU0ekQsTUFBTUM7SUFDdEMsT0FBTyxJQUFJO0FBQ2I7QUFDQXp0RSxFQUFFK3RFLEdBQUcsR0FBRyxTQUFVaGhCLE1BQU0sRUFBRXdnQixTQUFTLEVBQUUzekQsUUFBUSxFQUFFNHpELElBQUk7SUFDakQsT0FBTyxJQUFJLENBQUNsaUIsRUFBRSxDQUFDeUIsUUFBUXdnQixXQUFXM3pELFVBQVU0ekQsTUFBTTtRQUNoRE8sS0FBSztJQUNQO0FBQ0Y7QUFDQS90RSxFQUFFMHNELGNBQWMsR0FBRzFzRCxFQUFFd3ZCLEdBQUcsR0FBRyxTQUFVdTlCLE1BQU0sRUFBRXdnQixTQUFTLEVBQUUzekQsUUFBUSxFQUFFNHpELElBQUk7SUFDcEUsSUFBSS96RCxRQUFRLElBQUk7SUFDaEIsSUFBSSxJQUFJLENBQUMyekQsUUFBUSxLQUFLLEdBQUc7UUFDdkIsSUFBSSxDQUFDdnlELFNBQVMsR0FBRzNELFVBQVUsSUFBSSxDQUFDMkQsU0FBUztJQUMzQztJQUNBLElBQUlBLFlBQVksSUFBSSxDQUFDQSxTQUFTO0lBQzlCLElBQUk4RCxRQUFRLFNBQVNBLE1BQU0zbEIsQ0FBQztRQUMxQixJQUFJZzFFLFdBQVduekQsU0FBUyxDQUFDN2hCLEVBQUU7UUFDM0JxMEUsYUFBYTV6RCxPQUFPLFNBQVVyYyxLQUFJLEVBQUVwQixLQUFLLEVBQUVzUCxJQUFJLEVBQUV5Z0UsU0FBUyxFQUFFd0IsU0FBUyxFQUFFM3pELFNBQVMsUUFBUSxHQUFUO1lBQzdFLElBQUksQ0FBQ28wRCxTQUFTMWlFLElBQUksS0FBS0EsUUFBUXloRCxXQUFXLEdBQUUsS0FBTyxFQUFDZ2YsYUFBYWlDLFNBQVNqQyxTQUFTLEtBQUssUUFBUWlDLFNBQVNqQyxTQUFTLEtBQUtBLFNBQVEsS0FBTyxFQUFDd0IsYUFBYW53RSxNQUFLbXZFLGdCQUFnQixDQUFDeUIsU0FBU1QsU0FBUyxFQUFFQSxVQUFTLEtBQU8sRUFBQzN6RCxZQUFZbzBELFNBQVNwMEQsUUFBUSxLQUFLQSxRQUFPLEdBQUk7Z0JBQzFQaUIsVUFBVTVDLE1BQU0sQ0FBQ2pmLEdBQUc7Z0JBQ3BCLE9BQU87WUFDVDtRQUNGLEdBQUcrekQsUUFBUXdnQixXQUFXM3pELFVBQVU0ekQ7SUFDbEM7SUFDQSxJQUFLLElBQUl4MEUsSUFBSTZoQixVQUFVcGtCLE1BQU0sR0FBRyxHQUFHdUMsS0FBSyxHQUFHQSxJQUFLO1FBQzlDMmxCLE1BQU0zbEI7SUFDUjtJQUNBLE9BQU8sSUFBSTtBQUNiO0FBQ0FnSCxFQUFFaXVFLGtCQUFrQixHQUFHO0lBQ3JCLE9BQU8sSUFBSSxDQUFDdmhCLGNBQWMsQ0FBQztBQUM3QjtBQUNBMXNELEVBQUU0c0QsSUFBSSxHQUFHNXNELEVBQUUyc0QsT0FBTyxHQUFHLFNBQVVJLE1BQU0sRUFBRW1oQixXQUFXLEVBQUVDLGNBQWM7SUFDaEUsSUFBSXR6RCxZQUFZLElBQUksQ0FBQ0EsU0FBUztJQUM5QixJQUFJdXpELHlCQUF5QnZ6RCxVQUFVcGtCLE1BQU07SUFDN0MsSUFBSSxDQUFDMjJFLFFBQVE7SUFDYixJQUFJLENBQUNyeUUsTUFBTW16RSxjQUFjO1FBQ3ZCQSxjQUFjO1lBQUNBO1NBQVk7SUFDN0I7SUFDQUwsZ0JBQWdCLElBQUksRUFBRSxTQUFVendFLEtBQUksRUFBRTB3RSxRQUFRO1FBQzVDLElBQUlLLGtCQUFrQixNQUFNO1lBQzFCdHpELFlBQVk7Z0JBQUM7b0JBQ1g3ZSxPQUFPOHhFLFNBQVM5eEUsS0FBSztvQkFDckJzUCxNQUFNd2lFLFNBQVN4aUUsSUFBSTtvQkFDbkJ5Z0UsV0FBVytCLFNBQVMvQixTQUFTO29CQUM3Qm55RCxVQUFVdTBEO2dCQUNaO2FBQUU7WUFDRkMseUJBQXlCdnpELFVBQVVwa0IsTUFBTTtRQUMzQztRQUNBLElBQUk0M0UsU0FBUyxTQUFTQTtZQUNwQixJQUFJTCxXQUFXbnpELFNBQVMsQ0FBQzdoQixFQUFFO1lBQzNCLElBQUlnMUUsU0FBUzFpRSxJQUFJLEtBQUt3aUUsU0FBU3hpRSxJQUFJLElBQUssRUFBQzBpRSxTQUFTakMsU0FBUyxJQUFJaUMsU0FBU2pDLFNBQVMsS0FBSytCLFNBQVMvQixTQUFTLElBQUlpQyxTQUFTakMsU0FBUyxLQUFLTSxrQkFBaUIsS0FBTWp2RSxNQUFLc3ZFLFlBQVksQ0FBQ3R2RSxNQUFLeXZFLE9BQU8sRUFBRW1CLFVBQVVGLFdBQVc7Z0JBQzdNLElBQUk5d0UsT0FBTztvQkFBQzh3RTtpQkFBUztnQkFDckIsSUFBSUksZUFBZSxNQUFNO29CQUN2QmoxRSxLQUFLK0QsTUFBTWt4RTtnQkFDYjtnQkFDQTl3RSxNQUFLMHZFLFVBQVUsQ0FBQzF2RSxNQUFLeXZFLE9BQU8sRUFBRW1CLFVBQVVGO2dCQUN4QyxJQUFJRSxTQUFTUixJQUFJLElBQUlRLFNBQVNSLElBQUksQ0FBQ08sR0FBRyxFQUFFO29CQUN0QzN3RSxNQUFLeWQsU0FBUyxHQUFHemQsTUFBS3lkLFNBQVMsQ0FBQ25CLE1BQU0sQ0FBQyxTQUFVM2dCLENBQUM7d0JBQ2hELE9BQU9BLE1BQU1pMUU7b0JBQ2Y7Z0JBQ0Y7Z0JBQ0EsSUFBSW5CLFVBQVV6dkUsTUFBS3d2RSxlQUFlLENBQUN4dkUsTUFBS3l2RSxPQUFPLEVBQUVtQixVQUFVRjtnQkFDM0QsSUFBSXp3RSxNQUFNMndFLFNBQVNwMEQsUUFBUSxDQUFDcmMsS0FBSyxDQUFDc3ZFLFNBQVM3dkU7Z0JBQzNDSSxNQUFLMnZFLFNBQVMsQ0FBQzN2RSxNQUFLeXZFLE9BQU8sRUFBRW1CLFVBQVVGO2dCQUN2QyxJQUFJendFLFFBQVEsT0FBTztvQkFDakJ5d0UsU0FBUzVCLGVBQWU7b0JBQ3hCNEIsU0FBU2xDLGNBQWM7Z0JBQ3pCO1lBQ0YsRUFBRSxzQkFBc0I7UUFDMUI7UUFDQSxJQUFLLElBQUk1eUUsSUFBSSxHQUFHQSxJQUFJbzFFLHdCQUF3QnAxRSxJQUFLO1lBQy9DcTFFO1FBQ0YsRUFBRSxlQUFlO1FBRWpCLElBQUlqeEUsTUFBSzR2RSxNQUFNLENBQUM1dkUsTUFBS3l2RSxPQUFPLEtBQUssQ0FBQ2lCLFNBQVNwQyxvQkFBb0IsSUFBSTtZQUNqRXR1RSxNQUFLOGUsTUFBTSxDQUFDOWUsTUFBS3l2RSxPQUFPLEVBQUVqZ0IsSUFBSSxDQUFDa2hCLFVBQVVJO1FBQzNDO0lBQ0YsR0FBR25oQjtJQUNILElBQUksQ0FBQ3FnQixRQUFRO0lBQ2IsT0FBTyxJQUFJO0FBQ2I7QUFFQSxJQUFJa0IsbUJBQW1CO0lBQ3JCL0Isa0JBQWtCLFNBQVNBLGlCQUFpQmdDLFNBQVMsRUFBRUMsU0FBUztRQUM5RCxJQUFJRCxhQUFhLFFBQVFDLGFBQWEsTUFBTTtZQUMxQyxPQUFPRCxhQUFhLFFBQVFDLGFBQWE7UUFDM0MsT0FBTztZQUNMLE9BQU9ELFVBQVVoVyxRQUFRLENBQUNpVztRQUM1QjtJQUNGO0lBQ0E5QixjQUFjLFNBQVNBLGFBQWEzMEQsR0FBRyxFQUFFaTJELFFBQVEsRUFBRUYsUUFBUTtRQUN6RCxJQUFJOWdCLFdBQVdnaEIsU0FBU1QsU0FBUztRQUNqQyxJQUFJdmdCLFlBQVksTUFBTTtZQUNwQixPQUFPajFDLFFBQVErMUQsU0FBU3h6RCxNQUFNLElBQUk1ZSxRQUFRb3lFLFNBQVN4ekQsTUFBTSxLQUFLMHlDLFNBQVM4RCxPQUFPLENBQUNnZCxTQUFTeHpELE1BQU07UUFDaEc7UUFDQSxPQUFPO0lBQ1Q7SUFDQXF5RCxnQkFBZ0IsU0FBU0EsZUFBZTUwRCxHQUFHLEVBQUU0MUQsR0FBRztRQUM5Q0EsSUFBSTN6RCxFQUFFLEdBQUdqQyxJQUFJaUMsRUFBRTtRQUNmMnpELElBQUlyekQsTUFBTSxHQUFHdkM7SUFDZjtJQUNBNjBELGlCQUFpQixTQUFTQSxnQkFBZ0I3MEQsR0FBRyxFQUFFaTJELFFBQVEsRUFBRUYsUUFBUTtRQUMvRCxPQUFPRSxTQUFTVCxTQUFTLElBQUksT0FBT08sU0FBU3h6RCxNQUFNLEdBQUd2QztJQUN4RDtJQUNBKzBELFlBQVksU0FBU0EsV0FBV0QsT0FBTyxFQUFFbUIsU0FBUyxZQUFZLEdBQWI7UUFDL0MsSUFBSUEsU0FBU1IsSUFBSSxJQUFJUSxTQUFTUixJQUFJLENBQUNpQixJQUFJLEVBQUU7WUFDdkNULFNBQVNSLElBQUksQ0FBQ2tCLGNBQWMsQ0FBQ2hpQixjQUFjLENBQUNzaEIsU0FBU2h5RSxLQUFLLEVBQUVneUUsU0FBU1QsU0FBUyxFQUFFUyxTQUFTcDBELFFBQVE7UUFDbkc7SUFDRjtJQUNBb3pELFFBQVEsU0FBU0E7UUFDZixPQUFPO0lBQ1Q7SUFDQTl3RCxRQUFRLFNBQVNBLE9BQU9uRSxHQUFHO1FBQ3pCLE9BQU9BLElBQUltNUMsT0FBTyxLQUFLbjVDLElBQUltRSxNQUFNLEtBQUtuRSxJQUFJaUMsRUFBRTtJQUM5QztBQUNGO0FBQ0EsSUFBSTIwRCxnQkFBZ0IsU0FBU0MsWUFBWUMsR0FBRztJQUMxQyxJQUFJaDBFLE9BQU9nMEUsTUFBTTtRQUNmLE9BQU8sSUFBSTFXLFNBQVMwVztJQUN0QixPQUFPO1FBQ0wsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsSUFBSUMsV0FBVztJQUNiMXhELGVBQWUsU0FBU0E7UUFDdEIsSUFBSyxJQUFJcGtCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIsSUFBSXVoQixLQUFLeEMsSUFBSW5jLFFBQVE7WUFDckIsSUFBSSxDQUFDMmUsR0FBR3cwRCxPQUFPLEVBQUU7Z0JBQ2Z4MEQsR0FBR3cwRCxPQUFPLEdBQUcsSUFBSTVCLFFBQVFtQixrQkFBa0J2MkQ7WUFDN0M7UUFDRjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FnM0QsU0FBUyxTQUFTQTtRQUNoQixPQUFPLElBQUksQ0FBQ256RSxRQUFRLENBQUNtekUsT0FBTztJQUM5QjtJQUNBempCLElBQUksU0FBU0EsR0FBR3lCLE1BQU0sRUFBRUMsUUFBUSxFQUFFcHpDLFFBQVE7UUFDeEMsSUFBSW8xRCxTQUFTTCxjQUFjM2hCO1FBQzNCLElBQUssSUFBSWgwRCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJK2UsTUFBTSxJQUFJLENBQUMvZSxFQUFFO1lBQ2pCK2UsSUFBSWczRCxPQUFPLEdBQUd6akIsRUFBRSxDQUFDeUIsUUFBUWlpQixRQUFRcDFEO1FBQ25DO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQTh5QyxnQkFBZ0IsU0FBU0EsZUFBZUssTUFBTSxFQUFFQyxRQUFRLEVBQUVwekMsUUFBUTtRQUNoRSxJQUFJbzFELFNBQVNMLGNBQWMzaEI7UUFDM0IsSUFBSyxJQUFJaDBELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIrZSxJQUFJZzNELE9BQU8sR0FBR3JpQixjQUFjLENBQUNLLFFBQVFpaUIsUUFBUXAxRDtRQUMvQztRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FxMEQsb0JBQW9CLFNBQVNBO1FBQzNCLElBQUssSUFBSWoxRSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJK2UsTUFBTSxJQUFJLENBQUMvZSxFQUFFO1lBQ2pCK2UsSUFBSWczRCxPQUFPLEdBQUdkLGtCQUFrQjtRQUNsQztRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0FGLEtBQUssU0FBU0EsSUFBSWhoQixNQUFNLEVBQUVDLFFBQVEsRUFBRXB6QyxRQUFRO1FBQzFDLElBQUlvMUQsU0FBU0wsY0FBYzNoQjtRQUMzQixJQUFLLElBQUloMEQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtZQUNqQitlLElBQUlnM0QsT0FBTyxHQUFHaEIsR0FBRyxDQUFDaGhCLFFBQVFpaUIsUUFBUXAxRDtRQUNwQztRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0E2MEQsTUFBTSxTQUFTQSxLQUFLMWhCLE1BQU0sRUFBRUMsUUFBUSxFQUFFcHpDLFFBQVE7UUFDNUMsSUFBSW8xRCxTQUFTTCxjQUFjM2hCO1FBQzNCLElBQUssSUFBSWgwRCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdkMsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJK2UsTUFBTSxJQUFJLENBQUMvZSxFQUFFO1lBQ2pCK2UsSUFBSWczRCxPQUFPLEdBQUd6akIsRUFBRSxDQUFDeUIsUUFBUWlpQixRQUFRcDFELFVBQVU7Z0JBQ3pDNjBELE1BQU07Z0JBQ05DLGdCQUFnQixJQUFJO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBOWhCLE1BQU0sU0FBU0EsS0FBS0csTUFBTSxFQUFFbWhCLFdBQVc7UUFDckMsSUFBSyxJQUFJbDFFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIrZSxJQUFJZzNELE9BQU8sR0FBR25pQixJQUFJLENBQUNHLFFBQVFtaEI7UUFDN0I7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBNVAsZUFBZSxTQUFTQSxjQUFjdGlFLEtBQUssRUFBRWt5RSxXQUFXO1FBQ3RELHdCQUF3QjtRQUN4QixJQUFJLElBQUksQ0FBQ3ozRSxNQUFNLEtBQUssR0FBRztZQUNyQjtRQUNGLEVBQUUsa0RBQWtEO1FBRXBELGtCQUFrQjtRQUNsQixJQUFJLENBQUN1akIsRUFBRSxHQUFHc2hDLE1BQU0sQ0FBQ3QvQyxPQUFPLElBQUk7UUFDNUIsSUFBSSxDQUFDNHdELElBQUksQ0FBQzV3RCxPQUFPa3lFO1FBQ2pCLE9BQU8sSUFBSTtJQUNiO0FBQ0Y7QUFDQS9nQixPQUFPZixjQUFjLENBQUMwaUI7QUFFdEIsSUFBSUcsV0FBVztJQUNiM3dELE9BQU8sU0FBU0EsTUFBTTB1QyxRQUFRO1FBQzVCLE9BQU8sSUFBSSxDQUFDdHpDLE1BQU0sQ0FBQyxTQUFVM0IsR0FBRztZQUM5QixPQUFPQSxJQUFJb0UsTUFBTTtRQUNuQixHQUFHekMsTUFBTSxDQUFDc3pDO0lBQ1o7SUFDQWh4QyxPQUFPLFNBQVNBLE1BQU1neEMsUUFBUTtRQUM1QixPQUFPLElBQUksQ0FBQ3R6QyxNQUFNLENBQUMsU0FBVTNCLEdBQUc7WUFDOUIsT0FBT0EsSUFBSW02QixNQUFNO1FBQ25CLEdBQUd4NEIsTUFBTSxDQUFDc3pDO0lBQ1o7SUFDQSxxR0FBcUc7SUFDckczdUMsU0FBUyxTQUFTQTtRQUNoQixJQUFJQyxRQUFRLElBQUksQ0FBQ3FILEtBQUs7UUFDdEIsSUFBSTNKLFFBQVEsSUFBSSxDQUFDMkosS0FBSztRQUN0QixJQUFLLElBQUkzc0IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtZQUNqQixJQUFJK2UsSUFBSW9FLE1BQU0sSUFBSTtnQkFDaEJtQyxNQUFNcmxCLElBQUksQ0FBQzhlO1lBQ2IsT0FBTztnQkFDTGlFLE1BQU0vaUIsSUFBSSxDQUFDOGU7WUFDYjtRQUNGO1FBQ0EsT0FBTztZQUNMdUcsT0FBT0E7WUFDUHRDLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBdEMsUUFBUSxTQUFTQSxPQUFPdzFELE9BQU8sRUFBRTc5RCxPQUFPO1FBQ3RDLElBQUk2OUQsWUFBWTExRSxXQUFXO1lBQ3pCLDREQUE0RDtZQUM1RCxPQUFPLElBQUk7UUFDYixPQUFPLElBQUlxQixPQUFPcTBFLFlBQVlsMEUsb0JBQW9CazBFLFVBQVU7WUFDMUQsT0FBTyxJQUFJL1csU0FBUytXLFNBQVN4MUQsTUFBTSxDQUFDLElBQUk7UUFDMUMsT0FBTyxJQUFJOWUsS0FBS3MwRSxVQUFVO1lBQ3hCLElBQUlDLGFBQWEsSUFBSSxDQUFDeHBELEtBQUs7WUFDM0IsSUFBSTdCLE9BQU8sSUFBSTtZQUNmLElBQUssSUFBSTlxQixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO2dCQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO2dCQUNqQixJQUFJbzJFLFVBQVUvOUQsVUFBVTY5RCxRQUFRM3hFLEtBQUssQ0FBQzhULFNBQVM7b0JBQUMwRztvQkFBSy9lO29CQUFHOHFCO2lCQUFLLElBQUlvckQsUUFBUW4zRCxLQUFLL2UsR0FBRzhxQjtnQkFDakYsSUFBSXNyRCxTQUFTO29CQUNYRCxXQUFXbDJFLElBQUksQ0FBQzhlO2dCQUNsQjtZQUNGO1lBQ0EsT0FBT28zRDtRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUN4cEQsS0FBSyxJQUFJLHdEQUF3RDtJQUMvRTtJQUNBMjBDLEtBQUssU0FBU0EsSUFBSStVLFFBQVE7UUFDeEIsSUFBSSxDQUFDQSxVQUFVO1lBQ2IsT0FBTyxJQUFJO1FBQ2IsT0FBTztZQUNMLElBQUl4MEUsT0FBT3cwRSxXQUFXO2dCQUNwQkEsV0FBVyxJQUFJLENBQUMzMUQsTUFBTSxDQUFDMjFEO1lBQ3pCO1lBQ0EsSUFBSTlVLFdBQVcsSUFBSSxDQUFDNTBDLEtBQUs7WUFDekIsSUFBSyxJQUFJM3NCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO2dCQUNwQyxJQUFJMEMsVUFBVSxJQUFJLENBQUMxQyxFQUFFO2dCQUNyQixJQUFJczJFLFNBQVNELFNBQVN2MkQsR0FBRyxDQUFDcGQ7Z0JBQzFCLElBQUksQ0FBQzR6RSxRQUFRO29CQUNYL1UsU0FBU3RoRSxJQUFJLENBQUN5QztnQkFDaEI7WUFDRjtZQUNBLE9BQU82K0Q7UUFDVDtJQUNGO0lBQ0FnVixvQkFBb0IsU0FBU0E7UUFDM0IsSUFBSXYxRCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixPQUFPQSxHQUFHdzFELGVBQWUsR0FBR2xWLEdBQUcsQ0FBQyxJQUFJO0lBQ3RDO0lBQ0F6MUMsV0FBVyxTQUFTQSxVQUFValYsS0FBSztRQUNqQyx3REFBd0Q7UUFDeEQsSUFBSS9VLE9BQU8rVSxRQUFRO1lBQ2pCLElBQUlvOUMsV0FBV3A5QztZQUNmLE9BQU8sSUFBSSxDQUFDOEosTUFBTSxDQUFDc3pDO1FBQ3JCO1FBQ0EsSUFBSXVOLFdBQVcsSUFBSSxDQUFDNTBDLEtBQUs7UUFDekIsSUFBSThwRCxPQUFPLElBQUk7UUFDZixJQUFJQyxPQUFPOS9EO1FBQ1gsSUFBSSsvRCxjQUFjLElBQUksQ0FBQ2w1RSxNQUFNLEdBQUdtWixNQUFNblosTUFBTTtRQUM1QyxJQUFJbTVFLE9BQU9ELGNBQWNGLE9BQU9DO1FBQ2hDLElBQUlHLE9BQU9GLGNBQWNELE9BQU9EO1FBQ2hDLElBQUssSUFBSXoyRSxJQUFJLEdBQUdBLElBQUk0MkUsS0FBS241RSxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNNjNELElBQUksQ0FBQzUyRSxFQUFFO1lBQ2pCLElBQUk2MkUsS0FBSy8yRCxHQUFHLENBQUNmLE1BQU07Z0JBQ2pCd2lELFNBQVN0aEUsSUFBSSxDQUFDOGU7WUFDaEI7UUFDRjtRQUNBLE9BQU93aUQ7SUFDVDtJQUNBdVYsS0FBSyxTQUFTQSxJQUFJbGdFLEtBQUs7UUFDckIsSUFBSW9LLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtRQUN6QixJQUFJbmYsT0FBTytVLFFBQVE7WUFDakJBLFFBQVFvSyxHQUFHaVEsQ0FBQyxDQUFDcmE7UUFDZjtRQUNBLElBQUkycUQsV0FBVyxJQUFJLENBQUM1MEMsS0FBSztRQUN6QixJQUFJOHBELE9BQU8sSUFBSTtRQUNmLElBQUlDLE9BQU85L0Q7UUFDWCxJQUFJNEosTUFBTSxTQUFTQSxJQUFJNHRCLEdBQUcsRUFBRXgzQixLQUFLO1lBQy9CLElBQUssSUFBSTVXLElBQUksR0FBR0EsSUFBSW91QyxJQUFJM3dDLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ25DLElBQUkrZSxNQUFNcXZCLEdBQUcsQ0FBQ3B1QyxFQUFFO2dCQUNoQixJQUFJeWxCLEtBQUsxRyxJQUFJbmMsUUFBUSxDQUFDd2UsSUFBSSxDQUFDcUUsRUFBRTtnQkFDN0IsSUFBSXN4RCxVQUFVbmdFLE1BQU1vWSxnQkFBZ0IsQ0FBQ3ZKO2dCQUNyQyxJQUFJLENBQUNzeEQsU0FBUztvQkFDWnhWLFNBQVN0aEUsSUFBSSxDQUFDOGU7Z0JBQ2hCO1lBQ0Y7UUFDRjtRQUNBeUIsSUFBSWkyRCxNQUFNQztRQUNWbDJELElBQUlrMkQsTUFBTUQ7UUFDVixPQUFPbFY7SUFDVDtJQUNBcDRCLE1BQU0sU0FBU0EsS0FBS3Z5QixLQUFLO1FBQ3ZCLElBQUlvSyxLQUFLLElBQUksQ0FBQ3BlLFFBQVEsQ0FBQ29lLEVBQUU7UUFDekIsSUFBSW5mLE9BQU8rVSxRQUFRO1lBQ2pCQSxRQUFRb0ssR0FBR2lRLENBQUMsQ0FBQ3JhO1FBQ2Y7UUFDQSxJQUFJaWlCLE9BQU8sSUFBSSxDQUFDbE0sS0FBSztRQUNyQixJQUFJZ00sUUFBUSxJQUFJLENBQUNoTSxLQUFLO1FBQ3RCLElBQUlxcUQsT0FBTyxJQUFJLENBQUNycUQsS0FBSztRQUNyQixJQUFJOHBELE9BQU8sSUFBSTtRQUNmLElBQUlDLE9BQU85L0Q7UUFDWCxJQUFJNEosTUFBTSxTQUFTQSxJQUFJNHRCLEdBQUcsRUFBRXgzQixLQUFLLEVBQUVxZ0UsT0FBTztZQUN4QyxJQUFLLElBQUlqM0UsSUFBSSxHQUFHQSxJQUFJb3VDLElBQUkzd0MsTUFBTSxFQUFFdUMsSUFBSztnQkFDbkMsSUFBSStlLE1BQU1xdkIsR0FBRyxDQUFDcHVDLEVBQUU7Z0JBQ2hCLElBQUl5bEIsS0FBSzFHLElBQUluYyxRQUFRLENBQUN3ZSxJQUFJLENBQUNxRSxFQUFFO2dCQUM3QixJQUFJc3hELFVBQVVuZ0UsTUFBTW9ZLGdCQUFnQixDQUFDdko7Z0JBQ3JDLElBQUlzeEQsU0FBUztvQkFDWEMsS0FBSzFwRCxLQUFLLENBQUN2TztnQkFDYixPQUFPO29CQUNMazRELFFBQVFoM0UsSUFBSSxDQUFDOGU7Z0JBQ2Y7WUFDRjtRQUNGO1FBQ0F5QixJQUFJaTJELE1BQU1DLE1BQU03OUM7UUFDaEJyWSxJQUFJazJELE1BQU1ELE1BQU05OUM7UUFDaEIsT0FBTztZQUNMRSxNQUFNQTtZQUNORixPQUFPQTtZQUNQcStDLE1BQU1BO1FBQ1I7SUFDRjtJQUNBeDJELEtBQUssU0FBU0EsSUFBSTAyRCxLQUFLO1FBQ3JCLElBQUlsMkQsS0FBSyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFO1FBQ3pCLElBQUksQ0FBQ2syRCxPQUFPO1lBQ1YsT0FBTyxJQUFJO1FBQ2I7UUFDQSxJQUFJcjFFLE9BQU9xMUUsUUFBUTtZQUNqQixJQUFJbGpCLFdBQVdrakI7WUFDZkEsUUFBUWwyRCxHQUFHdzFELGVBQWUsR0FBRzkxRCxNQUFNLENBQUNzekM7UUFDdEM7UUFDQSxJQUFJdU4sV0FBVyxJQUFJLENBQUM0VixTQUFTO1FBQzdCLElBQUssSUFBSW4zRSxJQUFJLEdBQUdBLElBQUlrM0UsTUFBTXo1RSxNQUFNLEVBQUV1QyxJQUFLO1lBQ3JDLElBQUkrZSxNQUFNbTRELEtBQUssQ0FBQ2wzRSxFQUFFO1lBQ2xCLElBQUl3Z0IsTUFBTSxDQUFDLElBQUksQ0FBQ1YsR0FBRyxDQUFDZjtZQUNwQixJQUFJeUIsS0FBSztnQkFDUCtnRCxTQUFTdGhFLElBQUksQ0FBQzhlO1lBQ2hCO1FBQ0Y7UUFDQSxPQUFPd2lEO0lBQ1Q7SUFDQSx1Q0FBdUM7SUFDdkNqMEMsT0FBTyxTQUFTQSxNQUFNNHBELEtBQUs7UUFDekIsSUFBSTMxRCxLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSW9lLEtBQUtPLEdBQUdQLEVBQUU7UUFDZCxJQUFJLENBQUNrMkQsT0FBTztZQUNWLE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSUEsU0FBU3IxRSxPQUFPcTFFLFFBQVE7WUFDMUIsSUFBSWxqQixXQUFXa2pCO1lBQ2ZBLFFBQVFsMkQsR0FBR3cxRCxlQUFlLEdBQUc5MUQsTUFBTSxDQUFDc3pDO1FBQ3RDO1FBQ0EsSUFBSXhpRCxNQUFNK1AsR0FBRy9QLEdBQUc7UUFDaEIsSUFBSyxJQUFJeFIsSUFBSSxHQUFHQSxJQUFJazNFLE1BQU16NUUsTUFBTSxFQUFFdUMsSUFBSztZQUNyQyxJQUFJbzNFLFdBQVdGLEtBQUssQ0FBQ2wzRSxFQUFFO1lBQ3ZCLElBQUl5bEIsS0FBSzJ4RCxTQUFTeDBFLFFBQVEsQ0FBQ3dlLElBQUksQ0FBQ3FFLEVBQUU7WUFDbEMsSUFBSWpGLE1BQU0sQ0FBQ2hQLElBQUlzTyxHQUFHLENBQUMyRjtZQUNuQixJQUFJakYsS0FBSztnQkFDUCxJQUFJN00sUUFBUSxJQUFJLENBQUNsVyxNQUFNO2dCQUN2QixJQUFJLENBQUNrVyxNQUFNLEdBQUd5akU7Z0JBQ2Q1bEUsSUFBSWtPLEdBQUcsQ0FBQytGLElBQUk7b0JBQ1YxRyxLQUFLcTREO29CQUNMempFLE9BQU9BO2dCQUNUO1lBQ0Y7UUFDRjtRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQTBqRSxXQUFXLFNBQVNBLFVBQVVyM0UsQ0FBQztRQUM3QixJQUFJK2UsTUFBTSxJQUFJLENBQUMvZSxFQUFFO1FBQ2pCLElBQUl5bEIsS0FBSzFHLElBQUkwRyxFQUFFO1FBQ2YsSUFBSWxFLEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QixJQUFJNE8sTUFBTStQLEdBQUcvUCxHQUFHO1FBRWhCLGFBQWE7UUFDYixJQUFJLENBQUN4UixFQUFFLEdBQUdRO1FBQ1ZnUixHQUFHLENBQUMsU0FBUyxDQUFDaVU7UUFDZCxJQUFJNnhELGtCQUFrQnQzRSxNQUFNLElBQUksQ0FBQ3ZDLE1BQU0sR0FBRztRQUUxQyxpREFBaUQ7UUFDakQsSUFBSSxJQUFJLENBQUNBLE1BQU0sR0FBRyxLQUFLLENBQUM2NUUsaUJBQWlCO1lBQ3ZDLElBQUlDLFdBQVcsSUFBSSxDQUFDOTVFLE1BQU0sR0FBRztZQUM3QixJQUFJKzVFLFVBQVUsSUFBSSxDQUFDRCxTQUFTO1lBQzVCLElBQUlFLFlBQVlELFFBQVE1MEUsUUFBUSxDQUFDd2UsSUFBSSxDQUFDcUUsRUFBRTtZQUN4QyxJQUFJLENBQUM4eEQsU0FBUyxHQUFHLzJFO1lBQ2pCLElBQUksQ0FBQ1IsRUFBRSxHQUFHdzNFO1lBQ1ZobUUsSUFBSWtPLEdBQUcsQ0FBQyszRCxXQUFXO2dCQUNqQjE0RCxLQUFLeTREO2dCQUNMN2pFLE9BQU8zVDtZQUNUO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdEMsSUFBSSxDQUFDdkMsTUFBTTtRQUNYLE9BQU8sSUFBSTtJQUNiO0lBQ0EsbURBQW1EO0lBQ25EaTZFLFlBQVksU0FBU0EsV0FBVzM0RCxHQUFHO1FBQ2pDQSxNQUFNQSxHQUFHLENBQUMsRUFBRTtRQUNaLElBQUl3QyxLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSTZpQixLQUFLMUcsSUFBSW5jLFFBQVEsQ0FBQ3dlLElBQUksQ0FBQ3FFLEVBQUU7UUFDN0IsSUFBSWpVLE1BQU0rUCxHQUFHL1AsR0FBRztRQUNoQixJQUFJNEksUUFBUTVJLElBQUl1TyxHQUFHLENBQUMwRjtRQUNwQixJQUFJLENBQUNyTCxPQUFPO1lBQ1YsT0FBTyxJQUFJLEVBQUUsb0JBQW9CO1FBQ25DO1FBQ0EsSUFBSXBhLElBQUlvYSxNQUFNekcsS0FBSztRQUNuQixJQUFJLENBQUMwakUsU0FBUyxDQUFDcjNFO1FBQ2YsT0FBTyxJQUFJO0lBQ2I7SUFDQSw2Q0FBNkM7SUFDN0MyM0UsU0FBUyxTQUFTQSxRQUFRdEIsUUFBUTtRQUNoQyxJQUFJcjFELEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtRQUN6QixJQUFJLENBQUNxMUQsVUFBVTtZQUNiLE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSUEsWUFBWXgwRSxPQUFPdzBFLFdBQVc7WUFDaEMsSUFBSXJpQixXQUFXcWlCO1lBQ2ZBLFdBQVdyMUQsR0FBR3cxRCxlQUFlLEdBQUc5MUQsTUFBTSxDQUFDc3pDO1FBQ3pDO1FBQ0EsSUFBSyxJQUFJaDBELElBQUksR0FBR0EsSUFBSXEyRSxTQUFTNTRFLE1BQU0sRUFBRXVDLElBQUs7WUFDeEMsSUFBSSxDQUFDMDNFLFVBQVUsQ0FBQ3JCLFFBQVEsQ0FBQ3IyRSxFQUFFO1FBQzdCO1FBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztJQUMxQjtJQUNBbXJCLFdBQVcsU0FBU0EsVUFBVXlzRCxNQUFNO1FBQ2xDLElBQUssSUFBSTUzRSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sR0FBRyxHQUFHdUMsS0FBSyxHQUFHQSxJQUFLO1lBQ3pDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIsSUFBSTQzRSxPQUFPNzRELE1BQU07Z0JBQ2YsSUFBSSxDQUFDczRELFNBQVMsQ0FBQ3IzRTtZQUNqQjtRQUNGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQXdSLEtBQUssU0FBU0EsSUFBSXFtRSxLQUFLLEVBQUV4L0QsT0FBTztRQUM5QixJQUFJOEYsTUFBTSxFQUFFO1FBQ1osSUFBSTJNLE9BQU8sSUFBSTtRQUNmLElBQUssSUFBSTlxQixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNK0wsSUFBSSxDQUFDOXFCLEVBQUU7WUFDakIsSUFBSXFFLE1BQU1nVSxVQUFVdy9ELE1BQU10ekUsS0FBSyxDQUFDOFQsU0FBUztnQkFBQzBHO2dCQUFLL2U7Z0JBQUc4cUI7YUFBSyxJQUFJK3NELE1BQU05NEQsS0FBSy9lLEdBQUc4cUI7WUFDekUzTSxJQUFJbGUsSUFBSSxDQUFDb0U7UUFDWDtRQUNBLE9BQU84WjtJQUNUO0lBQ0FxL0MsUUFBUSxTQUFTQSxPQUFPMTdELEVBQUUsRUFBRWcyRSxZQUFZO1FBQ3RDLElBQUluNEQsTUFBTW00RDtRQUNWLElBQUlodEQsT0FBTyxJQUFJO1FBQ2YsSUFBSyxJQUFJOXFCLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMyZixNQUFNN2QsR0FBRzZkLEtBQUttTCxJQUFJLENBQUM5cUIsRUFBRSxFQUFFQSxHQUFHOHFCO1FBQzVCO1FBQ0EsT0FBT25MO0lBQ1Q7SUFDQXZJLEtBQUssU0FBU0EsSUFBSTJnRSxLQUFLLEVBQUUxL0QsT0FBTztRQUM5QixJQUFJakIsTUFBTSxDQUFDb1U7UUFDWCxJQUFJd3NEO1FBQ0osSUFBSWx0RCxPQUFPLElBQUk7UUFDZixJQUFLLElBQUk5cUIsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO1lBQ2pCLElBQUkyZixNQUFNdEgsVUFBVTAvRCxNQUFNeHpFLEtBQUssQ0FBQzhULFNBQVM7Z0JBQUMwRztnQkFBSy9lO2dCQUFHOHFCO2FBQUssSUFBSWl0RCxNQUFNaDVELEtBQUsvZSxHQUFHOHFCO1lBQ3pFLElBQUluTCxNQUFNdkksS0FBSztnQkFDYkEsTUFBTXVJO2dCQUNOcTRELFNBQVNqNUQ7WUFDWDtRQUNGO1FBQ0EsT0FBTztZQUNMMWYsT0FBTytYO1lBQ1AySCxLQUFLaTVEO1FBQ1A7SUFDRjtJQUNBMWdFLEtBQUssU0FBU0EsSUFBSXlnRSxLQUFLLEVBQUUxL0QsT0FBTztRQUM5QixJQUFJZixNQUFNa1U7UUFDVixJQUFJeXNEO1FBQ0osSUFBSW50RCxPQUFPLElBQUk7UUFDZixJQUFLLElBQUk5cUIsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO1lBQ2pCLElBQUkyZixNQUFNdEgsVUFBVTAvRCxNQUFNeHpFLEtBQUssQ0FBQzhULFNBQVM7Z0JBQUMwRztnQkFBSy9lO2dCQUFHOHFCO2FBQUssSUFBSWl0RCxNQUFNaDVELEtBQUsvZSxHQUFHOHFCO1lBQ3pFLElBQUluTCxNQUFNckksS0FBSztnQkFDYkEsTUFBTXFJO2dCQUNOczRELFNBQVNsNUQ7WUFDWDtRQUNGO1FBQ0EsT0FBTztZQUNMMWYsT0FBT2lZO1lBQ1B5SCxLQUFLazVEO1FBQ1A7SUFDRjtBQUNGO0FBRUEsVUFBVTtBQUNWLElBQUlDLE9BQU9qQztBQUNYaUMsSUFBSSxDQUFDLElBQUksR0FBR0EsSUFBSSxDQUFDLElBQUksR0FBR0EsSUFBSSxDQUFDLElBQUksR0FBR0EsS0FBS0MsS0FBSyxHQUFHRCxLQUFLRSxFQUFFLEdBQUdGLEtBQUsxM0QsR0FBRztBQUNuRTAzRCxJQUFJLENBQUMsS0FBSyxHQUFHQSxJQUFJLENBQUMsSUFBSSxHQUFHQSxJQUFJLENBQUMsSUFBSSxHQUFHQSxLQUFLNThCLFVBQVUsR0FBRzQ4QixLQUFLRyxrQkFBa0IsR0FBR0gsS0FBS0ksUUFBUSxHQUFHSixLQUFLNVcsR0FBRztBQUN6RzRXLElBQUksQ0FBQyxJQUFJLEdBQUdBLElBQUksQ0FBQyxJQUFJLEdBQUdBLElBQUksQ0FBQyxJQUFJLEdBQUdBLEtBQUtLLEdBQUcsR0FBR0wsS0FBSzEyQyxZQUFZLEdBQUcwMkMsS0FBS3JzRCxTQUFTO0FBQ2pGcXNELElBQUksQ0FBQyxJQUFJLEdBQUdBLElBQUksQ0FBQyxNQUFNLEdBQUdBLElBQUksQ0FBQyxNQUFNLEdBQUdBLEtBQUtNLG1CQUFtQixHQUFHTixLQUFLTyxPQUFPLEdBQUdQLEtBQUtwQixHQUFHO0FBQzFGb0IsS0FBS1EsUUFBUSxHQUFHUixLQUFLUyxRQUFRLEdBQUdULEtBQUtoWCxTQUFTLEdBQUdnWCxLQUFLeDNELE1BQU07QUFDNUR3M0QsS0FBS1UsVUFBVSxHQUFHVixLQUFLVyxPQUFPLEdBQUdYLEtBQUszQixrQkFBa0I7QUFFeEQsSUFBSXVDLFdBQVc7SUFDYjMxRCxRQUFRLFNBQVNBO1FBQ2YsT0FBTyxJQUFJLENBQUNoQyxLQUFLLE9BQU87SUFDMUI7SUFDQSszQixRQUFRLFNBQVNBO1FBQ2YsT0FBTyxJQUFJLENBQUMvM0IsS0FBSyxPQUFPO0lBQzFCO0lBQ0FpSyxRQUFRLFNBQVNBO1FBQ2YsT0FBTyxJQUFJLENBQUM4dEIsTUFBTSxNQUFNLElBQUksQ0FBQzczQixNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDQyxNQUFNLEVBQUUsQ0FBQyxFQUFFO0lBQy9EO0lBQ0E4MkMsVUFBVSxTQUFTQTtRQUNqQixPQUFPLElBQUksQ0FBQ2xmLE1BQU0sTUFBTSxJQUFJLENBQUM3M0IsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLElBQUksQ0FBQ0MsTUFBTSxFQUFFLENBQUMsRUFBRTtJQUMvRDtJQUNBSCxPQUFPLFNBQVNBO1FBQ2QsSUFBSXBDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSUEsS0FBSztZQUNQLE9BQU9BLElBQUluYyxRQUFRLENBQUN1ZSxLQUFLO1FBQzNCO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsSUFBSTQzRCxhQUFhLFNBQVNBLFdBQVd2N0UsQ0FBQyxFQUFFc0ksQ0FBQztJQUN2QyxJQUFJa2IsS0FBS3hqQixFQUFFd2pCLEVBQUU7SUFDYixJQUFJNmdELG1CQUFtQjdnRCxHQUFHNmdELGdCQUFnQjtJQUMxQyxTQUFTbVgsU0FBU2o2RCxHQUFHO1FBQ25CLElBQUkrQyxRQUFRL0MsSUFBSTRtRCxNQUFNLENBQUM7UUFDdkIsSUFBSTdqRCxNQUFNemlCLEtBQUssS0FBSyxRQUFRO1lBQzFCLE9BQU93aUUsbUJBQW1COWlELElBQUlrNkQsTUFBTSxLQUFLO1FBQzNDLE9BQU8sSUFBSW4zRCxNQUFNemlCLEtBQUssS0FBSyxVQUFVO1lBQ25DLE9BQU8sQ0FBQztRQUNWLE9BQU8sSUFBSXlpQixNQUFNemlCLEtBQUssS0FBSyxPQUFPO1lBQ2hDLE9BQU84ZDtRQUNUO1FBQ0EsV0FBVztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUkrN0QsWUFBWUYsU0FBU3g3RSxLQUFLdzdFLFNBQVNsekU7SUFDdkMsSUFBSW96RSxjQUFjLEdBQUc7UUFDbkIsT0FBT0E7SUFDVDtJQUNBLFNBQVNDLFlBQVlwNkQsR0FBRztRQUN0QixJQUFJK0MsUUFBUS9DLElBQUk0bUQsTUFBTSxDQUFDO1FBQ3ZCLElBQUk3akQsTUFBTXppQixLQUFLLEtBQUssUUFBUTtZQUMxQixPQUFPMGYsSUFBSW9FLE1BQU0sS0FBSyxJQUFJO1FBQzVCO1FBQ0EsV0FBVztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUlpMkQsVUFBVUQsWUFBWTM3RSxLQUFLMjdFLFlBQVlyekU7SUFDM0MsSUFBSXN6RSxZQUFZLEdBQUc7UUFDakIsT0FBT0E7SUFDVDtJQUNBLElBQUlDLFFBQVE3N0UsRUFBRW1vRSxNQUFNLENBQUMsV0FBV3RtRSxLQUFLLEdBQUd5RyxFQUFFNi9ELE1BQU0sQ0FBQyxXQUFXdG1FLEtBQUs7SUFDakUsSUFBSWc2RSxVQUFVLEdBQUc7UUFDZixPQUFPQTtJQUNUO0lBQ0Esb0VBQW9FO0lBQ3BFLE9BQU83N0UsRUFBRTg3RSxTQUFTLEtBQUt4ekUsRUFBRXd6RSxTQUFTO0FBQ3BDO0FBRUEsSUFBSUMsV0FBVztJQUNiNTRELFNBQVMsU0FBU0EsUUFBUTdlLEVBQUUsRUFBRXVXLE9BQU87UUFDbkMsSUFBSXpXLEtBQUtFLEtBQUs7WUFDWixJQUFJMnRCLElBQUksSUFBSSxDQUFDaHlCLE1BQU07WUFDbkIsSUFBSyxJQUFJdUMsSUFBSSxHQUFHQSxJQUFJeXZCLEdBQUd6dkIsSUFBSztnQkFDMUIsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtnQkFDakIsSUFBSXFFLE1BQU1nVSxVQUFVdlcsR0FBR3lDLEtBQUssQ0FBQzhULFNBQVM7b0JBQUMwRztvQkFBSy9lO29CQUFHLElBQUk7aUJBQUMsSUFBSThCLEdBQUdpZCxLQUFLL2UsR0FBRyxJQUFJO2dCQUN2RSxJQUFJcUUsUUFBUSxPQUFPO29CQUNqQjtnQkFDRixFQUFFLGtDQUFrQztZQUN0QztRQUNGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQWtjLFNBQVMsU0FBU0E7UUFDaEIsSUFBSXhlLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSS9CLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDK0IsTUFBTTlCLElBQUksQ0FBQyxJQUFJLENBQUNELEVBQUU7UUFDcEI7UUFDQSxPQUFPK0I7SUFDVDtJQUNBbEIsT0FBTyxTQUFTQSxNQUFNNnhCLEtBQUssRUFBRXZCLEdBQUc7UUFDOUIsSUFBSXB2QixRQUFRLEVBQUU7UUFDZCxJQUFJeTNFLFdBQVcsSUFBSSxDQUFDLzdFLE1BQU07UUFDMUIsSUFBSTB6QixPQUFPLE1BQU07WUFDZkEsTUFBTXFvRDtRQUNSO1FBQ0EsSUFBSTltRCxTQUFTLE1BQU07WUFDakJBLFFBQVE7UUFDVjtRQUNBLElBQUlBLFFBQVEsR0FBRztZQUNiQSxRQUFROG1ELFdBQVc5bUQ7UUFDckI7UUFDQSxJQUFJdkIsTUFBTSxHQUFHO1lBQ1hBLE1BQU1xb0QsV0FBV3JvRDtRQUNuQjtRQUNBLElBQUssSUFBSW54QixJQUFJMHlCLE9BQU8xeUIsS0FBSyxLQUFLQSxJQUFJbXhCLE9BQU9ueEIsSUFBSXc1RSxVQUFVeDVFLElBQUs7WUFDMUQrQixNQUFNOUIsSUFBSSxDQUFDLElBQUksQ0FBQ0QsRUFBRTtRQUNwQjtRQUNBLE9BQU8sSUFBSSxDQUFDMnNCLEtBQUssQ0FBQzVxQjtJQUNwQjtJQUNBdWUsTUFBTSxTQUFTQTtRQUNiLE9BQU8sSUFBSSxDQUFDN2lCLE1BQU07SUFDcEI7SUFDQXFxRCxJQUFJLFNBQVNBLEdBQUc5bkQsQ0FBQztRQUNmLE9BQU8sSUFBSSxDQUFDQSxFQUFFLElBQUksSUFBSSxDQUFDMnNCLEtBQUs7SUFDOUI7SUFDQThzRCxPQUFPLFNBQVNBO1FBQ2QsT0FBTyxJQUFJLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQzlzRCxLQUFLO0lBQzlCO0lBQ0Erc0QsTUFBTSxTQUFTQTtRQUNiLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ2o4RSxNQUFNLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQ2t2QixLQUFLO0lBQzVDO0lBQ0EzQyxPQUFPLFNBQVNBO1FBQ2QsT0FBTyxJQUFJLENBQUN2c0IsTUFBTSxLQUFLO0lBQ3pCO0lBQ0FzakUsVUFBVSxTQUFTQTtRQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLzJDLEtBQUs7SUFDcEI7SUFDQVgsTUFBTSxTQUFTQSxLQUFLc3dELE1BQU07UUFDeEIsSUFBSSxDQUFDLzNFLEtBQUsrM0UsU0FBUztZQUNqQixPQUFPLElBQUk7UUFDYjtRQUNBLElBQUlDLFNBQVMsSUFBSSxDQUFDcjVELE9BQU8sR0FBRzhJLElBQUksQ0FBQ3N3RDtRQUNqQyxPQUFPLElBQUksQ0FBQ2h0RCxLQUFLLENBQUNpdEQ7SUFDcEI7SUFDQUMsY0FBYyxTQUFTQTtRQUNyQixPQUFPLElBQUksQ0FBQ3h3RCxJQUFJLENBQUMwdkQ7SUFDbkI7SUFDQUUsUUFBUSxTQUFTQTtRQUNmLElBQUlsNkQsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJLENBQUNBLEtBQUs7WUFDUixPQUFPdmU7UUFDVDtRQUVBLHFCQUFxQjtRQUNyQixJQUFJK2dCLEtBQUt4QyxJQUFJbmMsUUFBUTtRQUNyQixJQUFJdWUsUUFBUUksR0FBR0osS0FBSztRQUNwQixJQUFJQSxVQUFVLFNBQVM7WUFDckIsSUFBSTRFLFFBQVF4RSxHQUFHSCxJQUFJLENBQUM4QixNQUFNLEdBQUduRSxJQUFJK2hELE9BQU8sR0FBR3hnRCxJQUFJLEtBQUs7WUFDcEQsSUFBSSxDQUFDdkIsSUFBSWk1QyxRQUFRLElBQUk7Z0JBQ25CLE9BQU83NkMsWUFBWSxHQUFHLGdDQUFnQztZQUN4RDtZQUNBLE9BQU80STtRQUNULE9BQU87WUFDTCxJQUFJRSxNQUFNMUUsR0FBR0YsTUFBTTtZQUNuQixJQUFJbGIsTUFBTW9iLEdBQUdELE1BQU07WUFDbkIsSUFBSXc0RCxXQUFXN3pELElBQUlnekQsTUFBTTtZQUN6QixJQUFJYyxXQUFXNXpFLElBQUk4eUUsTUFBTTtZQUN6QixPQUFPMTJFLEtBQUs2VSxHQUFHLENBQUMwaUUsVUFBVUMsVUFBVSxJQUFJLDBCQUEwQjtRQUNwRTtJQUNGO0FBQ0Y7QUFDQVIsU0FBU1MsSUFBSSxHQUFHVCxTQUFTNTRELE9BQU87QUFDaEMsSUFBSXM1RCx1QkFBdUIsU0FBU0E7SUFDbEMsSUFBSUMsY0FBYztJQUNsQixJQUFJQyxzQkFBc0IsQ0FBQyxPQUFPcDdFLFdBQVcsY0FBYyxjQUFjMkIsUUFBUTNCLE9BQU0sS0FBTW03RSxlQUFleDVFLFFBQVEzQixPQUFPQyxRQUFRLEtBQUtrN0U7SUFDeEksSUFBSUMscUJBQXFCO1FBQ3ZCWixRQUFRLENBQUN4NkUsT0FBT0MsUUFBUSxDQUFDLEdBQUc7WUFDMUIsSUFBSXloQixRQUFRLElBQUk7WUFDaEIsSUFBSXJHLFFBQVE7Z0JBQ1YvYSxPQUFPbUI7Z0JBQ1BwQixNQUFNO1lBQ1I7WUFDQSxJQUFJWSxJQUFJO1lBQ1IsSUFBSXZDLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1lBQ3hCLE9BQU9rQyxrQkFBa0I7Z0JBQ3ZCRixNQUFNLFNBQVNBO29CQUNiLElBQUlPLElBQUl2QyxRQUFRO3dCQUNkMmMsTUFBTS9hLEtBQUssR0FBR29oQixLQUFLLENBQUN6Z0IsSUFBSTtvQkFDMUIsT0FBTzt3QkFDTG9hLE1BQU0vYSxLQUFLLEdBQUdtQjt3QkFDZDRaLE1BQU1oYixJQUFJLEdBQUc7b0JBQ2Y7b0JBQ0EsT0FBT2diO2dCQUNUO1lBQ0YsR0FBR3JiLE9BQU9DLFFBQVEsRUFBRTtnQkFDbEIsT0FBTyxJQUFJO1lBQ2I7UUFDRjtJQUNGO0FBQ0Y7QUFDQWk3RTtBQUVBLElBQUlHLDRCQUE0QjU3RCxXQUFXO0lBQ3pDNjdELDZCQUE2QjtBQUMvQjtBQUNBLElBQUlDLFdBQVc7SUFDYix5RUFBeUU7SUFDekVDLGtCQUFrQixTQUFTQSxpQkFBaUJocEUsT0FBTztRQUNqREEsVUFBVTZvRSwwQkFBMEI3b0U7UUFDcEMsSUFBSWlwRTtRQUNKLElBQUksQ0FBQyxJQUFJLENBQUN6SixZQUFZLElBQUk7WUFDeEJ5SixPQUFPO2dCQUNMOTlELEdBQUc7Z0JBQ0g1VixHQUFHO1lBQ0w7UUFDRixPQUFPLElBQUl5SyxRQUFROG9FLDJCQUEyQixFQUFFO1lBQzlDLElBQUlJLFFBQVEsSUFBSSxDQUFDcjNFLFdBQVc7WUFDNUJvM0UsT0FBTztnQkFDTDk5RCxHQUFHKzlELE1BQU0vOUQsQ0FBQztnQkFDVjVWLEdBQUcyekUsTUFBTTN6RSxDQUFDO1lBQ1o7UUFDRixPQUFPO1lBQ0wwekUsT0FBTztnQkFDTDk5RCxHQUFHLElBQUksQ0FBQ3F3RCxVQUFVO2dCQUNsQmptRSxHQUFHLElBQUksQ0FBQ2ttRSxXQUFXO1lBQ3JCO1FBQ0Y7UUFFQSx3RUFBd0U7UUFDeEUsSUFBSXdOLEtBQUs5OUQsQ0FBQyxLQUFLLEtBQUs4OUQsS0FBSzF6RSxDQUFDLEtBQUssR0FBRztZQUNoQzB6RSxLQUFLOTlELENBQUMsR0FBRzg5RCxLQUFLMXpFLENBQUMsR0FBRztRQUNwQjtRQUNBLE9BQU8wekU7SUFDVDtJQUNBLCtFQUErRTtJQUMvRUUsaUJBQWlCLFNBQVNBLGdCQUFnQjFILE1BQU0sRUFBRXpoRSxPQUFPLEVBQUV6UCxFQUFFO1FBQzNELElBQUl3akIsUUFBUSxJQUFJLENBQUNBLEtBQUssR0FBRzVFLE1BQU0sQ0FBQyxTQUFVL2lCLENBQUM7WUFDekMsT0FBTyxDQUFDQSxFQUFFcTZELFFBQVE7UUFDcEI7UUFDQSxJQUFJaDNDLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUkyNUQsYUFBYXBwRSxRQUFRdVosSUFBSSxFQUFFLGdCQUFnQjtRQUMvQyxJQUFJOHZELGdCQUFnQixTQUFTQSxjQUFjajBELElBQUk7WUFDN0MsT0FBT0EsS0FBS2xCLEVBQUU7UUFDaEI7UUFDQSxJQUFJbzFELFFBQVFoM0UsUUFBUS9CLElBQUk4NEUsZ0JBQWdCLHdDQUF3QztRQUVoRjVILE9BQU9wZixJQUFJLENBQUM7WUFDVnRoRCxNQUFNO1lBQ04wZ0UsUUFBUUE7UUFDVjtRQUNBQSxPQUFPOEgsVUFBVSxHQUFHLEVBQUU7UUFDdEIsSUFBSUMsbUJBQW1CLFNBQVNBLGlCQUFpQkMsT0FBTyxFQUFFQyxPQUFPLEVBQUV6K0QsR0FBRztZQUNwRSxJQUFJNmtDLFNBQVM7Z0JBQ1h0dkMsR0FBR2twRSxRQUFRNTNFLEVBQUUsR0FBRzQzRSxRQUFRditELENBQUMsR0FBRztnQkFDNUJsQixHQUFHeS9ELFFBQVExM0UsRUFBRSxHQUFHMDNFLFFBQVFuMEUsQ0FBQyxHQUFHO1lBQzlCO1lBQ0EsSUFBSW8wRSxnQkFBZ0I7Z0JBQ2xCLDBEQUEwRDtnQkFDMURucEUsR0FBRyxDQUFDeUssSUFBSXpLLENBQUMsR0FBR3N2QyxPQUFPdHZDLENBQUMsSUFBSWlwRTtnQkFDeEJ4L0QsR0FBRyxDQUFDZ0IsSUFBSWhCLENBQUMsR0FBRzZsQyxPQUFPN2xDLENBQUMsSUFBSXcvRDtZQUMxQjtZQUNBLE9BQU87Z0JBQ0xqcEUsR0FBR3N2QyxPQUFPdHZDLENBQUMsR0FBR21wRSxjQUFjbnBFLENBQUM7Z0JBQzdCeUosR0FBRzZsQyxPQUFPN2xDLENBQUMsR0FBRzAvRCxjQUFjMS9ELENBQUM7WUFDL0I7UUFDRjtRQUNBLElBQUkyL0QsbUJBQW1CNXBFLFFBQVE2cEUsYUFBYSxJQUFJN3BFLFFBQVE2cEUsYUFBYSxLQUFLO1FBQzFFLElBQUlDLFlBQVksU0FBU0E7WUFDdkIsSUFBSSxDQUFDRixrQkFBa0I7Z0JBQ3JCLE9BQU87WUFDVDtZQUNBLElBQUlsakQsS0FBS0Q7WUFDVCxJQUFLLElBQUloNEIsSUFBSSxHQUFHQSxJQUFJc2xCLE1BQU03bkIsTUFBTSxFQUFFdUMsSUFBSztnQkFDckMsSUFBSTJtQixPQUFPckIsS0FBSyxDQUFDdGxCLEVBQUU7Z0JBQ25CLElBQUl3YyxNQUFNcStELE1BQU1sMEQsTUFBTTNtQjtnQkFDdEJ1NEIseUJBQXlCTixJQUFJemIsSUFBSXpLLENBQUMsRUFBRXlLLElBQUloQixDQUFDO1lBQzNDO1lBQ0EsT0FBT3ljO1FBQ1Q7UUFDQSxJQUFJQSxLQUFLb2pEO1FBQ1QsSUFBSUMsY0FBY3ozRSxRQUFRLFNBQVU4aUIsSUFBSSxFQUFFM21CLENBQUM7WUFDekMsSUFBSXFqRSxTQUFTd1gsTUFBTWwwRCxNQUFNM21CO1lBQ3pCLElBQUltN0Usa0JBQWtCO2dCQUNwQixJQUFJSCxVQUFVejRFLEtBQUsyM0IsR0FBRyxDQUFDM29CLFFBQVE2cEUsYUFBYTtnQkFDNUMvWCxTQUFTMFgsaUJBQWlCQyxTQUFTL2lELElBQUlvckM7WUFDekM7WUFDQSxJQUFJOXhELFFBQVFncUUsU0FBUyxJQUFJLE1BQU07Z0JBQzdCbFksU0FBUzl4RCxRQUFRZ3FFLFNBQVMsQ0FBQzUwRCxNQUFNMDhDO1lBQ25DO1lBQ0EsT0FBT0E7UUFDVCxHQUFHdVg7UUFDSCxJQUFJcnBFLFFBQVFvdkMsT0FBTyxFQUFFO1lBQ25CLElBQUssSUFBSTNnRCxJQUFJLEdBQUdBLElBQUlzbEIsTUFBTTduQixNQUFNLEVBQUV1QyxJQUFLO2dCQUNyQyxJQUFJMm1CLE9BQU9yQixLQUFLLENBQUN0bEIsRUFBRTtnQkFDbkIsSUFBSXFqRSxTQUFTaVksWUFBWTMwRCxNQUFNM21CO2dCQUMvQixJQUFJdzdFLGNBQWNqcUUsUUFBUWtxRSxhQUFhLElBQUksUUFBUWxxRSxRQUFRa3FFLGFBQWEsQ0FBQzkwRCxNQUFNM21CO2dCQUMvRSxJQUFJdzdFLGFBQWE7b0JBQ2YsSUFBSXY1QixNQUFNdDdCLEtBQUtoRSxTQUFTLENBQUM7d0JBQ3ZCbkIsVUFBVTZoRDt3QkFDVm5sQixVQUFVM3NDLFFBQVFtcUUsaUJBQWlCO3dCQUNuQ0MsUUFBUXBxRSxRQUFRcXFFLGVBQWU7b0JBQ2pDO29CQUNBNUksT0FBTzhILFVBQVUsQ0FBQzc2RSxJQUFJLENBQUNnaUQ7Z0JBQ3pCLE9BQU87b0JBQ0x0N0IsS0FBS25GLFFBQVEsQ0FBQzZoRDtnQkFDaEI7WUFDRjtZQUNBLElBQUk5eEQsUUFBUWt3QyxHQUFHLEVBQUU7Z0JBQ2YsSUFBSW82QixTQUFTNzZELEdBQUcyQixTQUFTLENBQUM7b0JBQ3hCOCtCLEtBQUs7d0JBQ0hyK0MsYUFBYXUzRSxXQUFXckwsYUFBYSxDQUFDZ007d0JBQ3RDN2lELFNBQVNsbkIsUUFBUWtuQixPQUFPO29CQUMxQjtvQkFDQXlsQixVQUFVM3NDLFFBQVFtcUUsaUJBQWlCO29CQUNuQ0MsUUFBUXBxRSxRQUFRcXFFLGVBQWU7Z0JBQ2pDO2dCQUNBNUksT0FBTzhILFVBQVUsQ0FBQzc2RSxJQUFJLENBQUM0N0U7WUFDekIsT0FBTyxJQUFJdHFFLFFBQVEwUyxJQUFJLEtBQUt6akIsYUFBYStRLFFBQVF5UyxHQUFHLEtBQUt4akIsV0FBVztnQkFDbEUsSUFBSXM3RSxhQUFhOTZELEdBQUcyQixTQUFTLENBQUM7b0JBQzVCc0IsTUFBTTFTLFFBQVEwUyxJQUFJO29CQUNsQkQsS0FBS3pTLFFBQVF5UyxHQUFHO29CQUNoQms2QixVQUFVM3NDLFFBQVFtcUUsaUJBQWlCO29CQUNuQ0MsUUFBUXBxRSxRQUFRcXFFLGVBQWU7Z0JBQ2pDO2dCQUNBNUksT0FBTzhILFVBQVUsQ0FBQzc2RSxJQUFJLENBQUM2N0U7WUFDekI7WUFDQTlJLE9BQU84SCxVQUFVLENBQUNuNkQsT0FBTyxDQUFDLFNBQVVzaEMsR0FBRztnQkFDckMsT0FBT0EsSUFBSTdDLElBQUk7WUFDakI7WUFDQTR6QixPQUFPK0IsR0FBRyxDQUFDLGVBQWV4akUsUUFBUXdxRSxLQUFLO1lBQ3ZDL0ksT0FBT3BmLElBQUksQ0FBQztnQkFDVnRoRCxNQUFNO2dCQUNOMGdFLFFBQVFBO1lBQ1Y7WUFDQXAxQixVQUFVajZCLEdBQUcsQ0FBQ3F2RCxPQUFPOEgsVUFBVSxDQUFDdHBFLEdBQUcsQ0FBQyxTQUFVeXdDLEdBQUc7Z0JBQy9DLE9BQU9BLElBQUl4K0MsT0FBTztZQUNwQixJQUFJQyxJQUFJLENBQUM7Z0JBQ1BzdkUsT0FBTytCLEdBQUcsQ0FBQyxjQUFjeGpFLFFBQVFndUMsSUFBSTtnQkFDckN5ekIsT0FBT3BmLElBQUksQ0FBQztvQkFDVnRoRCxNQUFNO29CQUNOMGdFLFFBQVFBO2dCQUNWO1lBQ0Y7UUFDRixPQUFPO1lBQ0wxdEQsTUFBTXcrQyxTQUFTLENBQUN3WDtZQUNoQixJQUFJL3BFLFFBQVFrd0MsR0FBRyxFQUFFO2dCQUNmemdDLEdBQUd5Z0MsR0FBRyxDQUFDbHdDLFFBQVF1WixJQUFJLEVBQUV2WixRQUFRa25CLE9BQU87WUFDdEM7WUFDQSxJQUFJbG5CLFFBQVEwUyxJQUFJLElBQUksTUFBTTtnQkFDeEJqRCxHQUFHaUQsSUFBSSxDQUFDMVMsUUFBUTBTLElBQUk7WUFDdEI7WUFDQSxJQUFJMVMsUUFBUXlTLEdBQUcsRUFBRTtnQkFDZmhELEdBQUdnRCxHQUFHLENBQUN6UyxRQUFReVMsR0FBRztZQUNwQjtZQUNBZ3ZELE9BQU8rQixHQUFHLENBQUMsZUFBZXhqRSxRQUFRd3FFLEtBQUs7WUFDdkMvSSxPQUFPcGYsSUFBSSxDQUFDO2dCQUNWdGhELE1BQU07Z0JBQ04wZ0UsUUFBUUE7WUFDVjtZQUNBQSxPQUFPK0IsR0FBRyxDQUFDLGNBQWN4akUsUUFBUWd1QyxJQUFJO1lBQ3JDeXpCLE9BQU9wZixJQUFJLENBQUM7Z0JBQ1Z0aEQsTUFBTTtnQkFDTjBnRSxRQUFRQTtZQUNWO1FBQ0Y7UUFDQSxPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0lBQ0FBLFFBQVEsU0FBU0EsT0FBT3poRSxPQUFPO1FBQzdCLElBQUl5UCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixPQUFPQSxHQUFHZzdELFVBQVUsQ0FBQ2gyRSxPQUFPLENBQUMsR0FBR3VMLFNBQVM7WUFDdkN1WixNQUFNLElBQUk7UUFDWjtJQUNGO0FBQ0Y7QUFFQSxXQUFXO0FBQ1h3dkQsU0FBUzJCLFlBQVksR0FBRzNCLFNBQVMwQixVQUFVLEdBQUcxQixTQUFTdEgsTUFBTTtBQUU3RCxTQUFTa0osV0FBV3Y5RSxHQUFHLEVBQUVtRCxFQUFFLEVBQUVpZCxHQUFHO0lBQzlCLElBQUl3QyxLQUFLeEMsSUFBSW5jLFFBQVE7SUFDckIsSUFBSTRCLFFBQVErYyxHQUFHMjZELFVBQVUsR0FBRzM2RCxHQUFHMjZELFVBQVUsSUFBSSxFQUFFO0lBQy9DLElBQUl2OEQ7SUFDSixJQUFJLENBQUNBLE1BQU1uYixLQUFLLENBQUM3RixJQUFJLEtBQUssTUFBTTtRQUM5QixPQUFPZ2hCO0lBQ1QsT0FBTztRQUNMQSxNQUFNbmIsS0FBSyxDQUFDN0YsSUFBSSxHQUFHbUQsR0FBR2lkO1FBQ3RCLE9BQU9ZO0lBQ1Q7QUFDRjtBQUNBLFNBQVN3OEQsbUJBQW1CeDlFLEdBQUcsRUFBRW1ELEVBQUU7SUFDakNuRCxNQUFNdWMsV0FBV3ZjO0lBQ2pCLE9BQU8sU0FBU3k5RSxvQkFBb0JyOUQsR0FBRztRQUNyQyxPQUFPbTlELFdBQVd2OUUsS0FBS21ELElBQUlpZDtJQUM3QjtBQUNGO0FBQ0EsU0FBU3M5RCw0QkFBNEIxOUUsR0FBRyxFQUFFbUQsRUFBRTtJQUMxQ25ELE1BQU11YyxXQUFXdmM7SUFDakIsSUFBSTI5RSxTQUFTLFNBQVNBLE9BQU92OUQsR0FBRztRQUM5QixPQUFPamQsR0FBR3RDLElBQUksQ0FBQ3VmO0lBQ2pCO0lBQ0EsT0FBTyxTQUFTdzlEO1FBQ2QsSUFBSXg5RCxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ2pCLElBQUlBLEtBQUs7WUFDUCxPQUFPbTlELFdBQVd2OUUsS0FBSzI5RSxRQUFRdjlEO1FBQ2pDO0lBQ0Y7QUFDRjtBQUNBLElBQUl5OUQsV0FBVztJQUNibk4sMEJBQTBCLFNBQVNBLHlCQUF5QnZKLFFBQVE7UUFDbEUsSUFBSTlrRCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJdXFELFdBQVd2cUQsR0FBR3VxRCxRQUFRO1FBQzFCLElBQUlqckIsZUFBZXQvQixHQUFHcy9CLFlBQVk7UUFDbEMsSUFBSWlyQixZQUFZanJCLGNBQWM7WUFDNUJpckIsU0FBUzhELHdCQUF3QixDQUFDLElBQUksRUFBRXZKO1FBQzFDO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQTJXLGlCQUFpQixTQUFTQTtRQUN4QixJQUFJejdELEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUkwN0QsUUFBUSxTQUFTQSxNQUFNMzlELEdBQUc7WUFDNUIsT0FBT0EsSUFBSW5jLFFBQVEsQ0FBQ3M1RSxVQUFVLEdBQUc7UUFDbkM7UUFDQSxJQUFJbDdELEdBQUc2Z0QsZ0JBQWdCLElBQUk7WUFDekIsSUFBSS8yQztZQUNKQSxPQUFPLElBQUksQ0FBQ3FzRCxTQUFTLEdBQUc3cEQsS0FBSyxDQUFDLElBQUksQ0FBQ3l4QyxXQUFXLElBQUl6eEMsS0FBSyxDQUFDLElBQUksQ0FBQ3d6QyxPQUFPO1lBQ3BFaDJDLEtBQUt3QyxLQUFLLENBQUN4QyxLQUFLekUsY0FBYztZQUM5QnlFLEtBQUtuSyxPQUFPLENBQUMrN0Q7UUFDZixPQUFPO1lBQ0wsSUFBSSxDQUFDLzdELE9BQU8sQ0FBQyxTQUFVNUIsR0FBRztnQkFDeEIyOUQsTUFBTTM5RDtnQkFDTkEsSUFBSXNILGNBQWMsR0FBRzFGLE9BQU8sQ0FBQys3RDtZQUMvQjtRQUNGO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQSwwREFBMEQ7SUFDMUQvcUIsYUFBYSxTQUFTQSxZQUFZZ3JCLGNBQWM7UUFDOUMsSUFBSTM3RCxLQUFLLElBQUksQ0FBQ3BlLFFBQVEsQ0FBQ29lLEVBQUU7UUFDekIsSUFBSSxDQUFDQSxHQUFHcy9CLFlBQVksSUFBSTtZQUN0QixPQUFPLElBQUk7UUFDYjtRQUNBLElBQUl0L0IsR0FBR3drRCxRQUFRLElBQUk7WUFDakIsSUFBSW9YLFFBQVE1N0QsR0FBR3BlLFFBQVEsQ0FBQ2k2RSxjQUFjO1lBQ3RDRCxNQUFNdHZELEtBQUssQ0FBQyxJQUFJO1lBQ2hCLE9BQU8sSUFBSSxFQUFFLHdDQUF3QztRQUN2RDtRQUNBLElBQUlzMEMsZUFBZTVnRCxHQUFHNmdELGdCQUFnQjtRQUN0QyxJQUFJaWIsY0FBYyxJQUFJO1FBQ3RCSCxpQkFBaUJBLGtCQUFrQkEsbUJBQW1CbjhFLFlBQVksT0FBTztRQUN6RSxJQUFJb2hFLGNBQWM7WUFDaEIsK0RBQStEO1lBQy9Ea2IsY0FBYyxJQUFJLENBQUMzRixTQUFTLEdBQUc3cEQsS0FBSyxDQUFDLElBQUksQ0FBQ3l4QyxXQUFXLElBQUl6eEMsS0FBSyxDQUFDLElBQUksQ0FBQ3d6QyxPQUFPO1FBQzdFO1FBRUEsZ0RBQWdEO1FBQ2hELElBQUlpYyxjQUFjRDtRQUNsQixJQUFJSCxnQkFBZ0I7WUFDbEJJLFlBQVl6WCxhQUFhLENBQUMsVUFBVSxxQ0FBcUM7UUFDM0UsT0FBTztZQUNMeVgsWUFBWW5wQixJQUFJLENBQUMsVUFBVSxzQkFBc0I7UUFDbkQ7UUFDQWtwQixZQUFZbjhELE9BQU8sQ0FBQyxTQUFVNUIsR0FBRztZQUMvQixPQUFPQSxJQUFJbmMsUUFBUSxDQUFDd3NFLFVBQVUsR0FBRztRQUNuQztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQSxvREFBb0Q7SUFDcEQ0TixZQUFZLFNBQVNBO1FBQ25CLElBQUloOEQsS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSSxDQUFDQSxHQUFHcy9CLFlBQVksSUFBSTtZQUN0QjtRQUNGO1FBQ0EsSUFBSyxJQUFJdGdELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNLElBQUksQ0FBQy9lLEVBQUU7WUFDakIsSUFBSStlLElBQUluYyxRQUFRLENBQUN3c0UsVUFBVSxFQUFFO2dCQUMzQixvRkFBb0Y7Z0JBQ3BGcndELElBQUluYyxRQUFRLENBQUN3c0UsVUFBVSxHQUFHO2dCQUMxQnB1RCxHQUFHYyxLQUFLLEdBQUd2ZCxLQUFLLENBQUN3YTtZQUNuQjtRQUNGO0lBQ0Y7SUFDQSxrRUFBa0U7SUFDbEVrK0QsYUFBYSxTQUFTQSxZQUFZQyxRQUFRO1FBQ3hDLElBQUlDLG9CQUFvQnA1RSxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDNUYsSUFBSWdiLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSWlDLEtBQUtqQyxJQUFJaUMsRUFBRTtRQUNmLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLElBQUk7WUFDdEI7UUFDRjtRQUNBLElBQUl2aEMsS0FBSztZQUNQLHFCQUFxQjtZQUVyQixpRUFBaUU7WUFDakUsSUFBSUEsSUFBSW5jLFFBQVEsQ0FBQ3dzRSxVQUFVLEVBQUU7Z0JBQzNCLG9GQUFvRjtnQkFDcEZyd0QsSUFBSW5jLFFBQVEsQ0FBQ3dzRSxVQUFVLEdBQUc7Z0JBQzFCcHVELEdBQUdjLEtBQUssR0FBR3ZkLEtBQUssQ0FBQ3dhO1lBQ25CO1lBQ0EsSUFBSXErRCxrQkFBa0JyK0QsSUFBSW5jLFFBQVEsQ0FBQ2tmLEtBQUssQ0FBQ283RCxTQUFTO1lBQ2xELElBQUlFLG1CQUFtQixNQUFNO2dCQUMzQixPQUFPQTtZQUNULE9BQU8sSUFBSUQsbUJBQW1CO2dCQUM1QixPQUFPbjhELEdBQUdjLEtBQUssR0FBR3U3RCxrQkFBa0IsQ0FBQ0g7WUFDdkMsT0FBTztnQkFDTCxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0FJLGNBQWMsU0FBU0EsYUFBYUosUUFBUTtRQUMxQyxJQUFJbitELE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxJQUFJaUMsRUFBRSxHQUFHcy9CLFlBQVksSUFBSTtZQUM1QjtRQUNGO1FBQ0EsSUFBSXZoQyxLQUFLO1lBQ1AsSUFBSTRtRCxTQUFTNW1ELElBQUk0bUQsTUFBTSxDQUFDdVg7WUFDeEIsT0FBT3ZYLE9BQU9DLE9BQU8sS0FBS3BsRSxZQUFZbWxFLE9BQU9DLE9BQU8sR0FBR0QsT0FBT3RtRSxLQUFLO1FBQ3JFO0lBQ0Y7SUFDQWsrRSxtQkFBbUIsU0FBU0Esa0JBQWtCTCxRQUFRO1FBQ3BELElBQUluK0QsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJLENBQUNBLElBQUlpQyxFQUFFLEdBQUdzL0IsWUFBWSxJQUFJO1lBQzVCO1FBQ0Y7UUFDQSxJQUFJdmhDLEtBQUs7WUFDUCxPQUFPQSxJQUFJNG1ELE1BQU0sQ0FBQ3VYLFVBQVV6VyxLQUFLO1FBQ25DO0lBQ0Y7SUFDQSw0RUFBNEU7SUFDNUUsc0ZBQXNGO0lBQ3RGK1csZUFBZSxTQUFTQSxjQUFjTixRQUFRO1FBQzVDLElBQUlsOEQsS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSSxDQUFDQSxHQUFHcy9CLFlBQVksSUFBSTtZQUN0QixPQUFPLElBQUk7UUFDYjtRQUNBLElBQUl2aEMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJQSxLQUFLO1lBQ1AsT0FBT2lDLEdBQUdjLEtBQUssR0FBRzI3RCxnQkFBZ0IsQ0FBQzErRCxLQUFLbStEO1FBQzFDO0lBQ0Y7SUFDQSxvRkFBb0Y7SUFDcEZwN0QsT0FBTyxTQUFTQSxNQUFNaGhCLElBQUksRUFBRXpCLEtBQUs7UUFDL0IsSUFBSTJoQixLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJLENBQUNBLEdBQUdzL0IsWUFBWSxJQUFJO1lBQ3RCLE9BQU8sSUFBSTtRQUNiO1FBQ0EsSUFBSW85QixvQkFBb0I7UUFDeEIsSUFBSTU3RCxRQUFRZCxHQUFHYyxLQUFLO1FBQ3BCLElBQUk3ZixZQUFZbkIsT0FBTztZQUNyQix5QkFBeUI7WUFDekIsSUFBSTg2QyxRQUFROTZDO1lBQ1pnaEIsTUFBTTY3RCxXQUFXLENBQUMsSUFBSSxFQUFFL2hDLE9BQU84aEM7WUFDL0IsSUFBSSxDQUFDcFksYUFBYSxDQUFDLFVBQVUsNENBQTRDO1FBQzNFLE9BQU8sSUFBSXpqRSxPQUFPZixPQUFPO1lBQ3ZCLElBQUl6QixVQUFVbUIsV0FBVztnQkFDdkIsdUNBQXVDO2dCQUN2QyxJQUFJdWUsTUFBTSxJQUFJLENBQUMsRUFBRTtnQkFDakIsSUFBSUEsS0FBSztvQkFDUCxPQUFPK0MsTUFBTTg3RCxxQkFBcUIsQ0FBQzcrRCxLQUFLamU7Z0JBQzFDLE9BQU87b0JBQ0wsMENBQTBDO29CQUMxQztnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsOENBQThDO2dCQUM5Q2doQixNQUFNNjdELFdBQVcsQ0FBQyxJQUFJLEVBQUU3OEUsTUFBTXpCLE9BQU9xK0U7Z0JBQ3JDLElBQUksQ0FBQ3BZLGFBQWEsQ0FBQyxVQUFVLDRDQUE0QztZQUMzRTtRQUNGLE9BQU8sSUFBSXhrRSxTQUFTTixXQUFXO1lBQzdCLElBQUk2eEQsT0FBTyxJQUFJLENBQUMsRUFBRTtZQUNsQixJQUFJQSxNQUFNO2dCQUNSLE9BQU92d0MsTUFBTSs3RCxXQUFXLENBQUN4ckI7WUFDM0IsT0FBTztnQkFDTCwwQ0FBMEM7Z0JBQzFDO1lBQ0Y7UUFDRjtRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQXlyQixhQUFhLFNBQVNBLFlBQVlwckIsS0FBSztRQUNyQyxJQUFJMXhDLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLElBQUk7WUFDdEIsT0FBTyxJQUFJO1FBQ2I7UUFDQSxJQUFJbzlCLG9CQUFvQjtRQUN4QixJQUFJNTdELFFBQVFkLEdBQUdjLEtBQUs7UUFDcEIsSUFBSWdKLE9BQU8sSUFBSTtRQUNmLElBQUk0bkMsVUFBVWx5RCxXQUFXO1lBQ3ZCLElBQUssSUFBSVIsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztnQkFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtnQkFDakI4aEIsTUFBTWk4RCxpQkFBaUIsQ0FBQ2gvRCxLQUFLMitEO1lBQy9CO1FBQ0YsT0FBTztZQUNMaHJCLFFBQVFBLE1BQU14dUMsS0FBSyxDQUFDO1lBQ3BCLElBQUssSUFBSXdDLEtBQUssR0FBR0EsS0FBS29FLEtBQUtydEIsTUFBTSxFQUFFaXBCLEtBQU07Z0JBQ3ZDLElBQUk4OUMsUUFBUTE1QyxJQUFJLENBQUNwRSxHQUFHO2dCQUNwQjVFLE1BQU1rOEQsY0FBYyxDQUFDeFosT0FBTzlSLE9BQU9nckI7WUFDckM7UUFDRjtRQUNBLElBQUksQ0FBQ3BZLGFBQWEsQ0FBQyxVQUFVLDRDQUE0QztRQUV6RSxPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0lBQ0EyWSxNQUFNLFNBQVNBO1FBQ2IsSUFBSSxDQUFDMzVELEdBQUcsQ0FBQyxXQUFXO1FBQ3BCLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQTQ1RCxNQUFNLFNBQVNBO1FBQ2IsSUFBSSxDQUFDNTVELEdBQUcsQ0FBQyxXQUFXO1FBQ3BCLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQTY1RCxrQkFBa0IsU0FBU0E7UUFDekIsSUFBSW45RCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJLENBQUNBLEdBQUdzL0IsWUFBWSxJQUFJO1lBQ3RCLE9BQU87UUFDVDtRQUNBLElBQUl1aEIsbUJBQW1CN2dELEdBQUc2Z0QsZ0JBQWdCO1FBQzFDLElBQUk5aUQsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJQSxLQUFLO1lBQ1AsSUFBSXdDLEtBQUt4QyxJQUFJbmMsUUFBUTtZQUNyQixJQUFJdzdFLGdCQUFnQnIvRCxJQUFJNG1ELE1BQU0sQ0FBQyxXQUFXdG1FLEtBQUs7WUFDL0MsSUFBSSxDQUFDd2lFLGtCQUFrQjtnQkFDckIsT0FBT3VjO1lBQ1Q7WUFDQSxJQUFJdGQsVUFBVSxDQUFDdi9DLEdBQUdILElBQUksQ0FBQzhCLE1BQU0sR0FBRyxPQUFPbkUsSUFBSStoRCxPQUFPO1lBQ2xELElBQUlBLFNBQVM7Z0JBQ1gsSUFBSyxJQUFJOWdFLElBQUksR0FBR0EsSUFBSThnRSxRQUFRcmpFLE1BQU0sRUFBRXVDLElBQUs7b0JBQ3ZDLElBQUlrakIsU0FBUzQ5QyxPQUFPLENBQUM5Z0UsRUFBRTtvQkFDdkIsSUFBSWlyRSxVQUFVL25ELE9BQU95aUQsTUFBTSxDQUFDLFdBQVd0bUUsS0FBSztvQkFDNUMrK0UsZ0JBQWdCblQsVUFBVW1UO2dCQUM1QjtZQUNGO1lBQ0EsT0FBT0E7UUFDVDtJQUNGO0lBQ0FsMkUsYUFBYSxTQUFTQTtRQUNwQixJQUFJOFksS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSSxDQUFDQSxHQUFHcy9CLFlBQVksSUFBSTtZQUN0QixPQUFPO1FBQ1Q7UUFDQSxJQUFJdmhDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSThpRCxtQkFBbUI5aUQsSUFBSWlDLEVBQUUsR0FBRzZnRCxnQkFBZ0I7UUFDaEQsSUFBSTlpRCxLQUFLO1lBQ1AsSUFBSSxDQUFDOGlELGtCQUFrQjtnQkFDckIsT0FBTzlpRCxJQUFJNG1ELE1BQU0sQ0FBQyxXQUFXdG1FLEtBQUssS0FBSztZQUN6QyxPQUFPO2dCQUNMLE9BQU8wZixJQUFJby9ELGdCQUFnQixPQUFPO1lBQ3BDO1FBQ0Y7SUFDRjtJQUNBOTZELGVBQWUsU0FBU0E7UUFDdEIsSUFBSXJDLEtBQUssSUFBSSxDQUFDQSxFQUFFO1FBQ2hCLElBQUksQ0FBQ0EsR0FBR3MvQixZQUFZLElBQUk7WUFDdEIsT0FBTztRQUNUO1FBQ0EsSUFBSXZoQyxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ2pCLE9BQU9BLElBQUluYyxRQUFRLENBQUN5Z0IsYUFBYSxHQUFHLE9BQU87SUFDN0M7QUFDRjtBQUNBLFNBQVNnN0QsY0FBY3QvRCxHQUFHLEVBQUV1L0QsUUFBUTtJQUNsQyxJQUFJLzhELEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQixJQUFJaytELFVBQVV2L0MsR0FBR0gsSUFBSSxDQUFDOEIsTUFBTSxHQUFHbkUsSUFBSStoRCxPQUFPLEtBQUs7SUFDL0MsSUFBSUEsU0FBUztRQUNYLElBQUssSUFBSTlnRSxJQUFJLEdBQUdBLElBQUk4Z0UsUUFBUXJqRSxNQUFNLEVBQUV1QyxJQUFLO1lBQ3ZDLElBQUlrakIsU0FBUzQ5QyxPQUFPLENBQUM5Z0UsRUFBRTtZQUN2QixJQUFJLENBQUNzK0UsU0FBU3A3RCxTQUFTO2dCQUNyQixPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU3E3RCwyQkFBMkJDLEtBQUs7SUFDdkMsSUFBSUMsS0FBS0QsTUFBTUMsRUFBRTtJQUNqQixJQUFJQyxnQkFBZ0JGLE1BQU1FLGFBQWEsSUFBSUYsTUFBTUMsRUFBRTtJQUNuRCxJQUFJSCxXQUFXRSxNQUFNRixRQUFRLElBQUlFLE1BQU1DLEVBQUU7SUFDekMsT0FBTztRQUNMLElBQUl6OUQsS0FBSyxJQUFJLENBQUNBLEVBQUU7UUFDaEIsSUFBSSxDQUFDQSxHQUFHcy9CLFlBQVksSUFBSTtZQUN0QixPQUFPO1FBQ1Q7UUFDQSxJQUFJdmhDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSThpRCxtQkFBbUI3Z0QsR0FBRzZnRCxnQkFBZ0I7UUFDMUMsSUFBSTlpRCxLQUFLO1lBQ1AsSUFBSXdDLEtBQUt4QyxJQUFJbmMsUUFBUTtZQUNyQixJQUFJLENBQUM2N0UsR0FBRzEvRCxNQUFNO2dCQUNaLE9BQU87WUFDVDtZQUNBLElBQUlBLElBQUlvRSxNQUFNLElBQUk7Z0JBQ2hCLE9BQU8sQ0FBQzArQyxvQkFBb0J3YyxjQUFjdC9ELEtBQUt1L0Q7WUFDakQsT0FBTztnQkFDTCxJQUFJcjRELE1BQU0xRSxHQUFHRixNQUFNO2dCQUNuQixJQUFJbGIsTUFBTW9iLEdBQUdELE1BQU07Z0JBQ25CLE9BQU9vOUQsY0FBY3o0RCxRQUFTLEVBQUM0N0Msb0JBQW9Cd2MsY0FBY3A0RCxLQUFLeTRELGNBQWEsS0FBT3o0RCxDQUFBQSxRQUFROWYsT0FBT3U0RSxjQUFjdjRFLFFBQVMsRUFBQzA3RCxvQkFBb0J3YyxjQUFjbDRFLEtBQUt1NEUsY0FBYSxDQUFDO1lBQ3hMO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSUMsa0JBQWtCeEMsbUJBQW1CLG1CQUFtQixTQUFVcDlELEdBQUc7SUFDdkUsT0FBT0EsSUFBSTRtRCxNQUFNLENBQUMsV0FBV3RtRSxLQUFLLEtBQUssYUFBYTBmLElBQUk0YixLQUFLLE9BQU8sS0FBTTViLENBQUFBLElBQUlvRSxNQUFNLEtBQUtwRSxJQUFJNmIsTUFBTSxPQUFPLElBQUksSUFBRztBQUNuSDtBQUNBNGhELFNBQVN6TCxZQUFZLEdBQUdzTCw0QkFBNEIsZ0JBQWdCa0MsMkJBQTJCO0lBQzdGRSxJQUFJRTtBQUNOO0FBQ0EsSUFBSUMsaUJBQWlCekMsbUJBQW1CLGtCQUFrQixTQUFVcDlELEdBQUc7SUFDckUsT0FBT0EsSUFBSTRtRCxNQUFNLENBQUMsVUFBVXRtRSxLQUFLLEtBQUssU0FBUzBmLElBQUk0bUQsTUFBTSxDQUFDLGNBQWN0bUUsS0FBSyxLQUFLLGFBQWFzL0UsZ0JBQWdCNS9EO0FBQ2pIO0FBQ0EsSUFBSTgvRCxvQkFBb0IxQyxtQkFBbUIscUJBQXFCLFNBQVVqNUQsTUFBTTtJQUM5RSxPQUFPQSxPQUFPeWlELE1BQU0sQ0FBQyxjQUFjdG1FLEtBQUssS0FBSyxhQUFhcy9FLGdCQUFnQno3RDtBQUM1RTtBQUNBczVELFNBQVNzQyxXQUFXLEdBQUd6Qyw0QkFBNEIsZUFBZWtDLDJCQUEyQjtJQUMzRkUsSUFBSUc7SUFDSk4sVUFBVU87SUFDVkgsZUFBZUM7QUFDakI7QUFDQW5DLFNBQVN1QyxjQUFjLEdBQUc7SUFDeEIsSUFBSWhnRSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ2pCLElBQUlBLEtBQUs7UUFDUCxPQUFPLENBQUNBLElBQUkrL0QsV0FBVztJQUN6QjtBQUNGO0FBQ0EsSUFBSUUsYUFBYTdDLG1CQUFtQixjQUFjLFNBQVVwOUQsR0FBRztJQUM3RCxPQUFPQSxJQUFJNG1ELE1BQU0sQ0FBQyxjQUFjdG1FLEtBQUssS0FBSyxhQUFhMGYsSUFBSTRtRCxNQUFNLENBQUMsV0FBV0MsT0FBTyxLQUFLLEtBQUsrWSxnQkFBZ0I1L0Q7QUFDaEg7QUFDQSxJQUFJa2dFLHFCQUFxQk47QUFDekJuQyxTQUFTemtCLE9BQU8sR0FBR3NrQiw0QkFBNEIsV0FBV2tDLDJCQUEyQjtJQUNuRkUsSUFBSU87SUFDSk4sZUFBZU87QUFDakI7QUFDQXpDLFNBQVMwQyxNQUFNLEdBQUc7SUFDaEIsSUFBSW5nRSxNQUFNLElBQUksQ0FBQyxFQUFFO0lBQ2pCLElBQUlBLEtBQUs7UUFDUCxPQUFPLENBQUNBLElBQUlnNUMsT0FBTztJQUNyQjtBQUNGO0FBQ0F5a0IsU0FBUzJDLGVBQWUsR0FBRzlDLDRCQUE0QixtQkFBbUI7SUFDeEUsSUFBSSxDQUFDLElBQUksQ0FBQ3I3RCxFQUFFLEdBQUdzL0IsWUFBWSxJQUFJO1FBQzdCLE9BQU87SUFDVDtJQUNBLE9BQU8sQ0FBQyxJQUFJLENBQUNwK0IsT0FBTyxNQUFNLElBQUksQ0FBQ3lqRCxNQUFNLENBQUMsZUFBZXRtRSxLQUFLLEtBQUssWUFBWSxJQUFJLENBQUMweEUsWUFBWTtBQUM5RjtBQUNBeUwsU0FBU240RCxNQUFNLEdBQUdtNEQsU0FBU2w0RCxHQUFHLEdBQUdrNEQsU0FBUzE2RCxLQUFLO0FBQy9DMDZELFNBQVM0QyxXQUFXLEdBQUc1QyxTQUFTZ0IsYUFBYTtBQUM3Q2hCLFNBQVM2QyxZQUFZLEdBQUc3QyxTQUFTOEMsU0FBUyxHQUFHOUMsU0FBU3NCLFdBQVc7QUFDakV0QixTQUFTN1csTUFBTSxHQUFHNlcsU0FBU1MsV0FBVztBQUV0QyxJQUFJc0MsV0FBVyxDQUFDO0FBQ2hCLFNBQVNDLHFCQUFxQnYrRCxNQUFNO0lBQ2xDLE9BQU87UUFDTCxJQUFJamQsT0FBT0Q7UUFDWCxJQUFJZzVFLGNBQWMsRUFBRTtRQUVwQiwwQ0FBMEM7UUFDMUMsSUFBSS80RSxLQUFLdkcsTUFBTSxLQUFLLEdBQUc7WUFDckIsSUFBSTJqQixPQUFPcGQsSUFBSSxDQUFDLEVBQUU7WUFDbEIsSUFBSXN3RSxVQUFVdHdFLElBQUksQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQ3N1RCxFQUFFLENBQUNyeEMsT0FBT2plLEtBQUssRUFBRW9lLE1BQU1rekQ7UUFDOUIsT0FHSyxJQUFJdHdFLEtBQUt2RyxNQUFNLEtBQUssS0FBS21FLEtBQUtvQyxJQUFJLENBQUMsRUFBRSxHQUFHO1lBQzNDLElBQUl5N0UsV0FBV3o3RSxJQUFJLENBQUMsRUFBRTtZQUN0QixJQUFJLENBQUNzdUQsRUFBRSxDQUFDcnhDLE9BQU9qZSxLQUFLLEVBQUV5OEU7UUFDeEIsT0FJSyxJQUFJejdFLEtBQUt2RyxNQUFNLEtBQUssS0FBS3VHLEtBQUt2RyxNQUFNLEtBQUssS0FBS3NFLE1BQU1pQyxJQUFJLENBQUMsRUFBRSxHQUFHO1lBQ2pFLElBQUkwN0UsYUFBYTE3RSxLQUFLdkcsTUFBTSxLQUFLLElBQUl1RyxJQUFJLENBQUMsRUFBRSxHQUFHO1lBQy9DLElBQUssSUFBSWhFLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO2dCQUNwQyxJQUFJK2UsTUFBTSxJQUFJLENBQUMvZSxFQUFFO2dCQUNqQixJQUFJMi9FLE9BQU8sQ0FBQzErRCxPQUFPMitELFNBQVMsSUFBSTdnRSxJQUFJbmMsUUFBUSxDQUFDcWUsT0FBTzIrRCxTQUFTLENBQUM7Z0JBQzlELElBQUlyckIsVUFBVXgxQyxJQUFJbmMsUUFBUSxDQUFDcWUsT0FBT2l3QyxLQUFLLENBQUMsSUFBSWp3QyxPQUFPNWhCLEtBQUs7Z0JBQ3hELElBQUk0aEIsT0FBTzQrRCxZQUFZLEVBQUU7b0JBQ3ZCLElBQUlBLGVBQWU1K0QsT0FBTzQrRCxZQUFZLENBQUM5Z0U7b0JBQ3ZDLElBQUk4Z0UsaUJBQWlCci9FLFdBQVc7d0JBQzlCbS9FLE9BQU9FO3dCQUNQLElBQUksQ0FBQ0EsY0FBYzs0QkFDakIsT0FBTyxJQUFJO3dCQUNiLEVBQUUscURBQXFEO29CQUN6RDtnQkFDRjtnQkFDQSxJQUFJRixNQUFNO29CQUNSNWdFLElBQUluYyxRQUFRLENBQUNxZSxPQUFPaXdDLEtBQUssQ0FBQyxHQUFHandDLE9BQU81aEIsS0FBSztvQkFDekMsSUFBSWsxRCxTQUFTO3dCQUNYd29CLFlBQVk5OEUsSUFBSSxDQUFDOGU7b0JBQ25CO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJK2dFLGNBQWMsSUFBSSxDQUFDbnpELEtBQUssQ0FBQ293RDtZQUM3QitDLFlBQVludUIsV0FBVyxJQUFJLDhDQUE4QztZQUN6RW11QixZQUFZbHNCLElBQUksQ0FBQzN5QyxPQUFPamUsS0FBSztZQUM3QixJQUFJMDhFLFlBQVk7Z0JBQ2RJLFlBQVlsc0IsSUFBSSxDQUFDOHJCO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPLElBQUk7SUFDYjtBQUNGO0FBQ0EsU0FBU0ssZ0JBQWdCOStELE1BQU07SUFDN0JzK0QsUUFBUSxDQUFDdCtELE9BQU9pd0MsS0FBSyxDQUFDLEdBQUc7UUFDdkIsSUFBSW55QyxNQUFNLElBQUksQ0FBQyxFQUFFO1FBQ2pCLElBQUlBLEtBQUs7WUFDUCxJQUFJa0MsT0FBTysrRCxhQUFhLEVBQUU7Z0JBQ3hCLElBQUlyZ0UsTUFBTXNCLE9BQU8rK0QsYUFBYSxDQUFDamhFO2dCQUMvQixJQUFJWSxRQUFRbmYsV0FBVztvQkFDckIsT0FBT21mO2dCQUNUO1lBQ0Y7WUFDQSxPQUFPWixJQUFJbmMsUUFBUSxDQUFDcWUsT0FBT2l3QyxLQUFLLENBQUM7UUFDbkM7SUFDRjtJQUNBcXVCLFFBQVEsQ0FBQ3QrRCxPQUFPcXhDLEVBQUUsQ0FBQyxHQUFHa3RCLHFCQUFxQjtRQUN6Q3g4RSxPQUFPaWUsT0FBT3F4QyxFQUFFO1FBQ2hCcEIsT0FBT2p3QyxPQUFPaXdDLEtBQUs7UUFDbkIwdUIsV0FBVzMrRCxPQUFPMitELFNBQVM7UUFDM0JDLGNBQWM1K0QsT0FBTzQrRCxZQUFZO1FBQ2pDeGdGLE9BQU87SUFDVDtJQUNBa2dGLFFBQVEsQ0FBQ3QrRCxPQUFPdVYsR0FBRyxDQUFDLEdBQUdncEQscUJBQXFCO1FBQzFDeDhFLE9BQU9pZSxPQUFPdVYsR0FBRztRQUNqQjA2QixPQUFPandDLE9BQU9pd0MsS0FBSztRQUNuQjB1QixXQUFXMytELE9BQU8yK0QsU0FBUztRQUMzQkMsY0FBYzUrRCxPQUFPNCtELFlBQVk7UUFDakN4Z0YsT0FBTztJQUNUO0FBQ0Y7QUFDQTBnRixnQkFBZ0I7SUFDZDd1QixPQUFPO0lBQ1A4dUIsZUFBZSxTQUFTQSxjQUFjamhFLEdBQUc7UUFDdkMsT0FBT0EsSUFBSWlDLEVBQUUsR0FBR2kvRCxRQUFRLEtBQUssT0FBT3ovRTtJQUN0QztJQUNBOHhELElBQUk7SUFDSjk3QixLQUFLO0FBQ1A7QUFDQXVwRCxnQkFBZ0I7SUFDZDd1QixPQUFPO0lBQ1A4dUIsZUFBZSxTQUFTQSxjQUFjamhFLEdBQUc7UUFDdkMsT0FBT0EsSUFBSWlDLEVBQUUsR0FBR2svRCxhQUFhLE1BQU1uaEUsSUFBSXlELFFBQVEsS0FBSyxRQUFRaGlCO0lBQzlEO0lBQ0E4eEQsSUFBSTtJQUNKOTdCLEtBQUs7QUFDUDtBQUNBdXBELGdCQUFnQjtJQUNkN3VCLE9BQU87SUFDUDB1QixXQUFXO0lBQ1hDLGNBQWMsU0FBU0EsYUFBYTlnRSxHQUFHO1FBQ3JDLE9BQU9BLElBQUlpQyxFQUFFLEdBQUdtL0QsZUFBZSxLQUFLLFFBQVEzL0U7SUFDOUM7SUFDQTh4RCxJQUFJO0lBQ0o5N0IsS0FBSztBQUNQO0FBQ0F1cEQsZ0JBQWdCO0lBQ2Q3dUIsT0FBTztJQUNQOHVCLGVBQWUsU0FBU0EsY0FBY2poRSxHQUFHO1FBQ3ZDLE9BQU9BLElBQUlpQyxFQUFFLEdBQUdtL0QsZUFBZSxLQUFLLFFBQVEzL0U7SUFDOUM7SUFDQTh4RCxJQUFJO0lBQ0o5N0IsS0FBSztBQUNQO0FBQ0Erb0QsU0FBU2EsUUFBUSxHQUFHYixTQUFTYyxRQUFRO0FBQ3JDZCxTQUFTajlELE9BQU8sR0FBRztJQUNqQixJQUFJdkQsTUFBTSxJQUFJLENBQUMsRUFBRTtJQUNqQixJQUFJQSxLQUFLO1FBQ1AsT0FBT0EsSUFBSW5jLFFBQVEsQ0FBQzBmLE9BQU87SUFDN0I7QUFDRjtBQUNBeTlELGdCQUFnQjtJQUNkN3VCLE9BQU87SUFDUG9CLElBQUk7SUFDSjk3QixLQUFLO0FBQ1A7QUFDQXVwRCxnQkFBZ0I7SUFDZDd1QixPQUFPO0lBQ1BvQixJQUFJO0lBQ0o5N0IsS0FBSztBQUNQO0FBQ0Erb0QsU0FBU2UsUUFBUSxHQUFHO0lBQ2xCLElBQUl2aEUsTUFBTSxJQUFJLENBQUMsRUFBRTtJQUNqQixJQUFJQSxLQUFLO1FBQ1AsT0FBTyxDQUFDQSxJQUFJbmMsUUFBUSxDQUFDNmYsTUFBTTtJQUM3QjtBQUNGO0FBRUEsSUFBSTg5RCxXQUFXLENBQUM7QUFFaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUVoQixJQUFJQyxxQkFBcUIsU0FBU0EsbUJBQW1Cdi9ELE1BQU07SUFDekQsT0FBTyxTQUFTdy9ELGlCQUFpQnpzQixRQUFRO1FBQ3ZDLElBQUlscEMsT0FBTyxJQUFJO1FBQ2YsSUFBSXptQixNQUFNLEVBQUU7UUFDWixJQUFLLElBQUlyRSxJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkrZSxNQUFNK0wsSUFBSSxDQUFDOXFCLEVBQUU7WUFDakIsSUFBSSxDQUFDK2UsSUFBSW9FLE1BQU0sSUFBSTtnQkFDakI7WUFDRjtZQUNBLElBQUl1OUQsZUFBZTtZQUNuQixJQUFJMTlELFFBQVFqRSxJQUFJc0gsY0FBYztZQUM5QixJQUFLLElBQUloZ0IsSUFBSSxHQUFHQSxJQUFJMmMsTUFBTXZsQixNQUFNLEVBQUU0SSxJQUFLO2dCQUNyQyxJQUFJdWdCLE9BQU81RCxLQUFLLENBQUMzYyxFQUFFO2dCQUNuQixJQUFJNGYsTUFBTVcsS0FBS3ZGLE1BQU07Z0JBQ3JCLElBQUlsYixNQUFNeWdCLEtBQUt0RixNQUFNO2dCQUNyQixJQUFJTCxPQUFPMC9ELGVBQWUsSUFBSXg2RSxRQUFRNFksT0FBT2tILFFBQVFsSCxPQUFPa0MsT0FBTzIvRCxlQUFlLElBQUkzNkQsUUFBUWxILE9BQU81WSxRQUFRNFksS0FBSztvQkFDaEgyaEUsZUFBZTtvQkFDZjtnQkFDRjtZQUNGO1lBQ0EsSUFBSSxDQUFDQSxjQUFjO2dCQUNqQnI4RSxJQUFJcEUsSUFBSSxDQUFDOGU7WUFDWDtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUM0TixLQUFLLENBQUN0b0IsS0FBSyxNQUFNcWMsTUFBTSxDQUFDc3pDO0lBQ3RDO0FBQ0Y7QUFDQSxJQUFJNnNCLGtCQUFrQixTQUFTQSxnQkFBZ0I1L0QsTUFBTTtJQUNuRCxPQUFPLFNBQVUreUMsUUFBUTtRQUN2QixJQUFJbHBDLE9BQU8sSUFBSTtRQUNmLElBQUlnMkQsUUFBUSxFQUFFO1FBQ2QsSUFBSyxJQUFJOWdGLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtZQUNqQixJQUFJLENBQUMrZSxJQUFJb0UsTUFBTSxJQUFJO2dCQUNqQjtZQUNGO1lBQ0EsSUFBSUgsUUFBUWpFLElBQUlzSCxjQUFjO1lBQzlCLElBQUssSUFBSWhnQixJQUFJLEdBQUdBLElBQUkyYyxNQUFNdmxCLE1BQU0sRUFBRTRJLElBQUs7Z0JBQ3JDLElBQUl1Z0IsT0FBTzVELEtBQUssQ0FBQzNjLEVBQUU7Z0JBQ25CLElBQUk0ZixNQUFNVyxLQUFLdkYsTUFBTTtnQkFDckIsSUFBSWxiLE1BQU15Z0IsS0FBS3RGLE1BQU07Z0JBQ3JCLElBQUlMLE9BQU95cEIsUUFBUSxJQUFJemtCLFFBQVFsSCxLQUFLO29CQUNsQytoRSxNQUFNN2dGLElBQUksQ0FBQzJtQjtvQkFDWGs2RCxNQUFNN2dGLElBQUksQ0FBQ2tHO2dCQUNiLE9BQU8sSUFBSThhLE9BQU93cEIsUUFBUSxJQUFJdGtDLFFBQVE0WSxLQUFLO29CQUN6QytoRSxNQUFNN2dGLElBQUksQ0FBQzJtQjtvQkFDWGs2RCxNQUFNN2dGLElBQUksQ0FBQ2dtQjtnQkFDYjtZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQzBHLEtBQUssQ0FBQ20wRCxPQUFPLE1BQU1wZ0UsTUFBTSxDQUFDc3pDO0lBQ3hDO0FBQ0Y7QUFDQSxJQUFJK3NCLG1CQUFtQixTQUFTQSxpQkFBaUI5L0QsTUFBTTtJQUNyRCxPQUFPLFNBQVUreUMsUUFBUTtRQUN2QixJQUFJbHBDLE9BQU8sSUFBSTtRQUNmLElBQUlrMkQsUUFBUSxFQUFFO1FBQ2QsSUFBSUMsV0FBVyxDQUFDO1FBQ2hCLE9BQVM7WUFDUCxJQUFJeGhGLE9BQU93aEIsT0FBT3lwQixRQUFRLEdBQUc1ZixLQUFLMGhCLFFBQVEsS0FBSzFoQixLQUFLK3pDLFFBQVE7WUFDNUQsSUFBSXAvRCxLQUFLaEMsTUFBTSxLQUFLLEdBQUc7Z0JBQ3JCO1lBQ0YsRUFBRSxvQkFBb0I7WUFFdEIsSUFBSXlqRixVQUFVO1lBQ2QsSUFBSyxJQUFJbGhGLElBQUksR0FBR0EsSUFBSVAsS0FBS2hDLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3BDLElBQUlyQyxJQUFJOEIsSUFBSSxDQUFDTyxFQUFFO2dCQUNmLElBQUltaEYsTUFBTXhqRixFQUFFOG5CLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDdzdELFFBQVEsQ0FBQ0UsSUFBSSxFQUFFO29CQUNsQkYsUUFBUSxDQUFDRSxJQUFJLEdBQUc7b0JBQ2hCSCxNQUFNL2dGLElBQUksQ0FBQ3RDO29CQUNYdWpGLFVBQVU7Z0JBQ1o7WUFDRjtZQUNBLElBQUksQ0FBQ0EsU0FBUztnQkFDWjtZQUNGLEVBQUUsdUNBQXVDO1lBRXpDcDJELE9BQU9yckI7UUFDVDtRQUNBLE9BQU8sSUFBSSxDQUFDa3RCLEtBQUssQ0FBQ3EwRCxPQUFPLE1BQU10Z0UsTUFBTSxDQUFDc3pDO0lBQ3hDO0FBQ0Y7QUFDQXVzQixTQUFTYSxtQkFBbUIsR0FBRztJQUM3QixJQUFLLElBQUlwaEYsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSSxDQUFDQSxFQUFFLENBQUM0QyxRQUFRLENBQUN3Z0IsY0FBYyxHQUFHO0lBQ3BDO0FBQ0Y7QUFDQXBkLE9BQU91NkUsVUFBVTtJQUNmLGdDQUFnQztJQUNoQzU3RCxPQUFPNjdELG1CQUFtQjtRQUN4QkcsaUJBQWlCO0lBQ25CO0lBQ0EsZ0NBQWdDO0lBQ2hDbnJDLFFBQVFnckMsbUJBQW1CO1FBQ3pCSSxpQkFBaUI7SUFDbkI7SUFDQSwyQ0FBMkM7SUFDM0Msc0NBQXNDO0lBQ3RDcDBDLFVBQVVob0MsTUFBTXE4RSxnQkFBZ0I7UUFDOUJuMkMsVUFBVTtJQUNaLElBQUk7SUFDSixzQkFBc0I7SUFDdEIyMkMsWUFBWU4saUJBQWlCO1FBQzNCcjJDLFVBQVU7SUFDWjtJQUNBLDBDQUEwQztJQUMxQyxzQ0FBc0M7SUFDdENtMEIsVUFBVXI2RCxNQUFNcThFLGdCQUFnQjtRQUM5QnAyQyxVQUFVO0lBQ1osSUFBSTtJQUNKLG9CQUFvQjtJQUNwQjYyQyxjQUFjUCxpQkFBaUIsQ0FDN0I7QUFDSjtBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFFMUIvNkUsT0FBT3U2RSxVQUFVO0lBQ2ZuMEQsY0FBYzVuQixNQUFNLFNBQVV3dkQsUUFBUTtRQUNwQyxJQUFJdU4sV0FBVyxFQUFFO1FBQ2pCLElBQUlqOEMsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSyxJQUFJdGxCLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7WUFDckMsZ0JBQWdCO1lBQ2hCLElBQUkybUIsT0FBT3JCLEtBQUssQ0FBQ3RsQixFQUFFO1lBQ25CLElBQUlxbUIsaUJBQWlCTSxLQUFLTixjQUFjO1lBRXhDLDJEQUEyRDtZQUMzRCxJQUFLLElBQUloZ0IsSUFBSSxHQUFHQSxJQUFJZ2dCLGVBQWU1b0IsTUFBTSxFQUFFNEksSUFBSztnQkFDOUMsSUFBSXVnQixPQUFPUCxjQUFjLENBQUNoZ0IsRUFBRTtnQkFDNUIsSUFBSTRmLE1BQU1XLEtBQUt2RixNQUFNO2dCQUNyQixJQUFJbGIsTUFBTXlnQixLQUFLdEYsTUFBTTtnQkFDckIsSUFBSWlnRSxZQUFZNTZELFNBQVNWLE1BQU05ZixNQUFNOGY7Z0JBRXJDLDZCQUE2QjtnQkFDN0IsSUFBSXM3RCxVQUFVOWpGLE1BQU0sR0FBRyxHQUFHO29CQUN4QjhqRSxTQUFTdGhFLElBQUksQ0FBQ3NoRixTQUFTLENBQUMsRUFBRSxHQUFHLHNCQUFzQjtnQkFDckQ7Z0JBRUEscUJBQXFCO2dCQUNyQmhnQixTQUFTdGhFLElBQUksQ0FBQzJtQixJQUFJLENBQUMsRUFBRTtZQUN2QjtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUMrRixLQUFLLENBQUM0MEMsVUFBVSxNQUFNN2dELE1BQU0sQ0FBQ3N6QztJQUMzQyxHQUFHO0lBQ0h3dEIsb0JBQW9CLFNBQVNBLG1CQUFtQnh0QixRQUFRO1FBQ3RELE9BQU8sSUFBSSxDQUFDNW5DLFlBQVksR0FBRzVMLEdBQUcsQ0FBQyxJQUFJLEVBQUVFLE1BQU0sQ0FBQ3N6QztJQUM5QztJQUNBdm5CLGtCQUFrQixTQUFTQSxpQkFBaUJ1bkIsUUFBUTtRQUNsRCxPQUFPLElBQUksQ0FBQzVuQyxZQUFZLENBQUM0bkM7SUFDM0I7QUFDRjtBQUVBLFVBQVU7QUFDVnVzQixTQUFTa0IsYUFBYSxHQUFHbEIsU0FBU24wRCxZQUFZO0FBQzlDbTBELFNBQVNtQixtQkFBbUIsR0FBR25CLFNBQVNpQixrQkFBa0I7QUFDMURqQixTQUFTb0IsaUJBQWlCLEdBQUdwQixTQUFTOXpDLGdCQUFnQjtBQUV0RCxpQkFBaUI7QUFDakIsaUJBQWlCO0FBRWpCem1DLE9BQU91NkUsVUFBVTtJQUNmbC9ELFFBQVE3YyxNQUFNLFNBQVNvOUUsV0FBVzV0QixRQUFRO1FBQ3hDLElBQUlqMUMsTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFJa0g7UUFDSixJQUFJbEgsS0FBSztZQUNQa0gsTUFBTWxILElBQUluYyxRQUFRLENBQUN5ZSxNQUFNLElBQUl0QyxJQUFJaUMsRUFBRSxHQUFHcmUsVUFBVTtRQUNsRDtRQUNBLE9BQU9zakIsT0FBTyt0QyxXQUFXL3RDLElBQUl2RixNQUFNLENBQUNzekMsWUFBWS90QztJQUNsRCxHQUFHO0lBQ0gzRSxRQUFROWMsTUFBTSxTQUFTcTlFLFdBQVc3dEIsUUFBUTtRQUN4QyxJQUFJajFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDakIsSUFBSTVZO1FBQ0osSUFBSTRZLEtBQUs7WUFDUDVZLE1BQU00WSxJQUFJbmMsUUFBUSxDQUFDMGUsTUFBTSxJQUFJdkMsSUFBSWlDLEVBQUUsR0FBR3JlLFVBQVU7UUFDbEQ7UUFDQSxPQUFPd0QsT0FBTzZ0RCxXQUFXN3RELElBQUl1YSxNQUFNLENBQUNzekMsWUFBWTd0RDtJQUNsRCxHQUFHO0lBQ0gyN0UsU0FBU0MscUJBQXFCO1FBQzVCMXJDLE1BQU07SUFDUjtJQUNBMnJDLFNBQVNELHFCQUFxQjtRQUM1QjFyQyxNQUFNO0lBQ1I7QUFDRjtBQUNBLFNBQVMwckMscUJBQXFCOWdFLE1BQU07SUFDbEMsT0FBTyxTQUFTMmdFLFdBQVc1dEIsUUFBUTtRQUNqQyxJQUFJOHRCLFVBQVUsRUFBRTtRQUNoQixJQUFLLElBQUk5aEYsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7WUFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtZQUNqQixJQUFJaW1CLE1BQU1sSCxJQUFJbmMsUUFBUSxDQUFDcWUsT0FBT28xQixJQUFJLENBQUM7WUFDbkMsSUFBSXB3QixLQUFLO2dCQUNQNjdELFFBQVE3aEYsSUFBSSxDQUFDZ21CO1lBQ2Y7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDMEcsS0FBSyxDQUFDbTFELFNBQVMsTUFBTXBoRSxNQUFNLENBQUNzekM7SUFDMUM7QUFDRjtBQUNBaHVELE9BQU91NkUsVUFBVTtJQUNmMzBELFdBQVdwbkIsTUFBTXk5RSwyQkFBMkI7SUFDNUN0MkQsU0FBU25uQixNQUFNeTlFLHdCQUF3QjtRQUNyQ0MsV0FBVztJQUNiLElBQUk7QUFDTjtBQUNBLFNBQVNELHdCQUF3QmhoRSxNQUFNO0lBQ3JDLE9BQU8sU0FBU2toRSxjQUFjQyxVQUFVO1FBQ3RDLElBQUk3Z0IsV0FBVyxFQUFFO1FBQ2pCLElBQUl2Z0QsS0FBSyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFO1FBQ3pCLElBQUloYSxJQUFJaWEsVUFBVSxDQUFDO1FBRW5CLDBDQUEwQztRQUMxQyxJQUFJcGYsT0FBT3VnRixhQUFhO1lBQ3RCQSxhQUFhcGhFLEdBQUdpUSxDQUFDLENBQUNteEQ7UUFDcEI7UUFDQSxJQUFLLElBQUl0N0UsSUFBSSxHQUFHQSxJQUFJczdFLFdBQVcza0YsTUFBTSxFQUFFcUosSUFBSztZQUMxQyxJQUFJa2MsUUFBUW8vRCxVQUFVLENBQUN0N0UsRUFBRSxDQUFDbEUsUUFBUSxDQUFDb2dCLEtBQUs7WUFDeEMsSUFBSyxJQUFJaGpCLElBQUksR0FBR0EsSUFBSWdqQixNQUFNdmxCLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3JDLElBQUk0bUIsT0FBTzVELEtBQUssQ0FBQ2hqQixFQUFFO2dCQUNuQixJQUFJcWlGLFdBQVd6N0QsS0FBS2hrQixRQUFRLENBQUN3ZSxJQUFJO2dCQUNqQyxJQUFJa2hFLGNBQWMsSUFBSSxDQUFDdHpELGdCQUFnQixDQUFDcXpELFNBQVNoaEUsTUFBTSxLQUFLK2dFLFdBQVdwekQsZ0JBQWdCLENBQUNxekQsU0FBUy9nRSxNQUFNO2dCQUN2RyxJQUFJaWhFLGNBQWNILFdBQVdwekQsZ0JBQWdCLENBQUNxekQsU0FBU2hoRSxNQUFNLEtBQUssSUFBSSxDQUFDMk4sZ0JBQWdCLENBQUNxekQsU0FBUy9nRSxNQUFNO2dCQUN2RyxJQUFJa2hFLDJCQUEyQkYsZUFBZUM7Z0JBQzlDLElBQUksQ0FBQ0MsMEJBQTBCO29CQUM3QjtnQkFDRjtnQkFDQSxJQUFJeDdFLEVBQUVrN0UsU0FBUyxJQUFJbDdFLEVBQUV5N0UsU0FBUyxFQUFFO29CQUM5QixJQUFJejdFLEVBQUVrN0UsU0FBUyxJQUFJLENBQUNJLGFBQWE7d0JBQy9CO29CQUNGO29CQUNBLElBQUl0N0UsRUFBRXk3RSxTQUFTLElBQUksQ0FBQ0YsYUFBYTt3QkFDL0I7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0FoaEIsU0FBU3RoRSxJQUFJLENBQUMybUI7WUFDaEI7UUFDRjtRQUNBLE9BQU8sSUFBSSxDQUFDK0YsS0FBSyxDQUFDNDBDLFVBQVU7SUFDOUI7QUFDRjtBQUNBdjdELE9BQU91NkUsVUFBVTtJQUNmbDZELGdCQUFnQjdoQixNQUFNLFNBQVV3dkQsUUFBUTtRQUN0QyxJQUFJaWpCLFVBQVUsRUFBRTtRQUNoQixJQUFJbnNELE9BQU8sSUFBSTtRQUNmLElBQUssSUFBSTlxQixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUkybUIsT0FBT21FLElBQUksQ0FBQzlxQixFQUFFO1lBQ2xCLElBQUksQ0FBQzJtQixLQUFLeEQsTUFBTSxJQUFJO2dCQUNsQjtZQUNGO1lBQ0EsSUFBSUgsUUFBUTJELEtBQUsvakIsUUFBUSxDQUFDb2dCLEtBQUs7WUFDL0IsSUFBSyxJQUFJM2MsSUFBSSxHQUFHQSxJQUFJMmMsTUFBTXZsQixNQUFNLEVBQUU0SSxJQUFLO2dCQUNyQyxJQUFJdWdCLE9BQU81RCxLQUFLLENBQUMzYyxFQUFFO2dCQUNuQjR3RSxRQUFRaDNFLElBQUksQ0FBQzJtQjtZQUNmO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQytGLEtBQUssQ0FBQ3NxRCxTQUFTLE1BQU12MkQsTUFBTSxDQUFDc3pDO0lBQzFDLEdBQUc7SUFDSGp2QyxnQkFBZ0J2Z0IsTUFBTSxTQUFVd3ZELFFBQVE7UUFDdEMsSUFBSWlqQixVQUFVLEVBQUU7UUFDaEIsSUFBSW5zRCxPQUFPLElBQUk7UUFDZixJQUFLLElBQUk5cUIsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJNG1CLE9BQU9rRSxJQUFJLENBQUM5cUIsRUFBRTtZQUNsQixJQUFJLENBQUM0bUIsS0FBS3N5QixNQUFNLElBQUk7Z0JBQ2xCO1lBQ0Y7WUFDQSs5QixRQUFRaDNFLElBQUksQ0FBQzJtQixLQUFLdkYsTUFBTSxFQUFFLENBQUMsRUFBRTtZQUM3QjQxRCxRQUFRaDNFLElBQUksQ0FBQzJtQixLQUFLdEYsTUFBTSxFQUFFLENBQUMsRUFBRTtRQUMvQjtRQUNBLE9BQU8sSUFBSSxDQUFDcUwsS0FBSyxDQUFDc3FELFNBQVMsTUFBTXYyRCxNQUFNLENBQUNzekM7SUFDMUMsR0FBRztJQUNIMHVCLGVBQWVsK0UsTUFBTW0rRSwrQkFBK0I7SUFDcERDLGlCQUFpQnArRSxNQUFNbStFLDRCQUE0QjtRQUNqREUsWUFBWTtJQUNkLElBQUk7QUFDTjtBQUNBLFNBQVNGLDRCQUE0QjFoRSxNQUFNO0lBQ3pDLElBQUl4QyxXQUFXO1FBQ2Jva0UsWUFBWTtJQUNkO0lBQ0E1aEUsU0FBU2piLE9BQU8sQ0FBQyxHQUFHeVksVUFBVXdDO0lBQzlCLE9BQU8sU0FBUzZoRSxrQkFBa0I5dUIsUUFBUTtRQUN4QywrQkFBK0I7UUFDL0IsSUFBSXVOLFdBQVcsRUFBRTtRQUNqQixJQUFJditDLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUloYyxJQUFJaWE7UUFFUiwwQ0FBMEM7UUFDMUMsSUFBSyxJQUFJamhCLElBQUksR0FBR0EsSUFBSWdqQixNQUFNdmxCLE1BQU0sRUFBRXVDLElBQUs7WUFDckMsSUFBSStpRixRQUFRLy9ELEtBQUssQ0FBQ2hqQixFQUFFO1lBQ3BCLElBQUlnakYsVUFBVUQsTUFBTW5nRixRQUFRO1lBQzVCLElBQUlxZ0YsT0FBT0QsUUFBUTNoRSxNQUFNO1lBQ3pCLElBQUk2aEUsU0FBU0QsS0FBS3JnRixRQUFRLENBQUN3ZSxJQUFJLENBQUNxRSxFQUFFO1lBQ2xDLElBQUkwOUQsU0FBU0gsUUFBUTVoRSxJQUFJLENBQUNFLE1BQU07WUFDaEMsSUFBSThoRSxZQUFZSCxLQUFLcmdGLFFBQVEsQ0FBQ29nQixLQUFLO1lBRW5DLHVEQUF1RDtZQUN2RCxJQUFLLElBQUkzYyxJQUFJLEdBQUdBLElBQUkrOEUsVUFBVTNsRixNQUFNLEVBQUU0SSxJQUFLO2dCQUN6QyxJQUFJZzlFLFFBQVFELFNBQVMsQ0FBQy84RSxFQUFFO2dCQUN4QixJQUFJaTlFLFlBQVlELE1BQU16Z0YsUUFBUSxDQUFDd2UsSUFBSTtnQkFDbkMsSUFBSW1pRSxTQUFTRCxVQUFVaGlFLE1BQU07Z0JBQzdCLElBQUlraUUsU0FBU0YsVUFBVWppRSxNQUFNO2dCQUM3QixJQUFJd2hFLGFBQWFVLFdBQVdKLFVBQVVLLFdBQVdOO2dCQUNqRCxJQUFJTyxjQUFjUCxXQUFXSyxVQUFVSixXQUFXSztnQkFDbEQsSUFBSXg4RSxFQUFFNjdFLFVBQVUsSUFBSUEsY0FBYyxDQUFDNzdFLEVBQUU2N0UsVUFBVSxJQUFLQSxDQUFBQSxjQUFjWSxXQUFVLEdBQUk7b0JBQzlFbGlCLFNBQVN0aEUsSUFBSSxDQUFDb2pGO2dCQUNoQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQzEyRCxLQUFLLENBQUM0MEMsVUFBVSxNQUFNN2dELE1BQU0sQ0FBQ3N6QztJQUMzQztBQUNGO0FBRUEsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUVqQmh1RCxPQUFPdTZFLFVBQVU7SUFDZjVxRCxZQUFZLFNBQVNBLFdBQVc1aUIsSUFBSTtRQUNsQyxJQUFJM08sUUFBTyxJQUFJO1FBQ2YsSUFBSTRjLEtBQUs1YyxNQUFLNGMsRUFBRTtRQUNoQixJQUFJMGlFLFVBQVUxaUUsR0FBR3JlLFVBQVU7UUFDM0IsSUFBSWdoRixZQUFZNXdFLFFBQVEsT0FBTzNPLE1BQUtraEIsS0FBSyxLQUFLdlMsS0FBS3VTLEtBQUs7UUFDeEQsSUFBSXFRLGFBQWEsRUFBRTtRQUNuQixJQUFJNWlCLFFBQVEsUUFBUTR3RSxVQUFVMzVELEtBQUssSUFBSTtZQUNyQyw4QkFBOEI7WUFDOUIyNUQsWUFBWTV3RSxLQUFLK3VFLE9BQU8sSUFBSSw4RUFBOEU7UUFDNUc7UUFDQSxJQUFJOEIsbUJBQW1CLFNBQVNBLGlCQUFpQmo5RCxJQUFJLEVBQUUrTyxTQUFTO1lBQzlEZ3VELFFBQVFwMkQsS0FBSyxDQUFDM0c7WUFDZGc5RCxVQUFVaE0sT0FBTyxDQUFDaHhEO1lBQ2xCK08sVUFBVXBJLEtBQUssQ0FBQzNHO1FBQ2xCO1FBQ0EsSUFBSWc5RCxVQUFVMzVELEtBQUssSUFBSTtZQUNyQixPQUFPNWxCLE1BQUt1b0IsS0FBSztRQUNuQjtRQUNBLElBQUloSCxRQUFRLFNBQVNBO1lBQ25CLG9DQUFvQztZQUNwQyxJQUFJaytELE9BQU83aUUsR0FBR3JlLFVBQVU7WUFDeEJnekIsV0FBVzExQixJQUFJLENBQUM0akY7WUFDaEIsSUFBSTl3RSxPQUFPNHdFLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZCQyxpQkFBaUI3d0UsTUFBTTh3RTtZQUN2QnovRSxNQUFLb2dCLEdBQUcsQ0FBQztnQkFDUEksVUFBVTtnQkFDVkQsT0FBTzVSO2dCQUNQOFIsT0FBTyxTQUFTQSxNQUFNamdCLENBQUM7b0JBQ3JCLE9BQU9nL0UsaUJBQWlCaC9FLEdBQUdpL0U7Z0JBQzdCO1lBQ0Y7WUFDQUEsS0FBS2xqRSxPQUFPLENBQUMsU0FBVWdHLElBQUk7Z0JBQ3pCQSxLQUFLTixjQUFjLEdBQUcxRixPQUFPLENBQUMsU0FBVWpqQixDQUFDO29CQUN2QyxrQ0FBa0M7b0JBQ2xDLElBQUkwRyxNQUFLMGIsR0FBRyxDQUFDcGlCLE1BQU1tbUYsS0FBSy9qRSxHQUFHLENBQUNwaUIsRUFBRTJqQixNQUFNLE9BQU93aUUsS0FBSy9qRSxHQUFHLENBQUNwaUIsRUFBRTRqQixNQUFNLEtBQUs7d0JBQy9ELGlCQUFpQjt3QkFDakJ1aUUsS0FBS3YyRCxLQUFLLENBQUM1dkIsSUFBSSx3REFBd0Q7b0JBQ3pFO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLEdBQUc7WUFDRGlvQjtRQUNGLFFBQVNnK0QsVUFBVWxtRixNQUFNLEdBQUcsR0FBRztRQUMvQixPQUFPazRCO0lBQ1Q7SUFDQUQsV0FBVyxTQUFTQTtRQUNsQixJQUFJM1csTUFBTSxJQUFJLENBQUMsRUFBRTtRQUNqQixPQUFPQSxJQUFJaUMsRUFBRSxHQUFHdzFELGVBQWUsR0FBRzdnRCxVQUFVLENBQUM1VyxJQUFJLENBQUMsRUFBRTtJQUN0RDtBQUNGO0FBQ0F3aEUsU0FBU3VELFlBQVksR0FBR3ZELFNBQVM1cUQsVUFBVTtBQUUzQyxxREFBcUQ7QUFDckQsSUFBSW91RCxhQUFhLFNBQVNBLFdBQVcvaUUsRUFBRSxFQUFFdWdELFFBQVE7SUFDL0MsSUFBSXlpQixTQUFTamdGLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNqRixJQUFJbWUsVUFBVW5lLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNsRixJQUFJaWQsT0FBT3hnQixXQUFXO1FBQ3BCbWQsTUFBTTtRQUNOO0lBQ0Y7SUFDQSxJQUFJbk0sTUFBTSxJQUFJd087SUFDZCxJQUFJaWtFLGtCQUFrQjtJQUN0QixJQUFJLENBQUMxaUIsVUFBVTtRQUNiQSxXQUFXLEVBQUU7SUFDZixPQUFPLElBQUlBLFNBQVM5akUsTUFBTSxHQUFHLEtBQUt3RSxZQUFZcy9ELFFBQVEsQ0FBQyxFQUFFLEtBQUssQ0FBQzcrRCxRQUFRNitELFFBQVEsQ0FBQyxFQUFFLEdBQUc7UUFDbkYwaUIsa0JBQWtCO1FBRWxCLHdEQUF3RDtRQUN4RCxJQUFJbjVELE9BQU8sRUFBRTtRQUNiLElBQUlvNUQsVUFBVSxJQUFJcmpFO1FBQ2xCLElBQUssSUFBSTdnQixJQUFJLEdBQUdELElBQUl3aEUsU0FBUzlqRSxNQUFNLEVBQUV1QyxJQUFJRCxHQUFHQyxJQUFLO1lBQy9DLElBQUlta0YsT0FBTzVpQixRQUFRLENBQUN2aEUsRUFBRTtZQUN0QixJQUFJbWtGLEtBQUsvaUUsSUFBSSxJQUFJLE1BQU07Z0JBQ3JCK2lFLEtBQUsvaUUsSUFBSSxHQUFHLENBQUM7WUFDZjtZQUNBLElBQUlnakUsUUFBUUQsS0FBSy9pRSxJQUFJO1lBRXJCLGtEQUFrRDtZQUNsRCxJQUFJZ2pFLE1BQU0zK0QsRUFBRSxJQUFJLE1BQU07Z0JBQ3BCMitELE1BQU0zK0QsRUFBRSxHQUFHckg7WUFDYixPQUFPLElBQUk0QyxHQUFHZ08sZ0JBQWdCLENBQUNvMUQsTUFBTTMrRCxFQUFFLEtBQUt5K0QsUUFBUXBrRSxHQUFHLENBQUNza0UsTUFBTTMrRCxFQUFFLEdBQUc7Z0JBQ2pFLFVBQVUsa0RBQWtEO1lBQzlEO1lBQ0EsSUFBSTFHLE1BQU0sSUFBSWdDLFFBQVFDLElBQUltakUsTUFBTTtZQUNoQ3I1RCxLQUFLN3FCLElBQUksQ0FBQzhlO1lBQ1ZtbEUsUUFBUTFqRSxHQUFHLENBQUM0akUsTUFBTTMrRCxFQUFFO1FBQ3RCO1FBQ0E4N0MsV0FBV3oyQztJQUNiO0lBQ0EsSUFBSSxDQUFDcnRCLE1BQU0sR0FBRztJQUNkLElBQUssSUFBSWlwQixLQUFLLEdBQUcyOUQsS0FBSzlpQixTQUFTOWpFLE1BQU0sRUFBRWlwQixLQUFLMjlELElBQUkzOUQsS0FBTTtRQUNwRCxJQUFJNDlELFlBQVkvaUIsUUFBUSxDQUFDNzZDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsaUZBQWlGO1FBQ2xILElBQUk0OUQsYUFBYSxNQUFNO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJNytELEtBQUs2K0QsVUFBVTFoRixRQUFRLENBQUN3ZSxJQUFJLENBQUNxRSxFQUFFO1FBQ25DLElBQUksQ0FBQ3UrRCxVQUFVLENBQUN4eUUsSUFBSXNPLEdBQUcsQ0FBQzJGLEtBQUs7WUFDM0IsSUFBSXUrRCxRQUFRO2dCQUNWeHlFLElBQUlrTyxHQUFHLENBQUMrRixJQUFJO29CQUNWOVIsT0FBTyxJQUFJLENBQUNsVyxNQUFNO29CQUNsQnNoQixLQUFLdWxFO2dCQUNQO1lBQ0Y7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDN21GLE1BQU0sQ0FBQyxHQUFHNm1GO1lBQ3BCLElBQUksQ0FBQzdtRixNQUFNO1FBQ2I7SUFDRjtJQUNBLElBQUksQ0FBQ21GLFFBQVEsR0FBRztRQUNka29CLE1BQU0sSUFBSTtRQUNWOUosSUFBSUE7UUFDSixJQUFJeFAsT0FBTTtZQUNSLElBQUksSUFBSSxDQUFDK3lFLE9BQU8sSUFBSSxNQUFNO2dCQUN4QixJQUFJLENBQUNDLFVBQVU7WUFDakI7WUFDQSxPQUFPLElBQUksQ0FBQ0QsT0FBTztRQUNyQjtRQUNBLElBQUkveUUsS0FBSXRLLEVBQUc7WUFDVCxJQUFJLENBQUNxOUUsT0FBTyxHQUFHcjlFO1FBQ2pCO1FBQ0FzOUUsWUFBWSxTQUFTQTtZQUNuQixJQUFJdDlFLEtBQUksSUFBSSxDQUFDcTlFLE9BQU8sR0FBRyxJQUFJdmtFO1lBQzNCLElBQUk4SyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtZQUNwQixJQUFLLElBQUl4RSxNQUFNLEdBQUdBLE1BQU13RSxLQUFLcnRCLE1BQU0sRUFBRTZvQixNQUFPO2dCQUMxQyxJQUFJK3JDLE9BQU92bkMsSUFBSSxDQUFDeEUsSUFBSTtnQkFDcEJwZixHQUFFd1ksR0FBRyxDQUFDMnlDLEtBQUs1c0MsRUFBRSxJQUFJO29CQUNmOVIsT0FBTzJTO29CQUNQdkgsS0FBS3N6QztnQkFDUDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUkyeEIsUUFBUTtRQUNWLElBQUksQ0FBQ3BoRixRQUFRLENBQUM0TyxHQUFHLEdBQUdBO0lBQ3RCO0lBRUEsb0RBQW9EO0lBQ3BELElBQUl5eUUsbUJBQW1CLENBQUMvaEUsU0FBUztRQUMvQixJQUFJLENBQUNoQixPQUFPO0lBQ2Q7QUFDRjtBQUVBLFlBQVk7QUFDWixvR0FBb0c7QUFFcEcsa0ZBQWtGO0FBQ2xGLDJEQUEyRDtBQUMzRCxJQUFJdWpFLFdBQVcxakUsUUFBUWxpQixTQUFTLEdBQUdrbEYsV0FBV2xsRixTQUFTLEdBQUdMLE9BQU82aEIsTUFBTSxDQUFDemlCLE1BQU1pQixTQUFTO0FBQ3ZGNGxGLFNBQVM5aUYsY0FBYyxHQUFHO0lBQ3hCLE9BQU87QUFDVDtBQUNBOGlGLFNBQVM5M0QsS0FBSyxHQUFHLFNBQVU3QixJQUFJLEVBQUVrNUQsTUFBTTtJQUNyQyxPQUFPLElBQUlELFdBQVcsSUFBSSxDQUFDL2lFLEVBQUUsSUFBSThKLE1BQU1rNUQ7QUFDekM7QUFDQVMsU0FBU3ROLFNBQVMsR0FBRztJQUNuQixPQUFPLElBQUksQ0FBQ3hxRCxLQUFLLENBQUMsSUFBSTtBQUN4QjtBQUNBODNELFNBQVN6akUsRUFBRSxHQUFHO0lBQ1osT0FBTyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFO0FBQ3pCO0FBQ0F5akUsU0FBU2xaLFFBQVEsR0FBRztJQUNsQixPQUFPLElBQUksQ0FBQzNvRSxRQUFRLENBQUNvZSxFQUFFLENBQUN1cUQsUUFBUTtBQUNsQztBQUNBa1osU0FBUy9oRixPQUFPLEdBQUc7SUFDakIsT0FBTyxJQUFJLENBQUMsRUFBRTtBQUNoQjtBQUNBK2hGLFNBQVM5aEYsVUFBVSxHQUFHO0lBQ3BCLElBQUlBLFdBQVcsSUFBSSxHQUFHO1FBQ3BCLE9BQU8sSUFBSTtJQUNiLE9BQU87UUFDTCxhQUFhO1FBQ2IsT0FBTyxJQUFJb2hGLFdBQVcsSUFBSSxDQUFDbmhGLFFBQVEsQ0FBQ29lLEVBQUUsRUFBRTtZQUFDLElBQUk7U0FBQztJQUNoRDtBQUNGO0FBQ0F5akUsU0FBU1QsTUFBTSxHQUFHO0lBQ2hCLE9BQU8sSUFBSUQsV0FBVyxJQUFJLENBQUNuaEYsUUFBUSxDQUFDb2UsRUFBRSxFQUFFLElBQUksRUFBRTtBQUNoRDtBQUNBeWpFLFNBQVN6MUQsZ0JBQWdCLEdBQUcsU0FBVXZKLEVBQUU7SUFDdENBLEtBQUssS0FBS0EsSUFBSSxvQkFBb0I7SUFFbEMsT0FBTyxJQUFJLENBQUM3aUIsUUFBUSxDQUFDNE8sR0FBRyxDQUFDc08sR0FBRyxDQUFDMkY7QUFDL0I7QUFDQWcvRCxTQUFTMzNDLGNBQWMsR0FBRyxTQUFVcm5CLEVBQUU7SUFDcENBLEtBQUssS0FBS0EsSUFBSSxvQkFBb0I7SUFFbEMsSUFBSXpFLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtJQUN6QixJQUFJNUcsUUFBUSxJQUFJLENBQUN4WCxRQUFRLENBQUM0TyxHQUFHLENBQUN1TyxHQUFHLENBQUMwRjtJQUNsQyxPQUFPckwsUUFBUUEsTUFBTTJFLEdBQUcsR0FBRyxJQUFJZ2xFLFdBQVcvaUUsS0FBSyw4QkFBOEI7QUFDL0U7QUFDQXlqRSxTQUFTQyxHQUFHLEdBQUdELFNBQVMzM0MsY0FBYztBQUN0QzIzQyxTQUFTbkwsU0FBUyxHQUFHO0lBQ25CLElBQUl0NEQsS0FBSyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFO0lBQ3pCLElBQUk4SixPQUFPOUosR0FBR3BlLFFBQVEsQ0FBQzIrRCxRQUFRO0lBQy9CLElBQUk5N0MsS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDN2lCLFFBQVEsQ0FBQ3dlLElBQUksQ0FBQ3FFLEVBQUU7SUFDakMsT0FBT3FGLEtBQUtsb0IsUUFBUSxDQUFDNE8sR0FBRyxDQUFDdU8sR0FBRyxDQUFDMEYsSUFBSTlSLEtBQUs7QUFDeEM7QUFDQTh3RSxTQUFTdDdELE9BQU8sR0FBRyxTQUFVcEssR0FBRztJQUM5QixJQUFJMEcsS0FBSzFHLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRLENBQUN3ZSxJQUFJLENBQUNxRSxFQUFFO0lBQ2hDLE9BQU8sSUFBSSxDQUFDN2lCLFFBQVEsQ0FBQzRPLEdBQUcsQ0FBQ3VPLEdBQUcsQ0FBQzBGLElBQUk5UixLQUFLO0FBQ3hDO0FBQ0E4d0UsU0FBUy83QyxTQUFTLEdBQUcsU0FBVWpqQixFQUFFO0lBQy9CQSxLQUFLLEtBQUtBLElBQUksb0JBQW9CO0lBRWxDLE9BQU8sSUFBSSxDQUFDN2lCLFFBQVEsQ0FBQzRPLEdBQUcsQ0FBQ3VPLEdBQUcsQ0FBQzBGLElBQUk5UixLQUFLO0FBQ3hDO0FBQ0E4d0UsU0FBU04sSUFBSSxHQUFHLFNBQVV6aUYsR0FBRztJQUMzQixJQUFJcWQsTUFBTSxJQUFJLENBQUNyYyxPQUFPO0lBQ3RCLElBQUlzZSxLQUFLLElBQUksQ0FBQ0EsRUFBRTtJQUNoQixJQUFJakMsT0FBTyxRQUFRcmQsS0FBSztRQUN0QixPQUFPLElBQUk7SUFDYixFQUFFLHVCQUF1QjtJQUV6QixJQUFJcWQsT0FBTyxNQUFNO1FBQ2YsT0FBT3ZlO0lBQ1QsRUFBRSx5QkFBeUI7SUFFM0IsSUFBSXdHLElBQUkrWCxJQUFJbmMsUUFBUTtJQUNwQixJQUFJWCxZQUFZUCxNQUFNO1FBQ3BCLE1BQU07UUFFTnNmLEdBQUdnakQsVUFBVTtRQUNiLElBQUl0aUUsSUFBSTBmLElBQUksRUFBRTtZQUNackMsSUFBSXFDLElBQUksQ0FBQzFmLElBQUkwZixJQUFJO1lBQ2pCLElBQUl1akUsU0FBUzM5RSxFQUFFb2EsSUFBSTtZQUNuQixJQUFJckMsSUFBSW02QixNQUFNLElBQUk7Z0JBQ2hCLDZDQUE2QztnQkFDN0MsSUFBSTByQyxPQUFPO2dCQUNYLElBQUkxUyxPQUFPLENBQUM7Z0JBQ1osSUFBSWpzRCxNQUFNdmtCLElBQUkwZixJQUFJLENBQUNDLE1BQU07Z0JBQ3pCLElBQUlsYixNQUFNekUsSUFBSTBmLElBQUksQ0FBQ0UsTUFBTTtnQkFDekIsSUFBSTJFLE9BQU8sUUFBUUEsT0FBTzArRCxPQUFPdGpFLE1BQU0sRUFBRTtvQkFDdkM2d0QsS0FBSzd3RCxNQUFNLEdBQUcsS0FBSzRFLEtBQUssb0JBQW9CO29CQUM1QzIrRCxPQUFPO2dCQUNUO2dCQUNBLElBQUl6K0UsT0FBTyxRQUFRQSxPQUFPdytFLE9BQU9yakUsTUFBTSxFQUFFO29CQUN2QzR3RCxLQUFLNXdELE1BQU0sR0FBRyxLQUFLbmIsS0FBSyxvQkFBb0I7b0JBQzVDeStFLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSUEsTUFBTTtvQkFDUjdsRSxNQUFNQSxJQUFJNmxFLElBQUksQ0FBQzFTO2dCQUNqQjtZQUNGLE9BQU87Z0JBQ0wsaUNBQWlDO2dCQUNqQyxJQUFJMlMsb0JBQW9CLFlBQVluakYsSUFBSTBmLElBQUk7Z0JBQzVDLElBQUk4QixTQUFTeGhCLElBQUkwZixJQUFJLENBQUM4QixNQUFNO2dCQUM1QixJQUFJMmhFLHFCQUFzQjNoRSxDQUFBQSxVQUFVLFFBQVF5aEUsT0FBT3poRSxNQUFNLElBQUksSUFBRyxLQUFNQSxVQUFVeWhFLE9BQU96aEUsTUFBTSxFQUFFO29CQUM3RixJQUFJQSxXQUFXMWlCLFdBQVc7d0JBQ3hCLGdEQUFnRDt3QkFDaEQwaUIsU0FBUztvQkFDWDtvQkFDQSxJQUFJQSxVQUFVLE1BQU07d0JBQ2xCQSxTQUFTLEtBQUtBLFFBQVEsb0JBQW9CO29CQUM1QztvQkFDQW5FLE1BQU1BLElBQUk2bEUsSUFBSSxDQUFDO3dCQUNiMWhFLFFBQVFBO29CQUNWO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBLElBQUl4aEIsSUFBSThmLFFBQVEsRUFBRTtZQUNoQnpDLElBQUl5QyxRQUFRLENBQUM5ZixJQUFJOGYsUUFBUTtRQUMzQjtRQUVBLDRCQUE0QjtRQUU1QixJQUFJc2pFLGNBQWMsU0FBU0EsWUFBWXhnRixDQUFDLEVBQUV5Z0YsVUFBVSxFQUFFQyxXQUFXO1lBQy9ELElBQUlDLFFBQVF2akYsR0FBRyxDQUFDNEMsRUFBRTtZQUNsQixJQUFJMmdGLFNBQVMsUUFBUUEsVUFBVWorRSxDQUFDLENBQUMxQyxFQUFFLEVBQUU7Z0JBQ25DLElBQUkyZ0YsT0FBTztvQkFDVGxtRSxHQUFHLENBQUNnbUUsV0FBVztnQkFDakIsT0FBTztvQkFDTGhtRSxHQUFHLENBQUNpbUUsWUFBWTtnQkFDbEI7WUFDRjtRQUNGO1FBQ0FGLFlBQVksV0FBVyxVQUFVO1FBQ2pDQSxZQUFZLFlBQVksVUFBVTtRQUNsQ0EsWUFBWSxjQUFjLGFBQWE7UUFDdkNBLFlBQVksVUFBVSxRQUFRO1FBQzlCQSxZQUFZLGFBQWEsV0FBVztRQUNwQ0EsWUFBWSxZQUFZLFVBQVU7UUFDbEMsSUFBSXBqRixJQUFJZ2hCLE9BQU8sSUFBSSxNQUFNO1lBQ3ZCM0QsSUFBSTJELE9BQU8sQ0FBQ2hoQixJQUFJZ2hCLE9BQU87UUFDekI7UUFDQTFCLEdBQUdrakQsUUFBUTtRQUNYLE9BQU8sSUFBSTtJQUNiLE9BQU8sSUFBSXhpRSxRQUFRbEIsV0FBVztRQUM1QixNQUFNO1FBRU4sSUFBSTJqRixPQUFPO1lBQ1QvaUUsTUFBTW5ELEtBQUtqWCxFQUFFb2EsSUFBSTtZQUNqQkksVUFBVXZELEtBQUtqWCxFQUFFd2EsUUFBUTtZQUN6QkwsT0FBT25hLEVBQUVtYSxLQUFLO1lBQ2RlLFNBQVNsYixFQUFFa2IsT0FBTztZQUNsQkMsVUFBVW5iLEVBQUVtYixRQUFRO1lBQ3BCQyxZQUFZcGIsRUFBRW9iLFVBQVU7WUFDeEJDLFFBQVFyYixFQUFFcWIsTUFBTTtZQUNoQkUsV0FBV3ZiLEVBQUV1YixTQUFTO1lBQ3RCQyxVQUFVeGIsRUFBRXdiLFFBQVE7WUFDcEJFLFNBQVM7UUFDWDtRQUNBeWhFLEtBQUt6aEUsT0FBTyxHQUFHO1FBQ2YsSUFBSTFpQixJQUFJO1FBQ1JnSCxFQUFFMGIsT0FBTyxDQUFDL0IsT0FBTyxDQUFDLFNBQVV3RCxHQUFHO1lBQzdCLE9BQU9nZ0UsS0FBS3poRSxPQUFPLElBQUkxaUIsUUFBUSxJQUFJbWtCLE1BQU0sTUFBTUE7UUFDakQ7UUFDQSxPQUFPZ2dFO0lBQ1Q7QUFDRjtBQUNBTSxTQUFTUyxLQUFLLEdBQUc7SUFDZixJQUFJQSxRQUFRLEVBQUU7SUFDZCxJQUFLLElBQUlsbEYsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtRQUNqQixJQUFJbWtGLE9BQU9wbEUsSUFBSW9sRSxJQUFJO1FBQ25CZSxNQUFNamxGLElBQUksQ0FBQ2trRjtJQUNiO0lBQ0EsT0FBT2U7QUFDVDtBQUNBVCxTQUFTem1FLEtBQUssR0FBRztJQUNmLElBQUlnRCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtJQUNoQixJQUFJbWtFLFVBQVUsRUFBRTtJQUNoQixJQUFLLElBQUlubEYsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0sSUFBSSxDQUFDL2UsRUFBRTtRQUNqQixJQUFJbWtGLE9BQU9wbEUsSUFBSW9sRSxJQUFJO1FBQ25CLElBQUlubUUsUUFBUSxJQUFJK0MsUUFBUUMsSUFBSW1qRSxNQUFNLFFBQVEsZ0JBQWdCO1FBRTFEZ0IsUUFBUWxsRixJQUFJLENBQUMrZDtJQUNmO0lBQ0EsT0FBTyxJQUFJK2xFLFdBQVcvaUUsSUFBSW1rRTtBQUM1QjtBQUNBVixTQUFTeG1FLElBQUksR0FBR3dtRSxTQUFTem1FLEtBQUs7QUFDOUJ5bUUsU0FBU3ZqRSxPQUFPLEdBQUc7SUFDakIsSUFBSXk3RCxpQkFBaUI1NEUsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3pGLElBQUlxaEYsWUFBWXJoRixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDcEYsSUFBSUssUUFBTyxJQUFJO0lBQ2YsSUFBSTRjLEtBQUs1YyxNQUFLNGMsRUFBRTtJQUNoQixJQUFJcWtFLE9BQU9ya0UsR0FBR3BlLFFBQVE7SUFFdEIscURBQXFEO0lBQ3JELDBCQUEwQjtJQUMxQixJQUFJMGlCLFFBQVEsRUFBRTtJQUNkLElBQUl0QyxRQUFRLEVBQUU7SUFDZCxJQUFJdStDO0lBQ0osSUFBSyxJQUFJMXNDLE1BQU0sR0FBRzkwQixJQUFJcUUsTUFBSzNHLE1BQU0sRUFBRW8zQixNQUFNOTBCLEdBQUc4MEIsTUFBTztRQUNqRCxJQUFJOVYsTUFBTTNhLEtBQUksQ0FBQ3l3QixJQUFJO1FBQ25CLElBQUl1d0QsYUFBYSxDQUFDcm1FLElBQUltRCxPQUFPLElBQUk7WUFFL0I7UUFDRjtRQUVBLGdEQUFnRDtRQUNoRCxJQUFJbkQsSUFBSW9FLE1BQU0sSUFBSTtZQUNoQixnQ0FBZ0M7WUFDaENtQyxNQUFNcmxCLElBQUksQ0FBQzhlO1FBQ2IsT0FBTztZQUNMLDhCQUE4QjtZQUM5QmlFLE1BQU0vaUIsSUFBSSxDQUFDOGU7UUFDYjtJQUNGO0lBQ0F3aUQsV0FBV2o4QyxNQUFNa0QsTUFBTSxDQUFDeEY7SUFDeEIsSUFBSWhqQjtJQUNKLElBQUlzbEYscUJBQXFCLFNBQVNBO1FBQ2hDL2pCLFNBQVN0aUQsTUFBTSxDQUFDamYsR0FBRztRQUNuQkE7SUFDRjtJQUVBLDRCQUE0QjtJQUM1QixJQUFLQSxJQUFJLEdBQUdBLElBQUl1aEUsU0FBUzlqRSxNQUFNLEVBQUV1QyxJQUFLO1FBQ3BDLElBQUl3a0UsUUFBUWpELFFBQVEsQ0FBQ3ZoRSxFQUFFO1FBQ3ZCLElBQUk0QyxXQUFXNGhFLE1BQU01aEUsUUFBUTtRQUM3QixJQUFJMmlGLFNBQVMzaUYsU0FBU3dlLElBQUk7UUFFMUIsMkRBQTJEO1FBQzNEb2pELE1BQU00YyxtQkFBbUI7UUFFekIsc0JBQXNCO1FBQ3RCLElBQUksQ0FBQ2dFLGFBQWEsQ0FBQ3hpRixTQUFTc2YsT0FBTzthQUFTLElBQUlxakUsT0FBTzkvRCxFQUFFLEtBQUtqbEIsV0FBVztZQUN2RStrRixPQUFPOS9ELEVBQUUsR0FBR3JIO1FBQ2QsT0FBTyxJQUFJamMsU0FBU29qRixPQUFPOS9ELEVBQUUsR0FBRztZQUM5QjgvRCxPQUFPOS9ELEVBQUUsR0FBRyxLQUFLOC9ELE9BQU85L0QsRUFBRSxFQUFFLG9CQUFvQjtRQUNsRCxPQUFPLElBQUl4aUIsWUFBWXNpRixPQUFPOS9ELEVBQUUsS0FBSyxDQUFDNWpCLE9BQU8wakYsT0FBTzkvRCxFQUFFLEdBQUc7WUFDdkQ5SCxNQUFNLG9EQUFvRDRuRSxPQUFPOS9ELEVBQUUsR0FBRztZQUV0RSxxRUFBcUU7WUFDckU2L0Q7WUFDQTtRQUNGLE9BQU8sSUFBSXRrRSxHQUFHZ08sZ0JBQWdCLENBQUN1MkQsT0FBTzkvRCxFQUFFLEdBQUc7WUFDekM5SCxNQUFNLDRDQUE0QzRuRSxPQUFPOS9ELEVBQUUsR0FBRztZQUU5RCxrREFBa0Q7WUFDbEQ2L0Q7WUFDQTtRQUNGO1FBQ0EsSUFBSTcvRCxLQUFLOC9ELE9BQU85L0QsRUFBRSxFQUFFLHdDQUF3QztRQUU1RCxJQUFJKytDLE1BQU1yaEQsTUFBTSxJQUFJO1lBQ2xCLHlCQUF5QjtZQUN6QixJQUFJM0csTUFBTTVaLFNBQVM0ZSxRQUFRO1lBRTNCLDhDQUE4QztZQUU5QyxJQUFJaEYsSUFBSXpLLENBQUMsSUFBSSxNQUFNO2dCQUNqQnlLLElBQUl6SyxDQUFDLEdBQUc7WUFDVjtZQUNBLElBQUl5SyxJQUFJaEIsQ0FBQyxJQUFJLE1BQU07Z0JBQ2pCZ0IsSUFBSWhCLENBQUMsR0FBRztZQUNWO1FBQ0Y7UUFDQSxJQUFJZ3BELE1BQU10ckIsTUFBTSxJQUFJO1lBQ2xCLHlCQUF5QjtZQUV6QixJQUFJdHlCLE9BQU80OUM7WUFDWCxJQUFJZ2hCLFNBQVM7Z0JBQUM7Z0JBQVU7YUFBUztZQUNqQyxJQUFJQyxlQUFlRCxPQUFPL25GLE1BQU07WUFDaEMsSUFBSWlvRixvQkFBb0I7WUFDeEIsSUFBSyxJQUFJci9FLElBQUksR0FBR0EsSUFBSW8vRSxjQUFjcC9FLElBQUs7Z0JBQ3JDLElBQUk2cUQsUUFBUXMwQixNQUFNLENBQUNuL0UsRUFBRTtnQkFDckIsSUFBSXNaLE1BQU00bEUsTUFBTSxDQUFDcjBCLE1BQU07Z0JBQ3ZCLElBQUkvdUQsU0FBU3dkLE1BQU07b0JBQ2pCQSxNQUFNNGxFLE1BQU0sQ0FBQ3IwQixNQUFNLEdBQUcsS0FBS3EwQixNQUFNLENBQUNyMEIsTUFBTSxFQUFFLGFBQWE7Z0JBQ3pEO2dCQUNBLElBQUl2eEMsT0FBTyxRQUFRQSxRQUFRLElBQUk7b0JBQzdCLDJEQUEyRDtvQkFDM0RoQyxNQUFNLDBCQUEwQjhILEtBQUssd0JBQXdCeXJDO29CQUM3RHcwQixvQkFBb0I7Z0JBQ3RCLE9BQU8sSUFBSSxDQUFDMWtFLEdBQUdnTyxnQkFBZ0IsQ0FBQ3JQLE1BQU07b0JBQ3BDLHNEQUFzRDtvQkFDdERoQyxNQUFNLDBCQUEwQjhILEtBQUssd0JBQXdCeXJDLFFBQVEsT0FBT3Z4QyxNQUFNO29CQUNsRitsRSxvQkFBb0I7Z0JBQ3RCO1lBQ0Y7WUFDQSxJQUFJQSxtQkFBbUI7Z0JBQ3JCSjtnQkFDQTtZQUNGLEVBQUUsb0JBQW9CO1lBRXRCLElBQUlyL0QsTUFBTWpGLEdBQUc4ckIsY0FBYyxDQUFDeTRDLE9BQU9sa0UsTUFBTTtZQUN6QyxJQUFJbGIsTUFBTTZhLEdBQUc4ckIsY0FBYyxDQUFDeTRDLE9BQU9qa0UsTUFBTTtZQUV6QyxnQ0FBZ0M7WUFDaEMsSUFBSTJFLElBQUlFLElBQUksQ0FBQ2hnQixNQUFNO2dCQUNqQjhmLElBQUlyakIsUUFBUSxDQUFDb2dCLEtBQUssQ0FBQy9pQixJQUFJLENBQUMybUI7WUFDMUIsT0FBTztnQkFDTFgsSUFBSXJqQixRQUFRLENBQUNvZ0IsS0FBSyxDQUFDL2lCLElBQUksQ0FBQzJtQjtnQkFDeEJ6Z0IsSUFBSXZELFFBQVEsQ0FBQ29nQixLQUFLLENBQUMvaUIsSUFBSSxDQUFDMm1CO1lBQzFCO1lBQ0FBLEtBQUtoa0IsUUFBUSxDQUFDeWUsTUFBTSxHQUFHNEU7WUFDdkJXLEtBQUtoa0IsUUFBUSxDQUFDMGUsTUFBTSxHQUFHbmI7UUFDekIsRUFBRSxhQUFhO1FBRWYsZ0ZBQWdGO1FBQ2hGdkQsU0FBUzRPLEdBQUcsR0FBRyxJQUFJd087UUFDbkJwZCxTQUFTNE8sR0FBRyxDQUFDa08sR0FBRyxDQUFDK0YsSUFBSTtZQUNuQjFHLEtBQUt5bEQ7WUFDTDd3RCxPQUFPO1FBQ1Q7UUFDQS9RLFNBQVNzZixPQUFPLEdBQUc7UUFDbkIsSUFBSWtqRSxXQUFXO1lBQ2Jwa0UsR0FBR29rRSxTQUFTLENBQUM1Z0I7UUFDZjtJQUNGLEVBQUUsbUJBQW1CO0lBRXJCLGlDQUFpQztJQUNqQyxJQUFLLElBQUl6dkMsTUFBTSxHQUFHQSxNQUFNelAsTUFBTTduQixNQUFNLEVBQUVzM0IsTUFBTztRQUMzQyxZQUFZO1FBQ1osSUFBSXBPLE9BQU9yQixLQUFLLENBQUN5UCxJQUFJO1FBQ3JCLElBQUk0d0QsU0FBU2gvRCxLQUFLL2pCLFFBQVEsQ0FBQ3dlLElBQUk7UUFDL0IsSUFBSWpmLFNBQVN3akYsT0FBT3ppRSxNQUFNLEdBQUc7WUFDM0IsdUJBQXVCO1lBQ3ZCeWlFLE9BQU96aUUsTUFBTSxHQUFHLEtBQUt5aUUsT0FBT3ppRSxNQUFNO1FBQ3BDO1FBQ0EsSUFBSTBpRSxXQUFXRCxPQUFPemlFLE1BQU07UUFDNUIsSUFBSTJpRSxrQkFBa0JELFlBQVk7UUFDbEMsSUFBSUMsbUJBQW1CbC9ELEtBQUsvakIsUUFBUSxDQUFDc2dCLE1BQU0sRUFBRTtZQUMzQyxJQUFJQSxTQUFTeUQsS0FBSy9qQixRQUFRLENBQUNzZ0IsTUFBTSxHQUFHbEMsR0FBR3JlLFVBQVUsR0FBRzJxQixLQUFLLENBQUMzRyxLQUFLL2pCLFFBQVEsQ0FBQ3NnQixNQUFNLElBQUlsQyxHQUFHOHJCLGNBQWMsQ0FBQzg0QztZQUNwRyxJQUFJMWlFLE9BQU84RyxLQUFLLElBQUk7Z0JBQ2xCLHNDQUFzQztnQkFDdEMyN0QsT0FBT3ppRSxNQUFNLEdBQUcxaUI7WUFDbEIsT0FBTyxJQUFJMGlCLE1BQU0sQ0FBQyxFQUFFLENBQUNoQixPQUFPLElBQUk7Z0JBQzlCbEYsS0FBSztnQkFDTDJvRSxPQUFPemlFLE1BQU0sR0FBRzFpQjtnQkFDaEJtbUIsS0FBSy9qQixRQUFRLENBQUNzZ0IsTUFBTSxHQUFHO1lBQ3pCLE9BQU87Z0JBQ0wsSUFBSTRpRSxlQUFlO2dCQUNuQixJQUFJeHFCLFdBQVdwNEM7Z0JBQ2YsTUFBTyxDQUFDbzRDLFNBQVN0eEMsS0FBSyxHQUFJO29CQUN4QixJQUFJckQsS0FBS1IsSUFBSSxDQUFDbTFDLFdBQVc7d0JBQ3ZCLDJDQUEyQzt3QkFDM0N3cUIsZUFBZTt3QkFDZkgsT0FBT3ppRSxNQUFNLEdBQUcxaUIsV0FBVywwQkFBMEI7d0JBR3JEO29CQUNGO29CQUNBODZELFdBQVdBLFNBQVNwNEMsTUFBTTtnQkFDNUI7Z0JBQ0EsSUFBSSxDQUFDNGlFLGNBQWM7b0JBQ2pCLHdCQUF3QjtvQkFDeEI1aUUsTUFBTSxDQUFDLEVBQUUsQ0FBQ3RnQixRQUFRLENBQUNxZ0IsUUFBUSxDQUFDaGpCLElBQUksQ0FBQzBtQjtvQkFDakNBLEtBQUsvakIsUUFBUSxDQUFDc2dCLE1BQU0sR0FBR0EsTUFBTSxDQUFDLEVBQUU7b0JBRWhDLDZDQUE2QztvQkFDN0NtaUUsS0FBS3hqQixnQkFBZ0IsR0FBRztnQkFDMUI7WUFDRixFQUFFLE9BQU87UUFDWCxFQUFFLHNCQUFzQjtJQUMxQixFQUFFLGdCQUFnQjtJQUVsQixJQUFJTixTQUFTOWpFLE1BQU0sR0FBRyxHQUFHO1FBQ3ZCLElBQUlzb0YsV0FBV3hrQixTQUFTOWpFLE1BQU0sS0FBSzJHLE1BQUszRyxNQUFNLEdBQUcyRyxRQUFPLElBQUkyL0UsV0FBVy9pRSxJQUFJdWdEO1FBQzNFLElBQUssSUFBSWpzQyxNQUFNLEdBQUdBLE1BQU15d0QsU0FBU3RvRixNQUFNLEVBQUU2M0IsTUFBTztZQUM5QyxJQUFJMHdELFFBQVFELFFBQVEsQ0FBQ3p3RCxJQUFJO1lBQ3pCLElBQUkwd0QsTUFBTTdpRSxNQUFNLElBQUk7Z0JBQ2xCO1lBQ0Y7WUFFQSx5RUFBeUU7WUFDekU2aUUsTUFBTXRELGFBQWEsR0FBR3RCLG1CQUFtQjtZQUV6Qyx5RUFBeUU7WUFDekU0RSxNQUFNM2tFLE1BQU0sR0FBRysvRCxtQkFBbUI7WUFDbEM0RSxNQUFNMWtFLE1BQU0sR0FBRzgvRCxtQkFBbUI7UUFDcEM7UUFDQSxJQUFJNkU7UUFDSixJQUFJWixLQUFLeGpCLGdCQUFnQixFQUFFO1lBQ3pCb2tCLGdCQUFnQmpsRSxHQUFHcmUsVUFBVSxHQUFHMnFCLEtBQUssQ0FBQ3k0RCxVQUFVejRELEtBQUssQ0FBQ3k0RCxTQUFTaGhFLGNBQWMsSUFBSXVJLEtBQUssQ0FBQ3k0RCxTQUFTN2lFLE1BQU07UUFDeEcsT0FBTztZQUNMK2lFLGdCQUFnQkY7UUFDbEI7UUFDQUUsY0FBY3JpQix3QkFBd0IsR0FBR0oscUJBQXFCLEdBQUc3UixXQUFXLENBQUNnckI7UUFDN0UsSUFBSUEsZ0JBQWdCO1lBQ2xCb0osU0FBU3pnQixhQUFhLENBQUM7UUFDekIsT0FBTyxJQUFJOGYsV0FBVztZQUNwQlcsU0FBU255QixJQUFJLENBQUM7UUFDaEI7SUFDRjtJQUNBLE9BQU94dkQsT0FBTSxlQUFlO0FBQzlCO0FBQ0FxZ0YsU0FBU3ZpRSxPQUFPLEdBQUc7SUFDakIsSUFBSW5ELE1BQU0sSUFBSSxDQUFDLEVBQUU7SUFDakIsT0FBT0EsT0FBT0EsSUFBSW5jLFFBQVEsQ0FBQ3NmLE9BQU87QUFDcEM7QUFDQXVpRSxTQUFTeUIsTUFBTSxHQUFHO0lBQ2hCLElBQUlubkUsTUFBTSxJQUFJLENBQUMsRUFBRTtJQUNqQixPQUFPQSxPQUFPLENBQUNBLElBQUluYyxRQUFRLENBQUNzZixPQUFPO0FBQ3JDO0FBQ0F1aUUsU0FBU25PLE1BQU0sR0FBRztJQUNoQixJQUFJcUcsaUJBQWlCNTRFLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUN6RixJQUFJb2lGLGlCQUFpQnBpRixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDekYsSUFBSUssUUFBTyxJQUFJO0lBQ2YsSUFBSWdpRixlQUFlLEVBQUU7SUFDckIsSUFBSUMsa0JBQWtCLENBQUM7SUFDdkIsSUFBSXJsRSxLQUFLNWMsTUFBS3hCLFFBQVEsQ0FBQ29lLEVBQUU7SUFFekIsc0JBQXNCO0lBQ3RCLFNBQVNzbEUsa0JBQWtCMy9ELElBQUk7UUFDN0IsSUFBSTNELFFBQVEyRCxLQUFLL2pCLFFBQVEsQ0FBQ29nQixLQUFLO1FBQy9CLElBQUssSUFBSWhqQixJQUFJLEdBQUdBLElBQUlnakIsTUFBTXZsQixNQUFNLEVBQUV1QyxJQUFLO1lBQ3JDd2dCLElBQUl3QyxLQUFLLENBQUNoakIsRUFBRTtRQUNkO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsU0FBUzhoRSxZQUFZbjdDLElBQUk7UUFDdkIsSUFBSTFELFdBQVcwRCxLQUFLL2pCLFFBQVEsQ0FBQ3FnQixRQUFRO1FBQ3JDLElBQUssSUFBSWpqQixJQUFJLEdBQUdBLElBQUlpakIsU0FBU3hsQixNQUFNLEVBQUV1QyxJQUFLO1lBQ3hDd2dCLElBQUl5QyxRQUFRLENBQUNqakIsRUFBRTtRQUNqQjtJQUNGO0lBQ0EsU0FBU3dnQixJQUFJekIsR0FBRztRQUNkLElBQUl3bkUsZUFBZUYsZUFBZSxDQUFDdG5FLElBQUkwRyxFQUFFLEdBQUc7UUFDNUMsSUFBSTBnRSxrQkFBa0JwbkUsSUFBSW1ELE9BQU8sTUFBTXFrRSxjQUFjO1lBQ25EO1FBQ0YsT0FBTztZQUNMRixlQUFlLENBQUN0bkUsSUFBSTBHLEVBQUUsR0FBRyxHQUFHO1FBQzlCO1FBQ0EsSUFBSTFHLElBQUlvRSxNQUFNLElBQUk7WUFDaEJpakUsYUFBYW5tRixJQUFJLENBQUM4ZSxNQUFNLHlCQUF5QjtZQUVqRHVuRSxrQkFBa0J2bkU7WUFDbEIraUQsWUFBWS9pRDtRQUNkLE9BQU87WUFDTHFuRSxhQUFhMWdFLE9BQU8sQ0FBQzNHLE1BQU0sMEJBQTBCO1FBQ3ZEO0lBQ0Y7SUFFQSxzQ0FBc0M7SUFDdEMsbUVBQW1FO0lBRW5FLElBQUssSUFBSS9lLElBQUksR0FBR0QsSUFBSXFFLE1BQUszRyxNQUFNLEVBQUV1QyxJQUFJRCxHQUFHQyxJQUFLO1FBQzNDLElBQUkrZSxNQUFNM2EsS0FBSSxDQUFDcEUsRUFBRTtRQUNqQndnQixJQUFJekI7SUFDTjtJQUNBLFNBQVN5bkUsY0FBYzcvRCxJQUFJLEVBQUVDLElBQUk7UUFDL0IsSUFBSVAsaUJBQWlCTSxLQUFLL2pCLFFBQVEsQ0FBQ29nQixLQUFLO1FBQ3hDbEUsZ0JBQWdCdUgsZ0JBQWdCTztRQUVoQyxrRUFBa0U7UUFDbEVELEtBQUt5NkQsbUJBQW1CO0lBQzFCO0lBQ0EsU0FBU3FGLGtCQUFrQkMsT0FBTztRQUNoQywyRUFBMkU7UUFDM0VBLFFBQVF0RixtQkFBbUI7SUFDN0I7SUFDQSxJQUFJdUYsaUJBQWlCLEVBQUU7SUFDdkJBLGVBQWVDLEdBQUcsR0FBRyxDQUFDO0lBQ3RCLFNBQVNDLGVBQWUzakUsTUFBTSxFQUFFbkUsR0FBRztRQUNqQ0EsTUFBTUEsR0FBRyxDQUFDLEVBQUU7UUFDWm1FLFNBQVNBLE1BQU0sQ0FBQyxFQUFFO1FBQ2xCLElBQUlELFdBQVdDLE9BQU90Z0IsUUFBUSxDQUFDcWdCLFFBQVE7UUFDdkMsSUFBSTZqRSxNQUFNNWpFLE9BQU91QyxFQUFFO1FBQ25CM0csZ0JBQWdCbUUsVUFBVWxFLE1BQU0sNkJBQTZCO1FBRTdEQSxJQUFJbmMsUUFBUSxDQUFDc2dCLE1BQU0sR0FBRyxNQUFNLDZCQUE2QjtRQUV6RCxJQUFJLENBQUN5akUsZUFBZUMsR0FBRyxDQUFDRSxJQUFJLEVBQUU7WUFDNUJILGVBQWVDLEdBQUcsQ0FBQ0UsSUFBSSxHQUFHO1lBQzFCSCxlQUFlMW1GLElBQUksQ0FBQ2lqQjtRQUN0QjtJQUNGO0lBQ0E5ZSxNQUFLdy9ELHdCQUF3QjtJQUM3QixJQUFJdWlCLGdCQUFnQjtRQUNsQm5sRSxHQUFHbWxFLGNBQWMsQ0FBQ0MsZUFBZSx3QkFBd0I7SUFDM0Q7SUFDQSxJQUFLLElBQUlwZ0QsTUFBTSxHQUFHQSxNQUFNb2dELGFBQWEzb0YsTUFBTSxFQUFFdW9DLE1BQU87UUFDbEQsSUFBSStnRCxRQUFRWCxZQUFZLENBQUNwZ0QsSUFBSTtRQUM3QixJQUFJK2dELE1BQU03dEMsTUFBTSxJQUFJO1lBQ2xCLHdEQUF3RDtZQUN4RCxJQUFJanpCLE1BQU04Z0UsTUFBTTFsRSxNQUFNLEVBQUUsQ0FBQyxFQUFFO1lBQzNCLElBQUlsYixNQUFNNGdGLE1BQU16bEUsTUFBTSxFQUFFLENBQUMsRUFBRTtZQUMzQmtsRSxjQUFjdmdFLEtBQUs4Z0U7WUFDbkJQLGNBQWNyZ0YsS0FBSzRnRjtZQUNuQixJQUFJQyxXQUFXRCxNQUFNckUsYUFBYTtZQUNsQyxJQUFLLElBQUlyOEUsSUFBSSxHQUFHQSxJQUFJMmdGLFNBQVN2cEYsTUFBTSxFQUFFNEksSUFBSztnQkFDeEMsSUFBSXFnRixVQUFVTSxRQUFRLENBQUMzZ0YsRUFBRTtnQkFDekJvZ0Ysa0JBQWtCQztnQkFDbEIsSUFBSUEsUUFBUXZILGVBQWUsSUFBSTtvQkFDN0J1SCxRQUFRbGpCLHFCQUFxQjtnQkFDL0I7WUFDRjtRQUNGLE9BQU87WUFDTCw2QkFBNkI7WUFDN0IsSUFBSXRnRCxTQUFTNmpFLE1BQU03akUsTUFBTTtZQUN6QixJQUFJQSxPQUFPemxCLE1BQU0sS0FBSyxHQUFHO2dCQUN2Qm9wRixlQUFlM2pFLFFBQVE2akU7WUFDekI7UUFDRjtRQUNBLElBQUlaLGdCQUFnQjtZQUNsQixrQkFBa0I7WUFDbEJZLE1BQU1ua0YsUUFBUSxDQUFDc2YsT0FBTyxHQUFHO1FBQzNCO0lBQ0Y7SUFFQSxrREFBa0Q7SUFDbEQsSUFBSStrRSxrQkFBa0JqbUUsR0FBR3BlLFFBQVEsQ0FBQzIrRCxRQUFRO0lBQzFDdmdELEdBQUdwZSxRQUFRLENBQUNpL0QsZ0JBQWdCLEdBQUc7SUFDL0IsSUFBSyxJQUFJejRCLE1BQU0sR0FBR0EsTUFBTTY5QyxnQkFBZ0J4cEYsTUFBTSxFQUFFMnJDLE1BQU87UUFDckQsSUFBSTg5QyxRQUFRRCxlQUFlLENBQUM3OUMsSUFBSTtRQUNoQyxJQUFJODlDLE1BQU1sdkIsUUFBUSxJQUFJO1lBQ3BCaDNDLEdBQUdwZSxRQUFRLENBQUNpL0QsZ0JBQWdCLEdBQUc7WUFDL0I7UUFDRjtJQUNGO0lBQ0EsSUFBSXNsQixrQkFBa0IsSUFBSXBELFdBQVcsSUFBSSxDQUFDL2lFLEVBQUUsSUFBSW9sRTtJQUNoRCxJQUFJZSxnQkFBZ0I3bUUsSUFBSSxLQUFLLEdBQUc7UUFDOUIsOEVBQThFO1FBRTlFLElBQUlxOEQsZ0JBQWdCO1lBQ2xCd0ssZ0JBQWdCN2hCLGFBQWEsQ0FBQztRQUNoQyxPQUFPLElBQUk2Z0IsZ0JBQWdCO1lBQ3pCZ0IsZ0JBQWdCdnpCLElBQUksQ0FBQztRQUN2QjtJQUNGO0lBRUEsd0VBQXdFO0lBQ3hFLElBQUssSUFBSXZjLE1BQU0sR0FBR0EsTUFBTXN2QyxlQUFlbHBGLE1BQU0sRUFBRTQ1QyxNQUFPO1FBQ3BELElBQUkrdkMsUUFBUVQsY0FBYyxDQUFDdHZDLElBQUk7UUFDL0IsSUFBSSxDQUFDOHVDLGtCQUFrQixDQUFDaUIsTUFBTWxsRSxPQUFPLElBQUk7WUFDdkNrbEUsTUFBTXoxQixXQUFXO1FBQ25CO0lBQ0Y7SUFDQSxPQUFPdzFCO0FBQ1Q7QUFDQTFDLFNBQVNHLElBQUksR0FBRyxTQUFVeUMsTUFBTTtJQUM5QixJQUFJcm1FLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtJQUN6QixJQUFJOEosT0FBTyxJQUFJO0lBRWYsdUZBQXVGO0lBQ3ZGLDRFQUE0RTtJQUM1RSxJQUFJNnhELGlCQUFpQjtJQUNyQixJQUFJMkssYUFBYTtJQUNqQixJQUFJMW1GLFdBQVcsU0FBU0EsU0FBUzZrQixFQUFFO1FBQ2pDLE9BQU9BLE1BQU0sT0FBT0EsS0FBSyxLQUFLQTtJQUNoQyxHQUFHLG9CQUFvQjtJQUV2QixJQUFJNGhFLE9BQU9obUUsTUFBTSxLQUFLN2dCLGFBQWE2bUYsT0FBTy9sRSxNQUFNLEtBQUs5Z0IsV0FBVztRQUM5RCxJQUFJZ29DLFFBQVE1bkMsU0FBU3ltRixPQUFPaG1FLE1BQU07UUFDbEMsSUFBSW9uQixRQUFRN25DLFNBQVN5bUYsT0FBTy9sRSxNQUFNO1FBQ2xDLElBQUlpbUUsWUFBWS8rQyxTQUFTLFFBQVF4bkIsR0FBR2dPLGdCQUFnQixDQUFDd1o7UUFDckQsSUFBSWcvQyxZQUFZLytDLFNBQVMsUUFBUXpuQixHQUFHZ08sZ0JBQWdCLENBQUN5WjtRQUNyRCxJQUFJOCtDLGFBQWFDLFdBQVc7WUFDMUJ4bUUsR0FBR3ltRSxLQUFLLENBQUM7Z0JBQ1AsZ0NBQWdDO2dCQUNoQzM4RCxLQUFLd3JELE1BQU0sQ0FBQ3FHLGdCQUFnQjJLLGFBQWEscUJBQXFCO2dCQUM5RHg4RCxLQUFLdzZDLGFBQWEsQ0FBQztnQkFDbkIsSUFBSyxJQUFJdGxFLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7b0JBQ3BDLElBQUkrZSxNQUFNK0wsSUFBSSxDQUFDOXFCLEVBQUU7b0JBQ2pCLElBQUkwbkYsU0FBUzNvRSxJQUFJbmMsUUFBUSxDQUFDd2UsSUFBSTtvQkFDOUIsSUFBSXJDLElBQUltNkIsTUFBTSxJQUFJO3dCQUNoQixJQUFJcXVDLFdBQVc7NEJBQ2JHLE9BQU9ybUUsTUFBTSxHQUFHbW5CO3dCQUNsQjt3QkFDQSxJQUFJZy9DLFdBQVc7NEJBQ2JFLE9BQU9wbUUsTUFBTSxHQUFHbW5CO3dCQUNsQjtvQkFDRjtnQkFDRjtnQkFDQTNkLEtBQUs1SixPQUFPLENBQUN5N0QsZ0JBQWdCMkssYUFBYSw2QkFBNkI7WUFDekU7WUFDQXg4RCxLQUFLdzZDLGFBQWEsQ0FBQztRQUNyQjtJQUNGLE9BQU8sSUFBSStoQixPQUFPbmtFLE1BQU0sS0FBSzFpQixXQUFXO1FBQ3RDLDBCQUEwQjtRQUMxQixJQUFJb2xGLFdBQVdobEYsU0FBU3ltRixPQUFPbmtFLE1BQU07UUFDckMsSUFBSXlrRSxlQUFlL0IsYUFBYSxRQUFRNWtFLEdBQUdnTyxnQkFBZ0IsQ0FBQzQyRDtRQUM1RCxJQUFJK0IsY0FBYztZQUNoQixJQUFJQyxjQUFjaEMsYUFBYSxPQUFPcGxGLFlBQVlvbEY7WUFDbEQ1a0UsR0FBR3ltRSxLQUFLLENBQUM7Z0JBQ1AsZ0NBQWdDO2dCQUNoQyxJQUFJSSxVQUFVLzhELEtBQUt3ckQsTUFBTSxDQUFDcUcsZ0JBQWdCMkssYUFBYSxxQkFBcUI7Z0JBQzVFTyxRQUFRdmlCLGFBQWEsQ0FBQztnQkFDdEIsSUFBSyxJQUFJdGxFLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7b0JBQ3BDLElBQUkrZSxNQUFNK0wsSUFBSSxDQUFDOXFCLEVBQUU7b0JBQ2pCLElBQUk4bkYsU0FBUy9vRSxJQUFJbmMsUUFBUSxDQUFDd2UsSUFBSTtvQkFDOUIsSUFBSXJDLElBQUlvRSxNQUFNLElBQUk7d0JBQ2hCMmtFLE9BQU81a0UsTUFBTSxHQUFHMGtFO29CQUNsQjtnQkFDRjtnQkFDQUMsUUFBUTNtRSxPQUFPLENBQUN5N0QsZ0JBQWdCMkssYUFBYSw2QkFBNkI7WUFDNUU7WUFDQXg4RCxLQUFLdzZDLGFBQWEsQ0FBQztRQUNyQjtJQUNGO0lBQ0EsT0FBTyxJQUFJO0FBQ2I7QUFDQTtJQUFDM3BCO0lBQVV5WTtJQUFVQztJQUFVb0w7SUFBVW9CO0lBQVV6L0M7SUFBTXFoRDtJQUFVMlA7SUFBWTBEO0lBQVVHO0lBQVU2QztJQUFVUztJQUFVZTtJQUFVa0M7SUFBVStDO0lBQVVnQjtDQUFTLENBQUM1L0QsT0FBTyxDQUFDLFNBQVVpN0IsS0FBSztJQUNwTDUxQyxPQUFPeStFLFVBQVU3b0M7QUFDbkI7QUFFQSxJQUFJbXNDLFdBQVc7SUFDYnZuRSxLQUFLLFNBQVNBLElBQUk3QixJQUFJO1FBQ3BCLElBQUk0aUQ7UUFDSixJQUFJdmdELEtBQUssSUFBSTtRQUViLG1CQUFtQjtRQUNuQixJQUFJaGYsb0JBQW9CMmMsT0FBTztZQUM3QixJQUFJbU0sT0FBT25NO1lBQ1gsSUFBSW1NLEtBQUtsb0IsUUFBUSxDQUFDb2UsRUFBRSxLQUFLQSxJQUFJO2dCQUMzQixnQ0FBZ0M7Z0JBQ2hDdWdELFdBQVd6MkMsS0FBSzVKLE9BQU87WUFDekIsT0FBTztnQkFDTCw0QkFBNEI7Z0JBQzVCLElBQUlna0UsUUFBUSxFQUFFO2dCQUNkLElBQUssSUFBSWxsRixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO29CQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO29CQUNqQmtsRixNQUFNamxGLElBQUksQ0FBQzhlLElBQUlvbEUsSUFBSTtnQkFDckI7Z0JBQ0E1aUIsV0FBVyxJQUFJd2lCLFdBQVcvaUUsSUFBSWtrRTtZQUNoQztRQUNGLE9BR0ssSUFBSW5qRixNQUFNNGMsT0FBTztZQUNwQixJQUFJcXBFLFNBQVNycEU7WUFDYjRpRCxXQUFXLElBQUl3aUIsV0FBVy9pRSxJQUFJZ25FO1FBQ2hDLE9BR0ssSUFBSS9sRixZQUFZMGMsU0FBVTVjLENBQUFBLE1BQU00YyxLQUFLMkcsS0FBSyxLQUFLdmpCLE1BQU00YyxLQUFLcUUsS0FBSyxJQUFJO1lBQ3RFLElBQUlpbEUsY0FBY3RwRTtZQUNsQixJQUFJdXBFLFVBQVUsRUFBRTtZQUNoQixJQUFJQyxNQUFNO2dCQUFDO2dCQUFTO2FBQVE7WUFDNUIsSUFBSyxJQUFJemhFLEtBQUssR0FBR3d1QyxLQUFLaXpCLElBQUkxcUYsTUFBTSxFQUFFaXBCLEtBQUt3dUMsSUFBSXh1QyxLQUFNO2dCQUMvQyxJQUFJdkYsUUFBUWduRSxHQUFHLENBQUN6aEUsR0FBRztnQkFDbkIsSUFBSTBoRSxZQUFZSCxXQUFXLENBQUM5bUUsTUFBTTtnQkFDbEMsSUFBSXBmLE1BQU1xbUYsWUFBWTtvQkFDcEIsSUFBSyxJQUFJL2hGLElBQUksR0FBR2dpRixLQUFLRCxVQUFVM3FGLE1BQU0sRUFBRTRJLElBQUlnaUYsSUFBSWhpRixJQUFLO3dCQUNsRCxJQUFJODlFLE9BQU9uK0UsT0FBTzs0QkFDaEJtYixPQUFPQTt3QkFDVCxHQUFHaW5FLFNBQVMsQ0FBQy9oRixFQUFFO3dCQUNmNmhGLFFBQVFqb0YsSUFBSSxDQUFDa2tGO29CQUNmO2dCQUNGO1lBQ0Y7WUFDQTVpQixXQUFXLElBQUl3aUIsV0FBVy9pRSxJQUFJa25FO1FBQ2hDLE9BR0s7WUFDSCxJQUFJSSxRQUFRM3BFO1lBQ1o0aUQsV0FBVyxJQUFJeGdELFFBQVFDLElBQUlzbkUsT0FBTzNsRixVQUFVO1FBQzlDO1FBQ0EsT0FBTzQrRDtJQUNUO0lBQ0ErVSxRQUFRLFNBQVNBLE9BQU8zekUsVUFBVTtRQUNoQyxJQUFJWCxvQkFBb0JXO2FBQW9CLElBQUlkLE9BQU9jLGFBQWE7WUFDbEUsSUFBSXF4RCxXQUFXcnhEO1lBQ2ZBLGFBQWEsSUFBSSxDQUFDc3VCLENBQUMsQ0FBQytpQztRQUN0QjtRQUNBLE9BQU9yeEQsV0FBVzJ6RSxNQUFNO0lBQzFCO0FBQ0Y7QUFFQSx1QkFBdUIsR0FFdkIsdUhBQXVILEdBQ3ZILFNBQVNpUyxvQkFBb0JDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDN0MsSUFBSUMsb0JBQW9CLEdBQ3RCQyxtQkFBbUIsT0FDbkJDLHdCQUF3QixXQUN4QkMsNkJBQTZCLElBQzdCQyxtQkFBbUIsSUFDbkJDLGtCQUFrQixNQUFPRCxDQUFBQSxtQkFBbUIsR0FBRSxHQUM5Q0Usd0JBQXdCLE9BQU9DLGlCQUFpQjtJQUVsRCxnQ0FBZ0MsR0FDaEMsSUFBSXBsRixVQUFVdEcsTUFBTSxLQUFLLEdBQUc7UUFDMUIsT0FBTztJQUNUO0lBRUEsOEJBQThCLEdBQzlCLElBQUssSUFBSXVDLElBQUksR0FBR0EsSUFBSSxHQUFHLEVBQUVBLEVBQUc7UUFDMUIsSUFBSSxPQUFPK0QsU0FBUyxDQUFDL0QsRUFBRSxLQUFLLFlBQVlxQyxNQUFNMEIsU0FBUyxDQUFDL0QsRUFBRSxLQUFLLENBQUNtMkIsU0FBU3B5QixTQUFTLENBQUMvRCxFQUFFLEdBQUc7WUFDdEYsT0FBTztRQUNUO0lBQ0Y7SUFFQSx5Q0FBeUMsR0FDekN3b0YsTUFBTWptRixLQUFLK1UsR0FBRyxDQUFDa3hFLEtBQUs7SUFDcEJFLE1BQU1ubUYsS0FBSytVLEdBQUcsQ0FBQ294RSxLQUFLO0lBQ3BCRixNQUFNam1GLEtBQUs2VSxHQUFHLENBQUNveEUsS0FBSztJQUNwQkUsTUFBTW5tRixLQUFLNlUsR0FBRyxDQUFDc3hFLEtBQUs7SUFDcEIsSUFBSVUsZ0JBQWdCRix3QkFBd0IsSUFBSUMsYUFBYUgsb0JBQW9CLElBQUlwckYsTUFBTW9yRjtJQUMzRixTQUFTaDhELEVBQUVxOEQsR0FBRyxFQUFFQyxHQUFHO1FBQ2pCLE9BQU8sTUFBTSxNQUFNQSxNQUFNLE1BQU1EO0lBQ2pDO0lBQ0EsU0FBUzc2QyxFQUFFNjZDLEdBQUcsRUFBRUMsR0FBRztRQUNqQixPQUFPLE1BQU1BLE1BQU0sTUFBTUQ7SUFDM0I7SUFDQSxTQUFTOThDLEVBQUU4OEMsR0FBRztRQUNaLE9BQU8sTUFBTUE7SUFDZjtJQUNBLFNBQVNFLFdBQVdDLEVBQUUsRUFBRUgsR0FBRyxFQUFFQyxHQUFHO1FBQzlCLE9BQU8sQ0FBQyxDQUFDdDhELEVBQUVxOEQsS0FBS0MsT0FBT0UsS0FBS2g3QyxFQUFFNjZDLEtBQUtDLElBQUcsSUFBS0UsS0FBS2o5QyxFQUFFODhDLElBQUcsSUFBS0c7SUFDNUQ7SUFDQSxTQUFTQyxTQUFTRCxFQUFFLEVBQUVILEdBQUcsRUFBRUMsR0FBRztRQUM1QixPQUFPLE1BQU10OEQsRUFBRXE4RCxLQUFLQyxPQUFPRSxLQUFLQSxLQUFLLE1BQU1oN0MsRUFBRTY2QyxLQUFLQyxPQUFPRSxLQUFLajlDLEVBQUU4OEM7SUFDbEU7SUFDQSxTQUFTSyxxQkFBcUJDLEVBQUUsRUFBRUMsT0FBTztRQUN2QyxJQUFLLElBQUlsakUsS0FBSyxHQUFHQSxLQUFLa2lFLG1CQUFtQixFQUFFbGlFLEdBQUk7WUFDN0MsSUFBSW1qRSxlQUFlSixTQUFTRyxTQUFTcEIsS0FBS0U7WUFDMUMsSUFBSW1CLGlCQUFpQixLQUFLO2dCQUN4QixPQUFPRDtZQUNUO1lBQ0EsSUFBSW5sRCxXQUFXOGtELFdBQVdLLFNBQVNwQixLQUFLRSxPQUFPaUI7WUFDL0NDLFdBQVdubEQsV0FBV29sRDtRQUN4QjtRQUNBLE9BQU9EO0lBQ1Q7SUFDQSxTQUFTRTtRQUNQLElBQUssSUFBSXhqRSxNQUFNLEdBQUdBLE1BQU0waUUsa0JBQWtCLEVBQUUxaUUsSUFBSztZQUMvQzhpRSxhQUFhLENBQUM5aUUsSUFBSSxHQUFHaWpFLFdBQVdqakUsTUFBTTJpRSxpQkFBaUJULEtBQUtFO1FBQzlEO0lBQ0Y7SUFDQSxTQUFTcUIsZ0JBQWdCSixFQUFFLEVBQUVLLEVBQUUsRUFBRUMsRUFBRTtRQUNqQyxJQUFJeGxELFVBQ0Z5bEQsVUFDQWxxRixJQUFJO1FBQ04sR0FBRztZQUNEa3FGLFdBQVdGLEtBQUssQ0FBQ0MsS0FBS0QsRUFBQyxJQUFLO1lBQzVCdmxELFdBQVc4a0QsV0FBV1csVUFBVTFCLEtBQUtFLE9BQU9pQjtZQUM1QyxJQUFJbGxELFdBQVcsS0FBSztnQkFDbEJ3bEQsS0FBS0M7WUFDUCxPQUFPO2dCQUNMRixLQUFLRTtZQUNQO1FBQ0YsUUFBUzNuRixLQUFLMjNCLEdBQUcsQ0FBQ3VLLFlBQVlxa0QseUJBQXlCLEVBQUU5b0YsSUFBSStvRiw0QkFBNEI7UUFDekYsT0FBT21CO0lBQ1Q7SUFDQSxTQUFTQyxTQUFTUixFQUFFO1FBQ2xCLElBQUlTLGdCQUFnQixLQUNsQkMsZ0JBQWdCLEdBQ2hCQyxhQUFhdEIsbUJBQW1CO1FBQ2xDLE1BQU9xQixrQkFBa0JDLGNBQWNsQixhQUFhLENBQUNpQixjQUFjLElBQUlWLElBQUksRUFBRVUsY0FBZTtZQUMxRkQsaUJBQWlCbkI7UUFDbkI7UUFDQSxFQUFFb0I7UUFDRixJQUFJci9ELE9BQU8sQ0FBQzIrRCxLQUFLUCxhQUFhLENBQUNpQixjQUFjLElBQUtqQixDQUFBQSxhQUFhLENBQUNpQixnQkFBZ0IsRUFBRSxHQUFHakIsYUFBYSxDQUFDaUIsY0FBYyxHQUMvR0UsWUFBWUgsZ0JBQWdCcC9ELE9BQU9pK0QsaUJBQ25DdUIsZUFBZWYsU0FBU2MsV0FBVy9CLEtBQUtFO1FBQzFDLElBQUk4QixnQkFBZ0IzQixrQkFBa0I7WUFDcEMsT0FBT2EscUJBQXFCQyxJQUFJWTtRQUNsQyxPQUFPLElBQUlDLGlCQUFpQixLQUFLO1lBQy9CLE9BQU9EO1FBQ1QsT0FBTztZQUNMLE9BQU9SLGdCQUFnQkosSUFBSVMsZUFBZUEsZ0JBQWdCbkI7UUFDNUQ7SUFDRjtJQUNBLElBQUl3QixlQUFlO0lBQ25CLFNBQVNDO1FBQ1BELGVBQWU7UUFDZixJQUFJakMsUUFBUUMsT0FBT0MsUUFBUUMsS0FBSztZQUM5Qm1CO1FBQ0Y7SUFDRjtJQUNBLElBQUl4cUYsSUFBSSxTQUFTQSxFQUFFcXFGLEVBQUU7UUFDbkIsSUFBSSxDQUFDYyxjQUFjO1lBQ2pCQztRQUNGO1FBQ0EsSUFBSWxDLFFBQVFDLE9BQU9DLFFBQVFDLEtBQUs7WUFDOUIsT0FBT2dCO1FBQ1Q7UUFDQSxJQUFJQSxPQUFPLEdBQUc7WUFDWixPQUFPO1FBQ1Q7UUFDQSxJQUFJQSxPQUFPLEdBQUc7WUFDWixPQUFPO1FBQ1Q7UUFDQSxPQUFPSixXQUFXWSxTQUFTUixLQUFLbEIsS0FBS0U7SUFDdkM7SUFDQXJwRixFQUFFK3hFLGdCQUFnQixHQUFHO1FBQ25CLE9BQU87WUFBQztnQkFDTnQvRCxHQUFHeTJFO2dCQUNIaHRFLEdBQUdpdEU7WUFDTDtZQUFHO2dCQUNEMTJFLEdBQUcyMkU7Z0JBQ0hsdEUsR0FBR210RTtZQUNMO1NBQUU7SUFDSjtJQUNBLElBQUlqa0YsTUFBTSxvQkFBb0I7UUFBQzhqRjtRQUFLQztRQUFLQztRQUFLQztLQUFJLEdBQUc7SUFDckRycEYsRUFBRXNCLFFBQVEsR0FBRztRQUNYLE9BQU84RDtJQUNUO0lBQ0EsT0FBT3BGO0FBQ1Q7QUFFQSxxSkFBcUosR0FDcko7dUpBQ3VKLEdBQ3ZKLElBQUlxckYsb0JBQW9CO0lBQ3RCLFNBQVNDLDJCQUEyQnp1QyxLQUFLO1FBQ3ZDLE9BQU8sQ0FBQ0EsTUFBTTB1QyxPQUFPLEdBQUcxdUMsTUFBTXBxQyxDQUFDLEdBQUdvcUMsTUFBTTJ1QyxRQUFRLEdBQUczdUMsTUFBTXYzQyxDQUFDO0lBQzVEO0lBQ0EsU0FBU21tRixrQ0FBa0NDLFlBQVksRUFBRUMsRUFBRSxFQUFFQyxVQUFVO1FBQ3JFLElBQUkvdUMsUUFBUTtZQUNWcHFDLEdBQUdpNUUsYUFBYWo1RSxDQUFDLEdBQUdtNUUsV0FBVzd6RCxFQUFFLEdBQUc0ekQ7WUFDcENybUYsR0FBR29tRixhQUFhcG1GLENBQUMsR0FBR3NtRixXQUFXQyxFQUFFLEdBQUdGO1lBQ3BDSixTQUFTRyxhQUFhSCxPQUFPO1lBQzdCQyxVQUFVRSxhQUFhRixRQUFRO1FBQ2pDO1FBQ0EsT0FBTztZQUNMenpELElBQUk4a0IsTUFBTXYzQyxDQUFDO1lBQ1h1bUYsSUFBSVAsMkJBQTJCenVDO1FBQ2pDO0lBQ0Y7SUFDQSxTQUFTaXZDLHFCQUFxQmp2QyxLQUFLLEVBQUU4dUMsRUFBRTtRQUNyQyxJQUFJenRGLElBQUk7WUFDSjY1QixJQUFJOGtCLE1BQU12M0MsQ0FBQztZQUNYdW1GLElBQUlQLDJCQUEyQnp1QztRQUNqQyxHQUNBcjJDLElBQUlpbEYsa0NBQWtDNXVDLE9BQU84dUMsS0FBSyxLQUFLenRGLElBQ3ZEdTFCLElBQUlnNEQsa0NBQWtDNXVDLE9BQU84dUMsS0FBSyxLQUFLbmxGLElBQ3ZEeWxCLElBQUl3L0Qsa0NBQWtDNXVDLE9BQU84dUMsSUFBSWw0RCxJQUNqRHM0RCxPQUFPLE1BQU0sTUFBTzd0RixDQUFBQSxFQUFFNjVCLEVBQUUsR0FBRyxNQUFPdnhCLENBQUFBLEVBQUV1eEIsRUFBRSxHQUFHdEUsRUFBRXNFLEVBQUUsSUFBSTlMLEVBQUU4TCxFQUFFLEdBQ3JEaTBELE9BQU8sTUFBTSxNQUFPOXRGLENBQUFBLEVBQUUydEYsRUFBRSxHQUFHLE1BQU9ybEYsQ0FBQUEsRUFBRXFsRixFQUFFLEdBQUdwNEQsRUFBRW80RCxFQUFFLElBQUk1L0QsRUFBRTQvRCxFQUFFO1FBQ3ZEaHZDLE1BQU1wcUMsQ0FBQyxHQUFHb3FDLE1BQU1wcUMsQ0FBQyxHQUFHczVFLE9BQU9KO1FBQzNCOXVDLE1BQU12M0MsQ0FBQyxHQUFHdTNDLE1BQU12M0MsQ0FBQyxHQUFHMG1GLE9BQU9MO1FBQzNCLE9BQU85dUM7SUFDVDtJQUNBLE9BQU8sU0FBU292QyxpQkFBaUJWLE9BQU8sRUFBRUMsUUFBUSxFQUFFNXNDLFFBQVE7UUFDMUQsSUFBSXN0QyxZQUFZO1lBQ1p6NUUsR0FBRyxDQUFDO1lBQ0puTixHQUFHO1lBQ0hpbUYsU0FBUztZQUNUQyxVQUFVO1FBQ1osR0FDQWprRSxPQUFPO1lBQUM7U0FBRSxFQUNWNGtFLGNBQWMsR0FDZDd0RCxZQUFZLElBQUksT0FDaEI4dEQsS0FBSyxLQUFLLE1BQ1ZDLGVBQ0FWLElBQ0FXO1FBQ0ZmLFVBQVV4akYsV0FBV3dqRixZQUFZO1FBQ2pDQyxXQUFXempGLFdBQVd5akYsYUFBYTtRQUNuQzVzQyxXQUFXQSxZQUFZO1FBQ3ZCc3RDLFVBQVVYLE9BQU8sR0FBR0E7UUFDcEJXLFVBQVVWLFFBQVEsR0FBR0E7UUFDckJhLGdCQUFnQnp0QyxhQUFhO1FBRTdCLG1HQUFtRyxHQUNuRyxJQUFJeXRDLGVBQWU7WUFDakIsMENBQTBDLEdBQzFDRixjQUFjRixpQkFBaUJWLFNBQVNDO1lBQ3hDLG9DQUFvQyxHQUNwQ0csS0FBS1EsY0FBY3Z0QyxXQUFXd3RDO1FBQ2hDLE9BQU87WUFDTFQsS0FBS1M7UUFDUDtRQUNBLE9BQVM7WUFDUCx1QkFBdUIsR0FDdkJFLGFBQWFSLHFCQUFxQlEsY0FBY0osV0FBV1A7WUFDM0QsdUJBQXVCLEdBQ3ZCcGtFLEtBQUs1bUIsSUFBSSxDQUFDLElBQUkyckYsV0FBVzc1RSxDQUFDO1lBQzFCMDVFLGVBQWU7WUFDZiw4Q0FBOEMsR0FDOUMsSUFBSSxDQUFFbHBGLENBQUFBLEtBQUsyM0IsR0FBRyxDQUFDMHhELFdBQVc3NUUsQ0FBQyxJQUFJNnJCLGFBQWFyN0IsS0FBSzIzQixHQUFHLENBQUMweEQsV0FBV2huRixDQUFDLElBQUlnNUIsU0FBUSxHQUFJO2dCQUMvRTtZQUNGO1FBQ0Y7UUFFQTtrR0FDOEYsR0FDOUYsT0FBTyxDQUFDK3RELGdCQUFnQkYsY0FBYyxTQUFVSSxlQUFlO1lBQzdELE9BQU9obEUsSUFBSSxDQUFDZ2xFLGtCQUFtQmhsRSxDQUFBQSxLQUFLcHBCLE1BQU0sR0FBRyxLQUFLLEVBQUU7UUFDdEQ7SUFDRjtBQUNGO0FBRUEsSUFBSXF1RixjQUFjLFNBQVNBLFlBQVlycEQsRUFBRSxFQUFFdkwsRUFBRSxFQUFFd0wsRUFBRSxFQUFFdkwsRUFBRTtJQUNuRCxJQUFJNDBELFNBQVN4RCxvQkFBb0I5bEQsSUFBSXZMLElBQUl3TCxJQUFJdkw7SUFDN0MsT0FBTyxTQUFVekUsS0FBSyxFQUFFdkIsR0FBRyxFQUFFNjZELE9BQU87UUFDbEMsT0FBT3Q1RCxRQUFRLENBQUN2QixNQUFNdUIsS0FBSSxJQUFLcTVELE9BQU9DO0lBQ3hDO0FBQ0Y7QUFDQSxJQUFJQyxVQUFVO0lBQ1osVUFBVSxTQUFTQyxPQUFPeDVELEtBQUssRUFBRXZCLEdBQUcsRUFBRTY2RCxPQUFPO1FBQzNDLE9BQU90NUQsUUFBUSxDQUFDdkIsTUFBTXVCLEtBQUksSUFBS3M1RDtJQUNqQztJQUNBLGtCQUFrQjtJQUNsQixRQUFRRixZQUFZLE1BQU0sS0FBSyxNQUFNO0lBQ3JDLFdBQVdBLFlBQVksTUFBTSxHQUFHLEdBQUc7SUFDbkMsWUFBWUEsWUFBWSxHQUFHLEdBQUcsTUFBTTtJQUNwQyxlQUFlQSxZQUFZLE1BQU0sR0FBRyxNQUFNO0lBQzFDLE9BQU87SUFDUCxnQkFBZ0JBLFlBQVksTUFBTSxHQUFHLE9BQU87SUFDNUMsaUJBQWlCQSxZQUFZLE1BQU0sT0FBTyxPQUFPO0lBQ2pELG9CQUFvQkEsWUFBWSxPQUFPLE1BQU0sTUFBTTtJQUNuRCxPQUFPO0lBQ1AsZ0JBQWdCQSxZQUFZLE1BQU0sT0FBTyxNQUFNO0lBQy9DLGlCQUFpQkEsWUFBWSxNQUFNLE1BQU0sTUFBTTtJQUMvQyxvQkFBb0JBLFlBQVksT0FBTyxNQUFNLE9BQU87SUFDcEQsUUFBUTtJQUNSLGlCQUFpQkEsWUFBWSxNQUFNLE9BQU8sT0FBTztJQUNqRCxrQkFBa0JBLFlBQVksT0FBTyxNQUFNLE9BQU87SUFDbEQscUJBQXFCQSxZQUFZLE9BQU8sT0FBTyxPQUFPO0lBQ3RELFFBQVE7SUFDUixpQkFBaUJBLFlBQVksT0FBTyxNQUFNLE9BQU87SUFDakQsa0JBQWtCQSxZQUFZLE9BQU8sTUFBTSxNQUFNO0lBQ2pELHFCQUFxQkEsWUFBWSxNQUFNLEdBQUcsT0FBTztJQUNqRCxRQUFRO0lBQ1IsaUJBQWlCQSxZQUFZLE9BQU8sTUFBTSxPQUFPO0lBQ2pELGtCQUFrQkEsWUFBWSxNQUFNLEdBQUcsTUFBTTtJQUM3QyxxQkFBcUJBLFlBQVksTUFBTSxHQUFHLE1BQU07SUFDaEQsT0FBTztJQUNQLGdCQUFnQkEsWUFBWSxNQUFNLE1BQU0sT0FBTztJQUMvQyxpQkFBaUJBLFlBQVksTUFBTSxHQUFHLE1BQU07SUFDNUMsb0JBQW9CQSxZQUFZLEdBQUcsR0FBRyxHQUFHO0lBQ3pDLE9BQU87SUFDUCxnQkFBZ0JBLFlBQVksS0FBSyxNQUFNLE1BQU07SUFDN0MsaUJBQWlCQSxZQUFZLE9BQU8sTUFBTSxPQUFPO0lBQ2pELG9CQUFvQkEsWUFBWSxPQUFPLE9BQU8sTUFBTTtJQUNwRCx3QkFBd0I7SUFFeEIsVUFBVSxTQUFTSyxPQUFPdEIsT0FBTyxFQUFFQyxRQUFRLEVBQUU1c0MsUUFBUTtRQUNuRCxJQUFJQSxhQUFhLEdBQUc7WUFDbEIsbUNBQW1DO1lBQ25DLE9BQU8rdEMsUUFBUUMsTUFBTSxFQUFFLG1EQUFtRDtRQUM1RTtRQUNBLElBQUlDLFNBQVN4QixrQkFBa0JFLFNBQVNDLFVBQVU1c0M7UUFDbEQsT0FBTyxTQUFVeHJCLEtBQUssRUFBRXZCLEdBQUcsRUFBRTY2RCxPQUFPO1lBQ2xDLE9BQU90NUQsUUFBUSxDQUFDdkIsTUFBTXVCLEtBQUksSUFBS3k1RCxPQUFPSDtRQUN4QztJQUNGO0lBQ0EsZ0JBQWdCRjtBQUNsQjtBQUVBLFNBQVNNLGNBQWM5NUUsSUFBSSxFQUFFb2dCLEtBQUssRUFBRXZCLEdBQUcsRUFBRTY2RCxPQUFPLEVBQUVLLFFBQVE7SUFDeEQsSUFBSUwsWUFBWSxHQUFHO1FBQ2pCLE9BQU83NkQ7SUFDVDtJQUNBLElBQUl1QixVQUFVdkIsS0FBSztRQUNqQixPQUFPQTtJQUNUO0lBQ0EsSUFBSXhSLE1BQU0wc0UsU0FBUzM1RCxPQUFPdkIsS0FBSzY2RDtJQUMvQixJQUFJMTVFLFFBQVEsTUFBTTtRQUNoQixPQUFPcU47SUFDVDtJQUNBLElBQUlyTixLQUFLZzZFLFVBQVUsSUFBSWg2RSxLQUFLdkssS0FBSyxFQUFFO1FBQ2pDNFgsTUFBTXBkLEtBQUsrRSxLQUFLLENBQUNxWTtJQUNuQjtJQUNBLElBQUlyTixLQUFLZ0YsR0FBRyxLQUFLOVcsV0FBVztRQUMxQm1mLE1BQU1wZCxLQUFLNlUsR0FBRyxDQUFDdUksS0FBS3JOLEtBQUtnRixHQUFHO0lBQzlCO0lBQ0EsSUFBSWhGLEtBQUs4RSxHQUFHLEtBQUs1VyxXQUFXO1FBQzFCbWYsTUFBTXBkLEtBQUsrVSxHQUFHLENBQUNxSSxLQUFLck4sS0FBSzhFLEdBQUc7SUFDOUI7SUFDQSxPQUFPdUk7QUFDVDtBQUNBLFNBQVN3bEMsU0FBU3JGLElBQUksRUFBRW95QixJQUFJO0lBQzFCLElBQUlweUIsS0FBSzhsQixPQUFPLElBQUksUUFBUTlsQixLQUFLemdELEtBQUssSUFBSSxNQUFNO1FBQzlDLElBQUl5Z0QsS0FBSzhsQixPQUFPLElBQUksUUFBU3NNLENBQUFBLFFBQVEsUUFBUUEsS0FBSzUvRCxJQUFJLENBQUNtMEQsS0FBSyxLQUFLLEdBQUUsR0FBSTtZQUNyRSxPQUFPM21CLEtBQUs4bEIsT0FBTztRQUNyQixPQUFPO1lBQ0wsT0FBTzlsQixLQUFLemdELEtBQUs7UUFDbkI7SUFDRixPQUFPO1FBQ0wsT0FBT3lnRDtJQUNUO0FBQ0Y7QUFDQSxTQUFTeXNDLEtBQUtDLFNBQVMsRUFBRUMsT0FBTyxFQUFFVCxPQUFPLEVBQUVLLFFBQVEsRUFBRUssUUFBUTtJQUMzRCxJQUFJcDZFLE9BQU9vNkUsWUFBWSxPQUFPQSxTQUFTcDZFLElBQUksR0FBRztJQUM5QyxJQUFJMDVFLFVBQVUsR0FBRztRQUNmQSxVQUFVO0lBQ1osT0FBTyxJQUFJQSxVQUFVLEdBQUc7UUFDdEJBLFVBQVU7SUFDWjtJQUNBLElBQUl0NUQsUUFBUXl5QixTQUFTcW5DLFdBQVdFO0lBQ2hDLElBQUl2N0QsTUFBTWcwQixTQUFTc25DLFNBQVNDO0lBQzVCLElBQUl2cUYsU0FBU3V3QixVQUFVdndCLFNBQVNndkIsTUFBTTtRQUNwQyxPQUFPaTdELGNBQWM5NUUsTUFBTW9nQixPQUFPdkIsS0FBSzY2RCxTQUFTSztJQUNsRCxPQUFPLElBQUl0cUYsTUFBTTJ3QixVQUFVM3dCLE1BQU1vdkIsTUFBTTtRQUNyQyxJQUFJdzdELFdBQVcsRUFBRTtRQUNqQixJQUFLLElBQUkzc0YsSUFBSSxHQUFHQSxJQUFJbXhCLElBQUkxekIsTUFBTSxFQUFFdUMsSUFBSztZQUNuQyxJQUFJNHNGLEtBQUtsNkQsS0FBSyxDQUFDMXlCLEVBQUU7WUFDakIsSUFBSTQyQyxLQUFLemxCLEdBQUcsQ0FBQ254QixFQUFFO1lBQ2YsSUFBSTRzRixNQUFNLFFBQVFoMkMsTUFBTSxNQUFNO2dCQUM1QixJQUFJajNCLE1BQU15c0UsY0FBYzk1RSxNQUFNczZFLElBQUloMkMsSUFBSW8xQyxTQUFTSztnQkFDL0NNLFNBQVMxc0YsSUFBSSxDQUFDMGY7WUFDaEIsT0FBTztnQkFDTGd0RSxTQUFTMXNGLElBQUksQ0FBQzIyQztZQUNoQjtRQUNGO1FBQ0EsT0FBTysxQztJQUNUO0lBQ0EsT0FBT25zRjtBQUNUO0FBRUEsU0FBU3FzRixPQUFPem9GLEtBQUksRUFBRTY5QyxHQUFHLEVBQUU3dUMsR0FBRyxFQUFFNHFDLE1BQU07SUFDcEMsSUFBSWdELFNBQVMsQ0FBQ2hEO0lBQ2QsSUFBSXo4QixLQUFLbmQsTUFBS3hCLFFBQVE7SUFDdEIsSUFBSXkvQyxRQUFRSixJQUFJci9DLFFBQVE7SUFDeEIsSUFBSWtxRixVQUFVenFDLE1BQU1zNUIsTUFBTTtJQUMxQixJQUFJb1IsWUFBWTFxQyxNQUFNMHFDLFNBQVM7SUFDL0IsSUFBSS9yRSxLQUFLZzlCLFNBQVM1NUMsUUFBT0EsTUFBSzRjLEVBQUU7SUFDaEMsSUFBSWMsUUFBUWQsR0FBR2MsS0FBSztJQUNwQixJQUFJLENBQUN1Z0MsTUFBTTJxQyxVQUFVLEVBQUU7UUFDckIsSUFBSUYsV0FBVyxNQUFNO1lBQ25CLGNBQWM7WUFDZHpxQyxNQUFNMnFDLFVBQVUsR0FBR2YsT0FBTyxDQUFDLFNBQVM7UUFDdEMsT0FBTztZQUNMLHNCQUFzQjtZQUN0QixJQUFJZ0I7WUFDSixJQUFJcHJGLE9BQU9pckYsVUFBVTtnQkFDbkIsSUFBSUksYUFBYXByRSxNQUFNdzZDLEtBQUssQ0FBQyw4QkFBOEJ3d0I7Z0JBQzNERyxhQUFhQyxXQUFXN3RGLEtBQUs7WUFDL0IsT0FBTztnQkFDTCw4QkFBOEI7Z0JBQzlCNHRGLGFBQWFIO1lBQ2Y7WUFDQSxJQUFJaHNGLE1BQU1rRDtZQUNWLElBQUluQyxPQUFPb3JGLGFBQWE7Z0JBQ3RCbnNGLE9BQU9tc0Y7Z0JBQ1BqcEYsT0FBTyxFQUFFO1lBQ1gsT0FBTztnQkFDTGxELE9BQU9tc0YsVUFBVSxDQUFDLEVBQUU7Z0JBQ3BCanBGLE9BQU9pcEYsV0FBV3BzRixLQUFLLENBQUMsR0FBRzJRLEdBQUcsQ0FBQyxTQUFVN1QsQ0FBQztvQkFDeEMsT0FBTyxDQUFDQTtnQkFDVjtZQUNGO1lBQ0EsSUFBSXFHLEtBQUt2RyxNQUFNLEdBQUcsR0FBRztnQkFDbkIsbUJBQW1CO2dCQUNuQixJQUFJcUQsU0FBUyxVQUFVO29CQUNyQmtELEtBQUsvRCxJQUFJLENBQUNvaUQsTUFBTW5FLFFBQVEsR0FBRyxtQ0FBbUM7Z0JBQ2hFO2dCQUNBbUUsTUFBTTJxQyxVQUFVLEdBQUdmLE9BQU8sQ0FBQ25yRixLQUFLLENBQUN5RCxLQUFLLENBQUMsTUFBTVA7WUFDL0MsT0FBTztnQkFDTCxzQkFBc0I7Z0JBQ3RCcStDLE1BQU0ycUMsVUFBVSxHQUFHZixPQUFPLENBQUNuckYsS0FBSztZQUNsQztRQUNGO0lBQ0Y7SUFDQSxJQUFJNjZFLFNBQVN0NUIsTUFBTTJxQyxVQUFVO0lBQzdCLElBQUloQjtJQUNKLElBQUkzcEMsTUFBTW5FLFFBQVEsS0FBSyxHQUFHO1FBQ3hCOHRDLFVBQVU7SUFDWixPQUFPO1FBQ0xBLFVBQVUsQ0FBQzU0RSxNQUFNMjVFLFNBQVEsSUFBSzFxQyxNQUFNbkUsUUFBUTtJQUM5QztJQUNBLElBQUltRSxNQUFNL0QsUUFBUSxFQUFFO1FBQ2xCMHRDLFVBQVUzcEMsTUFBTTlELFFBQVE7SUFDMUI7SUFDQSxJQUFJeXRDLFVBQVUsR0FBRztRQUNmQSxVQUFVO0lBQ1osT0FBTyxJQUFJQSxVQUFVLEdBQUc7UUFDdEJBLFVBQVU7SUFDWjtJQUNBLElBQUkzcEMsTUFBTTVCLEtBQUssSUFBSSxNQUFNO1FBQ3ZCLGNBQWM7UUFFZCxJQUFJMHNDLFdBQVc5cUMsTUFBTTFELGFBQWE7UUFDbEMsSUFBSXl1QyxTQUFTL3FDLE1BQU03Z0MsUUFBUTtRQUMzQixJQUFJNHJFLFVBQVVwc0MsVUFBVSxDQUFDNThDLE1BQUtpZSxNQUFNLElBQUk7WUFDdEMsSUFBSWdoRCxTQUFTLENBQUM7WUFDZCxJQUFJblIsTUFBTWk3QixTQUFTcDdFLENBQUMsRUFBRXE3RSxPQUFPcjdFLENBQUMsR0FBRztnQkFDL0JzeEQsT0FBT3R4RCxDQUFDLEdBQUd3NkUsS0FBS1ksU0FBU3A3RSxDQUFDLEVBQUVxN0UsT0FBT3I3RSxDQUFDLEVBQUVpNkUsU0FBU3JRO1lBQ2pEO1lBQ0EsSUFBSXpwQixNQUFNaTdCLFNBQVMzeEUsQ0FBQyxFQUFFNHhFLE9BQU81eEUsQ0FBQyxHQUFHO2dCQUMvQjZuRCxPQUFPN25ELENBQUMsR0FBRyt3RSxLQUFLWSxTQUFTM3hFLENBQUMsRUFBRTR4RSxPQUFPNXhFLENBQUMsRUFBRXd3RSxTQUFTclE7WUFDakQ7WUFDQXYzRSxNQUFLb2QsUUFBUSxDQUFDNmhEO1FBQ2hCO1FBQ0EsSUFBSXZrQixXQUFXdUQsTUFBTXZELFFBQVE7UUFDN0IsSUFBSXV1QyxTQUFTaHJDLE1BQU1yK0IsR0FBRztRQUN0QixJQUFJQSxNQUFNekMsR0FBR3lDLEdBQUc7UUFDaEIsSUFBSXNwRSxlQUFlRCxVQUFVLFFBQVFydkM7UUFDckMsSUFBSXN2QyxjQUFjO1lBQ2hCLElBQUlwN0IsTUFBTXBULFNBQVMvc0MsQ0FBQyxFQUFFczdFLE9BQU90N0UsQ0FBQyxHQUFHO2dCQUMvQmlTLElBQUlqUyxDQUFDLEdBQUd3NkUsS0FBS3p0QyxTQUFTL3NDLENBQUMsRUFBRXM3RSxPQUFPdDdFLENBQUMsRUFBRWk2RSxTQUFTclE7WUFDOUM7WUFDQSxJQUFJenBCLE1BQU1wVCxTQUFTdGpDLENBQUMsRUFBRTZ4RSxPQUFPN3hFLENBQUMsR0FBRztnQkFDL0J3SSxJQUFJeEksQ0FBQyxHQUFHK3dFLEtBQUt6dEMsU0FBU3RqQyxDQUFDLEVBQUU2eEUsT0FBTzd4RSxDQUFDLEVBQUV3d0UsU0FBU3JRO1lBQzlDO1lBQ0F2M0UsTUFBS3d2RCxJQUFJLENBQUM7UUFDWjtRQUNBLElBQUk3VSxZQUFZc0QsTUFBTXRELFNBQVM7UUFDL0IsSUFBSXd1QyxVQUFVbHJDLE1BQU1wK0IsSUFBSTtRQUN4QixJQUFJdXBFLGdCQUFnQkQsV0FBVyxRQUFRdnZDO1FBQ3ZDLElBQUl3dkMsZUFBZTtZQUNqQixJQUFJdDdCLE1BQU1uVCxXQUFXd3VDLFVBQVU7Z0JBQzdCaHNFLEdBQUcwQyxJQUFJLEdBQUc4VCxNQUFNeFcsR0FBR2tzRSxPQUFPLEVBQUVsQixLQUFLeHRDLFdBQVd3dUMsU0FBU3ZCLFNBQVNyUSxTQUFTcDZELEdBQUdtc0UsT0FBTztZQUNuRjtZQUNBdHBGLE1BQUt3dkQsSUFBSSxDQUFDO1FBQ1o7UUFDQSxJQUFJMDVCLGdCQUFnQkUsZUFBZTtZQUNqQ3BwRixNQUFLd3ZELElBQUksQ0FBQztRQUNaO1FBQ0EsSUFBSWhZLFFBQVF5RyxNQUFNdmdDLEtBQUs7UUFDdkIsSUFBSTg1QixTQUFTQSxNQUFNbitDLE1BQU0sR0FBRyxLQUFLdWpELFFBQVE7WUFDdkMsSUFBSyxJQUFJaGhELElBQUksR0FBR0EsSUFBSTQ3QyxNQUFNbitDLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3JDLElBQUk4L0MsT0FBT2xFLEtBQUssQ0FBQzU3QyxFQUFFO2dCQUNuQixJQUFJMnRGLFFBQVE3dEMsS0FBS2gvQyxJQUFJO2dCQUNyQixJQUFJcXdCLE1BQU0ydUI7Z0JBQ1YsSUFBSXB0QixRQUFRMnZCLE1BQU16RCxVQUFVLENBQUMrdUMsTUFBTTtnQkFDbkMsSUFBSWpCLFdBQVc1cUUsTUFBTWkvQixVQUFVLENBQUNydUIsTUFBTTV4QixJQUFJLENBQUM7Z0JBQzNDLElBQUk4c0YsV0FBV3JCLEtBQUs3NUQsT0FBT3ZCLEtBQUs2NkQsU0FBU3JRLFFBQVErUTtnQkFDakQ1cUUsTUFBTStyRSxjQUFjLENBQUN6cEYsT0FBTXVwRixPQUFPQztZQUNwQyxFQUFFLFlBQVk7WUFFZHhwRixNQUFLd3ZELElBQUksQ0FBQztRQUNaLEVBQUUsS0FBSztJQUNUO0lBQ0F2UixNQUFNOUQsUUFBUSxHQUFHeXRDO0lBQ2pCLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTOTVCLE1BQU14L0IsS0FBSyxFQUFFdkIsR0FBRztJQUN2QixJQUFJdUIsU0FBUyxRQUFRdkIsT0FBTyxNQUFNO1FBQ2hDLE9BQU87SUFDVDtJQUNBLElBQUlodkIsU0FBU3V3QixVQUFVdndCLFNBQVNndkIsTUFBTTtRQUNwQyxPQUFPO0lBQ1QsT0FBTyxJQUFJdUIsU0FBU3ZCLEtBQUs7UUFDdkIsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBRUEsU0FBUzI4RCxlQUFlMXBGLEtBQUksRUFBRTY5QyxHQUFHLEVBQUU3dUMsR0FBRyxFQUFFNHFDLE1BQU07SUFDNUMsSUFBSXFFLFFBQVFKLElBQUlyL0MsUUFBUTtJQUN4QnkvQyxNQUFNbEUsT0FBTyxHQUFHO0lBQ2hCa0UsTUFBTTBxQyxTQUFTLEdBQUczNUUsTUFBTWl2QyxNQUFNOUQsUUFBUSxHQUFHOEQsTUFBTW5FLFFBQVE7QUFDekQ7QUFFQSxTQUFTNnZDLFFBQVEzNkUsR0FBRyxFQUFFNE4sRUFBRTtJQUN0QixJQUFJOEosT0FBTzlKLEdBQUdwZSxRQUFRLENBQUNvckYsT0FBTztJQUM5QixJQUFJQyxXQUFXLEVBQUU7SUFDakIsU0FBU0MsUUFBUW52RSxHQUFHLEVBQUVpL0IsTUFBTTtRQUMxQixJQUFJejhCLEtBQUt4QyxJQUFJbmMsUUFBUTtRQUNyQixJQUFJZ2dCLFVBQVVyQixHQUFHb0IsU0FBUyxDQUFDQyxPQUFPO1FBQ2xDLElBQUlDLFFBQVF0QixHQUFHb0IsU0FBUyxDQUFDRSxLQUFLO1FBQzlCLElBQUlzckUsVUFBVTtRQUVkLCtEQUErRDtRQUMvRCxJQUFJdnJFLFFBQVFubEIsTUFBTSxLQUFLLEdBQUc7WUFDeEIsSUFBSWdDLE9BQU9vakIsTUFBTStDLEtBQUs7WUFDdEIsSUFBSW5tQixNQUFNO2dCQUNSbWpCLFFBQVEzaUIsSUFBSSxDQUFDUjtZQUNmO1FBQ0Y7UUFDQSxJQUFJMnVGLFlBQVksU0FBU0EsVUFBVUMsVUFBVTtZQUMzQyxJQUFLLElBQUlob0YsSUFBSWdvRixXQUFXNXdGLE1BQU0sR0FBRyxHQUFHNEksS0FBSyxHQUFHQSxJQUFLO2dCQUMvQyxJQUFJNjJDLEtBQUtteEMsVUFBVSxDQUFDaG9GLEVBQUU7Z0JBQ3RCNjJDO1lBQ0Y7WUFDQW14QyxXQUFXcHZFLE1BQU0sQ0FBQyxHQUFHb3ZFLFdBQVc1d0YsTUFBTTtRQUN4QztRQUVBLDBCQUEwQjtRQUMxQixJQUFLLElBQUl1QyxJQUFJNGlCLFFBQVFubEIsTUFBTSxHQUFHLEdBQUd1QyxLQUFLLEdBQUdBLElBQUs7WUFDNUMsSUFBSWlpRCxNQUFNci9CLE9BQU8sQ0FBQzVpQixFQUFFO1lBQ3BCLElBQUlxaUQsUUFBUUosSUFBSXIvQyxRQUFRO1lBQ3hCLElBQUl5L0MsTUFBTWhELE9BQU8sRUFBRTtnQkFDakJ6OEIsUUFBUTNELE1BQU0sQ0FBQ2pmLEdBQUc7Z0JBQ2xCcWlELE1BQU1oRSxNQUFNLEdBQUc7Z0JBQ2ZnRSxNQUFNakUsT0FBTyxHQUFHO2dCQUNoQmlFLE1BQU1sRSxPQUFPLEdBQUc7Z0JBQ2hCaXdDLFVBQVUvckMsTUFBTTVELE1BQU07Z0JBQ3RCO1lBQ0Y7WUFDQSxJQUFJLENBQUM0RCxNQUFNakUsT0FBTyxJQUFJLENBQUNpRSxNQUFNL0QsUUFBUSxFQUFFO2dCQUNyQztZQUNGO1lBRUEsaURBQWlEO1lBQ2pELElBQUkrRCxNQUFNakUsT0FBTyxJQUFJaUUsTUFBTS9ELFFBQVEsRUFBRTtnQkFDbkMrRCxNQUFNL0QsUUFBUSxHQUFHO1lBQ25CO1lBQ0EsSUFBSSxDQUFDK0QsTUFBTWxFLE9BQU8sRUFBRTtnQkFDbEIydkMsZUFBZS91RSxLQUFLa2pDLEtBQUs3dUM7WUFDM0I7WUFDQXk1RSxPQUFPOXRFLEtBQUtrakMsS0FBSzd1QyxLQUFLNHFDO1lBQ3RCLElBQUlxRSxNQUFNL0QsUUFBUSxFQUFFO2dCQUNsQitELE1BQU0vRCxRQUFRLEdBQUc7WUFDbkI7WUFDQTh2QyxVQUFVL3JDLE1BQU01RCxNQUFNO1lBQ3RCLElBQUk0RCxNQUFNaXNDLElBQUksSUFBSSxNQUFNO2dCQUN0QmpzQyxNQUFNaXNDLElBQUksQ0FBQ2w3RTtZQUNiO1lBQ0EsSUFBSTZ1QyxJQUFJdEMsU0FBUyxJQUFJO2dCQUNuQi84QixRQUFRM0QsTUFBTSxDQUFDamYsR0FBRztnQkFDbEJxaUQsTUFBTWhFLE1BQU0sR0FBRztnQkFDZmdFLE1BQU1qRSxPQUFPLEdBQUc7Z0JBQ2hCaUUsTUFBTWxFLE9BQU8sR0FBRztnQkFDaEJpd0MsVUFBVS9yQyxNQUFNN0QsU0FBUztZQUMzQjtZQUNBMnZDLFVBQVU7UUFDWjtRQUNBLElBQUksQ0FBQ253QyxVQUFVcDdCLFFBQVFubEIsTUFBTSxLQUFLLEtBQUtvbEIsTUFBTXBsQixNQUFNLEtBQUssR0FBRztZQUN6RHd3RixTQUFTaHVGLElBQUksQ0FBQzhlO1FBQ2hCO1FBQ0EsT0FBT292RTtJQUNULEVBQUUsY0FBYztJQUVoQixrQkFBa0I7SUFDbEIsSUFBSUksWUFBWTtJQUNoQixJQUFLLElBQUk3d0YsSUFBSSxHQUFHQSxJQUFJb3RCLEtBQUtydEIsTUFBTSxFQUFFQyxJQUFLO1FBQ3BDLElBQUlxaEIsTUFBTStMLElBQUksQ0FBQ3B0QixFQUFFO1FBQ2pCLElBQUk4d0YsaUJBQWlCTixRQUFRbnZFO1FBQzdCd3ZFLFlBQVlBLGFBQWFDO0lBQzNCLEVBQUUsZUFBZTtJQUVqQixJQUFJQyxhQUFhUCxRQUFRbHRFLElBQUk7SUFFN0Isa0JBQWtCO0lBQ2xCLElBQUl1dEUsYUFBYUUsWUFBWTtRQUMzQixJQUFJM2pFLEtBQUtydEIsTUFBTSxHQUFHLEdBQUc7WUFDbkJ1akIsR0FBR3NoQyxNQUFNLENBQUMsUUFBUXgzQjtRQUNwQixPQUFPO1lBQ0w5SixHQUFHc2hDLE1BQU0sQ0FBQztRQUNaO0lBQ0Y7SUFFQSwyRUFBMkU7SUFDM0V4M0IsS0FBSzZzRCxPQUFPLENBQUNzVztJQUNianRFLEdBQUc0eUMsSUFBSSxDQUFDO0FBQ1YsRUFBRSxVQUFVO0FBRVosSUFBSTg2QixXQUFXO0lBQ2IsOEJBQThCO0lBQzlCL3RDLFNBQVN3VCxPQUFPeFQsT0FBTztJQUN2QmgrQixXQUFXd3hDLE9BQU94eEMsU0FBUztJQUMzQnc5QixVQUFVZ1UsT0FBT2hVLFFBQVE7SUFDekJJLFlBQVk0VCxPQUFPNVQsVUFBVTtJQUM3QkUsT0FBTzBULE9BQU8xVCxLQUFLO0lBQ25CRyxnQkFBZ0J1VCxPQUFPdlQsY0FBYztJQUNyQ3JCLE1BQU00VSxPQUFPNVUsSUFBSTtJQUNqQkosb0JBQW9CLFNBQVNBLG1CQUFtQnIwQixJQUFJO1FBQ2xELElBQUk5SixLQUFLLElBQUk7UUFDYixJQUFJLENBQUNBLEdBQUdzL0IsWUFBWSxJQUFJO1lBQ3RCO1FBQ0YsRUFBRSxpQ0FBaUM7UUFFbkN0L0IsR0FBR3BlLFFBQVEsQ0FBQ29yRixPQUFPLENBQUMxZ0UsS0FBSyxDQUFDeEM7SUFDNUI7SUFDQTZqRSxtQkFBbUIsU0FBU0E7UUFDMUIsSUFBSSxDQUFDL3JGLFFBQVEsQ0FBQ2dzRixpQkFBaUIsR0FBRztJQUNwQztJQUNBQyxvQkFBb0IsU0FBU0E7UUFDM0IsSUFBSTd0RSxLQUFLLElBQUk7UUFDYkEsR0FBR3BlLFFBQVEsQ0FBQ2dzRixpQkFBaUIsR0FBRztRQUNoQyxJQUFJLENBQUM1dEUsR0FBR3MvQixZQUFZLElBQUk7WUFDdEI7UUFDRixFQUFFLGlDQUFpQztRQUVuQyw0RUFBNEU7UUFDNUUsMERBQTBEO1FBRTFELFNBQVN3dUM7WUFDUCxJQUFJLENBQUM5dEUsR0FBR3BlLFFBQVEsQ0FBQ2dzRixpQkFBaUIsRUFBRTtnQkFDbEM7WUFDRjtZQUNBbjFFLHNCQUFzQixTQUFTczFFLGNBQWMzN0UsR0FBRztnQkFDOUMyNkUsUUFBUTM2RSxLQUFLNE47Z0JBQ2I4dEU7WUFDRjtRQUNGO1FBQ0EsSUFBSXZqQixXQUFXdnFELEdBQUd1cUQsUUFBUTtRQUMxQixJQUFJQSxZQUFZQSxTQUFTeWpCLFlBQVksRUFBRTtZQUNyQyx1Q0FBdUM7WUFDdkN6akIsU0FBU3lqQixZQUFZLENBQUMsU0FBU0Msc0JBQXNCQyxRQUFRLEVBQUU5N0UsR0FBRztnQkFDaEUyNkUsUUFBUTM2RSxLQUFLNE47WUFDZixHQUFHdXFELFNBQVM0akIsc0JBQXNCLENBQUNyVSxVQUFVO1FBQy9DLE9BQU87WUFDTCxzQ0FBc0M7WUFDdENnVSxnQkFBZ0IsYUFBYTtRQUMvQjtJQUNGO0FBQ0Y7QUFFQSxJQUFJTSxpQkFBaUI7SUFDbkI3YixrQkFBa0IsU0FBU0EsaUJBQWlCZ0MsU0FBUyxFQUFFQyxTQUFTO1FBQzlELElBQUlELGFBQWEsUUFBUUMsYUFBYSxNQUFNO1lBQzFDLE9BQU9ELGFBQWEsUUFBUUMsYUFBYTtRQUMzQyxPQUFPO1lBQ0wsT0FBT0QsVUFBVWhXLFFBQVEsQ0FBQ2lXO1FBQzVCO0lBQ0Y7SUFDQTlCLGNBQWMsU0FBU0EsYUFBYTF5RCxFQUFFLEVBQUVnMEQsUUFBUSxFQUFFRixRQUFRO1FBQ3hELElBQUk5Z0IsV0FBV2doQixTQUFTVCxTQUFTO1FBQ2pDLElBQUl2Z0IsWUFBWSxNQUFNO1lBQ3BCLE9BQU9oekMsT0FBTzh6RCxTQUFTeHpELE1BQU0sSUFBSTVlLFFBQVFveUUsU0FBU3h6RCxNQUFNLEtBQUsweUMsU0FBUzhELE9BQU8sQ0FBQ2dkLFNBQVN4ekQsTUFBTTtRQUMvRjtRQUNBLE9BQU87SUFDVDtJQUNBcXlELGdCQUFnQixTQUFTQSxlQUFlM3lELEVBQUUsRUFBRTJ6RCxHQUFHO1FBQzdDQSxJQUFJM3pELEVBQUUsR0FBR0E7UUFDVDJ6RCxJQUFJcnpELE1BQU0sR0FBR047SUFDZjtJQUNBNHlELGlCQUFpQixTQUFTQSxnQkFBZ0I1eUQsRUFBRSxFQUFFZzBELFFBQVEsRUFBRUYsUUFBUTtRQUM5RCxPQUFPRSxTQUFTVCxTQUFTLElBQUksT0FBT08sU0FBU3h6RCxNQUFNLEdBQUdOO0lBQ3hEO0FBQ0Y7QUFDQSxJQUFJNDBELGNBQWMsU0FBU0EsWUFBWUMsR0FBRztJQUN4QyxJQUFJaDBFLE9BQU9nMEUsTUFBTTtRQUNmLE9BQU8sSUFBSTFXLFNBQVMwVztJQUN0QixPQUFPO1FBQ0wsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsSUFBSXdaLFNBQVM7SUFDWGpyRSxlQUFlLFNBQVNBO1FBQ3RCLElBQUk3QyxLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSSxDQUFDMmUsR0FBR3cwRCxPQUFPLEVBQUU7WUFDZngwRCxHQUFHdzBELE9BQU8sR0FBRyxJQUFJNUIsUUFBUWliLGdCQUFnQixJQUFJO1FBQy9DO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQXJaLFNBQVMsU0FBU0E7UUFDaEIsT0FBTyxJQUFJLENBQUNuekUsUUFBUSxDQUFDbXpFLE9BQU87SUFDOUI7SUFDQXpqQixJQUFJLFNBQVNBLEdBQUd5QixNQUFNLEVBQUVDLFFBQVEsRUFBRXB6QyxRQUFRO1FBQ3hDLElBQUksQ0FBQ20xRCxPQUFPLEdBQUd6akIsRUFBRSxDQUFDeUIsUUFBUTZoQixZQUFZNWhCLFdBQVdwekM7UUFDakQsT0FBTyxJQUFJO0lBQ2I7SUFDQTh5QyxnQkFBZ0IsU0FBU0EsZUFBZUssTUFBTSxFQUFFQyxRQUFRLEVBQUVwekMsUUFBUTtRQUNoRSxJQUFJLENBQUNtMUQsT0FBTyxHQUFHcmlCLGNBQWMsQ0FBQ0ssUUFBUTZoQixZQUFZNWhCLFdBQVdwekM7UUFDN0QsT0FBTyxJQUFJO0lBQ2I7SUFDQXEwRCxvQkFBb0IsU0FBU0E7UUFDM0IsSUFBSSxDQUFDYyxPQUFPLEdBQUdkLGtCQUFrQjtRQUNqQyxPQUFPLElBQUk7SUFDYjtJQUNBRixLQUFLLFNBQVNBLElBQUloaEIsTUFBTSxFQUFFQyxRQUFRLEVBQUVwekMsUUFBUTtRQUMxQyxJQUFJLENBQUNtMUQsT0FBTyxHQUFHaEIsR0FBRyxDQUFDaGhCLFFBQVE2aEIsWUFBWTVoQixXQUFXcHpDO1FBQ2xELE9BQU8sSUFBSTtJQUNiO0lBQ0E2MEQsTUFBTSxTQUFTQSxLQUFLMWhCLE1BQU0sRUFBRUMsUUFBUSxFQUFFcHpDLFFBQVE7UUFDNUMsSUFBSSxDQUFDbTFELE9BQU8sR0FBR2hCLEdBQUcsQ0FBQ2hoQixRQUFRNmhCLFlBQVk1aEIsV0FBV3B6QztRQUNsRCxPQUFPLElBQUk7SUFDYjtJQUNBZ3pDLE1BQU0sU0FBU0EsS0FBS0csTUFBTSxFQUFFbWhCLFdBQVc7UUFDckMsSUFBSSxDQUFDYSxPQUFPLEdBQUduaUIsSUFBSSxDQUFDRyxRQUFRbWhCO1FBQzVCLE9BQU8sSUFBSTtJQUNiO0lBQ0E1UCxlQUFlLFNBQVNBLGNBQWN0aUUsS0FBSyxFQUFFOG5CLElBQUk7UUFDL0MsSUFBSSxDQUFDOG9DLElBQUksQ0FBQzV3RDtRQUNWLElBQUksQ0FBQ3MvQyxNQUFNLENBQUN0L0MsT0FBTzhuQjtRQUNuQixPQUFPLElBQUk7SUFDYjtBQUNGO0FBQ0FxcEMsT0FBT2YsY0FBYyxDQUFDaThCO0FBRXRCLElBQUlDLFdBQVc7SUFDYkMsS0FBSyxTQUFTQSxJQUFJaCtFLE9BQU87UUFDdkIsSUFBSWc2RCxXQUFXLElBQUksQ0FBQzNvRSxRQUFRLENBQUMyb0UsUUFBUTtRQUNyQ2g2RCxVQUFVQSxXQUFXLENBQUM7UUFDdEIsT0FBT2c2RCxTQUFTZ2tCLEdBQUcsQ0FBQ2grRTtJQUN0QjtJQUNBaStFLEtBQUssU0FBU0EsSUFBSWorRSxPQUFPO1FBQ3ZCLElBQUlnNkQsV0FBVyxJQUFJLENBQUMzb0UsUUFBUSxDQUFDMm9FLFFBQVE7UUFDckNoNkQsVUFBVUEsV0FBVyxDQUFDO1FBQ3RCQSxRQUFRaytFLEVBQUUsR0FBR2wrRSxRQUFRaytFLEVBQUUsSUFBSTtRQUMzQixPQUFPbGtCLFNBQVNpa0IsR0FBRyxDQUFDaitFO0lBQ3RCO0FBQ0Y7QUFDQSs5RSxTQUFTSSxJQUFJLEdBQUdKLFNBQVNFLEdBQUc7QUFFNUIsSUFBSUcsV0FBVztJQUNiM2MsUUFBUSxTQUFTQSxPQUFPemhFLE9BQU87UUFDN0IsSUFBSXlQLEtBQUssSUFBSTtRQUNiLElBQUl6UCxXQUFXLE1BQU07WUFDbkJvTSxNQUFNO1lBQ047UUFDRjtRQUNBLElBQUlwTSxRQUFRelEsSUFBSSxJQUFJLE1BQU07WUFDeEI2YyxNQUFNO1lBQ047UUFDRjtRQUNBLElBQUk3YyxPQUFPeVEsUUFBUXpRLElBQUk7UUFDdkIsSUFBSTh1RixTQUFTNXVFLEdBQUc2dUUsU0FBUyxDQUFDLFVBQVUvdUY7UUFDcEMsSUFBSTh1RixVQUFVLE1BQU07WUFDbEJqeUUsTUFBTSxxQkFBcUI3YyxPQUFPO1lBQ2xDO1FBQ0Y7UUFDQSxJQUFJZ3FCO1FBQ0osSUFBSWpwQixPQUFPMFAsUUFBUXVaLElBQUksR0FBRztZQUN4QkEsT0FBTzlKLEdBQUdpUSxDQUFDLENBQUMxZixRQUFRdVosSUFBSTtRQUMxQixPQUFPO1lBQ0xBLE9BQU92WixRQUFRdVosSUFBSSxJQUFJLE9BQU92WixRQUFRdVosSUFBSSxHQUFHOUosR0FBR2lRLENBQUM7UUFDbkQ7UUFDQSxJQUFJK2hELFNBQVMsSUFBSTRjLE9BQU81cEYsT0FBTyxDQUFDLEdBQUd1TCxTQUFTO1lBQzFDeVAsSUFBSUE7WUFDSjhKLE1BQU1BO1FBQ1I7UUFDQSxPQUFPa29EO0lBQ1Q7QUFDRjtBQUNBMmMsU0FBUzFULFlBQVksR0FBRzBULFNBQVMzVCxVQUFVLEdBQUcyVCxTQUFTM2MsTUFBTTtBQUU3RCxJQUFJOGMsV0FBVztJQUNieHRDLFFBQVEsU0FBU0EsT0FBT3l0QyxTQUFTLEVBQUVDLFNBQVM7UUFDMUMsSUFBSXp1RSxLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSSxJQUFJLENBQUM0aUUsUUFBUSxJQUFJO1lBQ25CamtELEdBQUcwdUUsa0JBQWtCLEdBQUcxdUUsR0FBRzB1RSxrQkFBa0IsSUFBSSxDQUFDO1lBQ2xELElBQUlubEUsT0FBT3ZKLEdBQUcwdUUsa0JBQWtCLENBQUNGLFVBQVUsR0FBR3h1RSxHQUFHMHVFLGtCQUFrQixDQUFDRixVQUFVLElBQUksSUFBSSxDQUFDcHRGLFVBQVU7WUFDakcsSUFBSXF0RixhQUFhLE1BQU07Z0JBQ3JCbGxFLEtBQUt3QyxLQUFLLENBQUMwaUU7WUFDYjtZQUNBLFFBQVEsNkNBQTZDO1FBQ3ZEO1FBQ0EsSUFBSSxDQUFDenVFLEdBQUcydUUsb0JBQW9CLEVBQUU7WUFDNUI7UUFDRixFQUFFLG1CQUFtQjtRQUVyQixJQUFJM2tCLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBRTVCLDZFQUE2RTtRQUM3RSxJQUFJLElBQUksQ0FBQzRrQixTQUFTLE1BQU0sQ0FBQzVrQixVQUFVO1lBQ2pDO1FBQ0Y7UUFDQUEsU0FBU2pwQixNQUFNLENBQUN5dEMsV0FBV0M7SUFDN0I7SUFDQUksZUFBZSxTQUFTQSxjQUFjQyxJQUFJO1FBQ3hDLElBQUlycEYsSUFBSSxJQUFJLENBQUNwRSxRQUFRO1FBQ3JCLElBQUl5dEYsU0FBUzd2RixXQUFXO1lBQ3RCLE9BQU93RyxFQUFFa3BGLG9CQUFvQjtRQUMvQixPQUFPO1lBQ0xscEYsRUFBRWtwRixvQkFBb0IsR0FBR0csT0FBTyxPQUFPO1FBQ3pDO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQUMsaUJBQWlCLFNBQVNBLGdCQUFnQjF2RSxRQUFRO1FBQ2hELElBQUksQ0FBQ3d2RSxhQUFhLENBQUM7UUFDbkJ4dkU7UUFDQSxJQUFJLENBQUN3dkUsYUFBYSxDQUFDO0lBQ3JCO0lBQ0E1cUIsVUFBVSxTQUFTQTtRQUNqQixPQUFPLElBQUksQ0FBQzVpRSxRQUFRLENBQUMydEYsVUFBVSxHQUFHO0lBQ3BDO0lBQ0F2c0IsWUFBWSxTQUFTQTtRQUNuQixJQUFJemlELEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QixJQUFJMmUsR0FBR2d2RSxVQUFVLElBQUksTUFBTTtZQUN6Qmh2RSxHQUFHZ3ZFLFVBQVUsR0FBRztRQUNsQjtRQUNBLElBQUlodkUsR0FBR2d2RSxVQUFVLEtBQUssR0FBRztZQUN2Qmh2RSxHQUFHczdELGNBQWMsR0FBRyxJQUFJLENBQUNsNkUsVUFBVTtZQUNuQzRlLEdBQUcwdUUsa0JBQWtCLEdBQUcsQ0FBQztRQUMzQjtRQUNBMXVFLEdBQUdndkUsVUFBVTtRQUNiLE9BQU8sSUFBSTtJQUNiO0lBQ0Fyc0IsVUFBVSxTQUFTQTtRQUNqQixJQUFJM2lELEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QixJQUFJMmUsR0FBR2d2RSxVQUFVLEtBQUssR0FBRztZQUN2QixPQUFPLElBQUk7UUFDYjtRQUNBaHZFLEdBQUdndkUsVUFBVTtRQUNiLElBQUlodkUsR0FBR2d2RSxVQUFVLEtBQUssR0FBRztZQUN2Qiw4QkFBOEI7WUFDOUJodkUsR0FBR3M3RCxjQUFjLENBQUNsckIsV0FBVztZQUM3QixJQUFJNFosV0FBVyxJQUFJLENBQUNBLFFBQVE7WUFFNUIscURBQXFEO1lBQ3JEL3NFLE9BQU80SCxJQUFJLENBQUNtYixHQUFHMHVFLGtCQUFrQixFQUFFdHZFLE9BQU8sQ0FBQyxTQUFVb3ZFLFNBQVM7Z0JBQzVELElBQUlqbEUsT0FBT3ZKLEdBQUcwdUUsa0JBQWtCLENBQUNGLFVBQVU7Z0JBQzNDLElBQUlqbEUsS0FBS2QsS0FBSyxJQUFJO29CQUNoQnVoRCxTQUFTanBCLE1BQU0sQ0FBQ3l0QztnQkFDbEIsT0FBTztvQkFDTHhrQixTQUFTanBCLE1BQU0sQ0FBQ3l0QyxXQUFXamxFO2dCQUM3QjtZQUNGO1FBQ0Y7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBMjhELE9BQU8sU0FBU0EsTUFBTTdtRSxRQUFRO1FBQzVCLElBQUksQ0FBQ29qRCxVQUFVO1FBQ2ZwakQ7UUFDQSxJQUFJLENBQUNzakQsUUFBUTtRQUNiLE9BQU8sSUFBSTtJQUNiO0lBQ0EsOEJBQThCO0lBQzlCc3NCLFdBQVcsU0FBU0EsVUFBVWgvRSxHQUFHO1FBQy9CLElBQUl3UCxLQUFLLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQ3ltRSxLQUFLLENBQUM7WUFDaEIsSUFBSWIsTUFBTXBvRixPQUFPNEgsSUFBSSxDQUFDb0w7WUFDdEIsSUFBSyxJQUFJeFIsSUFBSSxHQUFHQSxJQUFJNG1GLElBQUlucEYsTUFBTSxFQUFFdUMsSUFBSztnQkFDbkMsSUFBSXlsQixLQUFLbWhFLEdBQUcsQ0FBQzVtRixFQUFFO2dCQUNmLElBQUlvaEIsT0FBTzVQLEdBQUcsQ0FBQ2lVLEdBQUc7Z0JBQ2xCLElBQUkxRyxNQUFNaUMsR0FBRzhyQixjQUFjLENBQUNybkI7Z0JBQzVCMUcsSUFBSXFDLElBQUksQ0FBQ0E7WUFDWDtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUlxdkUsbUJBQW1CanlFLFdBQVc7SUFDaENreUUscUJBQXFCO0lBQ3JCQyxtQkFBbUI7SUFDbkJDLFlBQVk7SUFDWkMsbUJBQW1CO0lBQ25CQyxZQUFZdHdGO0lBQ1p1d0YscUJBQXFCO0lBQ3JCQyxtQkFBbUI7SUFDbkJDLGtCQUFrQjtJQUNsQkMsT0FBTztJQUNQQyxTQUFTO0lBQ1QsZ0JBQWdCO0lBQ2hCQyxPQUFPO0lBQ1BDLFlBQVk7SUFDWkMsdUJBQXVCO0lBQ3ZCLDJCQUEyQjtJQUMzQkMsY0FBYztJQUNkQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsZ0JBQWdCO0lBQ2hCQyxrQkFBa0I7SUFDbEJDLGNBQWM7UUFBQztRQUFLO1FBQUs7S0FBSTtBQUMvQjtBQUNBLElBQUlDLFdBQVc7SUFDYkMsVUFBVSxTQUFTQSxTQUFTamUsT0FBTyxFQUFFNXZELElBQUksRUFBRUQsR0FBRyxFQUFFK3RFLE9BQU87UUFDckQsSUFBSXgwRixJQUFJLElBQUksQ0FBQ3FGLFFBQVEsQ0FBQzJvRSxRQUFRO1FBQzlCaHVFLEVBQUV1MEYsUUFBUSxDQUFDamUsU0FBUzV2RCxNQUFNRCxLQUFLK3RFO1FBQy9CLE9BQU8sSUFBSTtJQUNiO0lBQ0F4bUIsVUFBVSxTQUFTQTtRQUNqQixPQUFPLElBQUksQ0FBQzNvRSxRQUFRLENBQUMyb0UsUUFBUTtJQUMvQjtJQUNBeW1CLGFBQWEsU0FBU0E7UUFDcEIsSUFBSSxDQUFDMXZDLE1BQU0sQ0FBQztRQUNaLE9BQU8sSUFBSTtJQUNiO0lBQ0EydkMsUUFBUSxTQUFTQTtRQUNmLElBQUksQ0FBQ0MsY0FBYztRQUNuQixJQUFJLENBQUM1c0IsYUFBYSxDQUFDO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0E2c0IsY0FBYyxTQUFTQSxhQUFhNWdGLE9BQU87UUFDekMsSUFBSXlQLEtBQUssSUFBSTtRQUNiLElBQUlveEUsZ0JBQWdCcHhFLEdBQUc2dUUsU0FBUyxDQUFDLFlBQVl0K0UsUUFBUXpRLElBQUk7UUFDekQsSUFBSXN4RixpQkFBaUIsTUFBTTtZQUN6QnowRSxNQUFNLHlDQUF5QzZLLE1BQU0sQ0FBQ2pYLFFBQVF6USxJQUFJLEVBQUU7WUFDcEU7UUFDRjtRQUNBLElBQUl5USxRQUFRMC9FLGdCQUFnQixLQUFLendGLFdBQVc7WUFDMUN3YyxLQUFLO1FBQ1A7UUFDQSxJQUFJcTFFLFFBQVE1QixpQkFBaUJsL0U7UUFDN0I4Z0YsTUFBTXJ4RSxFQUFFLEdBQUdBO1FBQ1hBLEdBQUdwZSxRQUFRLENBQUMyb0UsUUFBUSxHQUFHLElBQUk2bUIsY0FBY0M7UUFDekMsSUFBSSxDQUFDL3ZDLE1BQU0sQ0FBQztJQUNkO0lBQ0Fnd0MsaUJBQWlCLFNBQVNBO1FBQ3hCLElBQUl0eEUsS0FBSyxJQUFJO1FBQ2JBLEdBQUdzaEMsTUFBTSxDQUFDLFlBQVksdUJBQXVCO1FBRTdDLElBQUlpd0MsU0FBU3Z4RSxHQUFHd3hFLFNBQVM7UUFDekIsSUFBSUQsUUFBUTtZQUNWQSxPQUFPRSxNQUFNLEdBQUc7WUFDaEIsTUFBT0YsT0FBT0csVUFBVSxDQUFDajFGLE1BQU0sR0FBRyxFQUFHO2dCQUNuQzgwRixPQUFPSSxXQUFXLENBQUNKLE9BQU9HLFVBQVUsQ0FBQyxFQUFFO1lBQ3pDO1FBQ0Y7UUFDQTF4RSxHQUFHcGUsUUFBUSxDQUFDMm9FLFFBQVEsR0FBRyxNQUFNLG1DQUFtQztRQUNoRXZxRCxHQUFHdzFELGVBQWUsR0FBRzcxRCxPQUFPLENBQUMsU0FBVTVCLEdBQUc7WUFDeEMsSUFBSXdDLEtBQUt4QyxJQUFJbmMsUUFBUTtZQUNyQjJlLEdBQUd1QixRQUFRLEdBQUcsQ0FBQztZQUNmdkIsR0FBR1EsTUFBTSxHQUFHLENBQUM7WUFDYlIsR0FBR29CLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7WUFDekJyQixHQUFHb0IsU0FBUyxDQUFDRSxLQUFLLEdBQUcsRUFBRTtRQUN6QjtJQUNGO0lBQ0ErdkUsVUFBVSxTQUFTQSxTQUFTOXdGLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUN3d0QsRUFBRSxDQUFDLFVBQVV4d0Q7SUFDM0I7SUFDQSt3RixXQUFXLFNBQVNBLFVBQVUvd0YsRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQzAwQixHQUFHLENBQUMsVUFBVTEwQjtJQUM1QjtBQUNGO0FBQ0ErdkYsU0FBU2lCLG9CQUFvQixHQUFHakIsU0FBU0ksTUFBTTtBQUUvQyxJQUFJYyxXQUFXO0lBQ2IsbUJBQW1CO0lBQ25CLGdDQUFnQztJQUNoQyx3REFBd0Q7SUFDeEQsMEVBQTBFO0lBQzFFcHdGLFlBQVksU0FBU0EsV0FBV21vQixJQUFJLEVBQUVuTSxJQUFJO1FBQ3hDLElBQUk5YyxPQUFPaXBCLE9BQU87WUFDaEIsT0FBTyxJQUFJLENBQUNtRyxDQUFDLENBQUNuRztRQUNoQixPQUFPLElBQUk5b0Isb0JBQW9COG9CLE9BQU87WUFDcEMsT0FBT0EsS0FBS25vQixVQUFVO1FBQ3hCLE9BQU8sSUFBSVosTUFBTStvQixPQUFPO1lBQ3RCLElBQUksQ0FBQ25NLE1BQU07Z0JBQ1RBLE9BQU8sQ0FBQztZQUNWO1lBQ0EsT0FBTyxJQUFJb2xFLFdBQVcsSUFBSSxFQUFFajVELE1BQU1uTSxLQUFLcWxFLE1BQU0sRUFBRXJsRSxLQUFLdUQsT0FBTztRQUM3RDtRQUNBLE9BQU8sSUFBSTZoRSxXQUFXLElBQUk7SUFDNUI7SUFDQXorRCxPQUFPLFNBQVNBLE1BQU0wdUMsUUFBUTtRQUM1QixJQUFJMXVDLFFBQVEsSUFBSSxDQUFDMkwsQ0FBQyxDQUFDLFNBQVVsUyxHQUFHO1lBQzlCLE9BQU9BLElBQUlvRSxNQUFNO1FBQ25CO1FBQ0EsSUFBSTZ3QyxVQUFVO1lBQ1osT0FBTzF1QyxNQUFNNUUsTUFBTSxDQUFDc3pDO1FBQ3RCO1FBQ0EsT0FBTzF1QztJQUNUO0lBQ0F0QyxPQUFPLFNBQVNBLE1BQU1neEMsUUFBUTtRQUM1QixJQUFJaHhDLFFBQVEsSUFBSSxDQUFDaU8sQ0FBQyxDQUFDLFNBQVVsUyxHQUFHO1lBQzlCLE9BQU9BLElBQUltNkIsTUFBTTtRQUNuQjtRQUNBLElBQUk4YSxVQUFVO1lBQ1osT0FBT2h4QyxNQUFNdEMsTUFBTSxDQUFDc3pDO1FBQ3RCO1FBQ0EsT0FBT2h4QztJQUNUO0lBQ0EsK0JBQStCO0lBQy9CaU8sR0FBRyxTQUFTQSxFQUFFK2lDLFFBQVE7UUFDcEIsSUFBSWxwQyxPQUFPLElBQUksQ0FBQ2xvQixRQUFRLENBQUMyK0QsUUFBUTtRQUNqQyxJQUFJdk4sVUFBVTtZQUNaLE9BQU9scEMsS0FBS3BLLE1BQU0sQ0FBQ3N6QztRQUNyQixPQUFPO1lBQ0wsT0FBT2xwQyxLQUFLcXNELFNBQVM7UUFDdkI7SUFDRjtJQUNBWCxpQkFBaUIsU0FBU0E7UUFDeEIsT0FBTyxJQUFJLENBQUM1ekUsUUFBUSxDQUFDMitELFFBQVE7SUFDL0I7QUFDRjtBQUVBLFVBQVU7QUFDVnd4QixTQUFTeHhCLFFBQVEsR0FBR3d4QixTQUFTcnlFLE1BQU0sR0FBR3F5RSxTQUFTOWhFLENBQUM7QUFFaEQsSUFBSStoRSxVQUFVLENBQUM7QUFFZixxQ0FBcUM7QUFDckMsSUFBSXA3QixPQUFPO0FBQ1gsSUFBSXE3QixRQUFRO0FBRVosc0NBQXNDO0FBQ3RDLDBDQUEwQztBQUMxQyxlQUFlO0FBQ2YsNEJBQTRCO0FBQzVCRCxRQUFRenVGLEtBQUssR0FBRyxTQUFVdW1CLElBQUk7SUFDNUIsSUFBSTFtQixRQUFPLElBQUk7SUFDZixJQUFJbWQsS0FBS25kLE1BQUt4QixRQUFRO0lBQ3RCLElBQUlvZSxLQUFLTyxHQUFHUCxFQUFFO0lBQ2QsSUFBSTg3RCxjQUFjOTdELEdBQUdyZSxVQUFVO0lBQy9CLElBQUssSUFBSXV3RixLQUFLLEdBQUdBLEtBQUtwb0UsS0FBS3J0QixNQUFNLEVBQUV5MUYsS0FBTTtRQUN2QyxJQUFJbjBFLE1BQU0rTCxJQUFJLENBQUNvb0UsR0FBRztRQUNsQixJQUFJQyxVQUFVL3VGLE1BQUtndkYsY0FBYyxDQUFDcjBFO1FBQ2xDLElBQUlvMEUsUUFBUW5wRSxLQUFLLEVBQUU7WUFDakI7UUFDRjtRQUNBLElBQUlxcEUsV0FBV2p2RixNQUFLa3ZGLGVBQWUsQ0FBQ0g7UUFDcEMsSUFBSUksTUFBTW52RixNQUFLb3ZGLGlCQUFpQixDQUFDTCxTQUFTRSxVQUFVdDBFO1FBQ3BELElBQUlBLElBQUluYyxRQUFRLENBQUM2d0YsZ0JBQWdCLEVBQUU7WUFDakNydkYsTUFBS3M1RSxpQkFBaUIsQ0FBQzMrRCxLQUFLdzBFLElBQUlHLFNBQVM7UUFDM0MsT0FBTztZQUNMMzBFLElBQUluYyxRQUFRLENBQUM2d0YsZ0JBQWdCLEdBQUc7UUFDbEM7UUFDQSxJQUFJRSxZQUFZdnZGLE1BQUt3dkYsZ0JBQWdCLENBQUM3MEU7UUFDdEMsSUFBSTQwRSxXQUFXO1lBQ2I3VyxZQUFZNzhFLElBQUksQ0FBQzhlO1FBQ25CO0lBQ0YsRUFBRSxlQUFlO0lBRWpCLE9BQU8rOUQ7QUFDVDtBQUNBa1csUUFBUWEsaUJBQWlCLEdBQUcsU0FBVUMsU0FBUyxFQUFFQyxTQUFTO0lBQ3hELElBQUkzdkYsUUFBTyxJQUFJO0lBQ2YsSUFBSUksUUFBUUosTUFBS3hCLFFBQVEsQ0FBQ294RixTQUFTLEdBQUc1dkYsTUFBS3hCLFFBQVEsQ0FBQ294RixTQUFTLElBQUksQ0FBQztJQUNsRSxJQUFJQyxhQUFhSCxZQUFZLE1BQU1DO0lBQ25DLElBQUlHLFlBQVkxdkYsS0FBSyxDQUFDeXZGLFdBQVc7SUFDakMsSUFBSUMsV0FBVztRQUNiLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJUixZQUFZLEVBQUU7SUFDbEIsSUFBSVMsWUFBWSxDQUFDO0lBQ2pCLElBQUssSUFBSW4wRixJQUFJLEdBQUdBLElBQUlvRSxNQUFLM0csTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJbzBGLE1BQU1od0YsS0FBSSxDQUFDcEUsRUFBRTtRQUNqQixJQUFJcTBGLFlBQVlQLFNBQVMsQ0FBQzl6RixFQUFFLEtBQUs0M0Q7UUFDakMsSUFBSTA4QixZQUFZUCxTQUFTLENBQUMvekYsRUFBRSxLQUFLNDNEO1FBQ2pDLElBQUkyOEIsZUFBZUYsY0FBY0M7UUFDakMsSUFBSUUsb0JBQW9CSixJQUFJSyxnQkFBZ0IsQ0FBQ2gzRixNQUFNLEdBQUc7UUFDdEQsSUFBSTgyRixnQkFBZ0JELGFBQWFFLG1CQUFtQjtZQUNsRCxJQUFJNTRDLFFBQVFwN0M7WUFDWixJQUFJK3pGLGdCQUFnQkMsbUJBQW1CO2dCQUNyQzU0QyxRQUFRdzRDLElBQUlyekMsVUFBVSxFQUFFLDBEQUEwRDtZQUNwRixPQUFPLElBQUl3ekMsY0FBYztnQkFDdkIzNEMsUUFBUXc0QyxJQUFJcnpDLFVBQVUsRUFBRSx5QkFBeUI7WUFDbkQsT0FBTyxJQUFJeXpDLG1CQUFtQjtnQkFDNUI1NEMsUUFBUXc0QyxJQUFJSyxnQkFBZ0IsRUFBRSw0QkFBNEI7WUFDNUQ7WUFDQSxJQUFLLElBQUlwdUYsSUFBSSxHQUFHQSxJQUFJdTFDLE1BQU1uK0MsTUFBTSxFQUFFNEksSUFBSztnQkFDckMsSUFBSXk1QyxPQUFPbEUsS0FBSyxDQUFDdjFDLEVBQUU7Z0JBQ25CLElBQUl2RixPQUFPZy9DLEtBQUtoL0MsSUFBSTtnQkFFcEIsaUhBQWlIO2dCQUNqSCxpSEFBaUg7Z0JBQ2pILGFBQWE7Z0JBQ2IsSUFBSTR6RixvQkFBb0I7Z0JBQ3hCLElBQUssSUFBSXB3RixJQUFJdEUsSUFBSSxHQUFHc0UsSUFBSUYsTUFBSzNHLE1BQU0sRUFBRTZHLElBQUs7b0JBQ3hDLElBQUlxd0YsV0FBV3Z3RixLQUFJLENBQUNFLEVBQUU7b0JBQ3RCLElBQUlzd0YsY0FBY2IsU0FBUyxDQUFDenZGLEVBQUUsS0FBS3N6RDtvQkFDbkMsSUFBSSxDQUFDZzlCLGFBQWE7d0JBQ2hCO29CQUNGLEVBQUUsOENBQThDO29CQUVoREYsb0JBQW9CQyxTQUFTNXpDLFVBQVUsQ0FBQ2pCLEtBQUtoL0MsSUFBSSxDQUFDLElBQUk7b0JBQ3RELElBQUk0ekYsbUJBQW1CO3dCQUNyQjtvQkFDRixFQUFFLG9EQUFvRDtnQkFDeEQ7Z0JBQ0EsSUFBSSxDQUFDUCxTQUFTLENBQUNyekYsS0FBSyxJQUFJLENBQUM0ekYsbUJBQW1CO29CQUMxQ1AsU0FBUyxDQUFDcnpGLEtBQUssR0FBRztvQkFDbEI0eUYsVUFBVXp6RixJQUFJLENBQUNhO2dCQUNqQjtZQUNGLEVBQUUsWUFBWTtRQUNoQixFQUFFLEtBQUs7SUFDVCxFQUFFLGVBQWU7SUFFakIwRCxLQUFLLENBQUN5dkYsV0FBVyxHQUFHUDtJQUNwQixPQUFPQTtBQUNUO0FBQ0FWLFFBQVFJLGNBQWMsR0FBRyxTQUFVcjBFLEdBQUc7SUFDcEMsSUFBSTNhLFFBQU8sSUFBSTtJQUNmLElBQUl5d0YsU0FBUztJQUNiLElBQUluQjtJQUNKLElBQUlvQixVQUFVLzFFLElBQUluYyxRQUFRLENBQUNteUYsV0FBVyxJQUFJO0lBRTFDLGtCQUFrQjtJQUNsQixJQUFLLElBQUkvMEYsSUFBSSxHQUFHQSxJQUFJb0UsTUFBSzNHLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSTZ6RSxVQUFVenZFLEtBQUksQ0FBQ3BFLEVBQUU7UUFDckIsSUFBSWcxRix5QkFBeUJuaEIsUUFBUTdmLFFBQVEsSUFBSTZmLFFBQVE3ZixRQUFRLENBQUM4RCxPQUFPLENBQUMvNEMsTUFBTSw4Q0FBOEM7UUFFOUgsSUFBSWkyRSx3QkFBd0I7WUFDMUJILFVBQVVqOUI7UUFDWixPQUFPO1lBQ0xpOUIsVUFBVTVCO1FBQ1o7SUFDRixFQUFFLGNBQWM7SUFFaEJTLFlBQVl0dkYsTUFBS3l2RixpQkFBaUIsQ0FBQ2lCLFNBQVNEO0lBQzVDOTFFLElBQUluYyxRQUFRLENBQUNteUYsV0FBVyxHQUFHRjtJQUMzQixPQUFPO1FBQ0xsMkYsS0FBS2syRjtRQUNMSSxlQUFldkI7UUFDZjFwRSxPQUFPMHBFLFVBQVVqMkYsTUFBTSxLQUFLO0lBQzlCO0FBQ0Y7QUFFQSw2REFBNkQ7QUFDN0R1MUYsUUFBUU0sZUFBZSxHQUFHLFNBQVVILE9BQU87SUFDekMsSUFBSTBCLFNBQVMxQixRQUFReDBGLEdBQUc7SUFDeEIsSUFBSXlGLFFBQU8sSUFBSTtJQUNmLElBQUk4d0YsWUFBWSxJQUFJLENBQUN0eUYsUUFBUSxDQUFDdXlGLGFBQWEsR0FBRyxJQUFJLENBQUN2eUYsUUFBUSxDQUFDdXlGLGFBQWEsSUFBSSxDQUFDO0lBRTlFLGtEQUFrRDtJQUNsRCxJQUFJRCxTQUFTLENBQUNMLE9BQU8sRUFBRTtRQUNyQixPQUFPSyxTQUFTLENBQUNMLE9BQU87SUFDMUI7SUFDQSxJQUFJL3lFLFFBQVE7UUFDVmxmLFVBQVU7WUFDUmpFLEtBQUtrMkY7UUFDUDtJQUNGO0lBQ0EsSUFBSyxJQUFJNzBGLElBQUksR0FBR0EsSUFBSW9FLE1BQUszRyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3BDLElBQUlvMEYsTUFBTWh3RixLQUFJLENBQUNwRSxFQUFFO1FBQ2pCLElBQUlvMUYsU0FBU1AsTUFBTSxDQUFDNzBGLEVBQUUsS0FBSzQzRDtRQUMzQixJQUFJLENBQUN3OUIsUUFBUTtZQUNYO1FBQ0Y7UUFDQSxJQUFLLElBQUkvdUYsSUFBSSxHQUFHQSxJQUFJK3RGLElBQUlyekMsVUFBVSxDQUFDdGpELE1BQU0sRUFBRTRJLElBQUs7WUFDOUMsSUFBSXk1QyxPQUFPczBDLElBQUlyekMsVUFBVSxDQUFDMTZDLEVBQUU7WUFDNUJ5YixLQUFLLENBQUNnK0IsS0FBS2gvQyxJQUFJLENBQUMsR0FBR2cvQztRQUNyQjtJQUNGO0lBQ0FvMUMsU0FBUyxDQUFDTCxPQUFPLEdBQUcveUU7SUFDcEIsT0FBT0E7QUFDVDtBQUNBa3hFLFFBQVFRLGlCQUFpQixHQUFHLFNBQVVMLE9BQU8sRUFBRUUsUUFBUSxFQUFFdDBFLEdBQUc7SUFDMUQsSUFBSTNhLFFBQU8sSUFBSTtJQUNmLElBQUlzdkYsWUFBWVAsUUFBUThCLGFBQWE7SUFDckMsSUFBSUksZUFBZSxDQUFDO0lBQ3BCLElBQUlDLFFBQVFseEYsTUFBS2t4RixLQUFLO0lBQ3RCLElBQUssSUFBSXQxRixJQUFJLEdBQUdBLElBQUkwekYsVUFBVWoyRixNQUFNLEVBQUV1QyxJQUFLO1FBQ3pDLElBQUl1MUYsZUFBZTdCLFNBQVMsQ0FBQzF6RixFQUFFO1FBQy9CLElBQUl3MUYsVUFBVW5DLFFBQVEsQ0FBQ2tDLGFBQWE7UUFDcEMsSUFBSUUsVUFBVTEyRSxJQUFJNG1ELE1BQU0sQ0FBQzR2QjtRQUN6QixJQUFJLENBQUNDLFNBQVM7WUFDWiwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDQyxTQUFTO2dCQUNaLFVBQVUscURBQXFEO1lBQy9ELCtFQUErRTtZQUNqRixPQUFPLElBQUlBLFFBQVFweEUsTUFBTSxFQUFFO2dCQUN6Qm14RSxVQUFVO29CQUNSMTBGLE1BQU15MEY7b0JBQ05HLGdCQUFnQjtnQkFDbEI7WUFDRixPQUFPO2dCQUNMRixVQUFVO29CQUNSMTBGLE1BQU15MEY7b0JBQ04sVUFBVTtnQkFDWjtZQUNGO1FBQ0Y7UUFFQSwrREFBK0Q7UUFDL0QsSUFBSUUsWUFBWUQsU0FBUztZQUN2QjtRQUNGO1FBRUEsb0VBQW9FO1FBQ3BFLElBQUlBLFFBQVFHLE1BQU0sS0FBS0wsTUFBTXh6RixFQUFFLENBQUMsa0NBQWtDO1lBQy9EMnpGLFdBQVcsS0FBSyxrRkFBa0Y7WUFDbEdBLFFBQVFHLE9BQU8sSUFBSSxLQUFLLGtEQUFrRDtZQUMxRUgsUUFBUUcsT0FBTyxDQUFDdjJGLEtBQUssS0FBS20yRixRQUFRbjJGLEtBQUssQ0FBQywyRUFBMkU7VUFDcEg7WUFDQSw4RUFBOEU7WUFDOUUsSUFBSXUyRixVQUFVSCxRQUFRRyxPQUFPLEVBQUUsK0NBQStDO1lBQzlFLElBQUlDLFVBQVVELFFBQVFDLE9BQU8sR0FBR0wsUUFBUW4yRixLQUFLLENBQUMwZixNQUFNLGdEQUFnRDtZQUVwRyxJQUFJODJFLFlBQVlELFFBQVFFLFdBQVcsRUFBRTtnQkFDbkM7WUFDRjtRQUNGO1FBQ0EsSUFBSUMsY0FBY1YsWUFBWSxDQUFDRSxhQUFhLEdBQUc7WUFDN0N0cUUsTUFBTXdxRTtRQUNSO1FBQ0FyeEYsTUFBSzR4RixtQkFBbUIsQ0FBQ2ozRSxLQUFLeTJFO1FBQzlCTyxZQUFZdDJGLElBQUksR0FBR3NmLElBQUk0bUQsTUFBTSxDQUFDNHZCO1FBQzlCLElBQUlRLFlBQVl0MkYsSUFBSSxJQUFJczJGLFlBQVl0MkYsSUFBSSxDQUFDNGtCLE1BQU0sRUFBRTtZQUMvQzB4RSxZQUFZdDJGLElBQUksR0FBR3MyRixZQUFZdDJGLElBQUksQ0FBQ3cyRixRQUFRO1FBQzlDO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x2QyxXQUFXMkI7SUFDYjtBQUNGO0FBQ0FyQyxRQUFRWSxnQkFBZ0IsR0FBRyxTQUFVNzBFLEdBQUc7SUFDdEMsSUFBSXdDLEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQixJQUFJd0IsUUFBTyxJQUFJO0lBQ2YsSUFBSTh4RixZQUFZOXhGLE1BQUsreEYsa0JBQWtCO0lBQ3ZDLElBQUlDLGFBQWFoeUYsTUFBS2l5RixpQkFBaUI7SUFDdkMsSUFBSUMsV0FBVyxTQUFTQSxTQUFTdjNFLEdBQUcsRUFBRW0zRSxTQUFTLEVBQUVLLE9BQU87UUFDdEQsT0FBT255RixNQUFLb3lGLGlCQUFpQixDQUFDejNFLEtBQUttM0UsV0FBV0s7SUFDaEQ7SUFDQSxJQUFJRSxjQUFjbDFFLEdBQUdtMUUsUUFBUTtJQUM3QixJQUFJMzNFLElBQUltRCxPQUFPLElBQUk7UUFDakIsT0FBTztJQUNUO0lBQ0EsSUFBSWlCLFNBQVM1QixHQUFHSixLQUFLLEtBQUs7SUFFMUIsMENBQTBDO0lBQzFDLGdGQUFnRjtJQUNoRixFQUFFO0lBRUYsSUFBSXcxRSxtQkFBbUI1M0UsSUFBSW5jLFFBQVEsQ0FBQ2tmLEtBQUs7SUFDekNvMEUsWUFBWTEzRixPQUFPNEgsSUFBSSxDQUFDdXdGO0lBQ3hCLElBQUssSUFBSTMyRixJQUFJLEdBQUdBLElBQUlvMkYsV0FBVzM0RixNQUFNLEVBQUV1QyxJQUFLO1FBQzFDLElBQUk0MkYsUUFBUVIsVUFBVSxDQUFDcDJGLEVBQUU7UUFDekJ1aEIsR0FBR1UsU0FBUyxDQUFDMjBFLE1BQU0sR0FBRztZQUFDOThFO1lBQW1CRTtTQUFzQjtJQUNsRTtJQUNBLElBQUk2OEUsZUFBZSxTQUFTQSxhQUFhbDNFLEdBQUcsRUFBRWkzRSxLQUFLO1FBQ2pELE9BQU9yMUUsR0FBR1UsU0FBUyxDQUFDMjBFLE1BQU0sQ0FBQyxFQUFFLEdBQUd2OEUsUUFBUXNGLEtBQUs0QixHQUFHVSxTQUFTLENBQUMyMEUsTUFBTSxDQUFDLEVBQUU7SUFDckU7SUFDQSxJQUFJRSxlQUFlLFNBQVNBLGFBQWFuM0UsR0FBRyxFQUFFaTNFLEtBQUs7UUFDakQsT0FBT3IxRSxHQUFHVSxTQUFTLENBQUMyMEUsTUFBTSxDQUFDLEVBQUUsR0FBR3I4RSxXQUFXb0YsS0FBSzRCLEdBQUdVLFNBQVMsQ0FBQzIwRSxNQUFNLENBQUMsRUFBRTtJQUN4RTtJQUNBLElBQUlHLGNBQWMsU0FBU0EsWUFBWXAzRSxHQUFHLEVBQUVpM0UsS0FBSztRQUMvQ0MsYUFBYWwzRSxLQUFLaTNFO1FBQ2xCRSxhQUFhbjNFLEtBQUtpM0U7SUFDcEI7SUFDQSxJQUFJSSxrQkFBa0IsU0FBU0EsZ0JBQWdCQyxNQUFNLEVBQUVMLEtBQUs7UUFDMUQsSUFBSyxJQUFJdndGLElBQUksR0FBR0EsSUFBSTR3RixPQUFPeDVGLE1BQU0sRUFBRTRJLElBQUs7WUFDdEMsSUFBSXM2RCxLQUFLczJCLE9BQU85N0UsVUFBVSxDQUFDOVU7WUFDM0J3d0YsYUFBYWwyQixJQUFJaTJCO1lBQ2pCRSxhQUFhbjJCLElBQUlpMkI7UUFDbkI7SUFDRjtJQUVBLHdEQUF3RDtJQUN4RCxnRkFBZ0Y7SUFDaEYsMEVBQTBFO0lBQzFFLHNFQUFzRTtJQUN0RSxnREFBZ0Q7SUFDaEQsSUFBSW5uRSxJQUFJO0lBQ1IsSUFBSXluRSxXQUFXLFNBQVNBLFNBQVN2M0UsR0FBRztRQUNsQyxPQUFPLENBQUMsTUFBTUEsT0FBT0EsTUFBTSxPQUFPcGQsS0FBS0MsS0FBSyxDQUFDbWQsU0FBU0EsTUFBTThQLElBQUs5UCxDQUFBQSxNQUFNLE9BQU8sS0FBS0E7SUFDckY7SUFDQSxJQUFLLElBQUkrRyxLQUFLLEdBQUdBLEtBQUt3dkUsVUFBVXo0RixNQUFNLEVBQUVpcEIsS0FBTTtRQUM1QyxJQUFJNWxCLE9BQU9vMUYsU0FBUyxDQUFDeHZFLEdBQUc7UUFDeEIsSUFBSXl3RSxhQUFhUixnQkFBZ0IsQ0FBQzcxRixLQUFLO1FBQ3ZDLElBQUlxMkYsY0FBYyxNQUFNO1lBQ3RCO1FBQ0Y7UUFDQSxJQUFJQyxXQUFXLElBQUksQ0FBQ3IyQyxVQUFVLENBQUNqZ0QsS0FBSztRQUNwQyxJQUFJd1IsT0FBTzhrRixTQUFTOWtGLElBQUk7UUFDeEIsSUFBSStrRixTQUFTRCxTQUFTRSxRQUFRO1FBQzlCLElBQUlDLHNCQUFzQi8yRjtRQUMxQixJQUFJNDJGLFNBQVNJLFlBQVksSUFBSSxNQUFNO1lBQ2pDRCxzQkFBc0JILFNBQVNJLFlBQVksQ0FBQ3o0RSxLQUFLbzRFO1FBQ25ELE9BQU8sSUFBSUEsV0FBV3Z4QixPQUFPLElBQUksTUFBTTtZQUNyQzJ4QixzQkFBc0JKLFdBQVd2eEIsT0FBTztRQUMxQztRQUVBLDJDQUEyQztRQUMzQyxJQUFJNnhCLFlBQVlMLFNBQVNNLEtBQUssSUFBSSxPQUFPUCxXQUFXOTNGLEtBQUssR0FBRztRQUM1RCxJQUFJczRGLGNBQWNKLHVCQUF1QjtRQUN6QyxJQUFJSyxnQkFBZ0JILGFBQWE7UUFDakMsSUFBSUksVUFBVUYsZUFBZUM7UUFDN0IsSUFBSW54QixRQUFRMHdCLFdBQVcxd0IsS0FBSztRQUU1QiwyQ0FBMkM7UUFDM0MsZ0RBQWdEO1FBQ2hELElBQUluMEQsS0FBS2xRLE1BQU0sSUFBSXkxRixXQUFXLENBQUN2bEYsS0FBS3dsRixRQUFRLEVBQUU7WUFDNUMsSUFBSWx6RixJQUFJK3lGLGNBQWNKLHNCQUFzQkU7WUFDNUNWLFlBQVlHLFNBQVN0eUYsSUFBSXl5RjtZQUN6QixJQUFJLENBQUNNLGVBQWVseEIsU0FBUyxNQUFNO2dCQUNqQ3V3QixnQkFBZ0J2d0IsT0FBTzR3QjtZQUN6QjtRQUNGLE9BQU87WUFDTEwsZ0JBQWdCRyxXQUFXMXVCLFFBQVEsRUFBRTR1QjtRQUN2QztJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCLEVBQUU7SUFFRixJQUFJbDlFLE9BQU87UUFBQ0w7UUFBbUJFO0tBQXNCO0lBQ3JELElBQUssSUFBSXNNLE1BQU0sR0FBR0EsTUFBTTh2RSxXQUFXMzRGLE1BQU0sRUFBRTZvQixNQUFPO1FBQ2hELElBQUl5eEUsVUFBVTNCLFVBQVUsQ0FBQzl2RSxJQUFJO1FBQzdCLElBQUkweEUsU0FBU3oyRSxHQUFHVSxTQUFTLENBQUM4MUUsUUFBUTtRQUNsQzU5RSxJQUFJLENBQUMsRUFBRSxHQUFHRSxRQUFRMjlFLE1BQU0sQ0FBQyxFQUFFLEVBQUU3OUUsSUFBSSxDQUFDLEVBQUU7UUFDcENBLElBQUksQ0FBQyxFQUFFLEdBQUdJLFdBQVd5OUUsTUFBTSxDQUFDLEVBQUUsRUFBRTc5RSxJQUFJLENBQUMsRUFBRTtJQUN6QztJQUNBb0gsR0FBR20xRSxRQUFRLEdBQUdsOEUsY0FBY0wsSUFBSSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEVBQUU7SUFFNUMsYUFBYTtJQUNiLEVBQUU7SUFFRixJQUFJODlFLEtBQUsxMkUsR0FBR1UsU0FBUztJQUNyQlYsR0FBRzIyRSxZQUFZLEdBQUd2OUUsbUJBQW1CczlFLEdBQUdFLGVBQWU7SUFDdkQsSUFBSUMsWUFBWTlCLFNBQVN2M0UsS0FBSztRQUFDO0tBQVEsRUFBRWs1RSxHQUFHRSxlQUFlO0lBQzNENTJFLEdBQUc4MkUsUUFBUSxHQUFHMTlFLG1CQUFtQnk5RTtJQUNqQzcyRSxHQUFHKzJFLGFBQWEsR0FBRzM5RSxtQkFBbUJFLFdBQVdvOUUsR0FBR00sV0FBVyxFQUFFSDtJQUNqRSxJQUFJLENBQUNqMUUsUUFBUTtRQUNYLElBQUlxMUUsa0JBQWtCbEMsU0FBU3YzRSxLQUFLO1lBQUM7U0FBZSxFQUFFazVFLEdBQUdFLGVBQWU7UUFDeEU1MkUsR0FBR2szRSxjQUFjLEdBQUc5OUUsbUJBQW1CNjlFO1FBQ3ZDajNFLEdBQUdtM0UsbUJBQW1CLEdBQUcvOUUsbUJBQW1CRSxXQUFXbzlFLEdBQUdNLFdBQVcsRUFBRUM7UUFDdkUsSUFBSUcsa0JBQWtCckMsU0FBU3YzRSxLQUFLO1lBQUM7U0FBZSxFQUFFazVFLEdBQUdFLGVBQWU7UUFDeEU1MkUsR0FBR3EzRSxjQUFjLEdBQUdqK0UsbUJBQW1CZytFO1FBQ3ZDcDNFLEdBQUdzM0UsbUJBQW1CLEdBQUdsK0UsbUJBQW1CRSxXQUFXbzlFLEdBQUdNLFdBQVcsRUFBRUk7SUFDekU7SUFFQSxPQUFPO0lBQ1AsRUFBRTtJQUVGLElBQUl4MUUsUUFBUTtRQUNWLElBQUkyMUUsZUFBZXYzRSxHQUFHVSxTQUFTLEVBQzdCODJFLFdBQVdELGFBQWFDLFFBQVEsRUFDaENDLGFBQWFGLGFBQWFFLFVBQVUsRUFDcENDLGNBQWNILGFBQWFHLFdBQVcsRUFDdENDLGtCQUFrQkosYUFBYUksZUFBZSxFQUM5Q24rQixXQUFXKzlCLGFBQWEvOUIsUUFBUSxFQUNoQ28rQixNQUFNTCxhQUFhSyxHQUFHLEVBQ3RCQyxTQUFTTixhQUFhTSxNQUFNO1FBQzlCLElBQUlDLFdBQVc7WUFBQ047WUFBVUM7WUFBWUM7WUFBYUM7WUFBaUJuK0I7WUFBVW8rQjtZQUFLQztTQUFPLENBQUMxNEUsTUFBTSxDQUFDLFNBQVVwYyxDQUFDO1lBQzNHLE9BQU9BLEtBQUs7UUFDZCxHQUFHazVELE1BQU0sQ0FBQzNpRCxZQUFZO1lBQUNmO1lBQW1CRTtTQUFzQjtRQUNoRXVILEdBQUcrM0UsT0FBTyxHQUFHMytFLG1CQUFtQjArRTtRQUNoQzkzRSxHQUFHZzRFLE1BQU0sR0FBR0osT0FBTyxRQUFRQSxHQUFHLENBQUMsRUFBRSxLQUFLci9FLHFCQUFxQnEvRSxHQUFHLENBQUMsRUFBRSxLQUFLbi9FO1FBQ3RFdUgsR0FBR2k0RSxTQUFTLEdBQUdKLFVBQVUsUUFBUUEsTUFBTSxDQUFDLEVBQUUsS0FBS3QvRSxxQkFBcUJzL0UsTUFBTSxDQUFDLEVBQUUsS0FBS3AvRTtJQUNwRjtJQUNBLE9BQU95OEUsZ0JBQWdCbDFFLEdBQUdtMUUsUUFBUTtBQUNwQztBQUNBMUQsUUFBUXlHLGVBQWUsR0FBRyxTQUFVMTZFLEdBQUc7SUFDckMsSUFBSXdDLEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQjJlLEdBQUd3ekUsV0FBVyxHQUFHO0lBQ2pCeHpFLEdBQUdVLFNBQVMsR0FBRyxDQUFDO0lBQ2hCVixHQUFHbTFFLFFBQVEsR0FBRztJQUNkbjFFLEdBQUc4MkUsUUFBUSxHQUFHO0lBQ2Q5MkUsR0FBRysyRSxhQUFhLEdBQUc7SUFDbkIvMkUsR0FBR2szRSxjQUFjLEdBQUc7SUFDcEJsM0UsR0FBR20zRSxtQkFBbUIsR0FBRztJQUN6Qm4zRSxHQUFHcTNFLGNBQWMsR0FBRztJQUNwQnIzRSxHQUFHczNFLG1CQUFtQixHQUFHO0lBQ3pCdDNFLEdBQUcrM0UsT0FBTyxHQUFHO0lBQ2IvM0UsR0FBR2c0RSxNQUFNLEdBQUc7SUFDWmg0RSxHQUFHaTRFLFNBQVMsR0FBRztBQUNqQjtBQUVBLG1EQUFtRDtBQUNuRCw2Q0FBNkM7QUFDN0MsRUFBRTtBQUNGLDREQUE0RDtBQUM1RCxFQUFFO0FBQ0Ysc0RBQXNEO0FBQ3RELCtEQUErRDtBQUMvRCxxRUFBcUU7QUFDckUsZ0VBQWdFO0FBQ2hFLHlCQUF5QjtBQUN6QixFQUFFO0FBQ0Ysb0NBQW9DO0FBQ3BDLGdEQUFnRDtBQUNoRCxFQUFFO0FBQ0Ysa0NBQWtDO0FBQ2xDLHVEQUF1RDtBQUN2RHhHLFFBQVFnRCxtQkFBbUIsR0FBRyxTQUFVajNFLEdBQUcsRUFBRW80RSxVQUFVO0lBQ3JELElBQUkveUYsUUFBTyxJQUFJO0lBQ2YsSUFBSTA3QyxPQUFPcTNDO0lBQ1gsSUFBSXIxRSxRQUFRL0MsSUFBSW5jLFFBQVEsQ0FBQ2tmLEtBQUs7SUFDOUIsSUFBSTQzRTtJQUNKLElBQUlwRSxRQUFRbHhGLE1BQUtreEYsS0FBSztJQUN0QixJQUFJaGpGLE9BQU9sTyxNQUFLMjhDLFVBQVUsQ0FBQ2pCLEtBQUtoL0MsSUFBSSxDQUFDLENBQUN3UixJQUFJO0lBQzFDLElBQUlxbkYsZUFBZTc1QyxLQUFLejdCLE1BQU07SUFDOUIsSUFBSXUxRSxXQUFXOTNFLEtBQUssQ0FBQ2crQixLQUFLaC9DLElBQUksQ0FBQztJQUMvQixJQUFJKzRGLG1CQUFtQkQsWUFBWUEsU0FBU3YxRSxNQUFNO0lBQ2xELElBQUk5QyxLQUFLeEMsSUFBSW5jLFFBQVE7SUFDckIsSUFBSWszRixrQkFBa0I7SUFDdEIsSUFBSUMsU0FBUyxTQUFTQSxPQUFPL3lGLENBQUM7UUFDNUIsSUFBSUEsS0FBSyxNQUFNO1lBQ2IsT0FBTztRQUNULE9BQU8sSUFBSUEsRUFBRTQrRCxPQUFPLElBQUksTUFBTTtZQUM1QixPQUFPNStELEVBQUU0K0QsT0FBTztRQUNsQixPQUFPO1lBQ0wsT0FBTzUrRCxFQUFFM0gsS0FBSztRQUNoQjtJQUNGO0lBQ0EsSUFBSTI2RixnQkFBZ0IsU0FBU0E7UUFDM0IsSUFBSUMsVUFBVUYsT0FBT0g7UUFDckIsSUFBSU0sUUFBUUgsT0FBT2o2QztRQUNuQjE3QyxNQUFLNDFGLGFBQWEsQ0FBQ2o3RSxLQUFLK2dDLEtBQUtoL0MsSUFBSSxFQUFFbTVGLFNBQVNDO0lBQzlDO0lBRUEsd0VBQXdFO0lBQ3hFLElBQUkvQyxXQUFXcjJGLElBQUksS0FBSyxpQkFBaUJpZSxJQUFJbTZCLE1BQU0sTUFDbkQsZ0NBQWdDO0lBQ2hDaStDLENBQUFBLFdBQVc5M0YsS0FBSyxLQUFLLFlBQVkwZixJQUFJcU0sTUFBTSxNQUMzQyx5REFBeUQ7SUFDekQrckUsV0FBVzkzRixLQUFLLEtBQUssY0FBZTBmLENBQUFBLElBQUlzQyxNQUFNLEdBQUcyMkMsUUFBUSxNQUFNajVDLElBQUl1QyxNQUFNLEdBQUcwMkMsUUFBUSxFQUFDLENBQUMsR0FBSTtRQUN4RmxZLE9BQU9xM0MsYUFBYSxJQUFJLENBQUM3NkIsS0FBSyxDQUFDNjZCLFdBQVdyMkYsSUFBSSxFQUFFLFVBQVU2NEY7SUFDNUQ7SUFDQSxJQUFJNzVDLElBQUksQ0FBQyxTQUFTLEVBQUU7UUFDbEIsZ0VBQWdFO1FBQ2hFaCtCLEtBQUssQ0FBQ2crQixLQUFLaC9DLElBQUksQ0FBQyxHQUFHTjtRQUNuQnc1RjtRQUNBLE9BQU87SUFDVDtJQUNBLElBQUlsNkMsS0FBSzQxQyxjQUFjLEVBQUU7UUFDdkIsK0JBQStCO1FBQy9CLElBQUksQ0FBQ2tFLFVBQVU7WUFDYkk7WUFDQSxPQUFPLE1BQU0sMEJBQTBCO1FBQ3pDLE9BQU8sSUFBSUosU0FBU3YxRSxNQUFNLEVBQUU7WUFDMUIsa0JBQWtCO1lBQ2xCdTFFLFNBQVMzRCxRQUFRLEdBQUd6MUY7WUFDcEJ3NUY7WUFDQSxPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU8sT0FBTywyQ0FBMkM7UUFDM0Q7SUFDRjtJQUVBLGdEQUFnRDtJQUNoRCxJQUFJbDZDLEtBQUtxNkMsWUFBWSxFQUFFO1FBQ3JCLGdFQUFnRTtRQUNoRSxJQUFJLENBQUNQLFVBQVU7WUFDYkk7WUFDQSxPQUFPLE1BQU0sa0NBQWtDO1FBQ2pELE9BQU8sSUFBSUosU0FBU3YxRSxNQUFNLEVBQUU7WUFDMUIscURBQXFEO1lBQ3JELDZIQUE2SDtZQUM3SHZDLEtBQUssQ0FBQ2crQixLQUFLaC9DLElBQUksQ0FBQyxHQUFHODRGLFNBQVMzRCxRQUFRO1lBQ3BDK0Q7WUFDQSxPQUFPO1FBQ1QsT0FBTztZQUNMLE9BQU8sT0FBTyx5Q0FBeUM7UUFDekQ7SUFDRjtJQUNBLElBQUlJLGtCQUFrQixTQUFTQTtRQUM3QnA5RSxLQUFLLDhFQUE4RStCLElBQUkwRyxFQUFFLEtBQUssb0NBQW9DcTZCLEtBQUtoL0MsSUFBSSxHQUFHLHdCQUF3QmcvQyxLQUFLb1IsS0FBSyxHQUFHLGlCQUFpQnBSLEtBQUtvUixLQUFLLEdBQUcsa0RBQWtEcFIsS0FBS29SLEtBQUssR0FBRztJQUNsUjtJQUVBLHdDQUF3QztJQUN4QyxPQUFRcFIsS0FBSzYxQyxNQUFNO1FBQ2pCLGlDQUFpQztRQUNqQyxLQUFLTCxNQUFNK0UsT0FBTztZQUNoQjtnQkFDRSx3Q0FBd0M7Z0JBQ3hDLElBQUk3VSxTQUFTMWxDLEtBQUtvUixLQUFLLENBQUNodEMsS0FBSyxDQUFDO2dCQUM5QixJQUFJMDVDLFdBQVdyOEMsR0FBR0gsSUFBSTtnQkFDdEIsSUFBSyxJQUFJcGhCLElBQUksR0FBR0EsSUFBSXdsRixPQUFPL25GLE1BQU0sSUFBSW1nRSxVQUFVNTlELElBQUs7b0JBQ2xELElBQUlreEQsUUFBUXMwQixNQUFNLENBQUN4bEYsRUFBRTtvQkFDckI0OUQsV0FBV0EsUUFBUSxDQUFDMU0sTUFBTTtnQkFDNUI7Z0JBQ0EsSUFBSTBNLFlBQVksTUFBTTtvQkFDcEJ3OEI7b0JBQ0EsT0FBTztnQkFDVDtnQkFDQSxJQUFJcE87Z0JBQ0osSUFBSSxDQUFDN3BGLFNBQVN5N0QsV0FBVztvQkFDdkIsdURBQXVEO29CQUN2RDVnRCxLQUFLLDBFQUEwRThpQyxLQUFLb1IsS0FBSyxHQUFHLE9BQU8wTSxXQUFXLFlBQVk3K0MsSUFBSTBHLEVBQUUsS0FBSztvQkFDckksT0FBTztnQkFDVCxPQUFPO29CQUNMLElBQUk2MEUsYUFBYXg2QyxLQUFLeTZDLFFBQVEsR0FBR3o2QyxLQUFLMDZDLFFBQVE7b0JBQzlDLElBQUlGLGVBQWUsR0FBRzt3QkFDcEIseUZBQXlGO3dCQUN6RnRPLFVBQVU7b0JBQ1osT0FBTzt3QkFDTEEsVUFBVSxDQUFDcHVCLFdBQVc5ZCxLQUFLMDZDLFFBQVEsSUFBSUY7b0JBQ3pDO2dCQUNGO2dCQUVBLG1DQUFtQztnQkFDbkMsSUFBSXRPLFVBQVUsR0FBRztvQkFDZkEsVUFBVTtnQkFDWixPQUFPLElBQUlBLFVBQVUsR0FBRztvQkFDdEJBLFVBQVU7Z0JBQ1o7Z0JBQ0EsSUFBSTE1RSxLQUFLdkssS0FBSyxFQUFFO29CQUNkLElBQUkweUYsS0FBSzM2QyxLQUFLNDZDLFFBQVEsQ0FBQyxFQUFFO29CQUN6QixJQUFJQyxLQUFLNzZDLEtBQUs4NkMsUUFBUSxDQUFDLEVBQUU7b0JBQ3pCLElBQUlDLEtBQUsvNkMsS0FBSzQ2QyxRQUFRLENBQUMsRUFBRTtvQkFDekIsSUFBSUksS0FBS2g3QyxLQUFLODZDLFFBQVEsQ0FBQyxFQUFFO29CQUN6QixJQUFJRyxLQUFLajdDLEtBQUs0NkMsUUFBUSxDQUFDLEVBQUU7b0JBQ3pCLElBQUluekIsS0FBS3puQixLQUFLODZDLFFBQVEsQ0FBQyxFQUFFO29CQUN6QixJQUFJSSxLQUFLbDdDLEtBQUs0NkMsUUFBUSxDQUFDLEVBQUUsSUFBSSxPQUFPLElBQUk1NkMsS0FBSzQ2QyxRQUFRLENBQUMsRUFBRTtvQkFDeEQsSUFBSU8sS0FBS243QyxLQUFLODZDLFFBQVEsQ0FBQyxFQUFFLElBQUksT0FBTyxJQUFJOTZDLEtBQUs4NkMsUUFBUSxDQUFDLEVBQUU7b0JBQ3hELElBQUlNLE1BQU07d0JBQUMzNEYsS0FBSytFLEtBQUssQ0FBQ216RixLQUFLLENBQUNFLEtBQUtGLEVBQUMsSUFBS3pPO3dCQUFVenBGLEtBQUsrRSxLQUFLLENBQUN1ekYsS0FBSyxDQUFDQyxLQUFLRCxFQUFDLElBQUs3Tzt3QkFBVXpwRixLQUFLK0UsS0FBSyxDQUFDeXpGLEtBQUssQ0FBQ3h6QixLQUFLd3pCLEVBQUMsSUFBSy9PO3dCQUFVenBGLEtBQUsrRSxLQUFLLENBQUMwekYsS0FBSyxDQUFDQyxLQUFLRCxFQUFDLElBQUtoUDtxQkFBUztvQkFDbEswTixXQUFXO3dCQUNULDJGQUEyRjt3QkFDM0ZyMUUsUUFBUXk3QixLQUFLejdCLE1BQU07d0JBQ25CLHFEQUFxRDt3QkFDckR2akIsTUFBTWcvQyxLQUFLaC9DLElBQUk7d0JBQ2Z6QixPQUFPNjdGO3dCQUNQenlCLFVBQVUsU0FBU3l5QixHQUFHLENBQUMsRUFBRSxHQUFHLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEdBQUcsT0FBT0EsR0FBRyxDQUFDLEVBQUUsR0FBRztvQkFDOUQ7Z0JBQ0YsT0FBTyxJQUFJNW9GLEtBQUtsUSxNQUFNLEVBQUU7b0JBQ3RCLElBQUkrNEYsWUFBWXI3QyxLQUFLNDZDLFFBQVEsR0FBRyxDQUFDNTZDLEtBQUs4NkMsUUFBUSxHQUFHOTZDLEtBQUs0NkMsUUFBUSxJQUFJMU87b0JBQ2xFME4sV0FBVyxJQUFJLENBQUNwOUIsS0FBSyxDQUFDeGMsS0FBS2gvQyxJQUFJLEVBQUVxNkYsV0FBV3I3QyxLQUFLejdCLE1BQU0sRUFBRXkxRTtnQkFDM0QsT0FBTztvQkFDTCxPQUFPLE9BQU8sc0NBQXNDO2dCQUN0RDtnQkFDQSxJQUFJLENBQUNKLFVBQVU7b0JBQ2Isc0dBQXNHO29CQUN0R1U7b0JBQ0EsT0FBTztnQkFDVDtnQkFDQVYsU0FBUzlELE9BQU8sR0FBRzkxQyxNQUFNLGtDQUFrQztnQkFDM0RBLE9BQU80NUMsVUFBVSxxREFBcUQ7Z0JBRXRFO1lBQ0Y7UUFFRixpQkFBaUI7UUFDakIsS0FBS3BFLE1BQU1sMEUsSUFBSTtZQUNiO2dCQUNFLHdDQUF3QztnQkFDeEMsSUFBSWc2RSxVQUFVdDdDLEtBQUtvUixLQUFLLENBQUNodEMsS0FBSyxDQUFDO2dCQUMvQixJQUFJbTNFLFlBQVk5NUUsR0FBR0gsSUFBSTtnQkFDdkIsSUFBSyxJQUFJeVQsTUFBTSxHQUFHQSxNQUFNdW1FLFFBQVEzOUYsTUFBTSxJQUFJNDlGLFdBQVd4bUUsTUFBTztvQkFDMUQsSUFBSW9vQyxTQUFTbStCLE9BQU8sQ0FBQ3ZtRSxJQUFJO29CQUN6QndtRSxZQUFZQSxTQUFTLENBQUNwK0IsT0FBTztnQkFDL0I7Z0JBQ0EsSUFBSW8rQixhQUFhLE1BQU07b0JBQ3JCM0IsV0FBVyxJQUFJLENBQUNwOUIsS0FBSyxDQUFDeGMsS0FBS2gvQyxJQUFJLEVBQUV1NkYsV0FBV3Y3QyxLQUFLejdCLE1BQU0sRUFBRXkxRTtnQkFDM0Q7Z0JBQ0EsSUFBSSxDQUFDSixVQUFVO29CQUNiLHlGQUF5RjtvQkFDekZVO29CQUNBLE9BQU87Z0JBQ1Q7Z0JBQ0FWLFNBQVM5RCxPQUFPLEdBQUc5MUMsTUFBTSxrQ0FBa0M7Z0JBQzNEQSxPQUFPNDVDLFVBQVUscURBQXFEO2dCQUV0RTtZQUNGO1FBQ0YsS0FBS3BFLE1BQU14ekYsRUFBRTtZQUNYO2dCQUNFLElBQUlBLEtBQUtnK0MsS0FBS3pnRCxLQUFLO2dCQUNuQixJQUFJaThGLFdBQVd4N0MsS0FBSysxQyxPQUFPLElBQUksT0FBTy8xQyxLQUFLKzFDLE9BQU8sR0FBRy96RixHQUFHaWQsTUFBTSxpREFBaUQ7Z0JBRS9HK2dDLEtBQUtnMkMsV0FBVyxHQUFHd0Y7Z0JBQ25CLElBQUlBLFlBQVksTUFBTTtvQkFDcEJ0K0UsS0FBSyx3REFBd0Q4aUMsS0FBS2gvQyxJQUFJLEdBQUcsZ0JBQWdCaWUsSUFBSTBHLEVBQUUsS0FBSztvQkFDcEcsT0FBTztnQkFDVDtnQkFDQWkwRSxXQUFXLElBQUksQ0FBQ3A5QixLQUFLLENBQUN4YyxLQUFLaC9DLElBQUksRUFBRXc2RixVQUFVeDdDLEtBQUt6N0IsTUFBTSxFQUFFeTFFO2dCQUN4RCxJQUFJLENBQUNKLFVBQVU7b0JBQ2IxOEUsS0FBSyx3RkFBd0Y4aUMsS0FBS2gvQyxJQUFJLEdBQUcsZ0JBQWdCaWUsSUFBSTBHLEVBQUUsS0FBSztvQkFDcEksT0FBTztnQkFDVDtnQkFDQWkwRSxTQUFTOUQsT0FBTyxHQUFHMzNFLEtBQUs2aEMsT0FBTyxrQ0FBa0M7Z0JBQ2pFQSxPQUFPNDVDLFVBQVUscURBQXFEO2dCQUV0RTtZQUNGO1FBQ0YsS0FBS2w1RjtZQUNIO1FBQ0Ysd0JBQXdCO1FBRXhCO1lBQ0UsT0FBTztJQUVYO0lBRUEsNkZBQTZGO0lBQzdGLElBQUltNUYsY0FBYztRQUNoQixJQUFJRSxrQkFBa0I7WUFDcEIsOENBQThDO1lBQzlDLzVDLEtBQUttMkMsUUFBUSxHQUFHMkQsU0FBUzNELFFBQVEsRUFBRSxzQ0FBc0M7UUFDM0UsT0FBTztZQUNMLDRDQUE0QztZQUM1Q24yQyxLQUFLbTJDLFFBQVEsR0FBRzJEO1FBQ2xCO1FBQ0E5M0UsS0FBSyxDQUFDZytCLEtBQUtoL0MsSUFBSSxDQUFDLEdBQUdnL0MsTUFBTSxVQUFVO0lBQ3JDLE9BQU87UUFDTCxxQkFBcUI7UUFDckIsSUFBSSs1QyxrQkFBa0I7WUFDcEIseUVBQXlFO1lBQ3pFRCxTQUFTM0QsUUFBUSxHQUFHbjJDO1FBQ3RCLE9BQU87WUFDTCxrREFBa0Q7WUFDbERoK0IsS0FBSyxDQUFDZytCLEtBQUtoL0MsSUFBSSxDQUFDLEdBQUdnL0M7UUFDckI7SUFDRjtJQUNBazZDO0lBQ0EsT0FBTztBQUNUO0FBQ0FoSCxRQUFRdUksYUFBYSxHQUFHLFNBQVV6d0UsSUFBSSxFQUFFMHdFLFlBQVk7SUFDbEQsSUFBSyxJQUFJeDdGLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtRQUNqQixJQUFJLENBQUN5NUYsZUFBZSxDQUFDMTZFO1FBQ3JCQSxJQUFJNmtELHdCQUF3QjtRQUM1QjdrRCxJQUFJeWtELHFCQUFxQjtRQUN6QixJQUFJLENBQUNnNEIsY0FBYztZQUNqQno4RSxJQUFJbmMsUUFBUSxDQUFDa2YsS0FBSyxHQUFHLENBQUM7UUFDeEIsT0FBTztZQUNMLElBQUlBLFFBQVEvQyxJQUFJbmMsUUFBUSxDQUFDa2YsS0FBSztZQUM5QixJQUFJbzBFLFlBQVkxM0YsT0FBTzRILElBQUksQ0FBQzBiO1lBQzVCLElBQUssSUFBSXpiLElBQUksR0FBR0EsSUFBSTZ2RixVQUFVejRGLE1BQU0sRUFBRTRJLElBQUs7Z0JBQ3pDLElBQUlpWixXQUFXNDJFLFNBQVMsQ0FBQzd2RixFQUFFO2dCQUMzQixJQUFJb3ZGLFVBQVUzekUsS0FBSyxDQUFDeEMsU0FBUztnQkFDN0IsSUFBSW0yRSxXQUFXLE1BQU07b0JBQ25CLElBQUlBLFFBQVFweEUsTUFBTSxFQUFFO3dCQUNsQm94RSxRQUFRUSxRQUFRLEdBQUc7b0JBQ3JCLE9BQU87d0JBQ0xuMEUsS0FBSyxDQUFDeEMsU0FBUyxHQUFHO29CQUNwQjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsOEZBQThGO0FBQzlGMHpFLFFBQVF2dEIsTUFBTSxHQUFHO0lBQ2YsSUFBSXprRCxLQUFLLElBQUksQ0FBQ3BlLFFBQVEsQ0FBQ29lLEVBQUU7SUFDekIsSUFBSThKLE9BQU85SixHQUFHdzFELGVBQWU7SUFDN0IxckQsS0FBSzZtQyxXQUFXO0FBQ2xCO0FBRUEseUNBQXlDO0FBQ3pDcWhDLFFBQVF0VixpQkFBaUIsR0FBRyxTQUFVMytELEdBQUcsRUFBRTIwRSxTQUFTO0lBQ2xELElBQUl0dkYsUUFBTyxJQUFJO0lBQ2YsSUFBSW1kLEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQixJQUFJZzVDLFFBQVE3OEIsSUFBSTRtRCxNQUFNLENBQUMsdUJBQXVCdG1FLEtBQUs7SUFDbkQsSUFBSTYrQyxXQUFXbi9CLElBQUk0bUQsTUFBTSxDQUFDLHVCQUF1QkMsT0FBTztJQUN4RCxJQUFJbmxCLFFBQVExaEMsSUFBSTRtRCxNQUFNLENBQUMsb0JBQW9CQyxPQUFPO0lBQ2xELElBQUlocUIsTUFBTW4rQyxNQUFNLEdBQUcsS0FBS3lnRCxXQUFXLEdBQUc7UUFDcEMsSUFBSXA4QixRQUFRLENBQUM7UUFFYix3Q0FBd0M7UUFDeEMsSUFBSTI1RSxVQUFVO1FBQ2QsSUFBSyxJQUFJejdGLElBQUksR0FBR0EsSUFBSTQ3QyxNQUFNbitDLE1BQU0sRUFBRXVDLElBQUs7WUFDckMsSUFBSTgvQyxPQUFPbEUsS0FBSyxDQUFDNTdDLEVBQUU7WUFDbkIsSUFBSTA3RixVQUFVMzhFLElBQUk0bUQsTUFBTSxDQUFDN2xCO1lBQ3pCLElBQUk2N0MsV0FBV2pJLFNBQVMsQ0FBQzV6QyxLQUFLO1lBQzlCLElBQUksQ0FBQzY3QyxVQUFVO2dCQUNiO1lBQ0Y7WUFDQSxJQUFJQyxXQUFXRCxTQUFTMXdFLElBQUk7WUFDNUIsSUFBSTR3RSxXQUFXRDtZQUNmLElBQUlFLFNBQVNILFNBQVNsOEYsSUFBSSxJQUFJLE9BQU9rOEYsU0FBU2w4RixJQUFJLEdBQUdpOEY7WUFDckQsSUFBSXZ5RCxPQUFPO1lBQ1gsSUFBSTR5RCxVQUFVdjdGO1lBQ2QsSUFBSXc3RixTQUFTLFVBQVUsNkVBQTZFO1lBRXBHLElBQUksQ0FBQ0gsVUFBVTtnQkFDYjtZQUNGO1lBRUEscUJBQXFCO1lBQ3JCLElBQUkxNUYsU0FBUzA1RixTQUFTajJCLE9BQU8sS0FBS3pqRSxTQUFTMjVGLE9BQU9sMkIsT0FBTyxHQUFHO2dCQUMxRHo4QixPQUFPMnlELE9BQU9sMkIsT0FBTyxHQUFHaTJCLFNBQVNqMkIsT0FBTyxFQUFFLG9CQUFvQjtnQkFDOURtMkIsVUFBVUYsU0FBU2oyQixPQUFPLEdBQUdvMkIsU0FBUzd5RDtZQUV0Qyw0QkFBNEI7WUFDOUIsT0FBTyxJQUFJaG5DLFNBQVMwNUYsU0FBU3g4RixLQUFLLEtBQUs4QyxTQUFTMjVGLE9BQU96OEYsS0FBSyxHQUFHO2dCQUM3RDhwQyxPQUFPMnlELE9BQU96OEYsS0FBSyxHQUFHdzhGLFNBQVN4OEYsS0FBSyxFQUFFLG9CQUFvQjtnQkFDMUQwOEYsVUFBVUYsU0FBU3g4RixLQUFLLEdBQUcyOEYsU0FBUzd5RDtZQUVwQyx5QkFBeUI7WUFDM0IsT0FBTyxJQUFJcG5DLE1BQU04NUYsU0FBU3g4RixLQUFLLEtBQUswQyxNQUFNKzVGLE9BQU96OEYsS0FBSyxHQUFHO2dCQUN2RDhwQyxPQUFPMHlELFNBQVN4OEYsS0FBSyxDQUFDLEVBQUUsS0FBS3k4RixPQUFPejhGLEtBQUssQ0FBQyxFQUFFLElBQUl3OEYsU0FBU3g4RixLQUFLLENBQUMsRUFBRSxLQUFLeThGLE9BQU96OEYsS0FBSyxDQUFDLEVBQUUsSUFBSXc4RixTQUFTeDhGLEtBQUssQ0FBQyxFQUFFLEtBQUt5OEYsT0FBT3o4RixLQUFLLENBQUMsRUFBRTtnQkFDOUgwOEYsVUFBVUYsU0FBU3B6QixRQUFRO1lBQzdCO1lBRUEscUVBQXFFO1lBQ3JFLElBQUl0L0IsTUFBTTtnQkFDUnJuQixLQUFLLENBQUNnK0IsS0FBSyxHQUFHZzhDLE9BQU9yekIsUUFBUSxFQUFFLFNBQVM7Z0JBQ3hDLElBQUksQ0FBQ2tWLFdBQVcsQ0FBQzUrRCxLQUFLK2dDLE1BQU1pOEMsVUFBVSxXQUFXO2dCQUNqRE4sVUFBVTtZQUNaO1FBQ0YsRUFBRSx5QkFBeUI7UUFFM0Isa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ0EsU0FBUztZQUNaO1FBQ0Y7UUFDQWw2RSxHQUFHMDZFLGFBQWEsR0FBRztRQUNuQixJQUFJcitDLFVBQVUsU0FBVVIsT0FBTztZQUM3QixJQUFJcUQsUUFBUSxHQUFHO2dCQUNiMWhDLElBQUk2aEMsY0FBYyxDQUFDSCxPQUFPckIsSUFBSSxHQUFHMzdDLE9BQU8sR0FBR0MsSUFBSSxDQUFDMDVDO1lBQ2xELE9BQU87Z0JBQ0xBO1lBQ0Y7UUFDRixHQUFHMTVDLElBQUksQ0FBQztZQUNOLE9BQU9xYixJQUFJNEQsU0FBUyxDQUFDO2dCQUNuQmIsT0FBT0E7Z0JBQ1BvOEIsVUFBVUE7Z0JBQ1Z5OUIsUUFBUTU4RCxJQUFJNG1ELE1BQU0sQ0FBQyw4QkFBOEJ0bUUsS0FBSztnQkFDdER3akIsT0FBTztZQUNULEdBQUd1OEIsSUFBSSxHQUFHMzdDLE9BQU87UUFDbkIsR0FBR0MsSUFBSSxDQUFDO1lBQ04sbUJBQW1CO1lBQ25CVSxNQUFLNDVFLGNBQWMsQ0FBQ2ovRCxLQUFLNjhCO1lBQ3pCNzhCLElBQUl1bUQsYUFBYSxDQUFDO1lBQ2xCLElBQUk7WUFFSi9qRCxHQUFHMDZFLGFBQWEsR0FBRztRQUNyQjtJQUNGLE9BQU8sSUFBSTE2RSxHQUFHMDZFLGFBQWEsRUFBRTtRQUMzQixJQUFJLENBQUNqZSxjQUFjLENBQUNqL0QsS0FBSzY4QjtRQUN6Qjc4QixJQUFJdW1ELGFBQWEsQ0FBQztRQUNsQi9qRCxHQUFHMDZFLGFBQWEsR0FBRztJQUNyQjtBQUNGO0FBQ0FqSixRQUFRa0osWUFBWSxHQUFHLFNBQVVuOUUsR0FBRyxFQUFFamUsSUFBSSxFQUFFcTdGLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLFNBQVM7SUFDbkYsSUFBSXg4QyxPQUFPLElBQUksQ0FBQ2lCLFVBQVUsQ0FBQ2pnRCxLQUFLO0lBQ2hDLElBQUl5N0YsZUFBZUYsV0FBV3Y4QztJQUM5QixJQUFJL2dDLElBQUltRCxPQUFPLElBQUk7UUFDakI7SUFDRjtJQUNBLElBQUlxNkUsZ0JBQWdCLFFBQVFBLGFBQWFKLFdBQVdDLFNBQVNyOUUsTUFBTTtRQUNqRXU5RSxVQUFVeDhDO0lBQ1o7QUFDRjtBQUNBa3pDLFFBQVF3SixrQkFBa0IsR0FBRyxTQUFVejlFLEdBQUcsRUFBRWplLElBQUksRUFBRXE3RixTQUFTLEVBQUVDLE9BQU87SUFDbEUsSUFBSTM3RSxRQUFRLElBQUk7SUFDaEIsSUFBSSxDQUFDeTdFLFlBQVksQ0FBQ245RSxLQUFLamUsTUFBTXE3RixXQUFXQyxTQUFTLFNBQVV0OEMsSUFBSTtRQUM3RCxPQUFPQSxLQUFLMjhDLGNBQWM7SUFDNUIsR0FBRztRQUNEaDhFLE1BQU03ZCxRQUFRLENBQUNvZSxFQUFFLENBQUNzaEMsTUFBTSxDQUFDLFVBQVV2akM7SUFDckM7QUFDRjtBQUNBaTBFLFFBQVEwSixrQkFBa0IsR0FBRyxTQUFVMzlFLEdBQUcsRUFBRWplLElBQUksRUFBRXE3RixTQUFTLEVBQUVDLE9BQU87SUFDbEUsSUFBSSxDQUFDRixZQUFZLENBQUNuOUUsS0FBS2plLE1BQU1xN0YsV0FBV0MsU0FBUyxTQUFVdDhDLElBQUk7UUFDN0QsT0FBT0EsS0FBSzY4QyxjQUFjO0lBQzVCLEdBQUcsU0FBVTc4QyxJQUFJO1FBQ2YvZ0MsSUFBSTZrRCx3QkFBd0I7UUFDNUI3a0QsSUFBSXlrRCxxQkFBcUI7SUFDM0I7QUFDRjtBQUNBd3ZCLFFBQVE0SixnQ0FBZ0MsR0FBRyxTQUFVNzlFLEdBQUcsRUFBRWplLElBQUksRUFBRXE3RixTQUFTLEVBQUVDLE9BQU87SUFDaEYsSUFBSSxDQUFDRixZQUFZLENBQUNuOUUsS0FBS2plLE1BQU1xN0YsV0FBV0MsU0FBUyxTQUFVdDhDLElBQUk7UUFDN0QsT0FBT0EsS0FBSys4Qyw4QkFBOEI7SUFDNUMsR0FBRyxTQUFVLzhDLElBQUk7UUFDZi9nQyxJQUFJc0gsY0FBYyxHQUFHMUYsT0FBTyxDQUFDLFNBQVVpRyxJQUFJO1lBQ3pDQSxLQUFLNDhDLHFCQUFxQjtRQUM1QjtJQUNGO0FBQ0Y7QUFDQXd2QixRQUFROEosK0JBQStCLEdBQUcsU0FBVS85RSxHQUFHLEVBQUVqZSxJQUFJLEVBQUVxN0YsU0FBUyxFQUFFQyxPQUFPO0lBQy9FLElBQUksQ0FBQ0YsWUFBWSxDQUFDbjlFLEtBQUtqZSxNQUFNcTdGLFdBQVdDLFNBQVMsU0FBVXQ4QyxJQUFJO1FBQzdELE9BQU9BLEtBQUtpOUMsNkJBQTZCO0lBQzNDLEdBQUcsU0FBVWo5QyxJQUFJO1FBQ2YvZ0MsSUFBSTJqRSxhQUFhLEdBQUcvaEUsT0FBTyxDQUFDLFNBQVUrbEUsT0FBTztZQUMzQ0EsUUFBUWxqQixxQkFBcUI7UUFDL0I7SUFDRjtBQUNGO0FBQ0F3dkIsUUFBUWdILGFBQWEsR0FBRyxTQUFVajdFLEdBQUcsRUFBRWplLElBQUksRUFBRXE3RixTQUFTLEVBQUVDLE9BQU87SUFDN0RyOUUsSUFBSTA5RCxlQUFlO0lBQ25CLElBQUksQ0FBQytmLGtCQUFrQixDQUFDejlFLEtBQUtqZSxNQUFNcTdGLFdBQVdDO0lBQzlDLElBQUksQ0FBQ00sa0JBQWtCLENBQUMzOUUsS0FBS2plLE1BQU1xN0YsV0FBV0M7SUFDOUMsSUFBSSxDQUFDUSxnQ0FBZ0MsQ0FBQzc5RSxLQUFLamUsTUFBTXE3RixXQUFXQztJQUM1RCxJQUFJLENBQUNVLCtCQUErQixDQUFDLzlFLEtBQUtqZSxNQUFNcTdGLFdBQVdDO0FBQzdEO0FBRUEsSUFBSVksVUFBVSxDQUFDO0FBRWYsMEZBQTBGO0FBQzFGLGdGQUFnRjtBQUNoRkEsUUFBUXJmLFdBQVcsR0FBRyxTQUFVN3lELElBQUksRUFBRWhxQixJQUFJLEVBQUV6QixLQUFLLEVBQUVxK0UsaUJBQWlCO0lBQ2xFLElBQUl0NUUsUUFBTyxJQUFJO0lBQ2YsSUFBSXczQyxRQUFRLEVBQUU7SUFDZCxJQUFJcWhELFdBQVc7SUFFZixrRkFBa0Y7SUFDbEYsSUFBSW44RixTQUFTLE9BQU9BLFNBQVMsTUFBTTtRQUNqQyw4QkFBOEI7UUFFOUIsSUFBSXpCLFVBQVVtQixXQUFXO1lBQ3ZCLElBQUssSUFBSVIsSUFBSSxHQUFHQSxJQUFJb0UsTUFBSzI4QyxVQUFVLENBQUN0akQsTUFBTSxFQUFFdUMsSUFBSztnQkFDL0MsSUFBSTgvQyxPQUFPMTdDLE1BQUsyOEMsVUFBVSxDQUFDL2dELEVBQUU7Z0JBQzdCLElBQUkydEYsUUFBUTd0QyxLQUFLaC9DLElBQUk7Z0JBQ3JCLElBQUlxMkYsYUFBYSxJQUFJLENBQUM3NkIsS0FBSyxDQUFDcXhCLE9BQU90dUYsT0FBTztnQkFDMUMsSUFBSTgzRixZQUFZO29CQUNkdjdDLE1BQU0zN0MsSUFBSSxDQUFDazNGO2dCQUNiO1lBQ0Y7UUFDRjtJQUNGLE9BQU8sSUFBSXQxRixPQUFPZixPQUFPO1FBQ3ZCLGlDQUFpQztRQUNqQyxJQUFJbzhGLGNBQWMsSUFBSSxDQUFDNWdDLEtBQUssQ0FBQ3g3RCxNQUFNekIsT0FBTztRQUMxQyxJQUFJNjlGLGFBQWE7WUFDZnRoRCxNQUFNMzdDLElBQUksQ0FBQ2k5RjtRQUNiO0lBQ0YsT0FBTyxJQUFJajdGLFlBQVluQixPQUFPO1FBQzVCLDJCQUEyQjtRQUMzQixJQUFJcThGLGlCQUFpQnI4RjtRQUNyQjQ4RSxvQkFBb0JyK0U7UUFDcEIsSUFBSXF6RCxRQUFRbDBELE9BQU80SCxJQUFJLENBQUMrMkY7UUFDeEIsSUFBSyxJQUFJejJFLEtBQUssR0FBR0EsS0FBS2dzQyxNQUFNajFELE1BQU0sRUFBRWlwQixLQUFNO1lBQ3hDLElBQUkwMkUsU0FBUzFxQyxLQUFLLENBQUNoc0MsR0FBRztZQUN0QixJQUFJMjJFLFNBQVNGLGNBQWMsQ0FBQ0MsT0FBTztZQUNuQyxJQUFJQyxXQUFXNzhGLFdBQVc7Z0JBQ3hCLDBCQUEwQjtnQkFDMUI2OEYsU0FBU0YsY0FBYyxDQUFDcjRGLFdBQVdzNEYsUUFBUTtZQUM3QztZQUNBLElBQUlDLFdBQVc3OEYsV0FBVztnQkFDeEIsSUFBSTg4RixlQUFlLElBQUksQ0FBQ2hoQyxLQUFLLENBQUM4Z0MsUUFBUUMsUUFBUTtnQkFDOUMsSUFBSUMsY0FBYztvQkFDaEIxaEQsTUFBTTM3QyxJQUFJLENBQUNxOUY7Z0JBQ2I7WUFDRjtRQUNGO0lBQ0YsT0FBTztRQUNMLG9EQUFvRDtRQUNwRCxPQUFPO0lBQ1Q7SUFFQSxnREFBZ0Q7SUFDaEQsSUFBSTFoRCxNQUFNbitDLE1BQU0sS0FBSyxHQUFHO1FBQ3RCLE9BQU87SUFDVDtJQUVBLG1EQUFtRDtJQUNuRCxJQUFJNEcsTUFBTSxPQUFPLHVEQUF1RDtJQUN4RSxJQUFLLElBQUlpaUIsTUFBTSxHQUFHQSxNQUFNd0UsS0FBS3J0QixNQUFNLEVBQUU2b0IsTUFBTztRQUMxQyxlQUFlO1FBQ2YsSUFBSXZILE1BQU0rTCxJQUFJLENBQUN4RSxJQUFJO1FBQ25CLElBQUlvdEUsWUFBWSxDQUFDO1FBQ2pCLElBQUlpSSxXQUFXbjdGO1FBQ2YsSUFBSyxJQUFJNkYsSUFBSSxHQUFHQSxJQUFJdTFDLE1BQU1uK0MsTUFBTSxFQUFFNEksSUFBSztZQUNyQyxnQkFBZ0I7WUFDaEIsSUFBSWszRixRQUFRM2hELEtBQUssQ0FBQ3YxQyxFQUFFO1lBQ3BCLElBQUlxM0UsbUJBQW1CO2dCQUNyQixJQUFJa2UsV0FBVzc4RSxJQUFJNG1ELE1BQU0sQ0FBQzQzQixNQUFNejhGLElBQUk7Z0JBQ3BDNjZGLFdBQVdqSSxTQUFTLENBQUM2SixNQUFNejhGLElBQUksQ0FBQyxHQUFHO29CQUNqQ21xQixNQUFNMndFO2dCQUNSO1lBQ0Y7WUFDQXYzRixNQUFNLElBQUksQ0FBQzJ4RixtQkFBbUIsQ0FBQ2ozRSxLQUFLZCxLQUFLcy9FLFdBQVdsNUY7WUFDcEQsSUFBSXE1RSxtQkFBbUI7Z0JBQ3JCaWUsU0FBU2w4RixJQUFJLEdBQUdzZixJQUFJNG1ELE1BQU0sQ0FBQzQzQixNQUFNejhGLElBQUk7WUFDdkM7UUFDRixFQUFFLFlBQVk7UUFFZCxJQUFJdUQsS0FBSztZQUNQLElBQUksQ0FBQ3V2RixnQkFBZ0IsQ0FBQzcwRTtRQUN4QjtRQUNBLElBQUkyK0QsbUJBQW1CO1lBQ3JCLElBQUksQ0FBQ0EsaUJBQWlCLENBQUMzK0QsS0FBSzIwRSxXQUFXdUo7UUFDekM7SUFDRixFQUFFLFdBQVc7SUFFYixPQUFPNTRGO0FBQ1Q7QUFFQSwrQ0FBK0M7QUFDL0MyNEYsUUFBUW5QLGNBQWMsR0FBRyxTQUFVL2lFLElBQUksRUFBRWhxQixJQUFJLEVBQUV6QixLQUFLO0lBQ2xEeUIsT0FBTzJELFdBQVczRDtJQUNsQixJQUFLLElBQUlkLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtRQUNqQixJQUFJOC9DLE9BQU8vZ0MsSUFBSW5jLFFBQVEsQ0FBQ2tmLEtBQUssQ0FBQ2hoQixLQUFLO1FBQ25DLElBQUl3UixPQUFPLElBQUksQ0FBQ3l1QyxVQUFVLENBQUNqZ0QsS0FBSyxDQUFDd1IsSUFBSTtRQUNyQyxJQUFJa3JGLFVBQVVsckYsS0FBS3ZLLEtBQUs7UUFDeEIsSUFBSTAxRixVQUFVbnJGLEtBQUtvckYsT0FBTztRQUMxQixJQUFJQyxXQUFXLENBQUM3OUMsT0FBTyxPQUFPQSxLQUFLOGxCLE9BQU8sSUFBSSxPQUFPOWxCLEtBQUs4bEIsT0FBTyxHQUFHOWxCLEtBQUt6Z0QsS0FBSztRQUM5RSxJQUFJLENBQUN5Z0QsUUFBUSxDQUFDQSxLQUFLejdCLE1BQU0sRUFBRTtZQUN6QixxQ0FBcUM7WUFDckMsSUFBSSxDQUFDczVELFdBQVcsQ0FBQzUrRCxLQUFLamUsTUFBTXpCO1FBQzlCLE9BQU87WUFDTHlnRCxLQUFLemdELEtBQUssR0FBR0E7WUFDYixJQUFJeWdELEtBQUs4bEIsT0FBTyxJQUFJLE1BQU07Z0JBQ3hCOWxCLEtBQUs4bEIsT0FBTyxHQUFHdm1FO1lBQ2pCO1lBQ0EsSUFBSW0rRixTQUFTO2dCQUNYMTlDLEtBQUsyb0IsUUFBUSxHQUFHLFNBQVNwcEUsTUFBTTRFLElBQUksQ0FBQyxPQUFPO1lBQzdDLE9BQU8sSUFBSXc1RixTQUFTO2dCQUNsQjM5QyxLQUFLMm9CLFFBQVEsR0FBR3BwRSxNQUFNNEUsSUFBSSxDQUFDO1lBQzdCLE9BQU87Z0JBQ0w2N0MsS0FBSzJvQixRQUFRLEdBQUcsS0FBS3BwRTtZQUN2QjtZQUNBLElBQUksQ0FBQ3UwRixnQkFBZ0IsQ0FBQzcwRTtRQUN4QjtRQUNBLElBQUksQ0FBQ2k3RSxhQUFhLENBQUNqN0UsS0FBS2plLE1BQU02OEYsVUFBVXQrRjtJQUMxQztBQUNGO0FBQ0EyOUYsUUFBUWpmLGlCQUFpQixHQUFHLFNBQVVqekQsSUFBSSxFQUFFNHlELGlCQUFpQjtJQUMzRCxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDbHpELE1BQU0sSUFBSSxDQUFDOHlFLGFBQWEsRUFBRWxnQjtBQUN2RDtBQUNBc2YsUUFBUWhmLGNBQWMsR0FBRyxTQUFVbHpELElBQUksRUFBRTh3QixLQUFLLEVBQUU4aEMsaUJBQWlCO0lBQy9ELElBQUl1ZixXQUFXO0lBQ2YsSUFBSyxJQUFJNTJGLElBQUksR0FBR0EsSUFBSXlrQixLQUFLcnRCLE1BQU0sRUFBRTRJLElBQUs7UUFDcEMsSUFBSTBZLE1BQU0rTCxJQUFJLENBQUN6a0IsRUFBRTtRQUNqQixJQUFJcXRGLFlBQVksQ0FBQztRQUNqQixJQUFLLElBQUkxekYsSUFBSSxHQUFHQSxJQUFJNDdDLE1BQU1uK0MsTUFBTSxFQUFFdUMsSUFBSztZQUNyQyxJQUFJYyxPQUFPODZDLEtBQUssQ0FBQzU3QyxFQUFFO1lBQ25CLElBQUk4L0MsT0FBTyxJQUFJLENBQUNpQixVQUFVLENBQUNqZ0QsS0FBSztZQUNoQyxJQUFJODZGLFdBQVc3OEUsSUFBSTRtRCxNQUFNLENBQUM3bEIsS0FBS2gvQyxJQUFJO1lBQ25DLElBQUksQ0FBQzg2RixZQUFZLENBQUNBLFNBQVN2M0UsTUFBTSxFQUFFO2dCQUVqQztZQUNGO1lBQ0EsSUFBSWhsQixRQUFRLElBQUkseUJBQXlCO1lBQ3pDLElBQUk4M0YsYUFBYSxJQUFJLENBQUM3NkIsS0FBSyxDQUFDeDdELE1BQU16QixPQUFPO1lBQ3pDLElBQUlzOEYsV0FBV2pJLFNBQVMsQ0FBQzV6QyxLQUFLaC9DLElBQUksQ0FBQyxHQUFHO2dCQUNwQ21xQixNQUFNMndFO1lBQ1I7WUFDQSxJQUFJLENBQUM1RixtQkFBbUIsQ0FBQ2ozRSxLQUFLbzRFO1lBQzlCd0UsU0FBU2w4RixJQUFJLEdBQUdzZixJQUFJNG1ELE1BQU0sQ0FBQzdsQixLQUFLaC9DLElBQUk7UUFDdEMsRUFBRSxZQUFZO1FBRWQsSUFBSSxDQUFDOHlGLGdCQUFnQixDQUFDNzBFO1FBQ3RCLElBQUkyK0QsbUJBQW1CO1lBQ3JCLElBQUksQ0FBQ0EsaUJBQWlCLENBQUMzK0QsS0FBSzIwRSxXQUFXdUo7UUFDekM7SUFDRixFQUFFLFdBQVc7QUFDZjtBQUVBLElBQUlZLFVBQVUsQ0FBQztBQUVmLDBFQUEwRTtBQUMxRUEsUUFBUUMsaUJBQWlCLEdBQUc7SUFDMUIsSUFBSUMsS0FBSyxJQUFJLENBQUNDLFlBQVksQ0FBQztJQUMzQixJQUFJRCxNQUFNLE1BQU07UUFDZCxPQUFPMTJGLFdBQVcwMkY7SUFDcEIsT0FBTztRQUNMLE9BQU8sR0FBRyxlQUFlO0lBQzNCO0FBQ0Y7QUFFQSw0Q0FBNEM7QUFDNUNGLFFBQVFHLFlBQVksR0FBRyxTQUFVMStFLFFBQVE7SUFDdkMsSUFBSTBCLEtBQUssSUFBSSxDQUFDcGUsUUFBUSxDQUFDb2UsRUFBRTtJQUN6QixJQUFJN2QsYUFBYTZkLEdBQUd3eEUsU0FBUztJQUM3QixJQUFJeUwsa0JBQWtCajlFLEdBQUcvZixNQUFNO0lBQy9CLElBQUlnOUYsbUJBQW1COTZGLGNBQWM4NkYsZ0JBQWdCQyxnQkFBZ0IsRUFBRTtRQUNyRSxPQUFPRCxnQkFBZ0JDLGdCQUFnQixDQUFDLzZGLFlBQVlnN0YsZ0JBQWdCLENBQUM3K0U7SUFDdkU7QUFDRjtBQUVBLElBQUk4K0UsVUFBVSxDQUFDO0FBRWYseUNBQXlDO0FBQ3pDQSxRQUFRM2dCLGdCQUFnQixHQUFHLFNBQVUxK0QsR0FBRyxFQUFFK2dDLElBQUk7SUFDNUMsSUFBSUEsTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDODlCLHFCQUFxQixDQUFDNytELEtBQUsrZ0MsTUFBTTtJQUMvQyxPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUMrOUIsV0FBVyxDQUFDOStELEtBQUs7SUFDL0I7QUFDRjtBQUVBLG9DQUFvQztBQUNwQ3EvRSxRQUFRdmdCLFdBQVcsR0FBRyxTQUFVOStELEdBQUcsRUFBRXMvRSxhQUFhO0lBQ2hELElBQUlqNkYsUUFBTyxJQUFJO0lBQ2YyYSxNQUFNQSxHQUFHLENBQUMsRUFBRSxFQUFFLHlCQUF5QjtJQUV2QyxJQUFJQSxLQUFLO1FBQ1AsSUFBSWdELFNBQVMsQ0FBQztRQUNkLElBQUssSUFBSS9oQixJQUFJLEdBQUdBLElBQUlvRSxNQUFLMjhDLFVBQVUsQ0FBQ3RqRCxNQUFNLEVBQUV1QyxJQUFLO1lBQy9DLElBQUk4L0MsT0FBTzE3QyxNQUFLMjhDLFVBQVUsQ0FBQy9nRCxFQUFFO1lBQzdCLElBQUkyZixNQUFNdmIsTUFBS3c1RSxxQkFBcUIsQ0FBQzcrRCxLQUFLK2dDLEtBQUtoL0MsSUFBSSxFQUFFdTlGO1lBQ3JELElBQUkxK0UsT0FBTyxNQUFNO2dCQUNmb0MsTUFBTSxDQUFDKzlCLEtBQUtoL0MsSUFBSSxDQUFDLEdBQUc2ZTtnQkFDcEJvQyxNQUFNLENBQUNqZCxXQUFXZzdDLEtBQUtoL0MsSUFBSSxFQUFFLEdBQUc2ZTtZQUNsQztRQUNGO1FBQ0EsT0FBT29DO0lBQ1Q7QUFDRjtBQUNBcThFLFFBQVFFLGVBQWUsR0FBRyxTQUFVdi9FLEdBQUcsRUFBRW0rRCxRQUFRLEVBQUVxaEIsV0FBVyxFQUFFNXFGLEtBQUs7SUFDbkUsSUFBSWd5RCxTQUFTNW1ELElBQUk0bUQsTUFBTSxDQUFDdVgsU0FBUyxDQUFDcWhCLFlBQVksQ0FBQzVxRixNQUFNO0lBQ3JELE9BQU9neUQsVUFBVSxPQUFPQSxTQUFTNW1ELElBQUlpQyxFQUFFLEdBQUdjLEtBQUssR0FBR3U3RCxrQkFBa0IsQ0FBQ0gsU0FBUyxDQUFDcWhCLFlBQVksQ0FBQyxFQUFFO0FBQ2hHO0FBQ0FILFFBQVF4Z0IscUJBQXFCLEdBQUcsU0FBVTcrRCxHQUFHLEVBQUVPLFFBQVEsRUFBRSsrRSxhQUFhO0lBQ3BFLElBQUlqNkYsUUFBTyxJQUFJO0lBQ2YyYSxNQUFNQSxHQUFHLENBQUMsRUFBRSxFQUFFLHlCQUF5QjtJQUV2QyxJQUFJQSxLQUFLO1FBQ1AsSUFBSStnQyxPQUFPMTdDLE1BQUsyOEMsVUFBVSxDQUFDemhDLFNBQVM7UUFDcEMsSUFBSXdnQyxLQUFLMCtDLEtBQUssRUFBRTtZQUNkMStDLE9BQU9BLEtBQUsyK0MsUUFBUTtRQUN0QjtRQUNBLElBQUluc0YsT0FBT3d0QyxLQUFLeHRDLElBQUk7UUFDcEIsSUFBSW9zRixZQUFZMy9FLElBQUk0bUQsTUFBTSxDQUFDN2xCLEtBQUtoL0MsSUFBSTtRQUNwQyxJQUFJNDlGLFdBQVc7WUFDYixJQUFJci9GLFFBQVFxL0YsVUFBVXIvRixLQUFLLEVBQ3pCb25FLFFBQVFpNEIsVUFBVWo0QixLQUFLLEVBQ3ZCZ0MsV0FBV2kyQixVQUFVajJCLFFBQVE7WUFDL0IsSUFBSTQxQixpQkFBaUIvckYsS0FBS2xRLE1BQU0sSUFBSS9DLFNBQVMsUUFBUThDLFNBQVM5QyxRQUFRO2dCQUNwRSxJQUFJNGtCLE9BQU9sRixJQUFJaUMsRUFBRSxHQUFHaUQsSUFBSTtnQkFDeEIsSUFBSTA2RSxtQkFBbUIsU0FBU0EsaUJBQWlCaC9FLEdBQUc7b0JBQ2xELE9BQU9BLE1BQU1zRTtnQkFDZjtnQkFDQSxJQUFJMjZFLDBCQUEwQixTQUFTQSx3QkFBd0JqL0UsR0FBRyxFQUFFOG1ELEtBQUs7b0JBQ3ZFLE9BQU9rNEIsaUJBQWlCaC9FLE9BQU84bUQ7Z0JBQ2pDO2dCQUNBLElBQUlvNEIsZUFBZTk4RixNQUFNMUM7Z0JBQ3pCLElBQUl5L0YsWUFBWUQsZUFBZXA0QixNQUFNaEksS0FBSyxDQUFDLFNBQVVsL0QsQ0FBQztvQkFDcEQsT0FBT0EsS0FBSztnQkFDZCxLQUFLa25FLFNBQVM7Z0JBQ2QsSUFBSXE0QixXQUFXO29CQUNiLElBQUlELGNBQWM7d0JBQ2hCLE9BQU94L0YsTUFBTW1TLEdBQUcsQ0FBQyxTQUFVNU0sQ0FBQyxFQUFFNUUsQ0FBQzs0QkFDN0IsT0FBTzQrRix3QkFBd0JoNkYsR0FBRzZoRSxLQUFLLENBQUN6bUUsRUFBRTt3QkFDNUMsR0FBR2lFLElBQUksQ0FBQztvQkFDVixPQUFPO3dCQUNMLE9BQU8yNkYsd0JBQXdCdi9GLE9BQU9vbkU7b0JBQ3hDO2dCQUNGLE9BQU87b0JBQ0wsSUFBSW80QixjQUFjO3dCQUNoQixPQUFPeC9GLE1BQU1tUyxHQUFHLENBQUMsU0FBVTVNLENBQUM7NEJBQzFCLE9BQU8vQyxPQUFPK0MsS0FBS0EsSUFBSSxLQUFLKzVGLGlCQUFpQi81Rjt3QkFDL0MsR0FBR1gsSUFBSSxDQUFDO29CQUNWLE9BQU87d0JBQ0wsT0FBTyxLQUFLMDZGLGlCQUFpQnQvRjtvQkFDL0I7Z0JBQ0Y7WUFDRixPQUFPLElBQUlvcEUsWUFBWSxNQUFNO2dCQUMzQixPQUFPQTtZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7QUFDRjtBQUNBMjFCLFFBQVF2L0Msc0JBQXNCLEdBQUcsU0FBVTkvQixHQUFHLEVBQUVnZ0YsUUFBUTtJQUN0RCxJQUFJaDlFLFNBQVMsQ0FBQztJQUNkLElBQUssSUFBSS9oQixJQUFJLEdBQUdBLElBQUkrK0YsU0FBU3RoRyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3hDLElBQUlnL0YsVUFBVUQsUUFBUSxDQUFDLytGLEVBQUU7UUFDekIsSUFBSWMsT0FBT2srRixRQUFRbCtGLElBQUk7UUFDdkIsSUFBSTQ5RixZQUFZMy9FLElBQUk0bUQsTUFBTSxDQUFDN2tFO1FBQzNCLElBQUk0OUYsY0FBY2wrRixXQUFXO1lBQzNCLHlCQUF5QjtZQUN6QixJQUFJeUIsWUFBWXk4RixZQUFZO2dCQUMxQkEsWUFBWSxJQUFJLENBQUNwaUMsS0FBSyxDQUFDeDdELE1BQU00OUYsVUFBVWoyQixRQUFRO1lBQ2pELE9BQU87Z0JBQ0xpMkIsWUFBWSxJQUFJLENBQUNwaUMsS0FBSyxDQUFDeDdELE1BQU00OUY7WUFDL0I7UUFDRjtRQUNBLElBQUlBLFdBQVc7WUFDYjM4RSxNQUFNLENBQUNqaEIsS0FBSyxHQUFHNDlGO1FBQ2pCO0lBQ0Y7SUFDQSxPQUFPMzhFO0FBQ1Q7QUFDQXE4RSxRQUFRbDlDLFlBQVksR0FBRyxTQUFVKzlDLFFBQVE7SUFDdkMsSUFBSTc2RixRQUFPLElBQUk7SUFDZixJQUFJMmQsU0FBUyxFQUFFO0lBQ2YsSUFBSUQsUUFBUW05RTtJQUNaLElBQUlyakQsUUFBUXgzQyxNQUFLMjhDLFVBQVU7SUFDM0IsSUFBSWovQixPQUFPO1FBQ1QsSUFBSTR3QyxRQUFRbDBELE9BQU80SCxJQUFJLENBQUMwYjtRQUN4QixJQUFLLElBQUk5aEIsSUFBSSxHQUFHQSxJQUFJMHlELE1BQU1qMUQsTUFBTSxFQUFFdUMsSUFBSztZQUNyQyxJQUFJYyxPQUFPNHhELEtBQUssQ0FBQzF5RCxFQUFFO1lBQ25CLElBQUkyZixNQUFNbUMsS0FBSyxDQUFDaGhCLEtBQUs7WUFDckIsSUFBSWcvQyxPQUFPbEUsS0FBSyxDQUFDOTZDLEtBQUssSUFBSTg2QyxLQUFLLENBQUNuM0MsV0FBVzNELE1BQU07WUFDakQsSUFBSTQ5RixZQUFZLElBQUksQ0FBQ3BpQyxLQUFLLENBQUN4YyxLQUFLaC9DLElBQUksRUFBRTZlO1lBQ3RDLElBQUkrK0UsV0FBVztnQkFDYjM4RSxPQUFPOWhCLElBQUksQ0FBQ3krRjtZQUNkO1FBQ0Y7SUFDRjtJQUNBLE9BQU8zOEU7QUFDVDtBQUNBcThFLFFBQVFjLDJCQUEyQixHQUFHLFNBQVVuZ0YsR0FBRyxFQUFFbTNFLFNBQVMsRUFBRWg4RSxJQUFJO0lBQ2xFLElBQUlDLE9BQU9ELEtBQUtyWixLQUFLO0lBQ3JCLElBQUlDLE1BQU02ZSxLQUFLczNFLFFBQVFrSTtJQUN2QixJQUFJbi9GLEdBQUdxRztJQUNQLElBQUtyRyxJQUFJLEdBQUdBLElBQUlrMkYsVUFBVXo0RixNQUFNLEVBQUV1QyxJQUFLO1FBQ3JDYyxPQUFPbzFGLFNBQVMsQ0FBQ2wyRixFQUFFO1FBQ25CMmYsTUFBTVosSUFBSTRtRCxNQUFNLENBQUM3a0UsTUFBTTtRQUN2QixJQUFJNmUsT0FBTyxNQUFNO1lBQ2Y7UUFDRixPQUFPLElBQUlBLElBQUlpbUQsT0FBTyxJQUFJLE1BQU07WUFDOUJ6ckQsSUFBSSxDQUFDLEVBQUUsR0FBR0UsUUFBUThrRixPQUFPaGxGLElBQUksQ0FBQyxFQUFFO1lBQ2hDQSxJQUFJLENBQUMsRUFBRSxHQUFHSSxXQUFXNGtGLE9BQU9obEYsSUFBSSxDQUFDLEVBQUU7UUFDckMsT0FBTztZQUNMODhFLFNBQVN0M0UsSUFBSThvRCxRQUFRO1lBQ3JCLElBQUtwaUUsSUFBSSxHQUFHQSxJQUFJNHdGLE9BQU94NUYsTUFBTSxFQUFFNEksSUFBSztnQkFDbEM4NEYsUUFBUWxJLE9BQU85N0UsVUFBVSxDQUFDOVU7Z0JBQzFCOFQsSUFBSSxDQUFDLEVBQUUsR0FBR0UsUUFBUThrRixPQUFPaGxGLElBQUksQ0FBQyxFQUFFO2dCQUNoQ0EsSUFBSSxDQUFDLEVBQUUsR0FBR0ksV0FBVzRrRixPQUFPaGxGLElBQUksQ0FBQyxFQUFFO1lBQ3JDO1FBQ0Y7SUFDRjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQWlrRixRQUFRNUgsaUJBQWlCLEdBQUc0SCxRQUFRYywyQkFBMkI7QUFFL0QsSUFBSUUsVUFBVSxDQUFDO0FBQ2ZBLFFBQVFDLGNBQWMsR0FBRyxTQUFVbGIsSUFBSTtJQUNyQyxJQUFJcmlFLFFBQVEsSUFBSTtJQUNoQixJQUFLLElBQUk5aEIsSUFBSSxHQUFHQSxJQUFJbWtGLEtBQUsxbUYsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJNnpFLFVBQVVzUSxJQUFJLENBQUNua0YsRUFBRTtRQUNyQixJQUFJZzBELFdBQVc2ZixRQUFRN2YsUUFBUTtRQUMvQixJQUFJcFksUUFBUWk0QixRQUFRL3hELEtBQUssSUFBSSt4RCxRQUFRdnZELEdBQUc7UUFDeEMsSUFBSW91QyxRQUFRbDBELE9BQU80SCxJQUFJLENBQUN3MUM7UUFDeEI5NUIsTUFBTWt5QyxRQUFRLENBQUNBLFdBQVcsaUJBQWlCO1FBRTNDLElBQUssSUFBSTN0RCxJQUFJLEdBQUdBLElBQUlxc0QsTUFBTWoxRCxNQUFNLEVBQUU0SSxJQUFLO1lBQ3JDLElBQUl2RixPQUFPNHhELEtBQUssQ0FBQ3JzRCxFQUFFO1lBQ25CLElBQUloSCxRQUFRdThDLEtBQUssQ0FBQzk2QyxLQUFLO1lBQ3ZCZ2hCLE1BQU13QyxHQUFHLENBQUN4akIsTUFBTXpCLFFBQVEsaUJBQWlCO1FBQzNDO0lBQ0Y7SUFDQSxPQUFPeWlCO0FBQ1Q7QUFFQSxpQ0FBaUM7QUFDakNzOUUsUUFBUUUsUUFBUSxHQUFHLFNBQVVuYixJQUFJO0lBQy9CLElBQUlyaUUsUUFBUSxJQUFJO0lBQ2hCQSxNQUFNeTlFLGNBQWM7SUFDcEJ6OUUsTUFBTXU5RSxjQUFjLENBQUNsYjtJQUNyQixPQUFPcmlFO0FBQ1Q7QUFFQSwrQkFBK0I7QUFDL0JzOUUsUUFBUWpiLElBQUksR0FBRztJQUNiLElBQUlBLE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSW5rRixJQUFJLElBQUksQ0FBQ3cvRixhQUFhLEVBQUV4L0YsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3JELElBQUlvMEYsTUFBTSxJQUFJLENBQUNwMEYsRUFBRTtRQUNqQixJQUFJZzBELFdBQVdvZ0MsSUFBSXBnQyxRQUFRO1FBQzNCLElBQUlwWSxRQUFRdzRDLElBQUlyekMsVUFBVTtRQUMxQixJQUFJejhCLE1BQU0sQ0FBQztRQUNYLElBQUssSUFBSWplLElBQUksR0FBR0EsSUFBSXUxQyxNQUFNbitDLE1BQU0sRUFBRTRJLElBQUs7WUFDckMsSUFBSXk1QyxPQUFPbEUsS0FBSyxDQUFDdjFDLEVBQUU7WUFDbkJpZSxHQUFHLENBQUN3N0IsS0FBS2gvQyxJQUFJLENBQUMsR0FBR2cvQyxLQUFLMm9CLFFBQVE7UUFDaEM7UUFDQTBiLEtBQUtsa0YsSUFBSSxDQUFDO1lBQ1IrekQsVUFBVSxDQUFDQSxXQUFXLFNBQVNBLFNBQVNwekQsUUFBUTtZQUNoRGtoQixPQUFPd0M7UUFDVDtJQUNGO0lBQ0EsT0FBTzYvRDtBQUNUO0FBRUEsSUFBSXNiLFVBQVUsQ0FBQztBQUNmQSxRQUFRQyxnQkFBZ0IsR0FBRyxTQUFVNzlGLE1BQU07SUFDekMsSUFBSXVDLFFBQU8sSUFBSTtJQUNmLElBQUkwZCxRQUFRLElBQUk7SUFDaEIsSUFBSW82QyxZQUFZLEtBQUtyNkQ7SUFDckIsSUFBSTg5RjtJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSix3Q0FBd0M7SUFDeEMzakMsWUFBWUEsVUFBVXYzRCxPQUFPLENBQUMseUJBQXlCO0lBQ3ZELFNBQVNtN0Y7UUFDUCx3RUFBd0U7UUFDeEUsSUFBSTVqQyxVQUFVeitELE1BQU0sR0FBR2tpRyxlQUFlbGlHLE1BQU0sRUFBRTtZQUM1Q3krRCxZQUFZQSxVQUFVOFYsTUFBTSxDQUFDMnRCLGVBQWVsaUcsTUFBTTtRQUNwRCxPQUFPO1lBQ0x5K0QsWUFBWTtRQUNkO0lBQ0Y7SUFDQSxTQUFTNmpDO1FBQ1AsOEVBQThFO1FBQzlFLElBQUlILFNBQVNuaUcsTUFBTSxHQUFHb2lHLGNBQWNwaUcsTUFBTSxFQUFFO1lBQzFDbWlHLFdBQVdBLFNBQVM1dEIsTUFBTSxDQUFDNnRCLGNBQWNwaUcsTUFBTTtRQUNqRCxPQUFPO1lBQ0xtaUcsV0FBVztRQUNiO0lBQ0Y7SUFDQSxPQUFTO1FBQ1AsSUFBSUkscUJBQXFCOWpDLFVBQVVoNUQsS0FBSyxDQUFDO1FBQ3pDLElBQUk4OEYsb0JBQW9CO1lBQ3RCO1FBQ0Y7UUFDQSxJQUFJQyxjQUFjL2pDLFVBQVVoNUQsS0FBSyxDQUFDO1FBQ2xDLElBQUksQ0FBQys4RixhQUFhO1lBQ2hCampGLEtBQUssOEdBQThHay9DO1lBQ25IO1FBQ0Y7UUFDQXlqQyxpQkFBaUJNLFdBQVcsQ0FBQyxFQUFFO1FBRS9CLHFCQUFxQjtRQUNyQixJQUFJQyxjQUFjRCxXQUFXLENBQUMsRUFBRTtRQUNoQyxJQUFJQyxnQkFBZ0IsUUFBUTtZQUMxQixJQUFJbHNDLFdBQVcsSUFBSW1MLFNBQVMrZ0M7WUFDNUIsSUFBSWxzQyxTQUFTcUwsT0FBTyxFQUFFO2dCQUNwQnJpRCxLQUFLLDZFQUE2RWtqRjtnQkFFbEYsK0JBQStCO2dCQUMvQko7Z0JBQ0E7WUFDRjtRQUNGO1FBRUEsMkNBQTJDO1FBQzNDLElBQUlLLFdBQVdGLFdBQVcsQ0FBQyxFQUFFO1FBQzdCLElBQUlHLGVBQWU7UUFDbkJSLFdBQVdPO1FBQ1gsSUFBSXZrRCxRQUFRLEVBQUU7UUFDZCxPQUFTO1lBQ1AsSUFBSXlrRCxzQkFBc0JULFNBQVMxOEYsS0FBSyxDQUFDO1lBQ3pDLElBQUltOUYscUJBQXFCO2dCQUN2QjtZQUNGO1lBQ0EsSUFBSUMsYUFBYVYsU0FBUzE4RixLQUFLLENBQUM7WUFDaEMsSUFBSSxDQUFDbzlGLFlBQVk7Z0JBQ2Z0akYsS0FBSyxvR0FBb0dtakY7Z0JBQ3pHQyxlQUFlO2dCQUNmO1lBQ0Y7WUFDQVAsZ0JBQWdCUyxVQUFVLENBQUMsRUFBRTtZQUM3QixJQUFJQyxVQUFVRCxVQUFVLENBQUMsRUFBRTtZQUMzQixJQUFJcmlDLFNBQVNxaUMsVUFBVSxDQUFDLEVBQUU7WUFDMUIsSUFBSXhnRCxPQUFPMTdDLE1BQUsyOEMsVUFBVSxDQUFDdy9DLFFBQVE7WUFDbkMsSUFBSSxDQUFDemdELE1BQU07Z0JBQ1Q5aUMsS0FBSyxrREFBa0Q2aUY7Z0JBRXZELGtDQUFrQztnQkFDbENFO2dCQUNBO1lBQ0Y7WUFDQSxJQUFJNUksYUFBYXIxRSxNQUFNdzZDLEtBQUssQ0FBQ2lrQyxTQUFTdGlDO1lBQ3RDLElBQUksQ0FBQ2s1QixZQUFZO2dCQUNmbjZFLEtBQUssd0RBQXdENmlGO2dCQUU3RCxrQ0FBa0M7Z0JBQ2xDRTtnQkFDQTtZQUNGO1lBQ0Fua0QsTUFBTTM3QyxJQUFJLENBQUM7Z0JBQ1RhLE1BQU15L0Y7Z0JBQ041Z0YsS0FBS3MrQztZQUNQO1lBQ0E4aEM7UUFDRjtRQUNBLElBQUlLLGNBQWM7WUFDaEJOO1lBQ0E7UUFDRjtRQUVBLG9DQUFvQztRQUNwQ2grRSxNQUFNa3lDLFFBQVEsQ0FBQ2tzQztRQUNmLElBQUssSUFBSWxnRyxJQUFJLEdBQUdBLElBQUk0N0MsTUFBTW4rQyxNQUFNLEVBQUV1QyxJQUFLO1lBQ3JDLElBQUl1OUYsUUFBUTNoRCxLQUFLLENBQUM1N0MsRUFBRTtZQUNwQjhoQixNQUFNd0MsR0FBRyxDQUFDaTVFLE1BQU16OEYsSUFBSSxFQUFFeThGLE1BQU01OUUsR0FBRztRQUNqQztRQUNBbWdGO0lBQ0Y7SUFDQSxPQUFPaCtFO0FBQ1Q7QUFDQTI5RSxRQUFRZSxVQUFVLEdBQUcsU0FBVTMrRixNQUFNO0lBQ25DLElBQUlpZ0IsUUFBUSxJQUFJO0lBQ2hCQSxNQUFNeTlFLGNBQWM7SUFDcEJ6OUUsTUFBTTQ5RSxnQkFBZ0IsQ0FBQzc5RjtJQUN2QixPQUFPaWdCO0FBQ1Q7QUFFQSxJQUFJMitFLFVBQVUsQ0FBQztBQUNkO0lBQ0MsSUFBSXQrRixXQUFXQztJQUNmLElBQUltRCxPQUFPQztJQUNYLElBQUlDLE9BQU9DO0lBQ1gsSUFBSWc3RixTQUFTLzZGO0lBQ2IsSUFBSWc3RixTQUFTLzZGO0lBQ2IsSUFBSXdiLE9BQU8sU0FBU0EsS0FBS25jLE1BQU07UUFDN0IsT0FBTyxNQUFNQSxTQUFTO0lBQ3hCO0lBQ0EsSUFBSW8xRixVQUFVLFNBQVNBLFFBQVFwMUYsTUFBTTtRQUNuQyxJQUFJMjdGLFNBQVN6K0YsV0FBVyxXQUFXb0QsT0FBTyxNQUFNRSxPQUFPLE1BQU1pN0YsU0FBUyxNQUFNQztRQUM1RSxPQUFPLE1BQU0xN0YsU0FBUyxtQ0FBbUM5QyxXQUFXLGtCQUFrQkEsV0FBVyxnQkFBZ0J5K0YsU0FBUyxrQkFBa0JBLFNBQVM7SUFDdko7SUFDQSxJQUFJQyxhQUFhO1FBQUM7UUFBNEM7UUFBWTtLQUFTO0lBRW5GLGtGQUFrRjtJQUNsRkosUUFBUW5MLEtBQUssR0FBRztRQUNkbDlFLE1BQU07WUFDSmhXLFFBQVE7WUFDUmtWLEtBQUs7WUFDTG12RCxPQUFPO1lBQ1BxNkIsZUFBZTtRQUNqQjtRQUNBOVUsU0FBUztZQUNQNXBGLFFBQVE7WUFDUmtWLEtBQUs7WUFDTEYsS0FBSztZQUNMcXZELE9BQU87WUFDUHE2QixlQUFlO1FBQ2pCO1FBQ0FDLGFBQWE7WUFDWDMrRixRQUFRO1lBQ1JrVixLQUFLO1lBQ0xGLEtBQUs7WUFDTHF2RCxPQUFPO1lBQ1BxNkIsZUFBZTtZQUNmaEosVUFBVTtRQUNaO1FBQ0FrSixlQUFlO1lBQ2I1K0YsUUFBUTtZQUNSa1YsS0FBSztZQUNMRixLQUFLO1lBQ0w2cEYsVUFBVTtRQUNaO1FBQ0FDLGdCQUFnQjtZQUNkOStGLFFBQVE7WUFDUmtWLEtBQUs7WUFDTEYsS0FBSztZQUNMNnBGLFVBQVU7WUFDVm5KLFVBQVU7UUFDWjtRQUNBcUosZUFBZTtZQUNiLytGLFFBQVE7WUFDUmtWLEtBQUssQ0FBQztZQUNORixLQUFLO1lBQ0w2cEYsVUFBVTtRQUNaO1FBQ0FHLGdCQUFnQjtZQUNkaC9GLFFBQVE7WUFDUmtWLEtBQUs7WUFDTGhWLFNBQVM7WUFDVDIrRixVQUFVO1FBQ1o7UUFDQUksbUJBQW1CO1lBQ2pCai9GLFFBQVE7WUFDUmtWLEtBQUs7WUFDTDJwRixVQUFVO1FBQ1o7UUFDQXovRSxVQUFVO1lBQ1JrMkUsT0FBTztnQkFBQztnQkFBVTthQUFTO1FBQzdCO1FBQ0E0SixVQUFVO1lBQ1JsL0YsUUFBUTtZQUNSa1YsS0FBSztZQUNMb2dGLE9BQU87Z0JBQUM7YUFBUTtRQUNsQjtRQUNBdDFGLFFBQVE7WUFDTkEsUUFBUTtZQUNSNitGLFVBQVU7UUFDWjtRQUNBTSxTQUFTO1lBQ1BuL0YsUUFBUTtZQUNSNitGLFVBQVU7WUFDVm5KLFVBQVU7UUFDWjtRQUNBMEosZ0JBQWdCO1lBQ2RwL0YsUUFBUTtZQUNSNitGLFVBQVU7WUFDVjNwRixLQUFLO1lBQ0xtcUYsV0FBVztRQUNiO1FBQ0FuaEYsTUFBTTtZQUNKbGUsUUFBUTtZQUNSa1YsS0FBSztRQUNQO1FBQ0FvcUYsbUJBQW1CO1lBQ2pCdC9GLFFBQVE7UUFDVjtRQUNBLGtCQUFrQjtRQUNsQnUvRiwrQkFBK0I7WUFDN0J2L0YsUUFBUTtZQUNSdy9GLGNBQWM7UUFDaEI7UUFDQSxrQkFBa0I7UUFDbEJDLG9CQUFvQjtZQUNsQnovRixRQUFRO1lBQ1IwMUYsVUFBVTtRQUNaO1FBQ0Esa0JBQWtCO1FBQ2xCZ0ssa0JBQWtCO1lBQ2hCMS9GLFFBQVE7WUFDUmtWLEtBQUs7WUFDTHNxRixjQUFjO1FBQ2hCO1FBQ0FHLGVBQWU7WUFDYnJLLE9BQU87Z0JBQUM7Z0JBQWM7Z0JBQVk7Z0JBQWE7Z0JBQVk7Z0JBQVU7Z0JBQVk7YUFBTztRQUMxRjtRQUNBc0ssdUJBQXVCO1lBQ3JCdEssT0FBTztnQkFBQztnQkFBWTtnQkFBYTtnQkFBVTthQUFXO1FBQ3hEO1FBQ0F1SyxzQkFBc0I7WUFDcEJ2SyxPQUFPO2dCQUFDO2dCQUFjO2FBQVc7UUFDbkM7UUFDQXdLLG1CQUFtQjtZQUNqQnhLLE9BQU87Z0JBQUM7Z0JBQVM7Z0JBQVU7Z0JBQVc7Z0JBQU87YUFBTTtRQUNyRDtRQUNBeUssTUFBTTtZQUNKLy9GLFFBQVE7WUFDUmtWLEtBQUs7WUFDTHNxRixjQUFjO1lBQ2RsSyxPQUFPO2dCQUFDO2FBQU87WUFDZkksVUFBVTtRQUNaO1FBQ0FzSyxPQUFPO1lBQ0xoZ0csUUFBUTtZQUNSdy9GLGNBQWM7WUFDZDlKLFVBQVU7UUFDWjtRQUNBdUssY0FBYztZQUNaM0ssT0FBTztnQkFBQztnQkFBUzthQUFrQjtZQUNuQ0ksVUFBVTtRQUNaO1FBQ0F3SyxVQUFVO1lBQ1I1SyxPQUFPO2dCQUFDO2dCQUFVO2dCQUFZO2dCQUFZO2FBQVk7WUFDdERJLFVBQVU7UUFDWjtRQUNBeUssT0FBTztZQUNMN0ssT0FBTztnQkFBQztnQkFBUTtnQkFBVzthQUFRO1lBQ25DSSxVQUFVO1FBQ1o7UUFDQTBLLGVBQWU7WUFDYjlLLE9BQU87Z0JBQUM7Z0JBQWE7Z0JBQW1CO2FBQU87WUFDL0NJLFVBQVU7UUFDWjtRQUNBMkssUUFBUTtZQUNOL0ssT0FBTztnQkFBQztnQkFBUTthQUFPO1lBQ3ZCSSxVQUFVO1FBQ1o7UUFDQTRLLGVBQWU7WUFDYmhMLE9BQU87Z0JBQUM7Z0JBQVU7YUFBTztZQUN6QkksVUFBVTtRQUNaO1FBQ0E2SyxjQUFjO1lBQ1pqTCxPQUFPO2dCQUFDO2dCQUFXO2dCQUFXO2FBQU87UUFDdkM7UUFDQTN2RixPQUFPO1lBQ0xBLE9BQU87UUFDVDtRQUNBQyxRQUFRO1lBQ05ELE9BQU87WUFDUCt2RixVQUFVO1FBQ1o7UUFDQThLLE1BQU07WUFDSmxMLE9BQU87Z0JBQUM7Z0JBQVM7Z0JBQW1CO2FBQWtCO1FBQ3hEO1FBQ0FySCxNQUFNO1lBQ0pxSCxPQUFPO2dCQUFDO2dCQUFPO2FBQUs7UUFDdEI7UUFDQW1MLE9BQU87WUFDTG5MLE9BQU87Z0JBQUM7Z0JBQU87YUFBSztZQUNwQkksVUFBVTtRQUNaO1FBQ0FnTCxXQUFXO1lBQ1RwTCxPQUFPO2dCQUFDO2dCQUFTO2dCQUFVO2FBQVM7UUFDdEM7UUFDQXFMLFNBQVM7WUFDUHJMLE9BQU87Z0JBQUM7Z0JBQVE7Z0JBQVM7YUFBUztRQUNwQztRQUNBc0wsY0FBYztZQUNadEwsT0FBTztnQkFBQztnQkFBVTtnQkFBVTthQUFVO1FBQ3hDO1FBQ0F1TCxVQUFVO1lBQ1J2TCxPQUFPO2dCQUFDO2dCQUFTO2dCQUFTO2FBQVE7UUFDcEM7UUFDQXdMLGFBQWE7WUFDWHhMLE9BQU87Z0JBQUM7Z0JBQVM7Z0JBQVU7Z0JBQVU7YUFBUztRQUNoRDtRQUNBdnFCLFlBQVk7WUFDVnVxQixPQUFPO2dCQUFDO2dCQUFVO2dCQUFvQjtnQkFBWTtnQkFBWTtnQkFBWTtnQkFBcUI7Z0JBQVE7Z0JBQWtCO2FBQWE7UUFDeEk7UUFDQXlMLFlBQVk7WUFDVnpMLE9BQU87Z0JBQUM7Z0JBQWM7YUFBbUI7WUFDekNJLFVBQVU7UUFDWjtRQUNBc0wsWUFBWTtZQUNWbnFDLE9BQU87UUFDVDtRQUNBb3FDLFdBQVc7WUFDVDNMLE9BQU87Z0JBQUM7Z0JBQVU7Z0JBQVU7YUFBVTtRQUN4QztRQUNBNEwsWUFBWTtZQUNWNUwsT0FBTztnQkFBQztnQkFBVTtnQkFBUTtnQkFBVTtnQkFBVztnQkFBTztnQkFBTztnQkFBTztnQkFBTztnQkFBTztnQkFBTztnQkFBTztnQkFBTztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBSztnQkFBSzthQUFJO1FBQ3JKO1FBQ0E2TCxnQkFBZ0I7WUFDZDdMLE9BQU87Z0JBQUM7Z0JBQVE7Z0JBQWE7Z0JBQVk7YUFBZTtRQUMxRDtRQUNBOEwsZUFBZTtZQUNiOUwsT0FBTztnQkFBQztnQkFBUTtnQkFBYTthQUFZO1FBQzNDO1FBQ0ErTCxVQUFVO1lBQ1IvTCxPQUFPO2dCQUFDO2dCQUFRO2dCQUFRO2FBQVc7UUFDckM7UUFDQWdNLGtCQUFrQjtZQUNoQmhNLE9BQU87Z0JBQUM7Z0JBQWM7YUFBVztRQUNuQztRQUNBaU0scUJBQXFCO1lBQ25Cak0sT0FBTztnQkFBQztnQkFBYTtnQkFBa0I7Z0JBQW1CO2FBQVM7UUFDckU7UUFDQWtNLFdBQVc7WUFDVGxNLE9BQU87Z0JBQUM7Z0JBQWE7Z0JBQWtCO2dCQUFtQjtnQkFBZ0I7Z0JBQWlCO2dCQUF3QjtnQkFBMEI7Z0JBQVU7Z0JBQVc7Z0JBQVk7Z0JBQWtCO2dCQUFVO2dCQUFZO2dCQUFrQjtnQkFBVztnQkFBaUI7Z0JBQWtCO2dCQUFtQjtnQkFBWTtnQkFBa0I7Z0JBQVc7Z0JBQWlCO2dCQUFPO2dCQUFhO2dCQUFRO2dCQUFXO2dCQUFpQjtnQkFBTztnQkFBWTtnQkFBa0I7YUFBVTtRQUM1YztRQUNBbU0sY0FBYztZQUNabk0sT0FBTztnQkFBQztnQkFBa0I7Z0JBQW1CO2FBQVU7UUFDekQ7UUFDQXI4RCxjQUFjO1lBQ1pqNUIsUUFBUTtZQUNSa1YsS0FBSztZQUNMbXZELE9BQU87WUFDUHE2QixlQUFlO1lBQ2ZwSixPQUFPO2dCQUFDO2FBQU87UUFDakI7UUFDQW9NLHVCQUF1QjtZQUNyQnBNLE9BQU87Z0JBQUM7Z0JBQVc7YUFBVTtRQUMvQjtRQUNBcU0sWUFBWTtZQUNWck0sT0FBTztnQkFBQztnQkFBTztnQkFBWTtnQkFBZ0I7Z0JBQW1CO2dCQUFrQjtnQkFBc0I7Z0JBQU87Z0JBQVU7Z0JBQVU7Z0JBQVc7Z0JBQVc7YUFBTztRQUNoSztRQUNBc00sV0FBVztZQUNUdE0sT0FBTztnQkFBQztnQkFBVTthQUFTO1FBQzdCO1FBQ0E3dkIsWUFBWTtZQUNWemxFLFFBQVE7WUFDUnFrRSxPQUFPO1lBQ1BxNkIsZUFBZTtZQUNmcEosT0FBTztnQkFBQzthQUFhO1FBQ3ZCO1FBQ0F1TSxTQUFTO1lBQ1B2TSxPQUFPO2dCQUFDO2dCQUFXO2FBQU87UUFDNUI7UUFDQXdNLFlBQVk7WUFDVnhNLE9BQU87Z0JBQUM7Z0JBQVU7YUFBVTtRQUM5QjtRQUNBeU0sZ0JBQWdCO1lBQ2R6TSxPQUFPO2dCQUFDO2dCQUFVO2dCQUFVO2dCQUFRO2FBQU07UUFDNUM7UUFDQTBNLGVBQWU7WUFDYjFNLE9BQU87Z0JBQUM7Z0JBQVE7YUFBUztRQUMzQjtRQUNBL3VCLFFBQVE7WUFDTit1QixPQUFPO2dCQUFDO2dCQUFPO2dCQUFVO2FBQVM7UUFDcEM7UUFDQWh2QixRQUFRO1lBQ05ndkIsT0FBTztnQkFBQztnQkFBUTtnQkFBVTthQUFRO1FBQ3BDO1FBQ0EyTSxlQUFlO1lBQ2IzTSxPQUFPO2dCQUFDO2dCQUFRO2dCQUFVO2dCQUFTO2FBQU87UUFDNUM7UUFDQXo0QixNQUFNO1lBQ0pwOUQsUUFBUTtRQUNWO1FBQ0F1ZixNQUFNO1lBQ0p3MEUsU0FBUztZQUNUMzhCLE9BQU83M0MsS0FBSztRQUNkO1FBQ0FrakYsWUFBWTtZQUNWMU8sU0FBUztZQUNUMzhCLE9BQU83M0MsS0FBSztRQUNkO1FBQ0EyQixTQUFTO1lBQ1A2eUUsU0FBUztZQUNUMzhCLE9BQU83M0MsS0FBSztRQUNkO1FBQ0FpNUUsU0FBUztZQUNQekUsU0FBUztZQUNUMzhCLE9BQU9vaEMsUUFBUTtRQUNqQjtRQUNBa0ssZUFBZTtZQUNiM08sU0FBUztZQUNUMzhCLE9BQU9vaEMsUUFBUTtRQUNqQjtRQUNBbUssWUFBWTtZQUNWNU8sU0FBUztZQUNUMzhCLE9BQU9vaEMsUUFBUTtRQUNqQjtRQUNBdjRGLElBQUk7WUFDRjh6RixTQUFTO1lBQ1Q5ekYsSUFBSTtRQUNOO1FBQ0EyaUcsS0FBSztZQUNIQyxTQUFTN0Q7WUFDVDhELHVCQUF1QjtRQUN6QjtRQUNBQyxNQUFNO1lBQ0pGLFNBQVM3RDtZQUNUOEQsdUJBQXVCO1lBQ3ZCN00sVUFBVTtRQUNaO1FBQ0ErTSxVQUFVO1lBQ1JBLFVBQVU7UUFDWjtRQUNBOWtFLE9BQU87WUFDTDM5QixRQUFRO1lBQ1Jxa0UsT0FBTztZQUNQcTZCLGVBQWU7UUFDakI7UUFDQWdFLGNBQWM7WUFDWjFpRyxRQUFRO1lBQ1Jxa0UsT0FBTztZQUNQcTZCLGVBQWU7WUFDZnBKLE9BQU87Z0JBQUM7Z0JBQVE7YUFBYTtRQUMvQjtRQUNBcU4sa0JBQWtCO1lBQ2hCM2lHLFFBQVE7WUFDUjAxRixVQUFVO1lBQ1ZrTixjQUFjO1lBQ2QxdEYsS0FBSyxDQUFDO1lBQ05GLEtBQUs7WUFDTDZwRixVQUFVO1FBQ1o7UUFDQWdFLGVBQWU7WUFDYnZOLE9BQU87Z0JBQUM7Z0JBQWdCO2dCQUFpQjthQUFZO1FBQ3ZEO1FBQ0F3TixjQUFjO1lBQ1o5aUcsUUFBUTtZQUNSMDFGLFVBQVU7WUFDVnJ4QixPQUFPO1lBQ1BxNkIsZUFBZTtZQUNmcEosT0FBTztnQkFBQztnQkFBa0I7Z0JBQW1CO2dCQUE0QjtnQkFBbUI7YUFBMkI7WUFDdkh5TixZQUFZO1lBQ1pDLFVBQVUsU0FBU0EsU0FBU0MsTUFBTSxFQUFFQyxRQUFRO2dCQUMxQyxPQUFRRCxPQUFPNW5HLE1BQU07b0JBQ25CLEtBQUs7d0JBQ0gsc0JBQXNCO3dCQUN0QixPQUFPNm5HLFFBQVEsQ0FBQyxFQUFFLEtBQUssU0FBU0EsUUFBUSxDQUFDLEVBQUUsS0FBSyxTQUFTQSxRQUFRLENBQUMsRUFBRSxLQUFLLFNBQVNBLFFBQVEsQ0FBQyxFQUFFLEtBQUs7b0JBQ3BHLEtBQUs7d0JBQ0gsZ0NBQWdDO3dCQUNoQyxPQUFPempHLE9BQU93akcsTUFBTSxDQUFDLEVBQUUsS0FBS0MsUUFBUSxDQUFDLEVBQUUsS0FBSyxTQUFTQSxRQUFRLENBQUMsRUFBRSxLQUFLO29CQUN2RTt3QkFDRSxPQUFPO2dCQUNYO1lBQ0Y7UUFDRjtRQUNBM3BCLFFBQVE7WUFDTitvQixTQUFTO2dCQUFDLDBCQUEwQnZpRyxXQUFXLGdCQUFnQkEsV0FBVztnQkFBYSxnQ0FBZ0NBLFdBQVcsZ0JBQWdCQSxXQUFXLGdCQUFnQkEsV0FBVyxnQkFBZ0JBLFdBQVc7YUFBWTtZQUMvTnUxRixPQUFPO2dCQUFDO2dCQUFVO2dCQUFRO2dCQUFXO2dCQUFZO2dCQUFlO2dCQUFnQjtnQkFBaUI7Z0JBQW9CO2dCQUFnQjtnQkFBaUI7Z0JBQW9CO2dCQUFpQjtnQkFBa0I7Z0JBQXFCO2dCQUFpQjtnQkFBa0I7Z0JBQXFCO2dCQUFpQjtnQkFBa0I7Z0JBQXFCO2dCQUFnQjtnQkFBaUI7Z0JBQW9CO2dCQUFnQjtnQkFBaUI7YUFBbUI7UUFDN2I7UUFDQTZOLG1CQUFtQjtZQUNqQjdOLE9BQU87Z0JBQUM7Z0JBQWE7Z0JBQVU7Z0JBQVc7Z0JBQVk7Z0JBQW1CO2dCQUFrQjtnQkFBZ0I7Z0JBQWU7Z0JBQW1CO2dCQUFrQjtnQkFBZ0IsY0FBYyxrQkFBa0I7YUFDOU07UUFDSDtRQUNBOE4saUJBQWlCO1lBQ2ZwakcsUUFBUTtZQUNSMDFGLFVBQVU7WUFDVnhnRixLQUFLO1lBQ0w4dEYsVUFBVSxTQUFTQSxTQUFTQyxNQUFNO2dCQUNoQyxJQUFJNW5HLFNBQVM0bkcsT0FBTzVuRyxNQUFNO2dCQUMxQixPQUFPQSxXQUFXLEtBQUtBLFdBQVcsS0FBS0EsV0FBVztZQUNwRDtRQUNGO0lBQ0Y7SUFDQSxJQUFJMHJDLE9BQU87UUFDVHM4RCxhQUFhLFNBQVNBLFlBQVlDLElBQUksRUFBRUMsSUFBSTtZQUMxQyxJQUFJLENBQUNELFFBQVEsUUFBUUMsUUFBUSxJQUFHLEtBQU1ELFNBQVNDLE1BQU07Z0JBQ25ELE9BQU8sTUFBTSx1Q0FBdUM7WUFDdEQ7WUFDQSxJQUFJRCxRQUFRLEtBQUtDLFFBQVEsR0FBRztnQkFDMUIsT0FBTztZQUNULE9BQU8sSUFBSUQsUUFBUSxLQUFLQyxRQUFRLEdBQUc7Z0JBQ2pDLE9BQU87WUFDVCxPQUFPO2dCQUNMLE9BQU87WUFDVDtRQUNGO1FBQ0FDLEtBQUssU0FBU0EsSUFBSUYsSUFBSSxFQUFFQyxJQUFJO1lBQzFCLE9BQU9ELFFBQVFDO1FBQ2pCO1FBQ0FFLGVBQWUsU0FBU0EsY0FBY0MsSUFBSSxFQUFFQyxJQUFJO1lBQzlDLElBQUlDLFNBQVMvaUcsWUFBWTZpRztZQUN6QixJQUFJRyxTQUFTaGpHLFlBQVk4aUc7WUFDekIsT0FBT0MsVUFBVSxDQUFDQyxVQUFVLENBQUNELFVBQVVDO1FBQ3pDO0lBQ0Y7SUFFQSxpQ0FBaUM7SUFDakMsRUFBRTtJQUNGLCtFQUErRTtJQUMvRSxxRUFBcUU7SUFFckUsSUFBSTluRyxJQUFJc2lHLFFBQVFuTCxLQUFLO0lBQ3JCLElBQUk0USxZQUFZO1FBQUM7WUFDZnBsRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRThnRSxJQUFJO1lBQ1owOUIsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztZQUN4Qm5KLGdCQUFnQnR6RCxLQUFLMDhELGFBQWE7UUFDcEM7UUFBRztZQUNEL2tHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFMm1HLFlBQVk7WUFDcEJuSSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVqRyxpQkFBaUI7WUFDekIvRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVqRyxpQkFBaUI7WUFDekIvRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO0tBQUU7SUFDRixJQUFJTyxjQUFjO1FBQUM7WUFDakJybEcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU4Z0UsSUFBSTtZQUNaMDlCLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFMm1HLFlBQVk7WUFDcEJuSSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVqRyxpQkFBaUI7WUFDekIvRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVqRyxpQkFBaUI7WUFDekIvRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtLQUFFO0lBQ0YsSUFBSVEsY0FBYztRQUFDO1lBQ2pCdGxHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFOGdFLElBQUk7WUFDWjA5QixnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTJtRyxZQUFZO1lBQ3BCbkksZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV1akcsaUJBQWlCO1lBQ3pCL0UsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV1akcsaUJBQWlCO1lBQ3pCL0UsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtZQUNacThFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7S0FBRTtJQUNGLElBQUl6TixrQkFBa0I7UUFBQztZQUNyQnIzRixNQUFNO1lBQ053UixNQUFNblUsRUFBRWlsRyxVQUFVO1lBQ2xCekcsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVrbEcsU0FBUztZQUNqQjFHLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWxHLFVBQVU7WUFDbEIzRyxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVxbEcsYUFBYTtZQUNyQjdHLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFc2xHLFFBQVE7WUFDaEI5RyxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVsRyxnQkFBZ0I7WUFDeEIvRyxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtZQUNacThFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFcWpHLGNBQWM7WUFDdEI3RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO0tBQUU7SUFDRixJQUFJck4sY0FBYztRQUFDO1lBQ2pCejNGLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFd3FFLE1BQU07WUFDZGcwQixnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVxRSxNQUFNO1lBQ2RpMEIsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU2aUcsYUFBYTtRQUN2QjtRQUFHO1lBQ0RsZ0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU2aUcsYUFBYTtRQUN2QjtRQUFHO1lBQ0RsZ0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtZQUNacThFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNmlHLGFBQWE7UUFDdkI7UUFBRztZQUNEbGdHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNEosS0FBSztRQUNmO1FBQUc7WUFDRGpILE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWlCLElBQUk7WUFDWnE4RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRStrRyxXQUFXO1lBQ25CdkcsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV3bEcsbUJBQW1CO1lBQzNCaEgsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVrbUcsYUFBYTtRQUN2QjtRQUFHO1lBQ0R2akcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVreUYsSUFBSTtZQUNac00sZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtLQUFFO0lBQ0YsSUFBSVMsV0FBVztRQUFDO1lBQ2R2bEcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVreUYsSUFBSTtZQUNab00sZ0JBQWdCdHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVreUYsSUFBSTtZQUNab00sZ0JBQWdCdHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV3a0csWUFBWTtZQUNwQmxHLGdCQUFnQnR6RCxLQUFLeThELEdBQUc7UUFDMUI7S0FBRTtJQUNGLElBQUkxQixhQUFhO1FBQUM7WUFDaEJwakcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU4bEcsT0FBTztZQUNmeEgsZ0JBQWdCdHpELEtBQUt5OEQsR0FBRztZQUN4QmpKLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7WUFDeEIvSSxnQ0FBZ0MxekQsS0FBS3k4RCxHQUFHO1lBQ3hDN0ksK0JBQStCLFNBQVNBLDhCQUE4QlosU0FBUyxFQUFFQyxPQUFPLEVBQUVyOUUsR0FBRztnQkFDM0YsSUFBSW85RSxjQUFjQyxTQUFTO29CQUN6QixPQUFPO2dCQUNUO2dCQUVBLGtGQUFrRjtnQkFDbEYsT0FBT3I5RSxJQUFJNG1ELE1BQU0sQ0FBQyxlQUFldG1FLEtBQUssS0FBSztZQUM3QztRQUNGO1FBQUc7WUFDRHlCLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFK2xHLFVBQVU7WUFDbEJ6SCxnQkFBZ0J0ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1lBQ3JCdkUsZ0JBQWdCdHpELEtBQUtzOEQsV0FBVztRQUNsQztRQUFHO1lBQ0Qza0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU2aUcsYUFBYTtRQUN2QjtRQUFHO1lBQ0RsZ0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtRQUNkO1FBQUc7WUFDRHhmLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFZ21HLGNBQWM7WUFDdEIxSCxnQkFBZ0J0ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWltRyxhQUFhO1lBQ3JCM0gsZ0JBQWdCdHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVpRSxNQUFNO1lBQ2RxNkYsZ0JBQWdCdHpELEtBQUt5OEQsR0FBRztRQUMxQjtLQUFFO0lBQ0YsSUFBSVUsVUFBVTtRQUFDO1lBQ2J4bEcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtZQUNacThFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNEosS0FBSztRQUNmO1FBQUc7WUFDRGpILE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNmlHLGFBQWE7WUFDckJyRSxnQkFBZ0J4ekQsS0FBS3M4RCxXQUFXO1FBQ2xDO1FBQUc7WUFDRDNrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTBsRyxZQUFZO1lBQ3BCbEgsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVrOUIsWUFBWTtRQUN0QjtLQUFFO0lBQ0YsSUFBSWtyRSxXQUFXO1FBQUM7WUFDZHpsRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU2aUcsYUFBYTtZQUNyQnJFLGdCQUFnQnh6RCxLQUFLczhELFdBQVc7UUFDbEM7UUFBRztZQUNEM2tHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFMGxHLFlBQVk7WUFDcEJsSCxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWs5QixZQUFZO1FBQ3RCO0tBQUU7SUFDRixJQUFJbXJFLGFBQWE7UUFBQztZQUNoQjFsRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTBtRyxRQUFRO1FBQ2xCO1FBQUc7WUFDRC9qRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWlhLElBQUk7UUFDZDtRQUFHO1lBQ0R0WCxNQUFNO1lBQ053UixNQUFNblUsRUFBRWlhLElBQUk7UUFDZDtRQUFHO1lBQ0R0WCxNQUFNO1lBQ053UixNQUFNblUsRUFBRXc5RSxNQUFNO1FBQ2hCO0tBQUU7SUFDRixJQUFJOHFCLHVCQUF1QixTQUFTQSxxQkFBcUIxbkYsR0FBRyxFQUFFbzRFLFVBQVU7UUFDdEUsSUFBSUEsV0FBVzkzRixLQUFLLEtBQUssU0FBUztZQUNoQyxPQUFPLENBQUMwZixJQUFJdTZELFNBQVMsSUFBSSw4RUFBOEU7UUFDekcsT0FBTztZQUNMLE9BQU82ZCxXQUFXdnhCLE9BQU87UUFDM0I7SUFDRjtJQUNBLElBQUltekIsV0FBVztRQUFDO1lBQ2RqNEYsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtakcsUUFBUTtZQUNoQjNFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7WUFDeEJwTyxjQUFjaVA7UUFDaEI7UUFBRztZQUNEM2xHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWpHLFFBQVE7WUFDaEIzRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1lBQ3hCcE8sY0FBY2lQO1FBQ2hCO1FBQUc7WUFDRDNsRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXlsRyxTQUFTO1lBQ2pCakgsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0bUcsZ0JBQWdCO1lBQ3hCcEksZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVrOUIsWUFBWTtRQUN0QjtRQUFHO1lBQ0R2NkIsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV5a0csSUFBSTtRQUNkO1FBQUc7WUFDRDloRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1FBQ3ZCO1FBQUc7WUFDRGxnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWdqRyxhQUFhO1FBQ3ZCO1FBQUc7WUFDRHJnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZKLE1BQU07UUFDaEI7UUFBRztZQUNEbEgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0aUcsV0FBVztRQUNyQjtRQUFHO1lBQ0RqZ0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVvbkcsaUJBQWlCO1FBQzNCO1FBQUc7WUFDRHprRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTJqRyxnQkFBZ0I7WUFDeEJuRixnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRStqRyxpQkFBaUI7WUFDekJ2RixnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXFuRyxlQUFlO1lBQ3ZCN0ksZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtLQUFFO0lBQ0YsSUFBSTVNLGFBQWE7UUFBQztZQUNoQmw0RixNQUFNO1lBQ053UixNQUFNblUsRUFBRTRKLEtBQUs7UUFDZjtRQUFHO1lBQ0RqSCxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1FBQ3ZCO1FBQUc7WUFDRGxnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUra0csV0FBVztRQUNyQjtRQUFHO1lBQ0RwaUcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0a0csT0FBTztRQUNqQjtRQUFHO1lBQ0RqaUcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU4a0csUUFBUTtRQUNsQjtRQUFHO1lBQ0RuaUcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVvakcsT0FBTztRQUNqQjtRQUFHO1lBQ0R6Z0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVpRSxNQUFNO1FBQ2hCO1FBQUc7WUFDRHRCLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNmtHLFlBQVk7UUFDdEI7S0FBRTtJQUNGLElBQUkvSixjQUFjO1FBQUM7WUFDakJuNEYsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU2aUcsYUFBYTtRQUN2QjtRQUFHO1lBQ0RsZ0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtZQUNacThFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFK2tHLFdBQVc7UUFDckI7UUFBRztZQUNEcGlHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWlCLElBQUk7WUFDWnE4RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO0tBQUU7SUFDRixJQUFJMU0sa0JBQWtCO1FBQUM7WUFDckJwNEYsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV5bUcsSUFBSTtRQUNkO1FBQUc7WUFDRDlqRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXFrRyxhQUFhO1FBQ3ZCO1FBQUc7WUFDRDFoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRStpRyxjQUFjO1FBQ3hCO1FBQUc7WUFDRHBnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVrRyxhQUFhO1FBQ3ZCO1FBQUc7WUFDRDVoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTBrRyxLQUFLO1FBQ2Y7UUFBRztZQUNEL2hHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFaWtHLEtBQUs7UUFDZjtRQUFHO1lBQ0R0aEcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVpa0csS0FBSztRQUNmO1FBQUc7WUFDRHRoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWtrRyxZQUFZO1FBQ3RCO1FBQUc7WUFDRHZoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWtrRyxZQUFZO1FBQ3RCO1FBQUc7WUFDRHZoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1rRyxRQUFRO1FBQ2xCO1FBQUc7WUFDRHhoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW9rRyxLQUFLO1FBQ2Y7UUFBRztZQUNEemhHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFc2tHLE1BQU07UUFDaEI7UUFBRztZQUNEM2hHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFZ2tHLElBQUk7UUFDZDtRQUFHO1lBQ0RyaEcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVna0csSUFBSTtRQUNkO1FBQUc7WUFDRHJoRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWlrRyxLQUFLO1FBQ2Y7UUFBRztZQUNEdGhHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFaWtHLEtBQUs7UUFDZjtLQUFFO0lBQ0YsSUFBSXJuQyxXQUFXO1FBQUM7WUFDZGo2RCxNQUFNO1lBQ053UixNQUFNblUsRUFBRXFqQixRQUFRO1lBQ2hCbTdFLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFMmxHLHFCQUFxQjtZQUM3Qm5ILGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWlCLElBQUk7WUFDWnE4RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTJqRyxnQkFBZ0I7WUFDeEJuRixnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTJqRyxnQkFBZ0I7WUFDeEJuRixnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUyakcsZ0JBQWdCO1lBQ3hCbkYsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUyakcsZ0JBQWdCO1lBQ3hCbkYsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtLQUFFO0lBQ0YsSUFBSWMsV0FBVztRQUFDO1lBQ2Q1bEcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUya0csU0FBUztRQUNuQjtRQUFHO1lBQ0RoaUcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUV5a0csSUFBSTtRQUNkO1FBQUc7WUFDRDloRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTRrRyxPQUFPO1FBQ2pCO1FBQUc7WUFDRGppRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1FBQ3ZCO1FBQUc7WUFDRGxnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW9qRyxPQUFPO1FBQ2pCO1FBQUc7WUFDRHpnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWlFLE1BQU07UUFDaEI7UUFBRztZQUNEdEIsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtRQUNkO1FBQUc7WUFDRHhmLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNEosS0FBSztRQUNmO1FBQUc7WUFDRGpILE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNkosTUFBTTtRQUNoQjtRQUFHO1lBQ0RsSCxNQUFNO1lBQ053UixNQUFNblUsRUFBRTRpRyxXQUFXO1FBQ3JCO1FBQUc7WUFDRGpnRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRWd2RSxVQUFVO1lBQ2xCd3ZCLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7WUFDeEI3SSwrQkFBK0IsU0FBU0EsOEJBQThCWixTQUFTLEVBQUVDLE9BQU87Z0JBQ3RGLElBQUlELGNBQWNDLFNBQVM7b0JBQ3pCLE9BQU87Z0JBQ1QsRUFBRSxpQkFBaUI7Z0JBRW5CLE9BQU9ELGNBQWMsWUFDckIscUJBQXFCO2dCQUNyQkMsWUFBWSxVQUFVLGdCQUFnQjtZQUN4QztRQUNGO1FBQUc7WUFDRHQ3RixNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1lBQ3JCckUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUrbUcsWUFBWTtZQUNwQnZJLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFK21HLFlBQVk7WUFDcEJ2SSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUwakcsa0JBQWtCO1lBQzFCbEYsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVvakcsT0FBTztZQUNmNUUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUUwakcsa0JBQWtCO1lBQzFCbEYsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVvakcsT0FBTztZQUNmNUUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVvakcsT0FBTztZQUNmNUUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVnbEcsVUFBVTtZQUNsQnhHLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFd2pHLDZCQUE2QjtZQUNyQ2hGLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWlCLElBQUk7WUFDWnE4RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTRqRyxhQUFhO1lBQ3JCcEYsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVpRSxNQUFNO1lBQ2R1NkYsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU4bUcsYUFBYTtZQUNyQnRJLGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFcWpHLGNBQWM7WUFDdEI3RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTRoQyxLQUFLO1lBQ2I0OEQsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtRQUFHO1lBQ0Q5a0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0aEMsS0FBSztZQUNiNDhELGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWlCLElBQUk7WUFDWnE4RSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRW1pQixJQUFJO1lBQ1pxOEUsZ0JBQWdCeHpELEtBQUt5OEQsR0FBRztRQUMxQjtLQUFFO0lBQ0YsSUFBSS8zQixRQUFRO1FBQUM7WUFDWC9zRSxNQUFNO1lBQ053UixNQUFNblUsRUFBRWt5RixJQUFJO1lBQ1pzTSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVqRyxpQkFBaUI7WUFDekIvRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRXVqRyxpQkFBaUI7WUFDekIvRSxnQkFBZ0J4ekQsS0FBS3k4RCxHQUFHO1FBQzFCO1FBQUc7WUFDRDlrRyxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1FBQ3ZCO0tBQUU7SUFDRixJQUFJbCtGLE9BQU87UUFBQztZQUNWaEMsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU2aUcsYUFBYTtRQUN2QjtRQUFHO1lBQ0RsZ0csTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0SixLQUFLO1FBQ2Y7UUFBRztZQUNEakgsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUVtaUIsSUFBSTtRQUNkO1FBQUc7WUFDRHhmLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNEosS0FBSztRQUNmO1FBQUc7WUFDRGpILE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNmlHLGFBQWE7UUFDdkI7UUFBRztZQUNEbGdHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFbWlCLElBQUk7UUFDZDtRQUFHO1lBQ0R4ZixNQUFNO1lBQ053UixNQUFNblUsRUFBRTRKLEtBQUs7UUFDZjtRQUFHO1lBQ0RqSCxNQUFNO1lBQ053UixNQUFNblUsRUFBRTZpRyxhQUFhO1FBQ3ZCO0tBQUU7SUFFRiw0QkFBNEI7SUFDNUIsSUFBSTdILE1BQU0sRUFBRTtJQUNac0gsUUFBUWtHLGNBQWMsR0FBRyxJQUFJLDBGQUEwRjtJQUN2SHhOLElBQUlsNUYsSUFBSSxDQUFDO1FBQ1BhLE1BQU07UUFDTndSLE1BQU1uVSxFQUFFMmpHLGdCQUFnQjtJQUMxQjtJQUNBM0ksSUFBSWw1RixJQUFJLENBQUM7UUFDUGEsTUFBTTtRQUNOd1IsTUFBTW5VLEVBQUUyakcsZ0JBQWdCO0lBQzFCO0lBQ0EzSSxJQUFJbDVGLElBQUksQ0FBQztRQUNQYSxNQUFNO1FBQ053UixNQUFNblUsRUFBRTRoQyxLQUFLO0lBQ2Y7SUFDQSxJQUFLLElBQUkvL0IsSUFBSSxHQUFHQSxLQUFLeWdHLFFBQVFrRyxjQUFjLEVBQUUzbUcsSUFBSztRQUNoRG01RixJQUFJbDVGLElBQUksQ0FBQztZQUNQYSxNQUFNLFNBQVNkLElBQUk7WUFDbkJzUyxNQUFNblUsRUFBRTRKLEtBQUs7UUFDZjtRQUNBb3hGLElBQUlsNUYsSUFBSSxDQUFDO1lBQ1BhLE1BQU0sU0FBU2QsSUFBSTtZQUNuQnNTLE1BQU1uVSxFQUFFNnRGLE9BQU87UUFDakI7UUFDQW1OLElBQUlsNUYsSUFBSSxDQUFDO1lBQ1BhLE1BQU0sU0FBU2QsSUFBSTtZQUNuQnNTLE1BQU1uVSxFQUFFNmlHLGFBQWE7UUFDdkI7SUFDRjtJQUVBLCtCQUErQjtJQUMvQixJQUFJNUgsU0FBUyxFQUFFO0lBQ2ZxSCxRQUFRbUcsaUJBQWlCLEdBQUcsSUFBSSw2RkFBNkY7SUFDN0h4TixPQUFPbjVGLElBQUksQ0FBQztRQUNWYSxNQUFNO1FBQ053UixNQUFNblUsRUFBRTJqRyxnQkFBZ0I7SUFDMUI7SUFDQTFJLE9BQU9uNUYsSUFBSSxDQUFDO1FBQ1ZhLE1BQU07UUFDTndSLE1BQU1uVSxFQUFFOGpHLG9CQUFvQjtJQUM5QjtJQUNBLElBQUssSUFBSXY3RSxLQUFLLEdBQUdBLE1BQU0rNUUsUUFBUW1HLGlCQUFpQixFQUFFbGdGLEtBQU07UUFDdEQweUUsT0FBT241RixJQUFJLENBQUM7WUFDVmEsTUFBTSxZQUFZNGxCLEtBQUs7WUFDdkJwVSxNQUFNblUsRUFBRTRKLEtBQUs7UUFDZjtRQUNBcXhGLE9BQU9uNUYsSUFBSSxDQUFDO1lBQ1ZhLE1BQU0sWUFBWTRsQixLQUFLO1lBQ3ZCcFUsTUFBTW5VLEVBQUU2dEYsT0FBTztRQUNqQjtRQUNBb04sT0FBT241RixJQUFJLENBQUM7WUFDVmEsTUFBTSxZQUFZNGxCLEtBQUs7WUFDdkJwVSxNQUFNblUsRUFBRTZpRyxhQUFhO1FBQ3ZCO0lBQ0Y7SUFFQSxjQUFjO0lBQ2QsSUFBSTZGLFlBQVksRUFBRTtJQUNsQixJQUFJQyxnQkFBZ0JyRyxRQUFRcUcsYUFBYSxHQUFHO1FBQUM7UUFBVTtRQUFjO1FBQVU7S0FBYTtJQUM1RjtRQUFDO1lBQ0NobUcsTUFBTTtZQUNOd1IsTUFBTW5VLEVBQUU0bEcsVUFBVTtZQUNsQnBILGdCQUFnQnh6RCxLQUFLeThELEdBQUc7UUFDMUI7UUFBRztZQUNEOWtHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNEosS0FBSztRQUNmO1FBQUc7WUFDRGpILE1BQU07WUFDTndSLE1BQU1uVSxFQUFFNmxHLFNBQVM7UUFDbkI7UUFBRztZQUNEbGpHLE1BQU07WUFDTndSLE1BQU1uVSxFQUFFMHBFLFVBQVU7UUFDcEI7S0FBRSxDQUFDbG5ELE9BQU8sQ0FBQyxTQUFVbS9CLElBQUk7UUFDdkJnbkQsY0FBY25tRixPQUFPLENBQUMsU0FBVTFiLE1BQU07WUFDcEMsSUFBSW5FLE9BQU9tRSxTQUFTLE1BQU02NkMsS0FBS2gvQyxJQUFJO1lBQ25DLElBQUl3UixPQUFPd3RDLEtBQUt4dEMsSUFBSSxFQUNsQnFxRixpQkFBaUI3OEMsS0FBSzY4QyxjQUFjO1lBQ3RDa0ssVUFBVTVtRyxJQUFJLENBQUM7Z0JBQ2JhLE1BQU1BO2dCQUNOd1IsTUFBTUE7Z0JBQ05xcUYsZ0JBQWdCQTtZQUNsQjtRQUNGO0lBQ0YsR0FBRyxDQUFDO0lBQ0osSUFBSS9nRCxRQUFRNmtELFFBQVExL0MsVUFBVSxHQUFHLEVBQUUsQ0FBQ3Y0QixNQUFNLENBQUM2OUUsVUFBVUcsWUFBWXRDLFlBQVlvQyxTQUFTQyxVQUFVMTRCLE9BQU8wcUIsYUFBYUosaUJBQWlCK04sV0FBV0MsYUFBYUMsYUFBYXJOLFVBQVVDLFlBQVlDLGFBQWFDLGlCQUFpQkMsS0FBS0MsUUFBUXIrQixVQUFVMnJDLFVBQVVHLFdBQVcvakc7SUFDMVEsSUFBSWlrRyxhQUFhdEcsUUFBUXVHLGNBQWMsR0FBRztRQUN4QyxxQkFBcUI7UUFDckJYLFVBQVVBO1FBQ1ZHLFlBQVlBO1FBQ1p0QyxZQUFZQTtRQUNab0MsU0FBU0E7UUFDVEMsVUFBVUE7UUFDVjE0QixPQUFPQTtRQUNQLFNBQVM7UUFDVDBxQixhQUFhQTtRQUNiSixpQkFBaUJBO1FBQ2pCK04sV0FBV0E7UUFDWEMsYUFBYUE7UUFDYkMsYUFBYUE7UUFDYixhQUFhO1FBQ2JyTixVQUFVQTtRQUNWQyxZQUFZQTtRQUNaQyxhQUFhQTtRQUNiQyxpQkFBaUJBO1FBQ2pCQyxLQUFLQTtRQUNMQyxRQUFRQTtRQUNScitCLFVBQVVBO1FBQ1YsYUFBYTtRQUNiMnJDLFVBQVVBO1FBQ1ZHLFdBQVdBO1FBQ1gvakcsTUFBTUE7SUFDUjtJQUNBLElBQUlta0csaUJBQWlCeEcsUUFBUXRLLGtCQUFrQixHQUFHLENBQUM7SUFDbkQsSUFBSStRLGdCQUFnQnpHLFFBQVFwSyxpQkFBaUIsR0FBRzczRixPQUFPNEgsSUFBSSxDQUFDMmdHO0lBQzVERyxjQUFjdm1GLE9BQU8sQ0FBQyxTQUFVaGlCLEdBQUc7UUFDakNzb0csY0FBYyxDQUFDdG9HLElBQUksR0FBR29vRyxVQUFVLENBQUNwb0csSUFBSSxDQUFDNlMsR0FBRyxDQUFDLFNBQVVzdUMsSUFBSTtZQUN0RCxPQUFPQSxLQUFLaC9DLElBQUk7UUFDbEI7UUFDQWltRyxVQUFVLENBQUNwb0csSUFBSSxDQUFDZ2lCLE9BQU8sQ0FBQyxTQUFVbS9CLElBQUk7WUFDcEMsT0FBT0EsS0FBS3czQyxRQUFRLEdBQUczNEY7UUFDekI7SUFDRjtJQUVBLGlCQUFpQjtJQUNqQixJQUFJd29HLFVBQVUxRyxRQUFRMEcsT0FBTyxHQUFHO1FBQUM7WUFDL0JybUcsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtRQUFHO1lBQ0QzOUYsTUFBTTtZQUNOMjlGLFVBQVU7UUFDWjtLQUFFO0lBRUYseUJBQXlCO0lBQ3pCZ0MsUUFBUTdDLGFBQWEsR0FBR2hpRCxNQUFNcHFDLEdBQUcsQ0FBQyxTQUFVeEssQ0FBQztRQUMzQyxPQUFPQSxFQUFFbEcsSUFBSTtJQUNmO0lBRUEsc0VBQXNFO0lBQ3RFLElBQUssSUFBSXdsQixNQUFNLEdBQUdBLE1BQU1zMUIsTUFBTW4rQyxNQUFNLEVBQUU2b0IsTUFBTztRQUMzQyxJQUFJdzVCLE9BQU9sRSxLQUFLLENBQUN0MUIsSUFBSTtRQUNyQnMxQixLQUFLLENBQUNrRSxLQUFLaC9DLElBQUksQ0FBQyxHQUFHZy9DLE1BQU0sdUJBQXVCO0lBQ2xEO0lBRUEsY0FBYztJQUNkLElBQUssSUFBSWpyQixNQUFNLEdBQUdBLE1BQU1zeUUsUUFBUTFwRyxNQUFNLEVBQUVvM0IsTUFBTztRQUM3QyxJQUFJMnBFLFFBQVEySSxPQUFPLENBQUN0eUUsSUFBSTtRQUN4QixJQUFJdXlFLGVBQWV4ckQsS0FBSyxDQUFDNGlELE1BQU1DLFFBQVEsQ0FBQztRQUN4QyxJQUFJNEksWUFBWTtZQUNkdm1HLE1BQU0wOUYsTUFBTTE5RixJQUFJO1lBQ2hCMDlGLE9BQU87WUFDUEMsVUFBVTJJO1FBQ1o7UUFFQSw2QkFBNkI7UUFDN0J4ckQsTUFBTTM3QyxJQUFJLENBQUNvbkc7UUFDWHpyRCxLQUFLLENBQUM0aUQsTUFBTTE5RixJQUFJLENBQUMsR0FBR3VtRyxXQUFXLHVCQUF1QjtJQUN4RDtBQUNGO0FBQ0E1RyxRQUFRcGpCLGtCQUFrQixHQUFHLFNBQVV2OEUsSUFBSTtJQUN6QyxPQUFPLElBQUksQ0FBQ3dtRyxvQkFBb0IsRUFBRSxDQUFDeG1HLEtBQUs7QUFDMUM7QUFDQTIvRixRQUFRNkcsb0JBQW9CLEdBQUc7SUFDN0IsSUFBSS9sRixLQUFLLElBQUksQ0FBQzNlLFFBQVE7SUFDdEIsSUFBSTJlLEdBQUdnbUYsaUJBQWlCLElBQUksTUFBTTtRQUNoQyxPQUFPaG1GLEdBQUdnbUYsaUJBQWlCO0lBQzdCO0lBQ0EsSUFBSUMsV0FBV3hoRyxPQUFPO1FBQ3BCLGFBQWE7UUFDYix1QkFBdUI7UUFDdkIseUJBQXlCO1FBQ3pCLDhCQUE4QjtRQUM5Qiw4QkFBOEI7UUFDOUIsbUJBQW1CO1FBQ25CLHFCQUFxQjtRQUNyQixrQkFBa0I7UUFDbEIsNEJBQTRCO1FBQzVCLDhCQUE4QjtRQUM5Qix5QkFBeUI7UUFDekIsVUFBVTtRQUNWLGVBQWU7UUFDZixlQUFlO1FBQ2YsZUFBZTtRQUNmLHNCQUFzQjtRQUN0QixlQUFlO1FBQ2YsU0FBUztRQUNULGlCQUFpQjtRQUNqQixzQkFBc0I7UUFDdEIsc0JBQXNCO1FBQ3RCLHdCQUF3QjtRQUN4QixnQkFBZ0I7UUFDaEIsbUJBQW1CO1FBQ25CLGtCQUFrQjtRQUNsQixhQUFhO1FBQ2Isc0JBQXNCO1FBQ3RCLGtCQUFrQjtRQUNsQix5QkFBeUI7UUFDekIsMkJBQTJCO1FBQzNCLHlCQUF5QjtRQUN6QiwyQkFBMkI7UUFDM0IsdUJBQXVCO1FBQ3ZCLHFCQUFxQjtRQUNyQixxQkFBcUI7UUFDckIscUJBQXFCO1FBQ3JCLGVBQWU7UUFDZixjQUFjO1FBQ2QsZUFBZTtRQUNmLGFBQWE7UUFDYix3QkFBd0I7UUFDeEIsaUJBQWlCO1FBQ2pCLHdCQUF3QjtRQUN4Qix3QkFBd0I7UUFDeEIsY0FBYztRQUNkLFdBQVc7UUFDWCxXQUFXO1FBQ1gsb0JBQW9CO1FBQ3BCLG1CQUFtQjtRQUNuQixXQUFXO1FBQ1gsU0FBUztRQUNULGlCQUFpQjtRQUNqQixpQkFBaUI7UUFDakIsZ0JBQWdCO1FBQ2hCLHNCQUFzQjtRQUN0Qix3QkFBd0I7UUFDeEIsd0JBQXdCO1FBQ3hCLGdCQUFnQjtRQUNoQixzQkFBc0I7UUFDdEIsd0JBQXdCO1FBQ3hCLHdCQUF3QjtRQUN4QixtQkFBbUI7UUFDbkIsaUJBQWlCO1FBQ2pCLG1CQUFtQjtRQUNuQixpQkFBaUI7UUFDakIseUJBQXlCO1FBQ3pCLG9CQUFvQjtRQUNwQixrQkFBa0I7UUFDbEIsb0JBQW9CO1FBQ3BCLGtCQUFrQjtRQUNsQiwwQkFBMEI7UUFDMUIsdUJBQXVCO1FBQ3ZCLHVCQUF1QjtRQUN2QixvQkFBb0I7UUFDcEIsOEJBQThCO1FBQzlCLHFCQUFxQjtRQUNyQixhQUFhO1FBQ2Isc0JBQXNCO1FBQ3RCLG9CQUFvQjtRQUNwQixtQkFBbUI7UUFDbkIsc0JBQXNCO1FBQ3RCLG9CQUFvQjtRQUNwQixnQ0FBZ0M7UUFDaEMsNEJBQTRCO1FBQzVCLGdDQUFnQztRQUNoQyw4QkFBOEI7UUFDOUIseUJBQXlCO1FBQ3pCLHlCQUF5QjtRQUN6Qix1QkFBdUI7UUFDdkIsdUJBQXVCO1FBQ3ZCLGdDQUFnQztRQUNoQyxpQ0FBaUM7UUFDakMscUJBQXFCO1FBQ3JCLGtCQUFrQjtRQUNsQixtQkFBbUI7UUFDbkIsb0JBQW9CO1FBQ3BCLHFCQUFxQjtRQUNyQixnQkFBZ0I7UUFDaEIsa0JBQWtCO1FBQ2xCLGdCQUFnQjtRQUNoQixnQkFBZ0I7UUFDaEIsdUJBQXVCO1lBQUM7WUFBRztTQUFFO1FBQzdCLHNCQUFzQjtRQUN0QixjQUFjO1FBQ2QsZUFBZTtRQUNmLG1CQUFtQjtRQUNuQixpQkFBaUI7UUFDakIsbUJBQW1CO1FBQ25CLGlCQUFpQjtRQUNqQixrQkFBa0I7UUFDbEIsaUJBQWlCO1FBQ2pCLFVBQVU7UUFDVixTQUFTO1FBQ1QsU0FBUztRQUNULHdCQUF3QjtRQUN4QixpQkFBaUI7UUFDakIsb0JBQW9CO1FBQ3BCLGdCQUFnQjtRQUNoQixpQ0FBaUM7UUFDakMsbUNBQW1DO1FBQ25DLHNDQUFzQztRQUN0QyxjQUFjO1FBQ2QsU0FBUztRQUNULGtCQUFrQjtRQUNsQixrQkFBa0I7UUFDbEIsaUJBQWlCO1FBQ2pCLGlCQUFpQjtRQUNqQixXQUFXO1FBQ1gsdUJBQXVCO1FBQ3ZCLFlBQVk7UUFDWiw4QkFBOEI7UUFDOUIsYUFBYTtRQUNiLHVCQUF1QjtRQUN2Qix3QkFBd0I7UUFDeEIsY0FBYztRQUNkLHVCQUF1QjtRQUN2QiwwQkFBMEI7SUFDNUIsR0FBRztRQUNELGNBQWM7UUFDZCxZQUFZO1FBQ1osWUFBWTtRQUNaLG1CQUFtQjtJQUNyQixHQUFHO1FBQUM7WUFDRmxGLE1BQU07WUFDTnpCLE9BQU87UUFDVDtRQUFHO1lBQ0R5QixNQUFNO1lBQ056QixPQUFPO1FBQ1Q7UUFBRztZQUNEeUIsTUFBTTtZQUNOekIsT0FBTztRQUNUO0tBQUUsQ0FBQ20rRCxNQUFNLENBQUMsU0FBVWw1QyxHQUFHLEVBQUV3N0IsSUFBSTtRQUMzQixJQUFLLElBQUk5L0MsSUFBSSxHQUFHQSxLQUFLeWdHLFFBQVFrRyxjQUFjLEVBQUUzbUcsSUFBSztZQUNoRCxJQUFJYyxPQUFPZy9DLEtBQUtoL0MsSUFBSSxDQUFDNkQsT0FBTyxDQUFDLFNBQVMzRTtZQUN0QyxJQUFJMmYsTUFBTW1nQyxLQUFLemdELEtBQUs7WUFDcEJpbEIsR0FBRyxDQUFDeGpCLEtBQUssR0FBRzZlO1FBQ2Q7UUFDQSxPQUFPMkU7SUFDVCxHQUFHLENBQUMsSUFBSTtRQUNOLGtCQUFrQjtRQUNsQixlQUFlO1FBQ2Ysb0JBQW9CO0lBQ3RCLEdBQUc7UUFBQztZQUNGeGpCLE1BQU07WUFDTnpCLE9BQU87UUFDVDtRQUFHO1lBQ0R5QixNQUFNO1lBQ056QixPQUFPO1FBQ1Q7UUFBRztZQUNEeUIsTUFBTTtZQUNOekIsT0FBTztRQUNUO0tBQUUsQ0FBQ20rRCxNQUFNLENBQUMsU0FBVWw1QyxHQUFHLEVBQUV3N0IsSUFBSTtRQUMzQixJQUFLLElBQUk5L0MsSUFBSSxHQUFHQSxLQUFLeWdHLFFBQVFtRyxpQkFBaUIsRUFBRTVtRyxJQUFLO1lBQ25ELElBQUljLE9BQU9nL0MsS0FBS2gvQyxJQUFJLENBQUM2RCxPQUFPLENBQUMsU0FBUzNFO1lBQ3RDLElBQUkyZixNQUFNbWdDLEtBQUt6Z0QsS0FBSztZQUNwQmlsQixHQUFHLENBQUN4akIsS0FBSyxHQUFHNmU7UUFDZDtRQUNBLE9BQU8yRTtJQUNULEdBQUcsQ0FBQyxJQUFJO1FBQ04sYUFBYTtRQUNiLGNBQWM7UUFDZCxjQUFjO1FBQ2QsYUFBYTtRQUNiLFlBQVk7UUFDWixnQkFBZ0I7UUFDaEIsc0JBQXNCO1FBQ3RCLHNCQUFzQjtRQUN0Qiw2QkFBNkI7UUFDN0IsZ0NBQWdDO1FBQ2hDLDJCQUEyQjtRQUMzQix5QkFBeUI7UUFDekIsbUJBQW1CO1FBQ25CLHFCQUFxQjtRQUNyQixpQkFBaUI7UUFDakIsZUFBZTtRQUNmLGFBQWE7UUFDYixlQUFlO1FBQ2YsMEJBQTBCO1FBQzFCLGtCQUFrQjtRQUNsQixrQkFBa0I7UUFDbEIsZUFBZTtRQUNmLG1CQUFtQjtRQUNuQixlQUFlO1FBQ2Ysa0JBQWtCO1FBQ2xCLGNBQWM7UUFDZCw2QkFBNkI7UUFDN0IsNkJBQTZCO1FBQzdCLG1CQUFtQjtRQUNuQixtQkFBbUI7UUFDbkIscUJBQXFCO1lBQUM7WUFBRztTQUFFO1FBQzNCLG9CQUFvQjtJQUN0QixHQUFHO1FBQUM7WUFDRnhqQixNQUFNO1lBQ056QixPQUFPO1FBQ1Q7UUFBRztZQUNEeUIsTUFBTTtZQUNOekIsT0FBTztRQUNUO1FBQUc7WUFDRHlCLE1BQU07WUFDTnpCLE9BQU87UUFDVDtRQUFHO1lBQ0R5QixNQUFNO1lBQ056QixPQUFPO1FBQ1Q7S0FBRSxDQUFDbStELE1BQU0sQ0FBQyxTQUFVbDVDLEdBQUcsRUFBRXc3QixJQUFJO1FBQzNCMmdELFFBQVFxRyxhQUFhLENBQUNubUYsT0FBTyxDQUFDLFNBQVUxYixNQUFNO1lBQzVDLElBQUluRSxPQUFPbUUsU0FBUyxNQUFNNjZDLEtBQUtoL0MsSUFBSTtZQUNuQyxJQUFJNmUsTUFBTW1nQyxLQUFLemdELEtBQUs7WUFDcEJpbEIsR0FBRyxDQUFDeGpCLEtBQUssR0FBRzZlO1FBQ2Q7UUFDQSxPQUFPMkU7SUFDVCxHQUFHLENBQUM7SUFDSixJQUFJbWpGLGNBQWMsQ0FBQztJQUNuQixJQUFLLElBQUl6bkcsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQytnRCxVQUFVLENBQUN0akQsTUFBTSxFQUFFdUMsSUFBSztRQUMvQyxJQUFJOC9DLE9BQU8sSUFBSSxDQUFDaUIsVUFBVSxDQUFDL2dELEVBQUU7UUFDN0IsSUFBSTgvQyxLQUFLMitDLFFBQVEsRUFBRTtZQUNqQjtRQUNGO1FBQ0EsSUFBSTM5RixPQUFPZy9DLEtBQUtoL0MsSUFBSTtRQUNwQixJQUFJNmUsTUFBTTZuRixRQUFRLENBQUMxbUcsS0FBSztRQUN4QixJQUFJcTJGLGFBQWEsSUFBSSxDQUFDNzZCLEtBQUssQ0FBQ3g3RCxNQUFNNmU7UUFDbEM4bkYsV0FBVyxDQUFDM21HLEtBQUssR0FBR3EyRjtJQUN0QjtJQUNBNTFFLEdBQUdnbUYsaUJBQWlCLEdBQUdFO0lBQ3ZCLE9BQU9sbUYsR0FBR2dtRixpQkFBaUI7QUFDN0I7QUFDQTlHLFFBQVFpSCxvQkFBb0IsR0FBRztJQUM3QixJQUFJLENBQUMxekMsUUFBUSxDQUFDLFdBQVcxdkMsR0FBRyxDQUFDO1FBQzNCLFNBQVM7UUFDVCxXQUFXO1FBQ1gsb0JBQW9CO1FBQ3BCLGdCQUFnQjtRQUNoQixnQkFBZ0I7SUFDbEIsR0FBRzB2QyxRQUFRLENBQUMsUUFBUTF2QyxHQUFHLENBQUM7UUFDdEIsU0FBUztJQUNYLEdBQUcwdkMsUUFBUSxDQUFDLFNBQVMxdkMsR0FBRyxDQUFDO1FBQ3ZCLGVBQWU7SUFDakIsR0FBRzB2QyxRQUFRLENBQUMsaUJBQWlCMXZDLEdBQUcsQ0FBQztRQUMvQixlQUFlO1FBQ2YsbUJBQW1CO1FBQ25CLG1CQUFtQjtJQUNyQixHQUFHMHZDLFFBQVEsQ0FBQyxhQUFhMXZDLEdBQUcsQ0FBQztRQUMzQixvQkFBb0I7UUFDcEIsY0FBYztRQUNkLHNCQUFzQjtRQUN0QixzQkFBc0I7UUFDdEIsMEJBQTBCO1FBQzFCLDBCQUEwQjtJQUM1QixHQUFHMHZDLFFBQVEsQ0FBQyxvQkFBb0IxdkMsR0FBRyxDQUFDO1FBQ2xDLG9CQUFvQjtRQUNwQixnQkFBZ0I7SUFDbEIsR0FBRzB2QyxRQUFRLENBQUMsV0FBVzF2QyxHQUFHLENBQUM7UUFDekIsaUJBQWlCO1FBQ2pCLG1CQUFtQjtRQUNuQixtQkFBbUI7SUFDckI7SUFDQSxJQUFJLENBQUNrN0UsYUFBYSxHQUFHLElBQUksQ0FBQy9oRyxNQUFNO0FBQ2xDO0FBRUEsSUFBSWtxRyxVQUFVLENBQUM7QUFFZix1Q0FBdUM7QUFDdkNBLFFBQVFyckMsS0FBSyxHQUFHLFNBQVV4N0QsSUFBSSxFQUFFekIsS0FBSyxFQUFFczZGLFlBQVksRUFBRWlPLFVBQVU7SUFDN0QsSUFBSXhqRyxRQUFPLElBQUk7SUFFZixvR0FBb0c7SUFDcEcsSUFBSXhDLEtBQUt2QyxRQUFRO1FBQ2YsT0FBTytFLE1BQUt5akcsYUFBYSxDQUFDL21HLE1BQU16QixPQUFPczZGLGNBQWNpTztJQUN2RDtJQUNBLElBQUlFLFVBQVVGLGVBQWUsYUFBYUEsZUFBZSxRQUFRQSxlQUFlLFNBQVNBLGNBQWMsT0FBTyxhQUFhQTtJQUMzSCxJQUFJRyxZQUFZcE8sZUFBZSxNQUFNO0lBQ3JDLElBQUlxTyxXQUFXLEtBQUszb0c7SUFDcEIsSUFBSTRvRyxVQUFVN3NGLFlBQVl0YSxNQUFNa25HLFVBQVVELFdBQVdEO0lBQ3JELElBQUlJLFlBQVk5akcsTUFBSzhqRyxTQUFTLEdBQUc5akcsTUFBSzhqRyxTQUFTLElBQUksRUFBRTtJQUNyRCxJQUFJN2pHO0lBQ0osSUFBSSxDQUFFQSxDQUFBQSxNQUFNNmpHLFNBQVMsQ0FBQ0QsUUFBUSxHQUFHO1FBQy9CNWpHLE1BQU02akcsU0FBUyxDQUFDRCxRQUFRLEdBQUc3akcsTUFBS3lqRyxhQUFhLENBQUMvbUcsTUFBTXpCLE9BQU9zNkYsY0FBY2lPO0lBQzNFO0lBRUEsZ0dBQWdHO0lBQ2hHLDBEQUEwRDtJQUMxRCxJQUFJak8sZ0JBQWdCaU8sZUFBZSxXQUFXO1FBQzVDLGdFQUFnRTtRQUNoRXZqRyxNQUFNNFosS0FBSzVaO1FBQ1gsSUFBSUEsS0FBSztZQUNQQSxJQUFJaEYsS0FBSyxHQUFHNGUsS0FBSzVaLElBQUloRixLQUFLLEdBQUcsNENBQTRDO1FBQzNFO0lBQ0Y7SUFDQSxPQUFPZ0Y7QUFDVDtBQUNBc2pHLFFBQVFFLGFBQWEsR0FBRyxTQUFVL21HLElBQUksRUFBRXpCLEtBQUssRUFBRXM2RixZQUFZLEVBQUVpTyxVQUFVO0lBQ3JFLElBQUk5bkQsT0FBTyxJQUFJLENBQUNxb0QsU0FBUyxDQUFDcm5HLE1BQU16QixPQUFPczZGLGNBQWNpTztJQUNyRCxJQUFJLENBQUM5bkQsUUFBUXpnRCxTQUFTLE1BQU07UUFDMUIyZCxLQUFLLHVCQUF1QndMLE1BQU0sQ0FBQzFuQixNQUFNLE1BQU0wbkIsTUFBTSxDQUFDbnBCLE9BQU87SUFDL0Q7SUFDQSxJQUFJeWdELFFBQVNBLENBQUFBLEtBQUtoL0MsSUFBSSxLQUFLLFdBQVdnL0MsS0FBS2gvQyxJQUFJLEtBQUssUUFBTyxLQUFNekIsVUFBVSxTQUFTO1FBQ2xGMmQsS0FBSyxtREFBbUQ4aUMsS0FBS2gvQyxJQUFJLEdBQUc7SUFDdEU7SUFDQSxPQUFPZy9DO0FBQ1Q7QUFFQSw2RUFBNkU7QUFDN0UsV0FBVztBQUNYLG9DQUFvQztBQUNwQywyREFBMkQ7QUFDM0QsOEVBQThFO0FBQzlFLHdEQUF3RDtBQUN4RDZuRCxRQUFRUSxTQUFTLEdBQUcsU0FBVXJuRyxJQUFJLEVBQUV6QixLQUFLLEVBQUVzNkYsWUFBWSxFQUFFaU8sVUFBVTtJQUNqRSxJQUFJeGpHLFFBQU8sSUFBSTtJQUNmdEQsT0FBTzJELFdBQVczRCxPQUFPLHdGQUF3RjtJQUVqSCxJQUFJbzhFLFdBQVc5NEUsTUFBSzI4QyxVQUFVLENBQUNqZ0QsS0FBSztJQUNwQyxJQUFJc25HLGNBQWMvb0c7SUFDbEIsSUFBSWkyRixRQUFRbHhGLE1BQUtreEYsS0FBSztJQUN0QixJQUFJLENBQUNwWSxVQUFVO1FBQ2IsT0FBTztJQUNULEVBQUUsMENBQTBDO0lBQzVDLElBQUk3OUUsVUFBVW1CLFdBQVc7UUFDdkIsT0FBTztJQUNULEVBQUUseUJBQXlCO0lBRTNCLCtCQUErQjtJQUMvQixJQUFJMDhFLFNBQVNzaEIsS0FBSyxFQUFFO1FBQ2xCdGhCLFdBQVdBLFNBQVN1aEIsUUFBUTtRQUM1QjM5RixPQUFPbzhFLFNBQVNwOEUsSUFBSTtJQUN0QjtJQUNBLElBQUlnNUQsZ0JBQWdCajRELE9BQU94QztJQUMzQixJQUFJeTZELGVBQWU7UUFDakIsd0NBQXdDO1FBQ3hDejZELFFBQVFBLE1BQU1ncEcsSUFBSTtJQUNwQjtJQUNBLElBQUkvMUYsT0FBTzRxRSxTQUFTNXFFLElBQUk7SUFDeEIsSUFBSSxDQUFDQSxNQUFNO1FBQ1QsT0FBTztJQUNULEVBQUUsbUJBQW1CO0lBRXJCLHNGQUFzRjtJQUN0RixJQUFJcW5GLGdCQUFpQnQ2RixDQUFBQSxVQUFVLE1BQU1BLFVBQVUsSUFBRyxHQUFJO1FBQ3BELE9BQU87WUFDTHlCLE1BQU1BO1lBQ056QixPQUFPQTtZQUNQZ2xCLFFBQVE7WUFDUjgxRSxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxnREFBZ0Q7SUFDaEQsSUFBSXY0RixLQUFLdkMsUUFBUTtRQUNmLE9BQU87WUFDTHlCLE1BQU1BO1lBQ056QixPQUFPQTtZQUNQb3BFLFVBQVU7WUFDVmt0QixRQUFRTCxNQUFNeHpGLEVBQUU7WUFDaEJ1aUIsUUFBUXMxRTtRQUNWO0lBQ0Y7SUFFQSwyQkFBMkI7SUFDM0IsSUFBSXY0RSxNQUFNaTVFO0lBQ1YsSUFBSSxDQUFDdmdDLGlCQUFpQjh0QyxjQUFjdm9HLE1BQU01QixNQUFNLEdBQUcsS0FBSzRCLEtBQUssQ0FBQyxFQUFFLEtBQUs7U0FBWSxJQUFJQSxNQUFNNUIsTUFBTSxJQUFJLEtBQUs0QixLQUFLLENBQUMsRUFBRSxLQUFLLE9BQVEraEIsQ0FBQUEsT0FBTyxJQUFJamEsT0FBT211RixNQUFNbDBFLElBQUksQ0FBQzYzQyxLQUFLLEVBQUU3eEQsSUFBSSxDQUFDL0gsTUFBSyxHQUFJO1FBQy9LLElBQUlzNkYsY0FBYztZQUNoQixPQUFPO1FBQ1QsRUFBRSxnQ0FBZ0M7UUFFbEMsSUFBSWhFLFNBQVNMLE1BQU1sMEUsSUFBSTtRQUN2QixPQUFPO1lBQ0x0Z0IsTUFBTUE7WUFDTnpCLE9BQU8raEI7WUFDUHFuRCxVQUFVLEtBQUtwcEU7WUFDZnMyRixRQUFRQTtZQUNSemtDLE9BQU85dkMsSUFBSSxDQUFDLEVBQUU7WUFDZGlELFFBQVFzMUU7UUFDVjtJQUNGLE9BQU8sSUFBSXQ2RixNQUFNNUIsTUFBTSxJQUFJLE1BQU00QixLQUFLLENBQUMsRUFBRSxLQUFLLE9BQVFnN0YsQ0FBQUEsVUFBVSxJQUFJbHpGLE9BQU9tdUYsTUFBTStFLE9BQU8sQ0FBQ3BoQyxLQUFLLEVBQUU3eEQsSUFBSSxDQUFDL0gsTUFBSyxHQUFJO1FBQzVHLElBQUlzNkYsY0FBYztZQUNoQixPQUFPO1FBQ1QsRUFBRSxnQ0FBZ0M7UUFDbEMsSUFBSXJuRixLQUFLd2xGLFFBQVEsRUFBRTtZQUNqQixPQUFPO1FBQ1QsRUFBRSwyQkFBMkI7UUFFN0IsSUFBSXdRLFVBQVVoVCxNQUFNK0UsT0FBTztRQUUzQixzREFBc0Q7UUFDdEQsSUFBSSxDQUFFL25GLENBQUFBLEtBQUt2SyxLQUFLLElBQUl1SyxLQUFLbFEsTUFBTSxHQUFHO1lBQ2hDLE9BQU87UUFDVDtRQUNBLElBQUlzNEYsV0FBVyxJQUFJLENBQUNwK0IsS0FBSyxDQUFDeDdELE1BQU11NUYsT0FBTyxDQUFDLEVBQUUsR0FBRyxvQkFBb0I7UUFDakUsSUFBSSxDQUFDSyxZQUFZQSxTQUFTL0UsTUFBTSxFQUFFO1lBQ2hDLE9BQU87UUFDVCxFQUFFLDZCQUE2QjtRQUUvQixJQUFJaUYsV0FBVyxJQUFJLENBQUN0K0IsS0FBSyxDQUFDeDdELE1BQU11NUYsT0FBTyxDQUFDLEVBQUUsR0FBRyxvQkFBb0I7UUFDakUsSUFBSSxDQUFDTyxZQUFZQSxTQUFTakYsTUFBTSxFQUFFO1lBQ2hDLE9BQU87UUFDVCxFQUFFLDZCQUE2QjtRQUUvQiw4Q0FBOEM7UUFDOUMsSUFBSStFLFNBQVM5MEIsT0FBTyxLQUFLZzFCLFNBQVNoMUIsT0FBTyxJQUFJODBCLFNBQVNqeUIsUUFBUSxLQUFLbXlCLFNBQVNueUIsUUFBUSxFQUFFO1lBQ3BGenJELEtBQUssTUFBTWxjLE9BQU8sT0FBT3pCLFFBQVEsOEVBQThFeUIsT0FBTyxPQUFPNDVGLFNBQVNqeUIsUUFBUSxHQUFHO1lBQ2pKLE9BQU8sSUFBSSxDQUFDbk0sS0FBSyxDQUFDeDdELE1BQU00NUYsU0FBU2p5QixRQUFRLEdBQUcsOENBQThDO1FBQzVGLE9BQU8sSUFBSW4yRCxLQUFLdkssS0FBSyxFQUFFO1lBQ3JCLElBQUlzbkMsS0FBS3FyRCxTQUFTcjdGLEtBQUs7WUFDdkIsSUFBSWl3QyxLQUFLc3JELFNBQVN2N0YsS0FBSztZQUN2QixJQUFJOG1CLE9BQU9rcEIsRUFBRSxDQUFDLEVBQUUsS0FBS0MsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNO2dCQUM5QkQsRUFBRSxDQUFDLEVBQUUsS0FBS0MsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRO2dCQUN4QkQsRUFBRSxDQUFDLEVBQUUsS0FBS0MsRUFBRSxDQUFDLEVBQUUsQ0FBQyxPQUFPO2dCQUUxQixpQkFBaUI7WUFDakJELENBQUFBLEVBQUUsQ0FBQyxFQUFFLEtBQUtDLEVBQUUsQ0FBQyxFQUFFLENBQUMsc0JBQXNCO2dCQUNuQyxDQUFDRCxFQUFFLENBQUMsRUFBRSxJQUFJLFFBQVFBLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSw2QkFBNkI7WUFBL0IsS0FDekJDLENBQUFBLEVBQUUsQ0FBQyxFQUFFLElBQUksUUFBUUEsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFHLDZCQUE2QjtZQUFoQyxDQUFDO1lBRWxDLElBQUlucEIsTUFBTTtnQkFDUixPQUFPO1lBQ1QsRUFBRSxzQ0FBc0M7UUFDMUM7UUFDQSxPQUFPO1lBQ0xybEIsTUFBTUE7WUFDTnpCLE9BQU9nN0Y7WUFDUDV4QixVQUFVLEtBQUtwcEU7WUFDZnMyRixRQUFRMlM7WUFDUnAzQyxPQUFPbXBDLE9BQU8sQ0FBQyxFQUFFO1lBQ2pCRyxVQUFVbnpGLFdBQVdnekYsT0FBTyxDQUFDLEVBQUU7WUFDL0Isd0JBQXdCO1lBQ3hCRSxVQUFVbHpGLFdBQVdnekYsT0FBTyxDQUFDLEVBQUU7WUFDL0JLLFVBQVVBLFNBQVNyN0YsS0FBSztZQUN4QnU3RixVQUFVQSxTQUFTdjdGLEtBQUs7WUFDeEJnbEIsUUFBUXMxRTtRQUNWO0lBQ0Y7SUFDQSxJQUFJcm5GLEtBQUt3bEYsUUFBUSxJQUFJOFAsZUFBZSxZQUFZO1FBQzlDLElBQUlucUQ7UUFDSixJQUFJcWMsZUFBZTtZQUNqQnJjLE9BQU9wK0MsTUFBTTZrQixLQUFLLENBQUM7UUFDckIsT0FBTyxJQUFJbmlCLE1BQU0xQyxRQUFRO1lBQ3ZCbytDLE9BQU9wK0M7UUFDVCxPQUFPO1lBQ0xvK0MsT0FBTztnQkFBQ3ArQzthQUFNO1FBQ2hCO1FBQ0EsSUFBSWlULEtBQUsweUYsWUFBWSxJQUFJdm5ELEtBQUtoZ0QsTUFBTSxHQUFHLE1BQU0sR0FBRztZQUM5QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJNG5HLFNBQVMsRUFBRTtRQUNmLElBQUlDLFdBQVcsRUFBRTtRQUNqQixJQUFJaUQsV0FBVyxFQUFFO1FBQ2pCLElBQUl0UixTQUFTO1FBQ2IsSUFBSXVSLFVBQVU7UUFDZCxJQUFLLElBQUl4b0csSUFBSSxHQUFHQSxJQUFJeTlDLEtBQUtoZ0QsTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJZ0gsSUFBSTVDLE1BQUtrNEQsS0FBSyxDQUFDeDdELE1BQU0yOEMsSUFBSSxDQUFDejlDLEVBQUUsRUFBRTI1RixjQUFjO1lBQ2hENk8sVUFBVUEsV0FBVzNtRyxPQUFPbUYsRUFBRTNILEtBQUs7WUFDbkNnbUcsT0FBT3BsRyxJQUFJLENBQUMrRyxFQUFFM0gsS0FBSztZQUNuQmtwRyxTQUFTdG9HLElBQUksQ0FBQytHLEVBQUU0K0QsT0FBTyxJQUFJLE9BQU81K0QsRUFBRTQrRCxPQUFPLEdBQUc1K0QsRUFBRTNILEtBQUs7WUFDckRpbUcsU0FBU3JsRyxJQUFJLENBQUMrRyxFQUFFeS9ELEtBQUs7WUFDckJ3d0IsVUFBVSxDQUFDajNGLElBQUksSUFBSSxNQUFNLEVBQUMsSUFBS2dILEVBQUV5aEUsUUFBUTtRQUMzQztRQUNBLElBQUluMkQsS0FBSzh5RixRQUFRLElBQUksQ0FBQzl5RixLQUFLOHlGLFFBQVEsQ0FBQ0MsUUFBUUMsV0FBVztZQUNyRCxPQUFPO1FBQ1Q7UUFDQSxJQUFJaHpGLEtBQUs2eUYsVUFBVSxJQUFJcUQsU0FBUztZQUM5QixJQUFJbkQsT0FBTzVuRyxNQUFNLEtBQUssS0FBS29FLE9BQU93akcsTUFBTSxDQUFDLEVBQUUsR0FBRztnQkFDNUMsT0FBTztvQkFDTHZrRyxNQUFNQTtvQkFDTnpCLE9BQU9nbUcsTUFBTSxDQUFDLEVBQUU7b0JBQ2hCNThCLFVBQVU0OEIsTUFBTSxDQUFDLEVBQUU7b0JBQ25CaGhGLFFBQVFzMUU7Z0JBQ1Y7WUFDRixPQUFPO2dCQUNMLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztZQUNMNzRGLE1BQU1BO1lBQ056QixPQUFPZ21HO1lBQ1B6L0IsU0FBUzJpQztZQUNUOS9CLFVBQVV3dUI7WUFDVjV5RSxRQUFRczFFO1lBQ1JsekIsT0FBTzYrQjtRQUNUO0lBQ0Y7SUFFQSxpQ0FBaUM7SUFDakMsSUFBSW1ELGFBQWEsU0FBU0E7UUFDeEIsSUFBSyxJQUFJL2hGLEtBQUssR0FBR0EsS0FBS3BVLEtBQUtvbEYsS0FBSyxDQUFDajZGLE1BQU0sRUFBRWlwQixLQUFNO1lBQzdDLElBQUlnaUYsS0FBS3AyRixLQUFLb2xGLEtBQUssQ0FBQ2h4RSxHQUFHO1lBQ3ZCLElBQUlnaUYsT0FBT3JwRyxPQUFPO2dCQUNoQixPQUFPO29CQUNMeUIsTUFBTUE7b0JBQ056QixPQUFPQTtvQkFDUG9wRSxVQUFVLEtBQUtwcEU7b0JBQ2ZnbEIsUUFBUXMxRTtnQkFDVjtZQUNGO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxtREFBbUQ7SUFDbkQsSUFBSXJuRixLQUFLbFEsTUFBTSxFQUFFO1FBQ2YsSUFBSXFrRTtRQUNKLElBQUlxNkIsZ0JBQWdCLE1BQU0sZ0JBQWdCO1FBRTFDLElBQUl4dUYsS0FBS20wRCxLQUFLLEVBQUU7WUFDZCw2QkFBNkI7WUFDN0JBLFFBQVFuMEQsS0FBS20wRCxLQUFLO1FBQ3BCO1FBQ0EsSUFBSW4wRCxLQUFLd3VGLGFBQWEsRUFBRTtZQUN0QkEsZ0JBQWdCeHVGLEtBQUt3dUYsYUFBYTtRQUNwQztRQUNBLElBQUksQ0FBQ3h1RixLQUFLMnVGLFFBQVEsRUFBRTtZQUNsQixJQUFJbm5DLGVBQWU7Z0JBQ2pCLElBQUk2dUMsYUFBYSxVQUFXcjJGLENBQUFBLEtBQUtzdkYsWUFBWSxHQUFHLFNBQVMsRUFBQztnQkFDMUQsSUFBSW43QixPQUFPO29CQUNUa2lDLGFBQWFsaUM7Z0JBQ2YsRUFBRSxzQ0FBc0M7Z0JBQ3hDLElBQUl2akUsUUFBUTdELE1BQU02RCxLQUFLLENBQUMsT0FBT2QsU0FBUyxPQUFPdW1HLGFBQWEsT0FBTztnQkFDbkUsSUFBSXpsRyxPQUFPO29CQUNUN0QsUUFBUTZELEtBQUssQ0FBQyxFQUFFO29CQUNoQnVqRSxRQUFRdmpFLEtBQUssQ0FBQyxFQUFFLElBQUk0OUY7Z0JBQ3RCO1lBQ0YsT0FBTyxJQUFJLENBQUNyNkIsU0FBU24wRCxLQUFLd3VGLGFBQWEsRUFBRTtnQkFDdkNyNkIsUUFBUXE2QixlQUFlLCtCQUErQjtZQUN4RDtRQUNGO1FBQ0F6aEcsUUFBUWdJLFdBQVdoSTtRQUVuQixtRUFBbUU7UUFDbkUsSUFBSWdELE1BQU1oRCxVQUFVaVQsS0FBS29sRixLQUFLLEtBQUtsM0YsV0FBVztZQUM1QyxPQUFPO1FBQ1Q7UUFFQSw4RUFBOEU7UUFDOUUsNkJBQTZCO1FBQzdCLElBQUk2QixNQUFNaEQsVUFBVWlULEtBQUtvbEYsS0FBSyxLQUFLbDNGLFdBQVc7WUFDNUNuQixRQUFRK29HO1lBQ1IsT0FBT0s7UUFDVDtRQUVBLG9DQUFvQztRQUNwQyxJQUFJbjJGLEtBQUtoUSxPQUFPLElBQUksQ0FBQ0EsUUFBUWpELFFBQVE7WUFDbkMsT0FBTztRQUNUO1FBRUEsOEJBQThCO1FBQzlCLElBQUlpVCxLQUFLZ0YsR0FBRyxLQUFLOVcsYUFBY25CLENBQUFBLFFBQVFpVCxLQUFLZ0YsR0FBRyxJQUFJaEYsS0FBS212RixTQUFTLElBQUlwaUcsVUFBVWlULEtBQUtnRixHQUFHLEtBQUtoRixLQUFLOEUsR0FBRyxLQUFLNVcsYUFBY25CLENBQUFBLFFBQVFpVCxLQUFLOEUsR0FBRyxJQUFJOUUsS0FBS3MyRixTQUFTLElBQUl2cEcsVUFBVWlULEtBQUs4RSxHQUFHLEdBQUc7WUFDaEwsT0FBTztRQUNUO1FBQ0EsSUFBSS9TLE1BQU07WUFDUnZELE1BQU1BO1lBQ056QixPQUFPQTtZQUNQb3BFLFVBQVUsS0FBS3BwRSxRQUFTb25FLENBQUFBLFFBQVFBLFFBQVEsRUFBQztZQUN6Q0EsT0FBT0E7WUFDUHBpRCxRQUFRczFFO1FBQ1Y7UUFFQSw0QkFBNEI7UUFDNUIsSUFBSXJuRixLQUFLMnVGLFFBQVEsSUFBSXg2QixVQUFVLFFBQVFBLFVBQVUsTUFBTTtZQUNyRHBpRSxJQUFJdWhFLE9BQU8sR0FBR3ZtRTtRQUNoQixPQUFPO1lBQ0xnRixJQUFJdWhFLE9BQU8sR0FBR2EsVUFBVSxRQUFRLENBQUNBLFFBQVFwbkUsUUFBUSxJQUFJLENBQUN5K0YsaUJBQWlCLEtBQUt6K0Y7UUFDOUU7UUFFQSx3QkFBd0I7UUFDeEIsSUFBSW9uRSxVQUFVLFFBQVFBLFVBQVUsS0FBSztZQUNuQ3BpRSxJQUFJdWhFLE9BQU8sR0FBR2EsVUFBVSxPQUFPcG5FLFFBQVEsT0FBT0E7UUFDaEQ7UUFFQSx5QkFBeUI7UUFDekIsSUFBSW9uRSxVQUFVLFNBQVNBLFVBQVUsT0FBTztZQUN0Q3BpRSxJQUFJdWhFLE9BQU8sR0FBR2EsVUFBVSxRQUFRcG5FLFFBQVFxM0IsUUFBUXIzQjtRQUNsRDtRQUVBLHVCQUF1QjtRQUN2QixJQUFJb25FLFVBQVUsS0FBSztZQUNqQnBpRSxJQUFJdWhFLE9BQU8sR0FBR3ZtRSxRQUFRO1FBQ3hCO1FBQ0EsT0FBT2dGO0lBQ1QsT0FBTyxJQUFJaU8sS0FBS3V5RixRQUFRLEVBQUU7UUFDeEIsSUFBSWpwRCxRQUFRLEVBQUU7UUFDZCxJQUFJaXRELFdBQVcsS0FBS3hwRztRQUNwQixJQUFJd3BHLGFBQWE7YUFBZTtZQUM5QixvQkFBb0I7WUFFcEIsSUFBSUMsYUFBYUQsU0FBUzNrRixLQUFLLENBQUM7WUFDaEMsSUFBSyxJQUFJb0MsTUFBTSxHQUFHQSxNQUFNd2lGLFdBQVdyckcsTUFBTSxFQUFFNm9CLE1BQU87Z0JBQ2hELElBQUloSCxXQUFXd3BGLFVBQVUsQ0FBQ3hpRixJQUFJLENBQUMraEYsSUFBSTtnQkFDbkMsSUFBSWprRyxNQUFLMjhDLFVBQVUsQ0FBQ3poQyxTQUFTLEVBQUU7b0JBQzdCczhCLE1BQU0zN0MsSUFBSSxDQUFDcWY7Z0JBQ2IsT0FBTztvQkFDTHRDLEtBQUssTUFBTXNDLFdBQVc7Z0JBQ3hCO1lBQ0Y7WUFDQSxJQUFJczhCLE1BQU1uK0MsTUFBTSxLQUFLLEdBQUc7Z0JBQ3RCLE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztZQUNMcUQsTUFBTUE7WUFDTnpCLE9BQU91OEM7WUFDUDZzQixVQUFVN3NCLE1BQU1uK0MsTUFBTSxLQUFLLElBQUksU0FBU20rQyxNQUFNMzNDLElBQUksQ0FBQztZQUNuRG9nQixRQUFRczFFO1FBQ1Y7SUFDRixPQUFPLElBQUlybkYsS0FBS3ZLLEtBQUssRUFBRTtRQUNyQixJQUFJZ2hHLFFBQVE5Z0csWUFBWTVJO1FBQ3hCLElBQUksQ0FBQzBwRyxPQUFPO1lBQ1YsT0FBTztRQUNUO1FBQ0EsT0FBTztZQUNMam9HLE1BQU1BO1lBQ056QixPQUFPMHBHO1lBQ1BuakMsU0FBU21qQztZQUNUdGdDLFVBQVUsU0FBU3NnQyxLQUFLLENBQUMsRUFBRSxHQUFHLE1BQU1BLEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTUEsS0FBSyxDQUFDLEVBQUUsR0FBRztZQUNoRSx5Q0FBeUM7WUFDekMxa0YsUUFBUXMxRTtRQUNWO0lBQ0YsT0FBTyxJQUFJcm5GLEtBQUsybUQsS0FBSyxJQUFJM21ELEtBQUtveUYsT0FBTyxFQUFFO1FBQ3JDLG9CQUFvQjtRQUNwQixJQUFJcHlGLEtBQUtvbEYsS0FBSyxFQUFFO1lBQ2QsSUFBSXNSLFdBQVdQO1lBQ2YsSUFBSU8sVUFBVTtnQkFDWixPQUFPQTtZQUNUO1FBQ0Y7UUFDQSxJQUFJdEUsVUFBVXB5RixLQUFLb3lGLE9BQU8sR0FBR3B5RixLQUFLb3lGLE9BQU8sR0FBRztZQUFDcHlGLEtBQUsybUQsS0FBSztTQUFDO1FBQ3hELElBQUssSUFBSXBrQyxNQUFNLEdBQUdBLE1BQU02dkUsUUFBUWpuRyxNQUFNLEVBQUVvM0IsTUFBTztZQUM3QyxJQUFJb2tDLFFBQVEsSUFBSTl4RCxPQUFPdTlGLE9BQU8sQ0FBQzd2RSxJQUFJLEdBQUcsb0NBQW9DO1lBQzFFLElBQUkzdEIsS0FBSSt4RCxNQUFNN3hELElBQUksQ0FBQy9IO1lBQ25CLElBQUk2SCxJQUFHO2dCQUNMLGdCQUFnQjtnQkFDaEIsT0FBTztvQkFDTHBHLE1BQU1BO29CQUNOekIsT0FBT2lULEtBQUtxeUYscUJBQXFCLEdBQUd6OUYsRUFBQyxDQUFDLEVBQUUsR0FBR0E7b0JBQzNDdWhFLFVBQVUsS0FBS3BwRTtvQkFDZmdsQixRQUFRczFFO2dCQUNWO1lBQ0Y7UUFDRjtRQUNBLE9BQU8sTUFBTSxtQkFBbUI7SUFDbEMsT0FBTyxJQUFJcm5GLEtBQUt6USxNQUFNLEVBQUU7UUFDdEIsY0FBYztRQUNkLE9BQU87WUFDTGYsTUFBTUE7WUFDTnpCLE9BQU8sS0FBS0E7WUFDWm9wRSxVQUFVLEtBQUtwcEU7WUFDZmdsQixRQUFRczFFO1FBQ1Y7SUFDRixPQUFPLElBQUlybkYsS0FBS29sRixLQUFLLEVBQUU7UUFDckIsdURBQXVEO1FBQ3ZELE9BQU8rUTtJQUNULE9BQU87UUFDTCxPQUFPLE1BQU0sMkJBQTJCO0lBQzFDO0FBQ0Y7QUFFQSxJQUFJUSxTQUFTLFNBQVNDLE1BQU1sb0YsRUFBRTtJQUM1QixJQUFJLENBQUUsS0FBSSxZQUFZaW9GLE1BQUssR0FBSTtRQUM3QixPQUFPLElBQUlBLE9BQU9qb0Y7SUFDcEI7SUFDQSxJQUFJLENBQUNsZSxLQUFLa2UsS0FBSztRQUNickQsTUFBTTtRQUNOO0lBQ0Y7SUFDQSxJQUFJLENBQUMvYSxRQUFRLEdBQUc7UUFDZG9lLElBQUlBO1FBQ0ptb0YsV0FBVyxDQUFDO0lBQ2Q7SUFDQSxJQUFJLENBQUMxckcsTUFBTSxHQUFHO0lBQ2QsSUFBSSxDQUFDOGhHLGNBQWM7QUFDckI7QUFDQSxJQUFJNkosUUFBUUgsT0FBT3BxRyxTQUFTO0FBQzVCdXFHLE1BQU16bkcsY0FBYyxHQUFHO0lBQ3JCLE9BQU87QUFDVDtBQUVBLHNCQUFzQjtBQUN0QnluRyxNQUFNdnBGLEtBQUssR0FBRztJQUNaLElBQUkwQixLQUFLLElBQUksQ0FBQzNlLFFBQVE7SUFDdEIsSUFBSW9lLEtBQUtPLEdBQUdQLEVBQUU7SUFDZCxJQUFJOEosT0FBTzlKLEdBQUd1Z0QsUUFBUTtJQUN0QixJQUFLLElBQUl2aEUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSSxDQUFDQSxFQUFFLEdBQUdRO0lBQ1o7SUFDQSxJQUFJLENBQUMvQyxNQUFNLEdBQUc7SUFDZDhqQixHQUFHNHpFLGFBQWEsR0FBRyxDQUFDO0lBQ3BCNXpFLEdBQUd5eUUsU0FBUyxHQUFHLENBQUM7SUFDaEIsSUFBSSxDQUFDdUgsYUFBYSxDQUFDendFLE1BQU07SUFDekJBLEtBQUtuSyxPQUFPLENBQUMsU0FBVTVCLEdBQUc7UUFDeEIsSUFBSXNxRixRQUFRdHFGLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRO1FBQzNCeW1HLE1BQU1qNkIsVUFBVSxHQUFHO1FBQ25CaTZCLE1BQU01VixnQkFBZ0IsR0FBRztJQUMzQjtJQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFDQTJWLE1BQU03SixjQUFjLEdBQUc7SUFDckIsSUFBSSxDQUFDMS9FLEtBQUs7SUFDVixJQUFJLENBQUM2bkYsb0JBQW9CO0lBQ3pCLE9BQU8sSUFBSTtBQUNiO0FBRUEsZ0RBQWdEO0FBQ2hEMEIsTUFBTXRtRyxJQUFJLEdBQUcsU0FBVXdjLFFBQVE7SUFDN0IsT0FBTyxJQUFJLENBQUMxYyxRQUFRLENBQUN1bUcsU0FBUyxDQUFDN3BGLFNBQVMsSUFBSSxJQUFJLENBQUMrOUQsa0JBQWtCLENBQUMvOUQ7QUFDdEU7QUFFQSxxRkFBcUY7QUFDckY4cEYsTUFBTXAxQyxRQUFRLEdBQUcsU0FBVWtzQyxXQUFXO0lBQ3BDLHdEQUF3RDtJQUN4RCxJQUFJbHNDLFdBQVdrc0MsZ0JBQWdCLFNBQVMsT0FBTyxJQUFJL2dDLFNBQVMrZ0M7SUFDNUQsSUFBSWxnRyxJQUFJLElBQUksQ0FBQ3ZDLE1BQU0sSUFBSSw4QkFBOEI7SUFDckQsSUFBSSxDQUFDdUMsRUFBRSxHQUFHO1FBQ1JnMEQsVUFBVUE7UUFDVmpULFlBQVksRUFBRTtRQUNkMHpDLGtCQUFrQixFQUFFO1FBQ3BCOWdGLE9BQU8zVDtJQUNUO0lBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztBQUMxQjtBQUVBLG1EQUFtRDtBQUNuRG9wRyxNQUFNOWtGLEdBQUcsR0FBRztJQUNWLElBQUlsZ0IsUUFBTyxJQUFJO0lBQ2YsSUFBSUosT0FBT0Q7SUFDWCxJQUFJQyxLQUFLdkcsTUFBTSxLQUFLLEdBQUc7UUFDckIsSUFBSStULE1BQU14TixJQUFJLENBQUMsRUFBRTtRQUNqQixJQUFLLElBQUloRSxJQUFJLEdBQUdBLElBQUlvRSxNQUFLMjhDLFVBQVUsQ0FBQ3RqRCxNQUFNLEVBQUV1QyxJQUFLO1lBQy9DLElBQUk4L0MsT0FBTzE3QyxNQUFLMjhDLFVBQVUsQ0FBQy9nRCxFQUFFO1lBQzdCLElBQUlzcEcsU0FBUzkzRixHQUFHLENBQUNzdUMsS0FBS2gvQyxJQUFJLENBQUM7WUFDM0IsSUFBSXdvRyxXQUFXOW9HLFdBQVc7Z0JBQ3hCOG9HLFNBQVM5M0YsR0FBRyxDQUFDMU0sV0FBV2c3QyxLQUFLaC9DLElBQUksRUFBRTtZQUNyQztZQUNBLElBQUl3b0csV0FBVzlvRyxXQUFXO2dCQUN4QixJQUFJLENBQUMrb0csT0FBTyxDQUFDenBELEtBQUtoL0MsSUFBSSxFQUFFd29HO1lBQzFCO1FBQ0Y7SUFDRixPQUFPLElBQUl0bEcsS0FBS3ZHLE1BQU0sS0FBSyxHQUFHO1FBQzVCLElBQUksQ0FBQzhyRyxPQUFPLENBQUN2bEcsSUFBSSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEVBQUU7SUFDL0I7SUFFQSxpQ0FBaUM7SUFFakMsT0FBTyxJQUFJLEVBQUUsV0FBVztBQUMxQjtBQUNBb2xHLE1BQU10bkYsS0FBSyxHQUFHc25GLE1BQU05a0YsR0FBRztBQUV2QiwrQ0FBK0M7QUFDL0M4a0YsTUFBTUcsT0FBTyxHQUFHLFNBQVV6b0csSUFBSSxFQUFFekIsS0FBSztJQUNuQyxrQkFBa0I7SUFDbEIsSUFBSTY5RSxXQUFXLElBQUksQ0FBQzVnQixLQUFLLENBQUN4N0QsTUFBTXpCO0lBRWhDLDJDQUEyQztJQUMzQyxJQUFJNjlFLFVBQVU7UUFDWixJQUFJbDlFLElBQUksSUFBSSxDQUFDdkMsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQ3VDLEVBQUUsQ0FBQytnRCxVQUFVLENBQUM5Z0QsSUFBSSxDQUFDaTlFO1FBQ3hCLElBQUksQ0FBQ2w5RSxFQUFFLENBQUMrZ0QsVUFBVSxDQUFDbThCLFNBQVNwOEUsSUFBSSxDQUFDLEdBQUdvOEUsVUFBVSwrQkFBK0I7UUFFN0UsSUFBSUEsU0FBU3A4RSxJQUFJLENBQUNvQyxLQUFLLENBQUMsZ0NBQWdDZzZFLFNBQVM3OUUsS0FBSyxFQUFFO1lBQ3RFLElBQUksQ0FBQ3VELFFBQVEsQ0FBQzIyRixNQUFNLEdBQUc7UUFDekI7UUFDQSxJQUFJcmMsU0FBU3A4RSxJQUFJLENBQUNvQyxLQUFLLENBQUMsbUNBQW1DZzZFLFNBQVM3OUUsS0FBSyxFQUFFO1lBQ3pFLElBQUksQ0FBQ3VELFFBQVEsQ0FBQzQyRixTQUFTLEdBQUc7UUFDNUI7UUFDQSxJQUFJdGMsU0FBU3lZLE1BQU0sRUFBRTtZQUNuQixJQUFJLENBQUMzMUYsRUFBRSxDQUFDeTBGLGdCQUFnQixDQUFDeDBGLElBQUksQ0FBQ2k5RTtRQUNoQztRQUVBLGlDQUFpQztRQUNqQyxJQUFJc3NCLHdCQUF3QixDQUFDLElBQUksQ0FBQ3hwRyxFQUFFLENBQUNnMEQsUUFBUTtRQUM3QyxJQUFJdzFDLHVCQUF1QjtZQUN6QixJQUFJLENBQUM1bUcsUUFBUSxDQUFDdW1HLFNBQVMsQ0FBQ2pzQixTQUFTcDhFLElBQUksQ0FBQyxHQUFHbzhFO1FBQzNDO0lBQ0Y7SUFDQSxPQUFPLElBQUksRUFBRSxXQUFXO0FBQzFCO0FBQ0Frc0IsTUFBTUssTUFBTSxHQUFHLFNBQVUzbkYsS0FBSztJQUM1QixJQUFJL2UsV0FBVytlLFFBQVE7UUFDckJBLE1BQU00bkYsYUFBYSxDQUFDLElBQUk7SUFDMUIsT0FBTyxJQUFJM25HLE1BQU0rZixRQUFRO1FBQ3ZCLElBQUksQ0FBQ3U5RSxjQUFjLENBQUN2OUU7SUFDdEIsT0FBTyxJQUFJamdCLE9BQU9pZ0IsUUFBUTtRQUN4QixJQUFJLENBQUM0OUUsZ0JBQWdCLENBQUM1OUU7SUFDeEIsRUFBRSx3RkFBd0Y7SUFFMUYsT0FBTyxJQUFJO0FBQ2I7QUFFQSxrQkFBa0I7QUFDbEJtbkYsT0FBTzNKLFFBQVEsR0FBRyxTQUFVdCtFLEVBQUUsRUFBRW1qRSxJQUFJO0lBQ2xDLElBQUlyaUUsUUFBUSxJQUFJbW5GLE9BQU9qb0Y7SUFDdkJjLE1BQU13OUUsUUFBUSxDQUFDbmI7SUFDZixPQUFPcmlFO0FBQ1Q7QUFDQW1uRixPQUFPekksVUFBVSxHQUFHLFNBQVV4L0UsRUFBRSxFQUFFbmYsTUFBTTtJQUN0QyxPQUFPLElBQUlvbkcsT0FBT2pvRixJQUFJdy9FLFVBQVUsQ0FBQzMrRjtBQUNuQztBQUNBO0lBQUNteEY7SUFBU2dLO0lBQVNhO0lBQVNPO0lBQVNnQjtJQUFTSztJQUFTZ0I7SUFBU2tIO0NBQVEsQ0FBQ2huRixPQUFPLENBQUMsU0FBVWk3QixLQUFLO0lBQzlGNTFDLE9BQU9vakcsT0FBT3h0RDtBQUNoQjtBQUNBcXRELE9BQU8zVCxLQUFLLEdBQUc4VCxNQUFNOVQsS0FBSztBQUMxQjJULE9BQU9sb0QsVUFBVSxHQUFHcW9ELE1BQU1yb0QsVUFBVTtBQUNwQ2tvRCxPQUFPakMsY0FBYyxHQUFHb0MsTUFBTXBDLGNBQWM7QUFDNUNpQyxPQUFPOVMsa0JBQWtCLEdBQUdpVCxNQUFNalQsa0JBQWtCO0FBQ3BEOFMsT0FBTzVTLGlCQUFpQixHQUFHK1MsTUFBTS9TLGlCQUFpQjtBQUVsRCxJQUFJc1QsV0FBVztJQUNiN25GLE9BQU8sU0FBU0EsTUFBTThuRixRQUFRO1FBQzVCLElBQUlBLFVBQVU7WUFDWixJQUFJenFHLElBQUksSUFBSSxDQUFDMHFHLFFBQVEsQ0FBQ0Q7WUFDdEJ6cUcsRUFBRXNtRSxNQUFNO1FBQ1Y7UUFDQSxPQUFPLElBQUksQ0FBQzdpRSxRQUFRLENBQUNrZixLQUFLO0lBQzVCO0lBQ0ErbkYsVUFBVSxTQUFTQSxTQUFTL25GLEtBQUs7UUFDL0IsSUFBSVAsS0FBSyxJQUFJLENBQUMzZSxRQUFRO1FBQ3RCLElBQUlHLFdBQVcrZSxRQUFRO1lBQ3JCUCxHQUFHTyxLQUFLLEdBQUdBLE1BQU1nb0YsYUFBYSxDQUFDLElBQUk7UUFDckMsT0FBTyxJQUFJL25HLE1BQU0rZixRQUFRO1lBQ3ZCUCxHQUFHTyxLQUFLLEdBQUdtbkYsT0FBTzNKLFFBQVEsQ0FBQyxJQUFJLEVBQUV4OUU7UUFDbkMsT0FBTyxJQUFJamdCLE9BQU9pZ0IsUUFBUTtZQUN4QlAsR0FBR08sS0FBSyxHQUFHbW5GLE9BQU96SSxVQUFVLENBQUMsSUFBSSxFQUFFMStFO1FBQ3JDLE9BQU87WUFDTFAsR0FBR08sS0FBSyxHQUFHbW5GLE9BQU8sSUFBSTtRQUN4QjtRQUNBLE9BQU8xbkYsR0FBR08sS0FBSztJQUNqQjtJQUNBLCtDQUErQztJQUMvQzZ2QyxhQUFhLFNBQVNBO1FBQ3BCLElBQUksQ0FBQzZrQixlQUFlLEdBQUc3a0IsV0FBVyxJQUFJLHdCQUF3QjtJQUNoRTtBQUNGO0FBRUEsSUFBSW80Qyx1QkFBdUI7QUFDM0IsSUFBSUMsV0FBVztJQUNiL3BCLFVBQVUsU0FBU0EsU0FBU29RLElBQUk7UUFDOUIsSUFBSUEsU0FBUzd2RixXQUFXO1lBQ3RCLElBQUksQ0FBQ29DLFFBQVEsQ0FBQ3E5RSxRQUFRLEdBQUdvUSxPQUFPLE9BQU87UUFDekMsT0FBTztZQUNMLE9BQU8sSUFBSSxDQUFDenRGLFFBQVEsQ0FBQ3E5RSxRQUFRO1FBQy9CO1FBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztJQUMxQjtJQUNBQyxlQUFlLFNBQVNBLGNBQWNtUSxJQUFJO1FBQ3hDLElBQUlBLFNBQVM3dkYsV0FBVztZQUN0QixJQUFJLENBQUNvQyxRQUFRLENBQUNzOUUsYUFBYSxHQUFHbVEsT0FBTyxPQUFPO1FBQzlDLE9BQU87WUFDTCxPQUFPLElBQUksQ0FBQ3p0RixRQUFRLENBQUNzOUUsYUFBYTtRQUNwQztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQUMsaUJBQWlCLFNBQVNBLGdCQUFnQmtRLElBQUk7UUFDNUMsSUFBSUEsU0FBUzd2RixXQUFXO1lBQ3RCLElBQUksQ0FBQ29DLFFBQVEsQ0FBQ3U5RSxlQUFlLEdBQUdrUSxPQUFPLE9BQU87UUFDaEQsT0FBTztZQUNMLE9BQU8sSUFBSSxDQUFDenRGLFFBQVEsQ0FBQ3U5RSxlQUFlO1FBQ3RDO1FBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztJQUMxQjtJQUNBOHBCLGVBQWUsU0FBU0EsY0FBY0MsT0FBTztRQUMzQyxJQUFJM29GLEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QixJQUFJMmUsR0FBRzBvRixhQUFhLElBQUksTUFBTTtZQUM1QjFvRixHQUFHMG9GLGFBQWEsR0FBR0Y7UUFDckI7UUFDQSxJQUFJRyxZQUFZMXBHLFdBQVc7WUFDekIsSUFBSTBwRyxZQUFZLGNBQWNBLFlBQVksVUFBVTtnQkFDbEQzb0YsR0FBRzBvRixhQUFhLEdBQUdDO1lBQ3JCO1FBQ0YsT0FBTztZQUNMLE9BQU8zb0YsR0FBRzBvRixhQUFhO1FBQ3pCO1FBQ0EsT0FBTyxJQUFJO0lBQ2I7SUFDQUUsZ0JBQWdCLFNBQVNBLGVBQWU5WixJQUFJO1FBQzFDLElBQUlBLFNBQVM3dkYsV0FBVztZQUN0QixJQUFJLENBQUNvQyxRQUFRLENBQUN1bkcsY0FBYyxHQUFHOVosT0FBTyxPQUFPO1FBQy9DLE9BQU87WUFDTCxPQUFPLElBQUksQ0FBQ3p0RixRQUFRLENBQUN1bkcsY0FBYztRQUNyQztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQUMsb0JBQW9CLFNBQVNBLG1CQUFtQi9aLElBQUk7UUFDbEQsSUFBSUEsU0FBUzd2RixXQUFXO1lBQ3RCLElBQUksQ0FBQ29DLFFBQVEsQ0FBQ3duRyxrQkFBa0IsR0FBRy9aLE9BQU8sT0FBTztRQUNuRCxPQUFPO1lBQ0wsT0FBTyxJQUFJLENBQUN6dEYsUUFBUSxDQUFDd25HLGtCQUFrQjtRQUN6QztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQUMsZ0JBQWdCLFNBQVNBLGVBQWVoYSxJQUFJO1FBQzFDLElBQUlBLFNBQVM3dkYsV0FBVztZQUN0QixJQUFJLENBQUNvQyxRQUFRLENBQUN5bkcsY0FBYyxHQUFHaGEsT0FBTyxPQUFPO1FBQy9DLE9BQU87WUFDTCxPQUFPLElBQUksQ0FBQ3p0RixRQUFRLENBQUN5bkcsY0FBYztRQUNyQztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQUMsb0JBQW9CLFNBQVNBLG1CQUFtQmphLElBQUk7UUFDbEQsSUFBSUEsU0FBUzd2RixXQUFXO1lBQ3RCLElBQUksQ0FBQ29DLFFBQVEsQ0FBQzBuRyxrQkFBa0IsR0FBR2phLE9BQU8sT0FBTztRQUNuRCxPQUFPO1lBQ0wsT0FBTyxJQUFJLENBQUN6dEYsUUFBUSxDQUFDMG5HLGtCQUFrQjtRQUN6QztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQUMscUJBQXFCLFNBQVNBLG9CQUFvQmxhLElBQUk7UUFDcEQsSUFBSUEsU0FBUzd2RixXQUFXO1lBQ3RCLElBQUksQ0FBQ29DLFFBQVEsQ0FBQzJuRyxtQkFBbUIsR0FBR2xhLE9BQU8sT0FBTztRQUNwRCxPQUFPO1lBQ0wsT0FBTyxJQUFJLENBQUN6dEYsUUFBUSxDQUFDMm5HLG1CQUFtQjtRQUMxQztRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQXZtRixLQUFLLFNBQVNBO1FBQ1osSUFBSWhnQixPQUFPRDtRQUNYLElBQUlpZ0IsTUFBTSxJQUFJLENBQUNwaEIsUUFBUSxDQUFDb2hCLEdBQUc7UUFDM0IsSUFBSTBzQixLQUFLL3dCLEtBQUs2NkQsTUFBTXpvRSxHQUFHeUo7UUFDdkIsT0FBUXhYLEtBQUt2RyxNQUFNO1lBQ2pCLEtBQUs7Z0JBQ0gsU0FBUztnQkFDVCxPQUFPdW1CO1lBQ1QsS0FBSztnQkFDSCxJQUFJbmlCLE9BQU9tQyxJQUFJLENBQUMsRUFBRSxHQUFHO29CQUNuQixZQUFZO29CQUNaMHNDLE1BQU0xc0MsSUFBSSxDQUFDLEVBQUU7b0JBQ2IsT0FBT2dnQixHQUFHLENBQUMwc0IsSUFBSTtnQkFDakIsT0FBTyxJQUFJenVDLFlBQVkrQixJQUFJLENBQUMsRUFBRSxHQUFHO29CQUMvQix5QkFBeUI7b0JBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUNwQixRQUFRLENBQUN1bkcsY0FBYyxFQUFFO3dCQUNqQyxPQUFPLElBQUk7b0JBQ2I7b0JBQ0EzdkIsT0FBT3gyRSxJQUFJLENBQUMsRUFBRTtvQkFDZCtOLElBQUl5b0UsS0FBS3pvRSxDQUFDO29CQUNWeUosSUFBSWcvRCxLQUFLaC9ELENBQUM7b0JBQ1YsSUFBSXJaLFNBQVM0UCxJQUFJO3dCQUNmaVMsSUFBSWpTLENBQUMsR0FBR0E7b0JBQ1Y7b0JBQ0EsSUFBSTVQLFNBQVNxWixJQUFJO3dCQUNmd0ksSUFBSXhJLENBQUMsR0FBR0E7b0JBQ1Y7b0JBQ0EsSUFBSSxDQUFDbzRDLElBQUksQ0FBQztnQkFDWjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsaUJBQWlCO2dCQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDaHhELFFBQVEsQ0FBQ3VuRyxjQUFjLEVBQUU7b0JBQ2pDLE9BQU8sSUFBSTtnQkFDYjtnQkFDQXo1RCxNQUFNMXNDLElBQUksQ0FBQyxFQUFFO2dCQUNiMmIsTUFBTTNiLElBQUksQ0FBQyxFQUFFO2dCQUNiLElBQUksQ0FBQzBzQyxRQUFRLE9BQU9BLFFBQVEsR0FBRSxLQUFNdnVDLFNBQVN3ZCxNQUFNO29CQUNqRHFFLEdBQUcsQ0FBQzBzQixJQUFJLEdBQUcvd0I7Z0JBQ2I7Z0JBQ0EsSUFBSSxDQUFDaTBDLElBQUksQ0FBQztnQkFDVjtRQUVKO1FBQ0EsSUFBSSxDQUFDdFIsTUFBTSxDQUFDO1FBQ1osT0FBTyxJQUFJLEVBQUUsV0FBVztJQUMxQjtJQUNBbkIsT0FBTyxTQUFTQSxNQUFNcXBELElBQUksRUFBRW5xQyxJQUFJO1FBQzlCLElBQUlyOEQsT0FBT0Q7UUFDWCxJQUFJaWdCLE1BQU0sSUFBSSxDQUFDcGhCLFFBQVEsQ0FBQ29oQixHQUFHO1FBQzNCLElBQUkwc0IsS0FBSy93QixLQUFLNjZELE1BQU16b0UsR0FBR3lKO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUM1WSxRQUFRLENBQUN1bkcsY0FBYyxFQUFFO1lBQ2pDLE9BQU8sSUFBSTtRQUNiO1FBQ0EsT0FBUW5tRyxLQUFLdkcsTUFBTTtZQUNqQixLQUFLO2dCQUNILElBQUl3RSxZQUFZdW9HLE9BQU87b0JBQ3JCLDJCQUEyQjtvQkFDM0Jod0IsT0FBT3gyRSxJQUFJLENBQUMsRUFBRTtvQkFDZCtOLElBQUl5b0UsS0FBS3pvRSxDQUFDO29CQUNWeUosSUFBSWcvRCxLQUFLaC9ELENBQUM7b0JBQ1YsSUFBSXJaLFNBQVM0UCxJQUFJO3dCQUNmaVMsSUFBSWpTLENBQUMsSUFBSUE7b0JBQ1g7b0JBQ0EsSUFBSTVQLFNBQVNxWixJQUFJO3dCQUNmd0ksSUFBSXhJLENBQUMsSUFBSUE7b0JBQ1g7b0JBQ0EsSUFBSSxDQUFDbzRDLElBQUksQ0FBQztnQkFDWjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsbUJBQW1CO2dCQUNuQmxqQixNQUFNODVEO2dCQUNON3FGLE1BQU0wZ0Q7Z0JBQ04sSUFBSSxDQUFDM3ZCLFFBQVEsT0FBT0EsUUFBUSxHQUFFLEtBQU12dUMsU0FBU3dkLE1BQU07b0JBQ2pEcUUsR0FBRyxDQUFDMHNCLElBQUksSUFBSS93QjtnQkFDZDtnQkFDQSxJQUFJLENBQUNpMEMsSUFBSSxDQUFDO2dCQUNWO1FBRUo7UUFDQSxJQUFJLENBQUN0UixNQUFNLENBQUM7UUFDWixPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0lBQ0Ftb0QsSUFBSSxTQUFTQTtRQUNYLElBQUksQ0FBQ25vRCxNQUFNLENBQUM7SUFDZDtJQUNBYixLQUFLLFNBQVNBLElBQUk4ZixRQUFRLEVBQUU5b0MsT0FBTztRQUNqQyxJQUFJaXlFLGdCQUFnQixJQUFJLENBQUMvb0QsY0FBYyxDQUFDNGYsVUFBVTlvQztRQUNsRCxJQUFJaXlFLGVBQWU7WUFDakIsSUFBSW5wRixLQUFLLElBQUksQ0FBQzNlLFFBQVE7WUFDdEIyZSxHQUFHMEMsSUFBSSxHQUFHeW1GLGNBQWN6bUYsSUFBSTtZQUM1QjFDLEdBQUd5QyxHQUFHLEdBQUcwbUYsY0FBYzFtRixHQUFHO1lBQzFCLElBQUksQ0FBQzR2QyxJQUFJLENBQUM7WUFDVixJQUFJLENBQUN0UixNQUFNLENBQUM7UUFDZDtRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQVgsZ0JBQWdCLFNBQVNBLGVBQWU0ZixRQUFRLEVBQUU5b0MsT0FBTztRQUN2RCxJQUFJdDJCLFNBQVNvL0QsYUFBYTlvQyxZQUFZajRCLFdBQVc7WUFDL0MsdUJBQXVCO1lBQ3ZCaTRCLFVBQVU4b0M7WUFDVkEsV0FBVy9nRTtRQUNiO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ29DLFFBQVEsQ0FBQ3VuRyxjQUFjLElBQUksQ0FBQyxJQUFJLENBQUN2bkcsUUFBUSxDQUFDeW5HLGNBQWMsRUFBRTtZQUNsRTtRQUNGO1FBQ0EsSUFBSXB5RTtRQUNKLElBQUlwMkIsT0FBTzAvRCxXQUFXO1lBQ3BCLElBQUkvSSxNQUFNK0k7WUFDVkEsV0FBVyxJQUFJLENBQUN0d0MsQ0FBQyxDQUFDdW5DO1FBQ3BCLE9BQU8sSUFBSXAxRCxZQUFZbStELFdBQVc7WUFDaEMsWUFBWTtZQUNaLElBQUlvcEMsTUFBTXBwQztZQUNWdHBDLEtBQUs7Z0JBQ0g1MEIsSUFBSXNuRyxJQUFJdG5HLEVBQUU7Z0JBQ1ZFLElBQUlvbkcsSUFBSXBuRyxFQUFFO2dCQUNWRCxJQUFJcW5HLElBQUlybkcsRUFBRTtnQkFDVkUsSUFBSW1uRyxJQUFJbm5HLEVBQUU7WUFDWjtZQUNBeTBCLEdBQUd2YixDQUFDLEdBQUd1YixHQUFHMzBCLEVBQUUsR0FBRzIwQixHQUFHNTBCLEVBQUU7WUFDcEI0MEIsR0FBR254QixDQUFDLEdBQUdteEIsR0FBR3owQixFQUFFLEdBQUd5MEIsR0FBRzEwQixFQUFFO1FBQ3RCLE9BQU8sSUFBSSxDQUFDdkIsb0JBQW9CdS9ELFdBQVc7WUFDekNBLFdBQVcsSUFBSSxDQUFDaVYsZUFBZTtRQUNqQztRQUNBLElBQUl4MEUsb0JBQW9CdS9ELGFBQWFBLFNBQVN2M0MsS0FBSyxJQUFJO1lBQ3JEO1FBQ0YsRUFBRSx1QkFBdUI7UUFFekJpTyxLQUFLQSxNQUFNc3BDLFNBQVNuK0QsV0FBVztRQUMvQixJQUFJc1osSUFBSSxJQUFJLENBQUNpZSxLQUFLO1FBQ2xCLElBQUk3ekIsSUFBSSxJQUFJLENBQUM4ekIsTUFBTTtRQUNuQixJQUFJM1c7UUFDSndVLFVBQVV0MkIsU0FBU3MyQixXQUFXQSxVQUFVO1FBQ3hDLElBQUksQ0FBQ3AyQixNQUFNcWEsTUFBTSxDQUFDcmEsTUFBTXlFLE1BQU00VixJQUFJLEtBQUs1VixJQUFJLEtBQUssQ0FBQ3pFLE1BQU00MUIsR0FBR3ZiLENBQUMsS0FBSyxDQUFDcmEsTUFBTTQxQixHQUFHbnhCLENBQUMsS0FBS214QixHQUFHdmIsQ0FBQyxHQUFHLEtBQUt1YixHQUFHbnhCLENBQUMsR0FBRyxHQUFHO1lBQ3BHbWQsT0FBTzFoQixLQUFLK1UsR0FBRyxDQUFDLENBQUNvRixJQUFJLElBQUkrYixPQUFNLElBQUtSLEdBQUd2YixDQUFDLEVBQUUsQ0FBQzVWLElBQUksSUFBSTJ4QixPQUFNLElBQUtSLEdBQUdueEIsQ0FBQztZQUVsRSxZQUFZO1lBQ1ptZCxPQUFPQSxPQUFPLElBQUksQ0FBQ3JoQixRQUFRLENBQUM4cUYsT0FBTyxHQUFHLElBQUksQ0FBQzlxRixRQUFRLENBQUM4cUYsT0FBTyxHQUFHenBFO1lBQzlEQSxPQUFPQSxPQUFPLElBQUksQ0FBQ3JoQixRQUFRLENBQUM2cUYsT0FBTyxHQUFHLElBQUksQ0FBQzdxRixRQUFRLENBQUM2cUYsT0FBTyxHQUFHeHBFO1lBQzlELElBQUlELE1BQU07Z0JBQ1Isb0JBQW9CO2dCQUNwQmpTLEdBQUcsQ0FBQzJLLElBQUl1SCxPQUFRZ1UsQ0FBQUEsR0FBRzUwQixFQUFFLEdBQUc0MEIsR0FBRzMwQixFQUFFLEtBQUs7Z0JBQ2xDa1ksR0FBRyxDQUFDMVUsSUFBSW1kLE9BQVFnVSxDQUFBQSxHQUFHMTBCLEVBQUUsR0FBRzAwQixHQUFHejBCLEVBQUUsS0FBSztZQUNwQztZQUNBLE9BQU87Z0JBQ0x5Z0IsTUFBTUE7Z0JBQ05ELEtBQUtBO1lBQ1A7UUFDRjtRQUNBO0lBQ0Y7SUFDQTRtRixXQUFXLFNBQVNBLFVBQVV0ekYsR0FBRyxFQUFFRixHQUFHO1FBQ3BDLElBQUltSyxLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSXdVLE9BQU8sTUFBTTtZQUNmLElBQUl1SCxPQUFPckg7WUFDWEEsTUFBTXFILEtBQUtySCxHQUFHO1lBQ2RGLE1BQU11SCxLQUFLdkgsR0FBRztRQUNoQjtRQUNBLElBQUlqVixTQUFTbVYsUUFBUW5WLFNBQVNpVixRQUFRRSxPQUFPRixLQUFLO1lBQ2hEbUssR0FBR2tzRSxPQUFPLEdBQUduMkU7WUFDYmlLLEdBQUdtc0UsT0FBTyxHQUFHdDJFO1FBQ2YsT0FBTyxJQUFJalYsU0FBU21WLFFBQVFGLFFBQVE1VyxhQUFhOFcsT0FBT2lLLEdBQUdtc0UsT0FBTyxFQUFFO1lBQ2xFbnNFLEdBQUdrc0UsT0FBTyxHQUFHbjJFO1FBQ2YsT0FBTyxJQUFJblYsU0FBU2lWLFFBQVFFLFFBQVE5VyxhQUFhNFcsT0FBT21LLEdBQUdrc0UsT0FBTyxFQUFFO1lBQ2xFbHNFLEdBQUdtc0UsT0FBTyxHQUFHdDJFO1FBQ2Y7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUNBcTJFLFNBQVMsU0FBU0EsUUFBUXhwRSxJQUFJO1FBQzVCLElBQUlBLFNBQVN6akIsV0FBVztZQUN0QixPQUFPLElBQUksQ0FBQ29DLFFBQVEsQ0FBQzZxRixPQUFPO1FBQzlCLE9BQU87WUFDTCxPQUFPLElBQUksQ0FBQ21kLFNBQVMsQ0FBQztnQkFDcEJ0ekYsS0FBSzJNO1lBQ1A7UUFDRjtJQUNGO0lBQ0F5cEUsU0FBUyxTQUFTQSxRQUFRenBFLElBQUk7UUFDNUIsSUFBSUEsU0FBU3pqQixXQUFXO1lBQ3RCLE9BQU8sSUFBSSxDQUFDb0MsUUFBUSxDQUFDOHFGLE9BQU87UUFDOUIsT0FBTztZQUNMLE9BQU8sSUFBSSxDQUFDa2QsU0FBUyxDQUFDO2dCQUNwQnh6RixLQUFLNk07WUFDUDtRQUNGO0lBQ0Y7SUFDQTQ5QixtQkFBbUIsU0FBU0Esa0JBQWtCNWdDLE1BQU07UUFDbEQsSUFBSU0sS0FBSyxJQUFJLENBQUMzZSxRQUFRO1FBQ3RCLElBQUlpb0csYUFBYXRwRixHQUFHeUMsR0FBRztRQUN2QixJQUFJOG1GLGNBQWN2cEYsR0FBRzBDLElBQUk7UUFDekIsSUFBSXpILEtBQUssaUJBQWlCO1FBQzFCLElBQUl5SDtRQUNKLElBQUk4bUYsT0FBTztRQUNYLElBQUksQ0FBQ3hwRixHQUFHOG9GLGNBQWMsRUFBRTtZQUN0QixtQkFBbUI7WUFDbkJVLE9BQU87UUFDVDtRQUNBLElBQUk1b0csU0FBUzhlLFNBQVM7WUFDcEIsb0JBQW9CO1lBQ3BCZ0QsT0FBT2hEO1FBQ1QsT0FBTyxJQUFJaGYsWUFBWWdmLFNBQVM7WUFDOUIsMEJBQTBCO1lBQzFCZ0QsT0FBT2hELE9BQU8rcEYsS0FBSztZQUNuQixJQUFJL3BGLE9BQU9PLFFBQVEsSUFBSSxNQUFNO2dCQUMzQmhGLE1BQU1zWiwwQkFBMEI3VSxPQUFPTyxRQUFRLEVBQUVzcEYsYUFBYUQ7WUFDaEUsT0FBTyxJQUFJNXBGLE9BQU82QyxnQkFBZ0IsSUFBSSxNQUFNO2dCQUMxQ3RILE1BQU15RSxPQUFPNkMsZ0JBQWdCO1lBQy9CO1lBQ0EsSUFBSXRILE9BQU8sUUFBUSxDQUFDK0UsR0FBRzRvRixjQUFjLEVBQUU7Z0JBQ3JDLG1CQUFtQjtnQkFDbkJZLE9BQU87WUFDVDtRQUNGO1FBRUEsWUFBWTtRQUNaOW1GLE9BQU9BLE9BQU8xQyxHQUFHbXNFLE9BQU8sR0FBR25zRSxHQUFHbXNFLE9BQU8sR0FBR3pwRTtRQUN4Q0EsT0FBT0EsT0FBTzFDLEdBQUdrc0UsT0FBTyxHQUFHbHNFLEdBQUdrc0UsT0FBTyxHQUFHeHBFO1FBRXhDLGlDQUFpQztRQUNqQyxJQUFJOG1GLFFBQVEsQ0FBQzVvRyxTQUFTOGhCLFNBQVNBLFNBQVM2bUYsZUFBZXR1RixPQUFPLFFBQVMsRUFBQ3JhLFNBQVNxYSxJQUFJekssQ0FBQyxLQUFLLENBQUM1UCxTQUFTcWEsSUFBSWhCLENBQUMsSUFBSTtZQUM1RyxPQUFPO1FBQ1Q7UUFDQSxJQUFJZ0IsT0FBTyxNQUFNO1lBQ2YsMEJBQTBCO1lBQzFCLElBQUl5dUYsT0FBT0o7WUFDWCxJQUFJSyxRQUFRSjtZQUNaLElBQUlLLFFBQVFsbkY7WUFDWixJQUFJbW5GLE9BQU87Z0JBQ1RyNUYsR0FBRyxDQUFDbzVGLFFBQVFELFFBQVMxdUYsQ0FBQUEsSUFBSXpLLENBQUMsR0FBR2s1RixLQUFLbDVGLENBQUMsSUFBSXlLLElBQUl6SyxDQUFDO2dCQUM1Q3lKLEdBQUcsQ0FBQzJ2RixRQUFRRCxRQUFTMXVGLENBQUFBLElBQUloQixDQUFDLEdBQUd5dkYsS0FBS3p2RixDQUFDLElBQUlnQixJQUFJaEIsQ0FBQztZQUM5QztZQUNBLE9BQU87Z0JBQ0xzbUMsUUFBUTtnQkFDUkMsUUFBUTtnQkFDUjk5QixNQUFNa25GO2dCQUNObm5GLEtBQUtvbkY7WUFDUDtRQUNGLE9BQU87WUFDTCxvQkFBb0I7WUFDcEIsT0FBTztnQkFDTHRwRCxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSOTlCLE1BQU1BO2dCQUNORCxLQUFLNm1GO1lBQ1A7UUFDRjtJQUNGO0lBQ0E1bUYsTUFBTSxTQUFTQSxLQUFLaEQsTUFBTTtRQUN4QixJQUFJQSxXQUFXemdCLFdBQVc7WUFDeEIsTUFBTTtZQUNOLE9BQU8sSUFBSSxDQUFDb0MsUUFBUSxDQUFDcWhCLElBQUk7UUFDM0IsT0FBTztZQUNMLE1BQU07WUFDTixJQUFJMjlCLEtBQUssSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQzVnQztZQUNoQyxJQUFJTSxLQUFLLElBQUksQ0FBQzNlLFFBQVE7WUFDdEIsSUFBSWcvQyxNQUFNLFFBQVEsQ0FBQ0EsR0FBR0UsTUFBTSxFQUFFO2dCQUM1QixPQUFPLElBQUk7WUFDYjtZQUNBdmdDLEdBQUcwQyxJQUFJLEdBQUcyOUIsR0FBRzM5QixJQUFJO1lBQ2pCLElBQUkyOUIsR0FBR0csTUFBTSxFQUFFO2dCQUNieGdDLEdBQUd5QyxHQUFHLENBQUNqUyxDQUFDLEdBQUc2dkMsR0FBRzU5QixHQUFHLENBQUNqUyxDQUFDO2dCQUNuQndQLEdBQUd5QyxHQUFHLENBQUN4SSxDQUFDLEdBQUdvbUMsR0FBRzU5QixHQUFHLENBQUN4SSxDQUFDO1lBQ3JCO1lBQ0EsSUFBSSxDQUFDbzRDLElBQUksQ0FBQyxTQUFVaFMsQ0FBQUEsR0FBR0csTUFBTSxHQUFHLFNBQVMsRUFBQyxJQUFLO1lBQy9DLElBQUksQ0FBQ08sTUFBTSxDQUFDO1lBQ1osT0FBTyxJQUFJLEVBQUUsV0FBVztRQUMxQjtJQUNGO0lBQ0Erb0QsVUFBVSxTQUFTQSxTQUFTMXNGLElBQUk7UUFDOUIsSUFBSTRDLEtBQUssSUFBSSxDQUFDM2UsUUFBUTtRQUN0QixJQUFJMG9HLFdBQVc7UUFDZixJQUFJQyxVQUFVO1FBQ2QsSUFBSXgzQyxTQUFTLEVBQUUsRUFBRSxhQUFhO1FBQzlCLElBQUl5M0MsYUFBYTtRQUNqQixJQUFJQyxZQUFZO1FBQ2hCLElBQUksQ0FBQzlzRixNQUFNO1lBQ1QsT0FBTyxJQUFJO1FBQ2I7UUFDQSxJQUFJLENBQUN4YyxTQUFTd2MsS0FBS3NGLElBQUksR0FBRztZQUN4QnFuRixXQUFXO1FBQ2I7UUFDQSxJQUFJLENBQUNycEcsWUFBWTBjLEtBQUtxRixHQUFHLEdBQUc7WUFDMUJ1bkYsVUFBVTtRQUNaO1FBQ0EsSUFBSSxDQUFDRCxZQUFZLENBQUNDLFNBQVM7WUFDekIsT0FBTyxJQUFJO1FBQ2I7UUFDQSxJQUFJRCxVQUFVO1lBQ1osSUFBSUksSUFBSS9zRixLQUFLc0YsSUFBSTtZQUNqQixJQUFJeW5GLElBQUlucUYsR0FBR2tzRSxPQUFPLElBQUlpZSxJQUFJbnFGLEdBQUdtc0UsT0FBTyxJQUFJLENBQUNuc0UsR0FBRzhvRixjQUFjLEVBQUU7Z0JBQzFEbUIsYUFBYTtZQUNmLE9BQU87Z0JBQ0xqcUYsR0FBRzBDLElBQUksR0FBR3luRjtnQkFDVjMzQyxPQUFPOXpELElBQUksQ0FBQztZQUNkO1FBQ0Y7UUFDQSxJQUFJc3JHLFdBQVksRUFBQ0MsY0FBYyxDQUFDN3NGLEtBQUtndEYsa0JBQWtCLEtBQUtwcUYsR0FBRzRvRixjQUFjLEVBQUU7WUFDN0UsSUFBSW5qRyxJQUFJMlgsS0FBS3FGLEdBQUc7WUFDaEIsSUFBSTdoQixTQUFTNkUsRUFBRStLLENBQUMsR0FBRztnQkFDakJ3UCxHQUFHeUMsR0FBRyxDQUFDalMsQ0FBQyxHQUFHL0ssRUFBRStLLENBQUM7Z0JBQ2QwNUYsWUFBWTtZQUNkO1lBQ0EsSUFBSXRwRyxTQUFTNkUsRUFBRXdVLENBQUMsR0FBRztnQkFDakIrRixHQUFHeUMsR0FBRyxDQUFDeEksQ0FBQyxHQUFHeFUsRUFBRXdVLENBQUM7Z0JBQ2Rpd0YsWUFBWTtZQUNkO1lBQ0EsSUFBSSxDQUFDQSxXQUFXO2dCQUNkMTNDLE9BQU85ekQsSUFBSSxDQUFDO1lBQ2Q7UUFDRjtRQUNBLElBQUk4ekQsT0FBT3QyRCxNQUFNLEdBQUcsR0FBRztZQUNyQnMyRCxPQUFPOXpELElBQUksQ0FBQztZQUNaLElBQUksQ0FBQzJ6RCxJQUFJLENBQUNHLE9BQU85dkQsSUFBSSxDQUFDO1lBQ3RCLElBQUksQ0FBQ3ErQyxNQUFNLENBQUM7UUFDZDtRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQWpCLFFBQVEsU0FBU0EsT0FBT2tnQixRQUFRO1FBQzlCLElBQUl2OUMsTUFBTSxJQUFJLENBQUN3OUIsWUFBWSxDQUFDK2Y7UUFDNUIsSUFBSXY5QyxLQUFLO1lBQ1AsSUFBSSxDQUFDcGhCLFFBQVEsQ0FBQ29oQixHQUFHLEdBQUdBO1lBQ3BCLElBQUksQ0FBQzR2QyxJQUFJLENBQUM7WUFDVixJQUFJLENBQUN0UixNQUFNLENBQUM7UUFDZDtRQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQWQsY0FBYyxTQUFTQSxhQUFhK2YsUUFBUSxFQUFFdDlDLElBQUk7UUFDaEQsSUFBSSxDQUFDLElBQUksQ0FBQ3JoQixRQUFRLENBQUN1bkcsY0FBYyxFQUFFO1lBQ2pDO1FBQ0Y7UUFDQSxJQUFJdG9HLE9BQU8wL0QsV0FBVztZQUNwQixJQUFJdk4sV0FBV3VOO1lBQ2ZBLFdBQVcsSUFBSSxDQUFDaVYsZUFBZSxHQUFHOTFELE1BQU0sQ0FBQ3N6QztRQUMzQyxPQUFPLElBQUksQ0FBQ2h5RCxvQkFBb0J1L0QsV0FBVztZQUN6Q0EsV0FBVyxJQUFJLENBQUNpVixlQUFlO1FBQ2pDO1FBQ0EsSUFBSWpWLFNBQVM5akUsTUFBTSxLQUFLLEdBQUc7WUFDekI7UUFDRixFQUFFLDhCQUE4QjtRQUVoQyxJQUFJdzZCLEtBQUtzcEMsU0FBU24rRCxXQUFXO1FBQzdCLElBQUlzWixJQUFJLElBQUksQ0FBQ2llLEtBQUs7UUFDbEIsSUFBSTd6QixJQUFJLElBQUksQ0FBQzh6QixNQUFNO1FBQ25CM1csT0FBT0EsU0FBU3pqQixZQUFZLElBQUksQ0FBQ29DLFFBQVEsQ0FBQ3FoQixJQUFJLEdBQUdBO1FBQ2pELElBQUlELE1BQU07WUFDUixTQUFTO1lBQ1RqUyxHQUFHLENBQUMySyxJQUFJdUgsT0FBUWdVLENBQUFBLEdBQUc1MEIsRUFBRSxHQUFHNDBCLEdBQUczMEIsRUFBRSxLQUFLO1lBQ2xDa1ksR0FBRyxDQUFDMVUsSUFBSW1kLE9BQVFnVSxDQUFBQSxHQUFHMTBCLEVBQUUsR0FBRzAwQixHQUFHejBCLEVBQUUsS0FBSztRQUNwQztRQUNBLE9BQU93Z0I7SUFDVDtJQUNBNG5GLE9BQU8sU0FBU0E7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDaHBHLFFBQVEsQ0FBQ3VuRyxjQUFjLElBQUksQ0FBQyxJQUFJLENBQUN2bkcsUUFBUSxDQUFDeW5HLGNBQWMsRUFBRTtZQUNsRSxPQUFPLElBQUk7UUFDYjtRQUNBLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQztZQUNacm5GLEtBQUs7Z0JBQ0hqUyxHQUFHO2dCQUNIeUosR0FBRztZQUNMO1lBQ0F5SSxNQUFNO1FBQ1I7UUFDQSxPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0lBQ0FpdUUsZ0JBQWdCLFNBQVNBO1FBQ3ZCLElBQUksQ0FBQ3R2RixRQUFRLENBQUNpcEcsU0FBUyxHQUFHO0lBQzVCO0lBQ0F2ckYsTUFBTSxTQUFTQTtRQUNiLElBQUlpQixLQUFLLElBQUksQ0FBQzNlLFFBQVE7UUFDdEIsSUFBSTR2RixZQUFZanhFLEdBQUdpeEUsU0FBUztRQUM1QixJQUFJeHhFLEtBQUssSUFBSTtRQUNiLE9BQU9PLEdBQUdzcUYsU0FBUyxHQUFHdHFGLEdBQUdzcUYsU0FBUyxJQUFLclosQ0FBQUEsWUFBWTtZQUNqRCxJQUFJMXdFLFFBQVFkLEdBQUcvZixNQUFNLEdBQUdpOUYsZ0JBQWdCLENBQUMxTDtZQUN6QyxJQUFJN3lFLE1BQU0sU0FBU0EsSUFBSTdlLElBQUk7Z0JBQ3pCLE9BQU91RyxXQUFXeWEsTUFBTXE4RSxnQkFBZ0IsQ0FBQ3I5RjtZQUMzQztZQUNBLE9BQU87Z0JBQ0w2NUIsT0FBTzYzRCxVQUFVc1osV0FBVyxHQUFHbnNGLElBQUksa0JBQWtCQSxJQUFJO2dCQUN6RGliLFFBQVE0M0QsVUFBVXVaLFlBQVksR0FBR3BzRixJQUFJLGlCQUFpQkEsSUFBSTtZQUM1RDtRQUNGLE1BQU07WUFDSixvRUFBb0U7WUFDcEVnYixPQUFPO1lBQ1BDLFFBQVE7UUFDVjtJQUNGO0lBQ0FELE9BQU8sU0FBU0E7UUFDZCxPQUFPLElBQUksQ0FBQ3JhLElBQUksR0FBR3FhLEtBQUs7SUFDMUI7SUFDQUMsUUFBUSxTQUFTQTtRQUNmLE9BQU8sSUFBSSxDQUFDdGEsSUFBSSxHQUFHc2EsTUFBTTtJQUMzQjtJQUNBb3hFLFFBQVEsU0FBU0E7UUFDZixJQUFJaG9GLE1BQU0sSUFBSSxDQUFDcGhCLFFBQVEsQ0FBQ29oQixHQUFHO1FBQzNCLElBQUlDLE9BQU8sSUFBSSxDQUFDcmhCLFFBQVEsQ0FBQ3FoQixJQUFJO1FBQzdCLElBQUlnb0YsS0FBSyxJQUFJLENBQUNDLGNBQWM7UUFDNUIsSUFBSXBtRyxJQUFJO1lBQ056QyxJQUFJLENBQUM0b0csR0FBRzVvRyxFQUFFLEdBQUcyZ0IsSUFBSWpTLENBQUMsSUFBSWtTO1lBQ3RCM2dCLElBQUksQ0FBQzJvRyxHQUFHM29HLEVBQUUsR0FBRzBnQixJQUFJalMsQ0FBQyxJQUFJa1M7WUFDdEIxZ0IsSUFBSSxDQUFDMG9HLEdBQUcxb0csRUFBRSxHQUFHeWdCLElBQUl4SSxDQUFDLElBQUl5STtZQUN0QnpnQixJQUFJLENBQUN5b0csR0FBR3pvRyxFQUFFLEdBQUd3Z0IsSUFBSXhJLENBQUMsSUFBSXlJO1FBQ3hCO1FBQ0FuZSxFQUFFNFcsQ0FBQyxHQUFHNVcsRUFBRXhDLEVBQUUsR0FBR3dDLEVBQUV6QyxFQUFFO1FBQ2pCeUMsRUFBRWdCLENBQUMsR0FBR2hCLEVBQUV0QyxFQUFFLEdBQUdzQyxFQUFFdkMsRUFBRTtRQUNqQixPQUFPdUM7SUFDVDtJQUNBb21HLGdCQUFnQixTQUFTQTtRQUN2QixJQUFJdnhFLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlDLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLE9BQU87WUFDTHYzQixJQUFJO1lBQ0pFLElBQUk7WUFDSkQsSUFBSXEzQjtZQUNKbjNCLElBQUlvM0I7WUFDSmxlLEdBQUdpZTtZQUNIN3pCLEdBQUc4ekI7UUFDTDtJQUNGO0lBQ0F1eEUsd0JBQXdCLFNBQVNBLHVCQUF1QkMsSUFBSTtRQUMxRCxJQUFJQSxNQUFNLElBQUksQ0FBQ3hwRyxRQUFRLENBQUN1cEcsc0JBQXNCLEdBQUdDO2FBQVUsT0FBTyxJQUFJLENBQUN4cEcsUUFBUSxDQUFDdXBHLHNCQUFzQjtRQUN0RyxPQUFPLElBQUksRUFBRSxXQUFXO0lBQzFCO0FBQ0Y7QUFFQSxVQUFVO0FBQ1ZuQyxTQUFTMW9ELE1BQU0sR0FBRzBvRCxTQUFTM29ELE1BQU07QUFFakMsMEJBQTBCO0FBQzFCMm9ELFNBQVNxQyxhQUFhLEdBQUdyQyxTQUFTL3BCLFFBQVE7QUFDMUMrcEIsU0FBU3NDLGtCQUFrQixHQUFHdEMsU0FBUzlwQixhQUFhO0FBRXBELElBQUlwK0UsS0FBSztJQUNQc2YsTUFBTSt5QyxPQUFPL3lDLElBQUksQ0FBQztRQUNoQjh2QyxPQUFPO1FBQ1BDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxjQUFjO1FBQ2RFLGNBQWM7UUFDZEMsc0JBQXNCO1FBQ3RCQyxlQUFlO1FBQ2ZILGNBQWM7UUFDZEssYUFBYTtJQUNmO0lBQ0FZLFlBQVk0QixPQUFPNUIsVUFBVSxDQUFDO1FBQzVCckIsT0FBTztRQUNQbHVELE9BQU87UUFDUHl1RCxlQUFlO1FBQ2ZlLGNBQWM7UUFDZGIsYUFBYTtJQUNmO0lBQ0E1dUMsU0FBU294QyxPQUFPL3lDLElBQUksQ0FBQztRQUNuQjh2QyxPQUFPO1FBQ1BDLGNBQWM7UUFDZEMsY0FBYztRQUNkQyxjQUFjO1FBQ2RFLGNBQWM7UUFDZEMsc0JBQXNCO1FBQ3RCQyxlQUFlO1FBQ2ZILGNBQWM7UUFDZEssYUFBYTtJQUNmO0lBQ0EyUSxlQUFlbk8sT0FBTzVCLFVBQVUsQ0FBQztRQUMvQnJCLE9BQU87UUFDUGx1RCxPQUFPO1FBQ1B5dUQsZUFBZTtRQUNmZSxjQUFjO1FBQ2RiLGFBQWE7SUFDZjtBQUNGO0FBRUEsVUFBVTtBQUNWN3ZELEdBQUd1MEMsSUFBSSxHQUFHdjBDLEdBQUdzZixJQUFJO0FBQ2pCdGYsR0FBRzBnRSxVQUFVLEdBQUcxZ0UsR0FBR3l3RCxVQUFVO0FBRTdCLElBQUlnNkMsT0FBTyxTQUFTQSxLQUFLNXRGLElBQUk7SUFDM0IsSUFBSXFDLEtBQUssSUFBSTtJQUNickMsT0FBTzNZLE9BQU8sQ0FBQyxHQUFHMlk7SUFDbEIsSUFBSTZ6RSxZQUFZN3pFLEtBQUs2ekUsU0FBUztJQUU5Qiw0Q0FBNEM7SUFDNUMsMENBQTBDO0lBQzFDLElBQUlBLGFBQWEsQ0FBQy92RixZQUFZK3ZGLGNBQWMvdkYsWUFBWSt2RixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3JFQSxZQUFZQSxTQUFTLENBQUMsRUFBRTtJQUMxQjtJQUNBLElBQUlnYSxNQUFNaGEsWUFBWUEsVUFBVUMsTUFBTSxHQUFHLE1BQU0sOERBQThEO0lBQzdHK1osTUFBTUEsT0FBTyxDQUFDO0lBQ2QsSUFBSUEsT0FBT0EsSUFBSXhyRixFQUFFLEVBQUU7UUFDakJ3ckYsSUFBSXhyRixFQUFFLENBQUN5ckYsT0FBTztRQUNkRCxNQUFNLENBQUMsR0FBRyx5Q0FBeUM7SUFDckQ7SUFDQSxJQUFJRSxVQUFVRixJQUFJRSxPQUFPLEdBQUdGLElBQUlFLE9BQU8sSUFBSSxFQUFFO0lBQzdDLElBQUlsYSxXQUFXO1FBQ2JBLFVBQVVDLE1BQU0sR0FBRytaO0lBQ3JCLEVBQUUsb0RBQW9EO0lBQ3REQSxJQUFJeHJGLEVBQUUsR0FBR0E7SUFDVCxJQUFJMnJGLE9BQU8zckcsWUFBWVIsYUFBYWd5RixjQUFjaHlGLGFBQWEsQ0FBQ21lLEtBQUtncEQsUUFBUTtJQUM3RSxJQUFJcDJELFVBQVVvTjtJQUNkcE4sUUFBUXloRSxNQUFNLEdBQUdodEUsT0FBTztRQUN0QmxGLE1BQU02ckcsT0FBTyxTQUFTO0lBQ3hCLEdBQUdwN0YsUUFBUXloRSxNQUFNO0lBQ2pCemhFLFFBQVFnNkQsUUFBUSxHQUFHdmxFLE9BQU87UUFDeEJsRixNQUFNNnJHLE9BQU8sV0FBVztJQUMxQixHQUFHcDdGLFFBQVFnNkQsUUFBUTtJQUNuQixJQUFJcWhDLFNBQVMsU0FBU0EsT0FBT0MsR0FBRyxFQUFFbHRGLEdBQUcsRUFBRW10RixNQUFNO1FBQzNDLElBQUludEYsUUFBUW5mLFdBQVc7WUFDckIsT0FBT21mO1FBQ1QsT0FBTyxJQUFJbXRGLFdBQVd0c0csV0FBVztZQUMvQixPQUFPc3NHO1FBQ1QsT0FBTztZQUNMLE9BQU9EO1FBQ1Q7SUFDRjtJQUNBLElBQUl0ckYsS0FBSyxJQUFJLENBQUMzZSxRQUFRLEdBQUc7UUFDdkI0dkYsV0FBV0E7UUFDWCx5QkFBeUI7UUFDekJ6VyxPQUFPO1FBQ1AsbUNBQW1DO1FBQ25DeHFFLFNBQVNBO1FBQ1QsaUJBQWlCO1FBQ2pCZ3dELFVBQVUsSUFBSXdpQixXQUFXLElBQUk7UUFDN0Isd0JBQXdCO1FBQ3hCbGlFLFdBQVcsRUFBRTtRQUNiLG9CQUFvQjtRQUNwQm1zRSxTQUFTLElBQUlqSyxXQUFXLElBQUk7UUFDNUIsMEJBQTBCO1FBQzFCM2lFLE1BQU03UCxRQUFRNlAsSUFBSSxJQUFJLENBQUM7UUFDdkIsb0JBQW9CO1FBQ3BCMkIsU0FBUyxDQUFDO1FBQ1YsMEJBQTBCO1FBQzFCaXdELFFBQVE7UUFDUnpILFVBQVU7UUFDVjRrQixXQUFXO1FBQ1gsNkJBQTZCO1FBQzdCRCxzQkFBc0I7UUFDdEIsaURBQWlEO1FBQ2pEekMsU0FBUztRQUNUQyxTQUFTO1FBQ1QyYyxnQkFBZ0J1QyxPQUFPLE1BQU1yN0YsUUFBUTg0RixjQUFjO1FBQ25EQyxvQkFBb0JzQyxPQUFPLE1BQU1yN0YsUUFBUSs0RixrQkFBa0I7UUFDM0RILGdCQUFnQnlDLE9BQU8sTUFBTXI3RixRQUFRNDRGLGNBQWM7UUFDbkRDLG9CQUFvQndDLE9BQU8sTUFBTXI3RixRQUFRNjRGLGtCQUFrQjtRQUMzREcscUJBQXFCcUMsT0FBTyxNQUFNcjdGLFFBQVFnNUYsbUJBQW1CO1FBQzdEdHFCLFVBQVUyc0IsT0FBTyxPQUFPcjdGLFFBQVEwdUUsUUFBUSxFQUFFMXVFLFFBQVE4NkYsYUFBYTtRQUMvRG5zQixlQUFlMHNCLE9BQU8sT0FBT3I3RixRQUFRMnVFLGFBQWEsRUFBRTN1RSxRQUFRKzZGLGtCQUFrQjtRQUM5RW5zQixpQkFBaUJ5c0IsT0FBTyxPQUFPcjdGLFFBQVE0dUUsZUFBZTtRQUN0RDcvQixjQUFjL3VDLFFBQVErdUMsWUFBWSxLQUFLOS9DLFlBQVltc0csT0FBT3A3RixRQUFRK3VDLFlBQVk7UUFDOUVyOEIsTUFBTTloQixTQUFTb1AsUUFBUTBTLElBQUksSUFBSTFTLFFBQVEwUyxJQUFJLEdBQUc7UUFDOUNELEtBQUs7WUFDSGpTLEdBQUc5UCxZQUFZc1AsUUFBUXlTLEdBQUcsS0FBSzdoQixTQUFTb1AsUUFBUXlTLEdBQUcsQ0FBQ2pTLENBQUMsSUFBSVIsUUFBUXlTLEdBQUcsQ0FBQ2pTLENBQUMsR0FBRztZQUN6RXlKLEdBQUd2WixZQUFZc1AsUUFBUXlTLEdBQUcsS0FBSzdoQixTQUFTb1AsUUFBUXlTLEdBQUcsQ0FBQ3hJLENBQUMsSUFBSWpLLFFBQVF5UyxHQUFHLENBQUN4SSxDQUFDLEdBQUc7UUFDM0U7UUFDQW1ILFdBQVc7WUFDVCwwQ0FBMEM7WUFDMUNDLFNBQVMsRUFBRTtZQUNYQyxPQUFPLEVBQUU7UUFDWDtRQUNBZy9DLGtCQUFrQjtRQUNsQnNxQyx3QkFBd0JTLE9BQU8sS0FBS3I3RixRQUFRNDZGLHNCQUFzQjtJQUNwRTtJQUNBLElBQUksQ0FBQy9uRixhQUFhO0lBRWxCLHFCQUFxQjtJQUNyQixJQUFJLENBQUM2bEYsYUFBYSxDQUFDMTRGLFFBQVEwNEYsYUFBYTtJQUV4QyxtQkFBbUI7SUFDbkIsSUFBSSxDQUFDVyxTQUFTLENBQUM7UUFDYnR6RixLQUFLL0YsUUFBUWs4RSxPQUFPO1FBQ3BCcjJFLEtBQUs3RixRQUFRbThFLE9BQU87SUFDdEI7SUFDQSxJQUFJcWYsY0FBYyxTQUFTQSxZQUFZQyxPQUFPLEVBQUV2dEcsSUFBSTtRQUNsRCxJQUFJd3RHLGVBQWVELFFBQVE1MkQsSUFBSSxDQUFDM3lDO1FBQ2hDLElBQUl3cEcsY0FBYztZQUNoQixPQUFPcnZELFVBQVVqNkIsR0FBRyxDQUFDcXBGLFNBQVN0cEcsSUFBSSxDQUFDakUsT0FBTyx1REFBdUQ7UUFDbkcsT0FBTztZQUNMQSxLQUFLdXRHLFVBQVUscUNBQXFDO1FBQ3REO0lBQ0Y7SUFFQSwrRkFBK0Y7SUFDL0YsSUFBSXpyRixHQUFHKytCLFlBQVksRUFBRTtRQUNuQnQvQixHQUFHNm9GLFFBQVEsQ0FBQyxFQUFFO0lBQ2hCO0lBRUEsc0JBQXNCO0lBQ3RCLElBQUlxRCxrQkFBa0JsbkcsT0FBTyxDQUFDLEdBQUd1TCxTQUFTQSxRQUFRZzZELFFBQVEsR0FBRyw2Q0FBNkM7SUFDMUd2cUQsR0FBR214RSxZQUFZLENBQUMrYTtJQUNoQixJQUFJQyxtQkFBbUIsU0FBU0EsaUJBQWlCNXJDLFFBQVEsRUFBRTZyQyxNQUFNLEVBQUVDLE1BQU07UUFDdkVyc0YsR0FBR292RSxhQUFhLENBQUM7UUFFakIsc0JBQXNCO1FBQ3RCLElBQUlrZCxVQUFVdHNGLEdBQUd3MUQsZUFBZTtRQUNoQyxJQUFJODJCLFFBQVE3dkcsTUFBTSxHQUFHLEdBQUc7WUFDdEI2dkcsUUFBUWgzQixNQUFNO1FBQ2hCO1FBQ0EsSUFBSS9VLFlBQVksTUFBTTtZQUNwQixJQUFJdC9ELFlBQVlzL0QsYUFBYXgvRCxNQUFNdy9ELFdBQVc7Z0JBQzVDdmdELEdBQUdSLEdBQUcsQ0FBQytnRDtZQUNUO1FBQ0Y7UUFDQXZnRCxHQUFHK3pELEdBQUcsQ0FBQyxlQUFlLFNBQVVyM0UsQ0FBQztZQUMvQnNqQixHQUFHb3ZFLGFBQWEsQ0FBQztZQUNqQnB2RSxHQUFHNHlDLElBQUksQ0FBQ2wyRCxJQUFJLG1FQUFtRTtZQUUvRXNqQixHQUFHK3pELEdBQUcsQ0FBQyxRQUFRcTRCO1lBQ2Zwc0YsR0FBR3NrRCxhQUFhLENBQUM7UUFDbkIsR0FBR3lQLEdBQUcsQ0FBQyxjQUFjO1lBQ25CL3pELEdBQUcrekQsR0FBRyxDQUFDLFFBQVFzNEI7WUFDZnJzRixHQUFHNHlDLElBQUksQ0FBQztRQUNWO1FBQ0EsSUFBSTI1QyxhQUFhdm5HLE9BQU8sQ0FBQyxHQUFHZ2IsR0FBR3BlLFFBQVEsQ0FBQzJPLE9BQU8sQ0FBQ3loRSxNQUFNO1FBQ3REdTZCLFdBQVd6aUYsSUFBSSxHQUFHOUosR0FBR3VnRCxRQUFRO1FBQzdCdmdELEdBQUdneUQsTUFBTSxDQUFDdTZCLFlBQVl2dEQsR0FBRztJQUMzQjtJQUNBK3NELFlBQVk7UUFBQ3g3RixRQUFRdVEsS0FBSztRQUFFdlEsUUFBUWd3RCxRQUFRO0tBQUMsRUFBRSxTQUFVaXNDLEtBQUs7UUFDNUQsSUFBSUMsWUFBWUQsS0FBSyxDQUFDLEVBQUU7UUFDeEIsSUFBSUUsV0FBV0YsS0FBSyxDQUFDLEVBQUU7UUFFdkIsYUFBYTtRQUNiLElBQUlqc0YsR0FBRysrQixZQUFZLEVBQUU7WUFDbkJ0L0IsR0FBR2MsS0FBSyxHQUFHMm5GLE1BQU0sQ0FBQ2dFO1FBQ3BCO1FBRUEsZUFBZTtRQUNmTixpQkFBaUJPLFVBQVU7WUFDekIsVUFBVTtZQUNWMXNGLEdBQUc2dEUsa0JBQWtCO1lBQ3JCdHRFLEdBQUd3NkQsS0FBSyxHQUFHO1lBRVgsNkRBQTZEO1lBQzdELElBQUluNkUsS0FBSzJQLFFBQVF3cUUsS0FBSyxHQUFHO2dCQUN2Qi82RCxHQUFHc3hDLEVBQUUsQ0FBQyxTQUFTL2dELFFBQVF3cUUsS0FBSztZQUM5QjtZQUVBLHVFQUF1RTtZQUN2RSxJQUFLLElBQUkvN0UsSUFBSSxHQUFHQSxJQUFJMHNHLFFBQVFqdkcsTUFBTSxFQUFFdUMsSUFBSztnQkFDdkMsSUFBSThCLEtBQUs0cUcsT0FBTyxDQUFDMXNHLEVBQUU7Z0JBQ25CZ2hCLEdBQUdzeEMsRUFBRSxDQUFDLFNBQVN4d0Q7WUFDakI7WUFDQSxJQUFJMHFHLEtBQUs7Z0JBQ1BBLElBQUlFLE9BQU8sR0FBRyxFQUFFO1lBQ2xCLEVBQUUsMkdBQTJHO1lBRTdHMXJGLEdBQUc0eUMsSUFBSSxDQUFDO1FBQ1YsR0FBR3JpRCxRQUFRblMsSUFBSTtJQUNqQjtBQUNGO0FBQ0EsSUFBSXV1RyxTQUFTcEIsS0FBSzF0RyxTQUFTLEVBQUUsY0FBYztBQUUzQ21ILE9BQU8ybkcsUUFBUTtJQUNiaHNHLGdCQUFnQixTQUFTQTtRQUN2QixPQUFPO0lBQ1Q7SUFDQWlzRyxTQUFTLFNBQVNBO1FBQ2hCLE9BQU8sSUFBSSxDQUFDaHJHLFFBQVEsQ0FBQ201RSxLQUFLO0lBQzVCO0lBQ0FvVSxXQUFXLFNBQVNBO1FBQ2xCLE9BQU8sSUFBSSxDQUFDdnRGLFFBQVEsQ0FBQ3V0RixTQUFTO0lBQ2hDO0lBQ0FwVSxPQUFPLFNBQVNBLE1BQU1qNkUsRUFBRTtRQUN0QixJQUFJLElBQUksQ0FBQzhyRyxPQUFPLElBQUk7WUFDbEIsSUFBSSxDQUFDNzNCLE9BQU8sR0FBR25pQixJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUU5eEQsS0FBSyxvREFBb0Q7UUFDNUYsT0FBTztZQUNMLElBQUksQ0FBQ3d3RCxFQUFFLENBQUMsU0FBU3h3RDtRQUNuQjtRQUNBLE9BQU8sSUFBSTtJQUNiO0lBQ0EycUcsU0FBUyxTQUFTQTtRQUNoQixJQUFJenJGLEtBQUssSUFBSTtRQUNiLElBQUlBLEdBQUdtdkUsU0FBUyxJQUFJO1FBQ3BCbnZFLEdBQUcydEUsaUJBQWlCO1FBQ3BCM3RFLEdBQUdzeEUsZUFBZTtRQUNsQixJQUFJLENBQUMxK0IsSUFBSSxDQUFDO1FBQ1Y1eUMsR0FBR3BlLFFBQVEsQ0FBQ3V0RixTQUFTLEdBQUc7UUFDeEIsT0FBT252RTtJQUNUO0lBQ0FnTyxrQkFBa0IsU0FBU0EsaUJBQWlCdkosRUFBRTtRQUM1QyxPQUFPLElBQUksQ0FBQzdpQixRQUFRLENBQUMyK0QsUUFBUSxDQUFDdnlDLGdCQUFnQixDQUFDdko7SUFDakQ7SUFDQXFuQixnQkFBZ0IsU0FBU0EsZUFBZXJuQixFQUFFO1FBQ3hDLE9BQU8sSUFBSSxDQUFDN2lCLFFBQVEsQ0FBQzIrRCxRQUFRLENBQUN6MEIsY0FBYyxDQUFDcm5CO0lBQy9DO0lBQ0FvOEMsa0JBQWtCLFNBQVNBO1FBQ3pCLE9BQU8sSUFBSSxDQUFDai9ELFFBQVEsQ0FBQ2kvRCxnQkFBZ0I7SUFDdkM7SUFDQThGLFVBQVUsU0FBU0E7UUFDakIsT0FBTyxJQUFJLENBQUMva0UsUUFBUSxDQUFDMm9FLFFBQVEsQ0FBQ3NpQyxVQUFVO0lBQzFDO0lBQ0F2dEQsY0FBYyxTQUFTQTtRQUNyQixPQUFPLElBQUksQ0FBQzE5QyxRQUFRLENBQUMwOUMsWUFBWTtJQUNuQztJQUNBOGtDLFdBQVcsU0FBU0EsVUFBVXQ2RCxJQUFJO1FBQ2hDLElBQUksQ0FBQ2xvQixRQUFRLENBQUMyK0QsUUFBUSxDQUFDajBDLEtBQUssQ0FBQ3hDO1FBQzdCLE9BQU8sSUFBSSxFQUFFLFdBQVc7SUFDMUI7SUFDQXE3RCxnQkFBZ0IsU0FBU0EsZUFBZXI3RCxJQUFJO1FBQzFDLElBQUksQ0FBQ2xvQixRQUFRLENBQUMyK0QsUUFBUSxDQUFDb1csT0FBTyxDQUFDN3NEO1FBQy9CLE9BQU8sSUFBSTtJQUNiO0lBQ0EwbkUsV0FBVyxTQUFTQTtRQUNsQixPQUFPLElBQUksQ0FBQzV2RixRQUFRLENBQUM0dkYsU0FBUyxJQUFJO0lBQ3BDO0lBQ0F2eEYsUUFBUSxTQUFTQTtRQUNmLElBQUl1eEYsWUFBWSxJQUFJLENBQUM1dkYsUUFBUSxDQUFDNHZGLFNBQVM7UUFDdkMsSUFBSUEsYUFBYSxNQUFNLE9BQU94eEY7UUFDOUIsSUFBSThzRyxnQkFBZ0IsSUFBSSxDQUFDbHJHLFFBQVEsQ0FBQzR2RixTQUFTLENBQUNzYixhQUFhO1FBQ3pELElBQUlBLGtCQUFrQnR0RyxhQUFhc3RHLGlCQUFpQixNQUFNO1lBQ3hELE9BQU85c0c7UUFDVDtRQUNBLE9BQU84c0csY0FBY0MsV0FBVyxJQUFJL3NHO0lBQ3RDO0lBQ0FndEcsT0FBTyxTQUFTQSxNQUFNeGIsU0FBUztRQUM3QixJQUFJQSxhQUFhLE1BQU07WUFDckI7UUFDRjtRQUNBLElBQUl4eEUsS0FBSyxJQUFJO1FBQ2IsSUFBSU8sS0FBS1AsR0FBR3BlLFFBQVE7UUFDcEIsSUFBSTJPLFVBQVVnUSxHQUFHaFEsT0FBTztRQUN4QixJQUFJLENBQUM5TyxZQUFZK3ZGLGNBQWMvdkYsWUFBWSt2RixTQUFTLENBQUMsRUFBRSxHQUFHO1lBQ3hEQSxZQUFZQSxTQUFTLENBQUMsRUFBRTtRQUMxQjtRQUNBeHhFLEdBQUcydEUsaUJBQWlCO1FBQ3BCM3RFLEdBQUdzeEUsZUFBZTtRQUNsQi93RSxHQUFHaXhFLFNBQVMsR0FBR0E7UUFDZmp4RSxHQUFHKytCLFlBQVksR0FBRztRQUNsQnQvQixHQUFHa3hFLGNBQWM7UUFDakJseEUsR0FBR214RSxZQUFZLENBQUNuc0YsT0FBTyxDQUFDLEdBQUd1TCxTQUFTQSxRQUFRZzZELFFBQVEsRUFBRTtZQUNwRCxpRUFBaUU7WUFDakV6cUUsTUFBTXlRLFFBQVFnNkQsUUFBUSxDQUFDenFFLElBQUksS0FBSyxTQUFTLFdBQVd5USxRQUFRZzZELFFBQVEsQ0FBQ3pxRSxJQUFJO1FBQzNFO1FBQ0FrZ0IsR0FBRzZ0RSxrQkFBa0I7UUFDckI3dEUsR0FBR2MsS0FBSyxDQUFDdlEsUUFBUXVRLEtBQUs7UUFDdEJkLEdBQUc0eUMsSUFBSSxDQUFDO1FBQ1IsT0FBTzV5QztJQUNUO0lBQ0FpdEYsU0FBUyxTQUFTQTtRQUNoQixJQUFJanRGLEtBQUssSUFBSTtRQUNiQSxHQUFHMnRFLGlCQUFpQjtRQUNwQjN0RSxHQUFHc3hFLGVBQWU7UUFDbEJ0eEUsR0FBR214RSxZQUFZLENBQUM7WUFDZHJ4RixNQUFNO1FBQ1I7UUFDQWtnQixHQUFHNHlDLElBQUksQ0FBQztRQUNSLE9BQU81eUM7SUFDVDtJQUNBelAsU0FBUyxTQUFTQTtRQUNoQixPQUFPME0sS0FBSyxJQUFJLENBQUNyYixRQUFRLENBQUMyTyxPQUFPO0lBQ25DO0lBQ0E0eUUsTUFBTSxTQUFTQSxLQUFLemlGLEdBQUc7UUFDckIsSUFBSXNmLEtBQUssSUFBSTtRQUNiLElBQUlPLEtBQUtQLEdBQUdwZSxRQUFRO1FBQ3BCLElBQUlrb0IsT0FBTzlKLEdBQUd3MUQsZUFBZTtRQUM3QixJQUFJMDNCLGNBQWMsU0FBU0EsWUFBWW52RixHQUFHO1lBQ3hDLE9BQU9pQyxHQUFHOHJCLGNBQWMsQ0FBQy90QixJQUFJMEcsRUFBRTtRQUNqQztRQUNBLElBQUl4akIsWUFBWVAsTUFBTTtZQUNwQixNQUFNO1lBRU5zZixHQUFHZ2pELFVBQVU7WUFDYixJQUFJdGlFLElBQUk2L0QsUUFBUSxFQUFFO2dCQUNoQixJQUFJNHNDLFdBQVcsQ0FBQztnQkFDaEIsSUFBSUMsYUFBYSxTQUFTQSxXQUFXbHBCLEtBQUssRUFBRW1wQixFQUFFO29CQUM1QyxJQUFJbjNCLFFBQVEsRUFBRTtvQkFDZCxJQUFJbzNCLFFBQVEsRUFBRTtvQkFDZCxJQUFLLElBQUl0dUcsSUFBSSxHQUFHQSxJQUFJa2xGLE1BQU16bkYsTUFBTSxFQUFFdUMsSUFBSzt3QkFDckMsSUFBSW1rRixPQUFPZSxLQUFLLENBQUNsbEYsRUFBRTt3QkFDbkIsSUFBSSxDQUFDbWtGLEtBQUsvaUUsSUFBSSxDQUFDcUUsRUFBRSxFQUFFOzRCQUNqQnpJLEtBQUs7NEJBQ0w7d0JBQ0Y7d0JBQ0EsSUFBSXlJLEtBQUssS0FBSzArRCxLQUFLL2lFLElBQUksQ0FBQ3FFLEVBQUUsRUFBRSxvQkFBb0I7d0JBQ2hELElBQUkxRyxNQUFNaUMsR0FBRzhyQixjQUFjLENBQUNybkI7d0JBQzVCMG9GLFFBQVEsQ0FBQzFvRixHQUFHLEdBQUc7d0JBQ2YsSUFBSTFHLElBQUl0aEIsTUFBTSxLQUFLLEdBQUc7NEJBQ3BCLHFDQUFxQzs0QkFDckM2d0csTUFBTXJ1RyxJQUFJLENBQUM7Z0NBQ1Q4ZSxLQUFLQTtnQ0FDTG9sRSxNQUFNQTs0QkFDUjt3QkFDRixPQUFPOzRCQUNMLDRCQUE0Qjs0QkFDNUIsSUFBSWtxQixJQUFJO2dDQUNObHFCLEtBQUtoakUsS0FBSyxHQUFHa3RGO2dDQUNibjNCLE1BQU1qM0UsSUFBSSxDQUFDa2tGOzRCQUNiLE9BQU87Z0NBQ0xqTixNQUFNajNFLElBQUksQ0FBQ2trRjs0QkFDYjt3QkFDRjtvQkFDRjtvQkFDQW5qRSxHQUFHUixHQUFHLENBQUMwMkQ7b0JBQ1AsSUFBSyxJQUFJeHdELEtBQUssR0FBR0EsS0FBSzRuRixNQUFNN3dHLE1BQU0sRUFBRWlwQixLQUFNO3dCQUN4QyxJQUFJNm5GLFlBQVlELEtBQUssQ0FBQzVuRixHQUFHLEVBQ3ZCMnJDLE9BQU9rOEMsVUFBVXh2RixHQUFHLEVBQ3BCdXBFLFFBQVFpbUIsVUFBVXBxQixJQUFJO3dCQUN4Qjl4QixLQUFLOHhCLElBQUksQ0FBQ21FO29CQUNaO2dCQUNGO2dCQUNBLElBQUl2bUYsTUFBTUwsSUFBSTYvRCxRQUFRLEdBQUc7b0JBQ3ZCLGVBQWU7b0JBQ2Y2c0MsV0FBVzFzRyxJQUFJNi9ELFFBQVE7Z0JBQ3pCLE9BQU87b0JBQ0wscUNBQXFDO29CQUNyQyxJQUFJNG1CLE1BQU07d0JBQUM7d0JBQVM7cUJBQVE7b0JBQzVCLElBQUssSUFBSW5vRixJQUFJLEdBQUdBLElBQUltb0YsSUFBSTFxRixNQUFNLEVBQUV1QyxJQUFLO3dCQUNuQyxJQUFJcXVHLEtBQUtsbUIsR0FBRyxDQUFDbm9GLEVBQUU7d0JBQ2YsSUFBSXVoRSxXQUFXNy9ELElBQUk2L0QsUUFBUSxDQUFDOHNDLEdBQUc7d0JBQy9CLElBQUl0c0csTUFBTXcvRCxXQUFXOzRCQUNuQjZzQyxXQUFXN3NDLFVBQVU4c0M7d0JBQ3ZCO29CQUNGO2dCQUNGO2dCQUNBLElBQUlHLGtCQUFrQnh0RixHQUFHcmUsVUFBVTtnQkFDbkNtb0IsS0FBS3BLLE1BQU0sQ0FBQyxTQUFVM0IsR0FBRztvQkFDdkIsT0FBTyxDQUFDb3ZGLFFBQVEsQ0FBQ3B2RixJQUFJMEcsRUFBRSxHQUFHO2dCQUM1QixHQUFHOUUsT0FBTyxDQUFDLFNBQVU1QixHQUFHO29CQUN0QixJQUFJQSxJQUFJaTVDLFFBQVEsSUFBSTt3QkFDbEJ3MkMsZ0JBQWdCbGhGLEtBQUssQ0FBQ3ZPO29CQUN4QixPQUFPO3dCQUNMQSxJQUFJdTNELE1BQU07b0JBQ1o7Z0JBQ0Y7Z0JBRUEsNENBQTRDO2dCQUM1Q2s0QixnQkFBZ0I3dEYsT0FBTyxDQUFDLFNBQVU1QixHQUFHO29CQUNuQyxPQUFPQSxJQUFJa0UsUUFBUSxHQUFHMmhFLElBQUksQ0FBQzt3QkFDekIxaEUsUUFBUTtvQkFDVjtnQkFDRjtnQkFFQSx3RkFBd0Y7Z0JBQ3hGc3JGLGdCQUFnQjd0RixPQUFPLENBQUMsU0FBVTVCLEdBQUc7b0JBQ25DLE9BQU9tdkYsWUFBWW52RixLQUFLdTNELE1BQU07Z0JBQ2hDO1lBQ0Y7WUFDQSxJQUFJNTBFLElBQUlvZ0IsS0FBSyxFQUFFO2dCQUNiZCxHQUFHYyxLQUFLLENBQUNwZ0IsSUFBSW9nQixLQUFLO1lBQ3BCO1lBQ0EsSUFBSXBnQixJQUFJdWlCLElBQUksSUFBSSxRQUFRdmlCLElBQUl1aUIsSUFBSSxLQUFLMUMsR0FBRzBDLElBQUksRUFBRTtnQkFDNUNqRCxHQUFHaUQsSUFBSSxDQUFDdmlCLElBQUl1aUIsSUFBSTtZQUNsQjtZQUNBLElBQUl2aUIsSUFBSXNpQixHQUFHLEVBQUU7Z0JBQ1gsSUFBSXRpQixJQUFJc2lCLEdBQUcsQ0FBQ2pTLENBQUMsS0FBS3dQLEdBQUd5QyxHQUFHLENBQUNqUyxDQUFDLElBQUlyUSxJQUFJc2lCLEdBQUcsQ0FBQ3hJLENBQUMsS0FBSytGLEdBQUd5QyxHQUFHLENBQUN4SSxDQUFDLEVBQUU7b0JBQ3BEd0YsR0FBR2dELEdBQUcsQ0FBQ3RpQixJQUFJc2lCLEdBQUc7Z0JBQ2hCO1lBQ0Y7WUFDQSxJQUFJdGlCLElBQUkwZixJQUFJLEVBQUU7Z0JBQ1pKLEdBQUdJLElBQUksQ0FBQzFmLElBQUkwZixJQUFJO1lBQ2xCO1lBQ0EsSUFBSW9rRSxTQUFTO2dCQUFDO2dCQUFXO2dCQUFXO2dCQUFrQjtnQkFBc0I7Z0JBQWtCO2dCQUFzQjtnQkFBdUI7Z0JBQVk7Z0JBQWlCO2dCQUFtQjthQUF5QjtZQUNwTixJQUFLLElBQUlsL0QsTUFBTSxHQUFHQSxNQUFNay9ELE9BQU8vbkYsTUFBTSxFQUFFNm9CLE1BQU87Z0JBQzVDLElBQUlobkIsSUFBSWttRixNQUFNLENBQUNsL0QsSUFBSTtnQkFDbkIsSUFBSTVrQixHQUFHLENBQUNwQyxFQUFFLElBQUksTUFBTTtvQkFDbEIwaEIsRUFBRSxDQUFDMWhCLEVBQUUsQ0FBQ29DLEdBQUcsQ0FBQ3BDLEVBQUU7Z0JBQ2Q7WUFDRjtZQUNBMGhCLEdBQUdrakQsUUFBUTtZQUNYLE9BQU8sSUFBSSxFQUFFLFdBQVc7UUFDMUIsT0FBTztZQUNMLE1BQU07WUFDTixJQUFJdXFDLE9BQU8sQ0FBQyxDQUFDL3NHO1lBQ2IsSUFBSXlpRixPQUFPLENBQUM7WUFDWixJQUFJc3FCLE1BQU07Z0JBQ1J0cUIsS0FBSzVpQixRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLEdBQUcvdkQsR0FBRyxDQUFDLFNBQVV1TixHQUFHO29CQUMvQyxPQUFPQSxJQUFJb2xFLElBQUk7Z0JBQ2pCO1lBQ0YsT0FBTztnQkFDTEEsS0FBSzVpQixRQUFRLEdBQUcsQ0FBQztnQkFDakJ6MkMsS0FBS25LLE9BQU8sQ0FBQyxTQUFVNUIsR0FBRztvQkFDeEIsSUFBSW9DLFFBQVFwQyxJQUFJb0MsS0FBSztvQkFDckIsSUFBSSxDQUFDZ2pFLEtBQUs1aUIsUUFBUSxDQUFDcGdELE1BQU0sRUFBRTt3QkFDekJnakUsS0FBSzVpQixRQUFRLENBQUNwZ0QsTUFBTSxHQUFHLEVBQUU7b0JBQzNCO29CQUNBZ2pFLEtBQUs1aUIsUUFBUSxDQUFDcGdELE1BQU0sQ0FBQ2xoQixJQUFJLENBQUM4ZSxJQUFJb2xFLElBQUk7Z0JBQ3BDO1lBQ0Y7WUFDQSxJQUFJLElBQUksQ0FBQ3ZoRixRQUFRLENBQUMwOUMsWUFBWSxFQUFFO2dCQUM5QjZqQyxLQUFLcmlFLEtBQUssR0FBR2QsR0FBR2MsS0FBSyxHQUFHcWlFLElBQUk7WUFDOUI7WUFDQUEsS0FBSy9pRSxJQUFJLEdBQUduRCxLQUFLK0MsR0FBR0ksSUFBSTtZQUN4QixJQUFJN1AsVUFBVWdRLEdBQUdoUSxPQUFPO1lBQ3hCNHlFLEtBQUtrbUIsY0FBYyxHQUFHOW9GLEdBQUc4b0YsY0FBYztZQUN2Q2xtQixLQUFLbW1CLGtCQUFrQixHQUFHL29GLEdBQUcrb0Ysa0JBQWtCO1lBQy9Dbm1CLEtBQUtsZ0UsSUFBSSxHQUFHMUMsR0FBRzBDLElBQUk7WUFDbkJrZ0UsS0FBS3NKLE9BQU8sR0FBR2xzRSxHQUFHa3NFLE9BQU87WUFDekJ0SixLQUFLdUosT0FBTyxHQUFHbnNFLEdBQUdtc0UsT0FBTztZQUN6QnZKLEtBQUtnbUIsY0FBYyxHQUFHNW9GLEdBQUc0b0YsY0FBYztZQUN2Q2htQixLQUFLaW1CLGtCQUFrQixHQUFHN29GLEdBQUc2b0Ysa0JBQWtCO1lBQy9Dam1CLEtBQUtuZ0UsR0FBRyxHQUFHL0YsS0FBS3NELEdBQUd5QyxHQUFHO1lBQ3RCbWdFLEtBQUtvbUIsbUJBQW1CLEdBQUdocEYsR0FBR2dwRixtQkFBbUI7WUFDakRwbUIsS0FBSzVZLFFBQVEsR0FBR3R0RCxLQUFLMU0sUUFBUWc2RCxRQUFRO1lBQ3JDNFksS0FBS3VNLG1CQUFtQixHQUFHbi9FLFFBQVFtL0UsbUJBQW1CO1lBQ3REdk0sS0FBS3dNLGlCQUFpQixHQUFHcC9FLFFBQVFvL0UsaUJBQWlCO1lBQ2xEeE0sS0FBSzhNLGdCQUFnQixHQUFHMS9FLFFBQVEwL0UsZ0JBQWdCO1lBQ2hEOU0sS0FBS3lNLFVBQVUsR0FBR3IvRSxRQUFRcS9FLFVBQVU7WUFDcEN6TSxLQUFLZ29CLHNCQUFzQixHQUFHNTZGLFFBQVE0NkYsc0JBQXNCO1lBQzVELE9BQU9ob0I7UUFDVDtJQUNGO0FBQ0Y7QUFDQXdwQixPQUFPanBCLEdBQUcsR0FBR2lwQixPQUFPN2dFLGNBQWM7QUFDbEM7SUFBQ2k3QztJQUFVMkc7SUFBVVc7SUFBUUM7SUFBVUs7SUFBVUc7SUFBVStCO0lBQVVrQjtJQUFVNFc7SUFBVUs7SUFBVWxvRztDQUFHLENBQUM2ZSxPQUFPLENBQUMsU0FBVWk3QixLQUFLO0lBQzVINTFDLE9BQU8ybkcsUUFBUS94RDtBQUNqQjtBQUVBLGlDQUFpQyxHQUNqQyxJQUFJOHlELGFBQWE7SUFDZmp0RCxLQUFLO0lBQ0wsMkNBQTJDO0lBQzNDNzhCLFVBQVU7SUFDVix3RkFBd0Y7SUFDeEZpYixXQUFXO0lBQ1gsNElBQTRJO0lBQzVJcEgsU0FBUztJQUNULGlCQUFpQjtJQUNqQmsyRSxRQUFRO0lBQ1IseUVBQXlFO0lBQ3pFQyxNQUFNO0lBQ04sa0ZBQWtGO0lBQ2xGeHpCLGVBQWU7SUFDZiwyRkFBMkY7SUFDM0ZoNEUsYUFBYTVDO0lBQ2Isa0VBQWtFO0lBQ2xFcXVHLGNBQWM7SUFDZCxzRUFBc0U7SUFDdEV4MEIsNkJBQTZCO0lBQzdCLG1GQUFtRjtJQUNuRjExRCxPQUFPbmtCO0lBQ1AseUJBQXlCO0lBQ3pCc3VHLFdBQVd0dUc7SUFDWCxzSEFBc0g7SUFDdEhtZ0QsU0FBUztJQUNULDJDQUEyQztJQUMzQys2QixtQkFBbUI7SUFDbkIseUNBQXlDO0lBQ3pDRSxpQkFBaUJwN0U7SUFDakIsa0NBQWtDO0lBQ2xDaTdFLGVBQWUsU0FBU0EsY0FBYzkwRCxJQUFJLEVBQUUzbUIsQ0FBQztRQUMzQyxPQUFPO0lBQ1Q7SUFDQSwyTEFBMkw7SUFDM0wrN0UsT0FBT3Y3RTtJQUNQLDBCQUEwQjtJQUMxQisrQyxNQUFNLytDO0lBQ04seUJBQXlCO0lBQ3pCKzZFLFdBQVcsU0FBU0EsVUFBVTUwRCxJQUFJLEVBQUVuRixRQUFRO1FBQzFDLE9BQU9BO0lBQ1QsRUFBRSwwRkFBMEY7QUFDOUY7QUFDQSxJQUFJdXRGLDJCQUEyQjtJQUM3QkMsU0FBUztJQUNULHNKQUFzSjtJQUN0SkMsU0FBUyxNQUFNLHNSQUFzUjtBQUN2UztBQUVBLGlCQUFpQixHQUVqQixJQUFJbCtFLFVBQVUsU0FBU0EsUUFBUWhTLEdBQUc7SUFDaEMsT0FBT0EsSUFBSWdFLE9BQU8sQ0FBQztBQUNyQjtBQUNBLElBQUltc0YsVUFBVSxTQUFTQSxRQUFRbndGLEdBQUcsRUFBRXJkLEdBQUc7SUFDckMsT0FBT3FkLElBQUlnRSxPQUFPLENBQUMsZ0JBQWdCcmhCO0FBQ3JDO0FBQ0EsU0FBU3l0RyxtQkFBbUI1OUYsT0FBTztJQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBR3ZMLE9BQU8sQ0FBQyxHQUFHMG9HLFlBQVlLLDBCQUEwQng5RjtBQUNsRTtBQUNBNDlGLG1CQUFtQnR3RyxTQUFTLENBQUNtaEQsR0FBRyxHQUFHO0lBQ2pDLElBQUl6dUMsVUFBVSxJQUFJLENBQUNBLE9BQU87SUFDMUIsSUFBSXlQLEtBQUt6UCxRQUFReVAsRUFBRTtJQUNuQixJQUFJOEosT0FBT3ZaLFFBQVF1WixJQUFJO0lBQ3ZCLElBQUl4RixRQUFRd0YsS0FBS3hGLEtBQUssR0FBRzVFLE1BQU0sQ0FBQyxTQUFVL2lCLENBQUM7UUFDekMsT0FBT0EsRUFBRXM2RCxXQUFXO0lBQ3RCO0lBQ0EsSUFBSW0zQyxRQUFRdGtGO0lBQ1osSUFBSWxHLFdBQVdyVCxRQUFRcVQsUUFBUTtJQUMvQixJQUFJb3FGLFVBQVV6OUYsUUFBUTA5RixPQUFPLElBQUkxOUYsUUFBUXk5RixPQUFPLElBQUl6OUYsUUFBUTg5RixrQkFBa0IsR0FBRyxHQUFHLGlHQUFpRztJQUVyTCxJQUFJQyxpQkFBaUIsQ0FBQyxDQUFDLzlGLFFBQVFuTyxXQUFXO0lBQzFDLElBQUk2MEIsS0FBS0QsZ0JBQWdCczNFLGlCQUFpQi85RixRQUFRbk8sV0FBVyxHQUFHbXNHLGdCQUFnQnZ1RixHQUFHZ3JGLE1BQU07SUFDekYsSUFBSXJuRjtJQUNKLElBQUkzaUIsb0JBQW9CdVAsUUFBUW9ULEtBQUssR0FBRztRQUN0Q0EsUUFBUXBULFFBQVFvVCxLQUFLO0lBQ3ZCLE9BQU8sSUFBSTVpQixNQUFNd1AsUUFBUW9ULEtBQUssR0FBRztRQUMvQixJQUFJNnFGLGFBQWEsRUFBRTtRQUNuQixJQUFLLElBQUl4dkcsSUFBSSxHQUFHQSxJQUFJdVIsUUFBUW9ULEtBQUssQ0FBQ2xuQixNQUFNLEVBQUV1QyxJQUFLO1lBQzdDLElBQUl5bEIsS0FBS2xVLFFBQVFvVCxLQUFLLENBQUMza0IsRUFBRTtZQUN6QixJQUFJK2UsTUFBTWlDLEdBQUc4ckIsY0FBYyxDQUFDcm5CO1lBQzVCK3BGLFdBQVd2dkcsSUFBSSxDQUFDOGU7UUFDbEI7UUFDQTRGLFFBQVEzRCxHQUFHcmUsVUFBVSxDQUFDNnNHO0lBQ3hCLE9BQU8sSUFBSTN0RyxPQUFPMFAsUUFBUW9ULEtBQUssR0FBRztRQUNoQ0EsUUFBUTNELEdBQUdpUSxDQUFDLENBQUMxZixRQUFRb1QsS0FBSztJQUM1QixPQUFPO1FBQ0wsSUFBSUMsVUFBVTtZQUNaRCxRQUFRVyxNQUFNWCxLQUFLO1FBQ3JCLE9BQU87WUFDTCxJQUFJZ1IsYUFBYTdLLEtBQUs2SyxVQUFVO1lBQ2hDaFIsUUFBUTNELEdBQUdyZSxVQUFVO1lBQ3JCLElBQUlnakIsUUFBUSxTQUFTQTtnQkFDbkIsSUFBSThwRixPQUFPOTVFLFVBQVUsQ0FBQ2pQLEdBQUc7Z0JBQ3pCLElBQUlpakIsWUFBWThsRSxLQUFLOWxFLFNBQVMsQ0FBQztnQkFDL0IsSUFBSStsRSxZQUFZRCxLQUFLL3VGLE1BQU0sQ0FBQyxTQUFVM0IsR0FBRztvQkFDdkMsT0FBT0EsSUFBSStxQixNQUFNLENBQUMsV0FBV0g7Z0JBQy9CO2dCQUNBaGxCLFFBQVFBLE1BQU1uRSxHQUFHLENBQUNrdkY7WUFDcEI7WUFDQSxJQUFLLElBQUlocEYsS0FBSyxHQUFHQSxLQUFLaVAsV0FBV2w0QixNQUFNLEVBQUVpcEIsS0FBTTtnQkFDN0NmO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsSUFBSWdxRixTQUFTLEVBQUU7SUFDZixJQUFJQyxhQUFhLENBQUM7SUFDbEIsSUFBSUMsYUFBYSxTQUFTQSxXQUFXOXdGLEdBQUcsRUFBRXdNLENBQUM7UUFDekMsSUFBSW9rRixNQUFNLENBQUNwa0YsRUFBRSxJQUFJLE1BQU07WUFDckJva0YsTUFBTSxDQUFDcGtGLEVBQUUsR0FBRyxFQUFFO1FBQ2hCO1FBQ0EsSUFBSXZyQixJQUFJMnZHLE1BQU0sQ0FBQ3BrRixFQUFFLENBQUM5dEIsTUFBTTtRQUN4Qmt5RyxNQUFNLENBQUNwa0YsRUFBRSxDQUFDdHJCLElBQUksQ0FBQzhlO1FBQ2Ztd0YsUUFBUW53RixLQUFLO1lBQ1hwTCxPQUFPM1Q7WUFDUCtsQixPQUFPd0Y7UUFDVDtJQUNGO0lBQ0EsSUFBSXVrRixjQUFjLFNBQVNBLFlBQVkvd0YsR0FBRyxFQUFFZ3hGLFFBQVE7UUFDbEQsSUFBSTMrRSxXQUFXTCxRQUFRaFMsTUFDckJnSCxRQUFRcUwsU0FBU3JMLEtBQUssRUFDdEJwUyxRQUFReWQsU0FBU3pkLEtBQUs7UUFDeEJnOEYsTUFBTSxDQUFDNXBGLE1BQU0sQ0FBQ3BTLE1BQU0sR0FBRztRQUV2QiwyQkFBMkI7UUFDM0IsSUFBSW9MLElBQUlrNUMsV0FBVyxJQUFJNDNDLFdBQVc5d0YsS0FBS2d4RjtJQUN6QztJQUVBLCtCQUErQjtJQUMvQlgsTUFBTTVxRixHQUFHLENBQUM7UUFDUkcsT0FBT0E7UUFDUEMsVUFBVXJULFFBQVFxVCxRQUFRO1FBQzFCQyxPQUFPLFNBQVNBLE1BQU04QixJQUFJLEVBQUVDLElBQUksRUFBRW9wRixLQUFLLEVBQUVod0csQ0FBQyxFQUFFK2xCLEtBQUs7WUFDL0MsSUFBSWhILE1BQU00SCxJQUFJLENBQUMsRUFBRTtZQUNqQixJQUFJbEIsS0FBSzFHLElBQUkwRyxFQUFFO1lBRWYsMkJBQTJCO1lBQzNCLElBQUkxRyxJQUFJazVDLFdBQVcsSUFBSTQzQyxXQUFXOXdGLEtBQUtnSDtZQUN2QzZwRixVQUFVLENBQUNucUYsR0FBRyxHQUFHO1FBQ25CO0lBQ0Y7SUFFQSxtQ0FBbUM7SUFDbkMsSUFBSXdxRixjQUFjLEVBQUU7SUFDcEIsSUFBSyxJQUFJM3BGLE1BQU0sR0FBR0EsTUFBTWhCLE1BQU03bkIsTUFBTSxFQUFFNm9CLE1BQU87UUFDM0MsSUFBSStyQyxPQUFPL3NDLEtBQUssQ0FBQ2dCLElBQUk7UUFDckIsSUFBSXNwRixVQUFVLENBQUN2OUMsS0FBSzVzQyxFQUFFLEdBQUcsRUFBRTtZQUN6QjtRQUNGLE9BQU87WUFDTHdxRixZQUFZaHdHLElBQUksQ0FBQ295RDtRQUNuQjtJQUNGO0lBRUEscUNBQXFDO0lBQ3JDLElBQUk2OUMsaUJBQWlCLFNBQVNBLGVBQWVsd0csQ0FBQztRQUM1QyxJQUFJOHFCLE9BQU82a0YsTUFBTSxDQUFDM3ZHLEVBQUU7UUFDcEIsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxJQUFJeWtCLEtBQUtydEIsTUFBTSxFQUFFNEksSUFBSztZQUNwQyxJQUFJbStELFFBQVExNUMsSUFBSSxDQUFDemtCLEVBQUU7WUFDbkIsSUFBSW0rRCxTQUFTLE1BQU07Z0JBQ2pCMTVDLEtBQUs3TCxNQUFNLENBQUM1WSxHQUFHO2dCQUNmQTtnQkFDQTtZQUNGO1lBQ0E2b0csUUFBUTFxQyxPQUFPO2dCQUNieitDLE9BQU8vbEI7Z0JBQ1AyVCxPQUFPdE47WUFDVDtRQUNGO0lBQ0Y7SUFDQSxJQUFJOHBHLGtCQUFrQixTQUFTQSxnQkFBZ0JweEYsR0FBRyxFQUFFcXhGLE9BQU87UUFDekQsSUFBSUMsUUFBUXQvRSxRQUFRaFM7UUFDcEIsSUFBSTgvQyxXQUFXOS9DLElBQUk4L0MsUUFBUSxHQUFHbitDLE1BQU0sQ0FBQyxTQUFVdEIsRUFBRTtZQUMvQyxPQUFPQSxHQUFHK0QsTUFBTSxNQUFNMkgsS0FBS2hMLEdBQUcsQ0FBQ1Y7UUFDakM7UUFDQSxJQUFJa3hGLFdBQVcsQ0FBQztRQUNoQixJQUFJN3FGLEtBQUsxRyxJQUFJMEcsRUFBRTtRQUNmLElBQUssSUFBSW5oQixJQUFJLEdBQUdBLElBQUl1NkQsU0FBU3BoRSxNQUFNLEVBQUU2RyxJQUFLO1lBQ3hDLElBQUlpc0csUUFBUTF4QyxRQUFRLENBQUN2NkQsRUFBRTtZQUN2QixJQUFJa3NHLFFBQVF6L0UsUUFBUXcvRTtZQUNwQkQsV0FBVy90RyxLQUFLNlUsR0FBRyxDQUFDazVGLFVBQVVFLE1BQU16cUYsS0FBSztRQUMzQztRQUNBLElBQUlzcUYsTUFBTXRxRixLQUFLLElBQUl1cUYsVUFBVTtZQUMzQixJQUFJLENBQUMvK0YsUUFBUTA5RixPQUFPLElBQUltQixPQUFPLENBQUMzcUYsR0FBRyxFQUFFO2dCQUNuQyxPQUFPO1lBQ1Q7WUFDQSxJQUFJc3FGLFdBQVdPLFdBQVc7WUFDMUJSLFlBQVkvd0YsS0FBS2d4RjtZQUNqQkssT0FBTyxDQUFDM3FGLEdBQUcsR0FBR3NxRjtZQUNkLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLHlGQUF5RjtJQUN6RixJQUFJbnJGLFlBQVlvcUYsU0FBUztRQUN2QixJQUFJbHFGLElBQUksRUFBRTtRQUNWLElBQUlzckYsVUFBVSxDQUFDO1FBQ2YsSUFBSUssVUFBVSxTQUFTQSxRQUFROXlHLENBQUM7WUFDOUIsT0FBT21uQixFQUFFN2tCLElBQUksQ0FBQ3RDO1FBQ2hCO1FBQ0EsSUFBSSt5RyxVQUFVLFNBQVNBO1lBQ3JCLE9BQU81ckYsRUFBRWMsS0FBSztRQUNoQjtRQUNBTixNQUFNM0UsT0FBTyxDQUFDLFNBQVVoakIsQ0FBQztZQUN2QixPQUFPbW5CLEVBQUU3a0IsSUFBSSxDQUFDdEM7UUFDaEI7UUFDQSxNQUFPbW5CLEVBQUVybkIsTUFBTSxHQUFHLEVBQUc7WUFDbkIsSUFBSXVvRixRQUFRMHFCO1lBQ1osSUFBSUMsV0FBV1IsZ0JBQWdCbnFCLE9BQU9vcUI7WUFDdEMsSUFBSU8sVUFBVTtnQkFDWjNxQixNQUFNeDVDLFFBQVEsR0FBRzlyQixNQUFNLENBQUMsU0FBVXRCLEVBQUU7b0JBQ2xDLE9BQU9BLEdBQUcrRCxNQUFNLE1BQU0ySCxLQUFLaEwsR0FBRyxDQUFDVjtnQkFDakMsR0FBR3VCLE9BQU8sQ0FBQzh2RjtZQUNiLE9BQU8sSUFBSUUsYUFBYSxNQUFNO2dCQUM1QjN6RixLQUFLLDZDQUE2Q2dwRSxNQUFNdmdFLEVBQUUsS0FBSztnQkFDL0QsT0FBTyxrQkFBa0I7WUFDM0I7UUFDRjtJQUNGO0lBRUEsbURBQW1EO0lBQ25ELElBQUltckYsY0FBYztJQUNsQixJQUFJci9GLFFBQVFzOUYsWUFBWSxFQUFFO1FBQ3hCLElBQUssSUFBSWg2RSxNQUFNLEdBQUdBLE1BQU12UCxNQUFNN25CLE1BQU0sRUFBRW8zQixNQUFPO1lBQzNDLElBQUlsM0IsSUFBSTJuQixLQUFLLENBQUN1UCxJQUFJO1lBQ2xCLElBQUlnOEUsTUFBTWx6RyxFQUFFNDhFLGdCQUFnQixDQUFDaHBFO1lBQzdCLElBQUltTCxJQUFJbTBGLElBQUluMEYsQ0FBQztZQUNiLElBQUk1VixJQUFJK3BHLElBQUkvcEcsQ0FBQztZQUNiOHBHLGNBQWNydUcsS0FBSzZVLEdBQUcsQ0FBQ3c1RixhQUFhbDBGLEdBQUc1VjtRQUN6QztJQUNGO0lBRUEsb0ZBQW9GO0lBQ3BGLElBQUlncUcsd0JBQXdCLENBQUM7SUFDN0IsSUFBSUMscUJBQXFCLFNBQVNBLG1CQUFtQmh5RixHQUFHO1FBQ3RELElBQUkreEYscUJBQXFCLENBQUMveEYsSUFBSTBHLEVBQUUsR0FBRyxFQUFFO1lBQ25DLE9BQU9xckYscUJBQXFCLENBQUMveEYsSUFBSTBHLEVBQUUsR0FBRztRQUN4QztRQUNBLElBQUl1ckYsV0FBV2pnRixRQUFRaFMsS0FBS2dILEtBQUs7UUFDakMsSUFBSW9HLFlBQVlwTixJQUFJcU4sWUFBWTtRQUNoQyxJQUFJNC9ELFVBQVU7UUFDZCxJQUFJaWxCLFVBQVU7UUFDZCxJQUFLLElBQUlsOEUsTUFBTSxHQUFHQSxNQUFNNUksVUFBVTF1QixNQUFNLEVBQUVzM0IsTUFBTztZQUMvQyxJQUFJOGxDLFdBQVcxdUMsU0FBUyxDQUFDNEksSUFBSTtZQUM3QixJQUFJOGxDLFNBQVMzaEIsTUFBTSxNQUFNMmhCLFNBQVM3QyxRQUFRLE1BQU0sQ0FBQzF5QyxNQUFNeEYsR0FBRyxDQUFDKzZDLFdBQVc7Z0JBQ3BFO1lBQ0Y7WUFDQSxJQUFJcTJDLEtBQUtuZ0YsUUFBUThwQztZQUNqQixJQUFJcTJDLE1BQU0sTUFBTTtnQkFDZDtZQUNGO1lBQ0EsSUFBSXY5RixRQUFRdTlGLEdBQUd2OUYsS0FBSztZQUNwQixJQUFJb1MsUUFBUW1yRixHQUFHbnJGLEtBQUs7WUFFcEIsc0RBQXNEO1lBQ3RELElBQUlwUyxTQUFTLFFBQVFvUyxTQUFTLE1BQU07Z0JBQ2xDO1lBQ0Y7WUFDQSxJQUFJb3JGLFNBQVN4QixNQUFNLENBQUM1cEYsTUFBTSxDQUFDdG9CLE1BQU07WUFDakMsSUFBSXNvQixRQUFRaXJGLFVBQVU7Z0JBQ3BCLHdDQUF3QztnQkFDeENobEIsV0FBV3I0RSxRQUFRdzlGO2dCQUNuQkY7WUFDRjtRQUNGO1FBQ0FBLFVBQVUxdUcsS0FBSzZVLEdBQUcsQ0FBQyxHQUFHNjVGO1FBQ3RCamxCLFVBQVVBLFVBQVVpbEI7UUFDcEIsSUFBSUEsWUFBWSxHQUFHO1lBQ2pCLDhCQUE4QjtZQUM5QmpsQixVQUFVO1FBQ1o7UUFDQThrQixxQkFBcUIsQ0FBQy94RixJQUFJMEcsRUFBRSxHQUFHLEdBQUd1bUU7UUFDbEMsT0FBT0E7SUFDVDtJQUVBLGtFQUFrRTtJQUNsRSxJQUFJclMsU0FBUyxTQUFTQSxPQUFPbjhFLENBQUMsRUFBRXNJLENBQUM7UUFDL0IsSUFBSXNyRyxPQUFPTCxtQkFBbUJ2ekc7UUFDOUIsSUFBSTZ6RyxPQUFPTixtQkFBbUJqckc7UUFDOUIsSUFBSXFqQyxPQUFPaW9FLE9BQU9DO1FBQ2xCLElBQUlsb0UsU0FBUyxHQUFHO1lBQ2QsT0FBT3RqQyxVQUFVckksRUFBRWlvQixFQUFFLElBQUkzZixFQUFFMmYsRUFBRSxLQUFLLHFEQUFxRDtRQUN6RixPQUFPO1lBQ0wsT0FBTzBqQjtRQUNUO0lBQ0Y7SUFDQSxJQUFJNTNCLFFBQVF1OUYsU0FBUyxLQUFLdHVHLFdBQVc7UUFDbkNtNUUsU0FBU3BvRSxRQUFRdTlGLFNBQVM7SUFDNUI7SUFDQSxJQUFJd0MsWUFBWTNCLE9BQU9seUcsTUFBTTtJQUU3QixpREFBaUQ7SUFDakQsSUFBSyxJQUFJNjNCLE1BQU0sR0FBR0EsTUFBTWc4RSxXQUFXaDhFLE1BQU87UUFDeENxNkUsTUFBTSxDQUFDcjZFLElBQUksQ0FBQ2pNLElBQUksQ0FBQ3N3RDtRQUNqQnUyQixlQUFlNTZFO0lBQ2pCO0lBRUEsK0NBQStDO0lBQy9DLElBQUlpOEUsY0FBYyxFQUFFO0lBQ3BCLElBQUssSUFBSXZyRSxNQUFNLEdBQUdBLE1BQU1pcUUsWUFBWXh5RyxNQUFNLEVBQUV1b0MsTUFBTztRQUNqRHVyRSxZQUFZdHhHLElBQUksQ0FBQ2d3RyxXQUFXLENBQUNqcUUsSUFBSTtJQUNuQztJQUNBLElBQUl3ckUsZUFBZSxTQUFTQTtRQUMxQixJQUFLLElBQUlwb0UsTUFBTSxHQUFHQSxNQUFNa29FLFdBQVdsb0UsTUFBTztZQUN4QzhtRSxlQUFlOW1FO1FBQ2pCO0lBQ0Y7SUFFQSw2REFBNkQ7SUFDN0QsSUFBSW1vRSxZQUFZOXpHLE1BQU0sRUFBRTtRQUN0Qmt5RyxPQUFPanFGLE9BQU8sQ0FBQzZyRjtRQUNmRCxZQUFZM0IsT0FBT2x5RyxNQUFNO1FBQ3pCK3pHO0lBQ0Y7SUFDQSxJQUFJQyxtQkFBbUI7SUFDdkIsSUFBSyxJQUFJcDZELE1BQU0sR0FBR0EsTUFBTWk2RCxXQUFXajZELE1BQU87UUFDeENvNkQsbUJBQW1CbHZHLEtBQUs2VSxHQUFHLENBQUN1NEYsTUFBTSxDQUFDdDRELElBQUksQ0FBQzU1QyxNQUFNLEVBQUVnMEc7SUFDbEQ7SUFDQSxJQUFJcHdELFNBQVM7UUFDWHR2QyxHQUFHa21CLEdBQUc1MEIsRUFBRSxHQUFHNDBCLEdBQUd2YixDQUFDLEdBQUc7UUFDbEJsQixHQUFHeWMsR0FBRzEwQixFQUFFLEdBQUcwMEIsR0FBR254QixDQUFDLEdBQUc7SUFDcEI7SUFFQSxvQkFBb0I7SUFDcEIsSUFBSTRxRyxjQUFjcHNGLE1BQU1rNEMsTUFBTSxDQUFDLFNBQVVtMEMsR0FBRyxFQUFFaHJGLElBQUk7UUFDaEQsT0FBTyxTQUFVbEssR0FBRztZQUNsQixPQUFPO2dCQUNMQyxHQUFHaTFGLElBQUlqMUYsQ0FBQyxLQUFLLENBQUMsSUFBSUQsSUFBSUMsQ0FBQyxHQUFHLENBQUNpMUYsSUFBSWoxRixDQUFDLEdBQUdELElBQUlDLENBQUMsSUFBSTtnQkFDNUM1VixHQUFHNnFHLElBQUk3cUcsQ0FBQyxLQUFLLENBQUMsSUFBSTJWLElBQUkzVixDQUFDLEdBQUcsQ0FBQzZxRyxJQUFJN3FHLENBQUMsR0FBRzJWLElBQUkzVixDQUFDLElBQUk7WUFDOUM7UUFDRixFQUFFNmYsS0FBS3ZqQixXQUFXLENBQUM7WUFDakJzaUUsZUFBZW4wRCxRQUFROG9FLDJCQUEyQjtRQUNwRDtJQUNGLEdBQUc7UUFDRDM5RCxHQUFHLENBQUM7UUFDSjVWLEdBQUcsQ0FBQztJQUNOO0lBQ0EsSUFBSThxRyxZQUFZcnZHLEtBQUs2VSxHQUFHLENBQ3hCLGlCQUFpQjtJQUNqQms2RixjQUFjLElBQUksSUFDbEIsMERBQTBEO0lBQzFEaEMsaUJBQWlCLENBQUNyM0UsR0FBR254QixDQUFDLEdBQUd5SyxRQUFRa25CLE9BQU8sR0FBRyxJQUFJaTVFLFlBQVk1cUcsQ0FBQyxJQUFLd3FHLENBQUFBLFlBQVksS0FBSyxDQUFDcjVFLEdBQUdueEIsQ0FBQyxHQUFHeUssUUFBUWtuQixPQUFPLEdBQUcsSUFBSWk1RSxZQUFZNXFHLENBQUMsSUFBS3dxRyxDQUFBQSxZQUFZLElBQUlWO0lBQ2xKLElBQUlpQixlQUFlbEMsT0FBT255QyxNQUFNLENBQUMsU0FBVXBtRCxHQUFHLEVBQUUwVCxJQUFJO1FBQ2xELE9BQU92b0IsS0FBSzZVLEdBQUcsQ0FBQ0EsS0FBSzBULEtBQUtydEIsTUFBTTtJQUNsQyxHQUFHO0lBQ0gsSUFBSXEwRyx1QkFBdUIsU0FBU0EscUJBQXFCL3lGLEdBQUc7UUFDMUQsSUFBSWd6RixZQUFZaGhGLFFBQVFoUyxNQUN0QmdILFFBQVFnc0YsVUFBVWhzRixLQUFLLEVBQ3ZCcFMsUUFBUW8rRixVQUFVcCtGLEtBQUs7UUFDekIsSUFBSXBDLFFBQVFvOUYsTUFBTSxFQUFFO1lBQ2xCLElBQUlxRCxpQkFBaUJ6dkcsS0FBSytVLEdBQUcsQ0FBQzJnQixHQUFHdmIsQ0FBQyxHQUFHLElBQUk0MEYsV0FBV3I1RSxHQUFHbnhCLENBQUMsR0FBRyxJQUFJd3FHO1lBQy9EVSxpQkFBaUJ6dkcsS0FBSzZVLEdBQUcsQ0FBQzQ2RixnQkFBZ0JwQjtZQUMxQyxJQUFJeDFFLFNBQVM0MkUsaUJBQWlCanNGLFFBQVFpc0YsaUJBQWtCVixDQUFBQSxZQUFZLEtBQUszQixNQUFNLENBQUMsRUFBRSxDQUFDbHlHLE1BQU0sSUFBSSxJQUFJdTBHLGlCQUFpQixJQUFJO1lBQ3RILElBQUk5bkMsUUFBUSxJQUFJM25FLEtBQUtzWixFQUFFLEdBQUc4ekYsTUFBTSxDQUFDNXBGLE1BQU0sQ0FBQ3RvQixNQUFNLEdBQUdrVztZQUNqRCxJQUFJb1MsVUFBVSxLQUFLNHBGLE1BQU0sQ0FBQyxFQUFFLENBQUNseUcsTUFBTSxLQUFLLEdBQUc7Z0JBQ3pDMjlCLFNBQVM7WUFDWDtZQUNBLE9BQU87Z0JBQ0xycEIsR0FBR3N2QyxPQUFPdHZDLENBQUMsR0FBR3FwQixTQUFTNzRCLEtBQUt3WixHQUFHLENBQUNtdUQ7Z0JBQ2hDMXVELEdBQUc2bEMsT0FBTzdsQyxDQUFDLEdBQUc0ZixTQUFTNzRCLEtBQUt5WixHQUFHLENBQUNrdUQ7WUFDbEM7UUFDRixPQUFPO1lBQ0wsSUFBSStuQyxZQUFZdEMsTUFBTSxDQUFDNXBGLE1BQU0sQ0FBQ3RvQixNQUFNO1lBQ3BDLElBQUl5MEcsWUFBWTN2RyxLQUFLNlUsR0FBRyxDQUN4QixpQkFBaUI7WUFDakI2NkYsY0FBYyxJQUFJLElBQ2xCLDBEQUEwRDtZQUMxRDNDLGlCQUFpQixDQUFDcjNFLEdBQUd2YixDQUFDLEdBQUduTCxRQUFRa25CLE9BQU8sR0FBRyxJQUFJaTVFLFlBQVloMUYsQ0FBQyxJQUFLLEVBQUNuTCxRQUFRcTlGLElBQUksR0FBR2lELGVBQWVJLFNBQVEsSUFBSyxLQUFLLENBQUNoNkUsR0FBR3ZiLENBQUMsR0FBR25MLFFBQVFrbkIsT0FBTyxHQUFHLElBQUlpNUUsWUFBWWgxRixDQUFDLElBQUssRUFBQ25MLFFBQVFxOUYsSUFBSSxHQUFHaUQsZUFBZUksU0FBUSxJQUFLLElBQUlyQjtZQUNsTixJQUFJdUIsT0FBTztnQkFDVHBnRyxHQUFHc3ZDLE9BQU90dkMsQ0FBQyxHQUFHLENBQUM0QixRQUFRLElBQUksQ0FBQ3MrRixZQUFZLEtBQUssS0FBS0M7Z0JBQ2xEMTJGLEdBQUc2bEMsT0FBTzdsQyxDQUFDLEdBQUcsQ0FBQ3VLLFFBQVEsSUFBSSxDQUFDdXJGLFlBQVksS0FBSyxLQUFLTTtZQUNwRDtZQUNBLE9BQU9PO1FBQ1Q7SUFDRjtJQUNBLElBQUlDLGdCQUFnQjtRQUNsQixZQUFZO1FBQ1osWUFBWTtRQUNaLFVBQVU7UUFDVixhQUFhLENBQUM7SUFDaEI7SUFDQSxJQUFJNXpHLE9BQU80SCxJQUFJLENBQUNnc0csZUFBZWpwRixPQUFPLENBQUM1WCxRQUFRc3VCLFNBQVMsTUFBTSxDQUFDLEdBQUc7UUFDaEVsaUIsTUFBTSxzQkFBc0I2SyxNQUFNLENBQUNqWCxRQUFRc3VCLFNBQVMsRUFBRSwyREFBMkRyWCxNQUFNLENBQUNocUIsT0FBTzRILElBQUksQ0FBQ2dzRyxlQUFlbnVHLElBQUksQ0FBQztJQUMxSjtJQUNBLElBQUlvdUcsY0FBYyxTQUFTQSxZQUFZdHpGLEdBQUc7UUFDeEMsT0FBT3hDLHNCQUFzQnUxRixxQkFBcUIveUYsTUFBTWtaLElBQUltNkUsYUFBYSxDQUFDN2dHLFFBQVFzdUIsU0FBUyxDQUFDO0lBQzlGO0lBQ0EvVSxLQUFLeEYsS0FBSyxHQUFHbzFELGVBQWUsQ0FBQyxJQUFJLEVBQUVucEUsU0FBUzhnRztJQUM1QyxPQUFPLElBQUksRUFBRSxXQUFXO0FBQzFCO0FBRUEsSUFBSUMsYUFBYTtJQUNmN3dELEtBQUs7SUFDTCwyQ0FBMkM7SUFDM0NocEIsU0FBUztJQUNULHFCQUFxQjtJQUNyQnIxQixhQUFhNUM7SUFDYixrRUFBa0U7SUFDbEVxdUcsY0FBYztJQUNkLGlGQUFpRjtJQUNqRngwQiw2QkFBNkI7SUFDN0IsbUZBQW1GO0lBQ25GZSxlQUFlNTZFO0lBQ2YscUdBQXFHO0lBQ3JHNDZCLFFBQVE1NkI7SUFDUiwyQkFBMkI7SUFDM0IwbEMsWUFBWSxJQUFJLElBQUkzakMsS0FBS3NaLEVBQUU7SUFDM0IsK0JBQStCO0lBQy9CMDJGLE9BQU8veEc7SUFDUCx1RkFBdUY7SUFDdkZneUcsV0FBVztJQUNYLDBGQUEwRjtJQUMxRm5wRixNQUFNN29CO0lBQ04sMkdBQTJHO0lBQzNHbWdELFNBQVM7SUFDVCwyQ0FBMkM7SUFDM0MrNkIsbUJBQW1CO0lBQ25CLHlDQUF5QztJQUN6Q0UsaUJBQWlCcDdFO0lBQ2pCLGlDQUFpQztJQUNqQ2k3RSxlQUFlLFNBQVNBLGNBQWM5MEQsSUFBSSxFQUFFM21CLENBQUM7UUFDM0MsT0FBTztJQUNUO0lBQ0EsMkxBQTJMO0lBQzNMKzdFLE9BQU92N0U7SUFDUCwwQkFBMEI7SUFDMUIrK0MsTUFBTS8rQztJQUNOLHlCQUF5QjtJQUN6Qis2RSxXQUFXLFNBQVNBLFVBQVU1MEQsSUFBSSxFQUFFbkYsUUFBUTtRQUMxQyxPQUFPQTtJQUNULEVBQUUsMkZBQTJGO0FBQy9GO0FBQ0EsU0FBU2l4RixhQUFhbGhHLE9BQU87SUFDM0IsSUFBSSxDQUFDQSxPQUFPLEdBQUd2TCxPQUFPLENBQUMsR0FBR3NzRyxZQUFZL2dHO0FBQ3hDO0FBQ0FraEcsYUFBYTV6RyxTQUFTLENBQUNtaEQsR0FBRyxHQUFHO0lBQzNCLElBQUkvK0IsU0FBUyxJQUFJLENBQUMxUCxPQUFPO0lBQ3pCLElBQUlBLFVBQVUwUDtJQUNkLElBQUlELEtBQUtDLE9BQU9ELEVBQUU7SUFDbEIsSUFBSThKLE9BQU92WixRQUFRdVosSUFBSTtJQUN2QixJQUFJMG5GLFlBQVlqaEcsUUFBUW1oRyxnQkFBZ0IsS0FBS2x5RyxZQUFZLENBQUMrUSxRQUFRbWhHLGdCQUFnQixHQUFHbmhHLFFBQVFpaEcsU0FBUztJQUN0RyxJQUFJbHRGLFFBQVF3RixLQUFLeEYsS0FBSyxHQUFHZzhDLEdBQUcsQ0FBQztJQUM3QixJQUFJL3ZELFFBQVE4WCxJQUFJLEVBQUU7UUFDaEIvRCxRQUFRQSxNQUFNK0QsSUFBSSxDQUFDOVgsUUFBUThYLElBQUk7SUFDakM7SUFDQSxJQUFJNE8sS0FBS0QsZ0JBQWdCem1CLFFBQVFuTyxXQUFXLEdBQUdtTyxRQUFRbk8sV0FBVyxHQUFHO1FBQ25FQyxJQUFJO1FBQ0pFLElBQUk7UUFDSm1aLEdBQUdzRSxHQUFHMlosS0FBSztRQUNYN3pCLEdBQUdrYSxHQUFHNFosTUFBTTtJQUNkO0lBQ0EsSUFBSXltQixTQUFTO1FBQ1h0dkMsR0FBR2ttQixHQUFHNTBCLEVBQUUsR0FBRzQwQixHQUFHdmIsQ0FBQyxHQUFHO1FBQ2xCbEIsR0FBR3ljLEdBQUcxMEIsRUFBRSxHQUFHMDBCLEdBQUdueEIsQ0FBQyxHQUFHO0lBQ3BCO0lBQ0EsSUFBSXlyRyxRQUFRaGhHLFFBQVFnaEcsS0FBSyxLQUFLL3hHLFlBQVksSUFBSStCLEtBQUtzWixFQUFFLEdBQUcsSUFBSXRaLEtBQUtzWixFQUFFLEdBQUd5SixNQUFNN25CLE1BQU0sR0FBRzhULFFBQVFnaEcsS0FBSztJQUNsRyxJQUFJSSxTQUFTSixRQUFRaHdHLEtBQUs2VSxHQUFHLENBQUMsR0FBR2tPLE1BQU03bkIsTUFBTSxHQUFHO0lBQ2hELElBQUlGO0lBQ0osSUFBSXF6RyxjQUFjO0lBQ2xCLElBQUssSUFBSTV3RyxJQUFJLEdBQUdBLElBQUlzbEIsTUFBTTduQixNQUFNLEVBQUV1QyxJQUFLO1FBQ3JDLElBQUlyQyxJQUFJMm5CLEtBQUssQ0FBQ3RsQixFQUFFO1FBQ2hCLElBQUk2d0csTUFBTWx6RyxFQUFFNDhFLGdCQUFnQixDQUFDaHBFO1FBQzdCLElBQUltTCxJQUFJbTBGLElBQUluMEYsQ0FBQztRQUNiLElBQUk1VixJQUFJK3BHLElBQUkvcEcsQ0FBQztRQUNiOHBHLGNBQWNydUcsS0FBSzZVLEdBQUcsQ0FBQ3c1RixhQUFhbDBGLEdBQUc1VjtJQUN6QztJQUNBLElBQUkzRSxTQUFTb1AsUUFBUTZwQixNQUFNLEdBQUc7UUFDNUI3OUIsSUFBSWdVLFFBQVE2cEIsTUFBTTtJQUNwQixPQUFPLElBQUk5VixNQUFNN25CLE1BQU0sSUFBSSxHQUFHO1FBQzVCRixJQUFJO0lBQ04sT0FBTztRQUNMQSxJQUFJZ0YsS0FBSytVLEdBQUcsQ0FBQzJnQixHQUFHbnhCLENBQUMsRUFBRW14QixHQUFHdmIsQ0FBQyxJQUFJLElBQUlrMEY7SUFDakM7SUFFQSx1QkFBdUI7SUFDdkIsSUFBSXRyRixNQUFNN25CLE1BQU0sR0FBRyxLQUFLOFQsUUFBUXM5RixZQUFZLEVBQUU7UUFDNUMsaURBQWlEO1FBQ2pEK0IsZUFBZSxNQUFNLGlDQUFpQztRQUV0RCxJQUFJZ0MsT0FBT3J3RyxLQUFLd1osR0FBRyxDQUFDNDJGLFVBQVVwd0csS0FBS3daLEdBQUcsQ0FBQztRQUN2QyxJQUFJODJGLE9BQU90d0csS0FBS3laLEdBQUcsQ0FBQzIyRixVQUFVcHdHLEtBQUt5WixHQUFHLENBQUM7UUFDdkMsSUFBSTgyRixPQUFPdndHLEtBQUsyd0IsSUFBSSxDQUFDMDlFLGNBQWNBLGNBQWVnQyxDQUFBQSxPQUFPQSxPQUFPQyxPQUFPQSxJQUFHLElBQUssNEJBQTRCO1FBQzNHdDFHLElBQUlnRixLQUFLNlUsR0FBRyxDQUFDMDdGLE1BQU12MUc7SUFDckI7SUFDQSxJQUFJdzFHLFNBQVMsU0FBU0EsT0FBT2gwRixHQUFHLEVBQUUvZSxDQUFDO1FBQ2pDLElBQUlrcUUsUUFBUTM0RCxRQUFRMjBCLFVBQVUsR0FBR2xtQyxJQUFJMnlHLFNBQVVILENBQUFBLFlBQVksSUFBSSxDQUFDO1FBQ2hFLElBQUlRLEtBQUt6MUcsSUFBSWdGLEtBQUt3WixHQUFHLENBQUNtdUQ7UUFDdEIsSUFBSStvQyxLQUFLMTFHLElBQUlnRixLQUFLeVosR0FBRyxDQUFDa3VEO1FBQ3RCLElBQUkxdEQsTUFBTTtZQUNSekssR0FBR3N2QyxPQUFPdHZDLENBQUMsR0FBR2loRztZQUNkeDNGLEdBQUc2bEMsT0FBTzdsQyxDQUFDLEdBQUd5M0Y7UUFDaEI7UUFDQSxPQUFPejJGO0lBQ1Q7SUFDQXNPLEtBQUt4RixLQUFLLEdBQUdvMUQsZUFBZSxDQUFDLElBQUksRUFBRW5wRSxTQUFTd2hHO0lBQzVDLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFFQSxJQUFJRyxhQUFhO0lBQ2Z6eEQsS0FBSztJQUNMLDJDQUEyQztJQUMzQ2hwQixTQUFTO0lBQ1QscUJBQXFCO0lBQ3JCeU4sWUFBWSxJQUFJLElBQUkzakMsS0FBS3NaLEVBQUU7SUFDM0IsK0JBQStCO0lBQy9CMDJGLE9BQU8veEc7SUFDUCx1RkFBdUY7SUFDdkZneUcsV0FBVztJQUNYLDBGQUEwRjtJQUMxRlcsYUFBYTtJQUNiLDRGQUE0RjtJQUM1RkMsZ0JBQWdCO0lBQ2hCLG9FQUFvRTtJQUNwRWh3RyxhQUFhNUM7SUFDYixrRUFBa0U7SUFDbEVxdUcsY0FBYztJQUNkLHNFQUFzRTtJQUN0RXgwQiw2QkFBNkI7SUFDN0IsbUZBQW1GO0lBQ25Gei9DLFFBQVFwNkI7SUFDUixxREFBcUQ7SUFDckRtNkIsT0FBT242QjtJQUNQLG1EQUFtRDtJQUNuRDQ2RSxlQUFlNTZFO0lBQ2YscUdBQXFHO0lBQ3JHNnlHLFlBQVksU0FBU0EsV0FBVzFzRixJQUFJO1FBQ2xDLHlGQUF5RjtRQUN6RixPQUFPQSxLQUFLbWpCLE1BQU07SUFDcEI7SUFDQXdwRSxZQUFZLFNBQVNBLFdBQVdodUYsS0FBSztRQUNuQyxtREFBbUQ7UUFDbkQsT0FBT0EsTUFBTXFrQixTQUFTLEtBQUs7SUFDN0I7SUFDQWdYLFNBQVM7SUFDVCwyQ0FBMkM7SUFDM0MrNkIsbUJBQW1CO0lBQ25CLHlDQUF5QztJQUN6Q0UsaUJBQWlCcDdFO0lBQ2pCLGlDQUFpQztJQUNqQ2k3RSxlQUFlLFNBQVNBLGNBQWM5MEQsSUFBSSxFQUFFM21CLENBQUM7UUFDM0MsT0FBTztJQUNUO0lBQ0EsMkxBQTJMO0lBQzNMKzdFLE9BQU92N0U7SUFDUCwwQkFBMEI7SUFDMUIrK0MsTUFBTS8rQztJQUNOLHlCQUF5QjtJQUN6Qis2RSxXQUFXLFNBQVNBLFVBQVU1MEQsSUFBSSxFQUFFbkYsUUFBUTtRQUMxQyxPQUFPQTtJQUNULEVBQUUsMEZBQTBGO0FBQzlGO0FBQ0EsU0FBUyt4RixpQkFBaUJoaUcsT0FBTztJQUMvQixJQUFJLENBQUNBLE9BQU8sR0FBR3ZMLE9BQU8sQ0FBQyxHQUFHa3RHLFlBQVkzaEc7QUFDeEM7QUFDQWdpRyxpQkFBaUIxMEcsU0FBUyxDQUFDbWhELEdBQUcsR0FBRztJQUMvQixJQUFJLytCLFNBQVMsSUFBSSxDQUFDMVAsT0FBTztJQUN6QixJQUFJQSxVQUFVMFA7SUFDZCxJQUFJdXhGLFlBQVlqaEcsUUFBUW1oRyxnQkFBZ0IsS0FBS2x5RyxZQUFZLENBQUMrUSxRQUFRbWhHLGdCQUFnQixHQUFHbmhHLFFBQVFpaEcsU0FBUztJQUN0RyxJQUFJeHhGLEtBQUtDLE9BQU9ELEVBQUU7SUFDbEIsSUFBSThKLE9BQU92WixRQUFRdVosSUFBSTtJQUN2QixJQUFJeEYsUUFBUXdGLEtBQUt4RixLQUFLLEdBQUdnOEMsR0FBRyxDQUFDO0lBQzdCLElBQUlycEMsS0FBS0QsZ0JBQWdCem1CLFFBQVFuTyxXQUFXLEdBQUdtTyxRQUFRbk8sV0FBVyxHQUFHO1FBQ25FQyxJQUFJO1FBQ0pFLElBQUk7UUFDSm1aLEdBQUdzRSxHQUFHMlosS0FBSztRQUNYN3pCLEdBQUdrYSxHQUFHNFosTUFBTTtJQUNkO0lBQ0EsSUFBSXltQixTQUFTO1FBQ1h0dkMsR0FBR2ttQixHQUFHNTBCLEVBQUUsR0FBRzQwQixHQUFHdmIsQ0FBQyxHQUFHO1FBQ2xCbEIsR0FBR3ljLEdBQUcxMEIsRUFBRSxHQUFHMDBCLEdBQUdueEIsQ0FBQyxHQUFHO0lBQ3BCO0lBQ0EsSUFBSTBzRyxhQUFhLEVBQUUsRUFBRSxrQkFBa0I7SUFDdkMsSUFBSUMsY0FBYztJQUNsQixJQUFLLElBQUl6ekcsSUFBSSxHQUFHQSxJQUFJc2xCLE1BQU03bkIsTUFBTSxFQUFFdUMsSUFBSztRQUNyQyxJQUFJMm1CLE9BQU9yQixLQUFLLENBQUN0bEIsRUFBRTtRQUNuQixJQUFJWCxRQUFRbUI7UUFFWiwyQkFBMkI7UUFDM0JuQixRQUFRa1MsUUFBUThoRyxVQUFVLENBQUMxc0Y7UUFDM0I2c0YsV0FBV3Z6RyxJQUFJLENBQUM7WUFDZFosT0FBT0E7WUFDUHNuQixNQUFNQTtRQUNSO1FBRUEsb0JBQW9CO1FBQ3BCQSxLQUFLL2pCLFFBQVEsQ0FBQ21nQixPQUFPLENBQUNzd0YsVUFBVSxHQUFHaDBHO0lBQ3JDO0lBRUEsNENBQTRDO0lBQzVDaW1CLE1BQU1xc0MsV0FBVztJQUVqQiw4REFBOEQ7SUFDOUQsSUFBSyxJQUFJanJDLEtBQUssR0FBR0EsS0FBS3BCLE1BQU03bkIsTUFBTSxFQUFFaXBCLEtBQU07UUFDeEMsSUFBSWtNLFFBQVF0TixLQUFLLENBQUNvQixHQUFHO1FBQ3JCLElBQUltcUYsTUFBTWorRSxNQUFNMm5ELGdCQUFnQixDQUFDaHBFO1FBQ2pDa2lHLGNBQWNseEcsS0FBSzZVLEdBQUcsQ0FBQ3E4RixhQUFhNUMsSUFBSW4wRixDQUFDLEVBQUVtMEYsSUFBSS9wRyxDQUFDO0lBQ2xEO0lBRUEsd0NBQXdDO0lBQ3hDMHNHLFdBQVducUYsSUFBSSxDQUFDLFNBQVU3ckIsQ0FBQyxFQUFFc0ksQ0FBQztRQUM1QixPQUFPQSxFQUFFekcsS0FBSyxHQUFHN0IsRUFBRTZCLEtBQUs7SUFDMUI7SUFDQSxJQUFJaTBHLGFBQWEvaEcsUUFBUStoRyxVQUFVLENBQUNodUY7SUFFcEMsNkJBQTZCO0lBQzdCLElBQUlvdUYsU0FBUztRQUFDLEVBQUU7S0FBQztJQUNqQixJQUFJQyxlQUFlRCxNQUFNLENBQUMsRUFBRTtJQUM1QixJQUFLLElBQUlwdEYsTUFBTSxHQUFHQSxNQUFNa3RGLFdBQVcvMUcsTUFBTSxFQUFFNm9CLE1BQU87UUFDaEQsSUFBSTNHLE1BQU02ekYsVUFBVSxDQUFDbHRGLElBQUk7UUFDekIsSUFBSXF0RixhQUFhbDJHLE1BQU0sR0FBRyxHQUFHO1lBQzNCLElBQUkwckMsT0FBTzVtQyxLQUFLMjNCLEdBQUcsQ0FBQ3k1RSxZQUFZLENBQUMsRUFBRSxDQUFDdDBHLEtBQUssR0FBR3NnQixJQUFJdGdCLEtBQUs7WUFDckQsSUFBSThwQyxRQUFRbXFFLFlBQVk7Z0JBQ3RCSyxlQUFlLEVBQUU7Z0JBQ2pCRCxPQUFPenpHLElBQUksQ0FBQzB6RztZQUNkO1FBQ0Y7UUFDQUEsYUFBYTF6RyxJQUFJLENBQUMwZjtJQUNwQjtJQUVBLCtCQUErQjtJQUUvQixJQUFJaTBGLFVBQVVILGNBQWNsaUcsUUFBUTZoRyxjQUFjLEVBQUUseUJBQXlCO0lBRTdFLElBQUksQ0FBQzdoRyxRQUFRczlGLFlBQVksRUFBRTtRQUN6QixnQ0FBZ0M7UUFDaEMsSUFBSWdGLG1CQUFtQkgsT0FBT2oyRyxNQUFNLEdBQUcsS0FBS2kyRyxNQUFNLENBQUMsRUFBRSxDQUFDajJHLE1BQU0sR0FBRztRQUMvRCxJQUFJcTJHLE9BQU92eEcsS0FBSytVLEdBQUcsQ0FBQzJnQixHQUFHdmIsQ0FBQyxFQUFFdWIsR0FBR254QixDQUFDLElBQUksSUFBSThzRztRQUN0QyxJQUFJRyxRQUFRRCxPQUFRSixDQUFBQSxPQUFPajJHLE1BQU0sR0FBR28yRyxtQkFBbUIsSUFBSTtRQUMzREQsVUFBVXJ4RyxLQUFLK1UsR0FBRyxDQUFDczhGLFNBQVNHO0lBQzlCO0lBRUEsa0NBQWtDO0lBQ2xDLElBQUl4MkcsSUFBSTtJQUNSLElBQUssSUFBSXMzQixNQUFNLEdBQUdBLE1BQU02K0UsT0FBT2oyRyxNQUFNLEVBQUVvM0IsTUFBTztRQUM1QyxJQUFJbTJFLFFBQVEwSSxNQUFNLENBQUM3K0UsSUFBSTtRQUN2QixJQUFJMDlFLFFBQVFoaEcsUUFBUWdoRyxLQUFLLEtBQUsveEcsWUFBWSxJQUFJK0IsS0FBS3NaLEVBQUUsR0FBRyxJQUFJdFosS0FBS3NaLEVBQUUsR0FBR212RixNQUFNdnRHLE1BQU0sR0FBRzhULFFBQVFnaEcsS0FBSztRQUNsRyxJQUFJSSxTQUFTM0gsTUFBTTJILE1BQU0sR0FBR0osUUFBUWh3RyxLQUFLNlUsR0FBRyxDQUFDLEdBQUc0ekYsTUFBTXZ0RyxNQUFNLEdBQUc7UUFFL0QsdUJBQXVCO1FBQ3ZCLElBQUl1dEcsTUFBTXZ0RyxNQUFNLEdBQUcsS0FBSzhULFFBQVFzOUYsWUFBWSxFQUFFO1lBQzVDLGlEQUFpRDtZQUNqRCxJQUFJK0QsT0FBT3J3RyxLQUFLd1osR0FBRyxDQUFDNDJGLFVBQVVwd0csS0FBS3daLEdBQUcsQ0FBQztZQUN2QyxJQUFJODJGLE9BQU90d0csS0FBS3laLEdBQUcsQ0FBQzIyRixVQUFVcHdHLEtBQUt5WixHQUFHLENBQUM7WUFDdkMsSUFBSTgyRixPQUFPdndHLEtBQUsyd0IsSUFBSSxDQUFDMGdGLFVBQVVBLFVBQVdoQixDQUFBQSxPQUFPQSxPQUFPQyxPQUFPQSxJQUFHLElBQUssNEJBQTRCO1lBRW5HdDFHLElBQUlnRixLQUFLNlUsR0FBRyxDQUFDMDdGLE1BQU12MUc7UUFDckI7UUFDQXl0RyxNQUFNenRHLENBQUMsR0FBR0E7UUFDVkEsS0FBS3EyRztJQUNQO0lBQ0EsSUFBSXJpRyxRQUFRNGhHLFdBQVcsRUFBRTtRQUN2QixJQUFJYSxZQUFZO1FBQ2hCLElBQUlDLEtBQUs7UUFDVCxJQUFLLElBQUlsL0UsTUFBTSxHQUFHQSxNQUFNMitFLE9BQU9qMkcsTUFBTSxFQUFFczNCLE1BQU87WUFDNUMsSUFBSW0vRSxTQUFTUixNQUFNLENBQUMzK0UsSUFBSTtZQUN4QixJQUFJby9FLFNBQVNELE9BQU8zMkcsQ0FBQyxHQUFHMDJHO1lBQ3hCRCxZQUFZenhHLEtBQUs2VSxHQUFHLENBQUM0OEYsV0FBV0c7UUFDbEM7UUFDQUYsS0FBSztRQUNMLElBQUssSUFBSTMrRSxNQUFNLEdBQUdBLE1BQU1vK0UsT0FBT2oyRyxNQUFNLEVBQUU2M0IsTUFBTztZQUM1QyxJQUFJOCtFLFVBQVVWLE1BQU0sQ0FBQ3ArRSxJQUFJO1lBQ3pCLElBQUlBLFFBQVEsR0FBRztnQkFDYjIrRSxLQUFLRyxRQUFRNzJHLENBQUM7WUFDaEI7WUFDQTYyRyxRQUFRNzJHLENBQUMsR0FBRzAyRztZQUNaQSxNQUFNRDtRQUNSO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsSUFBSXgzRixNQUFNLENBQUMsR0FBRyxpQkFBaUI7SUFDL0IsSUFBSyxJQUFJd3BCLE1BQU0sR0FBR0EsTUFBTTB0RSxPQUFPajJHLE1BQU0sRUFBRXVvQyxNQUFPO1FBQzVDLElBQUlxdUUsVUFBVVgsTUFBTSxDQUFDMXRFLElBQUk7UUFDekIsSUFBSXN1RSxVQUFVRCxRQUFRMUIsTUFBTTtRQUM1QixJQUFJNEIsTUFBTUYsUUFBUTkyRyxDQUFDO1FBQ25CLElBQUssSUFBSThJLElBQUksR0FBR0EsSUFBSWd1RyxRQUFRNTJHLE1BQU0sRUFBRTRJLElBQUs7WUFDdkMsSUFBSW11RyxPQUFPSCxPQUFPLENBQUNodUcsRUFBRTtZQUNyQixJQUFJNmpFLFFBQVEzNEQsUUFBUTIwQixVQUFVLEdBQUcsQ0FBQ3NzRSxZQUFZLElBQUksQ0FBQyxLQUFLOEIsVUFBVWp1RztZQUNsRSxJQUFJVyxJQUFJO2dCQUNOK0ssR0FBR3N2QyxPQUFPdHZDLENBQUMsR0FBR3dpRyxNQUFNaHlHLEtBQUt3WixHQUFHLENBQUNtdUQ7Z0JBQzdCMXVELEdBQUc2bEMsT0FBTzdsQyxDQUFDLEdBQUcrNEYsTUFBTWh5RyxLQUFLeVosR0FBRyxDQUFDa3VEO1lBQy9CO1lBQ0ExdEQsR0FBRyxDQUFDZzRGLEtBQUs3dEYsSUFBSSxDQUFDbEIsRUFBRSxHQUFHLEdBQUd6ZTtRQUN4QjtJQUNGO0lBRUEscUJBQXFCO0lBQ3JCOGpCLEtBQUt4RixLQUFLLEdBQUdvMUQsZUFBZSxDQUFDLElBQUksRUFBRW5wRSxTQUFTLFNBQVV3TixHQUFHO1FBQ3ZELElBQUkwRyxLQUFLMUcsSUFBSTBHLEVBQUU7UUFDZixPQUFPakosR0FBRyxDQUFDaUosR0FBRztJQUNoQjtJQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFFQTs7Ozs7Ozs7QUFRQSxHQUVBLElBQUlndkY7QUFFSjs7Q0FFQyxHQUNELElBQUlDLGFBQWE7SUFDZiwwQkFBMEI7SUFDMUIzNEIsT0FBTyxTQUFTQSxTQUFTO0lBQ3pCLHlCQUF5QjtJQUN6Qng4QixNQUFNLFNBQVNBLFFBQVE7SUFDdkIsOENBQThDO0lBQzlDLHVEQUF1RDtJQUN2RCxtQ0FBbUM7SUFDbkMsdUZBQXVGO0lBQ3ZGb0IsU0FBUztJQUNULDRDQUE0QztJQUM1Q2k3QixpQkFBaUJwN0U7SUFDakIsa0RBQWtEO0lBQ2xEazdFLG1CQUFtQmw3RTtJQUNuQixpRUFBaUU7SUFDakUsbURBQW1EO0lBQ25ELHVFQUF1RTtJQUN2RWk3RSxlQUFlLFNBQVNBLGNBQWM5MEQsSUFBSSxFQUFFM21CLENBQUM7UUFDM0MsT0FBTztJQUNUO0lBQ0EseUVBQXlFO0lBQ3pFLG1DQUFtQztJQUNuQzIwRyxvQkFBb0I7SUFDcEIsbUVBQW1FO0lBQ25FQyxTQUFTO0lBQ1Qsa0RBQWtEO0lBQ2xEbnpELEtBQUs7SUFDTCxpQkFBaUI7SUFDakJocEIsU0FBUztJQUNULGtFQUFrRTtJQUNsRXIxQixhQUFhNUM7SUFDYixtRkFBbUY7SUFDbkY2NUUsNkJBQTZCO0lBQzdCLHdGQUF3RjtJQUN4Rnc2QixXQUFXO0lBQ1gsMERBQTBEO0lBQzFEQyxrQkFBa0I7SUFDbEIsOENBQThDO0lBQzlDQyxlQUFlLFNBQVNBLGNBQWNwdUYsSUFBSTtRQUN4QyxPQUFPO0lBQ1Q7SUFDQSwwQ0FBMEM7SUFDMUNxdUYsYUFBYTtJQUNiLGlDQUFpQztJQUNqQ0MsaUJBQWlCLFNBQVNBLGdCQUFnQnJ1RixJQUFJO1FBQzVDLE9BQU87SUFDVDtJQUNBLGlDQUFpQztJQUNqQ3N1RixnQkFBZ0IsU0FBU0EsZUFBZXR1RixJQUFJO1FBQzFDLE9BQU87SUFDVDtJQUNBLDRFQUE0RTtJQUM1RXV1RixlQUFlO0lBQ2YsMkJBQTJCO0lBQzNCQyxTQUFTO0lBQ1QsMENBQTBDO0lBQzFDbGhGLFNBQVM7SUFDVCxrREFBa0Q7SUFDbERtaEYsYUFBYTtJQUNiLGdGQUFnRjtJQUNoRkMsZUFBZTtJQUNmLHFFQUFxRTtJQUNyRUMsU0FBUztBQUNYO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0MsV0FBV2prRyxPQUFPO0lBQ3pCLElBQUksQ0FBQ0EsT0FBTyxHQUFHdkwsT0FBTyxDQUFDLEdBQUcwdUcsWUFBWW5qRztJQUN0QyxJQUFJLENBQUNBLE9BQU8sQ0FBQ3loRSxNQUFNLEdBQUcsSUFBSTtJQUUxQiw4RkFBOEY7SUFDOUYsSUFBSTF0RCxRQUFRLElBQUksQ0FBQy9ULE9BQU8sQ0FBQ3VaLElBQUksQ0FBQ3hGLEtBQUs7SUFDbkMsSUFBSXRDLFFBQVEsSUFBSSxDQUFDelIsT0FBTyxDQUFDdVosSUFBSSxDQUFDOUgsS0FBSztJQUNuQyxJQUFJeXlGLFdBQVd6eUYsTUFBTXRDLE1BQU0sQ0FBQyxTQUFVaGpCLENBQUM7UUFDckMsSUFBSTI4QyxXQUFXMzhDLEVBQUUyakIsTUFBTSxHQUFHRCxJQUFJLENBQUM7UUFDL0IsSUFBSWs1QixXQUFXNThDLEVBQUU0akIsTUFBTSxHQUFHRixJQUFJLENBQUM7UUFDL0IsSUFBSXMwRixZQUFZcHdGLE1BQU04d0IsSUFBSSxDQUFDLFNBQVV6NEMsQ0FBQztZQUNwQyxPQUFPQSxFQUFFeWpCLElBQUksQ0FBQyxVQUFVaTVCO1FBQzFCO1FBQ0EsSUFBSXM3RCxZQUFZcndGLE1BQU04d0IsSUFBSSxDQUFDLFNBQVV6NEMsQ0FBQztZQUNwQyxPQUFPQSxFQUFFeWpCLElBQUksQ0FBQyxVQUFVazVCO1FBQzFCO1FBQ0EsT0FBTyxDQUFDbzdELGFBQWEsQ0FBQ0M7SUFDeEI7SUFDQSxJQUFJLENBQUNwa0csT0FBTyxDQUFDdVosSUFBSSxHQUFHLElBQUksQ0FBQ3ZaLE9BQU8sQ0FBQ3VaLElBQUksQ0FBQ3cyQyxHQUFHLENBQUNtMEM7QUFDNUM7QUFFQTs7Q0FFQyxHQUNERCxXQUFXMzJHLFNBQVMsQ0FBQ21oRCxHQUFHLEdBQUc7SUFDekIsSUFBSXp1QyxVQUFVLElBQUksQ0FBQ0EsT0FBTztJQUMxQixJQUFJeVAsS0FBS3pQLFFBQVF5UCxFQUFFO0lBQ25CLElBQUlneUQsU0FBUyxJQUFJO0lBQ2pCQSxPQUFPM3pCLE9BQU8sR0FBRztJQUNqQixJQUFJOXRDLFFBQVFvdkMsT0FBTyxLQUFLLFFBQVFwdkMsUUFBUW92QyxPQUFPLEtBQUssT0FBTztRQUN6RHF5QixPQUFPcGYsSUFBSSxDQUFDO1lBQ1Z0aEQsTUFBTTtZQUNOMGdFLFFBQVFBO1FBQ1Y7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixJQUFJLFNBQVN6aEUsUUFBUTIvRSxLQUFLLEVBQUU7UUFDMUJ1akIsUUFBUTtJQUNWLE9BQU87UUFDTEEsUUFBUTtJQUNWO0lBRUEseUJBQXlCO0lBQ3pCLElBQUltQixhQUFhQyxpQkFBaUI3MEYsSUFBSWd5RCxRQUFRemhFO0lBRTlDLHdDQUF3QztJQUN4QyxJQUFJa2pHLE9BQU87UUFDVHFCLGdCQUFnQkY7SUFDbEI7SUFFQSx3Q0FBd0M7SUFDeEMsSUFBSXJrRyxRQUFRc2pHLFNBQVMsRUFBRTtRQUNyQmtCLG1CQUFtQkg7SUFDckI7SUFDQSxJQUFJN29CLFlBQVlsekU7SUFDaEIsSUFBSSs2RixVQUFVLFNBQVNBO1FBQ3JCb0IsaUJBQWlCSixZQUFZNTBGLElBQUl6UDtRQUVqQyw2QkFBNkI7UUFDN0IsSUFBSSxTQUFTQSxRQUFRa3dDLEdBQUcsRUFBRTtZQUN4QnpnQyxHQUFHeWdDLEdBQUcsQ0FBQ2x3QyxRQUFRa25CLE9BQU87UUFDeEI7SUFDRjtJQUNBLElBQUl3OUUsV0FBVyxTQUFTQSxTQUFTajJHLENBQUM7UUFDaEMsSUFBSWd6RSxPQUFPM3pCLE9BQU8sSUFBSXIvQyxLQUFLdVIsUUFBUTJpQixPQUFPLEVBQUU7WUFDMUMsMEVBQTBFO1lBQzFFLE9BQU87UUFDVDtRQUVBLHlDQUF5QztRQUN6Q282RCxLQUFLc25CLFlBQVlya0c7UUFFakIscUJBQXFCO1FBQ3JCcWtHLFdBQVdNLFdBQVcsR0FBR04sV0FBV00sV0FBVyxHQUFHM2tHLFFBQVErakcsYUFBYTtRQUN2RSwwREFBMEQ7UUFFMUQsSUFBSU0sV0FBV00sV0FBVyxHQUFHM2tHLFFBQVFna0csT0FBTyxFQUFFO1lBQzVDLDJGQUEyRjtZQUMzRixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxJQUFJbjJHLE9BQU8sU0FBU0E7UUFDbEIsSUFBSW1TLFFBQVFvdkMsT0FBTyxLQUFLLFFBQVFwdkMsUUFBUW92QyxPQUFPLEtBQUssT0FBTztZQUN6RGkwRDtZQUVBLHNCQUFzQjtZQUN0QjVoQyxPQUFPK0IsR0FBRyxDQUFDLGNBQWN4akUsUUFBUWd1QyxJQUFJO1lBQ3JDeXpCLE9BQU9wZixJQUFJLENBQUM7Z0JBQ1Z0aEQsTUFBTTtnQkFDTjBnRSxRQUFRQTtZQUNWO1FBQ0YsT0FBTztZQUNMLElBQUkxdEQsUUFBUS9ULFFBQVF1WixJQUFJLENBQUN4RixLQUFLO1lBQzlCLElBQUk2d0YsZUFBZUMsbUJBQW1CUixZQUFZcmtHLFNBQVMrVDtZQUMzREEsTUFBTW8xRCxlQUFlLENBQUMxSCxRQUFRemhFLFNBQVM0a0c7UUFDekM7SUFDRjtJQUNBLElBQUluMkcsSUFBSTtJQUNSLElBQUlxMkcsVUFBVTtJQUNkLElBQUk5a0csUUFBUW92QyxPQUFPLEtBQUssTUFBTTtRQUM1QixJQUFJMjFELFNBQVMsU0FBU0M7WUFDcEIsSUFBSWozRyxJQUFJO1lBQ1IsTUFBTysyRyxXQUFXLzJHLElBQUlpUyxRQUFRcWpHLE9BQU8sQ0FBRTtnQkFDckN5QixVQUFVSixTQUFTajJHO2dCQUNuQkE7Z0JBQ0FWO1lBQ0Y7WUFDQSxJQUFJLENBQUMrMkcsU0FBUztnQkFDWixZQUFZO2dCQUNaRyxtQkFBbUJaLFlBQVlya0c7Z0JBQy9CblM7WUFDRixPQUFPO2dCQUNMLElBQUlnVSxNQUFNeUc7Z0JBQ1YsSUFBSXpHLE1BQU0yNUUsYUFBYXg3RSxRQUFRb2pHLGtCQUFrQixFQUFFO29CQUNqREM7Z0JBQ0Y7Z0JBQ0FuN0Ysc0JBQXNCNjhGO1lBQ3hCO1FBQ0Y7UUFDQUE7SUFDRixPQUFPO1FBQ0wsTUFBT0QsUUFBUztZQUNkQSxVQUFVSixTQUFTajJHO1lBQ25CQTtRQUNGO1FBQ0F3MkcsbUJBQW1CWixZQUFZcmtHO1FBQy9CblM7SUFDRjtJQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFFQTs7Q0FFQyxHQUNEbzJHLFdBQVczMkcsU0FBUyxDQUFDMGdELElBQUksR0FBRztJQUMxQixJQUFJLENBQUNGLE9BQU8sR0FBRztJQUNmLElBQUksSUFBSSxDQUFDbzNELE1BQU0sRUFBRTtRQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDbDNELElBQUk7SUFDbEI7SUFDQSxJQUFJLENBQUNxVSxJQUFJLENBQUM7SUFDVixPQUFPLElBQUksRUFBRSxXQUFXO0FBQzFCO0FBQ0E0aEQsV0FBVzMyRyxTQUFTLENBQUM0dEcsT0FBTyxHQUFHO0lBQzdCLElBQUksSUFBSSxDQUFDZ0ssTUFBTSxFQUFFO1FBQ2YsSUFBSSxDQUFDQSxNQUFNLENBQUNsM0QsSUFBSTtJQUNsQjtJQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUlzMkQsbUJBQW1CLFNBQVNBLGlCQUFpQjcwRixFQUFFLEVBQUVneUQsTUFBTSxFQUFFemhFLE9BQU87SUFDbEUsV0FBVztJQUNYLElBQUl5UixRQUFRelIsUUFBUXVaLElBQUksQ0FBQzlILEtBQUs7SUFDOUIsSUFBSXNDLFFBQVEvVCxRQUFRdVosSUFBSSxDQUFDeEYsS0FBSztJQUM5QixJQUFJMlMsS0FBS0QsZ0JBQWdCem1CLFFBQVFuTyxXQUFXLEdBQUdtTyxRQUFRbk8sV0FBVyxHQUFHO1FBQ25FQyxJQUFJO1FBQ0pFLElBQUk7UUFDSm1aLEdBQUdzRSxHQUFHMlosS0FBSztRQUNYN3pCLEdBQUdrYSxHQUFHNFosTUFBTTtJQUNkO0lBQ0EsSUFBSWc3RSxhQUFhO1FBQ2ZjLFlBQVkxMUYsR0FBRzZnRCxnQkFBZ0I7UUFDL0I4MEMsYUFBYSxFQUFFO1FBQ2ZDLFdBQVcsQ0FBQztRQUNadFYsVUFBVWg4RSxNQUFNaEYsSUFBSTtRQUNwQnUyRixVQUFVLEVBQUU7UUFDWkMsY0FBYyxFQUFFO1FBQ2hCQyxhQUFhLEVBQUU7UUFDZkMsVUFBVWgwRixNQUFNMUMsSUFBSTtRQUNwQjQxRixhQUFhM2tHLFFBQVE4akcsV0FBVztRQUNoQ3ZKLGFBQWE3ekUsR0FBR3ZiLENBQUM7UUFDakJxdkYsY0FBYzl6RSxHQUFHbnhCLENBQUM7UUFDbEIxRCxhQUFhNjBCO0lBQ2Y7SUFDQSxJQUFJdEMsYUFBYXBrQixRQUFRdVosSUFBSSxDQUFDNkssVUFBVTtJQUN4QyxJQUFJc2hGLFlBQVksQ0FBQztJQUNqQixJQUFLLElBQUlqM0csSUFBSSxHQUFHQSxJQUFJMjFCLFdBQVdsNEIsTUFBTSxFQUFFdUMsSUFBSztRQUMxQyxJQUFJMDFCLFlBQVlDLFVBQVUsQ0FBQzMxQixFQUFFO1FBQzdCLElBQUssSUFBSXFHLElBQUksR0FBR0EsSUFBSXF2QixVQUFVajRCLE1BQU0sRUFBRTRJLElBQUs7WUFDekMsSUFBSXNnQixPQUFPK08sU0FBUyxDQUFDcnZCLEVBQUU7WUFDdkI0d0csU0FBUyxDQUFDdHdGLEtBQUtsQixFQUFFLEdBQUcsR0FBR3psQjtRQUN6QjtJQUNGO0lBRUEsZ0RBQWdEO0lBQ2hELElBQUssSUFBSUEsSUFBSSxHQUFHQSxJQUFJNDFHLFdBQVd0VSxRQUFRLEVBQUV0aEcsSUFBSztRQUM1QyxJQUFJckMsSUFBSTJuQixLQUFLLENBQUN0bEIsRUFBRTtRQUNoQixJQUFJNndHLE1BQU1sekcsRUFBRTQ4RSxnQkFBZ0IsQ0FBQ2hwRTtRQUM3QixJQUFJMmxHLFdBQVcsQ0FBQztRQUNoQkEsU0FBU0MsUUFBUSxHQUFHeDVHLEVBQUUwa0IsTUFBTTtRQUM1QjYwRixTQUFTenhGLEVBQUUsR0FBRzluQixFQUFFeWpCLElBQUksQ0FBQztRQUNyQjgxRixTQUFTdHhCLFFBQVEsR0FBR2pvRixFQUFFeWpCLElBQUksQ0FBQztRQUMzQjgxRixTQUFTRSxNQUFNLEdBQUdILFNBQVMsQ0FBQ3Q1RyxFQUFFOG5CLEVBQUUsR0FBRztRQUNuQ3l4RixTQUFTajBGLFFBQVEsR0FBRyxFQUFFO1FBQ3RCaTBGLFNBQVNHLFNBQVMsR0FBRzE1RyxFQUFFNmpCLFFBQVEsQ0FBQztRQUNoQzAxRixTQUFTSSxTQUFTLEdBQUczNUcsRUFBRTZqQixRQUFRLENBQUM7UUFDaEMwMUYsU0FBU3AxRSxPQUFPLEdBQUc7UUFDbkJvMUUsU0FBU24xRSxPQUFPLEdBQUc7UUFDbkJtMUUsU0FBU3Q4RSxNQUFNLEdBQUdpMkUsSUFBSW4wRixDQUFDO1FBQ3ZCdzZGLFNBQVN2OEUsS0FBSyxHQUFHazJFLElBQUkvcEcsQ0FBQztRQUN0Qm93RyxTQUFTdHhFLElBQUksR0FBR3N4RSxTQUFTRyxTQUFTLEdBQUdILFNBQVN2OEUsS0FBSyxHQUFHO1FBQ3REdThFLFNBQVN4eEUsSUFBSSxHQUFHd3hFLFNBQVNHLFNBQVMsR0FBR0gsU0FBU3Y4RSxLQUFLLEdBQUc7UUFDdER1OEUsU0FBU3J4RSxJQUFJLEdBQUdxeEUsU0FBU0ksU0FBUyxHQUFHSixTQUFTdDhFLE1BQU0sR0FBRztRQUN2RHM4RSxTQUFTdnhFLElBQUksR0FBR3V4RSxTQUFTSSxTQUFTLEdBQUdKLFNBQVN0OEUsTUFBTSxHQUFHO1FBQ3ZEczhFLFNBQVNLLE9BQU8sR0FBR2x3RyxXQUFXMUosRUFBRW1rQixLQUFLLENBQUM7UUFDdENvMUYsU0FBU00sUUFBUSxHQUFHbndHLFdBQVcxSixFQUFFbWtCLEtBQUssQ0FBQztRQUN2Q28xRixTQUFTTyxNQUFNLEdBQUdwd0csV0FBVzFKLEVBQUVta0IsS0FBSyxDQUFDO1FBQ3JDbzFGLFNBQVNRLFNBQVMsR0FBR3J3RyxXQUFXMUosRUFBRW1rQixLQUFLLENBQUM7UUFFeEMsU0FBUztRQUNUbzFGLFNBQVNuQyxhQUFhLEdBQUduekcsS0FBSzJQLFFBQVF3akcsYUFBYSxJQUFJeGpHLFFBQVF3akcsYUFBYSxDQUFDcDNHLEtBQUs0VCxRQUFRd2pHLGFBQWE7UUFFdkcsZUFBZTtRQUNmYSxXQUFXZSxXQUFXLENBQUMxMkcsSUFBSSxDQUFDaTNHO1FBQzVCLDRCQUE0QjtRQUM1QnRCLFdBQVdnQixTQUFTLENBQUNNLFNBQVN6eEYsRUFBRSxDQUFDLEdBQUd6bEI7SUFDdEM7SUFFQSwrRUFBK0U7SUFDL0UsSUFBSTZpQixRQUFRLEVBQUU7SUFDZCxJQUFJNlAsUUFBUSxHQUFHLGdDQUFnQztJQUMvQyxJQUFJdkIsTUFBTSxDQUFDLEdBQUcsaUNBQWlDO0lBRS9DLElBQUl3bUYsWUFBWSxFQUFFO0lBRWxCLDJDQUEyQztJQUMzQyw4Q0FBOEM7SUFDOUMsSUFBSyxJQUFJMzNHLElBQUksR0FBR0EsSUFBSTQxRyxXQUFXdFUsUUFBUSxFQUFFdGhHLElBQUs7UUFDNUMsSUFBSXJDLElBQUlpNEcsV0FBV2UsV0FBVyxDQUFDMzJHLEVBQUU7UUFDakMsSUFBSTQzRyxPQUFPajZHLEVBQUVpb0YsUUFBUTtRQUNyQixvQ0FBb0M7UUFDcEMsSUFBSSxRQUFRZ3lCLE1BQU07WUFDaEIsMkNBQTJDO1lBQzNDaEMsV0FBV2UsV0FBVyxDQUFDZixXQUFXZ0IsU0FBUyxDQUFDZ0IsS0FBSyxDQUFDLENBQUMzMEYsUUFBUSxDQUFDaGpCLElBQUksQ0FBQ3RDLEVBQUU4bkIsRUFBRTtRQUN2RSxPQUFPO1lBQ0wsK0RBQStEO1lBQy9ENUMsS0FBSyxDQUFDLEVBQUVzTyxJQUFJLEdBQUd4ekIsRUFBRThuQixFQUFFO1lBQ25Ca3lGLFVBQVUxM0csSUFBSSxDQUFDdEMsRUFBRThuQixFQUFFO1FBQ3JCO0lBQ0Y7SUFFQSw2QkFBNkI7SUFDN0Jtd0YsV0FBV2lCLFFBQVEsQ0FBQzUyRyxJQUFJLENBQUMwM0c7SUFFekIsc0NBQXNDO0lBQ3RDLE1BQU9qbEYsU0FBU3ZCLElBQUs7UUFDbkIsaURBQWlEO1FBQ2pELElBQUkwbUYsVUFBVWgxRixLQUFLLENBQUM2UCxRQUFRO1FBQzVCLElBQUlvbEYsVUFBVWxDLFdBQVdnQixTQUFTLENBQUNpQixRQUFRO1FBQzNDLElBQUlseEYsT0FBT2l2RixXQUFXZSxXQUFXLENBQUNtQixRQUFRO1FBQzFDLElBQUk3MEYsV0FBVzBELEtBQUsxRCxRQUFRO1FBQzVCLElBQUlBLFNBQVN4bEIsTUFBTSxHQUFHLEdBQUc7WUFDdkIsaURBQWlEO1lBQ2pEbTRHLFdBQVdpQixRQUFRLENBQUM1MkcsSUFBSSxDQUFDZ2pCO1lBQ3pCLDBDQUEwQztZQUMxQyxJQUFLLElBQUlqakIsSUFBSSxHQUFHQSxJQUFJaWpCLFNBQVN4bEIsTUFBTSxFQUFFdUMsSUFBSztnQkFDeEM2aUIsS0FBSyxDQUFDLEVBQUVzTyxJQUFJLEdBQUdsTyxRQUFRLENBQUNqakIsRUFBRTtZQUM1QjtRQUNGO0lBQ0Y7SUFFQSwwQkFBMEI7SUFDMUIsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUk0MUcsV0FBV2lCLFFBQVEsQ0FBQ3A1RyxNQUFNLEVBQUV1QyxJQUFLO1FBQ25ELElBQUlvdkcsUUFBUXdHLFdBQVdpQixRQUFRLENBQUM3MkcsRUFBRTtRQUNsQyxJQUFLLElBQUlxRyxJQUFJLEdBQUdBLElBQUkrb0csTUFBTTN4RyxNQUFNLEVBQUU0SSxJQUFLO1lBQ3JDLElBQUlzTixRQUFRaWlHLFdBQVdnQixTQUFTLENBQUN4SCxLQUFLLENBQUMvb0csRUFBRSxDQUFDO1lBQzFDdXZHLFdBQVdrQixZQUFZLENBQUNuakcsTUFBTSxHQUFHM1Q7UUFDbkM7SUFDRjtJQUVBLGdEQUFnRDtJQUNoRCxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSTQxRyxXQUFXb0IsUUFBUSxFQUFFaDNHLElBQUs7UUFDNUMsSUFBSXRDLElBQUlzbEIsS0FBSyxDQUFDaGpCLEVBQUU7UUFDaEIsSUFBSSszRyxXQUFXLENBQUM7UUFDaEJBLFNBQVN0eUYsRUFBRSxHQUFHL25CLEVBQUUwakIsSUFBSSxDQUFDO1FBQ3JCMjJGLFNBQVMxOUQsUUFBUSxHQUFHMzhDLEVBQUUwakIsSUFBSSxDQUFDO1FBQzNCMjJGLFNBQVN6OUQsUUFBUSxHQUFHNThDLEVBQUUwakIsSUFBSSxDQUFDO1FBRTNCLHVCQUF1QjtRQUN2QixJQUFJNDJGLGNBQWNwMkcsS0FBSzJQLFFBQVEwakcsZUFBZSxJQUFJMWpHLFFBQVEwakcsZUFBZSxDQUFDdjNHLEtBQUs2VCxRQUFRMGpHLGVBQWU7UUFDdEcsSUFBSWdELGFBQWFyMkcsS0FBSzJQLFFBQVEyakcsY0FBYyxJQUFJM2pHLFFBQVEyakcsY0FBYyxDQUFDeDNHLEtBQUs2VCxRQUFRMmpHLGNBQWM7UUFFbEcsb0NBQW9DO1FBQ3BDLElBQUlnRCxXQUFXdEMsV0FBV2dCLFNBQVMsQ0FBQ21CLFNBQVMxOUQsUUFBUSxDQUFDO1FBQ3RELElBQUk4OUQsV0FBV3ZDLFdBQVdnQixTQUFTLENBQUNtQixTQUFTejlELFFBQVEsQ0FBQztRQUN0RCxJQUFJODlELGNBQWN4QyxXQUFXa0IsWUFBWSxDQUFDb0IsU0FBUztRQUNuRCxJQUFJRyxjQUFjekMsV0FBV2tCLFlBQVksQ0FBQ3FCLFNBQVM7UUFDbkQsSUFBSUMsZUFBZUMsYUFBYTtZQUM5QixvQ0FBb0M7WUFDcEMsSUFBSUMsTUFBTUMsUUFBUVIsU0FBUzE5RCxRQUFRLEVBQUUwOUQsU0FBU3o5RCxRQUFRLEVBQUVzN0Q7WUFFeEQsb0RBQW9EO1lBQ3BELElBQUk0QyxXQUFXNUMsV0FBV2lCLFFBQVEsQ0FBQ3lCLElBQUk7WUFDdkMsSUFBSXZ5RixRQUFRO1lBRVosZUFBZTtZQUNmLElBQUlteEYsV0FBV3RCLFdBQVdlLFdBQVcsQ0FBQ3VCLFNBQVM7WUFDL0MsTUFBTyxDQUFDLE1BQU1NLFNBQVNydkYsT0FBTyxDQUFDK3RGLFNBQVN6eEYsRUFBRSxFQUFHO2dCQUMzQ3l4RixXQUFXdEIsV0FBV2UsV0FBVyxDQUFDZixXQUFXZ0IsU0FBUyxDQUFDTSxTQUFTdHhCLFFBQVEsQ0FBQyxDQUFDO2dCQUMxRTcvRDtZQUNGO1lBRUEsZUFBZTtZQUNmbXhGLFdBQVd0QixXQUFXZSxXQUFXLENBQUN3QixTQUFTO1lBQzNDLE1BQU8sQ0FBQyxNQUFNSyxTQUFTcnZGLE9BQU8sQ0FBQyt0RixTQUFTenhGLEVBQUUsRUFBRztnQkFDM0N5eEYsV0FBV3RCLFdBQVdlLFdBQVcsQ0FBQ2YsV0FBV2dCLFNBQVMsQ0FBQ00sU0FBU3R4QixRQUFRLENBQUMsQ0FBQztnQkFDMUU3L0Q7WUFDRjtZQUVBLCtFQUErRTtZQUMvRSw2REFBNkQ7WUFDN0QseUJBQXlCO1lBRXpCLHFCQUFxQjtZQUNyQml5RixlQUFlanlGLFFBQVF4VSxRQUFRNGpHLGFBQWE7UUFDOUM7UUFDQTRDLFNBQVNDLFdBQVcsR0FBR0E7UUFDdkJELFNBQVNFLFVBQVUsR0FBR0E7UUFDdEJyQyxXQUFXbUIsV0FBVyxDQUFDOTJHLElBQUksQ0FBQzgzRztJQUM5QjtJQUVBLG9DQUFvQztJQUNwQyxPQUFPbkM7QUFDVDtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxJQUFJMkMsVUFBVSxTQUFTQSxRQUFROW1GLEtBQUssRUFBRUMsS0FBSyxFQUFFa2tGLFVBQVU7SUFDckQsMkRBQTJEO0lBQzNELElBQUl4bEYsTUFBTXFvRixhQUFhaG5GLE9BQU9DLE9BQU8sR0FBR2trRjtJQUN4QyxJQUFJLElBQUl4bEYsSUFBSXNvRixLQUFLLEVBQUU7UUFDakIscURBQXFEO1FBQ3JELDRCQUE0QjtRQUM1QixPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU90b0YsSUFBSWcvRSxLQUFLO0lBQ2xCO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsSUFBSXFKLGVBQWUsU0FBU0UsWUFBWWxuRixLQUFLLEVBQUVDLEtBQUssRUFBRWtuRixPQUFPLEVBQUVoRCxVQUFVO0lBQ3ZFLElBQUl4RyxRQUFRd0csV0FBV2lCLFFBQVEsQ0FBQytCLFFBQVE7SUFDeEMsbUNBQW1DO0lBQ25DLElBQUksQ0FBQyxJQUFJeEosTUFBTWptRixPQUFPLENBQUNzSSxVQUFVLENBQUMsSUFBSTI5RSxNQUFNam1GLE9BQU8sQ0FBQ3VJLFFBQVE7UUFDMUQsT0FBTztZQUNMZ25GLE9BQU87WUFDUHRKLE9BQU93SjtRQUNUO0lBQ0Y7SUFFQSx5Q0FBeUM7SUFDekMsSUFBSTdsRixJQUFJO0lBQ1IsSUFBSyxJQUFJL3lCLElBQUksR0FBR0EsSUFBSW92RyxNQUFNM3hHLE1BQU0sRUFBRXVDLElBQUs7UUFDckMsSUFBSWc2QyxTQUFTbzFELEtBQUssQ0FBQ3B2RyxFQUFFO1FBQ3JCLElBQUk2NEcsU0FBU2pELFdBQVdnQixTQUFTLENBQUM1OEQsT0FBTztRQUN6QyxJQUFJLzJCLFdBQVcyeUYsV0FBV2UsV0FBVyxDQUFDa0MsT0FBTyxDQUFDNTFGLFFBQVE7UUFFdEQsb0NBQW9DO1FBQ3BDLElBQUksTUFBTUEsU0FBU3hsQixNQUFNLEVBQUU7WUFDekI7UUFDRjtRQUNBLElBQUlxN0csZUFBZWxELFdBQVdrQixZQUFZLENBQUNsQixXQUFXZ0IsU0FBUyxDQUFDM3pGLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM3RSxJQUFJbE8sU0FBUzBqRyxhQUFhaG5GLE9BQU9DLE9BQU9vbkYsY0FBY2xEO1FBQ3RELElBQUksTUFBTTdnRyxPQUFPMmpHLEtBQUssRUFBRTtZQUV0QjtRQUNGLE9BQU8sSUFBSSxNQUFNM2pHLE9BQU8yakcsS0FBSyxFQUFFO1lBQzdCLG9EQUFvRDtZQUNwRDNsRjtZQUNBLElBQUksTUFBTUEsR0FBRztnQkFFWDtZQUNGO1FBQ0YsT0FBTztZQUNMLDBDQUEwQztZQUMxQyxPQUFPaGU7UUFDVDtJQUNGO0lBQ0EsT0FBTztRQUNMMmpHLE9BQU8zbEY7UUFDUHE4RSxPQUFPd0o7SUFDVDtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsSUFBSTlDO0FBRUo7O0NBRUMsR0FDRCxJQUFJQyxxQkFBcUIsU0FBU0EsbUJBQW1CSCxVQUFVLEVBQUU1MEYsRUFBRTtJQUNqRSxJQUFJMlosUUFBUWk3RSxXQUFXOUosV0FBVztJQUNsQyxJQUFJbHhFLFNBQVNnN0UsV0FBVzdKLFlBQVk7SUFDcEMsSUFBSyxJQUFJL3JHLElBQUksR0FBR0EsSUFBSTQxRyxXQUFXdFUsUUFBUSxFQUFFdGhHLElBQUs7UUFDNUMsSUFBSXJDLElBQUlpNEcsV0FBV2UsV0FBVyxDQUFDMzJHLEVBQUU7UUFFakMsc0RBQXNEO1FBQ3RELElBQUksTUFBTXJDLEVBQUVzbEIsUUFBUSxDQUFDeGxCLE1BQU0sSUFBSSxDQUFDRSxFQUFFdzVHLFFBQVEsRUFBRTtZQUMxQ3g1RyxFQUFFMDVHLFNBQVMsR0FBRzkwRyxLQUFLOGIsTUFBTSxLQUFLc2M7WUFDOUJoOUIsRUFBRTI1RyxTQUFTLEdBQUcvMEcsS0FBSzhiLE1BQU0sS0FBS3VjO1FBQ2hDO0lBQ0Y7QUFDRjtBQUNBLElBQUl3N0UscUJBQXFCLFNBQVNBLG1CQUFtQlIsVUFBVSxFQUFFcmtHLE9BQU8sRUFBRStULEtBQUs7SUFDN0UsSUFBSTJTLEtBQUsyOUUsV0FBV3h5RyxXQUFXO0lBQy9CLElBQUkyMUcsU0FBUztRQUNYMTFHLElBQUltb0I7UUFDSmxvQixJQUFJLENBQUNrb0I7UUFDTGpvQixJQUFJaW9CO1FBQ0pob0IsSUFBSSxDQUFDZ29CO0lBQ1A7SUFDQSxJQUFJamEsUUFBUW5PLFdBQVcsRUFBRTtRQUN2QmtpQixNQUFNM0UsT0FBTyxDQUFDLFNBQVVnRyxJQUFJO1lBQzFCLElBQUlxeUYsUUFBUXBELFdBQVdlLFdBQVcsQ0FBQ2YsV0FBV2dCLFNBQVMsQ0FBQ2p3RixLQUFLdkYsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN6RTIzRixPQUFPMTFHLEVBQUUsR0FBR2QsS0FBSytVLEdBQUcsQ0FBQ3loRyxPQUFPMTFHLEVBQUUsRUFBRTIxRyxNQUFNM0IsU0FBUztZQUMvQzBCLE9BQU96MUcsRUFBRSxHQUFHZixLQUFLNlUsR0FBRyxDQUFDMmhHLE9BQU96MUcsRUFBRSxFQUFFMDFHLE1BQU0zQixTQUFTO1lBQy9DMEIsT0FBT3gxRyxFQUFFLEdBQUdoQixLQUFLK1UsR0FBRyxDQUFDeWhHLE9BQU94MUcsRUFBRSxFQUFFeTFHLE1BQU0xQixTQUFTO1lBQy9DeUIsT0FBT3YxRyxFQUFFLEdBQUdqQixLQUFLNlUsR0FBRyxDQUFDMmhHLE9BQU92MUcsRUFBRSxFQUFFdzFHLE1BQU0xQixTQUFTO1FBQ2pEO1FBQ0F5QixPQUFPcjhGLENBQUMsR0FBR3E4RixPQUFPejFHLEVBQUUsR0FBR3kxRyxPQUFPMTFHLEVBQUU7UUFDaEMwMUcsT0FBT2p5RyxDQUFDLEdBQUdpeUcsT0FBT3YxRyxFQUFFLEdBQUd1MUcsT0FBT3gxRyxFQUFFO0lBQ2xDO0lBQ0EsT0FBTyxTQUFVd2IsR0FBRyxFQUFFL2UsQ0FBQztRQUNyQixJQUFJZzVHLFFBQVFwRCxXQUFXZSxXQUFXLENBQUNmLFdBQVdnQixTQUFTLENBQUM3M0YsSUFBSXFDLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDeEUsSUFBSTdQLFFBQVFuTyxXQUFXLEVBQUU7WUFDdkIseUNBQXlDO1lBQ3pDLDBEQUEwRDtZQUMxRCxJQUFJNjFHLE9BQU9GLE9BQU9yOEYsQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDczhGLE1BQU0zQixTQUFTLEdBQUcwQixPQUFPMTFHLEVBQUUsSUFBSTAxRyxPQUFPcjhGLENBQUM7WUFDMUUsSUFBSXc4RixPQUFPSCxPQUFPanlHLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQ2t5RyxNQUFNMUIsU0FBUyxHQUFHeUIsT0FBT3gxRyxFQUFFLElBQUl3MUcsT0FBT2p5RyxDQUFDO1lBQzFFLE9BQU87Z0JBQ0xpTCxHQUFHa21CLEdBQUc1MEIsRUFBRSxHQUFHNDFHLE9BQU9oaEYsR0FBR3ZiLENBQUM7Z0JBQ3RCbEIsR0FBR3ljLEdBQUcxMEIsRUFBRSxHQUFHMjFHLE9BQU9qaEYsR0FBR254QixDQUFDO1lBQ3hCO1FBQ0YsT0FBTztZQUNMLE9BQU87Z0JBQ0xpTCxHQUFHaW5HLE1BQU0zQixTQUFTO2dCQUNsQjc3RixHQUFHdzlGLE1BQU0xQixTQUFTO1lBQ3BCO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxJQUFJdEIsbUJBQW1CLFNBQVNBLGlCQUFpQkosVUFBVSxFQUFFNTBGLEVBQUUsRUFBRXpQLE9BQU87SUFDdEUsa0NBQWtDO0lBQ2xDLGVBQWU7SUFFZixJQUFJeWhFLFNBQVN6aEUsUUFBUXloRSxNQUFNO0lBQzNCLElBQUkxdEQsUUFBUS9ULFFBQVF1WixJQUFJLENBQUN4RixLQUFLO0lBQzlCLElBQUk2d0YsZUFBZUMsbUJBQW1CUixZQUFZcmtHLFNBQVMrVDtJQUMzREEsTUFBTXcrQyxTQUFTLENBQUNxeUM7SUFFaEIseUNBQXlDO0lBQ3pDLElBQUksU0FBU1AsV0FBVzc1QixLQUFLLEVBQUU7UUFDN0IsZ0NBQWdDO1FBQ2hDLGVBQWU7UUFDZjY1QixXQUFXNzVCLEtBQUssR0FBRztRQUNuQi9JLE9BQU8rQixHQUFHLENBQUMsZUFBZXhqRSxRQUFRd3FFLEtBQUs7UUFDdkMvSSxPQUFPcGYsSUFBSSxDQUFDO1lBQ1Z0aEQsTUFBTTtZQUNOMGdFLFFBQVEsSUFBSTtRQUNkO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ0Qsa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQiwyQkFBMkI7QUFDM0IsTUFBTTtBQUNOLEtBQUs7QUFFTDs7Ozs7Q0FLQyxHQUNELElBQUlzYixPQUFPLFNBQVNBLEtBQUtzbkIsVUFBVSxFQUFFcmtHLE9BQU8sRUFBRTYxQixLQUFLO0lBQ2pELGlEQUFpRDtJQUNqRCwwQkFBMEI7SUFDMUIsOENBQThDO0lBQzlDLGVBQWU7SUFFZiw0QkFBNEI7SUFDNUIreEUsb0JBQW9CdkQsWUFBWXJrRztJQUNoQyx3QkFBd0I7SUFDeEI2bkcsb0JBQW9CeEQ7SUFDcEIsMkJBQTJCO0lBQzNCeUQsdUJBQXVCekQsWUFBWXJrRztJQUNuQyx3Q0FBd0M7SUFDeEMrbkcsZ0JBQWdCMUQ7SUFDaEIsOENBQThDO0lBQzlDMkQsZ0JBQWdCM0Q7QUFDbEI7QUFFQTs7Q0FFQyxHQUNELElBQUl1RCxzQkFBc0IsU0FBU0Esb0JBQW9CdkQsVUFBVSxFQUFFcmtHLE9BQU87SUFDeEUsNENBQTRDO0lBQzVDLCtEQUErRDtJQUMvRCxpQ0FBaUM7SUFDakMsZUFBZTtJQUNmLElBQUssSUFBSXZSLElBQUksR0FBR0EsSUFBSTQxRyxXQUFXaUIsUUFBUSxDQUFDcDVHLE1BQU0sRUFBRXVDLElBQUs7UUFDbkQsSUFBSW92RyxRQUFRd0csV0FBV2lCLFFBQVEsQ0FBQzcyRyxFQUFFO1FBQ2xDLElBQUk4c0IsV0FBV3NpRixNQUFNM3hHLE1BQU07UUFFM0Isa0NBQWtDO1FBQ2xDLGVBQWU7UUFFZixpQ0FBaUM7UUFDakMsMkNBQTJDO1FBQzNDLElBQUssSUFBSTRJLElBQUksR0FBR0EsSUFBSXltQixVQUFVem1CLElBQUs7WUFDakMsSUFBSW9yQixRQUFRbWtGLFdBQVdlLFdBQVcsQ0FBQ2YsV0FBV2dCLFNBQVMsQ0FBQ3hILEtBQUssQ0FBQy9vRyxFQUFFLENBQUMsQ0FBQztZQUNsRSxJQUFLLElBQUkvQixJQUFJK0IsSUFBSSxHQUFHL0IsSUFBSXdvQixVQUFVeG9CLElBQUs7Z0JBQ3JDLElBQUlvdEIsUUFBUWtrRixXQUFXZSxXQUFXLENBQUNmLFdBQVdnQixTQUFTLENBQUN4SCxLQUFLLENBQUM5cUcsRUFBRSxDQUFDLENBQUM7Z0JBQ2xFeXdHLGNBQWN0akYsT0FBT0MsT0FBT2trRixZQUFZcmtHO1lBQzFDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSWlvRyxpQkFBaUIsU0FBU0EsZUFBZXBpRyxHQUFHO0lBQzlDLE9BQU8sQ0FBQyxJQUFJLElBQUlBLE1BQU03VSxLQUFLOGIsTUFBTTtBQUNuQztBQUVBOztDQUVDLEdBQ0QsSUFBSTAyRixnQkFBZ0IsU0FBU0EsY0FBY3RqRixLQUFLLEVBQUVDLEtBQUssRUFBRWtrRixVQUFVLEVBQUVya0csT0FBTztJQUMxRSx3RUFBd0U7SUFFeEUsSUFBSWtvRyxVQUFVaG9GLE1BQU0ybEYsTUFBTTtJQUMxQixJQUFJc0MsVUFBVWhvRixNQUFNMGxGLE1BQU07SUFDMUIsSUFBSXFDLFlBQVlDLFdBQVcsQ0FBQzlELFdBQVdjLFVBQVUsRUFBRTtRQUNqRDtJQUNGO0lBRUEscURBQXFEO0lBQ3JELElBQUlpRCxhQUFham9GLE1BQU0ybEYsU0FBUyxHQUFHNWxGLE1BQU00bEYsU0FBUztJQUNsRCxJQUFJdUMsYUFBYWxvRixNQUFNNGxGLFNBQVMsR0FBRzdsRixNQUFNNmxGLFNBQVM7SUFDbEQsSUFBSXVDLGNBQWM7SUFDbEIsc0VBQXNFO0lBRXRFLHFEQUFxRDtJQUNyRCxJQUFJLE1BQU1GLGNBQWMsTUFBTUMsWUFBWTtRQUN4Q0QsYUFBYUgsZUFBZUs7UUFDNUJELGFBQWFKLGVBQWVLO0lBQzlCO0lBQ0EsSUFBSUMsVUFBVUMsYUFBYXRvRixPQUFPQyxPQUFPaW9GLFlBQVlDO0lBQ3JELElBQUlFLFVBQVUsR0FBRztRQUNmLDhCQUE4QjtRQUM5QixnQ0FBZ0M7UUFDaEMsb0RBQW9EO1FBQ3BELGlCQUFpQjtRQUNqQixJQUFJdjBDLFFBQVFoMEQsUUFBUXlqRyxXQUFXLEdBQUc4RTtRQUVsQyx3REFBd0Q7UUFDeEQsSUFBSS9xRixXQUFXeHNCLEtBQUsyd0IsSUFBSSxDQUFDeW1GLGFBQWFBLGFBQWFDLGFBQWFBO1FBQ2hFLGtDQUFrQztRQUNsQyxJQUFJSSxTQUFTejBDLFFBQVFvMEMsYUFBYTVxRjtRQUNsQyxJQUFJa3JGLFNBQVMxMEMsUUFBUXEwQyxhQUFhN3FGO0lBQ3BDLE9BQU87UUFDTCxrQ0FBa0M7UUFDbEMseURBQXlEO1FBQ3pELHNCQUFzQjtRQUV0QixxQ0FBcUM7UUFDckMsSUFBSW1yRixTQUFTQyxrQkFBa0Ixb0YsT0FBT2tvRixZQUFZQztRQUNsRCxJQUFJUSxTQUFTRCxrQkFBa0J6b0YsT0FBTyxDQUFDLElBQUlpb0YsWUFBWSxDQUFDLElBQUlDO1FBRTVELDBDQUEwQztRQUMxQyxJQUFJMUgsWUFBWWtJLE9BQU9yb0csQ0FBQyxHQUFHbW9HLE9BQU9ub0csQ0FBQztRQUNuQyxJQUFJNi9GLFlBQVl3SSxPQUFPNStGLENBQUMsR0FBRzArRixPQUFPMStGLENBQUM7UUFDbkMsSUFBSTYrRixjQUFjbkksWUFBWUEsWUFBWU4sWUFBWUE7UUFDdEQsSUFBSTdpRixXQUFXeHNCLEtBQUsyd0IsSUFBSSxDQUFDbW5GO1FBQ3pCLGtDQUFrQztRQUVsQyx3REFBd0Q7UUFDeEQsSUFBSTkwQyxRQUFRLENBQUM5ekMsTUFBTXNqRixhQUFhLEdBQUdyakYsTUFBTXFqRixhQUFhLElBQUlzRjtRQUMxRCxJQUFJTCxTQUFTejBDLFFBQVEyc0MsWUFBWW5qRjtRQUNqQyxJQUFJa3JGLFNBQVMxMEMsUUFBUXFzQyxZQUFZN2lGO0lBQ25DO0lBRUEsY0FBYztJQUNkLElBQUksQ0FBQzBDLE1BQU0wbEYsUUFBUSxFQUFFO1FBQ25CMWxGLE1BQU1xUSxPQUFPLElBQUlrNEU7UUFDakJ2b0YsTUFBTXNRLE9BQU8sSUFBSWs0RTtJQUNuQjtJQUNBLElBQUksQ0FBQ3ZvRixNQUFNeWxGLFFBQVEsRUFBRTtRQUNuQnpsRixNQUFNb1EsT0FBTyxJQUFJazRFO1FBQ2pCdG9GLE1BQU1xUSxPQUFPLElBQUlrNEU7SUFDbkI7SUFFQSxxREFBcUQ7SUFDckQsZUFBZTtJQUVmO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxJQUFJRixlQUFlLFNBQVNBLGFBQWF0b0YsS0FBSyxFQUFFQyxLQUFLLEVBQUU0b0YsRUFBRSxFQUFFQyxFQUFFO0lBQzNELElBQUlELEtBQUssR0FBRztRQUNWLElBQUlFLFdBQVcvb0YsTUFBTW1VLElBQUksR0FBR2xVLE1BQU1nVSxJQUFJO0lBQ3hDLE9BQU87UUFDTCxJQUFJODBFLFdBQVc5b0YsTUFBTWtVLElBQUksR0FBR25VLE1BQU1pVSxJQUFJO0lBQ3hDO0lBQ0EsSUFBSTYwRSxLQUFLLEdBQUc7UUFDVixJQUFJRSxXQUFXaHBGLE1BQU1vVSxJQUFJLEdBQUduVSxNQUFNaVUsSUFBSTtJQUN4QyxPQUFPO1FBQ0wsSUFBSTgwRSxXQUFXL29GLE1BQU1tVSxJQUFJLEdBQUdwVSxNQUFNa1UsSUFBSTtJQUN4QztJQUNBLElBQUk2MEUsWUFBWSxLQUFLQyxZQUFZLEdBQUc7UUFDbEMsT0FBT2w0RyxLQUFLMndCLElBQUksQ0FBQ3NuRixXQUFXQSxXQUFXQyxXQUFXQTtJQUNwRCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxJQUFJTixvQkFBb0IsU0FBU0Esa0JBQWtCeHpGLElBQUksRUFBRTJ6RixFQUFFLEVBQUVDLEVBQUU7SUFDN0QsV0FBVztJQUNYLElBQUlHLElBQUkvekYsS0FBSzB3RixTQUFTO0lBQ3RCLElBQUlzRCxJQUFJaDBGLEtBQUsyd0YsU0FBUztJQUN0QixJQUFJc0QsSUFBSWowRixLQUFLaVUsTUFBTSxJQUFJO0lBQ3ZCLElBQUlpZ0YsSUFBSWwwRixLQUFLZ1UsS0FBSyxJQUFJO0lBQ3RCLElBQUltZ0YsV0FBV1AsS0FBS0Q7SUFDcEIsSUFBSVMsWUFBWUgsSUFBSUM7SUFFcEIsMERBQTBEO0lBQzFELDJDQUEyQztJQUMzQyxxQ0FBcUM7SUFDckMsRUFBRTtJQUNGLHVCQUF1QjtJQUN2QixJQUFJenFGLE1BQU0sQ0FBQztJQUVYLGdDQUFnQztJQUNoQyxJQUFJLE1BQU1rcUYsTUFBTSxJQUFJQyxJQUFJO1FBQ3RCbnFGLElBQUlyZSxDQUFDLEdBQUcyb0c7UUFDUix5QkFBeUI7UUFDekJ0cUYsSUFBSTVVLENBQUMsR0FBR20vRixJQUFJQyxJQUFJO1FBQ2hCLE9BQU94cUY7SUFDVDtJQUVBLGtDQUFrQztJQUNsQyxJQUFJLE1BQU1rcUYsTUFBTSxJQUFJQyxJQUFJO1FBQ3RCbnFGLElBQUlyZSxDQUFDLEdBQUcyb0c7UUFDUnRxRixJQUFJNVUsQ0FBQyxHQUFHbS9GLElBQUlDLElBQUk7UUFDaEIsMkJBQTJCO1FBRTNCLE9BQU94cUY7SUFDVDtJQUVBLG9DQUFvQztJQUNwQyxJQUFJLElBQUlrcUYsTUFBTSxDQUFDLElBQUlTLGFBQWFELFlBQVlBLFlBQVlDLFdBQVc7UUFDakUzcUYsSUFBSXJlLENBQUMsR0FBRzJvRyxJQUFJRyxJQUFJO1FBQ2hCenFGLElBQUk1VSxDQUFDLEdBQUdtL0YsSUFBSUUsSUFBSU4sS0FBSyxJQUFJRDtRQUN6Qix3QkFBd0I7UUFFeEIsT0FBT2xxRjtJQUNUO0lBRUEsbUNBQW1DO0lBQ25DLElBQUksSUFBSWtxRixNQUFNLENBQUMsSUFBSVMsYUFBYUQsWUFBWUEsWUFBWUMsV0FBVztRQUNqRTNxRixJQUFJcmUsQ0FBQyxHQUFHMm9HLElBQUlHLElBQUk7UUFDaEJ6cUYsSUFBSTVVLENBQUMsR0FBR20vRixJQUFJRSxJQUFJTixLQUFLLElBQUlEO1FBQ3pCLHVCQUF1QjtRQUV2QixPQUFPbHFGO0lBQ1Q7SUFFQSxrQ0FBa0M7SUFDbEMsSUFBSSxJQUFJbXFGLE1BQU9PLENBQUFBLFlBQVksQ0FBQyxJQUFJQyxhQUFhRCxZQUFZQyxTQUFRLEdBQUk7UUFDbkUzcUYsSUFBSXJlLENBQUMsR0FBRzJvRyxJQUFJRSxJQUFJTixLQUFLLElBQUlDO1FBQ3pCbnFGLElBQUk1VSxDQUFDLEdBQUdtL0YsSUFBSUMsSUFBSTtRQUNoQix1QkFBdUI7UUFFdkIsT0FBT3hxRjtJQUNUO0lBRUEscUNBQXFDO0lBQ3JDLElBQUksSUFBSW1xRixNQUFPTyxDQUFBQSxZQUFZLENBQUMsSUFBSUMsYUFBYUQsWUFBWUMsU0FBUSxHQUFJO1FBQ25FM3FGLElBQUlyZSxDQUFDLEdBQUcyb0csSUFBSUUsSUFBSU4sS0FBSyxJQUFJQztRQUN6Qm5xRixJQUFJNVUsQ0FBQyxHQUFHbS9GLElBQUlDLElBQUk7UUFDaEIsMEJBQTBCO1FBRTFCLE9BQU94cUY7SUFDVDtJQUVBLDREQUE0RDtJQUM1RCxlQUFlO0lBQ2YsT0FBT0E7QUFDVDtBQUVBOztDQUVDLEdBQ0QsSUFBSWdwRixzQkFBc0IsU0FBU0Esb0JBQW9CeEQsVUFBVSxFQUFFcmtHLE9BQU87SUFDeEUseUJBQXlCO0lBQ3pCLElBQUssSUFBSXZSLElBQUksR0FBR0EsSUFBSTQxRyxXQUFXb0IsUUFBUSxFQUFFaDNHLElBQUs7UUFDNUMsa0NBQWtDO1FBQ2xDLElBQUk0bUIsT0FBT2d2RixXQUFXbUIsV0FBVyxDQUFDLzJHLEVBQUU7UUFDcEMsSUFBSWs0RyxXQUFXdEMsV0FBV2dCLFNBQVMsQ0FBQ2h3RixLQUFLeXpCLFFBQVEsQ0FBQztRQUNsRCxJQUFJaDVCLFNBQVN1MEYsV0FBV2UsV0FBVyxDQUFDdUIsU0FBUztRQUM3QyxJQUFJQyxXQUFXdkMsV0FBV2dCLFNBQVMsQ0FBQ2h3RixLQUFLMHpCLFFBQVEsQ0FBQztRQUNsRCxJQUFJaDVCLFNBQVNzMEYsV0FBV2UsV0FBVyxDQUFDd0IsU0FBUztRQUU3QyxxREFBcUQ7UUFDckQsSUFBSXdCLGFBQWFyNEYsT0FBTysxRixTQUFTLEdBQUdoMkYsT0FBT2cyRixTQUFTO1FBQ3BELElBQUl1QyxhQUFhdDRGLE9BQU9nMkYsU0FBUyxHQUFHajJGLE9BQU9pMkYsU0FBUztRQUVwRCw0Q0FBNEM7UUFDNUMsNERBQTREO1FBQzVELElBQUksTUFBTXFDLGNBQWMsTUFBTUMsWUFBWTtZQUN4QztRQUNGO1FBRUEscUNBQXFDO1FBQ3JDLElBQUlNLFNBQVNDLGtCQUFrQjk0RixRQUFRczRGLFlBQVlDO1FBQ25ELElBQUlRLFNBQVNELGtCQUFrQjc0RixRQUFRLENBQUMsSUFBSXE0RixZQUFZLENBQUMsSUFBSUM7UUFDN0QsSUFBSW9CLEtBQUtaLE9BQU9yb0csQ0FBQyxHQUFHbW9HLE9BQU9ub0csQ0FBQztRQUM1QixJQUFJa3BHLEtBQUtiLE9BQU81K0YsQ0FBQyxHQUFHMCtGLE9BQU8xK0YsQ0FBQztRQUM1QixJQUFJemIsSUFBSXdDLEtBQUsyd0IsSUFBSSxDQUFDOG5GLEtBQUtBLEtBQUtDLEtBQUtBO1FBQ2pDLElBQUkxMUMsUUFBUWhqRSxLQUFLNnhCLEdBQUcsQ0FBQ3hOLEtBQUtveEYsV0FBVyxHQUFHajRHLEdBQUcsS0FBSzZtQixLQUFLcXhGLFVBQVU7UUFDL0QsSUFBSSxNQUFNbDRHLEdBQUc7WUFDWCxJQUFJaTZHLFNBQVN6MEMsUUFBUXkxQyxLQUFLajdHO1lBQzFCLElBQUlrNkcsU0FBUzEwQyxRQUFRMDFDLEtBQUtsN0c7UUFDNUIsT0FBTztZQUNMLElBQUlpNkcsU0FBUztZQUNiLElBQUlDLFNBQVM7UUFDZjtRQUVBLDRDQUE0QztRQUM1QyxJQUFJLENBQUM1NEYsT0FBTzgxRixRQUFRLEVBQUU7WUFDcEI5MUYsT0FBT3lnQixPQUFPLElBQUlrNEU7WUFDbEIzNEYsT0FBTzBnQixPQUFPLElBQUlrNEU7UUFDcEI7UUFDQSxJQUFJLENBQUMzNEYsT0FBTzYxRixRQUFRLEVBQUU7WUFDcEI3MUYsT0FBT3dnQixPQUFPLElBQUlrNEU7WUFDbEIxNEYsT0FBT3lnQixPQUFPLElBQUlrNEU7UUFDcEI7SUFFQSx5RUFBeUU7SUFDekUsd0VBQXdFO0lBQ3hFLGVBQWU7SUFDakI7QUFDRjtBQUVBOztDQUVDLEdBQ0QsSUFBSVoseUJBQXlCLFNBQVNBLHVCQUF1QnpELFVBQVUsRUFBRXJrRyxPQUFPO0lBQzlFLElBQUlBLFFBQVE2akcsT0FBTyxLQUFLLEdBQUc7UUFDekI7SUFDRjtJQUNBLElBQUk4RixnQkFBZ0I7SUFFcEIsb0NBQW9DO0lBQ3BDLGVBQWU7SUFDZixJQUFLLElBQUlsN0csSUFBSSxHQUFHQSxJQUFJNDFHLFdBQVdpQixRQUFRLENBQUNwNUcsTUFBTSxFQUFFdUMsSUFBSztRQUNuRCxJQUFJb3ZHLFFBQVF3RyxXQUFXaUIsUUFBUSxDQUFDNzJHLEVBQUU7UUFDbEMsSUFBSThzQixXQUFXc2lGLE1BQU0zeEcsTUFBTTtRQUUzQixrQ0FBa0M7UUFDbEMsZUFBZTtRQUVmLHVCQUF1QjtRQUN2QixJQUFJLE1BQU11QyxHQUFHO1lBQ1gsSUFBSXliLFVBQVVtNkYsV0FBVzdKLFlBQVksR0FBRztZQUN4QyxJQUFJcndGLFVBQVVrNkYsV0FBVzlKLFdBQVcsR0FBRztRQUN6QyxPQUFPO1lBQ0wsaUVBQWlFO1lBQ2pFLElBQUkvaUUsT0FBTzZzRSxXQUFXZSxXQUFXLENBQUNmLFdBQVdnQixTQUFTLENBQUN4SCxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakUsSUFBSWxzRixTQUFTMHlGLFdBQVdlLFdBQVcsQ0FBQ2YsV0FBV2dCLFNBQVMsQ0FBQzd0RSxLQUFLNjhDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hFLElBQUlucUUsVUFBVXlILE9BQU9tMEYsU0FBUztZQUM5QixJQUFJMzdGLFVBQVV3SCxPQUFPbzBGLFNBQVM7UUFDaEM7UUFDQSxzREFBc0Q7UUFDdEQsZUFBZTtRQUVmLG9DQUFvQztRQUNwQyxJQUFLLElBQUlqeEcsSUFBSSxHQUFHQSxJQUFJeW1CLFVBQVV6bUIsSUFBSztZQUNqQyxJQUFJc2dCLE9BQU9pdkYsV0FBV2UsV0FBVyxDQUFDZixXQUFXZ0IsU0FBUyxDQUFDeEgsS0FBSyxDQUFDL29HLEVBQUUsQ0FBQyxDQUFDO1lBQ2pFLDBCQUEwQjtZQUUxQixJQUFJc2dCLEtBQUt3d0YsUUFBUSxFQUFFO2dCQUNqQjtZQUNGO1lBQ0EsSUFBSTkvRSxLQUFLNWIsVUFBVWtMLEtBQUswd0YsU0FBUztZQUNqQyxJQUFJLy9FLEtBQUs1YixVQUFVaUwsS0FBSzJ3RixTQUFTO1lBQ2pDLElBQUkvckYsSUFBSWhwQixLQUFLMndCLElBQUksQ0FBQ21FLEtBQUtBLEtBQUtDLEtBQUtBO1lBQ2pDLElBQUkvTCxJQUFJMnZGLGVBQWU7Z0JBQ3JCLElBQUlDLEtBQUs1cEcsUUFBUTZqRyxPQUFPLEdBQUcvOUUsS0FBSzlMO2dCQUNoQyxJQUFJNnZGLEtBQUs3cEcsUUFBUTZqRyxPQUFPLEdBQUc5OUUsS0FBSy9MO2dCQUNoQzVFLEtBQUttYixPQUFPLElBQUlxNUU7Z0JBQ2hCeDBGLEtBQUtvYixPQUFPLElBQUlxNUU7WUFDaEIsNkNBQTZDO1lBQy9DO1FBQ0EsZUFBZTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxJQUFJOUIsa0JBQWtCLFNBQVNBLGdCQUFnQjFELFVBQVUsRUFBRXJrRyxPQUFPO0lBQ2hFLCtFQUErRTtJQUMvRSxJQUFJc1IsUUFBUSxFQUFFO0lBQ2QsSUFBSTZQLFFBQVEsR0FBRyxnQ0FBZ0M7SUFDL0MsSUFBSXZCLE1BQU0sQ0FBQyxHQUFHLGlDQUFpQztJQUUvQywrQkFBK0I7SUFFL0IsZ0RBQWdEO0lBQ2hEdE8sTUFBTTVpQixJQUFJLENBQUNzRSxLQUFLLENBQUNzZSxPQUFPK3lGLFdBQVdpQixRQUFRLENBQUMsRUFBRTtJQUM5QzFsRixPQUFPeWtGLFdBQVdpQixRQUFRLENBQUMsRUFBRSxDQUFDcDVHLE1BQU07SUFFcEMsc0NBQXNDO0lBQ3RDLE1BQU9pMUIsU0FBU3ZCLElBQUs7UUFDbkIsaURBQWlEO1FBQ2pELElBQUk2b0IsU0FBU24zQixLQUFLLENBQUM2UCxRQUFRO1FBQzNCLElBQUkyb0YsWUFBWXpGLFdBQVdnQixTQUFTLENBQUM1OEQsT0FBTztRQUM1QyxJQUFJcnpCLE9BQU9pdkYsV0FBV2UsV0FBVyxDQUFDMEUsVUFBVTtRQUM1QyxJQUFJcDRGLFdBQVcwRCxLQUFLMUQsUUFBUTtRQUU1QixvREFBb0Q7UUFDcEQsSUFBSSxJQUFJQSxTQUFTeGxCLE1BQU0sSUFBSSxDQUFDa3BCLEtBQUt3d0YsUUFBUSxFQUFFO1lBQ3pDLElBQUltRSxPQUFPMzBGLEtBQUttYixPQUFPO1lBQ3ZCLElBQUl5NUUsT0FBTzUwRixLQUFLb2IsT0FBTztZQUV2QiwrREFBK0Q7WUFDL0QsaURBQWlEO1lBQ2pELDhDQUE4QztZQUM5QyxlQUFlO1lBRWYsSUFBSyxJQUFJL2hDLElBQUksR0FBR0EsSUFBSWlqQixTQUFTeGxCLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3hDLElBQUl3N0csWUFBWTVGLFdBQVdlLFdBQVcsQ0FBQ2YsV0FBV2dCLFNBQVMsQ0FBQzN6RixRQUFRLENBQUNqakIsRUFBRSxDQUFDLENBQUM7Z0JBQ3pFLG1CQUFtQjtnQkFDbkJ3N0csVUFBVTE1RSxPQUFPLElBQUl3NUU7Z0JBQ3JCRSxVQUFVejVFLE9BQU8sSUFBSXc1RTtnQkFDckIsc0NBQXNDO2dCQUN0QzE0RixLQUFLLENBQUMsRUFBRXNPLElBQUksR0FBR2xPLFFBQVEsQ0FBQ2pqQixFQUFFO1lBQzVCO1lBRUEsdUJBQXVCO1lBQ3ZCMm1CLEtBQUttYixPQUFPLEdBQUc7WUFDZm5iLEtBQUtvYixPQUFPLEdBQUc7UUFDakI7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsSUFBSXczRSxrQkFBa0IsU0FBU0EsZ0JBQWdCM0QsVUFBVSxFQUFFcmtHLE9BQU87SUFDaEUsZ0NBQWdDO0lBQ2hDLGVBQWU7SUFFZixzQ0FBc0M7SUFDdEMsSUFBSyxJQUFJdlIsSUFBSSxHQUFHQSxJQUFJNDFHLFdBQVd0VSxRQUFRLEVBQUV0aEcsSUFBSztRQUM1QyxJQUFJckMsSUFBSWk0RyxXQUFXZSxXQUFXLENBQUMzMkcsRUFBRTtRQUNqQyxJQUFJLElBQUlyQyxFQUFFc2xCLFFBQVEsQ0FBQ3hsQixNQUFNLEVBQUU7WUFDekIsOERBQThEO1lBQzlERSxFQUFFaW9DLElBQUksR0FBR3BsQztZQUNUN0MsRUFBRStuQyxJQUFJLEdBQUdsbEM7WUFDVDdDLEVBQUVrb0MsSUFBSSxHQUFHcmxDO1lBQ1Q3QyxFQUFFZ29DLElBQUksR0FBR25sQztRQUNYO0lBQ0Y7SUFDQSxJQUFLLElBQUlSLElBQUksR0FBR0EsSUFBSTQxRyxXQUFXdFUsUUFBUSxFQUFFdGhHLElBQUs7UUFDNUMsSUFBSXJDLElBQUlpNEcsV0FBV2UsV0FBVyxDQUFDMzJHLEVBQUU7UUFDakMsSUFBSSxJQUFJckMsRUFBRXNsQixRQUFRLENBQUN4bEIsTUFBTSxJQUFJRSxFQUFFdzVHLFFBQVEsRUFBRTtZQUd2QztRQUNGO1FBQ0Esa0RBQWtEO1FBQ2xELDJDQUEyQztRQUUzQyxtREFBbUQ7UUFDbkQsSUFBSXNFLFlBQVlDLFdBQVcvOUcsRUFBRW1rQyxPQUFPLEVBQUVua0MsRUFBRW9rQyxPQUFPLEVBQUU2ekUsV0FBV00sV0FBVztRQUN2RXY0RyxFQUFFMDVHLFNBQVMsSUFBSW9FLFVBQVUxcEcsQ0FBQztRQUMxQnBVLEVBQUUyNUcsU0FBUyxJQUFJbUUsVUFBVWpnRyxDQUFDO1FBQzFCN2QsRUFBRW1rQyxPQUFPLEdBQUc7UUFDWm5rQyxFQUFFb2tDLE9BQU8sR0FBRztRQUNacGtDLEVBQUUrbkMsSUFBSSxHQUFHL25DLEVBQUUwNUcsU0FBUyxHQUFHMTVHLEVBQUVnOUIsS0FBSztRQUM5Qmg5QixFQUFFaW9DLElBQUksR0FBR2pvQyxFQUFFMDVHLFNBQVMsR0FBRzE1RyxFQUFFZzlCLEtBQUs7UUFDOUJoOUIsRUFBRWdvQyxJQUFJLEdBQUdob0MsRUFBRTI1RyxTQUFTLEdBQUczNUcsRUFBRWk5QixNQUFNO1FBQy9CajlCLEVBQUVrb0MsSUFBSSxHQUFHbG9DLEVBQUUyNUcsU0FBUyxHQUFHMzVHLEVBQUVpOUIsTUFBTTtRQUMvQixxRUFBcUU7UUFDckUsZUFBZTtRQUVmLDRCQUE0QjtRQUM1QitnRiwwQkFBMEJoK0csR0FBR2k0RztJQUMvQjtJQUVBLHlDQUF5QztJQUN6QyxJQUFLLElBQUk1MUcsSUFBSSxHQUFHQSxJQUFJNDFHLFdBQVd0VSxRQUFRLEVBQUV0aEcsSUFBSztRQUM1QyxJQUFJckMsSUFBSWk0RyxXQUFXZSxXQUFXLENBQUMzMkcsRUFBRTtRQUNqQyxJQUFJLElBQUlyQyxFQUFFc2xCLFFBQVEsQ0FBQ3hsQixNQUFNLElBQUksQ0FBQ0UsRUFBRXc1RyxRQUFRLEVBQUU7WUFDeEN4NUcsRUFBRTA1RyxTQUFTLEdBQUcsQ0FBQzE1RyxFQUFFaW9DLElBQUksR0FBR2pvQyxFQUFFK25DLElBQUksSUFBSTtZQUNsQy9uQyxFQUFFMjVHLFNBQVMsR0FBRyxDQUFDMzVHLEVBQUVrb0MsSUFBSSxHQUFHbG9DLEVBQUVnb0MsSUFBSSxJQUFJO1lBQ2xDaG9DLEVBQUVnOUIsS0FBSyxHQUFHaDlCLEVBQUVpb0MsSUFBSSxHQUFHam9DLEVBQUUrbkMsSUFBSTtZQUN6Qi9uQyxFQUFFaTlCLE1BQU0sR0FBR2o5QixFQUFFa29DLElBQUksR0FBR2xvQyxFQUFFZ29DLElBQUk7UUFDMUIsMERBQTBEO1FBQzFELHNFQUFzRTtRQUN0RSx3REFBd0Q7UUFDeEQsZUFBZTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQTs7OztFQUlFLEdBQ0YsSUFBSSsxRSxhQUFhLFNBQVNBLFdBQVcxQixNQUFNLEVBQUVDLE1BQU0sRUFBRTdpRyxHQUFHO0lBQ3RELDJFQUEyRTtJQUMzRSxJQUFJbXVELFFBQVFoakUsS0FBSzJ3QixJQUFJLENBQUM4bUYsU0FBU0EsU0FBU0MsU0FBU0E7SUFDakQsSUFBSTEwQyxRQUFRbnVELEtBQUs7UUFDZixJQUFJZ1osTUFBTTtZQUNScmUsR0FBR3FGLE1BQU00aUcsU0FBU3owQztZQUNsQi9wRCxHQUFHcEUsTUFBTTZpRyxTQUFTMTBDO1FBQ3BCO0lBQ0YsT0FBTztRQUNMLElBQUluMUMsTUFBTTtZQUNScmUsR0FBR2lvRztZQUNIeCtGLEdBQUd5K0Y7UUFDTDtJQUNGO0lBRUEsb0RBQW9EO0lBQ3BELGVBQWU7SUFFZixPQUFPN3BGO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxJQUFJdXJGLDRCQUE0QixTQUFTQyx5QkFBeUJqMUYsSUFBSSxFQUFFaXZGLFVBQVU7SUFDaEYsOERBQThEO0lBQzlELElBQUlod0IsV0FBV2ovRCxLQUFLaS9ELFFBQVE7SUFDNUIsSUFBSSxRQUFRQSxVQUFVO1FBQ3BCLG9DQUFvQztRQUNwQyw0QkFBNEI7UUFDNUIsZUFBZTtRQUNmO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsSUFBSTUrRSxJQUFJNHVHLFdBQVdlLFdBQVcsQ0FBQ2YsV0FBV2dCLFNBQVMsQ0FBQ2h4QixTQUFTLENBQUM7SUFDOUQsSUFBSWkyQixPQUFPO0lBRVgsT0FBTztJQUNQLElBQUksUUFBUTcwRyxFQUFFNCtCLElBQUksSUFBSWpmLEtBQUtpZixJQUFJLEdBQUc1K0IsRUFBRXd3RyxRQUFRLEdBQUd4d0csRUFBRTQrQixJQUFJLEVBQUU7UUFDckQ1K0IsRUFBRTQrQixJQUFJLEdBQUdqZixLQUFLaWYsSUFBSSxHQUFHNStCLEVBQUV3d0csUUFBUTtRQUMvQnFFLE9BQU87SUFDUCw2REFBNkQ7SUFDL0Q7SUFFQSxPQUFPO0lBQ1AsSUFBSSxRQUFRNzBHLEVBQUUwK0IsSUFBSSxJQUFJL2UsS0FBSytlLElBQUksR0FBRzErQixFQUFFdXdHLE9BQU8sR0FBR3Z3RyxFQUFFMCtCLElBQUksRUFBRTtRQUNwRDErQixFQUFFMCtCLElBQUksR0FBRy9lLEtBQUsrZSxJQUFJLEdBQUcxK0IsRUFBRXV3RyxPQUFPO1FBQzlCc0UsT0FBTztJQUNQLDZEQUE2RDtJQUMvRDtJQUVBLE9BQU87SUFDUCxJQUFJLFFBQVE3MEcsRUFBRTYrQixJQUFJLElBQUlsZixLQUFLa2YsSUFBSSxHQUFHNytCLEVBQUUwd0csU0FBUyxHQUFHMXdHLEVBQUU2K0IsSUFBSSxFQUFFO1FBQ3RENytCLEVBQUU2K0IsSUFBSSxHQUFHbGYsS0FBS2tmLElBQUksR0FBRzcrQixFQUFFMHdHLFNBQVM7UUFDaENtRSxPQUFPO0lBQ1AsNkRBQTZEO0lBQy9EO0lBRUEsT0FBTztJQUNQLElBQUksUUFBUTcwRyxFQUFFMitCLElBQUksSUFBSWhmLEtBQUtnZixJQUFJLEdBQUczK0IsRUFBRXl3RyxNQUFNLEdBQUd6d0csRUFBRTIrQixJQUFJLEVBQUU7UUFDbkQzK0IsRUFBRTIrQixJQUFJLEdBQUdoZixLQUFLZ2YsSUFBSSxHQUFHMytCLEVBQUV5d0csTUFBTTtRQUM3Qm9FLE9BQU87SUFDUCw2REFBNkQ7SUFDL0Q7SUFFQSxrREFBa0Q7SUFDbEQsSUFBSUEsTUFBTTtRQUNSLGVBQWU7UUFDZixPQUFPRiwwQkFBMEIzMEcsR0FBRzR1RztJQUN0QztJQUVBLHFFQUFxRTtJQUNyRSxlQUFlO0lBQ2Y7QUFDRjtBQUNBLElBQUlZLHFCQUFxQixTQUFTQSxtQkFBbUJaLFVBQVUsRUFBRXJrRyxPQUFPO0lBQ3RFLElBQUkrVCxRQUFRc3dGLFdBQVdlLFdBQVc7SUFDbEMsSUFBSWhoRixhQUFhLEVBQUU7SUFDbkIsSUFBSyxJQUFJMzFCLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7UUFDckMsSUFBSTJtQixPQUFPckIsS0FBSyxDQUFDdGxCLEVBQUU7UUFDbkIsSUFBSTg3RyxNQUFNbjFGLEtBQUt5d0YsTUFBTTtRQUNyQixJQUFJMWhGLFlBQVlDLFVBQVUsQ0FBQ21tRixJQUFJLEdBQUdubUYsVUFBVSxDQUFDbW1GLElBQUksSUFBSSxFQUFFO1FBQ3ZEcG1GLFVBQVV6MUIsSUFBSSxDQUFDMG1CO0lBQ2pCO0lBQ0EsSUFBSW8xRixTQUFTO0lBQ2IsSUFBSyxJQUFJLzdHLElBQUksR0FBR0EsSUFBSTIxQixXQUFXbDRCLE1BQU0sRUFBRXVDLElBQUs7UUFDMUMsSUFBSSt5QixJQUFJNEMsVUFBVSxDQUFDMzFCLEVBQUU7UUFDckIsSUFBSSxDQUFDK3lCLEdBQUc7WUFDTjtRQUNGO1FBQ0FBLEVBQUUxdkIsRUFBRSxHQUFHbW9CO1FBQ1B1SCxFQUFFenZCLEVBQUUsR0FBRyxDQUFDa29CO1FBQ1J1SCxFQUFFeHZCLEVBQUUsR0FBR2lvQjtRQUNQdUgsRUFBRXZ2QixFQUFFLEdBQUcsQ0FBQ2dvQjtRQUNSLElBQUssSUFBSW5sQixJQUFJLEdBQUdBLElBQUkwc0IsRUFBRXQxQixNQUFNLEVBQUU0SSxJQUFLO1lBQ2pDLElBQUkxSSxJQUFJbzFCLENBQUMsQ0FBQzFzQixFQUFFO1lBQ1owc0IsRUFBRTF2QixFQUFFLEdBQUdkLEtBQUsrVSxHQUFHLENBQUN5YixFQUFFMXZCLEVBQUUsRUFBRTFGLEVBQUUwNUcsU0FBUyxHQUFHMTVHLEVBQUVnOUIsS0FBSyxHQUFHO1lBQzlDNUgsRUFBRXp2QixFQUFFLEdBQUdmLEtBQUs2VSxHQUFHLENBQUMyYixFQUFFenZCLEVBQUUsRUFBRTNGLEVBQUUwNUcsU0FBUyxHQUFHMTVHLEVBQUVnOUIsS0FBSyxHQUFHO1lBQzlDNUgsRUFBRXh2QixFQUFFLEdBQUdoQixLQUFLK1UsR0FBRyxDQUFDeWIsRUFBRXh2QixFQUFFLEVBQUU1RixFQUFFMjVHLFNBQVMsR0FBRzM1RyxFQUFFaTlCLE1BQU0sR0FBRztZQUMvQzdILEVBQUV2dkIsRUFBRSxHQUFHakIsS0FBSzZVLEdBQUcsQ0FBQzJiLEVBQUV2dkIsRUFBRSxFQUFFN0YsRUFBRTI1RyxTQUFTLEdBQUczNUcsRUFBRWk5QixNQUFNLEdBQUc7UUFDakQ7UUFDQTdILEVBQUVyVyxDQUFDLEdBQUdxVyxFQUFFenZCLEVBQUUsR0FBR3l2QixFQUFFMXZCLEVBQUU7UUFDakIwdkIsRUFBRWpzQixDQUFDLEdBQUdpc0IsRUFBRXZ2QixFQUFFLEdBQUd1dkIsRUFBRXh2QixFQUFFO1FBQ2pCdzRHLFVBQVVocEYsRUFBRXJXLENBQUMsR0FBR3FXLEVBQUVqc0IsQ0FBQztJQUNyQjtJQUNBNnVCLFdBQVd0TSxJQUFJLENBQUMsU0FBVWdtQixFQUFFLEVBQUVDLEVBQUU7UUFDOUIsT0FBT0EsR0FBRzV5QixDQUFDLEdBQUc0eUIsR0FBR3hvQyxDQUFDLEdBQUd1b0MsR0FBRzN5QixDQUFDLEdBQUcyeUIsR0FBR3ZvQyxDQUFDO0lBQ2xDO0lBQ0EsSUFBSWlMLElBQUk7SUFDUixJQUFJeUosSUFBSTtJQUNSLElBQUl3Z0csUUFBUTtJQUNaLElBQUlDLE9BQU87SUFDWCxJQUFJQyxVQUFVMzVHLEtBQUsyd0IsSUFBSSxDQUFDNm9GLFVBQVVuRyxXQUFXOUosV0FBVyxHQUFHOEosV0FBVzdKLFlBQVk7SUFDbEYsSUFBSyxJQUFJL3JHLElBQUksR0FBR0EsSUFBSTIxQixXQUFXbDRCLE1BQU0sRUFBRXVDLElBQUs7UUFDMUMsSUFBSSt5QixJQUFJNEMsVUFBVSxDQUFDMzFCLEVBQUU7UUFDckIsSUFBSSxDQUFDK3lCLEdBQUc7WUFDTjtRQUNGO1FBQ0EsSUFBSyxJQUFJMXNCLElBQUksR0FBR0EsSUFBSTBzQixFQUFFdDFCLE1BQU0sRUFBRTRJLElBQUs7WUFDakMsSUFBSTFJLElBQUlvMUIsQ0FBQyxDQUFDMXNCLEVBQUU7WUFDWixJQUFJLENBQUMxSSxFQUFFdzVHLFFBQVEsRUFBRTtnQkFDZng1RyxFQUFFMDVHLFNBQVMsSUFBSXRsRyxJQUFJZ2hCLEVBQUUxdkIsRUFBRTtnQkFDdkIxRixFQUFFMjVHLFNBQVMsSUFBSTk3RixJQUFJdVgsRUFBRXh2QixFQUFFO1lBQ3pCO1FBQ0Y7UUFDQXdPLEtBQUtnaEIsRUFBRXJXLENBQUMsR0FBR25MLFFBQVF1akcsZ0JBQWdCO1FBQ25Da0gsU0FBU2pwRixFQUFFclcsQ0FBQyxHQUFHbkwsUUFBUXVqRyxnQkFBZ0I7UUFDdkNtSCxPQUFPMTVHLEtBQUs2VSxHQUFHLENBQUM2a0csTUFBTWxwRixFQUFFanNCLENBQUM7UUFDekIsSUFBSWsxRyxRQUFRRSxTQUFTO1lBQ25CMWdHLEtBQUt5Z0csT0FBTzFxRyxRQUFRdWpHLGdCQUFnQjtZQUNwQy9pRyxJQUFJO1lBQ0ppcUcsUUFBUTtZQUNSQyxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBRUEsSUFBSUUsYUFBYTtJQUNmMTZELEtBQUs7SUFDTCwyQ0FBMkM7SUFDM0NocEIsU0FBUztJQUNULHNCQUFzQjtJQUN0QnIxQixhQUFhNUM7SUFDYixrRUFBa0U7SUFDbEVxdUcsY0FBYztJQUNkLHNFQUFzRTtJQUN0RXVOLHFCQUFxQjtJQUNyQixxREFBcUQ7SUFDckQvaEMsNkJBQTZCO0lBQzdCLG1GQUFtRjtJQUNuRmUsZUFBZTU2RTtJQUNmLHFHQUFxRztJQUNyRzY3RyxVQUFVO0lBQ1YsZ0VBQWdFO0lBQ2hFQyxNQUFNOTdHO0lBQ04sZ0NBQWdDO0lBQ2hDKzdHLE1BQU0vN0c7SUFDTixtQ0FBbUM7SUFDbkNnaEIsVUFBVSxTQUFTQSxTQUFTbUYsSUFBSSxHQUFHO0lBQ25DLG1DQUFtQztJQUNuQzBDLE1BQU03b0I7SUFDTiwyR0FBMkc7SUFDM0dtZ0QsU0FBUztJQUNULDJDQUEyQztJQUMzQys2QixtQkFBbUI7SUFDbkIseUNBQXlDO0lBQ3pDRSxpQkFBaUJwN0U7SUFDakIsaUNBQWlDO0lBQ2pDaTdFLGVBQWUsU0FBU0EsY0FBYzkwRCxJQUFJLEVBQUUzbUIsQ0FBQztRQUMzQyxPQUFPO0lBQ1Q7SUFDQSwyTEFBMkw7SUFDM0wrN0UsT0FBT3Y3RTtJQUNQLDBCQUEwQjtJQUMxQisrQyxNQUFNLytDO0lBQ04seUJBQXlCO0lBQ3pCKzZFLFdBQVcsU0FBU0EsVUFBVTUwRCxJQUFJLEVBQUVuRixRQUFRO1FBQzFDLE9BQU9BO0lBQ1QsRUFBRSwyRkFBMkY7QUFDL0Y7QUFDQSxTQUFTZzdGLFdBQVdqckcsT0FBTztJQUN6QixJQUFJLENBQUNBLE9BQU8sR0FBR3ZMLE9BQU8sQ0FBQyxHQUFHbTJHLFlBQVk1cUc7QUFDeEM7QUFDQWlyRyxXQUFXMzlHLFNBQVMsQ0FBQ21oRCxHQUFHLEdBQUc7SUFDekIsSUFBSS8rQixTQUFTLElBQUksQ0FBQzFQLE9BQU87SUFDekIsSUFBSUEsVUFBVTBQO0lBQ2QsSUFBSUQsS0FBS0MsT0FBT0QsRUFBRTtJQUNsQixJQUFJOEosT0FBT3ZaLFFBQVF1WixJQUFJO0lBQ3ZCLElBQUl4RixRQUFRd0YsS0FBS3hGLEtBQUssR0FBR2c4QyxHQUFHLENBQUM7SUFDN0IsSUFBSS92RCxRQUFROFgsSUFBSSxFQUFFO1FBQ2hCL0QsUUFBUUEsTUFBTStELElBQUksQ0FBQzlYLFFBQVE4WCxJQUFJO0lBQ2pDO0lBQ0EsSUFBSTRPLEtBQUtELGdCQUFnQnptQixRQUFRbk8sV0FBVyxHQUFHbU8sUUFBUW5PLFdBQVcsR0FBRztRQUNuRUMsSUFBSTtRQUNKRSxJQUFJO1FBQ0ptWixHQUFHc0UsR0FBRzJaLEtBQUs7UUFDWDd6QixHQUFHa2EsR0FBRzRaLE1BQU07SUFDZDtJQUNBLElBQUkzQyxHQUFHbnhCLENBQUMsS0FBSyxLQUFLbXhCLEdBQUd2YixDQUFDLEtBQUssR0FBRztRQUM1Qm9PLEtBQUt4RixLQUFLLEdBQUdvMUQsZUFBZSxDQUFDLElBQUksRUFBRW5wRSxTQUFTLFNBQVV3TixHQUFHO1lBQ3ZELE9BQU87Z0JBQ0xoTixHQUFHa21CLEdBQUc1MEIsRUFBRTtnQkFDUm1ZLEdBQUd5YyxHQUFHMTBCLEVBQUU7WUFDVjtRQUNGO0lBQ0YsT0FBTztRQUNMLGlGQUFpRjtRQUNqRixJQUFJazVHLFFBQVFuM0YsTUFBTWhGLElBQUk7UUFDdEIsSUFBSW84RixTQUFTbjZHLEtBQUsyd0IsSUFBSSxDQUFDdXBGLFFBQVF4a0YsR0FBR254QixDQUFDLEdBQUdteEIsR0FBR3ZiLENBQUM7UUFDMUMsSUFBSTQvRixPQUFPLzVHLEtBQUsrRSxLQUFLLENBQUNvMUc7UUFDdEIsSUFBSUgsT0FBT2g2RyxLQUFLK0UsS0FBSyxDQUFDMndCLEdBQUd2YixDQUFDLEdBQUd1YixHQUFHbnhCLENBQUMsR0FBRzQxRztRQUNwQyxJQUFJQyxRQUFRLFNBQVNBLE1BQU1oOUYsR0FBRztZQUM1QixJQUFJQSxPQUFPLE1BQU07Z0JBQ2YsT0FBT3BkLEtBQUsrVSxHQUFHLENBQUNnbEcsTUFBTUM7WUFDeEIsT0FBTztnQkFDTCxJQUFJamxHLE1BQU0vVSxLQUFLK1UsR0FBRyxDQUFDZ2xHLE1BQU1DO2dCQUN6QixJQUFJamxHLE9BQU9nbEcsTUFBTTtvQkFDZkEsT0FBTzM4RjtnQkFDVCxPQUFPO29CQUNMNDhGLE9BQU81OEY7Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsSUFBSWk5RixRQUFRLFNBQVNBLE1BQU1qOUYsR0FBRztZQUM1QixJQUFJQSxPQUFPLE1BQU07Z0JBQ2YsT0FBT3BkLEtBQUs2VSxHQUFHLENBQUNrbEcsTUFBTUM7WUFDeEIsT0FBTztnQkFDTCxJQUFJbmxHLE1BQU03VSxLQUFLNlUsR0FBRyxDQUFDa2xHLE1BQU1DO2dCQUN6QixJQUFJbmxHLE9BQU9rbEcsTUFBTTtvQkFDZkEsT0FBTzM4RjtnQkFDVCxPQUFPO29CQUNMNDhGLE9BQU81OEY7Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsSUFBSWs5RixRQUFRdHJHLFFBQVErcUcsSUFBSTtRQUN4QixJQUFJUSxRQUFRdnJHLFFBQVFnckcsSUFBSSxJQUFJLE9BQU9ockcsUUFBUWdyRyxJQUFJLEdBQUdockcsUUFBUXdyRyxPQUFPO1FBRWpFLDJEQUEyRDtRQUMzRCxJQUFJRixTQUFTLFFBQVFDLFNBQVMsTUFBTTtZQUNsQ1IsT0FBT087WUFDUE4sT0FBT087UUFDVCxPQUFPLElBQUlELFNBQVMsUUFBUUMsU0FBUyxNQUFNO1lBQ3pDUixPQUFPTztZQUNQTixPQUFPaDZHLEtBQUs0eEIsSUFBSSxDQUFDc29GLFFBQVFIO1FBQzNCLE9BQU8sSUFBSU8sU0FBUyxRQUFRQyxTQUFTLE1BQU07WUFDekNQLE9BQU9PO1lBQ1BSLE9BQU8vNUcsS0FBSzR4QixJQUFJLENBQUNzb0YsUUFBUUY7UUFDM0IsT0FLSyxJQUFJQSxPQUFPRCxPQUFPRyxPQUFPO1lBQzVCLElBQUlPLEtBQUtMO1lBQ1QsSUFBSU0sS0FBS0w7WUFFVCxxRUFBcUU7WUFDckUsSUFBSSxDQUFDSSxLQUFLLEtBQUtDLE1BQU1SLE9BQU87Z0JBQzFCRSxNQUFNSyxLQUFLO1lBQ2IsT0FBTyxJQUFJLENBQUNDLEtBQUssS0FBS0QsTUFBTVAsT0FBTztnQkFDakNHLE1BQU1LLEtBQUs7WUFDYjtRQUNGLE9BQU87WUFDTCwrQ0FBK0M7WUFDL0MsTUFBT1YsT0FBT0QsT0FBT0csTUFBTztnQkFDMUIsSUFBSVMsTUFBTVA7Z0JBQ1YsSUFBSVEsTUFBTVA7Z0JBRVYsZ0VBQWdFO2dCQUNoRSxJQUFJLENBQUNPLE1BQU0sS0FBS0QsT0FBT1QsT0FBTztvQkFDNUJHLE1BQU1PLE1BQU07Z0JBQ2QsT0FBTztvQkFDTFIsTUFBTU8sTUFBTTtnQkFDZDtZQUNGO1FBQ0Y7UUFDQSxJQUFJRSxZQUFZbmxGLEdBQUd2YixDQUFDLEdBQUc2L0Y7UUFDdkIsSUFBSWMsYUFBYXBsRixHQUFHbnhCLENBQUMsR0FBR3cxRztRQUN4QixJQUFJL3FHLFFBQVE4cUcsUUFBUSxFQUFFO1lBQ3BCZSxZQUFZO1lBQ1pDLGFBQWE7UUFDZjtRQUNBLElBQUk5ckcsUUFBUXM5RixZQUFZLEVBQUU7WUFDeEIsSUFBSyxJQUFJN3VHLElBQUksR0FBR0EsSUFBSXNsQixNQUFNN25CLE1BQU0sRUFBRXVDLElBQUs7Z0JBQ3JDLElBQUkybUIsT0FBT3JCLEtBQUssQ0FBQ3RsQixFQUFFO2dCQUNuQixJQUFJd2MsTUFBTW1LLEtBQUsvakIsUUFBUSxDQUFDNGUsUUFBUTtnQkFDaEMsSUFBSWhGLElBQUl6SyxDQUFDLElBQUksUUFBUXlLLElBQUloQixDQUFDLElBQUksTUFBTTtvQkFDbEMsU0FBUztvQkFDVGdCLElBQUl6SyxDQUFDLEdBQUc7b0JBQ1J5SyxJQUFJaEIsQ0FBQyxHQUFHO2dCQUNWO2dCQUNBLElBQUlxMUYsTUFBTWxxRixLQUFLNHpELGdCQUFnQixDQUFDaHBFO2dCQUNoQyxJQUFJdkssSUFBSXVLLFFBQVE2cUcsbUJBQW1CO2dCQUNuQyxJQUFJMS9GLElBQUltMEYsSUFBSW4wRixDQUFDLEdBQUcxVjtnQkFDaEIsSUFBSUYsSUFBSStwRyxJQUFJL3BHLENBQUMsR0FBR0U7Z0JBQ2hCbzJHLFlBQVk3NkcsS0FBSzZVLEdBQUcsQ0FBQ2dtRyxXQUFXMWdHO2dCQUNoQzJnRyxhQUFhOTZHLEtBQUs2VSxHQUFHLENBQUNpbUcsWUFBWXYyRztZQUNwQztRQUNGO1FBQ0EsSUFBSXcyRyxXQUFXLENBQUMsR0FBRyx1QkFBdUI7UUFFMUMsSUFBSUMsT0FBTyxTQUFTQSxLQUFLbHZFLEdBQUcsRUFBRUQsR0FBRztZQUMvQixPQUFPa3ZFLFFBQVEsQ0FBQyxPQUFPanZFLE1BQU0sTUFBTUQsSUFBSSxHQUFHLE9BQU87UUFDbkQ7UUFDQSxJQUFJb3ZFLE1BQU0sU0FBU0EsSUFBSW52RSxHQUFHLEVBQUVELEdBQUc7WUFDN0JrdkUsUUFBUSxDQUFDLE9BQU9qdkUsTUFBTSxNQUFNRCxJQUFJLEdBQUc7UUFDckM7UUFFQSx5Q0FBeUM7UUFDekMsSUFBSUMsTUFBTTtRQUNWLElBQUlELE1BQU07UUFDVixJQUFJcXZFLGlCQUFpQixTQUFTQTtZQUM1QnJ2RTtZQUNBLElBQUlBLE9BQU9tdUUsTUFBTTtnQkFDZm51RSxNQUFNO2dCQUNOQztZQUNGO1FBQ0Y7UUFFQSwwQ0FBMEM7UUFDMUMsSUFBSXF2RSxZQUFZLENBQUM7UUFDakIsSUFBSyxJQUFJaDNGLEtBQUssR0FBR0EsS0FBS3BCLE1BQU03bkIsTUFBTSxFQUFFaXBCLEtBQU07WUFDeEMsSUFBSWtNLFFBQVF0TixLQUFLLENBQUNvQixHQUFHO1lBQ3JCLElBQUlpM0YsUUFBUXBzRyxRQUFRaVEsUUFBUSxDQUFDb1I7WUFDN0IsSUFBSStxRixTQUFVQSxDQUFBQSxNQUFNdHZFLEdBQUcsS0FBSzd0QyxhQUFhbTlHLE1BQU12dkUsR0FBRyxLQUFLNXRDLFNBQVEsR0FBSTtnQkFDakUsc0NBQXNDO2dCQUN0QyxJQUFJeWpFLE9BQU87b0JBQ1Q1MUIsS0FBS3N2RSxNQUFNdHZFLEdBQUc7b0JBQ2RELEtBQUt1dkUsTUFBTXZ2RSxHQUFHO2dCQUNoQjtnQkFDQSxJQUFJNjFCLEtBQUs3MUIsR0FBRyxLQUFLNXRDLFdBQVc7b0JBQzFCLGtCQUFrQjtvQkFDbEJ5akUsS0FBSzcxQixHQUFHLEdBQUc7b0JBQ1gsTUFBT212RSxLQUFLdDVDLEtBQUs1MUIsR0FBRyxFQUFFNDFCLEtBQUs3MUIsR0FBRyxFQUFHO3dCQUMvQjYxQixLQUFLNzFCLEdBQUc7b0JBQ1Y7Z0JBQ0YsT0FBTyxJQUFJNjFCLEtBQUs1MUIsR0FBRyxLQUFLN3RDLFdBQVc7b0JBQ2pDLGtCQUFrQjtvQkFDbEJ5akUsS0FBSzUxQixHQUFHLEdBQUc7b0JBQ1gsTUFBT2t2RSxLQUFLdDVDLEtBQUs1MUIsR0FBRyxFQUFFNDFCLEtBQUs3MUIsR0FBRyxFQUFHO3dCQUMvQjYxQixLQUFLNTFCLEdBQUc7b0JBQ1Y7Z0JBQ0Y7Z0JBQ0FxdkUsU0FBUyxDQUFDOXFGLE1BQU1uTixFQUFFLEdBQUcsR0FBR3crQztnQkFDeEJ1NUMsSUFBSXY1QyxLQUFLNTFCLEdBQUcsRUFBRTQxQixLQUFLNzFCLEdBQUc7WUFDeEI7UUFDRjtRQUNBLElBQUkya0UsU0FBUyxTQUFTQSxPQUFPcndHLE9BQU8sRUFBRTFDLENBQUM7WUFDckMsSUFBSStSLEdBQUd5SjtZQUNQLElBQUk5WSxRQUFRMmYsTUFBTSxNQUFNM2YsUUFBUXMxRCxRQUFRLElBQUk7Z0JBQzFDLE9BQU87WUFDVDtZQUVBLHVDQUF1QztZQUN2QyxJQUFJMmxELFFBQVFELFNBQVMsQ0FBQ2g3RyxRQUFRK2lCLEVBQUUsR0FBRztZQUNuQyxJQUFJazRGLE9BQU87Z0JBQ1Q1ckcsSUFBSTRyRyxNQUFNdnZFLEdBQUcsR0FBR2d2RSxZQUFZQSxZQUFZLElBQUlubEYsR0FBRzUwQixFQUFFO2dCQUNqRG1ZLElBQUltaUcsTUFBTXR2RSxHQUFHLEdBQUdndkUsYUFBYUEsYUFBYSxJQUFJcGxGLEdBQUcxMEIsRUFBRTtZQUNyRCxPQUFPO2dCQUNMLDhCQUE4QjtnQkFFOUIsTUFBT2c2RyxLQUFLbHZFLEtBQUtELEtBQU07b0JBQ3JCcXZFO2dCQUNGO2dCQUNBMXJHLElBQUlxOEIsTUFBTWd2RSxZQUFZQSxZQUFZLElBQUlubEYsR0FBRzUwQixFQUFFO2dCQUMzQ21ZLElBQUk2eUIsTUFBTWd2RSxhQUFhQSxhQUFhLElBQUlwbEYsR0FBRzEwQixFQUFFO2dCQUM3Q2k2RyxJQUFJbnZFLEtBQUtEO2dCQUNUcXZFO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMMXJHLEdBQUdBO2dCQUNIeUosR0FBR0E7WUFDTDtRQUNGO1FBQ0E4SixNQUFNbzFELGVBQWUsQ0FBQyxJQUFJLEVBQUVucEUsU0FBU3doRztJQUN2QztJQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFFQSx5QkFBeUI7QUFDekIsSUFBSTZLLGFBQWE7SUFDZjdoQyxPQUFPLFNBQVNBLFNBQVM7SUFDekIsaUJBQWlCO0lBQ2pCeDhCLE1BQU0sU0FBU0EsUUFBUSxFQUFFLGdCQUFnQjtBQUMzQztBQUVBLGNBQWM7QUFDZCw2Q0FBNkM7QUFDN0MsU0FBU3MrRCxXQUFXdHNHLE9BQU87SUFDekIsSUFBSSxDQUFDQSxPQUFPLEdBQUd2TCxPQUFPLENBQUMsR0FBRzQzRyxZQUFZcnNHO0FBQ3hDO0FBRUEsa0JBQWtCO0FBQ2xCc3NHLFdBQVdoL0csU0FBUyxDQUFDbWhELEdBQUcsR0FBRztJQUN6QixJQUFJenVDLFVBQVUsSUFBSSxDQUFDQSxPQUFPO0lBQzFCLElBQUl1WixPQUFPdlosUUFBUXVaLElBQUksRUFBRSxxQ0FBcUM7SUFDOUQsSUFBSWtvRCxTQUFTLElBQUk7SUFFakIsMERBQTBEO0lBQzFELDhGQUE4RjtJQUM5RiwwQ0FBMEM7SUFDMUN6aEUsUUFBUXlQLEVBQUU7SUFDVmd5RCxPQUFPcGYsSUFBSSxDQUFDO0lBRVosMkJBQTJCO0lBQzNCLDBGQUEwRjtJQUMxRjlvQyxLQUFLeEYsS0FBSyxHQUFHdytDLFNBQVMsQ0FBQztRQUNyQixPQUFPO1lBQ0wveEQsR0FBRztZQUNIeUosR0FBRztRQUNMO0lBQ0Y7SUFFQSw0RUFBNEU7SUFDNUV3M0QsT0FBTytCLEdBQUcsQ0FBQyxlQUFleGpFLFFBQVF3cUUsS0FBSztJQUN2Qy9JLE9BQU9wZixJQUFJLENBQUM7SUFFWiwyREFBMkQ7SUFDM0RvZixPQUFPK0IsR0FBRyxDQUFDLGNBQWN4akUsUUFBUWd1QyxJQUFJO0lBQ3JDeXpCLE9BQU9wZixJQUFJLENBQUM7SUFDWixPQUFPLElBQUksRUFBRSxXQUFXO0FBQzFCO0FBRUEsK0RBQStEO0FBQy9EaXFELFdBQVdoL0csU0FBUyxDQUFDMGdELElBQUksR0FBRztJQUMxQixPQUFPLElBQUksRUFBRSxXQUFXO0FBQzFCO0FBRUEsSUFBSXUrRCxhQUFhO0lBQ2ZoNkMsV0FBV3RqRTtJQUNYLDBFQUEwRTtJQUMxRXlqQixNQUFNempCO0lBQ04sdURBQXVEO0lBQ3ZEd2pCLEtBQUt4akI7SUFDTCxzREFBc0Q7SUFDdERpaEQsS0FBSztJQUNMLDZCQUE2QjtJQUM3QmhwQixTQUFTO0lBQ1QsaUJBQWlCO0lBQ2pCMmlELGVBQWU1NkU7SUFDZixxR0FBcUc7SUFDckdtZ0QsU0FBUztJQUNULDJDQUEyQztJQUMzQys2QixtQkFBbUI7SUFDbkIseUNBQXlDO0lBQ3pDRSxpQkFBaUJwN0U7SUFDakIsaUNBQWlDO0lBQ2pDaTdFLGVBQWUsU0FBU0EsY0FBYzkwRCxJQUFJLEVBQUUzbUIsQ0FBQztRQUMzQyxPQUFPO0lBQ1Q7SUFDQSwyTEFBMkw7SUFDM0wrN0UsT0FBT3Y3RTtJQUNQLDBCQUEwQjtJQUMxQisrQyxNQUFNLytDO0lBQ04seUJBQXlCO0lBQ3pCKzZFLFdBQVcsU0FBU0EsVUFBVTUwRCxJQUFJLEVBQUVuRixRQUFRO1FBQzFDLE9BQU9BO0lBQ1QsRUFBRSwwRkFBMEY7QUFDOUY7QUFDQSxTQUFTdThGLGFBQWF4c0csT0FBTztJQUMzQixJQUFJLENBQUNBLE9BQU8sR0FBR3ZMLE9BQU8sQ0FBQyxHQUFHODNHLFlBQVl2c0c7QUFDeEM7QUFDQXdzRyxhQUFhbC9HLFNBQVMsQ0FBQ21oRCxHQUFHLEdBQUc7SUFDM0IsSUFBSXp1QyxVQUFVLElBQUksQ0FBQ0EsT0FBTztJQUMxQixJQUFJdVosT0FBT3ZaLFFBQVF1WixJQUFJO0lBQ3ZCLElBQUl4RixRQUFRd0YsS0FBS3hGLEtBQUs7SUFDdEIsSUFBSTA0RixVQUFVcDhHLEtBQUsyUCxRQUFRdXlELFNBQVM7SUFDcEMsU0FBU3V1QyxZQUFZMXJGLElBQUk7UUFDdkIsSUFBSXBWLFFBQVF1eUQsU0FBUyxJQUFJLE1BQU07WUFDN0IsT0FBT2p1QyxhQUFhbFAsS0FBS25GLFFBQVE7UUFDbkM7UUFDQSxJQUFJdzhGLFNBQVM7WUFDWCxPQUFPenNHLFFBQVF1eUQsU0FBUyxDQUFDbjlDO1FBQzNCO1FBQ0EsSUFBSW5LLE1BQU1qTCxRQUFRdXlELFNBQVMsQ0FBQ245QyxLQUFLL2pCLFFBQVEsQ0FBQ3dlLElBQUksQ0FBQ3FFLEVBQUUsQ0FBQztRQUNsRCxJQUFJakosT0FBTyxNQUFNO1lBQ2YsT0FBTztRQUNUO1FBQ0EsT0FBT0E7SUFDVDtJQUNBOEksTUFBTW8xRCxlQUFlLENBQUMsSUFBSSxFQUFFbnBFLFNBQVMsU0FBVW9WLElBQUksRUFBRTNtQixDQUFDO1FBQ3BELElBQUl3aEIsV0FBVzZ3RixZQUFZMXJGO1FBQzNCLElBQUlBLEtBQUt0RSxNQUFNLE1BQU1iLFlBQVksTUFBTTtZQUNyQyxPQUFPO1FBQ1Q7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztBQUMxQjtBQUVBLElBQUkvQyxXQUFXO0lBQ2JnakMsS0FBSztJQUNMLDZCQUE2QjtJQUM3QmhwQixTQUFTO0lBQ1QsY0FBYztJQUNkcjFCLGFBQWE1QztJQUNiLGtFQUFrRTtJQUNsRW1nRCxTQUFTO0lBQ1QsMkNBQTJDO0lBQzNDKzZCLG1CQUFtQjtJQUNuQix5Q0FBeUM7SUFDekNFLGlCQUFpQnA3RTtJQUNqQixpQ0FBaUM7SUFDakNpN0UsZUFBZSxTQUFTQSxjQUFjOTBELElBQUksRUFBRTNtQixDQUFDO1FBQzNDLE9BQU87SUFDVDtJQUNBLDJMQUEyTDtJQUMzTCs3RSxPQUFPdjdFO0lBQ1AsMEJBQTBCO0lBQzFCKytDLE1BQU0vK0M7SUFDTix5QkFBeUI7SUFDekIrNkUsV0FBVyxTQUFTQSxVQUFVNTBELElBQUksRUFBRW5GLFFBQVE7UUFDMUMsT0FBT0E7SUFDVCxFQUFFLDJGQUEyRjtBQUMvRjtBQUNBLFNBQVN5OEYsYUFBYTFzRyxPQUFPO0lBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHdkwsT0FBTyxDQUFDLEdBQUd5WSxVQUFVbE47QUFDdEM7QUFDQTBzRyxhQUFhcC9HLFNBQVMsQ0FBQ21oRCxHQUFHLEdBQUc7SUFDM0IsSUFBSXp1QyxVQUFVLElBQUksQ0FBQ0EsT0FBTztJQUMxQixJQUFJeVAsS0FBS3pQLFFBQVF5UCxFQUFFO0lBQ25CLElBQUk4SixPQUFPdlosUUFBUXVaLElBQUk7SUFDdkIsSUFBSW1OLEtBQUtELGdCQUFnQnptQixRQUFRbk8sV0FBVyxHQUFHbU8sUUFBUW5PLFdBQVcsR0FBRztRQUNuRUMsSUFBSTtRQUNKRSxJQUFJO1FBQ0ptWixHQUFHc0UsR0FBRzJaLEtBQUs7UUFDWDd6QixHQUFHa2EsR0FBRzRaLE1BQU07SUFDZDtJQUNBLElBQUltNEUsU0FBUyxTQUFTQSxPQUFPcHNGLElBQUksRUFBRTNtQixDQUFDO1FBQ2xDLE9BQU87WUFDTCtSLEdBQUdrbUIsR0FBRzUwQixFQUFFLEdBQUdkLEtBQUsrRSxLQUFLLENBQUMvRSxLQUFLOGIsTUFBTSxLQUFLNFosR0FBR3ZiLENBQUM7WUFDMUNsQixHQUFHeWMsR0FBRzEwQixFQUFFLEdBQUdoQixLQUFLK0UsS0FBSyxDQUFDL0UsS0FBSzhiLE1BQU0sS0FBSzRaLEdBQUdueEIsQ0FBQztRQUM1QztJQUNGO0lBQ0Fna0IsS0FBS3hGLEtBQUssR0FBR28xRCxlQUFlLENBQUMsSUFBSSxFQUFFbnBFLFNBQVN3aEc7SUFDNUMsT0FBTyxJQUFJLEVBQUUsV0FBVztBQUMxQjtBQUVBLElBQUkvL0IsU0FBUztJQUFDO1FBQ1pseUUsTUFBTTtRQUNOcXdDLE1BQU1nK0Q7SUFDUjtJQUFHO1FBQ0RydUcsTUFBTTtRQUNOcXdDLE1BQU1zaEU7SUFDUjtJQUFHO1FBQ0QzeEcsTUFBTTtRQUNOcXdDLE1BQU1vaUU7SUFDUjtJQUFHO1FBQ0R6eUcsTUFBTTtRQUNOcXdDLE1BQU1xa0U7SUFDUjtJQUFHO1FBQ0QxMEcsTUFBTTtRQUNOcXdDLE1BQU1xckU7SUFDUjtJQUFHO1FBQ0QxN0csTUFBTTtRQUNOcXdDLE1BQU0wc0U7SUFDUjtJQUFHO1FBQ0QvOEcsTUFBTTtRQUNOcXdDLE1BQU00c0U7SUFDUjtJQUFHO1FBQ0RqOUcsTUFBTTtRQUNOcXdDLE1BQU04c0U7SUFDUjtDQUFFO0FBRUYsU0FBU0MsYUFBYTNzRyxPQUFPO0lBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNmLElBQUksQ0FBQzYrRSxhQUFhLEdBQUcsR0FBRyxjQUFjO0FBQ3hDO0FBQ0EsSUFBSTF5RSxPQUFPLFNBQVNBLFFBQVE7QUFDNUIsSUFBSXlnRyxjQUFjLFNBQVNBO0lBQ3pCLE1BQU0sSUFBSTFzRyxNQUFNO0FBQ2xCO0FBQ0F5c0csYUFBYXIvRyxTQUFTLEdBQUc7SUFDdkJ3d0UsMEJBQTBCM3hEO0lBQzFCNGtDLFFBQVEsU0FBU0E7UUFDZixJQUFJLENBQUM4dEMsYUFBYTtJQUNwQjtJQUNBNS9DLE1BQU05eUI7SUFDTm13RixZQUFZLFNBQVNBO1FBQ25CLE9BQU87SUFDVDtJQUNBdGUsS0FBSzR1QjtJQUNMM3VCLEtBQUsydUI7QUFDUDtBQUVBLElBQUlDLFFBQVEsQ0FBQztBQUNiQSxNQUFNQyxlQUFlLEdBQUc7QUFDeEJELE1BQU1FLG1CQUFtQixHQUFHO0lBQzFCLElBQUlDLGNBQWMsSUFBSSxDQUFDQSxXQUFXLEdBQUcsQ0FBQztJQUN0QyxJQUFJaHpDLFdBQVcsSUFBSTtJQUVuQiw2QkFBNkI7SUFDN0Isb0JBQW9CO0lBQ3BCLG1DQUFtQztJQUNuQyxrQkFBa0I7SUFDbEIsRUFBRTtJQUNGLGtCQUFrQjtJQUNsQiwrQkFBK0I7SUFDL0IsMERBQTBEO0lBQzFELGFBQWE7SUFDYix3Q0FBd0M7SUFDeEMsNERBQTREO0lBRTVELElBQUlpekMsWUFBWSxTQUFTQSxVQUFVenNHLENBQUMsRUFBRXlKLENBQUMsRUFBRThFLElBQUksRUFBRXlmLEtBQUssRUFBRTArRSxXQUFXLEVBQUVDLFNBQVMsRUFBRWptRixPQUFPO1FBQ25GLElBQUlwMUIsS0FBS283RyxZQUFZMXNHLENBQUMsR0FBR3VPLE9BQU8sSUFBSW1ZO1FBQ3BDLElBQUluMUIsS0FBS203RyxZQUFZMXNHLENBQUMsR0FBR3VPLE9BQU8sSUFBSW1ZO1FBQ3BDLElBQUlsMUIsS0FBS2s3RyxZQUFZampHLENBQUMsR0FBRzhFLE9BQU8sSUFBSW1ZO1FBQ3BDLElBQUlqMUIsS0FBS2k3RyxZQUFZampHLENBQUMsR0FBRzhFLE9BQU8sSUFBSW1ZO1FBQ3BDLElBQUl5dEQsU0FBUzdpRixNQUFNME8sS0FBS0EsS0FBS3pPLE1BQU1DLE1BQU1pWSxLQUFLQSxLQUFLaFk7UUFDbkQsT0FBTzBpRjtJQUNUO0lBQ0EsSUFBSTNLLFlBQVksU0FBU0EsVUFBVXhwRSxDQUFDLEVBQUV5SixDQUFDLEVBQUU4RSxJQUFJLEVBQUV5ZixLQUFLLEVBQUUwK0UsV0FBVztRQUMvRCxJQUFJRSxXQUFXNXNHLElBQUl4UCxLQUFLd1osR0FBRyxDQUFDZ2tCLFNBQVN2a0IsSUFBSWpaLEtBQUt5WixHQUFHLENBQUMrakI7UUFDbEQsSUFBSTYrRSxXQUFXN3NHLElBQUl4UCxLQUFLeVosR0FBRyxDQUFDK2pCLFNBQVN2a0IsSUFBSWpaLEtBQUt3WixHQUFHLENBQUNna0I7UUFDbEQsSUFBSTgrRSxVQUFVRixXQUFXcitGO1FBQ3pCLElBQUl3K0YsVUFBVUYsV0FBV3QrRjtRQUN6QixJQUFJeStGLGNBQWNGLFVBQVVKLFlBQVkxc0csQ0FBQztRQUN6QyxJQUFJaXRHLGNBQWNGLFVBQVVMLFlBQVlqakcsQ0FBQztRQUN6QyxPQUFPO1lBQ0x6SixHQUFHZ3RHO1lBQ0h2akcsR0FBR3dqRztRQUNMO0lBQ0Y7SUFDQSxJQUFJamtGLGtCQUFrQixTQUFTQSxnQkFBZ0JsQixHQUFHLEVBQUV2WixJQUFJLEVBQUV5ZixLQUFLLEVBQUUwK0UsV0FBVztRQUMxRSxJQUFJUSxTQUFTLEVBQUU7UUFDZixJQUFLLElBQUlqL0csSUFBSSxHQUFHQSxJQUFJNjVCLElBQUlwOEIsTUFBTSxFQUFFdUMsS0FBSyxFQUFHO1lBQ3RDLElBQUkrUixJQUFJOG5CLEdBQUcsQ0FBQzc1QixFQUFFO1lBQ2QsSUFBSXdiLElBQUlxZSxHQUFHLENBQUM3NUIsSUFBSSxFQUFFO1lBQ2xCaS9HLE9BQU9oL0csSUFBSSxDQUFDczdFLFVBQVV4cEUsR0FBR3lKLEdBQUc4RSxNQUFNeWYsT0FBTzArRTtRQUMzQztRQUNBLE9BQU9RO0lBQ1Q7SUFDQSxJQUFJQyxjQUFjLFNBQVNBLFlBQVlybEYsR0FBRztRQUN4QyxJQUFJeDFCLE1BQU0sRUFBRTtRQUNaLElBQUssSUFBSXJFLElBQUksR0FBR0EsSUFBSTY1QixJQUFJcDhCLE1BQU0sRUFBRXVDLElBQUs7WUFDbkMsSUFBSWdILElBQUk2eUIsR0FBRyxDQUFDNzVCLEVBQUU7WUFDZHFFLElBQUlwRSxJQUFJLENBQUMrRyxFQUFFK0ssQ0FBQyxFQUFFL0ssRUFBRXdVLENBQUM7UUFDbkI7UUFDQSxPQUFPblg7SUFDVDtJQUNBLElBQUk4NkcsY0FBYyxTQUFTQSxZQUFZdjRGLElBQUk7UUFDekMsT0FBT0EsS0FBSysrQyxNQUFNLENBQUMsU0FBU0MsT0FBTyxHQUFHaC9DLEtBQUsrK0MsTUFBTSxDQUFDLGVBQWVDLE9BQU8sR0FBRztJQUM3RTtJQUNBLElBQUl3NUMsbUJBQW1CLFNBQVNBLGlCQUFpQnQrRyxJQUFJLEVBQUV1K0csSUFBSTtRQUN6RCxJQUFJeDlHLE9BQU93OUcsT0FBTztZQUNoQkEsT0FBT2QsV0FBVyxDQUFDYyxLQUFLO1FBQzFCO1FBQ0FkLFdBQVcsQ0FBQ3o5RyxLQUFLLEdBQUdrRixPQUFPO1lBQ3pCbEYsTUFBTUE7WUFDTjIrQixRQUFRO2dCQUFDLENBQUM7Z0JBQU0sQ0FBQztnQkFBSztnQkFBTSxDQUFDO2dCQUFLO2dCQUFNO2dCQUFLLENBQUM7Z0JBQU07YUFBSTtZQUN4RDYvRSxTQUFTLFNBQVNBLFFBQVF2dEcsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFOEUsSUFBSSxFQUFFeWYsS0FBSyxFQUFFMCtFLFdBQVcsRUFBRWhtRixPQUFPO2dCQUMvRCxJQUFJZ0gsU0FBU3kvRSxZQUFZbmtGLGdCQUFnQixJQUFJLENBQUMwRSxNQUFNLEVBQUVuZixPQUFPLElBQUltWSxTQUFTc0gsT0FBTzArRTtnQkFDakYsSUFBSXY0QixTQUFTMW1ELHlCQUF5Qnp0QixHQUFHeUosR0FBR2lrQjtnQkFDNUMsT0FBT3ltRDtZQUNUO1lBQ0FxNUIsY0FBY2Y7WUFDZGdCLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUV2ekQsSUFBSSxFQUFFeWYsS0FBSyxFQUFFMCtFLFdBQVc7Z0JBQ25ELElBQUloL0UsU0FBUzFFLGdCQUFnQixJQUFJLENBQUMwRSxNQUFNLEVBQUVuZixNQUFNeWYsT0FBTzArRTtnQkFDdkRsekMsU0FBU2swQyxjQUFjLENBQUMsV0FBVzVyQyxTQUFTcDBDO1lBQzlDO1lBQ0F1N0MsU0FBUyxTQUFTQSxRQUFRcDBELElBQUk7Z0JBQzVCLE9BQU87WUFDVDtZQUNBODRGLEtBQUtQO1FBQ1AsR0FBR0U7SUFDTDtJQUNBRCxpQkFBaUIsUUFBUTtRQUN2QkUsU0FBUy9oRztRQUNUZ2lHLGNBQWNoaUc7UUFDZGlpRyxNQUFNL2hHO1FBQ051OUQsU0FBU3g5RDtRQUNUa2lHLEtBQUtsaUc7SUFDUDtJQUNBNGhHLGlCQUFpQixZQUFZO1FBQzNCMy9FLFFBQVE7WUFBQyxDQUFDO1lBQU0sQ0FBQztZQUFLO1lBQUc7WUFBRztZQUFNLENBQUM7U0FBSTtJQUN6QztJQUNBMi9FLGlCQUFpQixTQUFTO0lBQzFCQSxpQkFBaUIsc0JBQXNCO1FBQ3JDMy9FLFFBQVE4K0UsV0FBVyxDQUFDLFdBQVcsQ0FBQzkrRSxNQUFNO1FBQ3RDa2dGLGNBQWM7WUFBQztZQUFHLENBQUM7U0FBSztRQUN4QkosY0FBY2Y7UUFDZGdCLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUV2ekQsSUFBSSxFQUFFeWYsS0FBSyxFQUFFMCtFLFdBQVcsRUFBRUMsU0FBUztZQUM5RCxJQUFJa0IsV0FBVzdrRixnQkFBZ0IsSUFBSSxDQUFDMEUsTUFBTSxFQUFFbmYsTUFBTXlmLE9BQU8wK0U7WUFDekQsSUFBSW9CLFNBQVMsSUFBSSxDQUFDRixZQUFZO1lBQzlCLElBQUlHLGNBQWN2a0MsVUFBVXNrQyxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFdi9GLE1BQU15ZixPQUFPMCtFO1lBQy9EbHpDLFNBQVNrMEMsY0FBYyxDQUFDLElBQUksQ0FBQzMrRyxJQUFJLEVBQUUreUUsU0FBUytyQyxVQUFVRTtRQUN4RDtRQUNBSixLQUFLLFNBQVNBLElBQUk5NEYsSUFBSTtZQUNwQixPQUFPdTRGLFlBQVl2NEYsUUFBUTtRQUM3QjtJQUNGO0lBQ0F3NEYsaUJBQWlCLGdCQUFnQjtRQUMvQjMvRSxRQUFRO1lBQUM7WUFBRztZQUFHO1lBQU0sQ0FBQztZQUFLLENBQUM7WUFBTSxDQUFDO1lBQUs7WUFBRztTQUFFO1FBQzdDc2dGLFdBQVc7WUFBQyxDQUFDO1lBQU0sQ0FBQztZQUFLLENBQUM7WUFBTSxDQUFDO1lBQUs7WUFBTSxDQUFDO1lBQUs7WUFBTSxDQUFDO1NBQUk7UUFDN0RULFNBQVMsU0FBU0EsUUFBUXZ0RyxDQUFDLEVBQUV5SixDQUFDLEVBQUU4RSxJQUFJLEVBQUV5ZixLQUFLLEVBQUUwK0UsV0FBVyxFQUFFQyxTQUFTLEVBQUVqbUYsT0FBTztZQUMxRSxJQUFJdW5GLFNBQVNkLFlBQVlua0YsZ0JBQWdCLElBQUksQ0FBQzBFLE1BQU0sRUFBRW5mLE9BQU8sSUFBSW1ZLFNBQVNzSCxPQUFPMCtFO1lBQ2pGLElBQUl3QixTQUFTZixZQUFZbmtGLGdCQUFnQixJQUFJLENBQUNnbEYsU0FBUyxFQUFFei9GLE9BQU8sSUFBSW1ZLFNBQVNzSCxPQUFPMCtFO1lBQ3BGLElBQUl2NEIsU0FBUzFtRCx5QkFBeUJ6dEIsR0FBR3lKLEdBQUd3a0csV0FBV3hnRix5QkFBeUJ6dEIsR0FBR3lKLEdBQUd5a0c7WUFDdEYsT0FBTy81QjtRQUNUO1FBQ0FzNUIsTUFBTSxTQUFTQSxLQUFLM3JDLE9BQU8sRUFBRXZ6RCxJQUFJLEVBQUV5ZixLQUFLLEVBQUUwK0UsV0FBVyxFQUFFQyxTQUFTO1lBQzlELElBQUlzQixTQUFTamxGLGdCQUFnQixJQUFJLENBQUMwRSxNQUFNLEVBQUVuZixNQUFNeWYsT0FBTzArRTtZQUN2RCxJQUFJd0IsU0FBU2xsRixnQkFBZ0IsSUFBSSxDQUFDZ2xGLFNBQVMsRUFBRXovRixNQUFNeWYsT0FBTzArRTtZQUMxRGx6QyxTQUFTazBDLGNBQWMsQ0FBQyxJQUFJLENBQUMzK0csSUFBSSxFQUFFK3lFLFNBQVNtc0MsUUFBUUM7UUFDdEQ7SUFDRjtJQUNBYixpQkFBaUIsbUJBQW1CO1FBQ2xDaGtGLFFBQVE7UUFDUjhrRixVQUFVO1lBQUM7WUFBRyxDQUFDO1lBQU07WUFBTSxDQUFDO1lBQU0sQ0FBQztZQUFNLENBQUM7WUFBTTtZQUFHLENBQUM7U0FBSztRQUN6RFosU0FBUyxTQUFTQSxRQUFRdnRHLENBQUMsRUFBRXlKLENBQUMsRUFBRThFLElBQUksRUFBRXlmLEtBQUssRUFBRTArRSxXQUFXLEVBQUVDLFNBQVMsRUFBRWptRixPQUFPO1lBQzFFLElBQUl0NkIsSUFBSXNnSDtZQUNSLElBQUkwQixlQUFlNTlHLEtBQUs2eEIsR0FBRyxDQUFDajJCLEVBQUU0VCxDQUFDLEdBQUdBLEdBQUcsS0FBS3hQLEtBQUs2eEIsR0FBRyxDQUFDajJCLEVBQUVxZCxDQUFDLEdBQUdBLEdBQUcsTUFBTWpaLEtBQUs2eEIsR0FBRyxDQUFDLENBQUM5VCxPQUFPLElBQUltWSxPQUFNLElBQUssSUFBSSxDQUFDMkMsTUFBTSxFQUFFO1lBQy9HLElBQUk0a0YsU0FBU2QsWUFBWW5rRixnQkFBZ0IsSUFBSSxDQUFDMEUsTUFBTSxFQUFFbmYsT0FBTyxJQUFJbVksU0FBU3NILE9BQU8wK0U7WUFDakYsT0FBT2ovRSx5QkFBeUJ6dEIsR0FBR3lKLEdBQUd3a0csV0FBV0c7UUFDbkQ7UUFDQVgsTUFBTSxTQUFTQSxLQUFLM3JDLE9BQU8sRUFBRXZ6RCxJQUFJLEVBQUV5ZixLQUFLLEVBQUUwK0UsV0FBVyxFQUFFQyxTQUFTO1lBQzlELElBQUlzQixTQUFTamxGLGdCQUFnQixJQUFJLENBQUNtbEYsUUFBUSxFQUFFNS9GLE1BQU15ZixPQUFPMCtFO1lBQ3pEbHpDLFNBQVNrMEMsY0FBYyxDQUFDLElBQUksQ0FBQzMrRyxJQUFJLEVBQUUreUUsU0FBU21zQyxRQUFRdkIsWUFBWTFzRyxDQUFDLEVBQUUwc0csWUFBWWpqRyxDQUFDLEVBQUUsSUFBSSxDQUFDNGYsTUFBTSxHQUFHOWE7UUFDbEc7UUFDQTA2RCxTQUFTLFNBQVNBLFFBQVFwMEQsSUFBSTtZQUM1QixPQUFPMmtELFNBQVM2MEMsYUFBYSxDQUFDeDVGLEtBQUsrK0MsTUFBTSxDQUFDLFNBQVNDLE9BQU8sRUFBRWgvQyxLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUssSUFBSSxJQUFJLENBQUMrN0IsTUFBTTtRQUM3RztJQUNGO0lBQ0Fna0YsaUJBQWlCLGtCQUFrQjtRQUNqQzMvRSxRQUFRO1lBQUM7WUFBRztZQUFHO1lBQU0sQ0FBQztZQUFLLENBQUM7WUFBTSxDQUFDO1lBQUs7WUFBRztTQUFFO1FBQzdDNGdGLGtCQUFrQjtZQUFDLENBQUM7WUFBTSxDQUFDO1lBQzNCLDhCQUE4QjtZQUM5QixDQUFDO1lBQU0sQ0FBQztZQUFLO1lBQU0sQ0FBQztZQUNwQiwrQkFBK0I7WUFDL0I7WUFBTSxDQUFDO1NBQUk7UUFDWEMsY0FBYyxTQUFTQSxhQUFhaGdHLElBQUksRUFBRW8rRixTQUFTO1lBQ2pELGdGQUFnRjtZQUNoRixJQUFJMTNHLElBQUksSUFBSSxDQUFDcTVHLGdCQUFnQixDQUFDeC9HLEtBQUs7WUFDbkMsSUFBSTAvRyxjQUFjN0IsWUFBWXArRjtZQUM5QixJQUFJa2dHLEtBQUs7WUFDVCxJQUFJajlHLEtBQUs7WUFDVHlELENBQUMsQ0FBQ3c1RyxHQUFHLEdBQUd4NUcsQ0FBQyxDQUFDdzVHLEdBQUcsR0FBR0Q7WUFDaEJ2NUcsQ0FBQyxDQUFDekQsR0FBRyxHQUFHeUQsQ0FBQyxDQUFDekQsR0FBRyxHQUFHZzlHO1lBQ2hCLE9BQU92NUc7UUFDVDtRQUNBczRHLFNBQVMsU0FBU0EsUUFBUXZ0RyxDQUFDLEVBQUV5SixDQUFDLEVBQUU4RSxJQUFJLEVBQUV5ZixLQUFLLEVBQUUwK0UsV0FBVyxFQUFFQyxTQUFTLEVBQUVqbUYsT0FBTztZQUMxRSxJQUFJdW5GLFNBQVNkLFlBQVlua0YsZ0JBQWdCLElBQUksQ0FBQzBFLE1BQU0sRUFBRW5mLE9BQU8sSUFBSW1ZLFNBQVNzSCxPQUFPMCtFO1lBQ2pGLElBQUl3QixTQUFTZixZQUFZbmtGLGdCQUFnQixJQUFJLENBQUN1bEYsWUFBWSxDQUFDaGdHLE1BQU1vK0YsWUFBWXArRixPQUFPLElBQUltWSxTQUFTc0gsT0FBTzArRTtZQUN4RyxJQUFJdjRCLFNBQVMxbUQseUJBQXlCenRCLEdBQUd5SixHQUFHd2tHLFdBQVd4Z0YseUJBQXlCenRCLEdBQUd5SixHQUFHeWtHO1lBQ3RGLE9BQU8vNUI7UUFDVDtRQUNBczVCLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUV2ekQsSUFBSSxFQUFFeWYsS0FBSyxFQUFFMCtFLFdBQVcsRUFBRUMsU0FBUztZQUM5RCxJQUFJc0IsU0FBU2psRixnQkFBZ0IsSUFBSSxDQUFDMEUsTUFBTSxFQUFFbmYsTUFBTXlmLE9BQU8wK0U7WUFDdkQsSUFBSTZCLGVBQWV2bEYsZ0JBQWdCLElBQUksQ0FBQ3VsRixZQUFZLENBQUNoZ0csTUFBTW8rRixZQUFZcCtGLE1BQU15ZixPQUFPMCtFO1lBQ3BGbHpDLFNBQVNrMEMsY0FBYyxDQUFDLElBQUksQ0FBQzMrRyxJQUFJLEVBQUUreUUsU0FBU21zQyxRQUFRTTtRQUN0RDtJQUNGO0lBQ0FsQixpQkFBaUIsT0FBTztRQUN0QjMvRSxRQUFRO1lBQUMsQ0FBQztZQUFNLENBQUM7WUFBSztZQUFHO1lBQUc7WUFBTSxDQUFDO1lBQUs7WUFBRyxDQUFDO1NBQUs7UUFDakRpZ0YsS0FBSyxTQUFTQSxJQUFJOTRGLElBQUk7WUFDcEIsT0FBT3U0RixZQUFZdjRGLFFBQVE7UUFDN0I7SUFDRjtJQUNBdzRGLGlCQUFpQixVQUFVO1FBQ3pCaGtGLFFBQVE7UUFDUmtrRixTQUFTLFNBQVNBLFFBQVF2dEcsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFOEUsSUFBSSxFQUFFeWYsS0FBSyxFQUFFMCtFLFdBQVcsRUFBRUMsU0FBUyxFQUFFam1GLE9BQU87WUFDMUUsSUFBSXQ2QixJQUFJc2dIO1lBQ1IsSUFBSXY0QixTQUFTM2pGLEtBQUs2eEIsR0FBRyxDQUFDajJCLEVBQUU0VCxDQUFDLEdBQUdBLEdBQUcsS0FBS3hQLEtBQUs2eEIsR0FBRyxDQUFDajJCLEVBQUVxZCxDQUFDLEdBQUdBLEdBQUcsTUFBTWpaLEtBQUs2eEIsR0FBRyxDQUFDLENBQUM5VCxPQUFPLElBQUltWSxPQUFNLElBQUssSUFBSSxDQUFDMkMsTUFBTSxFQUFFO1lBQ3pHLE9BQU84cUQ7UUFDVDtRQUNBczVCLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUV2ekQsSUFBSSxFQUFFeWYsS0FBSyxFQUFFMCtFLFdBQVcsRUFBRUMsU0FBUztZQUM5RG56QyxTQUFTazBDLGNBQWMsQ0FBQyxJQUFJLENBQUMzK0csSUFBSSxFQUFFK3lFLFNBQVM0cUMsWUFBWTFzRyxDQUFDLEVBQUUwc0csWUFBWWpqRyxDQUFDLEVBQUUsSUFBSSxDQUFDNGYsTUFBTSxHQUFHOWE7UUFDMUY7UUFDQTA2RCxTQUFTLFNBQVNBLFFBQVFwMEQsSUFBSTtZQUM1QixPQUFPMmtELFNBQVM2MEMsYUFBYSxDQUFDeDVGLEtBQUsrK0MsTUFBTSxDQUFDLFNBQVNDLE9BQU8sRUFBRWgvQyxLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUssSUFBSSxJQUFJLENBQUMrN0IsTUFBTTtRQUM3RztJQUNGO0lBQ0Fna0YsaUJBQWlCLE9BQU87UUFDdEIzL0UsUUFBUTtZQUFDLENBQUM7WUFBTTtZQUFHLENBQUM7WUFBTSxDQUFDO1lBQUs7WUFBTSxDQUFDO1lBQUs7WUFBTTtTQUFFO1FBQ3BEdTdDLFNBQVMsU0FBU0EsUUFBUXAwRCxJQUFJO1lBQzVCLE9BQU87UUFDVDtRQUNBODRGLEtBQUssU0FBU0EsSUFBSTk0RixJQUFJO1lBQ3BCLE9BQU87UUFDVDtJQUNGO0lBQ0F3NEYsaUJBQWlCLFVBQVU7UUFDekIzL0UsUUFBUTtZQUFDLENBQUM7WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNLENBQUM7WUFBSyxDQUFDO1lBQU0sQ0FBQztTQUFJO0lBQzVEO0lBQ0EyL0UsaUJBQWlCLFdBQVc7UUFDMUIzL0UsUUFBUTtZQUFDLENBQUM7WUFBTSxDQUFDO1lBQU07WUFBRyxDQUFDO1lBQUs7WUFBTSxDQUFDO1lBQU07WUFBRztTQUFFO1FBQ2xEaWdGLEtBQUssU0FBU0EsSUFBSTk0RixJQUFJO1lBQ3BCLE9BQU9BLEtBQUsrK0MsTUFBTSxDQUFDLFNBQVNDLE9BQU8sR0FBR2gvQyxLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7UUFDeEU7SUFDRjtJQUNBKy9HLGlCQUFpQixXQUFXO1FBQzFCMy9FLFFBQVE7WUFBQztZQUFHO1lBQUcsQ0FBQztZQUFNLENBQUM7WUFBTSxDQUFDO1lBQUssQ0FBQztZQUFLO1lBQUcsQ0FBQztZQUFLO1lBQUssQ0FBQztZQUFLO1lBQU0sQ0FBQztTQUFLO1FBQ3pFaWdGLEtBQUssU0FBU0EsSUFBSTk0RixJQUFJO1lBQ3BCLE9BQU8sT0FBT0EsS0FBSysrQyxNQUFNLENBQUMsU0FBU0MsT0FBTyxHQUFHaC9DLEtBQUsrK0MsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztRQUMvRTtJQUNGO0FBQ0Y7QUFFQSxJQUFJb2hILFFBQVEsQ0FBQztBQUViLGdCQUFnQjtBQUNoQkEsTUFBTUMsbUJBQW1CLEdBQUcsU0FBVUMsT0FBTyxFQUFFQyxPQUFPO0lBQ3BELElBQUk1L0YsS0FBSyxJQUFJLENBQUNBLEVBQUU7SUFDaEIsSUFBSTYvRixVQUFVLElBQUksQ0FBQ0MseUJBQXlCO0lBQzVDLElBQUlDLGFBQWFGLE9BQU8sQ0FBQyxFQUFFO0lBQzNCLElBQUlHLFlBQVlILE9BQU8sQ0FBQyxFQUFFO0lBQzFCLElBQUlwbkYsUUFBUW9uRixPQUFPLENBQUMsRUFBRTtJQUN0QixJQUFJNzhGLE1BQU1oRCxHQUFHZ0QsR0FBRztJQUNoQixJQUFJQyxPQUFPakQsR0FBR2lELElBQUk7SUFDbEIsSUFBSWxTLElBQUksQ0FBQyxDQUFDNHVHLFVBQVVJLFVBQVMsSUFBS3RuRixRQUFRelYsSUFBSWpTLENBQUMsSUFBSWtTO0lBQ25ELElBQUl6SSxJQUFJLENBQUMsQ0FBQ29sRyxVQUFVSSxTQUFRLElBQUt2bkYsUUFBUXpWLElBQUl4SSxDQUFDLElBQUl5STtJQUNsRCxPQUFPO1FBQUNsUztRQUFHeUo7S0FBRTtBQUNmO0FBQ0FpbEcsTUFBTUsseUJBQXlCLEdBQUc7SUFDaEMsSUFBSSxJQUFJLENBQUNHLFdBQVcsRUFBRTtRQUNwQixPQUFPLElBQUksQ0FBQ0EsV0FBVztJQUN6QjtJQUNBLElBQUl6dUIsWUFBWSxJQUFJLENBQUNBLFNBQVM7SUFDOUIsSUFBSTB1QixPQUFPMXVCLFVBQVUydUIscUJBQXFCO0lBQzFDLElBQUlyL0YsUUFBUSxJQUFJLENBQUNkLEVBQUUsQ0FBQy9mLE1BQU0sR0FBR2k5RixnQkFBZ0IsQ0FBQzFMO0lBQzlDLElBQUk0dUIsYUFBYSxTQUFTQSxXQUFXdGdILElBQUk7UUFDdkMsT0FBT3VHLFdBQVd5YSxNQUFNcThFLGdCQUFnQixDQUFDcjlGO0lBQzNDO0lBQ0EsSUFBSTIzQixVQUFVO1FBQ1pJLE1BQU11b0YsV0FBVztRQUNqQnpvRixPQUFPeW9GLFdBQVc7UUFDbEJqM0YsS0FBS2kzRixXQUFXO1FBQ2hCeG9GLFFBQVF3b0YsV0FBVztJQUNyQjtJQUNBLElBQUk3d0MsU0FBUztRQUNYMTNDLE1BQU11b0YsV0FBVztRQUNqQnpvRixPQUFPeW9GLFdBQVc7UUFDbEJqM0YsS0FBS2kzRixXQUFXO1FBQ2hCeG9GLFFBQVF3b0YsV0FBVztJQUNyQjtJQUNBLElBQUl0VixjQUFjdFosVUFBVXNaLFdBQVc7SUFDdkMsSUFBSUMsZUFBZXZaLFVBQVV1WixZQUFZO0lBQ3pDLElBQUlzVixhQUFhNW9GLFFBQVFJLElBQUksR0FBR0osUUFBUUUsS0FBSztJQUM3QyxJQUFJMm9GLGFBQWE3b0YsUUFBUXRPLEdBQUcsR0FBR3NPLFFBQVFHLE1BQU07SUFDN0MsSUFBSTJvRixZQUFZaHhDLE9BQU8xM0MsSUFBSSxHQUFHMDNDLE9BQU81M0MsS0FBSztJQUMxQyxJQUFJYyxRQUFReW5GLEtBQUt2bUYsS0FBSyxHQUFJbXhFLENBQUFBLGNBQWN5VixTQUFRO0lBQ2hELElBQUlDLFlBQVkxVixjQUFjdVY7SUFDOUIsSUFBSUksWUFBWTFWLGVBQWV1VjtJQUMvQixJQUFJem9GLE9BQU9xb0YsS0FBS3JvRixJQUFJLEdBQUdKLFFBQVFJLElBQUksR0FBRzAzQyxPQUFPMTNDLElBQUk7SUFDakQsSUFBSTFPLE1BQU0rMkYsS0FBSy8yRixHQUFHLEdBQUdzTyxRQUFRdE8sR0FBRyxHQUFHb21ELE9BQU9wbUQsR0FBRztJQUM3QyxPQUFPLElBQUksQ0FBQzgyRixXQUFXLEdBQUc7UUFBQ3BvRjtRQUFNMU87UUFBS3EzRjtRQUFXQztRQUFXaG9GO0tBQU07QUFDcEU7QUFDQWduRixNQUFNaUIsb0NBQW9DLEdBQUc7SUFDM0MsSUFBSSxDQUFDVCxXQUFXLEdBQUc7QUFDckI7QUFDQVIsTUFBTWtCLGtCQUFrQixHQUFHLFNBQVU1dkcsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFb21HLHVCQUF1QixFQUFFQyxPQUFPO0lBQ3pFLE9BQU8sSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQy92RyxHQUFHeUosR0FBR29tRyx5QkFBeUJDLFFBQVEsQ0FBQyxFQUFFO0FBQzVFO0FBQ0FwQixNQUFNcUIsbUJBQW1CLEdBQUcsU0FBVS92RyxDQUFDLEVBQUV5SixDQUFDLEVBQUVvbUcsdUJBQXVCLEVBQUVDLE9BQU87SUFDMUUsSUFBSXo5RyxRQUFPLElBQUk7SUFDZixJQUFJN0csSUFBSSxJQUFJO0lBQ1osSUFBSXV0QixPQUFPdnRCLEVBQUV3a0gsb0JBQW9CO0lBQ2pDLElBQUlDLE9BQU8sRUFBRSxFQUFFLHlCQUF5QjtJQUN4QyxJQUFJLzlGLE9BQU8xbUIsRUFBRXlqQixFQUFFLENBQUNpRCxJQUFJO0lBQ3BCLElBQUkyOUMsZUFBZXJrRSxFQUFFeWpCLEVBQUUsQ0FBQzZnRCxnQkFBZ0I7SUFDeEMsSUFBSW9nRCxnQkFBZ0IsQ0FBQ0osVUFBVSxLQUFLLEtBQUs1OUY7SUFDekMsSUFBSWkrRixnQkFBZ0IsQ0FBQ0wsVUFBVSxJQUFJLEtBQUs1OUY7SUFDeEMsSUFBSWsrRixpQkFBaUIsQ0FBQ04sVUFBVSxJQUFJLEtBQUs1OUY7SUFDekMsSUFBSW0rRixZQUFZNTJGO0lBQ2hCLElBQUk2MkY7SUFDSixJQUFJQztJQUNKLElBQUlWLHlCQUF5QjtRQUMzQjkyRixPQUFPQSxLQUFLZzBELFdBQVc7SUFDekI7SUFDQSxTQUFTeWpDLE9BQU94akcsR0FBRyxFQUFFeWpHLE1BQU07UUFDekIsSUFBSXpqRyxJQUFJb0UsTUFBTSxJQUFJO1lBQ2hCLElBQUltL0YsVUFBVTtnQkFDWixRQUFRLHFCQUFxQjtZQUMvQixPQUFPO2dCQUNMQSxXQUFXdmpHO2dCQUNYaWpHLEtBQUsvaEgsSUFBSSxDQUFDOGU7WUFDWjtRQUNGO1FBQ0EsSUFBSUEsSUFBSW02QixNQUFNLE1BQU9zcEUsQ0FBQUEsVUFBVSxRQUFRQSxTQUFTSixTQUFRLEdBQUk7WUFDMUQsSUFBSUMsVUFBVTtnQkFDWiw2QkFBNkI7Z0JBQzdCLG1DQUFtQztnQkFDbkMsSUFBSUEsU0FBUzE4QyxNQUFNLENBQUMsb0JBQW9CdG1FLEtBQUssS0FBSzBmLElBQUk0bUQsTUFBTSxDQUFDLG9CQUFvQnRtRSxLQUFLLElBQUlnakgsU0FBUzE4QyxNQUFNLENBQUMsb0JBQW9CdG1FLEtBQUssS0FBSzBmLElBQUk0bUQsTUFBTSxDQUFDLG9CQUFvQnRtRSxLQUFLLEVBQUU7b0JBQzVLLElBQUssSUFBSVcsSUFBSSxHQUFHQSxJQUFJZ2lILEtBQUt2a0gsTUFBTSxFQUFFdUMsSUFBSzt3QkFDcEMsSUFBSWdpSCxJQUFJLENBQUNoaUgsRUFBRSxDQUFDazVDLE1BQU0sSUFBSTs0QkFDcEI4b0UsSUFBSSxDQUFDaGlILEVBQUUsR0FBRytlOzRCQUNWc2pHLFdBQVd0akc7NEJBQ1hxakcsWUFBWUksVUFBVSxPQUFPQSxTQUFTSjs0QkFDdEM7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMSixLQUFLL2hILElBQUksQ0FBQzhlO2dCQUNWc2pHLFdBQVd0akc7Z0JBQ1hxakcsWUFBWUksVUFBVSxPQUFPQSxTQUFTSjtZQUN4QztRQUNGO0lBQ0Y7SUFDQSxTQUFTSyxVQUFVOTdGLElBQUk7UUFDckIsSUFBSWdVLFFBQVFoVSxLQUFLb21ELFVBQVUsS0FBSyxJQUFJbTFDO1FBQ3BDLElBQUl0bkYsU0FBU2pVLEtBQUtxbUQsV0FBVyxLQUFLLElBQUlrMUM7UUFDdEMsSUFBSVEsS0FBSy9uRixRQUFRO1FBQ2pCLElBQUlnb0YsS0FBSy9uRixTQUFTO1FBQ2xCLElBQUlwZSxNQUFNbUssS0FBS25GLFFBQVE7UUFDdkIsSUFBSTZaLGVBQWUxVSxLQUFLZy9DLE1BQU0sQ0FBQyxpQkFBaUJ0bUUsS0FBSyxLQUFLLFNBQVMsU0FBU3NuQixLQUFLZy9DLE1BQU0sQ0FBQyxpQkFBaUJDLE9BQU87UUFDaEgsSUFBSWc5QyxLQUFLajhGLEtBQUsvakIsUUFBUSxDQUFDa2dCLFFBQVE7UUFDL0IsSUFBSXRHLElBQUl6SyxDQUFDLEdBQUcyd0csTUFBTTN3RyxLQUFLQSxLQUFLeUssSUFBSXpLLENBQUMsR0FBRzJ3RyxHQUFHLGFBQWE7WUFDakRsbUcsSUFBSWhCLENBQUMsR0FBR21uRyxNQUFNbm5HLEtBQUtBLEtBQUtnQixJQUFJaEIsQ0FBQyxHQUFHbW5HLEdBQUcsYUFBYTtVQUNqRDtZQUNBLElBQUl0M0MsUUFBUTl0RSxFQUFFaXVFLFVBQVUsQ0FBQ3BuRSxNQUFLeStHLFlBQVksQ0FBQ2w4RixNQUFNO1lBQ2pELElBQUkwa0QsTUFBTXkzQyxVQUFVLENBQUMvd0csR0FBR3lKLEdBQUcsR0FBR21mLE9BQU9DLFFBQVFwZSxJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUMsRUFBRTZmLGNBQWN1bkYsS0FBSztnQkFDNUVMLE9BQU81N0YsTUFBTTtnQkFDYixPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsU0FBU284RixVQUFVbjhGLElBQUk7UUFDckIsSUFBSXJGLEtBQUtxRixLQUFLaGtCLFFBQVE7UUFDdEIsSUFBSWdnSCxLQUFLcmhHLEdBQUd1QixRQUFRO1FBQ3BCLElBQUlrZ0csYUFBYXA4RixLQUFLKytDLE1BQU0sQ0FBQyxTQUFTQyxPQUFPO1FBQzdDLElBQUluc0MsUUFBUTdTLEtBQUsrK0MsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztRQUM1QyxJQUFJczdCLFFBQVFxb0YsYUFBYSxJQUFJZixlQUFlLDBDQUEwQztRQUN0RixJQUFJZ0IsVUFBVXRvRixRQUFRQTtRQUN0QixJQUFJdW9GLFNBQVN2b0YsUUFBUTtRQUNyQixJQUFJMVUsTUFBTTFFLEdBQUdGLE1BQU07UUFDbkIsSUFBSWxiLE1BQU1vYixHQUFHRCxNQUFNO1FBQ25CLElBQUlraEc7UUFDSixJQUFJSSxHQUFHTyxRQUFRLEtBQUssY0FBY1AsR0FBR08sUUFBUSxLQUFLLGNBQWNQLEdBQUdPLFFBQVEsS0FBSyxZQUFZO1lBQzFGLElBQUl0cEYsTUFBTStvRixHQUFHUSxNQUFNO1lBQ25CLElBQUssSUFBSXBqSCxJQUFJLEdBQUdBLElBQUksSUFBSTY1QixJQUFJcDhCLE1BQU0sRUFBRXVDLEtBQUssRUFBRztnQkFDMUMsSUFBSXU5QixlQUFleHJCLEdBQUd5SixHQUFHcWUsR0FBRyxDQUFDNzVCLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxFQUFFNjVCLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsRUFBRWtqSCxXQUFXRCxVQUFXVCxDQUFBQSxTQUFTdmpGLG1CQUFtQmx0QixHQUFHeUosR0FBR3FlLEdBQUcsQ0FBQzc1QixFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxFQUFFNjVCLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFLElBQUk7b0JBQ3pLdWlILE9BQU8zN0YsTUFBTTQ3RjtvQkFDYixPQUFPO2dCQUNUO1lBQ0Y7UUFDRixPQUFPLElBQUlJLEdBQUdPLFFBQVEsS0FBSyxZQUFZUCxHQUFHTyxRQUFRLEtBQUssaUJBQWlCUCxHQUFHTyxRQUFRLEtBQUssVUFBVVAsR0FBR08sUUFBUSxLQUFLLFlBQVk7WUFDNUgsSUFBSXRwRixNQUFNK29GLEdBQUdRLE1BQU07WUFDbkIsSUFBSyxJQUFJcGpILElBQUksR0FBR0EsSUFBSSxJQUFJNGlILEdBQUdRLE1BQU0sQ0FBQzNsSCxNQUFNLEVBQUV1QyxLQUFLLEVBQUc7Z0JBQ2hELElBQUk2OUIsaUJBQWlCOXJCLEdBQUd5SixHQUFHcWUsR0FBRyxDQUFDNzVCLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxFQUFFNjVCLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxFQUFFa2pILFdBQVdELFVBQVdULENBQUFBLFNBQVM3akYsd0JBQXdCNXNCLEdBQUd5SixHQUFHcWUsR0FBRyxDQUFDNzVCLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxFQUFFNjVCLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxJQUFJO29CQUNoT3VpSCxPQUFPMzdGLE1BQU00N0Y7b0JBQ2IsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFFQSx3RUFBd0U7UUFFeEUsSUFBSXY4RixNQUFNQSxPQUFPMUUsR0FBR0YsTUFBTTtRQUMxQixJQUFJbGIsTUFBTUEsT0FBT29iLEdBQUdELE1BQU07UUFDMUIsSUFBSStoRyxTQUFTai9HLE1BQUtnOEcsYUFBYSxDQUFDNEMsWUFBWXZwRjtRQUM1QyxJQUFJNnBGLFNBQVM7WUFBQztnQkFDWnhpSCxNQUFNO2dCQUNOaVIsR0FBRzZ3RyxHQUFHVyxXQUFXO2dCQUNqQi9uRyxHQUFHb25HLEdBQUdZLFdBQVc7Z0JBQ2pCempGLE9BQU82aUYsR0FBR2EsYUFBYTtZQUN6QjtZQUFHO2dCQUNEM2lILE1BQU07Z0JBQ05pUixHQUFHNndHLEdBQUdjLFNBQVM7Z0JBQ2Zsb0csR0FBR29uRyxHQUFHZSxTQUFTO2dCQUNmNWpGLE9BQU82aUYsR0FBR2dCLGFBQWE7WUFDekI7WUFBRztnQkFDRDlpSCxNQUFNO2dCQUNOaVIsR0FBRzZ3RyxHQUFHejZDLElBQUk7Z0JBQ1Yzc0QsR0FBR29uRyxHQUFHeDZDLElBQUk7Z0JBQ1Zyb0MsT0FBTzZpRixHQUFHaUIsZ0JBQWdCO1lBQzVCO1lBQUc7Z0JBQ0QvaUgsTUFBTTtnQkFDTmlSLEdBQUc2d0csR0FBR3o2QyxJQUFJO2dCQUNWM3NELEdBQUdvbkcsR0FBR3g2QyxJQUFJO2dCQUNWcm9DLE9BQU82aUYsR0FBR2tCLGdCQUFnQjtZQUM1QjtTQUFFO1FBQ0YsSUFBSyxJQUFJOWpILElBQUksR0FBR0EsSUFBSXNqSCxPQUFPN2xILE1BQU0sRUFBRXVDLElBQUs7WUFDdEMsSUFBSStqSCxLQUFLVCxNQUFNLENBQUN0akgsRUFBRTtZQUNsQixJQUFJcXJFLFFBQVE5dEUsRUFBRWdoSCxXQUFXLENBQUMzM0YsS0FBSysrQyxNQUFNLENBQUNvK0MsR0FBR2pqSCxJQUFJLEdBQUcsZ0JBQWdCekIsS0FBSyxDQUFDO1lBQ3RFLElBQUlxL0csWUFBWTkzRixLQUFLKytDLE1BQU0sQ0FBQyxTQUFTQyxPQUFPO1lBQzVDLElBQUl5RixNQUFNazBDLFlBQVksQ0FBQ3h0RyxHQUFHeUosR0FBRzZuRyxRQUFRVSxHQUFHaGtGLEtBQUssRUFBRTtnQkFDN0NodUIsR0FBR2d5RyxHQUFHaHlHLENBQUM7Z0JBQ1B5SixHQUFHdW9HLEdBQUd2b0csQ0FBQztZQUNULEdBQUdrakcsV0FBV3VELGtCQUFrQjUyQyxNQUFNaTBDLE9BQU8sQ0FBQ3Z0RyxHQUFHeUosR0FBRzZuRyxRQUFRVSxHQUFHaGtGLEtBQUssRUFBRTtnQkFDcEVodUIsR0FBR2d5RyxHQUFHaHlHLENBQUM7Z0JBQ1B5SixHQUFHdW9HLEdBQUd2b0csQ0FBQztZQUNULEdBQUdrakcsV0FBV3VELGdCQUFnQjtnQkFDNUJNLE9BQU8zN0Y7Z0JBQ1AsT0FBTztZQUNUO1FBQ0Y7UUFFQSw4SEFBOEg7UUFDOUgsSUFBSWc3QyxnQkFBZ0JvZ0QsS0FBS3ZrSCxNQUFNLEdBQUcsR0FBRztZQUNuQ2dsSCxVQUFVeDhGO1lBQ1Z3OEYsVUFBVXQ4RztRQUNaO0lBQ0Y7SUFDQSxTQUFTNjlHLFFBQVF0aUgsR0FBRyxFQUFFWixJQUFJLEVBQUVtakgsR0FBRztRQUM3QixPQUFPNWtHLG9CQUFvQjNkLEtBQUtaLE1BQU1takg7SUFDeEM7SUFDQSxTQUFTQyxXQUFXbmxHLEdBQUcsRUFBRTlaLE1BQU07UUFDN0IsSUFBSXNjLEtBQUt4QyxJQUFJbmMsUUFBUTtRQUNyQixJQUFJdWhILEtBQUtoQztRQUNULElBQUk1NUM7UUFDSixJQUFJdGpFLFFBQVE7WUFDVnNqRSxhQUFhdGpFLFNBQVM7UUFDeEIsT0FBTztZQUNMc2pFLGFBQWE7UUFDZjtRQUNBeHBELElBQUkzYixXQUFXO1FBQ2YsSUFBSTYwQixLQUFLMVcsR0FBR21DLFdBQVcsQ0FBQ3plLFVBQVUsT0FBTztRQUN6QyxJQUFJZzZELE9BQU9sZ0QsSUFBSTRtRCxNQUFNLENBQUM0QyxhQUFhLFNBQVNscEUsS0FBSztRQUNqRCxJQUFJK2tILGdCQUFnQnJsRyxJQUFJNG1ELE1BQU0sQ0FBQyxlQUFlOEMsUUFBUSxLQUFLO1FBQzNELElBQUksQ0FBQzI3QyxpQkFBaUIsQ0FBQ25sRCxNQUFNO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJKzdDLEtBQUtnSixRQUFRemlHLEdBQUd1QixRQUFRLEVBQUUsVUFBVTdkO1FBQ3hDLElBQUlnMkcsS0FBSytJLFFBQVF6aUcsR0FBR3VCLFFBQVEsRUFBRSxVQUFVN2Q7UUFDeEMsSUFBSWlsRSxRQUFRODVDLFFBQVF6aUcsR0FBR3VCLFFBQVEsRUFBRSxjQUFjN2Q7UUFDL0MsSUFBSW8vRyxLQUFLdGxHLElBQUk0bUQsTUFBTSxDQUFDNEMsYUFBYSxpQkFBaUIzQyxPQUFPO1FBQ3pELElBQUkwK0MsS0FBS3ZsRyxJQUFJNG1ELE1BQU0sQ0FBQzRDLGFBQWEsaUJBQWlCM0MsT0FBTztRQUN6RCxJQUFJcG9DLE1BQU12RixHQUFHNTBCLEVBQUUsR0FBRzhnSCxLQUFLRSxJQUFJLDJDQUEyQztRQUN0RSxJQUFJM21GLE1BQU16RixHQUFHMzBCLEVBQUUsR0FBRzZnSCxLQUFLRSxJQUFJLGlDQUFpQztRQUM1RCxJQUFJNW1GLE1BQU14RixHQUFHMTBCLEVBQUUsR0FBRzRnSCxLQUFLRztRQUN2QixJQUFJM21GLE1BQU0xRixHQUFHejBCLEVBQUUsR0FBRzJnSCxLQUFLRztRQUN2QixJQUFJcDZDLE9BQU87WUFDVCxJQUFJbnVELE1BQU14WixLQUFLd1osR0FBRyxDQUFDbXVEO1lBQ25CLElBQUlsdUQsTUFBTXpaLEtBQUt5WixHQUFHLENBQUNrdUQ7WUFDbkIsSUFBSUcsU0FBUyxTQUFTQSxPQUFPdDRELENBQUMsRUFBRXlKLENBQUM7Z0JBQy9CekosSUFBSUEsSUFBSWlwRztnQkFDUngvRixJQUFJQSxJQUFJeS9GO2dCQUNSLE9BQU87b0JBQ0xscEcsR0FBR0EsSUFBSWdLLE1BQU1QLElBQUlRLE1BQU1nL0Y7b0JBQ3ZCeC9GLEdBQUd6SixJQUFJaUssTUFBTVIsSUFBSU8sTUFBTWsvRjtnQkFDekI7WUFDRjtZQUNBLElBQUkzd0MsUUFBUUQsT0FBTzdzQyxLQUFLQztZQUN4QixJQUFJOHNDLFFBQVFGLE9BQU83c0MsS0FBS0c7WUFDeEIsSUFBSTZzQyxRQUFRSCxPQUFPM3NDLEtBQUtEO1lBQ3hCLElBQUlndEMsUUFBUUosT0FBTzNzQyxLQUFLQztZQUN4QixJQUFJOEIsU0FBUztnQkFDYixzREFBc0Q7Z0JBQ3RENnFDLE1BQU12NEQsQ0FBQyxHQUFHc3lHO2dCQUFJLzVDLE1BQU05dUQsQ0FBQyxHQUFHOG9HO2dCQUFJOTVDLE1BQU16NEQsQ0FBQyxHQUFHc3lHO2dCQUFJNzVDLE1BQU1odkQsQ0FBQyxHQUFHOG9HO2dCQUFJNzVDLE1BQU0xNEQsQ0FBQyxHQUFHc3lHO2dCQUFJNTVDLE1BQU1qdkQsQ0FBQyxHQUFHOG9HO2dCQUFJLzVDLE1BQU14NEQsQ0FBQyxHQUFHc3lHO2dCQUFJOTVDLE1BQU0vdUQsQ0FBQyxHQUFHOG9HO2FBQUc7WUFDL0csSUFBSTlrRix5QkFBeUJ6dEIsR0FBR3lKLEdBQUdpa0IsU0FBUztnQkFDMUM4aUYsT0FBT3hqRztnQkFDUCxPQUFPO1lBQ1Q7UUFDRixPQUFPO1lBQ0wsd0JBQXdCO1lBQ3hCLElBQUlrYSxjQUFjaEIsSUFBSWxtQixHQUFHeUosSUFBSTtnQkFDM0IrbUcsT0FBT3hqRztnQkFDUCxPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsSUFBSyxJQUFJL2UsSUFBSThxQixLQUFLcnRCLE1BQU0sR0FBRyxHQUFHdUMsS0FBSyxHQUFHQSxJQUFLO1FBQ3pDLCtCQUErQjtRQUMvQixJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO1FBQ2pCLElBQUkrZSxJQUFJb0UsTUFBTSxJQUFJO1lBQ2hCcy9GLFVBQVUxakcsUUFBUW1sRyxXQUFXbmxHO1FBQy9CLE9BQU87WUFDTCxZQUFZO1lBQ1pna0csVUFBVWhrRyxRQUFRbWxHLFdBQVdubEcsUUFBUW1sRyxXQUFXbmxHLEtBQUssYUFBYW1sRyxXQUFXbmxHLEtBQUs7UUFDcEY7SUFDRjtJQUNBLE9BQU9pakc7QUFDVDtBQUVBLHFDQUFxQztBQUNyQ3ZCLE1BQU04RCxXQUFXLEdBQUcsU0FBVWxoSCxFQUFFLEVBQUVFLEVBQUUsRUFBRUQsRUFBRSxFQUFFRSxFQUFFO0lBQzFDLElBQUlzbkIsT0FBTyxJQUFJLENBQUNpM0Ysb0JBQW9CLEdBQUdqakMsV0FBVztJQUNsRCxJQUFJNzZELE9BQU8sSUFBSSxDQUFDakQsRUFBRSxDQUFDaUQsSUFBSTtJQUN2QixJQUFJaytGLGlCQUFpQixJQUFJbCtGO0lBQ3pCLElBQUl4SCxNQUFNLEVBQUU7SUFDWixJQUFJK25HLE1BQU1qaUgsS0FBSytVLEdBQUcsQ0FBQ2pVLElBQUlDO0lBQ3ZCLElBQUltaEgsTUFBTWxpSCxLQUFLNlUsR0FBRyxDQUFDL1QsSUFBSUM7SUFDdkIsSUFBSW9oSCxNQUFNbmlILEtBQUsrVSxHQUFHLENBQUMvVCxJQUFJQztJQUN2QixJQUFJbWhILE1BQU1waUgsS0FBSzZVLEdBQUcsQ0FBQzdULElBQUlDO0lBQ3ZCSCxLQUFLbWhIO0lBQ0xsaEgsS0FBS21oSDtJQUNMbGhILEtBQUttaEg7SUFDTGxoSCxLQUFLbWhIO0lBQ0wsSUFBSUMsUUFBUTVzRixnQkFBZ0I7UUFDMUIzMEIsSUFBSUE7UUFDSkUsSUFBSUE7UUFDSkQsSUFBSUE7UUFDSkUsSUFBSUE7SUFDTjtJQUNBLElBQUlxaEgsZUFBZTtRQUFDO1lBQ2xCOXlHLEdBQUc2eUcsTUFBTXZoSCxFQUFFO1lBQ1htWSxHQUFHb3BHLE1BQU1yaEgsRUFBRTtRQUNiO1FBQUc7WUFDRHdPLEdBQUc2eUcsTUFBTXRoSCxFQUFFO1lBQ1hrWSxHQUFHb3BHLE1BQU1yaEgsRUFBRTtRQUNiO1FBQUc7WUFDRHdPLEdBQUc2eUcsTUFBTXRoSCxFQUFFO1lBQ1hrWSxHQUFHb3BHLE1BQU1waEgsRUFBRTtRQUNiO1FBQUc7WUFDRHVPLEdBQUc2eUcsTUFBTXZoSCxFQUFFO1lBQ1htWSxHQUFHb3BHLE1BQU1waEgsRUFBRTtRQUNiO0tBQUU7SUFDRixJQUFJc2hILFdBQVc7UUFBQztZQUFDRCxZQUFZLENBQUMsRUFBRTtZQUFFQSxZQUFZLENBQUMsRUFBRTtTQUFDO1FBQUU7WUFBQ0EsWUFBWSxDQUFDLEVBQUU7WUFBRUEsWUFBWSxDQUFDLEVBQUU7U0FBQztRQUFFO1lBQUNBLFlBQVksQ0FBQyxFQUFFO1lBQUVBLFlBQVksQ0FBQyxFQUFFO1NBQUM7UUFBRTtZQUFDQSxZQUFZLENBQUMsRUFBRTtZQUFFQSxZQUFZLENBQUMsRUFBRTtTQUFDO0tBQUM7SUFDL0osU0FBU2IsUUFBUXRpSCxHQUFHLEVBQUVaLElBQUksRUFBRW1qSCxHQUFHO1FBQzdCLE9BQU81a0csb0JBQW9CM2QsS0FBS1osTUFBTW1qSDtJQUN4QztJQUNBLFNBQVNjLG1CQUFtQmhtRyxHQUFHLEVBQUU5WixNQUFNO1FBQ3JDLElBQUlzYyxLQUFLeEMsSUFBSW5jLFFBQVE7UUFDckIsSUFBSXVoSCxLQUFLaEM7UUFDVCxJQUFJNTVDLGFBQWE7UUFDakJ4cEQsSUFBSTNiLFdBQVc7UUFDZixJQUFJNjBCLEtBQUsxVyxHQUFHbUMsV0FBVyxDQUFDLE9BQU87UUFFL0IscURBQXFEO1FBQ3JELDhFQUE4RTtRQUM5RSxnRkFBZ0Y7UUFDaEYsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ3VVLElBQUk7WUFDUCxPQUFPO1FBQ1Q7UUFDQSxJQUFJK2lGLEtBQUtnSixRQUFRemlHLEdBQUd1QixRQUFRLEVBQUUsVUFBVTdkO1FBQ3hDLElBQUlnMkcsS0FBSytJLFFBQVF6aUcsR0FBR3VCLFFBQVEsRUFBRSxVQUFVN2Q7UUFDeEMsSUFBSWlsRSxRQUFRODVDLFFBQVF6aUcsR0FBR3VCLFFBQVEsRUFBRSxjQUFjN2Q7UUFDL0MsSUFBSW8vRyxLQUFLdGxHLElBQUk0bUQsTUFBTSxDQUFDNEMsYUFBYSxpQkFBaUIzQyxPQUFPO1FBQ3pELElBQUkwK0MsS0FBS3ZsRyxJQUFJNG1ELE1BQU0sQ0FBQzRDLGFBQWEsaUJBQWlCM0MsT0FBTztRQUN6RCxJQUFJcG9DLE1BQU12RixHQUFHNTBCLEVBQUUsR0FBRzhnSCxLQUFLRTtRQUN2QixJQUFJM21GLE1BQU16RixHQUFHMzBCLEVBQUUsR0FBRzZnSCxLQUFLRTtRQUN2QixJQUFJNW1GLE1BQU14RixHQUFHMTBCLEVBQUUsR0FBRzRnSCxLQUFLRztRQUN2QixJQUFJM21GLE1BQU0xRixHQUFHejBCLEVBQUUsR0FBRzJnSCxLQUFLRztRQUN2QixJQUFJcDZDLE9BQU87WUFDVCxJQUFJbnVELE1BQU14WixLQUFLd1osR0FBRyxDQUFDbXVEO1lBQ25CLElBQUlsdUQsTUFBTXpaLEtBQUt5WixHQUFHLENBQUNrdUQ7WUFDbkIsSUFBSUcsU0FBUyxTQUFTQSxPQUFPdDRELENBQUMsRUFBRXlKLENBQUM7Z0JBQy9CekosSUFBSUEsSUFBSWlwRztnQkFDUngvRixJQUFJQSxJQUFJeS9GO2dCQUNSLE9BQU87b0JBQ0xscEcsR0FBR0EsSUFBSWdLLE1BQU1QLElBQUlRLE1BQU1nL0Y7b0JBQ3ZCeC9GLEdBQUd6SixJQUFJaUssTUFBTVIsSUFBSU8sTUFBTWsvRjtnQkFDekI7WUFDRjtZQUNBLE9BQU87Z0JBQUM1d0MsT0FBTzdzQyxLQUFLQztnQkFBTTRzQyxPQUFPM3NDLEtBQUtEO2dCQUFNNHNDLE9BQU8zc0MsS0FBS0M7Z0JBQU0wc0MsT0FBTzdzQyxLQUFLRzthQUFLO1FBQ2pGLE9BQU87WUFDTCxPQUFPO2dCQUFDO29CQUNONXJCLEdBQUd5ckI7b0JBQ0hoaUIsR0FBR2lpQjtnQkFDTDtnQkFBRztvQkFDRDFyQixHQUFHMnJCO29CQUNIbGlCLEdBQUdpaUI7Z0JBQ0w7Z0JBQUc7b0JBQ0QxckIsR0FBRzJyQjtvQkFDSGxpQixHQUFHbWlCO2dCQUNMO2dCQUFHO29CQUNENXJCLEdBQUd5ckI7b0JBQ0hoaUIsR0FBR21pQjtnQkFDTDthQUFFO1FBQ0o7SUFDRjtJQUNBLFNBQVNxbkYsaUJBQWlCOXRGLEVBQUUsRUFBRUMsRUFBRSxFQUFFcThDLEVBQUUsRUFBRUMsRUFBRTtRQUN0QyxTQUFTd3hDLElBQUl6bkgsQ0FBQyxFQUFFc0ksQ0FBQyxFQUFFaXRCLENBQUM7WUFDbEIsT0FBTyxDQUFDQSxFQUFFdlgsQ0FBQyxHQUFHaGUsRUFBRWdlLENBQUMsSUFBSzFWLENBQUFBLEVBQUVpTSxDQUFDLEdBQUd2VSxFQUFFdVUsQ0FBQyxJQUFJLENBQUNqTSxFQUFFMFYsQ0FBQyxHQUFHaGUsRUFBRWdlLENBQUMsSUFBS3VYLENBQUFBLEVBQUVoaEIsQ0FBQyxHQUFHdlUsRUFBRXVVLENBQUM7UUFDN0Q7UUFDQSxPQUFPa3pHLElBQUkvdEYsSUFBSXM4QyxJQUFJQyxRQUFRd3hDLElBQUk5dEYsSUFBSXE4QyxJQUFJQyxPQUFPd3hDLElBQUkvdEYsSUFBSUMsSUFBSXE4QyxRQUFReXhDLElBQUkvdEYsSUFBSUMsSUFBSXM4QztJQUNoRjtJQUNBLElBQUssSUFBSS8xRSxJQUFJLEdBQUdBLElBQUlvdEIsS0FBS3J0QixNQUFNLEVBQUVDLElBQUs7UUFDcEMsSUFBSXFoQixNQUFNK0wsSUFBSSxDQUFDcHRCLEVBQUU7UUFDakIsSUFBSXFoQixJQUFJb0UsTUFBTSxJQUFJO1lBQ2hCLElBQUl3RCxPQUFPNUg7WUFDWCxJQUFJbW1HLGFBQWF2K0YsS0FBS2cvQyxNQUFNLENBQUMsZUFBZThDLFFBQVEsS0FBSztZQUN6RCxJQUFJMDhDLG9CQUFvQngrRixLQUFLZy9DLE1BQU0sQ0FBQyxpQkFBaUI4QyxRQUFRO1lBQzdELElBQUkyOEMsd0JBQXdCeitGLEtBQUtnL0MsTUFBTSxDQUFDLHFCQUFxQjhDLFFBQVEsS0FBSztZQUMxRSxJQUFJMDhDLHNCQUFzQixRQUFRO2dCQUNoQztZQUNGO1lBQ0EsSUFBSXovQyxnQkFBZ0IsQ0FBQ3kvQyxzQkFBc0IsYUFBYUMscUJBQW9CLEtBQU1GO1lBQ2xGLElBQUlHLFNBQVMxK0YsS0FBS3ZqQixXQUFXLENBQUM7Z0JBQzVCMHBFLGNBQWM7Z0JBQ2RJLGNBQWM7Z0JBQ2R4SCxlQUFlQTtZQUNqQjtZQUNBLElBQUl5L0Msc0JBQXNCLFdBQVc7Z0JBQ25DLElBQUloakcsV0FBVztnQkFDZixJQUFJaWpHLHlCQUF5QkYsWUFBWTtvQkFDdkMsSUFBSUksa0JBQWtCUCxtQkFBbUJwK0Y7b0JBQ3pDLElBQUkyK0YsbUJBQW1CMytFLHVCQUF1QjIrRSxpQkFBaUJULGVBQWU7d0JBQzVFcG9HLElBQUl4YyxJQUFJLENBQUMwbUI7d0JBQ1R4RSxXQUFXO29CQUNiO2dCQUNGO2dCQUNBLElBQUksQ0FBQ0EsWUFBWWlYLHlCQUF5QndyRixPQUFPUyxTQUFTO29CQUN4RDVvRyxJQUFJeGMsSUFBSSxDQUFDMG1CO2dCQUNYO1lBQ0YsT0FBTyxJQUFJdytGLHNCQUFzQixXQUFXO2dCQUMxQyxJQUFJbnNGLHVCQUF1QjRyRixPQUFPUyxTQUFTO29CQUN6QyxJQUFJRSxhQUFhNStGLEtBQUt2akIsV0FBVyxDQUFDO3dCQUNoQzBwRSxjQUFjO3dCQUNkSSxjQUFjO3dCQUNkeEgsZUFBZTt3QkFDZnlJLG1CQUFtQjt3QkFDbkJDLHFCQUFxQjt3QkFDckJDLHFCQUFxQjtvQkFDdkI7b0JBQ0EsSUFBSW0zQyxrQkFBa0I7d0JBQUM7NEJBQ3JCenpHLEdBQUd3ekcsV0FBV2xpSCxFQUFFOzRCQUNoQm1ZLEdBQUcrcEcsV0FBV2hpSCxFQUFFO3dCQUNsQjt3QkFBRzs0QkFDRHdPLEdBQUd3ekcsV0FBV2ppSCxFQUFFOzRCQUNoQmtZLEdBQUcrcEcsV0FBV2hpSCxFQUFFO3dCQUNsQjt3QkFBRzs0QkFDRHdPLEdBQUd3ekcsV0FBV2ppSCxFQUFFOzRCQUNoQmtZLEdBQUcrcEcsV0FBVy9oSCxFQUFFO3dCQUNsQjt3QkFBRzs0QkFDRHVPLEdBQUd3ekcsV0FBV2xpSCxFQUFFOzRCQUNoQm1ZLEdBQUcrcEcsV0FBVy9oSCxFQUFFO3dCQUNsQjtxQkFBRTtvQkFFRixrREFBa0Q7b0JBQ2xELElBQUltakMsdUJBQXVCNitFLGlCQUFpQlgsZUFBZTt3QkFDekRwb0csSUFBSXhjLElBQUksQ0FBQzBtQjtvQkFDWCxPQUFPO3dCQUNMLGlEQUFpRDt3QkFDakQsSUFBSTgrRixtQkFBbUJWLG1CQUFtQnArRjt3QkFDMUMsSUFBSTgrRixvQkFBb0I5K0UsdUJBQXVCOCtFLGtCQUFrQlosZUFBZTs0QkFDOUVwb0csSUFBSXhjLElBQUksQ0FBQzBtQjt3QkFDWDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0YsT0FBTztZQUNMLElBQUlDLE9BQU83SDtZQUNYLElBQUl3QyxLQUFLcUYsS0FBS2hrQixRQUFRO1lBQ3RCLElBQUlnZ0gsS0FBS3JoRyxHQUFHdUIsUUFBUTtZQUNwQixJQUFJNGlHLG9CQUFvQjkrRixLQUFLKytDLE1BQU0sQ0FBQyxpQkFBaUI4QyxRQUFRO1lBQzdELElBQUlpOUMsc0JBQXNCLFFBQVE7Z0JBQ2hDO1lBQ0Y7WUFDQSxJQUFJQSxzQkFBc0IsV0FBVztnQkFDbkMsSUFBSTlDLEdBQUdwaUYsTUFBTSxJQUFJLFFBQVFvaUYsR0FBR25pRixNQUFNLElBQUksUUFBUSxDQUFDeEgsY0FBYzJyRixPQUFPaEMsR0FBR3BpRixNQUFNLEVBQUVvaUYsR0FBR25pRixNQUFNLEdBQUc7b0JBQ3pGO2dCQUNGO2dCQUNBLElBQUltaUYsR0FBRytDLElBQUksSUFBSSxRQUFRL0MsR0FBR2dELElBQUksSUFBSSxRQUFRLENBQUMzc0YsY0FBYzJyRixPQUFPaEMsR0FBRytDLElBQUksRUFBRS9DLEdBQUdnRCxJQUFJLEdBQUc7b0JBQ2pGO2dCQUNGO2dCQUNBLElBQUloRCxHQUFHTyxRQUFRLEtBQUssWUFBWVAsR0FBR08sUUFBUSxLQUFLLGlCQUFpQlAsR0FBR08sUUFBUSxLQUFLLFVBQVVQLEdBQUdPLFFBQVEsS0FBSyxjQUFjUCxHQUFHTyxRQUFRLEtBQUssY0FBY1AsR0FBR08sUUFBUSxLQUFLLFlBQVk7b0JBQ2pMLElBQUl0cEYsTUFBTXRZLEdBQUdRLE1BQU0sQ0FBQ3dyRCxTQUFTLElBQUloc0QsR0FBR1EsTUFBTSxDQUFDeXJELE9BQU8sSUFBSWpzRCxHQUFHUSxNQUFNLENBQUNzckQsV0FBVztvQkFDM0UsSUFBSXc0QyxZQUFZO29CQUNoQixJQUFLLElBQUk3bEgsSUFBSSxHQUFHQSxJQUFJNjVCLElBQUlwOEIsTUFBTSxFQUFFdUMsSUFBSzt3QkFDbkMsSUFBSSxDQUFDazVCLG1CQUFtQjByRixPQUFPL3FGLEdBQUcsQ0FBQzc1QixFQUFFLEdBQUc7NEJBQ3RDNmxILFlBQVk7NEJBQ1o7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsSUFBSUEsV0FBVzt3QkFDYnBwRyxJQUFJeGMsSUFBSSxDQUFDMm1CO29CQUNYO2dCQUNGLE9BQU8sSUFBSWc4RixHQUFHTyxRQUFRLEtBQUssWUFBWTtvQkFDckMxbUcsSUFBSXhjLElBQUksQ0FBQzJtQjtnQkFDWDtZQUNGLE9BQU8sSUFBSTgrRixzQkFBc0IsV0FBVztnQkFDMUMsSUFBSUksWUFBWTtnQkFFaEIsb0NBQW9DO2dCQUNwQyxJQUFJbEQsR0FBR3BpRixNQUFNLElBQUksUUFBUW9pRixHQUFHbmlGLE1BQU0sSUFBSSxRQUFRbWlGLEdBQUcrQyxJQUFJLElBQUksUUFBUS9DLEdBQUdnRCxJQUFJLElBQUksUUFBUzNzRixDQUFBQSxjQUFjMnJGLE9BQU9oQyxHQUFHcGlGLE1BQU0sRUFBRW9pRixHQUFHbmlGLE1BQU0sS0FBS3hILGNBQWMyckYsT0FBT2hDLEdBQUcrQyxJQUFJLEVBQUUvQyxHQUFHZ0QsSUFBSSxJQUFJO29CQUMxS25wRyxJQUFJeGMsSUFBSSxDQUFDMm1CO29CQUNUay9GLFlBQVk7Z0JBQ2QsT0FHSyxJQUFJLENBQUNBLGFBQWFsRCxHQUFHTyxRQUFRLEtBQUssWUFBWTtvQkFDakQsSUFBSTkxQyxjQUFjOXJELEdBQUdRLE1BQU0sQ0FBQ3NyRCxXQUFXO29CQUN2QyxJQUFLLElBQUkzbUQsS0FBSyxHQUFHQSxLQUFLMm1ELFlBQVk1dkUsTUFBTSxFQUFFaXBCLEtBQU07d0JBQzlDLElBQUl3UyxtQkFBbUIwckYsT0FBT3YzQyxXQUFXLENBQUMzbUQsR0FBRyxHQUFHOzRCQUM5Q2pLLElBQUl4YyxJQUFJLENBQUMybUI7NEJBQ1RrL0YsWUFBWTs0QkFDWjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFFQSw0REFBNEQ7Z0JBQzVELElBQUksQ0FBQ0EsV0FBVztvQkFDZCxJQUFJQyxPQUFPeGtHLEdBQUdRLE1BQU0sQ0FBQ3dyRCxTQUFTLElBQUloc0QsR0FBR1EsTUFBTSxDQUFDeXJELE9BQU8sSUFBSWpzRCxHQUFHUSxNQUFNLENBQUNzckQsV0FBVztvQkFFNUUsaUJBQWlCO29CQUNqQixJQUFJLENBQUMsQ0FBQzA0QyxRQUFRQSxLQUFLdG9ILE1BQU0sR0FBRyxNQUFNbWxILEdBQUdPLFFBQVEsS0FBSyxZQUFZO3dCQUM1RCxJQUFJUCxHQUFHcGlGLE1BQU0sSUFBSSxRQUFRb2lGLEdBQUduaUYsTUFBTSxJQUFJLFFBQVFtaUYsR0FBRytDLElBQUksSUFBSSxRQUFRL0MsR0FBR2dELElBQUksSUFBSSxNQUFNOzRCQUNoRkcsT0FBTztnQ0FBQztvQ0FDTmgwRyxHQUFHNndHLEdBQUdwaUYsTUFBTTtvQ0FDWmhsQixHQUFHb25HLEdBQUduaUYsTUFBTTtnQ0FDZDtnQ0FBRztvQ0FDRDF1QixHQUFHNndHLEdBQUcrQyxJQUFJO29DQUNWbnFHLEdBQUdvbkcsR0FBR2dELElBQUk7Z0NBQ1o7NkJBQUU7d0JBQ0o7b0JBQ0Y7b0JBQ0EsSUFBSSxDQUFDRyxRQUFRQSxLQUFLdG9ILE1BQU0sR0FBRyxHQUFHO29CQUM5QixJQUFLLElBQUk2b0IsTUFBTSxHQUFHQSxNQUFNeS9GLEtBQUt0b0gsTUFBTSxHQUFHLEdBQUc2b0IsTUFBTzt3QkFDOUMsSUFBSTAvRixXQUFXRCxJQUFJLENBQUN6L0YsSUFBSTt3QkFDeEIsSUFBSTIvRixTQUFTRixJQUFJLENBQUN6L0YsTUFBTSxFQUFFO3dCQUMxQixJQUFLLElBQUl4Z0IsSUFBSSxHQUFHQSxJQUFJZy9HLFNBQVNybkgsTUFBTSxFQUFFcUksSUFBSzs0QkFDeEMsSUFBSW9nSCxjQUFjOWxILGVBQWUwa0gsUUFBUSxDQUFDaC9HLEVBQUUsRUFBRSxJQUM1Q3FnSCxXQUFXRCxXQUFXLENBQUMsRUFBRSxFQUN6QkUsU0FBU0YsV0FBVyxDQUFDLEVBQUU7NEJBQ3pCLElBQUlsQixpQkFBaUJnQixVQUFVQyxRQUFRRSxVQUFVQyxTQUFTO2dDQUN4RDNwRyxJQUFJeGMsSUFBSSxDQUFDMm1CO2dDQUNUay9GLFlBQVk7Z0NBQ1o7NEJBQ0Y7d0JBQ0Y7d0JBQ0EsSUFBSUEsV0FBVztvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPcnBHO0FBQ1Q7QUFFQSxJQUFJNHBHLFFBQVEsQ0FBQztBQUNiQSxNQUFNQyxvQkFBb0IsR0FBRyxTQUFVMS9GLElBQUk7SUFDekMsSUFBSWc4RixLQUFLaDhGLEtBQUtoa0IsUUFBUSxDQUFDa2dCLFFBQVE7SUFDL0IsSUFBSXlqRyxhQUFhM0QsR0FBR08sUUFBUSxLQUFLO0lBQ2pDLElBQUlxRCxXQUFXNUQsR0FBR08sUUFBUSxLQUFLO0lBQy9CLElBQUlzRCxnQkFBZ0I3RCxHQUFHTyxRQUFRLEtBQUs7SUFDcEMsSUFBSXVELGFBQWE5RCxHQUFHTyxRQUFRLEtBQUs7SUFDakMsSUFBSXpNLGFBQWFrTSxHQUFHTyxRQUFRLEtBQUs7SUFDakMsSUFBSXdELFNBQVMvRCxHQUFHTyxRQUFRLEtBQUs7SUFFN0IseURBQXlEO0lBQ3pELElBQUl0c0YsT0FBT0M7SUFDWCxJQUFJMEosUUFBUUMsUUFBUWtsRixNQUFNQyxNQUFNejlDLE1BQU1DO0lBQ3RDLElBQUltK0MsWUFBWTtRQUNkL2xGLFNBQVNvaUYsR0FBR3YxQyxXQUFXLENBQUMsRUFBRTtRQUMxQjVzQyxTQUFTbWlGLEdBQUd2MUMsV0FBVyxDQUFDLEVBQUU7UUFDMUJzNEMsT0FBTy9DLEdBQUd2MUMsV0FBVyxDQUFDLEVBQUU7UUFDeEJ1NEMsT0FBT2hELEdBQUd2MUMsV0FBVyxDQUFDLEVBQUU7SUFDMUIsT0FBTztRQUNMN3NDLFNBQVNvaUYsR0FBR1csV0FBVztRQUN2QjlpRixTQUFTbWlGLEdBQUdZLFdBQVc7UUFDdkJtQyxPQUFPL0MsR0FBR2MsU0FBUztRQUNuQmtDLE9BQU9oRCxHQUFHZSxTQUFTO0lBQ3JCO0lBQ0F4N0MsT0FBT3k2QyxHQUFHejZDLElBQUk7SUFDZEMsT0FBT3c2QyxHQUFHeDZDLElBQUk7SUFFZCxTQUFTO0lBQ1QsRUFBRTtJQUVGLElBQUlzK0MsWUFBWTtRQUNkN3ZGLFFBQVEySixTQUFTb2lGLEdBQUdnRSxNQUFNLENBQUMsRUFBRTtRQUM3Qjl2RixRQUFRMkosU0FBU21pRixHQUFHZ0UsTUFBTSxDQUFDLEVBQUU7SUFDL0IsT0FBTyxJQUFJSCxpQkFBaUIvUCxjQUFjaVEsVUFBVUgsVUFBVTtRQUM1RCxJQUFJM3NGLE1BQU0rb0YsR0FBR1EsTUFBTTtRQUNuQixJQUFJeUQsS0FBS3J2RixVQUFVcUMsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRTtRQUMzQyxJQUFJaXRGLEtBQUt0dkYsVUFBVXFDLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUU7UUFDM0NoRCxRQUFRMkosU0FBU3FtRjtRQUNqQi92RixRQUFRMkosU0FBU3FtRjtJQUNuQixPQUFPO1FBQ0xqd0YsUUFBUTJKLFNBQVMybkM7UUFDakJyeEMsUUFBUTJKLFNBQVMybkM7SUFDbkI7SUFDQXc2QyxHQUFHYSxhQUFhLEdBQUc3c0YsaUJBQWlCQyxPQUFPQztJQUUzQyxhQUFhO0lBQ2IsRUFBRTtJQUVGLElBQUlxeEMsT0FBT3k2QyxHQUFHejZDLElBQUk7SUFDbEIsSUFBSUMsT0FBT3c2QyxHQUFHeDZDLElBQUk7SUFDbEIsSUFBSW0rQyxZQUFZO1FBQ2RwK0MsT0FBTyxDQUFDM25DLFNBQVNtbEYsSUFBRyxJQUFLO1FBQ3pCdjlDLE9BQU8sQ0FBQzNuQyxTQUFTbWxGLElBQUcsSUFBSztJQUMzQjtJQUNBL3VGLFFBQVE4dUYsT0FBT25sRjtJQUNmMUosUUFBUTh1RixPQUFPbmxGO0lBQ2YsSUFBSWltRixZQUFZO1FBQ2QsSUFBSTdzRixNQUFNK29GLEdBQUdRLE1BQU07UUFDbkIsSUFBSXZwRixJQUFJcDhCLE1BQU0sR0FBRyxJQUFJLE1BQU0sR0FBRztZQUM1QixJQUFJc3BILEtBQUtsdEYsSUFBSXA4QixNQUFNLEdBQUc7WUFDdEIsSUFBSXVwSCxLQUFLRCxLQUFLO1lBQ2Rsd0YsUUFBUWdELEdBQUcsQ0FBQ2t0RixHQUFHLEdBQUdsdEYsR0FBRyxDQUFDbXRGLEdBQUc7WUFDekJsd0YsUUFBUStDLEdBQUcsQ0FBQ2t0RixLQUFLLEVBQUUsR0FBR2x0RixHQUFHLENBQUNtdEYsS0FBSyxFQUFFO1FBQ25DLE9BQU8sSUFBSXBFLEdBQUdxRSxPQUFPLEVBQUU7WUFDckJwd0YsUUFBUStyRixHQUFHc0UsU0FBUyxDQUFDLEVBQUU7WUFDdkJwd0YsUUFBUSxDQUFDOHJGLEdBQUdzRSxTQUFTLENBQUMsRUFBRTtRQUMxQixPQUFPO1lBQ0wsSUFBSUgsS0FBS2x0RixJQUFJcDhCLE1BQU0sR0FBRyxJQUFJO1lBQzFCLElBQUl1cEgsS0FBS0QsS0FBSztZQUNkbHdGLFFBQVFnRCxHQUFHLENBQUNrdEYsR0FBRyxHQUFHbHRGLEdBQUcsQ0FBQ210RixHQUFHO1lBQ3pCbHdGLFFBQVErQyxHQUFHLENBQUNrdEYsS0FBSyxFQUFFLEdBQUdsdEYsR0FBRyxDQUFDbXRGLEtBQUssRUFBRTtRQUNuQztJQUNGLE9BQU8sSUFBSVAsaUJBQWlCL1AsY0FBY2lRLFFBQVE7UUFDaEQsSUFBSTlzRixNQUFNK29GLEdBQUdRLE1BQU07UUFDbkIsSUFBSStELE9BQU92RSxHQUFHd0UsT0FBTztRQUNyQixJQUFJQyxNQUFNQztRQUNWLElBQUlDLE1BQU1DO1FBQ1YsSUFBSUwsS0FBSzFwSCxNQUFNLEdBQUcsSUFBSSxNQUFNLEdBQUc7WUFDN0IsSUFBSWc2QixLQUFLb0MsSUFBSXA4QixNQUFNLEdBQUcsSUFBSSxHQUFHLFVBQVU7WUFDdkMsSUFBSWdxSCxLQUFLaHdGLEtBQUs7WUFDZCxJQUFJUCxLQUFLdXdGLEtBQUs7WUFDZEosT0FBTzd2RixVQUFVcUMsR0FBRyxDQUFDcEMsR0FBRyxFQUFFb0MsR0FBRyxDQUFDNHRGLEdBQUcsRUFBRTV0RixHQUFHLENBQUMzQyxHQUFHLEVBQUU7WUFDNUNvd0YsT0FBTzl2RixVQUFVcUMsR0FBRyxDQUFDcEMsS0FBSyxFQUFFLEVBQUVvQyxHQUFHLENBQUM0dEYsS0FBSyxFQUFFLEVBQUU1dEYsR0FBRyxDQUFDM0MsS0FBSyxFQUFFLEVBQUU7WUFDeERxd0YsT0FBTy92RixVQUFVcUMsR0FBRyxDQUFDcEMsR0FBRyxFQUFFb0MsR0FBRyxDQUFDNHRGLEdBQUcsRUFBRTV0RixHQUFHLENBQUMzQyxHQUFHLEVBQUU7WUFDNUNzd0YsT0FBT2h3RixVQUFVcUMsR0FBRyxDQUFDcEMsS0FBSyxFQUFFLEVBQUVvQyxHQUFHLENBQUM0dEYsS0FBSyxFQUFFLEVBQUU1dEYsR0FBRyxDQUFDM0MsS0FBSyxFQUFFLEVBQUU7UUFDMUQsT0FBTztZQUNMLElBQUl1d0YsS0FBSzV0RixJQUFJcDhCLE1BQU0sR0FBRyxJQUFJLEdBQUcsUUFBUTtZQUNyQyxJQUFJZzZCLEtBQUtnd0YsS0FBSyxHQUFHLFVBQVU7WUFDM0IsSUFBSXZ3RixLQUFLdXdGLEtBQUssR0FBRyxRQUFRO1lBRXpCSixPQUFPN3ZGLFVBQVVxQyxHQUFHLENBQUNwQyxHQUFHLEVBQUVvQyxHQUFHLENBQUM0dEYsR0FBRyxFQUFFNXRGLEdBQUcsQ0FBQzNDLEdBQUcsRUFBRTtZQUM1Q293RixPQUFPOXZGLFVBQVVxQyxHQUFHLENBQUNwQyxLQUFLLEVBQUUsRUFBRW9DLEdBQUcsQ0FBQzR0RixLQUFLLEVBQUUsRUFBRTV0RixHQUFHLENBQUMzQyxLQUFLLEVBQUUsRUFBRTtZQUN4RHF3RixPQUFPL3ZGLFVBQVVxQyxHQUFHLENBQUNwQyxHQUFHLEVBQUVvQyxHQUFHLENBQUM0dEYsR0FBRyxFQUFFNXRGLEdBQUcsQ0FBQzNDLEdBQUcsRUFBRTtZQUM1Q3N3RixPQUFPaHdGLFVBQVVxQyxHQUFHLENBQUNwQyxLQUFLLEVBQUUsRUFBRW9DLEdBQUcsQ0FBQzR0RixLQUFLLEVBQUUsRUFBRTV0RixHQUFHLENBQUMzQyxLQUFLLEVBQUUsRUFBRTtRQUMxRDtRQUNBTCxRQUFRMHdGLE9BQU9GO1FBQ2Z2d0YsUUFBUTB3RixPQUFPRjtJQUNqQjtJQUNBMUUsR0FBR2tCLGdCQUFnQixHQUFHbHRGLGlCQUFpQkMsT0FBT0M7SUFDOUM4ckYsR0FBRzhFLFFBQVEsR0FBRzd3RjtJQUNkK3JGLEdBQUcrRSxRQUFRLEdBQUc3d0Y7SUFFZCxhQUFhO0lBQ2IsRUFBRTtJQUVGRCxTQUFTLENBQUM7SUFDVkMsU0FBUyxDQUFDO0lBQ1YsSUFBSTR2RixZQUFZO1FBQ2QsSUFBSTdzRixNQUFNK29GLEdBQUdRLE1BQU07UUFDbkIsSUFBSXZwRixJQUFJcDhCLE1BQU0sR0FBRyxJQUFJLE1BQU07YUFBVSxJQUFJLENBQUNtbEgsR0FBR3FFLE9BQU8sRUFBRTtZQUNwRCxJQUFJRixLQUFLbHRGLElBQUlwOEIsTUFBTSxHQUFHLElBQUk7WUFDMUIsSUFBSW1xSCxLQUFLYixLQUFLO1lBQ2Rsd0YsUUFBUSxDQUFFZ0QsQ0FBQUEsR0FBRyxDQUFDK3RGLEdBQUcsR0FBRy90RixHQUFHLENBQUNrdEYsR0FBRztZQUMzQmp3RixRQUFRLENBQUUrQyxDQUFBQSxHQUFHLENBQUMrdEYsS0FBSyxFQUFFLEdBQUcvdEYsR0FBRyxDQUFDa3RGLEtBQUssRUFBRTtRQUNyQztJQUNGO0lBQ0FuRSxHQUFHaUIsZ0JBQWdCLEdBQUdqdEYsaUJBQWlCQyxPQUFPQztJQUU5QyxTQUFTO0lBQ1QsRUFBRTtJQUVGLElBQUk0dkYsWUFBWTtRQUNkN3ZGLFFBQVE4dUYsT0FBTy9DLEdBQUdnRSxNQUFNLENBQUNoRSxHQUFHZ0UsTUFBTSxDQUFDbnBILE1BQU0sR0FBRyxFQUFFO1FBQzlDcTVCLFFBQVE4dUYsT0FBT2hELEdBQUdnRSxNQUFNLENBQUNoRSxHQUFHZ0UsTUFBTSxDQUFDbnBILE1BQU0sR0FBRyxFQUFFO0lBQ2hELE9BQU8sSUFBSWdwSCxpQkFBaUIvUCxjQUFjaVEsVUFBVUgsVUFBVTtRQUM1RCxJQUFJM3NGLE1BQU0rb0YsR0FBR1EsTUFBTTtRQUNuQixJQUFJcmpILElBQUk4NUIsSUFBSXA4QixNQUFNO1FBQ2xCLElBQUlvcEgsS0FBS3J2RixVQUFVcUMsR0FBRyxDQUFDOTVCLElBQUksRUFBRSxFQUFFODVCLEdBQUcsQ0FBQzk1QixJQUFJLEVBQUUsRUFBRTg1QixHQUFHLENBQUM5NUIsSUFBSSxFQUFFLEVBQUU7UUFDdkQsSUFBSSttSCxLQUFLdHZGLFVBQVVxQyxHQUFHLENBQUM5NUIsSUFBSSxFQUFFLEVBQUU4NUIsR0FBRyxDQUFDOTVCLElBQUksRUFBRSxFQUFFODVCLEdBQUcsQ0FBQzk1QixJQUFJLEVBQUUsRUFBRTtRQUN2RDgyQixRQUFROHVGLE9BQU9rQjtRQUNmL3ZGLFFBQVE4dUYsT0FBT2tCO0lBQ2pCLE9BQU87UUFDTGp3RixRQUFROHVGLE9BQU94OUM7UUFDZnJ4QyxRQUFROHVGLE9BQU94OUM7SUFDakI7SUFDQXc2QyxHQUFHZ0IsYUFBYSxHQUFHaHRGLGlCQUFpQkMsT0FBT0M7QUFDN0M7QUFDQXV2RixNQUFNakcsYUFBYSxHQUFHaUcsTUFBTXdCLGNBQWMsR0FBRyxTQUFVbkosU0FBUyxFQUFFamxGLEtBQUs7SUFDckUsSUFBSWoxQixRQUFRLElBQUksQ0FBQ3NqSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlLElBQUksQ0FBQztJQUM1RCxJQUFJNXpCLFlBQVkxdkYsS0FBSyxDQUFDazZHLFlBQVksT0FBT2psRixNQUFNO0lBQy9DLElBQUl5NkQsV0FBVztRQUNiLE9BQU9BO0lBQ1Q7SUFDQUEsWUFBWTN4RixLQUFLNlUsR0FBRyxDQUFDN1UsS0FBSzZ4QixHQUFHLENBQUNzcUYsWUFBWSxPQUFPLE1BQU0sTUFBTWpsRjtJQUM3RGoxQixLQUFLLENBQUNrNkcsWUFBWSxPQUFPamxGLE1BQU0sR0FBR3k2RDtJQUNsQyxPQUFPQTtBQUNUO0FBRUE7O0NBRUMsR0FFRCw0RkFBNEY7QUFDNUYsSUFBSW5pRixHQUNGeUosR0FDQXV6QixLQUFLLENBQUMsR0FDTkMsS0FBSyxDQUFDLEdBQ04rNEUsTUFDQUMsUUFDQUMsY0FDQUMsZUFDQW5vRixPQUNBb29GLFdBQ0FDLFNBQ0FDLFFBQ0FqdEYsUUFDQWt0RjtBQUNGLElBQUk5bkYsUUFBUUMsUUFBUUMsT0FBT0M7QUFDM0IsSUFBSTRuRjtBQUVKLGdFQUFnRTtBQUNoRSxJQUFJQyxRQUFRLFNBQVNBLE1BQU14aEgsQ0FBQyxFQUFFeWhILEVBQUUsRUFBRTdqSCxDQUFDO0lBQ2pDQSxFQUFFbU4sQ0FBQyxHQUFHMDJHLEdBQUcxMkcsQ0FBQyxHQUFHL0ssRUFBRStLLENBQUM7SUFDaEJuTixFQUFFNFcsQ0FBQyxHQUFHaXRHLEdBQUdqdEcsQ0FBQyxHQUFHeFUsRUFBRXdVLENBQUM7SUFDaEI1VyxFQUFFNnhCLEdBQUcsR0FBR2wwQixLQUFLMndCLElBQUksQ0FBQ3R1QixFQUFFbU4sQ0FBQyxHQUFHbk4sRUFBRW1OLENBQUMsR0FBR25OLEVBQUU0VyxDQUFDLEdBQUc1VyxFQUFFNFcsQ0FBQztJQUN2QzVXLEVBQUU4akgsRUFBRSxHQUFHOWpILEVBQUVtTixDQUFDLEdBQUduTixFQUFFNnhCLEdBQUc7SUFDbEI3eEIsRUFBRStqSCxFQUFFLEdBQUcvakgsRUFBRTRXLENBQUMsR0FBRzVXLEVBQUU2eEIsR0FBRztJQUNsQjd4QixFQUFFZ2tILEdBQUcsR0FBR3JtSCxLQUFLdzBCLEtBQUssQ0FBQ255QixFQUFFK2pILEVBQUUsRUFBRS9qSCxFQUFFOGpILEVBQUU7QUFDL0I7QUFDQSxJQUFJRyxZQUFZLFNBQVNBLFVBQVVDLFNBQVMsRUFBRUMsU0FBUztJQUNyREEsVUFBVWgzRyxDQUFDLEdBQUcrMkcsVUFBVS8yRyxDQUFDLEdBQUcsQ0FBQztJQUM3QmczRyxVQUFVdnRHLENBQUMsR0FBR3N0RyxVQUFVdHRHLENBQUMsR0FBRyxDQUFDO0lBQzdCdXRHLFVBQVVMLEVBQUUsR0FBR0ksVUFBVUosRUFBRSxHQUFHLENBQUM7SUFDL0JLLFVBQVVKLEVBQUUsR0FBR0csVUFBVUgsRUFBRSxHQUFHLENBQUM7SUFDL0JJLFVBQVVILEdBQUcsR0FBR0UsVUFBVUYsR0FBRyxHQUFHLElBQUksQ0FBRXJtSCxDQUFBQSxLQUFLc1osRUFBRSxHQUFHaXRHLFVBQVVGLEdBQUcsSUFBSXJtSCxLQUFLc1osRUFBRSxHQUFHaXRHLFVBQVVGLEdBQUc7QUFDMUY7QUFDQSxJQUFJSSxnQkFBZ0IsU0FBU0EsY0FBY0MsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxXQUFXO0lBQ3ZHLDJDQUEyQztJQUMzQyxTQUFTO0lBQ1RKLGtCQUFrQlYsWUFBWUMsTUFBTVUsY0FBY0QsZUFBZWw2RSxNQUFNODVFLFVBQVU3NUUsSUFBSUQsS0FBSyx5RUFBeUU7SUFDbkt5NUUsTUFBTVUsY0FBY0MsV0FBV242RTtJQUMvQis0RSxPQUFPaDVFLEdBQUcyNUUsRUFBRSxHQUFHMTVFLEdBQUcyNUUsRUFBRSxHQUFHNTVFLEdBQUc0NUUsRUFBRSxHQUFHMzVFLEdBQUcwNUUsRUFBRTtJQUNwQ1YsU0FBU2o1RSxHQUFHMjVFLEVBQUUsR0FBRzE1RSxHQUFHMDVFLEVBQUUsR0FBRzM1RSxHQUFHNDVFLEVBQUUsR0FBRyxDQUFDMzVFLEdBQUcyNUUsRUFBRTtJQUN2QzVvRixRQUFReDlCLEtBQUsrbUgsSUFBSSxDQUFDL21ILEtBQUs2VSxHQUFHLENBQUMsQ0FBQyxHQUFHN1UsS0FBSytVLEdBQUcsQ0FBQyxHQUFHeXdHO0lBQzNDLElBQUl4bEgsS0FBSzIzQixHQUFHLENBQUM2RixTQUFTLE1BQU07UUFDMUJodUIsSUFBSW0zRyxhQUFhbjNHLENBQUM7UUFDbEJ5SixJQUFJMHRHLGFBQWExdEcsQ0FBQztRQUNsQjRzRyxVQUFVaHRGLFNBQVM7UUFDbkI7SUFDRjtJQUNBLDJDQUEyQztJQUMzQzZzRixlQUFlO0lBQ2ZDLGdCQUFnQjtJQUNoQixJQUFJRixTQUFTLEdBQUc7UUFDZCxJQUFJam9GLFFBQVEsR0FBRztZQUNiQSxRQUFReDlCLEtBQUtzWixFQUFFLEdBQUdra0I7UUFDcEIsT0FBTztZQUNMQSxRQUFReDlCLEtBQUtzWixFQUFFLEdBQUdra0I7WUFDbEJrb0YsZUFBZSxDQUFDO1lBQ2hCQyxnQkFBZ0I7UUFDbEI7SUFDRixPQUFPO1FBQ0wsSUFBSW5vRixRQUFRLEdBQUc7WUFDYmtvRixlQUFlLENBQUM7WUFDaEJDLGdCQUFnQjtRQUNsQjtJQUNGO0lBQ0EsSUFBSWdCLGFBQWE5dEYsTUFBTSxLQUFLNTZCLFdBQVc7UUFDckM0NkIsU0FBUzh0RixhQUFhOXRGLE1BQU07SUFDOUIsT0FBTztRQUNMQSxTQUFTZ3VGO0lBQ1g7SUFDQSwyQ0FBMkM7SUFDM0MsU0FBUztJQUNUakIsWUFBWXBvRixRQUFRO0lBQ3BCLDJDQUEyQztJQUUzQ3VvRixRQUFRL2xILEtBQUsrVSxHQUFHLENBQUN5M0IsR0FBR3RZLEdBQUcsR0FBRyxHQUFHdVksR0FBR3ZZLEdBQUcsR0FBRztJQUN0QyxJQUFJNHlGLGFBQWE7UUFDZiwyQ0FBMkM7UUFDM0MsU0FBUztRQUNUaEIsU0FBUzlsSCxLQUFLMjNCLEdBQUcsQ0FBQzMzQixLQUFLd1osR0FBRyxDQUFDb3NHLGFBQWEvc0YsU0FBUzc0QixLQUFLeVosR0FBRyxDQUFDbXNHO1FBRTFELDJDQUEyQztRQUMzQyxpQkFBaUI7UUFDakIsSUFBSUUsU0FBU0MsT0FBTztZQUNsQkQsU0FBU0M7WUFDVEYsVUFBVTdsSCxLQUFLMjNCLEdBQUcsQ0FBQ211RixTQUFTOWxILEtBQUt5WixHQUFHLENBQUNtc0csYUFBYTVsSCxLQUFLd1osR0FBRyxDQUFDb3NHO1FBQzdELE9BQU87WUFDTEMsVUFBVWh0RjtRQUNaO0lBQ0YsT0FBTztRQUNMaXRGLFNBQVM5bEgsS0FBSytVLEdBQUcsQ0FBQ2d4RyxPQUFPbHRGO1FBQ3pCZ3RGLFVBQVU3bEgsS0FBSzIzQixHQUFHLENBQUNtdUYsU0FBUzlsSCxLQUFLeVosR0FBRyxDQUFDbXNHLGFBQWE1bEgsS0FBS3daLEdBQUcsQ0FBQ29zRztJQUM3RDtJQUNBLDJDQUEyQztJQUUzQywyQ0FBMkM7SUFDM0MsU0FBUztJQUNUem5GLFFBQVF3b0YsYUFBYW4zRyxDQUFDLEdBQUdpOUIsR0FBRzA1RSxFQUFFLEdBQUdMO0lBQ2pDMW5GLFFBQVF1b0YsYUFBYTF0RyxDQUFDLEdBQUd3ekIsR0FBRzI1RSxFQUFFLEdBQUdOO0lBQ2pDLDJDQUEyQztJQUMzQyxTQUFTO0lBQ1R0MkcsSUFBSTJ1QixRQUFRc08sR0FBRzI1RSxFQUFFLEdBQUdQLFVBQVVIO0lBQzlCenNHLElBQUltbEIsUUFBUXFPLEdBQUcwNUUsRUFBRSxHQUFHTixVQUFVSDtJQUM5QiwyQ0FBMkM7SUFDM0MsNENBQTRDO0lBQzVDem5GLFNBQVMwb0YsYUFBYW4zRyxDQUFDLEdBQUdnOUIsR0FBRzI1RSxFQUFFLEdBQUdMO0lBQ2xDNW5GLFNBQVN5b0YsYUFBYTF0RyxDQUFDLEdBQUd1ekIsR0FBRzQ1RSxFQUFFLEdBQUdOO0lBRWxDLGdFQUFnRTtJQUNoRUUsWUFBWVc7QUFDZDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0ssd0JBQXdCQyxHQUFHLEVBQUVDLFdBQVc7SUFDL0MsSUFBSUEsWUFBWXJ1RixNQUFNLEtBQUssR0FBR291RixJQUFJRSxNQUFNLENBQUNELFlBQVk1b0YsRUFBRSxFQUFFNG9GLFlBQVl6b0csRUFBRTtTQUFPd29HLElBQUlHLEdBQUcsQ0FBQ0YsWUFBWTVvRixFQUFFLEVBQUU0b0YsWUFBWXpvRyxFQUFFLEVBQUV5b0csWUFBWXJ1RixNQUFNLEVBQUVxdUYsWUFBWXZqRixVQUFVLEVBQUV1akYsWUFBWUcsUUFBUSxFQUFFSCxZQUFZSSxnQkFBZ0I7QUFDdE47QUFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVNDLGVBQWViLGFBQWEsRUFBRUMsWUFBWSxFQUFFQyxTQUFTLEVBQUVDLFNBQVM7SUFDdkUsSUFBSUMsY0FBY3RsSCxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDdEYsSUFBSXFsSCxjQUFjLEtBQUtGLGFBQWE5dEYsTUFBTSxLQUFLLEdBQUcsT0FBTztRQUN2RHlGLElBQUlxb0YsYUFBYW4zRyxDQUFDO1FBQ2xCaVAsSUFBSWtvRyxhQUFhMXRHLENBQUM7UUFDbEI0ZixRQUFRO1FBQ1JvRixRQUFRMG9GLGFBQWFuM0csQ0FBQztRQUN0QjB1QixRQUFReW9GLGFBQWExdEcsQ0FBQztRQUN0QmtsQixPQUFPd29GLGFBQWFuM0csQ0FBQztRQUNyQjR1QixPQUFPdW9GLGFBQWExdEcsQ0FBQztRQUNyQjBxQixZQUFZMWxDO1FBQ1pvcEgsVUFBVXBwSDtRQUNWcXBILGtCQUFrQnJwSDtJQUNwQjtJQUNBd29ILGNBQWNDLGVBQWVDLGNBQWNDLFdBQVdDLFdBQVdDO0lBQ2pFLE9BQU87UUFDTHhvRixJQUFJOXVCO1FBQ0ppUCxJQUFJeEY7UUFDSjRmLFFBQVFndEY7UUFDUjVuRixRQUFRQTtRQUNSQyxRQUFRQTtRQUNSQyxPQUFPQTtRQUNQQyxPQUFPQTtRQUNQdUYsWUFBWTZJLEdBQUc2NUUsR0FBRyxHQUFHcm1ILEtBQUtzWixFQUFFLEdBQUcsSUFBSW9zRztRQUNuQzJCLFVBQVU1NkUsR0FBRzQ1RSxHQUFHLEdBQUdybUgsS0FBS3NaLEVBQUUsR0FBRyxJQUFJb3NHO1FBQ2pDNEIsa0JBQWtCM0I7SUFDcEI7QUFDRjtBQUVBLElBQUk2QixtQ0FBbUM7QUFDdkMsSUFBSUMscUNBQXFDem5ILEtBQUsyd0IsSUFBSSxDQUFDLElBQUk2MkY7QUFDdkQsSUFBSUUsUUFBUSxDQUFDO0FBQ2JBLE1BQU1DLGVBQWUsR0FBRyxTQUFVdGpHLElBQUksRUFBRXVqRyxRQUFRO0lBQzlDLElBQUlDLFNBQVNELFNBQVNDLE1BQU0sRUFDMUJDLGtCQUFrQkYsU0FBU0UsZUFBZSxFQUMxQ0Msb0JBQW9CSCxTQUFTRyxpQkFBaUI7SUFDaEQsSUFBSUM7SUFFSix3RUFBd0U7SUFDeEUsSUFBSUMsY0FBYzVqRyxLQUFLKytDLE1BQU0sQ0FBQztJQUM5QixJQUFJOGtELGNBQWM3akcsS0FBSysrQyxNQUFNLENBQUM7SUFDOUIsSUFBSStrRCxtQkFBbUJGLFlBQVkvakQsS0FBSyxJQUFJLFFBQVFna0QsWUFBWWhrRCxLQUFLLElBQUk7SUFDekUsSUFBSWtrRCwwQkFBMEIsU0FBU0Esd0JBQXdCdG5ILEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUU7UUFDM0UsSUFBSTh6QixLQUFLOXpCLEtBQUtEO1FBQ2QsSUFBSTh6QixLQUFLL3pCLEtBQUtEO1FBQ2QsSUFBSXRELElBQUl3QyxLQUFLMndCLElBQUksQ0FBQ21FLEtBQUtBLEtBQUtDLEtBQUtBO1FBQ2pDLE9BQU87WUFDTHZsQixHQUFHLENBQUN1bEIsS0FBS3YzQjtZQUNUeWIsR0FBRzZiLEtBQUt0M0I7UUFDVjtJQUNGO0lBQ0EsSUFBSWtsRyxnQkFBZ0JyK0UsS0FBSysrQyxNQUFNLENBQUMsa0JBQWtCdG1FLEtBQUs7SUFDdkQsT0FBUTRsRztRQUNOLEtBQUs7WUFDSHNsQixXQUFXSDtZQUNYO1FBQ0YsS0FBSztZQUNIRyxXQUFXRjtZQUNYO1FBQ0YsS0FBSztZQUNIO2dCQUNFLElBQUlLLGtCQUFrQjtvQkFDcEIsSUFBSUUsd0JBQXdCLElBQUksQ0FBQ0MsZUFBZSxDQUFDamtHLEtBQUt2RixNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUVtcEcsY0FDakVNLHlCQUF5QjFxSCxlQUFld3FILHVCQUF1QixJQUMvRHZuSCxLQUFLeW5ILHNCQUFzQixDQUFDLEVBQUUsRUFDOUJ2bkgsS0FBS3VuSCxzQkFBc0IsQ0FBQyxFQUFFO29CQUNoQyxJQUFJQyx5QkFBeUIsSUFBSSxDQUFDRixlQUFlLENBQUNqa0csS0FBS3RGLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRW1wRyxjQUNsRU8seUJBQXlCNXFILGVBQWUycUgsd0JBQXdCLElBQ2hFem5ILEtBQUswbkgsc0JBQXNCLENBQUMsRUFBRSxFQUM5QnhuSCxLQUFLd25ILHNCQUFzQixDQUFDLEVBQUU7b0JBQ2hDLElBQUlDLFNBQVM7d0JBQ1g1bkgsSUFBSUE7d0JBQ0pFLElBQUlBO3dCQUNKRCxJQUFJQTt3QkFDSkUsSUFBSUE7b0JBQ047b0JBQ0E4bUgsb0JBQW9CSyx3QkFBd0J0bkgsSUFBSUUsSUFBSUQsSUFBSUU7b0JBQ3hEK21ILFdBQVdVO2dCQUNiLE9BQU87b0JBQ0xqdUcsS0FBSyxRQUFRd0wsTUFBTSxDQUFDNUIsS0FBS25CLEVBQUUsSUFBSTtvQkFDL0I4a0csV0FBV0YsaUJBQWlCLGtCQUFrQjtnQkFDaEQ7Z0JBQ0E7WUFDRjtJQUNKO0lBQ0EsT0FBTztRQUNMRSxVQUFVQTtRQUNWRCxtQkFBbUJBO0lBQ3JCO0FBQ0Y7QUFDQUwsTUFBTWlCLGtCQUFrQixHQUFHLFNBQVVsb0csS0FBSztJQUN4QyxJQUFLLElBQUloakIsSUFBSSxHQUFHQSxJQUFJZ2pCLE1BQU12bEIsTUFBTSxFQUFFdUMsSUFBSztRQUNyQyxJQUFJNG1CLE9BQU81RCxLQUFLLENBQUNoakIsRUFBRTtRQUNuQixJQUFJdWhCLEtBQUtxRixLQUFLaGtCLFFBQVE7UUFDdEIsSUFBSWdnSCxLQUFLcmhHLEdBQUd1QixRQUFRO1FBQ3BCLElBQUksQ0FBQzgvRixHQUFHdUksUUFBUSxFQUFFO1lBQ2hCLElBQUlwckYsUUFBUXg5QixLQUFLOGIsTUFBTSxLQUFLLElBQUk5YixLQUFLc1osRUFBRTtZQUN2QyttRyxHQUFHdmhHLE1BQU0sR0FBRztnQkFDVnRQLEdBQUd4UCxLQUFLd1osR0FBRyxDQUFDZ2tCO2dCQUNadmtCLEdBQUdqWixLQUFLeVosR0FBRyxDQUFDK2pCO1lBQ2Q7WUFDQUEsUUFBUXg5QixLQUFLOGIsTUFBTSxLQUFLLElBQUk5YixLQUFLc1osRUFBRTtZQUNuQyttRyxHQUFHdGhHLE1BQU0sR0FBRztnQkFDVnZQLEdBQUd4UCxLQUFLd1osR0FBRyxDQUFDZ2tCO2dCQUNadmtCLEdBQUdqWixLQUFLeVosR0FBRyxDQUFDK2pCO1lBQ2Q7UUFDRjtRQUNBLElBQUk5WixNQUFNMUUsR0FBR0YsTUFBTTtRQUNuQixJQUFJbGIsTUFBTW9iLEdBQUdELE1BQU07UUFDbkIsSUFBSThwRyxTQUFTbmxHLElBQUl6RSxRQUFRO1FBQ3pCLElBQUk2cEcsU0FBU2xsSCxJQUFJcWIsUUFBUTtRQUN6QixJQUFJOHBHLE9BQU9ybEcsSUFBSTBVLEtBQUs7UUFDcEIsSUFBSTR3RixPQUFPcGxILElBQUl3MEIsS0FBSztRQUNwQixJQUFJNndGLE9BQU92bEcsSUFBSTJVLE1BQU07UUFDckIsSUFBSTZ3RixPQUFPdGxILElBQUl5MEIsTUFBTTtRQUNyQixJQUFJUSxTQUFTeFUsS0FBSysrQyxNQUFNLENBQUMsbUJBQW1CdG1FLEtBQUs7UUFDakQsSUFBSXFzSCxhQUFhdHdGLFNBQVMsR0FBRyxnQ0FBZ0M7UUFFN0R3bkYsR0FBR3YxQyxXQUFXLEdBQUd1MUMsR0FBR1EsTUFBTSxHQUFHO1lBQUNSLEdBQUd2aEcsTUFBTSxDQUFDdFAsQ0FBQyxHQUFHdTVHLE9BQU9JLGFBQWFOLE9BQU9yNUcsQ0FBQztZQUFFNndHLEdBQUd2aEcsTUFBTSxDQUFDN0YsQ0FBQyxHQUFHZ3dHLE9BQU9FLGFBQWFOLE9BQU81dkcsQ0FBQztZQUFFb25HLEdBQUd0aEcsTUFBTSxDQUFDdlAsQ0FBQyxHQUFHdzVHLE9BQU9HLGFBQWFMLE9BQU90NUcsQ0FBQztZQUFFNndHLEdBQUd0aEcsTUFBTSxDQUFDOUYsQ0FBQyxHQUFHaXdHLE9BQU9DLGFBQWFMLE9BQU83dkcsQ0FBQztTQUFDO1FBQzdNb25HLEdBQUd6NkMsSUFBSSxHQUFHLENBQUN5NkMsR0FBR1EsTUFBTSxDQUFDLEVBQUUsR0FBR1IsR0FBR1EsTUFBTSxDQUFDLEVBQUUsSUFBSTtRQUMxQ1IsR0FBR3g2QyxJQUFJLEdBQUcsQ0FBQ3c2QyxHQUFHUSxNQUFNLENBQUMsRUFBRSxHQUFHUixHQUFHUSxNQUFNLENBQUMsRUFBRSxJQUFJO1FBRTFDLHVFQUF1RTtRQUN2RVIsR0FBR08sUUFBUSxHQUFHO1FBQ2RQLEdBQUd1SSxRQUFRLEdBQUc7UUFDZCxJQUFJLENBQUNRLG9CQUFvQixDQUFDL2tHO1FBQzFCLElBQUksQ0FBQzAvRixvQkFBb0IsQ0FBQzEvRjtRQUMxQixJQUFJLENBQUNnbEcsK0JBQStCLENBQUNobEc7UUFDckMsSUFBSSxDQUFDaWxHLG9CQUFvQixDQUFDamxHO0lBQzVCO0FBQ0Y7QUFDQXFqRyxNQUFNNkIsa0JBQWtCLEdBQUcsU0FBVWxsRyxJQUFJLEVBQUV1akcsUUFBUTtJQUNqRCxxQ0FBcUM7SUFFckMsSUFBSXZILEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJaXBHLFlBQVlubEcsS0FBSysrQyxNQUFNLENBQUM7SUFDNUIsSUFBSXFtRCxZQUFZcGxHLEtBQUsrK0MsTUFBTSxDQUFDO0lBQzVCLElBQUlzbUQsWUFBWXJsRyxLQUFLKytDLE1BQU0sQ0FBQztJQUM1QixJQUFJdW1ELFlBQVl0bEcsS0FBSysrQyxNQUFNLENBQUM7SUFDNUIsSUFBSXdtRCxZQUFZNXBILEtBQUsrVSxHQUFHLENBQUN5MEcsVUFBVW5tRCxPQUFPLENBQUNub0UsTUFBTSxFQUFFdXVILFVBQVVwbUQsT0FBTyxDQUFDbm9FLE1BQU07SUFDM0UsSUFBSTJ1SCxhQUFhSCxVQUFVcm1ELE9BQU8sQ0FBQ3FtRCxVQUFVcm1ELE9BQU8sQ0FBQ25vRSxNQUFNLEdBQUcsRUFBRTtJQUNoRSxJQUFJNHVILGlCQUFpQkgsVUFBVXRtRCxPQUFPLENBQUNzbUQsVUFBVXRtRCxPQUFPLENBQUNub0UsTUFBTSxHQUFHLEVBQUU7SUFDcEVtbEgsR0FBR08sUUFBUSxHQUFHO0lBQ2RQLEdBQUdnRSxNQUFNLEdBQUcsRUFBRTtJQUNkaEUsR0FBRzBKLEtBQUssR0FBRyxFQUFFO0lBQ2IxSixHQUFHeUcsV0FBVyxHQUFHLEVBQUU7SUFDbkIsSUFBSyxJQUFJbHFILElBQUksR0FBR0EsSUFBSWd0SCxXQUFXaHRILElBQUs7UUFDbEMsSUFBSXVkLElBQUlxdkcsVUFBVW5tRCxPQUFPLENBQUN6bUUsRUFBRTtRQUM1QixJQUFJb3NCLElBQUl5Z0csVUFBVXBtRCxPQUFPLENBQUN6bUUsRUFBRTtRQUM1QixJQUFJb3RILEtBQUssSUFBSTd2RztRQUNiLElBQUk4dkcsS0FBSzl2RztRQUNULElBQUkrdkcsd0JBQXdCLElBQUksQ0FBQ3ZDLGVBQWUsQ0FBQ3RqRyxNQUFNdWpHLFdBQ3JESSxXQUFXa0Msc0JBQXNCbEMsUUFBUSxFQUN6Q0Qsb0JBQW9CbUMsc0JBQXNCbkMsaUJBQWlCO1FBQzdELElBQUlvQyxnQkFBZ0I7WUFDbEIzNkcsR0FBR3c0RyxTQUFTbG5ILEVBQUUsR0FBR2twSCxLQUFLaEMsU0FBU2puSCxFQUFFLEdBQUdrcEg7WUFDcENoeEcsR0FBRyt1RyxTQUFTaG5ILEVBQUUsR0FBR2dwSCxLQUFLaEMsU0FBUy9tSCxFQUFFLEdBQUdncEg7UUFDdEM7UUFDQTVKLEdBQUdnRSxNQUFNLENBQUMzbUgsSUFBSSxDQUFDeXNILGNBQWMzNkcsQ0FBQyxHQUFHdTRHLGtCQUFrQnY0RyxDQUFDLEdBQUd3WixHQUFHbWhHLGNBQWNseEcsQ0FBQyxHQUFHOHVHLGtCQUFrQjl1RyxDQUFDLEdBQUcrUDtRQUNsR3EzRixHQUFHMEosS0FBSyxDQUFDcnNILElBQUksQ0FBQ2dzSCxVQUFVcm1ELE9BQU8sQ0FBQ3ptRSxFQUFFLEtBQUtxQixZQUFZeXJILFVBQVVybUQsT0FBTyxDQUFDem1FLEVBQUUsR0FBR2l0SDtRQUMxRXhKLEdBQUd5RyxXQUFXLENBQUNwcEgsSUFBSSxDQUFDLENBQUNpc0gsVUFBVXRtRCxPQUFPLENBQUN6bUUsRUFBRSxLQUFLcUIsWUFBWTBySCxVQUFVdG1ELE9BQU8sQ0FBQ3ptRSxFQUFFLEdBQUdrdEgsY0FBYSxNQUFPO0lBQ3ZHO0FBQ0Y7QUFDQXBDLE1BQU0wQyxjQUFjLEdBQUcsU0FBVS9sRyxJQUFJLEVBQUV1akcsUUFBUSxFQUFFbnFILENBQUMsRUFBRTRzSCxlQUFlO0lBQ2pFLFlBQVk7SUFFWixJQUFJaEssS0FBS2g4RixLQUFLaGtCLFFBQVEsQ0FBQ2tnQixRQUFRO0lBQy9CLElBQUkrcEcsWUFBWTFDLFNBQVMwQyxTQUFTLEVBQ2hDekIsU0FBU2pCLFNBQVNpQixNQUFNO0lBQzFCLElBQUkwQixjQUFjbG1HLEtBQUsrK0MsTUFBTSxDQUFDO0lBQzlCLElBQUlvbkQsYUFBYUQsY0FBY0EsWUFBWWxuRCxPQUFPLENBQUMsRUFBRSxHQUFHcGxFO0lBQ3hELElBQUl3c0gsVUFBVXBtRyxLQUFLKytDLE1BQU0sQ0FBQyxrQkFBa0JDLE9BQU87SUFDbkQsSUFBSXFuRCxVQUFVcm1HLEtBQUsrK0MsTUFBTSxDQUFDLGNBQWNDLE9BQU87SUFDL0MsSUFBSXNuRCxXQUFXdG1HLEtBQUsrK0MsTUFBTSxDQUFDLDJCQUEyQkMsT0FBTztJQUM3RGc5QyxHQUFHTyxRQUFRLEdBQUc7SUFDZCxJQUFJOThHLElBQUlyRztJQUNSLElBQUltdEgsV0FBV0Q7SUFDZixJQUFJTixpQkFBaUI7UUFDbkJ2bUgsSUFBSTtRQUNKOG1ILFdBQVdKO0lBQ2I7SUFDQSxJQUFJSyxZQUFZSixVQUFVenFILEtBQUtzWixFQUFFLEdBQUc7SUFDcEMsSUFBSXd4RyxXQUFXRCxZQUFZSCxVQUFVO0lBQ3JDLElBQUlLLFVBQVVGLFlBQVlILFVBQVU7SUFFcEMsbUZBQW1GO0lBQ25GLElBQUlsaUYsS0FBS3RxQyxPQUFPdXNILFVBQVUsTUFBTUM7SUFDaEM1bUgsSUFBSXdtSCxTQUFTLENBQUM5aEYsR0FBRyxLQUFLdnFDLFlBQVlxc0gsU0FBUyxDQUFDOWhGLEdBQUcsR0FBRyxJQUFJLEVBQUU4aEYsU0FBUyxDQUFDOWhGLEdBQUc7SUFDckU2M0UsR0FBR3dFLE9BQU8sR0FBRztRQUFDZ0UsT0FBT3I1RyxDQUFDLEdBQUd4UCxLQUFLd1osR0FBRyxDQUFDc3hHLFlBQVksTUFBTUYsV0FBWTltSCxDQUFBQSxJQUFJLElBQUk7UUFBSStrSCxPQUFPNXZHLENBQUMsR0FBR2paLEtBQUt5WixHQUFHLENBQUNxeEcsWUFBWSxNQUFNRixXQUFZOW1ILENBQUFBLElBQUksSUFBSTtRQUFJK2tILE9BQU9yNUcsQ0FBQyxHQUFHeFAsS0FBS3daLEdBQUcsQ0FBQ3V4RyxXQUFXLE1BQU1ILFdBQVk5bUgsQ0FBQUEsSUFBSSxJQUFJO1FBQUkra0gsT0FBTzV2RyxDQUFDLEdBQUdqWixLQUFLeVosR0FBRyxDQUFDc3hHLFdBQVcsTUFBTUgsV0FBWTltSCxDQUFBQSxJQUFJLElBQUk7S0FBRztBQUNyUTtBQUNBNGpILE1BQU1zRCxzQkFBc0IsR0FBRyxTQUFVM21HLElBQUksRUFBRXVqRyxRQUFRLEVBQUVucUgsQ0FBQyxFQUFFNHNILGVBQWU7SUFDekUsZ0JBQWdCO0lBRWhCLElBQUloSyxLQUFLaDhGLEtBQUtoa0IsUUFBUSxDQUFDa2dCLFFBQVE7SUFDL0I4L0YsR0FBR08sUUFBUSxHQUFHO0lBQ2QsSUFBSWlJLFNBQVNqQixTQUFTaUIsTUFBTSxFQUMxQkMsU0FBU2xCLFNBQVNrQixNQUFNLEVBQ3hCQyxPQUFPbkIsU0FBU21CLElBQUksRUFDcEJFLE9BQU9yQixTQUFTcUIsSUFBSSxFQUNwQkQsT0FBT3BCLFNBQVNvQixJQUFJLEVBQ3BCRSxPQUFPdEIsU0FBU3NCLElBQUk7SUFDdEIsSUFBSXlCLFdBQVd0bUcsS0FBSysrQyxNQUFNLENBQUMsMkJBQTJCQyxPQUFPO0lBQzdELElBQUlrbkQsY0FBY2xtRyxLQUFLKytDLE1BQU0sQ0FBQztJQUM5QixJQUFJb25ELGFBQWFELGNBQWNBLFlBQVlsbkQsT0FBTyxDQUFDLEVBQUUsR0FBR3BsRTtJQUN4RCxJQUFJNkYsSUFBSXJHO0lBQ1IsSUFBSW10SCxXQUFXRDtJQUNmLElBQUlOLGlCQUFpQjtRQUNuQnZtSCxJQUFJO1FBQ0o4bUgsV0FBV0o7SUFDYjtJQUNBLElBQUlTLFFBQVE7SUFDWixJQUFJQyxXQUFXO1FBQ2IxN0csR0FBR3E1RyxPQUFPcjVHLENBQUMsR0FBR3U1RyxPQUFPO1FBQ3JCOXZHLEdBQUc0dkcsT0FBTzV2RyxDQUFDLEdBQUdnd0csT0FBTztJQUN2QjtJQUNBLElBQUlrQyxXQUFXO1FBQ2IzN0csR0FBR3M1RyxPQUFPdDVHLENBQUMsR0FBR3c1RyxPQUFPO1FBQ3JCL3ZHLEdBQUc2dkcsT0FBTzd2RyxDQUFDLEdBQUdpd0csT0FBTztJQUN2QjtJQUNBLElBQUlrQyxVQUFVO1FBQ1o1N0csR0FBR3hQLEtBQUsrVSxHQUFHLENBQUNtMkcsU0FBUzE3RyxDQUFDLEVBQUUyN0csU0FBUzM3RyxDQUFDO1FBQ2xDeUosR0FBR2paLEtBQUsrVSxHQUFHLENBQUNtMkcsU0FBU2p5RyxDQUFDLEVBQUVreUcsU0FBU2x5RyxDQUFDO0lBQ3BDO0lBRUEsdUNBQXVDO0lBQ3ZDLElBQUlveUcscUJBQXFCO0lBQ3pCLElBQUlDLG1CQUFtQnRySCxLQUFLNlUsR0FBRyxDQUFDdzJHLG9CQUFvQnJySCxLQUFLd2IsR0FBRyxDQUFDdXRHLE9BQU92QjtJQUNwRSxJQUFJK0QsbUJBQW1CdnJILEtBQUs2VSxHQUFHLENBQUN3Mkcsb0JBQW9CcnJILEtBQUt3YixHQUFHLENBQUN3dEcsT0FBT3hCO0lBQ3BFbkgsR0FBR3dFLE9BQU8sR0FBRztRQUFDdUcsUUFBUTU3RyxDQUFDO1FBQUU0N0csUUFBUW55RyxDQUFDLEdBQUcsQ0FBQyxJQUFJalosS0FBSzZ4QixHQUFHLENBQUNvNUYsT0FBTyxRQUFRLEdBQUUsSUFBS0wsV0FBWTltSCxDQUFBQSxJQUFJLElBQUksS0FBS3duSDtRQUFrQkYsUUFBUTU3RyxDQUFDLEdBQUcsQ0FBQyxJQUFJeFAsS0FBSzZ4QixHQUFHLENBQUNvNUYsT0FBTyxRQUFRLEdBQUUsSUFBS0wsV0FBWTltSCxDQUFBQSxJQUFJLElBQUksS0FBS3luSDtRQUFrQkgsUUFBUW55RyxDQUFDO0tBQUM7QUFDM047QUFDQXl1RyxNQUFNOEQsc0JBQXNCLEdBQUcsU0FBVW5uRyxJQUFJO0lBQzNDLDhCQUE4QjtJQUU5QkEsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUSxDQUFDcWdHLFFBQVEsR0FBRztBQUNwQztBQUNBOEcsTUFBTStELGdCQUFnQixHQUFHLFNBQVVwbkcsSUFBSSxFQUFFdWpHLFFBQVEsRUFBRW5xSCxDQUFDLEVBQUU0c0gsZUFBZSxFQUFFcUIsYUFBYTtJQUNsRixJQUFJckwsS0FBS2g4RixLQUFLaGtCLFFBQVEsQ0FBQ2tnQixRQUFRO0lBQy9CLElBQUlvcUcsV0FBV3RtRyxLQUFLKytDLE1BQU0sQ0FBQywyQkFBMkJDLE9BQU87SUFDN0QsSUFBSWtuRCxjQUFjbG1HLEtBQUsrK0MsTUFBTSxDQUFDO0lBQzlCLElBQUl1b0QsV0FBV3RuRyxLQUFLKytDLE1BQU0sQ0FBQztJQUMzQixJQUFJd29ELFVBQVVyQixlQUFlb0IsV0FBVzNySCxLQUFLK1UsR0FBRyxDQUFDdzFHLFlBQVl6dEgsS0FBSyxDQUFDNUIsTUFBTSxFQUFFeXdILFNBQVM3dUgsS0FBSyxDQUFDNUIsTUFBTSxJQUFJO0lBQ3BHLElBQUlzdkgsYUFBYUQsY0FBY0EsWUFBWWxuRCxPQUFPLENBQUMsRUFBRSxHQUFHcGxFO0lBQ3hELElBQUk0dEgsZUFBZUYsU0FBUzd1SCxLQUFLLENBQUMsRUFBRTtJQUVwQyxnQkFBZ0I7SUFFaEIsSUFBSWd2SCxRQUFRekI7SUFDWmhLLEdBQUdPLFFBQVEsR0FBR2tMLFFBQVEsZ0JBQWdCO0lBQ3RDekwsR0FBR3dFLE9BQU8sR0FBRyxFQUFFO0lBQ2YsSUFBSyxJQUFJdGhILElBQUksR0FBR0EsSUFBSXFvSCxTQUFTcm9ILElBQUs7UUFDaEMsSUFBSXdvSCxpQkFBaUIsQ0FBQyxNQUFNbkUsU0FBU3IvRixJQUFJLENBQUNydEIsTUFBTSxHQUFHLElBQUl1QyxDQUFBQSxJQUFLa3RILFdBQVllLENBQUFBLGdCQUFnQixDQUFDLElBQUk7UUFDN0YsSUFBSU0sZ0JBQWdCL3RIO1FBQ3BCLElBQUlndUgsT0FBT3YzRixPQUFPcTNGO1FBQ2xCLElBQUlELE9BQU87WUFDVHRCLGFBQWFELGNBQWNBLFlBQVlsbkQsT0FBTyxDQUFDOS9ELEVBQUUsR0FBR29uSCxVQUFVLHlCQUF5QjtZQUN2RmtCLGVBQWVGLFNBQVM3dUgsS0FBSyxDQUFDeUcsRUFBRTtRQUNsQztRQUNBLElBQUk4bUgsaUJBQWlCO1lBQ25CLDRCQUE0QjtZQUM1QjJCLGdCQUFnQnhCO1FBQ2xCLE9BQU87WUFDTHdCLGdCQUFnQnhCLGVBQWV2c0gsWUFBWWd1SCxPQUFPekIsYUFBYXZzSDtRQUNqRTtRQUNBLElBQUlpdUgsdUJBQXVCRixrQkFBa0IvdEgsWUFBWSt0SCxnQkFBZ0JEO1FBQ3pFLElBQUkvQixLQUFLLElBQUk2QjtRQUNiLElBQUk1QixLQUFLNEI7UUFDVCxJQUFJTSx5QkFBeUIsSUFBSSxDQUFDeEUsZUFBZSxDQUFDdGpHLE1BQU11akcsV0FDdERJLFdBQVdtRSx1QkFBdUJuRSxRQUFRLEVBQzFDRCxvQkFBb0JvRSx1QkFBdUJwRSxpQkFBaUI7UUFDOUQsSUFBSW9DLGdCQUFnQjtZQUNsQjM2RyxHQUFHdzRHLFNBQVNsbkgsRUFBRSxHQUFHa3BILEtBQUtoQyxTQUFTam5ILEVBQUUsR0FBR2twSDtZQUNwQ2h4RyxHQUFHK3VHLFNBQVNobkgsRUFBRSxHQUFHZ3BILEtBQUtoQyxTQUFTL21ILEVBQUUsR0FBR2dwSDtRQUN0QztRQUNBNUosR0FBR3dFLE9BQU8sQ0FBQ25uSCxJQUFJLENBQUN5c0gsY0FBYzM2RyxDQUFDLEdBQUd1NEcsa0JBQWtCdjRHLENBQUMsR0FBRzA4RyxzQkFBc0IvQixjQUFjbHhHLENBQUMsR0FBRzh1RyxrQkFBa0I5dUcsQ0FBQyxHQUFHaXpHO0lBQ3hIO0FBQ0Y7QUFDQXhFLE1BQU0wRSxjQUFjLEdBQUcsU0FBVS9uRyxJQUFJLEVBQUV1akcsUUFBUTtJQUM3QywwQ0FBMEM7SUFFMUMsSUFBSXZILEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQjgvRixHQUFHTyxRQUFRLEdBQUc7SUFDZCxJQUFJeUwsV0FBVztJQUNmLElBQUlDLGFBQWE7SUFDakIsSUFBSUMsV0FBVztJQUNmLElBQUlDLFlBQVk7SUFDaEIsSUFBSUMsV0FBVztJQUNmLElBQUlDLFNBQVM7SUFDYixJQUFJQyxPQUFPO0lBQ1gsSUFBSTlFLFNBQVNELFNBQVNDLE1BQU0sRUFDMUJrQixPQUFPbkIsU0FBU21CLElBQUksRUFDcEJFLE9BQU9yQixTQUFTcUIsSUFBSSxFQUNwQkQsT0FBT3BCLFNBQVNvQixJQUFJLEVBQ3BCRSxPQUFPdEIsU0FBU3NCLElBQUk7SUFDdEIsSUFBSXhtQixnQkFBZ0JyK0UsS0FBSysrQyxNQUFNLENBQUMsa0JBQWtCdG1FLEtBQUs7SUFDdkQsSUFBSTh2SCxvQkFBb0JscUIsa0JBQWtCO0lBQzFDLElBQUltcUIsVUFBVXhvRyxLQUFLKytDLE1BQU0sQ0FBQyxrQkFBa0J0bUUsS0FBSztJQUNqRCxJQUFJZ3dILGFBQWFELFNBQVMsb0JBQW9CO0lBQzlDLElBQUlFLFdBQVcxb0csS0FBSysrQyxNQUFNLENBQUM7SUFDM0IsSUFBSTRwRCxnQkFBZ0JELFNBQVM3b0QsS0FBSyxLQUFLO0lBQ3ZDLElBQUkrb0QsZ0JBQWdCRixTQUFTMXBELE9BQU87SUFDcEMsSUFBSTZwRCxpQkFBaUJELGdCQUFnQixHQUFHLHdCQUF3QjtJQUNoRSxJQUFJRSxPQUFPOW9HLEtBQUsrK0MsTUFBTSxDQUFDLDBCQUEwQkMsT0FBTztJQUN4RCxJQUFJK3BELEtBQUtSLG9CQUFvQixDQUFDN0QsT0FBT0MsSUFBRyxJQUFLLElBQUk7SUFDakQsSUFBSXFFLEtBQUtULG9CQUFvQixDQUFDM0QsT0FBT0MsSUFBRyxJQUFLLElBQUk7SUFDakQsSUFBSW9FLE1BQU16RixPQUFPOW1ILEVBQUUsR0FBRzhtSCxPQUFPL21ILEVBQUU7SUFDL0IsSUFBSXlzSCxNQUFNMUYsT0FBTzVtSCxFQUFFLEdBQUc0bUgsT0FBTzdtSCxFQUFFO0lBRS9CLG9FQUFvRTtJQUNwRSxJQUFJd3NILFNBQVMsU0FBU0EsT0FBT0MsR0FBRyxFQUFFQyxHQUFHO1FBQ25DLElBQUlELE1BQU0sR0FBRztZQUNYLE9BQU96dEgsS0FBSzZVLEdBQUcsQ0FBQzQ0RyxNQUFNQyxLQUFLO1FBQzdCLE9BQU87WUFDTCxPQUFPMXRILEtBQUsrVSxHQUFHLENBQUMwNEcsTUFBTUMsS0FBSztRQUM3QjtJQUNGO0lBQ0EsSUFBSTU0RixLQUFLMDRGLE9BQU9GLEtBQUtGO0lBQ3JCLElBQUlyNEYsS0FBS3k0RixPQUFPRCxLQUFLRjtJQUNyQixJQUFJTSxnQkFBZ0I7SUFDcEIsSUFBSWIsZUFBZUgsTUFBTTtRQUN2QkUsVUFBVTdzSCxLQUFLMjNCLEdBQUcsQ0FBQzdDLE1BQU05MEIsS0FBSzIzQixHQUFHLENBQUM1QyxNQUFNdTNGLGFBQWFEO0lBQ3ZELE9BQU8sSUFBSVMsZUFBZUosVUFBVUksZUFBZUwsVUFBVTtRQUMzREksVUFBVVI7UUFDVnNCLGdCQUFnQjtJQUNsQixPQUFPLElBQUliLGVBQWVQLFlBQVlPLGVBQWVOLFdBQVc7UUFDOURLLFVBQVVQO1FBQ1ZxQixnQkFBZ0I7SUFDbEI7SUFDQSxJQUFJQyxTQUFTZixZQUFZUjtJQUN6QixJQUFJN3VILElBQUlvd0gsU0FBUzc0RixLQUFLRDtJQUN0QixJQUFJKzRGLEtBQUtELFNBQVNMLE1BQU1EO0lBQ3hCLElBQUlRLE9BQU9wNUYsT0FBT201RjtJQUNsQixJQUFJRSxZQUFZO0lBQ2hCLElBQUksQ0FBRUosQ0FBQUEsaUJBQWtCWCxDQUFBQSxpQkFBaUJFLGNBQWEsRUFBSSwyRUFBMkU7SUFBOUUsS0FDbkRKLENBQUFBLGVBQWVMLFlBQVlvQixLQUFLLEtBQUtmLGVBQWVKLFVBQVVtQixLQUFLLEtBQUtmLGVBQWVQLFlBQVlzQixLQUFLLEtBQUtmLGVBQWVOLGFBQWFxQixLQUFLLElBQUk7UUFDcEpDLFFBQVEsQ0FBQztRQUNUdHdILElBQUlzd0gsT0FBTzl0SCxLQUFLMjNCLEdBQUcsQ0FBQ242QjtRQUNwQnV3SCxZQUFZO0lBQ2Q7SUFDQSxJQUFJL2tHO0lBQ0osSUFBSWdrRyxlQUFlO1FBQ2pCLElBQUl2b0gsSUFBSXdvSCxnQkFBZ0IsSUFBSSxJQUFJQSxnQkFBZ0JBO1FBQ2hEamtHLElBQUl2a0IsSUFBSWpIO0lBQ1YsT0FBTztRQUNMLElBQUl1RSxJQUFJa3JILGdCQUFnQixJQUFJenZILElBQUk7UUFDaEN3ckIsSUFBSWpuQixJQUFJa3JILGdCQUFnQmE7SUFDMUI7SUFDQSxJQUFJRSxnQkFBZ0IsU0FBU0EsY0FBY2hsRyxDQUFDO1FBQzFDLE9BQU9ocEIsS0FBSzIzQixHQUFHLENBQUMzTyxLQUFLbWtHLFFBQVFudEgsS0FBSzIzQixHQUFHLENBQUMzTyxNQUFNaHBCLEtBQUsyM0IsR0FBRyxDQUFDbjZCO0lBQ3ZEO0lBQ0EsSUFBSXl3SCxnQkFBZ0JELGNBQWNobEc7SUFDbEMsSUFBSWtsRyxnQkFBZ0JGLGNBQWNodUgsS0FBSzIzQixHQUFHLENBQUNuNkIsS0FBS3dDLEtBQUsyM0IsR0FBRyxDQUFDM087SUFDekQsSUFBSW1sRyxhQUFhRixpQkFBaUJDO0lBQ2xDLElBQUlDLGNBQWMsQ0FBQ0osV0FBVztRQUM1QixvQkFBb0I7UUFDcEIsSUFBSUgsUUFBUTtZQUNWLHFCQUFxQjtZQUNyQixJQUFJUSxrQkFBa0JwdUgsS0FBSzIzQixHQUFHLENBQUNrMkYsT0FBTzVFLE9BQU87WUFDN0MsSUFBSW9GLGtCQUFrQnJ1SCxLQUFLMjNCLEdBQUcsQ0FBQzIxRixRQUFRdEUsT0FBTztZQUM5QyxJQUFJb0YsaUJBQWlCO2dCQUNuQiwrQ0FBK0M7Z0JBQy9DLElBQUk1K0csSUFBSSxDQUFDcTRHLE9BQU8vbUgsRUFBRSxHQUFHK21ILE9BQU85bUgsRUFBRSxJQUFJO2dCQUNsQyxJQUFJQyxLQUFLNm1ILE9BQU83bUgsRUFBRSxFQUNoQkMsS0FBSzRtSCxPQUFPNW1ILEVBQUU7Z0JBQ2hCby9HLEdBQUdnRSxNQUFNLEdBQUc7b0JBQUM3MEc7b0JBQUd4TztvQkFBSXdPO29CQUFHdk87aUJBQUc7WUFDNUIsT0FBTyxJQUFJb3RILGlCQUFpQjtnQkFDMUIsNENBQTRDO2dCQUM1QyxJQUFJcDFHLElBQUksQ0FBQzR1RyxPQUFPN21ILEVBQUUsR0FBRzZtSCxPQUFPNW1ILEVBQUUsSUFBSTtnQkFDbEMsSUFBSUgsS0FBSyttSCxPQUFPL21ILEVBQUUsRUFDaEJDLEtBQUs4bUgsT0FBTzltSCxFQUFFO2dCQUNoQnMvRyxHQUFHZ0UsTUFBTSxHQUFHO29CQUFDdmpIO29CQUFJbVk7b0JBQUdsWTtvQkFBSWtZO2lCQUFFO1lBQzVCLE9BQU87Z0JBQ0wsb0ZBQW9GO2dCQUNwRm9uRyxHQUFHZ0UsTUFBTSxHQUFHO29CQUFDd0QsT0FBTy9tSCxFQUFFO29CQUFFK21ILE9BQU81bUgsRUFBRTtpQkFBQztZQUNwQztRQUNGLE9BQU87WUFDTCx1QkFBdUI7WUFDdkIsSUFBSXF0SCxtQkFBbUJ0dUgsS0FBSzIzQixHQUFHLENBQUNrMkYsT0FBTzlFLE9BQU87WUFDOUMsSUFBSXdGLG1CQUFtQnZ1SCxLQUFLMjNCLEdBQUcsQ0FBQzQxRixRQUFRckUsT0FBTztZQUMvQyxJQUFJb0Ysa0JBQWtCO2dCQUNwQiw2Q0FBNkM7Z0JBQzdDLElBQUlFLEtBQUssQ0FBQzNHLE9BQU83bUgsRUFBRSxHQUFHNm1ILE9BQU81bUgsRUFBRSxJQUFJO2dCQUNuQyxJQUFJd3RILEtBQUs1RyxPQUFPL21ILEVBQUUsRUFDaEI0dEgsTUFBTTdHLE9BQU85bUgsRUFBRTtnQkFDakJzL0csR0FBR2dFLE1BQU0sR0FBRztvQkFBQ29LO29CQUFJRDtvQkFBSUU7b0JBQUtGO2lCQUFHO1lBQy9CLE9BQU8sSUFBSUQsa0JBQWtCO2dCQUMzQixtREFBbUQ7Z0JBQ25ELElBQUlJLE1BQU0sQ0FBQzlHLE9BQU8vbUgsRUFBRSxHQUFHK21ILE9BQU85bUgsRUFBRSxJQUFJO2dCQUNwQyxJQUFJNnRILE1BQU0vRyxPQUFPN21ILEVBQUUsRUFDakI2dEgsTUFBTWhILE9BQU81bUgsRUFBRTtnQkFDakJvL0csR0FBR2dFLE1BQU0sR0FBRztvQkFBQ3NLO29CQUFLQztvQkFBS0Q7b0JBQUtFO2lCQUFJO1lBQ2xDLE9BQU87Z0JBQ0wsMEVBQTBFO2dCQUMxRXhPLEdBQUdnRSxNQUFNLEdBQUc7b0JBQUN3RCxPQUFPOW1ILEVBQUU7b0JBQUU4bUgsT0FBTzdtSCxFQUFFO2lCQUFDO1lBQ3BDO1FBQ0Y7SUFDRixPQUFPO1FBQ0wsZ0JBQWdCO1FBQ2hCLElBQUk0c0gsUUFBUTtZQUNWLElBQUlrQixNQUFNakgsT0FBTzdtSCxFQUFFLEdBQUdnb0IsSUFBSzRqRyxDQUFBQSxvQkFBb0IzRCxPQUFPLElBQUk2RSxPQUFPO1lBQ2pFLElBQUlpQixNQUFNbEgsT0FBTy9tSCxFQUFFLEVBQ2pCa3VILE1BQU1uSCxPQUFPOW1ILEVBQUU7WUFDakJzL0csR0FBR2dFLE1BQU0sR0FBRztnQkFBQzBLO2dCQUFLRDtnQkFBS0U7Z0JBQUtGO2FBQUk7UUFDbEMsT0FBTztZQUNMLGFBQWE7WUFDYixJQUFJRyxNQUFNcEgsT0FBTy9tSCxFQUFFLEdBQUdrb0IsSUFBSzRqRyxDQUFBQSxvQkFBb0I3RCxPQUFPLElBQUkrRSxPQUFPO1lBQ2pFLElBQUlvQixNQUFNckgsT0FBTzdtSCxFQUFFLEVBQ2pCbXVILE1BQU10SCxPQUFPNW1ILEVBQUU7WUFDakJvL0csR0FBR2dFLE1BQU0sR0FBRztnQkFBQzRLO2dCQUFLQztnQkFBS0Q7Z0JBQUtFO2FBQUk7UUFDbEM7SUFDRjtJQUNBLElBQUk5TyxHQUFHcUUsT0FBTyxFQUFFO1FBQ2QsSUFBSTdyRixTQUFTeFUsS0FBSysrQyxNQUFNLENBQUMsZUFBZXRtRSxLQUFLO1FBQzdDLElBQUlncUgsY0FBY3ppRyxLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUssQ0FBQyxFQUFFLEtBQUs7UUFDMUR1akgsR0FBRzBKLEtBQUssR0FBRyxJQUFJMXVILE1BQU1nbEgsR0FBR2dFLE1BQU0sQ0FBQ25wSCxNQUFNLEdBQUcsR0FBR21sRyxJQUFJLENBQUN4bkU7UUFDaER3bkYsR0FBR3lHLFdBQVcsR0FBRyxJQUFJenJILE1BQU1nbEgsR0FBR2dFLE1BQU0sQ0FBQ25wSCxNQUFNLEdBQUcsR0FBR21sRyxJQUFJLENBQUN5bUI7SUFDeEQ7QUFDRjtBQUNBWSxNQUFNMEgseUJBQXlCLEdBQUcsU0FBVS9xRyxJQUFJLEVBQUV1akcsUUFBUTtJQUN4RCxJQUFJdkgsS0FBS2g4RixLQUFLaGtCLFFBQVEsQ0FBQ2tnQixRQUFRO0lBRS9CLHNDQUFzQztJQUN0QyxJQUFJOC9GLEdBQUdPLFFBQVEsS0FBSyxVQUFVO1FBQzVCLElBQUlpSSxTQUFTakIsU0FBU2lCLE1BQU0sRUFDMUJDLFNBQVNsQixTQUFTa0IsTUFBTSxFQUN4QkMsT0FBT25CLFNBQVNtQixJQUFJLEVBQ3BCRSxPQUFPckIsU0FBU3FCLElBQUksRUFDcEJELE9BQU9wQixTQUFTb0IsSUFBSSxFQUNwQkUsT0FBT3RCLFNBQVNzQixJQUFJLEVBQ3BCbUcsV0FBV3pILFNBQVN5SCxRQUFRLEVBQzVCQyxXQUFXMUgsU0FBUzBILFFBQVEsRUFDNUJDLGtCQUFrQjNILFNBQVMySCxlQUFlLEVBQzFDQyxrQkFBa0I1SCxTQUFTNEgsZUFBZSxFQUMxQ0MsUUFBUTdILFNBQVM2SCxLQUFLLEVBQ3RCQyxRQUFROUgsU0FBUzhILEtBQUs7UUFDeEIsSUFBSUMsV0FBVyxDQUFDL3ZILFNBQVN5Z0gsR0FBR3BpRixNQUFNLEtBQUssQ0FBQ3IrQixTQUFTeWdILEdBQUduaUYsTUFBTTtRQUMxRCxJQUFJMHhGLFlBQVksQ0FBQ2h3SCxTQUFTeWdILEdBQUdXLFdBQVcsS0FBSyxDQUFDcGhILFNBQVN5Z0gsR0FBR1ksV0FBVztRQUNyRSxJQUFJNE8sU0FBUyxDQUFDandILFNBQVN5Z0gsR0FBRytDLElBQUksS0FBSyxDQUFDeGpILFNBQVN5Z0gsR0FBR2dELElBQUk7UUFDcEQsSUFBSXlNLFVBQVUsQ0FBQ2x3SCxTQUFTeWdILEdBQUdjLFNBQVMsS0FBSyxDQUFDdmhILFNBQVN5Z0gsR0FBR2UsU0FBUztRQUMvRCxJQUFJMk8sbUJBQW1CO1FBQ3ZCLElBQUlDLFNBQVMsSUFBSSxDQUFDblMsYUFBYSxDQUFDeDVGLEtBQUsrK0MsTUFBTSxDQUFDLFNBQVNDLE9BQU8sRUFBRWgvQyxLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUssSUFBSSxJQUFJLENBQUNnL0csZUFBZTtRQUN0SCxJQUFJbVUsYUFBYUYsbUJBQW1CQztRQUNwQyxJQUFJRSxlQUFlem5HLEtBQUs7WUFDdEJqWixHQUFHNndHLEdBQUd3RSxPQUFPLENBQUMsRUFBRTtZQUNoQjVyRyxHQUFHb25HLEdBQUd3RSxPQUFPLENBQUMsRUFBRTtRQUNsQixHQUFHO1lBQ0RyMUcsR0FBRzZ3RyxHQUFHcGlGLE1BQU07WUFDWmhsQixHQUFHb25HLEdBQUduaUYsTUFBTTtRQUNkO1FBQ0EsSUFBSWl5RixnQkFBZ0JELGVBQWVEO1FBQ25DLElBQUlHLGFBQWEzbkcsS0FBSztZQUNwQmpaLEdBQUc2d0csR0FBR3dFLE9BQU8sQ0FBQyxFQUFFO1lBQ2hCNXJHLEdBQUdvbkcsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFO1FBQ2xCLEdBQUc7WUFDRHIxRyxHQUFHNndHLEdBQUcrQyxJQUFJO1lBQ1ZucUcsR0FBR29uRyxHQUFHZ0QsSUFBSTtRQUNaO1FBQ0EsSUFBSWdOLGNBQWNELGFBQWFIO1FBQy9CLElBQUlLLGNBQWM7UUFDbEIsSUFBSVgsWUFBWUMsYUFBYU8sZUFBZTtZQUMxQ0csY0FBYztZQUVkLDRFQUE0RTtZQUM1RSw4Q0FBOEM7WUFDOUMsSUFBSUMsTUFBTTtnQkFDUixRQUFRO2dCQUNSL2dILEdBQUc2d0csR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUdnRSxPQUFPcjVHLENBQUM7Z0JBQzNCeUosR0FBR29uRyxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBR2dFLE9BQU81dkcsQ0FBQztZQUM3QjtZQUNBLElBQUl1M0csTUFBTXh3SCxLQUFLMndCLElBQUksQ0FBQzQvRixJQUFJL2dILENBQUMsR0FBRytnSCxJQUFJL2dILENBQUMsR0FBRytnSCxJQUFJdDNHLENBQUMsR0FBR3MzRyxJQUFJdDNHLENBQUMsR0FBRyxpQkFBaUI7WUFDckUsSUFBSXczRyxNQUFNO2dCQUNSLG1CQUFtQjtnQkFDbkJqaEgsR0FBRytnSCxJQUFJL2dILENBQUMsR0FBR2doSDtnQkFDWHYzRyxHQUFHczNHLElBQUl0M0csQ0FBQyxHQUFHdTNHO1lBQ2I7WUFDQSxJQUFJMzNGLFNBQVM3NEIsS0FBSzZVLEdBQUcsQ0FBQ2swRyxNQUFNRTtZQUM1QixJQUFJeUgsU0FBUztnQkFDWCxxQ0FBcUM7Z0JBQ3JDbGhILEdBQUc2d0csR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUc0TCxJQUFJamhILENBQUMsR0FBRyxJQUFJcXBCO2dCQUMvQjVmLEdBQUdvbkcsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUc0TCxJQUFJeDNHLENBQUMsR0FBRyxJQUFJNGY7WUFDakM7WUFDQSxJQUFJODNGLGdCQUFnQnRCLFNBQVN1QixhQUFhLENBQUMvSCxPQUFPcjVHLENBQUMsRUFBRXE1RyxPQUFPNXZHLENBQUMsRUFBRTh2RyxNQUFNRSxNQUFNeUgsT0FBT2xoSCxDQUFDLEVBQUVraEgsT0FBT3ozRyxDQUFDLEVBQUUsR0FBR3MyRyxpQkFBaUJFO1lBQ25ILElBQUlVLGVBQWU7Z0JBQ2pCOVAsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUd4RSxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBRzRMLElBQUlqaEgsQ0FBQyxHQUFJeWdILENBQUFBLGFBQWFDLFlBQVc7Z0JBQ2pFN1AsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUd4RSxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBRzRMLElBQUl4M0csQ0FBQyxHQUFJZzNHLENBQUFBLGFBQWFDLFlBQVc7WUFDbkUsT0FBTztnQkFDTDdQLEdBQUd3RSxPQUFPLENBQUMsRUFBRSxHQUFHOEwsYUFBYSxDQUFDLEVBQUUsR0FBR0YsSUFBSWpoSCxDQUFDLEdBQUd5Z0g7Z0JBQzNDNVAsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUc4TCxhQUFhLENBQUMsRUFBRSxHQUFHRixJQUFJeDNHLENBQUMsR0FBR2czRztZQUM3QztRQUNGO1FBQ0EsSUFBSUosVUFBVUMsV0FBV08sYUFBYTtZQUNwQ0MsY0FBYztZQUVkLDRFQUE0RTtZQUM1RSw4Q0FBOEM7WUFDOUMsSUFBSU8sT0FBTztnQkFDVCxRQUFRO2dCQUNScmhILEdBQUc2d0csR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUdpRSxPQUFPdDVHLENBQUM7Z0JBQzNCeUosR0FBR29uRyxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBR2lFLE9BQU83dkcsQ0FBQztZQUM3QjtZQUNBLElBQUk2M0csT0FBTzl3SCxLQUFLMndCLElBQUksQ0FBQ2tnRyxLQUFLcmhILENBQUMsR0FBR3FoSCxLQUFLcmhILENBQUMsR0FBR3FoSCxLQUFLNTNHLENBQUMsR0FBRzQzRyxLQUFLNTNHLENBQUMsR0FBRyxpQkFBaUI7WUFDMUUsSUFBSTgzRyxPQUFPO2dCQUNULG1CQUFtQjtnQkFDbkJ2aEgsR0FBR3FoSCxLQUFLcmhILENBQUMsR0FBR3NoSDtnQkFDWjczRyxHQUFHNDNHLEtBQUs1M0csQ0FBQyxHQUFHNjNHO1lBQ2Q7WUFDQSxJQUFJRSxVQUFVaHhILEtBQUs2VSxHQUFHLENBQUNrMEcsTUFBTUU7WUFDN0IsSUFBSWdJLFVBQVU7Z0JBQ1oscUNBQXFDO2dCQUNyQ3poSCxHQUFHNndHLEdBQUd3RSxPQUFPLENBQUMsRUFBRSxHQUFHa00sS0FBS3ZoSCxDQUFDLEdBQUcsSUFBSXdoSDtnQkFDaEMvM0csR0FBR29uRyxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBR2tNLEtBQUs5M0csQ0FBQyxHQUFHLElBQUkrM0c7WUFDbEM7WUFDQSxJQUFJRSxnQkFBZ0I1QixTQUFTc0IsYUFBYSxDQUFDOUgsT0FBT3Q1RyxDQUFDLEVBQUVzNUcsT0FBTzd2RyxDQUFDLEVBQUUrdkcsTUFBTUUsTUFBTStILFFBQVF6aEgsQ0FBQyxFQUFFeWhILFFBQVFoNEcsQ0FBQyxFQUFFLEdBQUd1MkcsaUJBQWlCRTtZQUNySCxJQUFJVyxhQUFhO2dCQUNmaFEsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUd4RSxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBR2tNLEtBQUt2aEgsQ0FBQyxHQUFJeWdILENBQUFBLGFBQWFHLFVBQVM7Z0JBQ2hFL1AsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUd4RSxHQUFHd0UsT0FBTyxDQUFDLEVBQUUsR0FBR2tNLEtBQUs5M0csQ0FBQyxHQUFJZzNHLENBQUFBLGFBQWFHLFVBQVM7WUFDbEUsT0FBTztnQkFDTC9QLEdBQUd3RSxPQUFPLENBQUMsRUFBRSxHQUFHcU0sYUFBYSxDQUFDLEVBQUUsR0FBR0gsS0FBS3ZoSCxDQUFDLEdBQUd5Z0g7Z0JBQzVDNVAsR0FBR3dFLE9BQU8sQ0FBQyxFQUFFLEdBQUdxTSxhQUFhLENBQUMsRUFBRSxHQUFHSCxLQUFLOTNHLENBQUMsR0FBR2czRztZQUM5QztRQUNGO1FBQ0EsSUFBSUssYUFBYTtZQUNmLGdCQUFnQjtZQUNoQixJQUFJLENBQUNhLGFBQWEsQ0FBQzlzRztRQUNyQjtJQUNGO0FBQ0Y7QUFDQXFqRyxNQUFNMEosV0FBVyxHQUFHLFNBQVUvc0csSUFBSTtJQUNoQyxJQUFJZzhGLEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJOC9GLEdBQUdPLFFBQVEsS0FBSyxpQkFBaUJQLEdBQUdPLFFBQVEsS0FBSyxZQUFZUCxHQUFHTyxRQUFRLEtBQUssVUFBVVAsR0FBR08sUUFBUSxLQUFLLFlBQVk7UUFDckhQLEdBQUdRLE1BQU0sR0FBRyxFQUFFO1FBQ2RSLEdBQUdRLE1BQU0sQ0FBQ25qSCxJQUFJLENBQUMyaUgsR0FBR3BpRixNQUFNLEVBQUVvaUYsR0FBR25pRixNQUFNO1FBQ25DLElBQUssSUFBSTM2QixJQUFJLEdBQUdBLElBQUksSUFBSTg4RyxHQUFHd0UsT0FBTyxDQUFDM3BILE1BQU0sRUFBRXFJLEtBQUssRUFBRztZQUNqRCxpQkFBaUI7WUFDakI4OEcsR0FBR1EsTUFBTSxDQUFDbmpILElBQUksQ0FBQzJpSCxHQUFHd0UsT0FBTyxDQUFDdGhILEVBQUUsRUFBRTg4RyxHQUFHd0UsT0FBTyxDQUFDdGhILElBQUksRUFBRTtZQUUvQyw0REFBNEQ7WUFDNUQsSUFBSUEsSUFBSSxJQUFJODhHLEdBQUd3RSxPQUFPLENBQUMzcEgsTUFBTSxFQUFFO2dCQUM3Qm1sSCxHQUFHUSxNQUFNLENBQUNuakgsSUFBSSxDQUFDLENBQUMyaUgsR0FBR3dFLE9BQU8sQ0FBQ3RoSCxFQUFFLEdBQUc4OEcsR0FBR3dFLE9BQU8sQ0FBQ3RoSCxJQUFJLEVBQUUsSUFBSSxHQUFHLENBQUM4OEcsR0FBR3dFLE9BQU8sQ0FBQ3RoSCxJQUFJLEVBQUUsR0FBRzg4RyxHQUFHd0UsT0FBTyxDQUFDdGhILElBQUksRUFBRSxJQUFJO1lBQ3BHO1FBQ0Y7UUFDQTg4RyxHQUFHUSxNQUFNLENBQUNuakgsSUFBSSxDQUFDMmlILEdBQUcrQyxJQUFJLEVBQUUvQyxHQUFHZ0QsSUFBSTtRQUMvQixJQUFJMStHLElBQUcwc0g7UUFDUCxJQUFJaFIsR0FBR3dFLE9BQU8sQ0FBQzNwSCxNQUFNLEdBQUcsSUFBSSxNQUFNLEdBQUc7WUFDbkN5SixLQUFJMDdHLEdBQUdRLE1BQU0sQ0FBQzNsSCxNQUFNLEdBQUcsSUFBSTtZQUMzQm1sSCxHQUFHejZDLElBQUksR0FBR3k2QyxHQUFHUSxNQUFNLENBQUNsOEcsR0FBRTtZQUN0QjA3RyxHQUFHeDZDLElBQUksR0FBR3c2QyxHQUFHUSxNQUFNLENBQUNsOEcsS0FBSSxFQUFFO1FBQzVCLE9BQU87WUFDTEEsS0FBSTA3RyxHQUFHUSxNQUFNLENBQUMzbEgsTUFBTSxHQUFHLElBQUk7WUFDM0JtMkgsS0FBSztZQUNMaFIsR0FBR3o2QyxJQUFJLEdBQUczd0MsVUFBVW9yRixHQUFHUSxNQUFNLENBQUNsOEcsR0FBRSxFQUFFMDdHLEdBQUdRLE1BQU0sQ0FBQ2w4RyxLQUFJLEVBQUUsRUFBRTA3RyxHQUFHUSxNQUFNLENBQUNsOEcsS0FBSSxFQUFFLEVBQUUwc0g7WUFDdEVoUixHQUFHeDZDLElBQUksR0FBRzV3QyxVQUFVb3JGLEdBQUdRLE1BQU0sQ0FBQ2w4RyxLQUFJLEVBQUUsRUFBRTA3RyxHQUFHUSxNQUFNLENBQUNsOEcsS0FBSSxFQUFFLEVBQUUwN0csR0FBR1EsTUFBTSxDQUFDbDhHLEtBQUksRUFBRSxFQUFFMHNIO1FBQzVFO0lBQ0YsT0FBTyxJQUFJaFIsR0FBR08sUUFBUSxLQUFLLFlBQVk7UUFDckMsa0NBQWtDO1FBQ2xDUCxHQUFHUSxNQUFNLEdBQUc7WUFBQ1IsR0FBR3BpRixNQUFNO1lBQUVvaUYsR0FBR25pRixNQUFNO1lBQUVtaUYsR0FBRytDLElBQUk7WUFBRS9DLEdBQUdnRCxJQUFJO1NBQUM7UUFFcEQsK0JBQStCO1FBQy9CaEQsR0FBR3o2QyxJQUFJLEdBQUcsQ0FBQ3k2QyxHQUFHcGlGLE1BQU0sR0FBR29pRixHQUFHK0MsSUFBSSxHQUFHL0MsR0FBR1csV0FBVyxHQUFHWCxHQUFHYyxTQUFTLElBQUk7UUFDbEVkLEdBQUd4NkMsSUFBSSxHQUFHLENBQUN3NkMsR0FBR25pRixNQUFNLEdBQUdtaUYsR0FBR2dELElBQUksR0FBR2hELEdBQUdZLFdBQVcsR0FBR1osR0FBR2UsU0FBUyxJQUFJO0lBQ3BFLE9BQU8sSUFBSWYsR0FBR08sUUFBUSxLQUFLLFlBQVk7UUFDckNQLEdBQUdRLE1BQU0sR0FBRyxFQUFFO1FBQ2RSLEdBQUdRLE1BQU0sQ0FBQ25qSCxJQUFJLENBQUMyaUgsR0FBR3BpRixNQUFNLEVBQUVvaUYsR0FBR25pRixNQUFNO1FBQ25DbWlGLEdBQUdRLE1BQU0sQ0FBQ25qSCxJQUFJLENBQUNzRSxLQUFLLENBQUNxK0csR0FBR1EsTUFBTSxFQUFFUixHQUFHZ0UsTUFBTTtRQUN6Q2hFLEdBQUdRLE1BQU0sQ0FBQ25qSCxJQUFJLENBQUMyaUgsR0FBRytDLElBQUksRUFBRS9DLEdBQUdnRCxJQUFJO1FBQy9CLElBQUloRCxHQUFHcUUsT0FBTyxFQUFFO1lBQ2RyRSxHQUFHaVIsWUFBWSxHQUFHLEVBQUU7WUFDcEIsSUFBSyxJQUFJN3pILElBQUksR0FBR0EsSUFBSSxJQUFJNGlILEdBQUdRLE1BQU0sQ0FBQzNsSCxNQUFNLEVBQUV1QyxLQUFLLEVBQUc7Z0JBQ2hELElBQUlvN0IsU0FBU3duRixHQUFHMEosS0FBSyxDQUFDdHNILElBQUksSUFBSSxFQUFFO2dCQUNoQyxJQUFJcXBILGNBQWN6RyxHQUFHeUcsV0FBVyxDQUFDcnBILElBQUksSUFBSSxFQUFFO2dCQUMzQzRpSCxHQUFHaVIsWUFBWSxDQUFDNXpILElBQUksQ0FBQzZwSCxlQUFlO29CQUNsQy8zRyxHQUFHNndHLEdBQUdRLE1BQU0sQ0FBQ3BqSCxJQUFJLEVBQUU7b0JBQ25Cd2IsR0FBR29uRyxHQUFHUSxNQUFNLENBQUNwakgsSUFBSSxFQUFFO2dCQUNyQixHQUFHO29CQUNEK1IsR0FBRzZ3RyxHQUFHUSxNQUFNLENBQUNwakgsRUFBRTtvQkFDZndiLEdBQUdvbkcsR0FBR1EsTUFBTSxDQUFDcGpILElBQUksRUFBRTtvQkFDbkJvN0IsUUFBUUE7Z0JBQ1YsR0FBRztvQkFDRHJwQixHQUFHNndHLEdBQUdRLE1BQU0sQ0FBQ3BqSCxJQUFJLEVBQUU7b0JBQ25Cd2IsR0FBR29uRyxHQUFHUSxNQUFNLENBQUNwakgsSUFBSSxFQUFFO2dCQUNyQixHQUFHbzdCLFFBQVFpdUY7WUFDYjtRQUNGO1FBQ0EsSUFBSXpHLEdBQUdnRSxNQUFNLENBQUNucEgsTUFBTSxHQUFHLE1BQU0sR0FBRztZQUM5QixJQUFJc3BILEtBQUtuRSxHQUFHZ0UsTUFBTSxDQUFDbnBILE1BQU0sR0FBRztZQUM1QixJQUFJdXBILEtBQUtELEtBQUs7WUFDZG5FLEdBQUd6NkMsSUFBSSxHQUFHLENBQUN5NkMsR0FBR2dFLE1BQU0sQ0FBQ0ksR0FBRyxHQUFHcEUsR0FBR2dFLE1BQU0sQ0FBQ0csR0FBRyxJQUFJO1lBQzVDbkUsR0FBR3g2QyxJQUFJLEdBQUcsQ0FBQ3c2QyxHQUFHZ0UsTUFBTSxDQUFDSSxLQUFLLEVBQUUsR0FBR3BFLEdBQUdnRSxNQUFNLENBQUNHLEtBQUssRUFBRSxJQUFJO1FBQ3RELE9BQU87WUFDTCxJQUFJcmdHLEtBQUtrOEYsR0FBR2dFLE1BQU0sQ0FBQ25wSCxNQUFNLEdBQUcsSUFBSTtZQUNoQyxJQUFJLENBQUNtbEgsR0FBR3FFLE9BQU8sRUFBRTtnQkFDZnJFLEdBQUd6NkMsSUFBSSxHQUFHeTZDLEdBQUdnRSxNQUFNLENBQUNsZ0csR0FBRztnQkFDdkJrOEYsR0FBR3g2QyxJQUFJLEdBQUd3NkMsR0FBR2dFLE1BQU0sQ0FBQ2xnRyxLQUFLLEVBQUU7WUFDN0IsT0FBTztnQkFDTCxJQUFJMmdCLFFBQVE7b0JBQ1Z0MUIsR0FBRzZ3RyxHQUFHZ0UsTUFBTSxDQUFDbGdHLEdBQUc7b0JBQ2hCbEwsR0FBR29uRyxHQUFHZ0UsTUFBTSxDQUFDbGdHLEtBQUssRUFBRTtnQkFDdEI7Z0JBQ0EsSUFBSTZaLFNBQVNxaUYsR0FBR2lSLFlBQVksQ0FBQ250RyxLQUFLLEVBQUU7Z0JBQ3BDLElBQUk2WixPQUFPbkYsTUFBTSxLQUFLLEdBQUc7b0JBQ3ZCLHNCQUFzQjtvQkFDdEIsSUFBSSt0RixZQUFZO3dCQUNkcDNHLEdBQUc2d0csR0FBR2dFLE1BQU0sQ0FBQ2xnRyxLQUFLLEVBQUU7d0JBQ3BCbEwsR0FBR29uRyxHQUFHZ0UsTUFBTSxDQUFDbGdHLEtBQUssRUFBRTtvQkFDdEI7b0JBQ0FrOEYsR0FBR3o2QyxJQUFJLEdBQUc5Z0MsTUFBTXQxQixDQUFDO29CQUNqQjZ3RyxHQUFHeDZDLElBQUksR0FBRy9nQyxNQUFNN3JCLENBQUM7b0JBQ2pCb25HLEdBQUdzRSxTQUFTLEdBQUc7d0JBQUM3L0UsTUFBTTdyQixDQUFDLEdBQUcydEcsVUFBVTN0RyxDQUFDO3dCQUFFMnRHLFVBQVVwM0csQ0FBQyxHQUFHczFCLE1BQU10MUIsQ0FBQztxQkFBQztnQkFDL0QsT0FBTztvQkFDTCxvQkFBb0I7b0JBQ3BCLElBQUluTixJQUFJO3dCQUFDeWlDLE1BQU10MUIsQ0FBQyxHQUFHd3VCLE9BQU9NLEVBQUU7d0JBQUV3RyxNQUFNN3JCLENBQUMsR0FBRytrQixPQUFPdmYsRUFBRTtxQkFBQztvQkFDbEQsSUFBSTh5RyxTQUFTdnpGLE9BQU9uRixNQUFNLEdBQUc3NEIsS0FBSzJ3QixJQUFJLENBQUMzd0IsS0FBSzZ4QixHQUFHLENBQUN4dkIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxLQUFLckMsS0FBSzZ4QixHQUFHLENBQUN4dkIsQ0FBQyxDQUFDLEVBQUUsRUFBRTtvQkFDMUVBLElBQUlBLEVBQUU0TSxHQUFHLENBQUMsU0FBVXVoQixDQUFDO3dCQUNuQixPQUFPQSxJQUFJK2dHO29CQUNiO29CQUNBbFIsR0FBR3o2QyxJQUFJLEdBQUc1bkMsT0FBT00sRUFBRSxHQUFHajhCLENBQUMsQ0FBQyxFQUFFO29CQUMxQmcrRyxHQUFHeDZDLElBQUksR0FBRzduQyxPQUFPdmYsRUFBRSxHQUFHcGMsQ0FBQyxDQUFDLEVBQUU7b0JBQzFCZytHLEdBQUdzRSxTQUFTLEdBQUd0aUg7Z0JBQ2pCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQXFsSCxNQUFNOEosMEJBQTBCLEdBQUcsU0FBVW50RyxJQUFJO0lBQy9DLElBQUlnOEYsS0FBS2g4RixJQUFJLENBQUMsRUFBRSxDQUFDaGtCLFFBQVEsQ0FBQ2tnQixRQUFRO0lBQ2xDLElBQUk4L0YsR0FBRzdJLFlBQVksSUFBSTUzRyxTQUFTeWdILEdBQUdwaUYsTUFBTSxLQUFLcitCLFNBQVN5Z0gsR0FBR25pRixNQUFNLEtBQUt0K0IsU0FBU3lnSCxHQUFHK0MsSUFBSSxLQUFLeGpILFNBQVN5Z0gsR0FBR2dELElBQUksR0FBRztRQUMzR2hELEdBQUdvUixTQUFTLEdBQUc7SUFDakIsT0FBTztRQUNMLElBQUksQ0FBQ3BSLEdBQUdvUixTQUFTLEVBQUU7WUFDakJwUixHQUFHb1IsU0FBUyxHQUFHO1lBQ2ZoM0csS0FBSyxXQUFXNEosS0FBS25CLEVBQUUsS0FBSztRQUM5QjtJQUNGO0FBQ0Y7QUFDQXdrRyxNQUFNZ0sscUJBQXFCLEdBQUcsU0FBVWp4RyxLQUFLO0lBQzNDLElBQUl2QyxRQUFRLElBQUk7SUFDaEIsSUFBSSxDQUFDdUMsU0FBU0EsTUFBTXZsQixNQUFNLEtBQUssR0FBRztRQUNoQztJQUNGO0lBQ0EsSUFBSUYsSUFBSSxJQUFJO0lBQ1osSUFBSXlqQixLQUFLempCLEVBQUV5akIsRUFBRTtJQUNiLElBQUk0Z0QsZUFBZTVnRCxHQUFHNmdELGdCQUFnQjtJQUN0QyxJQUFJcXlELFlBQVksSUFBSWwwRztJQUNwQixJQUFJc3VELFNBQVMsU0FBU0EsT0FBTzZsRCxNQUFNLEVBQUV2SCxlQUFlO1FBQ2xELE9BQU8sRUFBRSxDQUFDcGtHLE1BQU0sQ0FBQ25vQixtQkFBbUI4ekgsU0FBUztZQUFDdkgsa0JBQWtCLElBQUk7U0FBRSxFQUFFM29ILElBQUksQ0FBQztJQUMvRTtJQUNBLElBQUltd0gsVUFBVSxFQUFFO0lBQ2hCLElBQUlDLGdCQUFnQixFQUFFO0lBRXRCLGtFQUFrRTtJQUNsRSxJQUFLLElBQUlyMEgsSUFBSSxHQUFHQSxJQUFJZ2pCLE1BQU12bEIsTUFBTSxFQUFFdUMsSUFBSztRQUNyQyxJQUFJNG1CLE9BQU81RCxLQUFLLENBQUNoakIsRUFBRTtRQUNuQixJQUFJdWhCLEtBQUtxRixLQUFLaGtCLFFBQVE7UUFDdEIsSUFBSXVxRSxhQUFhdm1ELEtBQUsrK0MsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztRQUVqRCwyQ0FBMkM7UUFDM0MsK0JBQStCO1FBQy9CLElBQUl1bkIsS0FBSzFFLE9BQU8sTUFBTSxDQUFDMEUsS0FBS21xRCxZQUFZLElBQUk7WUFDMUM7UUFDRjtRQUNBLElBQUk1RCxlQUFlLFlBQVk7WUFDN0JrbkQsY0FBY3AwSCxJQUFJLENBQUMybUI7WUFDbkI7UUFDRjtRQUNBLElBQUlnbUcsa0JBQWtCei9DLGVBQWUsc0JBQXNCOW5FLFNBQVM4bkUsWUFBWSxlQUFlQSxlQUFlLGNBQWNBLGVBQWUsdUJBQXVCOW5FLFNBQVM4bkUsWUFBWTtRQUN2TCxJQUFJbW5ELGVBQWVubkQsZUFBZSxzQkFBc0JBLGVBQWU7UUFDdkUsSUFBSWxuRCxNQUFNMUUsR0FBR0YsTUFBTTtRQUNuQixJQUFJbGIsTUFBTW9iLEdBQUdELE1BQU07UUFDbkIsSUFBSWl6RyxXQUFXdHVHLElBQUlxekQsU0FBUztRQUM1QixJQUFJazdDLFdBQVdydUgsSUFBSW16RSxTQUFTO1FBQzVCLElBQUk2NkMsU0FBUztZQUFDSTtZQUFVQztTQUFTLENBQUNuckcsSUFBSTtRQUN0QyxJQUFJMXFCLE1BQU0ydkUsT0FBTzZsRCxRQUFRdkg7UUFDekIsSUFBSTZILGFBQWFQLFVBQVVuMEcsR0FBRyxDQUFDcGhCO1FBQy9CLElBQUk4MUgsY0FBYyxNQUFNO1lBQ3RCQSxhQUFhO2dCQUNYM3BHLE1BQU0sRUFBRTtZQUNWO1lBQ0FzcEcsUUFBUW4wSCxJQUFJLENBQUM7Z0JBQ1hrMEgsUUFBUUE7Z0JBQ1J2SCxpQkFBaUJBO1lBQ25CO1lBQ0FzSCxVQUFVeDBHLEdBQUcsQ0FBQy9nQixLQUFLODFIO1FBQ3JCO1FBQ0FBLFdBQVczcEcsSUFBSSxDQUFDN3FCLElBQUksQ0FBQzJtQjtRQUNyQixJQUFJZ21HLGlCQUFpQjtZQUNuQjZILFdBQVdDLFlBQVksR0FBRztRQUM1QjtRQUNBLElBQUlKLGNBQWM7WUFDaEJHLFdBQVdFLFNBQVMsR0FBRztRQUN6QjtJQUNGO0lBRUEsZ0RBQWdEO0lBQ2hELCtFQUErRTtJQUMvRSxJQUFJaHZHLFFBQVEsU0FBU0E7UUFDbkIsSUFBSWl2RyxhQUFhUixPQUFPLENBQUNwdEgsRUFBRSxFQUN6Qm10SCxTQUFTUyxXQUFXVCxNQUFNLEVBQzFCdkgsa0JBQWtCZ0ksV0FBV2hJLGVBQWU7UUFDOUMsSUFBSWp1SCxNQUFNMnZFLE9BQU82bEQsUUFBUXZIO1FBQ3pCLElBQUl6QyxXQUFXK0osVUFBVW4wRyxHQUFHLENBQUNwaEI7UUFDN0IsSUFBSWsySDtRQUNKLElBQUksQ0FBQzFLLFNBQVN1SyxZQUFZLEVBQUU7WUFDMUIsSUFBSTF0QyxXQUFXbWpDLFNBQVNyL0YsSUFBSSxDQUFDLEVBQUUsQ0FBQzQzRCxhQUFhLEdBQUdoaUUsTUFBTSxDQUFDLFNBQVVoakIsQ0FBQztnQkFDaEUsT0FBT0EsRUFBRXloRixlQUFlO1lBQzFCO1lBQ0FqZ0UsV0FBV2lyRyxTQUFTci9GLElBQUk7WUFDeEJrOEQsU0FBU3JtRSxPQUFPLENBQUMsU0FBVWlHLElBQUk7Z0JBQzdCLE9BQU91akcsU0FBU3IvRixJQUFJLENBQUM3cUIsSUFBSSxDQUFDMm1CO1lBQzVCO1lBRUEsd0RBQXdEO1lBQ3hEdWpHLFNBQVNyL0YsSUFBSSxDQUFDekIsSUFBSSxDQUFDLFNBQVUwNUQsS0FBSyxFQUFFTSxLQUFLO2dCQUN2QyxPQUFPTixNQUFNekosU0FBUyxLQUFLK0osTUFBTS9KLFNBQVM7WUFDNUM7UUFDRjtRQUNBLElBQUl3N0MsWUFBWTNLLFNBQVNyL0YsSUFBSSxDQUFDLEVBQUU7UUFDaEMsSUFBSTdFLE1BQU02dUcsVUFBVXp6RyxNQUFNO1FBQzFCLElBQUlsYixNQUFNMnVILFVBQVV4ekcsTUFBTTtRQUUxQiw0REFBNEQ7UUFDNUQsSUFBSTJFLElBQUlxekQsU0FBUyxLQUFLbnpFLElBQUltekUsU0FBUyxJQUFJO1lBQ3JDLElBQUl2d0MsT0FBTzlpQjtZQUNYQSxNQUFNOWY7WUFDTkEsTUFBTTRpQztRQUNSO1FBQ0EsSUFBSXFpRixTQUFTakIsU0FBU2lCLE1BQU0sR0FBR25sRyxJQUFJekUsUUFBUTtRQUMzQyxJQUFJNnBHLFNBQVNsQixTQUFTa0IsTUFBTSxHQUFHbGxILElBQUlxYixRQUFRO1FBQzNDLElBQUk4cEcsT0FBT25CLFNBQVNtQixJQUFJLEdBQUdybEcsSUFBSThtRCxVQUFVO1FBQ3pDLElBQUl5K0MsT0FBT3JCLFNBQVNxQixJQUFJLEdBQUd2bEcsSUFBSSttRCxXQUFXO1FBQzFDLElBQUl1K0MsT0FBT3BCLFNBQVNvQixJQUFJLEdBQUdwbEgsSUFBSTRtRSxVQUFVO1FBQ3pDLElBQUkwK0MsT0FBT3RCLFNBQVNzQixJQUFJLEdBQUd0bEgsSUFBSTZtRSxXQUFXO1FBQzFDLElBQUk0a0QsV0FBV3pILFNBQVN5SCxRQUFRLEdBQUdyMEgsRUFBRWl1RSxVQUFVLENBQUMvcUQsTUFBTW9pRyxZQUFZLENBQUM1OEYsS0FBSztRQUN4RSxJQUFJNHJHLFdBQVcxSCxTQUFTMEgsUUFBUSxHQUFHdDBILEVBQUVpdUUsVUFBVSxDQUFDL3FELE1BQU1vaUcsWUFBWSxDQUFDMThHLEtBQUs7UUFDeEUsSUFBSTJySCxrQkFBa0IzSCxTQUFTMkgsZUFBZSxHQUFHN3JHLElBQUkwL0MsTUFBTSxDQUFDLGlCQUFpQnRtRSxLQUFLLEtBQUssU0FBUyxTQUFTNG1CLElBQUkwL0MsTUFBTSxDQUFDLGlCQUFpQkMsT0FBTztRQUM1SSxJQUFJbXNELGtCQUFrQjVILFNBQVM0SCxlQUFlLEdBQUc1ckgsSUFBSXcvRCxNQUFNLENBQUMsaUJBQWlCdG1FLEtBQUssS0FBSyxTQUFTLFNBQVM4RyxJQUFJdy9ELE1BQU0sQ0FBQyxpQkFBaUJDLE9BQU87UUFDNUksSUFBSXFzRCxRQUFROUgsU0FBUzhILEtBQUssR0FBRzlySCxJQUFJdkQsUUFBUSxDQUFDa2dCLFFBQVE7UUFDbEQsSUFBSWt2RyxRQUFRN0gsU0FBUzZILEtBQUssR0FBRy9yRyxJQUFJcmpCLFFBQVEsQ0FBQ2tnQixRQUFRO1FBQ2xEcW5HLFNBQVMwQyxTQUFTLEdBQUc7WUFDbkIsU0FBUztZQUNULFFBQVE7WUFDUixTQUFTO1lBQ1QsUUFBUTtZQUNSLGFBQWE7WUFDYixhQUFhO1lBQ2IsYUFBYTtZQUNiLGFBQWE7UUFDZjtRQUNBLElBQUssSUFBSXZtRyxNQUFNLEdBQUdBLE1BQU02akcsU0FBU3IvRixJQUFJLENBQUNydEIsTUFBTSxFQUFFNm9CLE1BQU87WUFDbkQsSUFBSTJMLFFBQVFrNEYsU0FBU3IvRixJQUFJLENBQUN4RSxJQUFJO1lBQzlCLElBQUlzOEYsS0FBSzN3RixLQUFLLENBQUMsRUFBRSxDQUFDcnZCLFFBQVEsQ0FBQ2tnQixRQUFRO1lBQ25DLElBQUlpeUcsY0FBYzlpRyxNQUFNMHpDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7WUFDbkQsSUFBSTIxSCxtQkFBbUJELGdCQUFnQixzQkFBc0IxdkgsU0FBUzB2SCxhQUFhLGVBQWUxdkgsU0FBUzB2SCxhQUFhO1lBRXhILCtFQUErRTtZQUMvRSxJQUFJOUcsZ0JBQWdCLENBQUNob0csSUFBSUUsSUFBSSxDQUFDOEwsTUFBTTVRLE1BQU07WUFDMUMsSUFBSSxDQUFDOG9HLFNBQVM4SyxzQkFBc0IsSUFBSWh2RyxRQUFROWYsT0FBUWdrSCxDQUFBQSxTQUFTd0ssU0FBUyxJQUFJeEssU0FBU3VLLFlBQVksR0FBRztnQkFDcEd2SyxTQUFTOEssc0JBQXNCLEdBQUc7Z0JBRWxDLHFFQUFxRTtnQkFDckUsSUFBSUMsYUFBYXRELFNBQVN1QixhQUFhLENBQUMvSCxPQUFPcjVHLENBQUMsRUFBRXE1RyxPQUFPNXZHLENBQUMsRUFBRTh2RyxNQUFNRSxNQUFNSCxPQUFPdDVHLENBQUMsRUFBRXM1RyxPQUFPN3ZHLENBQUMsRUFBRSxHQUFHczJHLGlCQUFpQkU7Z0JBQ2hILElBQUltRCxVQUFVaEwsU0FBU2dMLE9BQU8sR0FBR0Q7Z0JBRWpDLHFFQUFxRTtnQkFDckUsSUFBSUUsYUFBYXZELFNBQVNzQixhQUFhLENBQUM5SCxPQUFPdDVHLENBQUMsRUFBRXM1RyxPQUFPN3ZHLENBQUMsRUFBRSt2RyxNQUFNRSxNQUFNTCxPQUFPcjVHLENBQUMsRUFBRXE1RyxPQUFPNXZHLENBQUMsRUFBRSxHQUFHdTJHLGlCQUFpQkU7Z0JBQ2hILElBQUlvRCxVQUFVbEwsU0FBU2tMLE9BQU8sR0FBR0Q7Z0JBQ2pDLElBQUkvSyxrQkFBa0JGLFNBQVNFLGVBQWUsR0FBRztvQkFDL0NobkgsSUFBSTZ4SCxVQUFVLENBQUMsRUFBRTtvQkFDakI1eEgsSUFBSTh4SCxVQUFVLENBQUMsRUFBRTtvQkFDakI3eEgsSUFBSTJ4SCxVQUFVLENBQUMsRUFBRTtvQkFDakIxeEgsSUFBSTR4SCxVQUFVLENBQUMsRUFBRTtnQkFDbkI7Z0JBQ0EsSUFBSWhMLFNBQVNELFNBQVNDLE1BQU0sR0FBRztvQkFDN0IvbUgsSUFBSStuSCxPQUFPcjVHLENBQUM7b0JBQ1p6TyxJQUFJK25ILE9BQU90NUcsQ0FBQztvQkFDWnhPLElBQUk2bkgsT0FBTzV2RyxDQUFDO29CQUNaaFksSUFBSTZuSCxPQUFPN3ZHLENBQUM7Z0JBQ2Q7Z0JBQ0EsSUFBSThiLEtBQUs4OUYsVUFBVSxDQUFDLEVBQUUsR0FBR0YsVUFBVSxDQUFDLEVBQUU7Z0JBQ3RDLElBQUk3OUYsS0FBSys5RixVQUFVLENBQUMsRUFBRSxHQUFHRixVQUFVLENBQUMsRUFBRTtnQkFDdEMsSUFBSW4xSCxJQUFJd0MsS0FBSzJ3QixJQUFJLENBQUNtRSxLQUFLQSxLQUFLQyxLQUFLQTtnQkFDakMsSUFBSW4xQixTQUFTcEMsTUFBTUEsS0FBS2lxSDtxQkFBMkM7b0JBQ2pFanFILElBQUl3QyxLQUFLMndCLElBQUksQ0FBQzN3QixLQUFLNlUsR0FBRyxDQUFDaWdCLEtBQUtBLElBQUkweUYsb0NBQW9DeG5ILEtBQUs2VSxHQUFHLENBQUNrZ0IsS0FBS0EsSUFBSXl5RjtnQkFDeEY7Z0JBQ0EsSUFBSXVMLFNBQVNuTCxTQUFTbUwsTUFBTSxHQUFHO29CQUM3QnZqSCxHQUFHc2xCO29CQUNIN2IsR0FBRzhiO2dCQUNMO2dCQUNBLElBQUlpK0YsYUFBYXBMLFNBQVNvTCxVQUFVLEdBQUc7b0JBQ3JDeGpILEdBQUd1akgsT0FBT3ZqSCxDQUFDLEdBQUdoUztvQkFDZHliLEdBQUc4NUcsT0FBTzk1RyxDQUFDLEdBQUd6YjtnQkFDaEI7Z0JBQ0EsSUFBSXVxSCxvQkFBb0I7b0JBQ3RCdjRHLEdBQUcsQ0FBQ3dqSCxXQUFXLzVHLENBQUM7b0JBQ2hCQSxHQUFHKzVHLFdBQVd4akgsQ0FBQztnQkFDakI7Z0JBRUEsbURBQW1EO2dCQUNuRG80RyxTQUFTcFEsWUFBWSxHQUFHLENBQUM1M0csU0FBU3BDLE1BQU04eEgsU0FBUy9PLFVBQVUsQ0FBQ29TLFVBQVUsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsQ0FBQyxFQUFFLEVBQUUsR0FBRzNKLE1BQU1FLE1BQU1KLE9BQU90NUcsQ0FBQyxFQUFFczVHLE9BQU83dkcsQ0FBQyxFQUFFdTJHLGlCQUFpQkUsVUFBVUwsU0FBUzlPLFVBQVUsQ0FBQ3NTLFVBQVUsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsQ0FBQyxFQUFFLEVBQUUsR0FBRzlKLE1BQU1FLE1BQU1KLE9BQU9yNUcsQ0FBQyxFQUFFcTVHLE9BQU81dkcsQ0FBQyxFQUFFczJHLGlCQUFpQkU7Z0JBQzlQN0gsU0FBU0csaUJBQWlCLEdBQUdBO2dCQUM3QnVLLGtCQUFrQjtvQkFDaEI5YSxjQUFjb1EsU0FBU3BRLFlBQVk7b0JBQ25DOFMsV0FBVzFDLFNBQVMwQyxTQUFTO29CQUM3Qm9JLHdCQUF3QjtvQkFDeEJOLFdBQVd4SyxTQUFTd0ssU0FBUztvQkFDN0JELGNBQWN2SyxTQUFTdUssWUFBWTtvQkFDbkM1cEcsTUFBTXEvRixTQUFTci9GLElBQUk7b0JBQ25Cc2dHLFFBQVFDO29CQUNSMkcsT0FBT0M7b0JBQ1A1RyxRQUFRRDtvQkFDUjZHLE9BQU9EO29CQUNQMUcsTUFBTUM7b0JBQ05DLE1BQU1DO29CQUNORixNQUFNRDtvQkFDTkcsTUFBTUQ7b0JBQ04ySixTQUFTRTtvQkFDVEEsU0FBU0Y7b0JBQ1R2RCxVQUFVQztvQkFDVkEsVUFBVUQ7b0JBQ1Z4SCxRQUFRO3dCQUNOL21ILElBQUkrbUgsT0FBTzltSCxFQUFFO3dCQUNiQyxJQUFJNm1ILE9BQU81bUgsRUFBRTt3QkFDYkYsSUFBSThtSCxPQUFPL21ILEVBQUU7d0JBQ2JHLElBQUk0bUgsT0FBTzdtSCxFQUFFO29CQUNmO29CQUNBOG1ILGlCQUFpQjt3QkFDZmhuSCxJQUFJZ25ILGdCQUFnQi9tSCxFQUFFO3dCQUN0QkMsSUFBSThtSCxnQkFBZ0I3bUgsRUFBRTt3QkFDdEJGLElBQUkrbUgsZ0JBQWdCaG5ILEVBQUU7d0JBQ3RCRyxJQUFJNm1ILGdCQUFnQjltSCxFQUFFO29CQUN4QjtvQkFDQSt4SCxRQUFRO3dCQUNOdmpILEdBQUcsQ0FBQ3VqSCxPQUFPdmpILENBQUM7d0JBQ1p5SixHQUFHLENBQUM4NUcsT0FBTzk1RyxDQUFDO29CQUNkO29CQUNBKzVHLFlBQVk7d0JBQ1Z4akgsR0FBRyxDQUFDd2pILFdBQVd4akgsQ0FBQzt3QkFDaEJ5SixHQUFHLENBQUMrNUcsV0FBVy81RyxDQUFDO29CQUNsQjtvQkFDQTh1RyxtQkFBbUI7d0JBQ2pCdjRHLEdBQUcsQ0FBQ3U0RyxrQkFBa0J2NEcsQ0FBQzt3QkFDdkJ5SixHQUFHLENBQUM4dUcsa0JBQWtCOXVHLENBQUM7b0JBQ3pCO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJZzZHLGlCQUFpQnZILGdCQUFnQjRHLGtCQUFrQjFLO1lBQ3ZEdkgsR0FBRzdJLFlBQVksR0FBR3liLGVBQWV6YixZQUFZO1lBQzdDNkksR0FBR3VTLE9BQU8sR0FBR0ssZUFBZUwsT0FBTztZQUNuQ3ZTLEdBQUd5UyxPQUFPLEdBQUdHLGVBQWVILE9BQU87WUFDbkN6UyxHQUFHcUUsT0FBTyxHQUFHOE4sWUFBWVUsVUFBVSxDQUFDO1lBQ3BDLElBQUk3ekQsZ0JBQWlCMzdDLENBQUFBLElBQUkreEMsUUFBUSxNQUFNL3hDLElBQUlpeUMsT0FBTyxNQUFNL3hELElBQUk2eEQsUUFBUSxNQUFNN3hELElBQUkreEQsT0FBTyxFQUFDLEtBQU9qeUMsQ0FBQUEsSUFBSTY2QyxPQUFPLEdBQUdmLE9BQU8sQ0FBQzU1RCxRQUFRQSxJQUFJMjZELE9BQU8sR0FBR2YsT0FBTyxDQUFDOTVDLFFBQVFBLElBQUlFLElBQUksQ0FBQ2hnQixRQUFROGYsSUFBSSt4QyxRQUFRLEVBQUMsR0FBSTtnQkFDekx2M0MsTUFBTThzRyxzQkFBc0IsQ0FBQ3Q3RixPQUFPdWpHLGdCQUFnQmx2RyxLQUFLMHVHO1lBQzNELE9BQU8sSUFBSS91RyxRQUFROWYsS0FBSztnQkFDdEJzYSxNQUFNa3NHLGNBQWMsQ0FBQzE2RixPQUFPdWpHLGdCQUFnQmx2RyxLQUFLMHVHO1lBQ25ELE9BQU8sSUFBSUQsWUFBWTF2SCxRQUFRLENBQUMsYUFBYTtnQkFDM0NvYixNQUFNcXJHLGtCQUFrQixDQUFDNzVGLE9BQU91akc7WUFDbEMsT0FBTyxJQUFJVCxZQUFZMXZILFFBQVEsQ0FBQyxTQUFTO2dCQUN2Q29iLE1BQU1rdUcsY0FBYyxDQUFDMThGLE9BQU91akc7WUFDOUIsT0FBTyxJQUFJVCxnQkFBZ0IsY0FBYyxDQUFDQyxvQkFBb0I3SyxTQUFTci9GLElBQUksQ0FBQ3J0QixNQUFNLEdBQUcsTUFBTSxLQUFLNm9CLFFBQVEvakIsS0FBS0MsS0FBSyxDQUFDMm5ILFNBQVNyL0YsSUFBSSxDQUFDcnRCLE1BQU0sR0FBRyxJQUFJO2dCQUM1SWdqQixNQUFNc3RHLHNCQUFzQixDQUFDOTdGO1lBQy9CLE9BQU87Z0JBQ0x4UixNQUFNdXRHLGdCQUFnQixDQUFDLzdGLE9BQU91akcsZ0JBQWdCbHZHLEtBQUswdUcsa0JBQWtCL0c7WUFDdkU7WUFDQXh0RyxNQUFNaXpHLGFBQWEsQ0FBQ3poRztZQUNwQnhSLE1BQU1reEcseUJBQXlCLENBQUMxL0YsT0FBT3VqRztZQUN2Qy8wRyxNQUFNc3pHLDBCQUEwQixDQUFDOWhHO1lBQ2pDeFIsTUFBTWt6RyxXQUFXLENBQUMxaEc7WUFDbEJ4UixNQUFNa3JHLG9CQUFvQixDQUFDMTVGO1lBQzNCeFIsTUFBTTZsRyxvQkFBb0IsQ0FBQ3IwRjtZQUMzQnhSLE1BQU1tckcsK0JBQStCLENBQUMzNUY7WUFDdEN4UixNQUFNb3JHLG9CQUFvQixDQUFDNTVGO1FBQzdCLEVBQUUsaUJBQWlCO0lBQ3JCO0lBQ0EsSUFBSyxJQUFJanJCLElBQUksR0FBR0EsSUFBSW90SCxRQUFRMzJILE1BQU0sRUFBRXVKLElBQUs7UUFDdkMyZTtJQUNGLEVBQUUsZUFBZTtJQUVqQixxRUFBcUU7SUFDckUsSUFBSSxDQUFDdWxHLGtCQUFrQixDQUFDbUo7QUFDMUI7QUFDQSxTQUFTcUIsT0FBTzc3RixHQUFHO0lBQ2pCLElBQUlvbEYsU0FBUyxFQUFFO0lBQ2YsSUFBSXBsRixPQUFPLE1BQU07UUFDZjtJQUNGO0lBQ0EsSUFBSyxJQUFJNzVCLElBQUksR0FBR0EsSUFBSTY1QixJQUFJcDhCLE1BQU0sRUFBRXVDLEtBQUssRUFBRztRQUN0QyxJQUFJK1IsSUFBSThuQixHQUFHLENBQUM3NUIsRUFBRTtRQUNkLElBQUl3YixJQUFJcWUsR0FBRyxDQUFDNzVCLElBQUksRUFBRTtRQUNsQmkvRyxPQUFPaC9HLElBQUksQ0FBQztZQUNWOFIsR0FBR0E7WUFDSHlKLEdBQUdBO1FBQ0w7SUFDRjtJQUNBLE9BQU95akc7QUFDVDtBQUNBZ0wsTUFBTTE0QyxnQkFBZ0IsR0FBRyxTQUFVM3FELElBQUk7SUFDckMsSUFBSWc4RixLQUFLaDhGLElBQUksQ0FBQyxFQUFFLENBQUNoa0IsUUFBUSxDQUFDa2dCLFFBQVE7SUFDbEMsSUFBSSxDQUFDdXNELHdCQUF3QixDQUFDem9EO0lBQzlCLElBQUl0VSxPQUFPc3dHLEdBQUdPLFFBQVE7SUFDdEIsSUFBSTd3RyxTQUFTLFlBQVk7UUFDdkIsT0FBT29qSCxPQUFPOVMsR0FBR2dFLE1BQU07SUFDekI7QUFDRjtBQUNBcUQsTUFBTTU0QyxnQkFBZ0IsR0FBRyxTQUFVenFELElBQUk7SUFDckMsSUFBSWc4RixLQUFLaDhGLElBQUksQ0FBQyxFQUFFLENBQUNoa0IsUUFBUSxDQUFDa2dCLFFBQVE7SUFDbEMsSUFBSSxDQUFDdXNELHdCQUF3QixDQUFDem9EO0lBQzlCLElBQUl0VSxPQUFPc3dHLEdBQUdPLFFBQVE7SUFDdEIsSUFBSTd3RyxTQUFTLFlBQVlBLFNBQVMsaUJBQWlCQSxTQUFTLFVBQVVBLFNBQVMsWUFBWTtRQUN6RixPQUFPb2pILE9BQU85UyxHQUFHd0UsT0FBTztJQUMxQjtBQUNGO0FBQ0E2QyxNQUFNcDRDLGVBQWUsR0FBRyxTQUFVanJELElBQUk7SUFDcEMsSUFBSWc4RixLQUFLaDhGLElBQUksQ0FBQyxFQUFFLENBQUNoa0IsUUFBUSxDQUFDa2dCLFFBQVE7SUFDbEMsSUFBSSxDQUFDdXNELHdCQUF3QixDQUFDem9EO0lBQzlCLE9BQU87UUFDTDdVLEdBQUc2d0csR0FBR3o2QyxJQUFJO1FBQ1Yzc0QsR0FBR29uRyxHQUFHeDZDLElBQUk7SUFDWjtBQUNGO0FBRUEsSUFBSXV0RCxRQUFRLENBQUM7QUFDYkEsTUFBTTlLLGVBQWUsR0FBRyxTQUFVbGtHLElBQUksRUFBRW01QixJQUFJO0lBQzFDLElBQUl2aUQsSUFBSSxJQUFJO0lBQ1osSUFBSXE0SCxPQUFPanZHLEtBQUtuRixRQUFRO0lBQ3hCLElBQUk5RSxJQUFJaUssS0FBS29tRCxVQUFVO0lBQ3ZCLElBQUlqbUUsSUFBSTZmLEtBQUtxbUQsV0FBVztJQUN4QixJQUFJNDFDLEtBQUtqOEYsS0FBSy9qQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJZzlCLEtBQUt6Z0QsS0FBSyxDQUFDNUIsTUFBTSxLQUFLLEdBQUc7UUFDM0IsSUFBSXVKLElBQUk7WUFBQzg0QyxLQUFLOGxCLE9BQU8sQ0FBQyxFQUFFO1lBQUU5bEIsS0FBSzhsQixPQUFPLENBQUMsRUFBRTtTQUFDO1FBQzFDLElBQUk5bEIsS0FBSzJtQixLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUs7WUFDekJ6L0QsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBRzBWO1FBQ2hCO1FBQ0EsSUFBSW9qQyxLQUFLMm1CLEtBQUssQ0FBQyxFQUFFLEtBQUssS0FBSztZQUN6QnovRCxDQUFDLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRSxHQUFHRjtRQUNoQjtRQUNBRSxDQUFDLENBQUMsRUFBRSxJQUFJNHVILEtBQUs3akgsQ0FBQztRQUNkL0ssQ0FBQyxDQUFDLEVBQUUsSUFBSTR1SCxLQUFLcDZHLENBQUM7UUFDZCxPQUFPeFU7SUFDVCxPQUFPO1FBQ0wsSUFBSSs0QixRQUFRK2YsS0FBSzhsQixPQUFPLENBQUMsRUFBRTtRQUMzQjdsQyxRQUFRLENBQUN4OUIsS0FBS3NaLEVBQUUsR0FBRyxJQUFJa2tCLE9BQU8sc0JBQXNCO1FBRXBELElBQUloZ0MsSUFBSSxJQUFJd0MsS0FBSzZVLEdBQUcsQ0FBQ3NGLEdBQUc1VjtRQUN4QixJQUFJeWEsS0FBSztZQUFDcTBHLEtBQUs3akgsQ0FBQyxHQUFHeFAsS0FBS3daLEdBQUcsQ0FBQ2drQixTQUFTaGdDO1lBQUc2MUgsS0FBS3A2RyxDQUFDLEdBQUdqWixLQUFLeVosR0FBRyxDQUFDK2pCLFNBQVNoZ0M7U0FBRTtRQUNyRSxPQUFPeEMsRUFBRWl1RSxVQUFVLENBQUMsSUFBSSxDQUFDcTNDLFlBQVksQ0FBQ2w4RixNQUFNLENBQUN3c0csYUFBYSxDQUFDeUMsS0FBSzdqSCxDQUFDLEVBQUU2akgsS0FBS3A2RyxDQUFDLEVBQUVrQixHQUFHNVYsR0FBR3lhLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBR29GLEtBQUtnL0MsTUFBTSxDQUFDLGlCQUFpQnRtRSxLQUFLLEtBQUssU0FBUyxTQUFTc25CLEtBQUtnL0MsTUFBTSxDQUFDLGlCQUFpQkMsT0FBTyxFQUFFZzlDO0lBQ25NO0FBQ0Y7QUFDQStTLE1BQU1qQyxhQUFhLEdBQUcsU0FBVTlzRyxJQUFJO0lBQ2xDLElBQUlnQyxNQUFNaXRHLHNCQUFzQjE4RCxPQUFPMjhEO0lBQ3ZDLElBQUl2NEgsSUFBSSxJQUFJO0lBQ1osSUFBSXN1QjtJQUNKLElBQUl4SyxTQUFTdUYsS0FBS3ZGLE1BQU0sRUFBRSxDQUFDLEVBQUU7SUFDN0IsSUFBSUMsU0FBU3NGLEtBQUt0RixNQUFNLEVBQUUsQ0FBQyxFQUFFO0lBQzdCLElBQUk4cEcsU0FBUy9wRyxPQUFPRyxRQUFRO0lBQzVCLElBQUk2cEcsU0FBUy9wRyxPQUFPRSxRQUFRO0lBQzVCLElBQUl1MEcsYUFBYW52RyxLQUFLKytDLE1BQU0sQ0FBQyxzQkFBc0J0bUUsS0FBSztJQUN4RCxJQUFJMjJILGFBQWFwdkcsS0FBSysrQyxNQUFNLENBQUMsc0JBQXNCdG1FLEtBQUs7SUFDeEQsSUFBSWl6QixVQUFVMUwsS0FBSysrQyxNQUFNLENBQUMsNkJBQTZCQyxPQUFPO0lBQzlELElBQUl2ekMsVUFBVXpMLEtBQUsrK0MsTUFBTSxDQUFDLDZCQUE2QkMsT0FBTztJQUM5RCxJQUFJb3NELFFBQVEzd0csT0FBT3plLFFBQVEsQ0FBQ2tnQixRQUFRO0lBQ3BDLElBQUltdkcsUUFBUTN3RyxPQUFPMWUsUUFBUSxDQUFDa2dCLFFBQVE7SUFDcEMsSUFBSXFxRCxhQUFhdm1ELEtBQUsrK0MsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztJQUNqRCxJQUFJdWpILEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJbXpHLEtBQUtyVCxHQUFHTyxRQUFRO0lBQ3BCLElBQUkrUyxPQUFPN3dILFNBQVM4bkUsWUFBWSxTQUFTLDZCQUE2QjtJQUN0RSxJQUFJL29FLFFBQU82eEgsT0FBTyxVQUFVQSxPQUFPO0lBQ25DLElBQUlscUMsU0FBU2txQyxPQUFPLFlBQVlBLE9BQU8saUJBQWlCN3hIO0lBQ3hELElBQUlpcUgsUUFBUTRILE9BQU87SUFDbkIsSUFBSW54RixRQUFRbXhGLE9BQU8sY0FBY0EsT0FBTztJQUN4QyxJQUFJRSxXQUFXRixPQUFPO0lBQ3RCLElBQUlHLFlBQVlycUMsVUFBVXNpQyxTQUFTdnBGO0lBQ25DLElBQUl1eEYsaUJBQWlCanlILFNBQVE4eEg7SUFDN0IsSUFBSTFMLGNBQWM1akcsS0FBSysrQyxNQUFNLENBQUM7SUFDOUIsSUFBSTJ3RCxpQkFBaUJELGlCQUFpQixvQkFBb0I3TCxZQUFZbnJILEtBQUs7SUFDM0UsSUFBSXl5SCxrQkFBa0J6d0csT0FBT3NrRCxNQUFNLENBQUMsaUJBQWlCdG1FLEtBQUssS0FBSyxTQUFTLFNBQVNnaUIsT0FBT3NrRCxNQUFNLENBQUMsaUJBQWlCQyxPQUFPO0lBQ3ZILElBQUk2a0QsY0FBYzdqRyxLQUFLKytDLE1BQU0sQ0FBQztJQUM5QixJQUFJNHdELGlCQUFpQkYsaUJBQWlCLG9CQUFvQjVMLFlBQVlwckgsS0FBSztJQUMzRSxJQUFJMHlILGtCQUFrQnp3RyxPQUFPcWtELE1BQU0sQ0FBQyxpQkFBaUJ0bUUsS0FBSyxLQUFLLFNBQVMsU0FBU2lpQixPQUFPcWtELE1BQU0sQ0FBQyxpQkFBaUJDLE9BQU87SUFDdkhnOUMsR0FBRzRILFdBQVcsR0FBR0E7SUFDakI1SCxHQUFHNkgsV0FBVyxHQUFHQTtJQUNqQixJQUFJdnpGLElBQUksMENBQTBDO0lBQ2xELElBQUlDLElBQUksMENBQTBDO0lBRWxELElBQUlxL0YsTUFBTSx1Q0FBdUM7SUFDakQsSUFBSUMsTUFBTSx1Q0FBdUM7SUFFakQsSUFBSUMsZ0JBQWdCLENBQUM5dEcsT0FBTyxDQUFDNmhHLGdCQUFnQixRQUFRQSxnQkFBZ0JqcUgsYUFBYSxDQUFDcTFILHVCQUF1QnBMLFlBQVk3a0QsT0FBTyxNQUFNLFFBQVFpd0QseUJBQXlCcjFILFlBQVlBLFlBQVlxMUgscUJBQXFCcDRILE1BQU0sTUFBTSxJQUFJZ3RILFlBQVk3a0QsT0FBTyxHQUFHLElBQUcsTUFBTyxRQUFRaDlDLFNBQVNwb0IsWUFBWW9vQixPQUFPO1FBQUM7UUFBRztLQUFFO0lBQzNTLElBQUkrdEcsZ0JBQWdCLENBQUN4OUQsUUFBUSxDQUFDcXhELGdCQUFnQixRQUFRQSxnQkFBZ0JocUgsYUFBYSxDQUFDczFILHVCQUF1QnRMLFlBQVk1a0QsT0FBTyxNQUFNLFFBQVFrd0QseUJBQXlCdDFILFlBQVlBLFlBQVlzMUgscUJBQXFCcjRILE1BQU0sTUFBTSxJQUFJK3NILFlBQVk1a0QsT0FBTyxHQUFHLElBQUcsTUFBTyxRQUFRek0sVUFBVTM0RCxZQUFZMjRELFFBQVE7UUFBQztRQUFHO0tBQUU7SUFDOVMsSUFBSTR5QixRQUFRO1FBQ1YsSUFBSTZxQyxVQUFVO1lBQUNoVSxHQUFHd0UsT0FBTyxDQUFDLEVBQUU7WUFBRXhFLEdBQUd3RSxPQUFPLENBQUMsRUFBRTtTQUFDO1FBQzVDLElBQUl5UCxRQUFReEksUUFBUTtZQUFDekwsR0FBR3dFLE9BQU8sQ0FBQ3hFLEdBQUd3RSxPQUFPLENBQUMzcEgsTUFBTSxHQUFHLEVBQUU7WUFBRW1sSCxHQUFHd0UsT0FBTyxDQUFDeEUsR0FBR3dFLE9BQU8sQ0FBQzNwSCxNQUFNLEdBQUcsRUFBRTtTQUFDLEdBQUdtNUg7UUFDN0YxL0YsS0FBSzIvRjtRQUNMMS9GLEtBQUt5L0Y7SUFDUCxPQUFPLElBQUk5eEYsT0FBTztRQUNoQixJQUFJZ3lGLGlCQUFpQixDQUFDWCxXQUFXO1lBQUM5SyxPQUFPdDVHLENBQUMsR0FBRzJrSCxhQUFhLENBQUMsRUFBRTtZQUFFckwsT0FBTzd2RyxDQUFDLEdBQUdrN0csYUFBYSxDQUFDLEVBQUU7U0FBQyxHQUFHOVQsR0FBR2dFLE1BQU0sQ0FBQy9sSCxLQUFLLENBQUMsR0FBRztRQUNqSCxJQUFJazJILGlCQUFpQixDQUFDWixXQUFXO1lBQUMvSyxPQUFPcjVHLENBQUMsR0FBRzRrSCxhQUFhLENBQUMsRUFBRTtZQUFFdkwsT0FBTzV2RyxDQUFDLEdBQUdtN0csYUFBYSxDQUFDLEVBQUU7U0FBQyxHQUFHL1QsR0FBR2dFLE1BQU0sQ0FBQy9sSCxLQUFLLENBQUMraEgsR0FBR2dFLE1BQU0sQ0FBQ25wSCxNQUFNLEdBQUc7UUFDakl5NUIsS0FBSzYvRjtRQUNMNS9GLEtBQUsyL0Y7SUFDUDtJQUNBLElBQUlQLG1CQUFtQixrQkFBa0I7UUFDdkMxcUcsWUFBWTtZQUFDdy9GLE9BQU90NUcsQ0FBQztZQUFFczVHLE9BQU83dkcsQ0FBQztTQUFDO0lBQ2xDLE9BQU8sSUFBSWl2RyxZQUFZaGtELEtBQUssRUFBRTtRQUM1QjU2QyxZQUFZLElBQUksQ0FBQ2cvRixlQUFlLENBQUN2cEcsUUFBUW1wRztJQUMzQyxPQUFPLElBQUk4TCxtQkFBbUIsbUJBQW1CO1FBQy9DMXFHLFlBQVkrMkYsR0FBR3lTLE9BQU8sRUFBRSxvQ0FBb0M7SUFDOUQsT0FBTztRQUNMLElBQUlrQixtQkFBbUIscUJBQXFCQSxtQkFBbUIsNEJBQTRCO1lBQ3pGQyxPQUFPdC9GO1FBQ1QsT0FBTyxJQUFJcS9GLG1CQUFtQixxQkFBcUJBLG1CQUFtQiw0QkFBNEI7WUFDaEdDLE9BQU87Z0JBQUNwTCxPQUFPcjVHLENBQUM7Z0JBQUVxNUcsT0FBTzV2RyxDQUFDO2FBQUM7UUFDN0I7UUFDQXFRLFlBQVl0dUIsRUFBRWl1RSxVQUFVLENBQUMsSUFBSSxDQUFDcTNDLFlBQVksQ0FBQ3ZoRyxRQUFRLENBQUM2eEcsYUFBYSxDQUFDOUgsT0FBT3Q1RyxDQUFDLEVBQUVzNUcsT0FBTzd2RyxDQUFDLEVBQUU4RixPQUFPeXJELFVBQVUsSUFBSXpyRCxPQUFPMHJELFdBQVcsSUFBSXdwRCxJQUFJLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUd6RSxpQkFBaUJFO1FBQ3ZLLElBQUlzRSxtQkFBbUIsOEJBQThCQSxtQkFBbUIsNEJBQTRCO1lBQ2xHLElBQUlTLE1BQU0xMUcsT0FBTzFlLFFBQVEsQ0FBQ2tnQixRQUFRO1lBQ2xDLElBQUkwbUQsS0FBS3d0RCxJQUFJcHVELFVBQVU7WUFDdkIsSUFBSVcsS0FBS3l0RCxJQUFJbnVELFdBQVc7WUFDeEIsSUFBSW15QyxLQUFLZ2MsSUFBSWx1RCxNQUFNO1lBQ25CLElBQUlteUMsS0FBSytiLElBQUlqdUQsTUFBTTtZQUNuQixJQUFJa3VELE1BQU16dEQsS0FBSztZQUNmLElBQUkwdEQsTUFBTTN0RCxLQUFLO1lBQ2YsSUFBSTR0RCxLQUFLNzFHLE9BQU9xa0QsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztZQUMzQyxJQUFJODNILE9BQU8sT0FBTztnQkFDaEJsYyxNQUFNaWM7WUFDUixPQUFPLElBQUlDLE9BQU8sVUFBVTtnQkFDMUJsYyxNQUFNaWM7WUFDUjtZQUNBLElBQUlFLEtBQUs5MUcsT0FBT3FrRCxNQUFNLENBQUMsZUFBZXRtRSxLQUFLO1lBQzNDLElBQUkrM0gsT0FBTyxRQUFRO2dCQUNqQnBjLE1BQU1pYztZQUNSLE9BQU8sSUFBSUcsT0FBTyxTQUFTO2dCQUN6QnBjLE1BQU1pYztZQUNSO1lBQ0EsSUFBSUksaUJBQWlCL3lGLHFCQUFxQmt5RixJQUFJLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsRUFBRSxFQUFFO2dCQUFDeGIsS0FBS2ljO2dCQUFLaGMsS0FBS2ljO2dCQUFLbGMsS0FBS2ljO2dCQUFLaGMsS0FBS2ljO2dCQUFLbGMsS0FBS2ljO2dCQUFLaGMsS0FBS2ljO2dCQUFLbGMsS0FBS2ljO2dCQUFLaGMsS0FBS2ljO2FBQUksRUFBRTdMLE9BQU90NUcsQ0FBQyxFQUFFczVHLE9BQU83dkcsQ0FBQztZQUNoSyxJQUFJNjdHLGVBQWU1NUgsTUFBTSxHQUFHLEdBQUc7Z0JBQzdCLElBQUk2NUgsUUFBUWxNO2dCQUNaLElBQUltTSxZQUFZbmdHLE9BQU9rZ0csT0FBT3JoRyxZQUFZcEs7Z0JBQzFDLElBQUkyckcsZUFBZXBnRyxPQUFPa2dHLE9BQU9yaEcsWUFBWW9oRztnQkFDN0MsSUFBSWpWLFlBQVltVjtnQkFDaEIsSUFBSUMsZUFBZUQsV0FBVztvQkFDNUIxckcsWUFBWXdyRztvQkFDWmpWLFlBQVlvVjtnQkFDZDtnQkFDQSxJQUFJSCxlQUFlNTVILE1BQU0sR0FBRyxHQUFHO29CQUM3QixJQUFJZzZILGdCQUFnQnJnRyxPQUFPa2dHLE9BQU87d0JBQ2hDdmxILEdBQUdzbEgsY0FBYyxDQUFDLEVBQUU7d0JBQ3BCNzdHLEdBQUc2N0csY0FBYyxDQUFDLEVBQUU7b0JBQ3RCO29CQUNBLElBQUlJLGdCQUFnQnJWLFdBQVc7d0JBQzdCdjJGLFlBQVk7NEJBQUN3ckcsY0FBYyxDQUFDLEVBQUU7NEJBQUVBLGNBQWMsQ0FBQyxFQUFFO3lCQUFDO29CQUNwRDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUlLLFdBQVd6eUYsb0JBQW9CcFosV0FBV3FMLElBQUkzNUIsRUFBRWdoSCxXQUFXLENBQUN3WCxXQUFXLENBQUMvNkMsT0FBTyxDQUFDcDBELFFBQVEwTDtJQUM1RixJQUFJcWxHLFVBQVUxeUYsb0JBQW9CcFosV0FBV3FMLElBQUkzNUIsRUFBRWdoSCxXQUFXLENBQUN3WCxXQUFXLENBQUNyVyxHQUFHLENBQUM5NEYsUUFBUTBMO0lBQ3ZGc3dGLEdBQUcrQyxJQUFJLEdBQUdnUyxPQUFPLENBQUMsRUFBRTtJQUNwQi9VLEdBQUdnRCxJQUFJLEdBQUcrUixPQUFPLENBQUMsRUFBRTtJQUNwQi9VLEdBQUdjLFNBQVMsR0FBR2dVLFFBQVEsQ0FBQyxFQUFFO0lBQzFCOVUsR0FBR2UsU0FBUyxHQUFHK1QsUUFBUSxDQUFDLEVBQUU7SUFDMUIsSUFBSXBCLG1CQUFtQixrQkFBa0I7UUFDdkN6cUcsWUFBWTtZQUFDdS9GLE9BQU9yNUcsQ0FBQztZQUFFcTVHLE9BQU81dkcsQ0FBQztTQUFDO0lBQ2xDLE9BQU8sSUFBSWd2RyxZQUFZL2pELEtBQUssRUFBRTtRQUM1QjU2QyxZQUFZLElBQUksQ0FBQ2cvRixlQUFlLENBQUN4cEcsUUFBUW1wRztJQUMzQyxPQUFPLElBQUk4TCxtQkFBbUIsbUJBQW1CO1FBQy9DenFHLFlBQVkrMkYsR0FBR3VTLE9BQU8sRUFBRSxvQ0FBb0M7SUFDOUQsT0FBTztRQUNMLElBQUltQixtQkFBbUIscUJBQXFCQSxtQkFBbUIsNEJBQTRCO1lBQ3pGRyxPQUFPdC9GO1FBQ1QsT0FBTyxJQUFJbS9GLG1CQUFtQixxQkFBcUJBLG1CQUFtQiw0QkFBNEI7WUFDaEdHLE9BQU87Z0JBQUNwTCxPQUFPdDVHLENBQUM7Z0JBQUVzNUcsT0FBTzd2RyxDQUFDO2FBQUM7UUFDN0I7UUFDQXFRLFlBQVl0dUIsRUFBRWl1RSxVQUFVLENBQUMsSUFBSSxDQUFDcTNDLFlBQVksQ0FBQ3hoRyxRQUFRLENBQUM4eEcsYUFBYSxDQUFDL0gsT0FBT3I1RyxDQUFDLEVBQUVxNUcsT0FBTzV2RyxDQUFDLEVBQUU2RixPQUFPMHJELFVBQVUsSUFBSTFyRCxPQUFPMnJELFdBQVcsSUFBSXlwRCxJQUFJLENBQUMsRUFBRSxFQUFFQSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUczRSxpQkFBaUJFO1FBQ3ZLLElBQUlzRSxtQkFBbUIsOEJBQThCQSxtQkFBbUIsNEJBQTRCO1lBQ2xHLElBQUlzQixNQUFNdjJHLE9BQU96ZSxRQUFRLENBQUNrZ0IsUUFBUTtZQUNsQyxJQUFJKzBHLE1BQU1ELElBQUlodkQsVUFBVTtZQUN4QixJQUFJa3ZELE1BQU1GLElBQUkvdUQsV0FBVztZQUN6QixJQUFJa3ZELE1BQU1ILElBQUk5dUQsTUFBTTtZQUNwQixJQUFJa3ZELE1BQU1KLElBQUk3dUQsTUFBTTtZQUNwQixJQUFJa3ZELE9BQU9KLE1BQU07WUFDakIsSUFBSUssT0FBT0osTUFBTTtZQUNqQixJQUFJSyxNQUFNOTJHLE9BQU9za0QsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztZQUM1QyxJQUFJODRILFFBQVEsT0FBTztnQkFDakJILE9BQU9FO1lBQ1QsT0FBTyxJQUFJQyxRQUFRLFVBQVU7Z0JBQzNCSCxPQUFPRTtZQUNUO1lBQ0EsSUFBSUUsTUFBTS8yRyxPQUFPc2tELE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7WUFDNUMsSUFBSSs0SCxRQUFRLFFBQVE7Z0JBQ2xCTCxPQUFPRTtZQUNULE9BQU8sSUFBSUcsUUFBUSxTQUFTO2dCQUMxQkwsT0FBT0U7WUFDVDtZQUNBLElBQUlJLGtCQUFrQi96RixxQkFBcUJteUYsSUFBSSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFBQ3NCLE1BQU1FO2dCQUFNRCxNQUFNRTtnQkFBTUgsTUFBTUU7Z0JBQU1ELE1BQU1FO2dCQUFNSCxNQUFNRTtnQkFBTUQsTUFBTUU7Z0JBQU1ILE1BQU1FO2dCQUFNRCxNQUFNRTthQUFLLEVBQUU5TSxPQUFPcjVHLENBQUMsRUFBRXE1RyxPQUFPNXZHLENBQUM7WUFDakwsSUFBSTY4RyxnQkFBZ0I1NkgsTUFBTSxHQUFHLEdBQUc7Z0JBQzlCLElBQUk2NkgsU0FBU2pOO2dCQUNiLElBQUlrTixhQUFhbmhHLE9BQU9raEcsUUFBUXJpRyxZQUFZcEs7Z0JBQzVDLElBQUkyc0csZ0JBQWdCcGhHLE9BQU9raEcsUUFBUXJpRyxZQUFZb2lHO2dCQUMvQyxJQUFJSSxhQUFhRjtnQkFDakIsSUFBSUMsZ0JBQWdCRCxZQUFZO29CQUM5QjFzRyxZQUFZO3dCQUFDd3NHLGVBQWUsQ0FBQyxFQUFFO3dCQUFFQSxlQUFlLENBQUMsRUFBRTtxQkFBQztvQkFDcERJLGFBQWFEO2dCQUNmO2dCQUNBLElBQUlILGdCQUFnQjU2SCxNQUFNLEdBQUcsR0FBRztvQkFDOUIsSUFBSWk3SCxpQkFBaUJ0aEcsT0FBT2toRyxRQUFRO3dCQUNsQ3ZtSCxHQUFHc21ILGVBQWUsQ0FBQyxFQUFFO3dCQUNyQjc4RyxHQUFHNjhHLGVBQWUsQ0FBQyxFQUFFO29CQUN2QjtvQkFDQSxJQUFJSyxpQkFBaUJELFlBQVk7d0JBQy9CNXNHLFlBQVk7NEJBQUN3c0csZUFBZSxDQUFDLEVBQUU7NEJBQUVBLGVBQWUsQ0FBQyxFQUFFO3lCQUFDO29CQUN0RDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUlNLGFBQWExekYsb0JBQW9CcFosV0FBV3NMLElBQUk1NUIsRUFBRWdoSCxXQUFXLENBQUN5WCxXQUFXLENBQUNoN0MsT0FBTyxDQUFDcDBELFFBQVF5TDtJQUM5RixJQUFJdW1HLFlBQVkzekYsb0JBQW9CcFosV0FBV3NMLElBQUk1NUIsRUFBRWdoSCxXQUFXLENBQUN5WCxXQUFXLENBQUN0VyxHQUFHLENBQUM5NEYsUUFBUXlMO0lBQ3pGdXdGLEdBQUdwaUYsTUFBTSxHQUFHbzRGLFNBQVMsQ0FBQyxFQUFFO0lBQ3hCaFcsR0FBR25pRixNQUFNLEdBQUdtNEYsU0FBUyxDQUFDLEVBQUU7SUFDeEJoVyxHQUFHVyxXQUFXLEdBQUdvVixVQUFVLENBQUMsRUFBRTtJQUM5Qi9WLEdBQUdZLFdBQVcsR0FBR21WLFVBQVUsQ0FBQyxFQUFFO0lBQzlCLElBQUl2QyxXQUFXO1FBQ2IsSUFBSSxDQUFDajBILFNBQVN5Z0gsR0FBR3BpRixNQUFNLEtBQUssQ0FBQ3IrQixTQUFTeWdILEdBQUduaUYsTUFBTSxLQUFLLENBQUN0K0IsU0FBU3lnSCxHQUFHK0MsSUFBSSxLQUFLLENBQUN4akgsU0FBU3lnSCxHQUFHZ0QsSUFBSSxHQUFHO1lBQzVGaEQsR0FBR2lXLE9BQU8sR0FBRztRQUNmLE9BQU87WUFDTGpXLEdBQUdpVyxPQUFPLEdBQUc7UUFDZjtJQUNGO0FBQ0Y7QUFDQWxELE1BQU1sa0QsaUJBQWlCLEdBQUcsU0FBVTdxRCxJQUFJO0lBQ3RDLElBQUlnOEYsS0FBS2g4RixJQUFJLENBQUMsRUFBRSxDQUFDaGtCLFFBQVEsQ0FBQ2tnQixRQUFRO0lBQ2xDLElBQUksQ0FBQ3VzRCx3QkFBd0IsQ0FBQ3pvRDtJQUM5QixPQUFRZzhGLEdBQUdPLFFBQVE7UUFDakIsS0FBSztZQUNILE9BQU87Z0JBQ0xweEcsR0FBRzZ3RyxHQUFHdjFDLFdBQVcsQ0FBQyxFQUFFO2dCQUNwQjd4RCxHQUFHb25HLEdBQUd2MUMsV0FBVyxDQUFDLEVBQUU7WUFDdEI7UUFDRjtZQUNFLE9BQU87Z0JBQ0x0N0QsR0FBRzZ3RyxHQUFHVyxXQUFXO2dCQUNqQi9uRyxHQUFHb25HLEdBQUdZLFdBQVc7WUFDbkI7SUFDSjtBQUNGO0FBQ0FtUyxNQUFNaGtELGlCQUFpQixHQUFHLFNBQVUvcUQsSUFBSTtJQUN0QyxJQUFJZzhGLEtBQUtoOEYsSUFBSSxDQUFDLEVBQUUsQ0FBQ2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUNsQyxJQUFJLENBQUN1c0Qsd0JBQXdCLENBQUN6b0Q7SUFDOUIsT0FBUWc4RixHQUFHTyxRQUFRO1FBQ2pCLEtBQUs7WUFDSCxPQUFPO2dCQUNMcHhHLEdBQUc2d0csR0FBR3YxQyxXQUFXLENBQUMsRUFBRTtnQkFDcEI3eEQsR0FBR29uRyxHQUFHdjFDLFdBQVcsQ0FBQyxFQUFFO1lBQ3RCO1FBQ0Y7WUFDRSxPQUFPO2dCQUNMdDdELEdBQUc2d0csR0FBR2MsU0FBUztnQkFDZmxvRyxHQUFHb25HLEdBQUdlLFNBQVM7WUFDakI7SUFDSjtBQUNGO0FBRUEsSUFBSW1WLFFBQVEsQ0FBQztBQUNiLFNBQVNDLGNBQWN4N0gsQ0FBQyxFQUFFcXBCLElBQUksRUFBRWlULEdBQUc7SUFDakMsSUFBSW0vRixjQUFjLFNBQVNBLFlBQVk5aEcsRUFBRSxFQUFFQyxFQUFFLEVBQUU0QyxFQUFFLEVBQUU1N0IsQ0FBQztRQUNsRCxPQUFPcTVCLFVBQVVOLElBQUlDLElBQUk0QyxJQUFJNTdCO0lBQy9CO0lBQ0EsSUFBSW9qQixLQUFLcUYsS0FBS2hrQixRQUFRO0lBQ3RCLElBQUlxMkgsT0FBTzEzRyxHQUFHUSxNQUFNLENBQUN3ckQsU0FBUztJQUM5QixJQUFLLElBQUl2dEUsSUFBSSxHQUFHQSxJQUFJekMsRUFBRTI3SCxjQUFjLENBQUN6N0gsTUFBTSxFQUFFdUMsSUFBSztRQUNoRCxJQUFJZ0gsSUFBSXpKLEVBQUUyN0gsY0FBYyxDQUFDbDVILEVBQUU7UUFDM0JpNUgsS0FBS2g1SCxJQUFJLENBQUM7WUFDUjhSLEdBQUdpbkgsWUFBWW4vRixHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFN3lCO1lBQ3ZDd1UsR0FBR3c5RyxZQUFZbi9GLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUU3eUI7UUFDekM7SUFDRjtBQUNGO0FBQ0E4eEgsTUFBTW5OLG9CQUFvQixHQUFHLFNBQVUva0csSUFBSTtJQUN6QyxJQUFJckYsS0FBS3FGLEtBQUtoa0IsUUFBUTtJQUN0QixJQUFJZ2dILEtBQUtyaEcsR0FBR3VCLFFBQVE7SUFDcEIsSUFBSW16RyxLQUFLclQsR0FBR08sUUFBUTtJQUVwQixnQ0FBZ0M7SUFDaEM1aEcsR0FBR1EsTUFBTSxDQUFDd3JELFNBQVMsR0FBRztJQUN0QmhzRCxHQUFHUSxNQUFNLENBQUN5ckQsT0FBTyxHQUFHO0lBQ3BCanNELEdBQUdRLE1BQU0sQ0FBQ3NyRCxXQUFXLEdBQUc7SUFDeEIsSUFBSTRvRCxPQUFPLGlCQUFpQkEsT0FBTyxZQUFZQSxPQUFPLFVBQVVBLE9BQU8sWUFBWTtRQUNqRjEwRyxHQUFHUSxNQUFNLENBQUN3ckQsU0FBUyxHQUFHLEVBQUU7UUFDeEIsSUFBSyxJQUFJdnRFLElBQUksR0FBR0EsSUFBSSxJQUFJNGlILEdBQUdRLE1BQU0sQ0FBQzNsSCxNQUFNLEVBQUV1QyxLQUFLLEVBQUc7WUFDaEQrNEgsY0FBYyxJQUFJLEVBQUVueUcsTUFBTWc4RixHQUFHUSxNQUFNLENBQUN2aUgsS0FBSyxDQUFDYixHQUFHQSxJQUFJO1FBQ25EO0lBQ0YsT0FBTyxJQUFJaTJILE9BQU8sWUFBWTtRQUM1QixJQUFJa0QsT0FBTzUzRyxHQUFHUSxNQUFNLENBQUN5ckQsT0FBTyxHQUFHLEVBQUU7UUFDakMsSUFBSyxJQUFJeHRFLElBQUksR0FBR0EsSUFBSSxJQUFJNGlILEdBQUdRLE1BQU0sQ0FBQzNsSCxNQUFNLEVBQUV1QyxLQUFLLEVBQUc7WUFDaERtNUgsS0FBS2w1SCxJQUFJLENBQUM7Z0JBQ1I4UixHQUFHNndHLEdBQUdRLE1BQU0sQ0FBQ3BqSCxFQUFFO2dCQUNmd2IsR0FBR29uRyxHQUFHUSxNQUFNLENBQUNwakgsSUFBSSxFQUFFO1lBQ3JCO1FBQ0Y7SUFDRixPQUFPLElBQUlpMkgsT0FBTyxZQUFZO1FBQzVCLElBQUk3b0QsT0FBT3cxQyxHQUFHdjFDLFdBQVc7UUFDekI5ckQsR0FBR1EsTUFBTSxDQUFDc3JELFdBQVcsR0FBRztZQUFDO2dCQUN2QnQ3RCxHQUFHcTdELElBQUksQ0FBQyxFQUFFO2dCQUNWNXhELEdBQUc0eEQsSUFBSSxDQUFDLEVBQUU7WUFDWjtZQUFHO2dCQUNEcjdELEdBQUdxN0QsSUFBSSxDQUFDLEVBQUU7Z0JBQ1Y1eEQsR0FBRzR4RCxJQUFJLENBQUMsRUFBRTtZQUNaO1NBQUU7SUFDSjtJQUNBN3JELEdBQUdRLE1BQU0sQ0FBQzhsRCxVQUFVLEdBQUcsSUFBSSxDQUFDdTRDLGFBQWEsQ0FBQ3g1RixLQUFLKytDLE1BQU0sQ0FBQyxTQUFTQyxPQUFPLEVBQUVoL0MsS0FBSysrQyxNQUFNLENBQUMsZUFBZXRtRSxLQUFLLElBQUksSUFBSSxDQUFDZy9HLGVBQWU7QUFDbEk7QUFDQXlhLE1BQU1NLDBCQUEwQixHQUFHLFNBQVVwMkcsS0FBSztJQUNoRCxJQUFJLENBQUNpeEcscUJBQXFCLENBQUNqeEc7QUFDN0I7QUFFQSxJQUFJcTJHLFFBQVEsQ0FBQztBQUNiQSxNQUFNQyw4QkFBOEIsR0FBRyxTQUFVM3lHLElBQUk7SUFDbkQsSUFBSTR5RyxVQUFVNXlHLEtBQUtnL0MsTUFBTSxDQUFDLFNBQVM4QyxRQUFRO0lBQzNDLElBQUl4bEUsWUFBWXMySCxVQUFVO1FBQ3hCO0lBQ0Y7SUFDQSxJQUFJQyxPQUFPQztJQUNYLElBQUlsNEcsS0FBS29GLEtBQUsvakIsUUFBUTtJQUN0QixJQUFJODJILFlBQVkveUcsS0FBS2dVLEtBQUs7SUFDMUIsSUFBSWcvRixhQUFhaHpHLEtBQUtpVSxNQUFNO0lBQzVCLElBQUluQyxVQUFVOVIsS0FBSzhSLE9BQU87SUFDMUIsSUFBSW1oRyxVQUFVanpHLEtBQUtuRixRQUFRO0lBQzNCLElBQUlxNEcsYUFBYWx6RyxLQUFLZy9DLE1BQU0sQ0FBQyxlQUFlOEMsUUFBUTtJQUNwRCxJQUFJcXhELGFBQWFuekcsS0FBS2cvQyxNQUFNLENBQUMsZUFBZThDLFFBQVE7SUFDcEQsSUFBSW02QyxLQUFLcmhHLEdBQUd1QixRQUFRO0lBQ3BCLElBQUlmLFNBQVNSLEdBQUdRLE1BQU07SUFDdEIsT0FBUTgzRztRQUNOLEtBQUs7WUFDSEwsUUFBUUksUUFBUTduSCxDQUFDLEdBQUcybkgsWUFBWSxJQUFJamhHO1lBQ3BDO1FBQ0YsS0FBSztZQUNIK2dHLFFBQVFJLFFBQVE3bkgsQ0FBQyxHQUFHMm5ILFlBQVksSUFBSWpoRztZQUNwQztRQUNGO1lBQ0UsY0FBYztZQUNkK2dHLFFBQVFJLFFBQVE3bkgsQ0FBQztJQUNyQjtJQUNBLE9BQVErbkg7UUFDTixLQUFLO1lBQ0hMLFFBQVFHLFFBQVFwK0csQ0FBQyxHQUFHbStHLGFBQWEsSUFBSWxoRztZQUNyQztRQUNGLEtBQUs7WUFDSGdoRyxRQUFRRyxRQUFRcCtHLENBQUMsR0FBR20rRyxhQUFhLElBQUlsaEc7WUFDckM7UUFDRjtZQUNFLGNBQWM7WUFDZGdoRyxRQUFRRyxRQUFRcCtHLENBQUM7SUFDckI7SUFDQW9uRyxHQUFHOTVDLE1BQU0sR0FBRzB3RDtJQUNaNVcsR0FBRzc1QyxNQUFNLEdBQUcwd0Q7SUFDWjEzRyxPQUFPK21ELE1BQU0sR0FBRzB3RDtJQUNoQnozRyxPQUFPZ25ELE1BQU0sR0FBRzB3RDtJQUNoQixJQUFJLENBQUM1TixvQkFBb0IsQ0FBQ2xsRztJQUMxQixJQUFJLENBQUNvekcsb0JBQW9CLENBQUNwekc7QUFDNUI7QUFDQSxJQUFJcXpHLHFCQUFxQixTQUFTQSxtQkFBbUIzaUcsRUFBRSxFQUFFQyxFQUFFO0lBQ3pELElBQUl5SSxRQUFReDlCLEtBQUt5OUIsSUFBSSxDQUFDMUksS0FBS0Q7SUFDM0IsSUFBSUEsT0FBTyxLQUFLMEksUUFBUSxHQUFHO1FBQ3pCQSxRQUFRQSxRQUFRLENBQUM7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSWs2RixZQUFZLFNBQVNBLFVBQVV4aUcsRUFBRSxFQUFFUCxFQUFFO0lBQ3ZDLElBQUlHLEtBQUtILEdBQUdubEIsQ0FBQyxHQUFHMGxCLEdBQUcxbEIsQ0FBQztJQUNwQixJQUFJdWxCLEtBQUtKLEdBQUcxYixDQUFDLEdBQUdpYyxHQUFHamMsQ0FBQztJQUNwQixPQUFPdytHLG1CQUFtQjNpRyxJQUFJQztBQUNoQztBQUNBLElBQUk0aUcsY0FBYyxTQUFTQSxZQUFZemlHLEVBQUUsRUFBRVAsRUFBRSxFQUFFQyxFQUFFLEVBQUVoNUIsQ0FBQztJQUNsRCxJQUFJZzhILEtBQUtwaUcsTUFBTSxHQUFHNTVCLElBQUksT0FBTztJQUM3QixJQUFJc2tDLEtBQUsxSyxNQUFNLEdBQUc1NUIsSUFBSSxPQUFPO0lBQzdCLElBQUlpOEgsTUFBTTFpRyxZQUFZRCxJQUFJUCxJQUFJQyxJQUFJZ2pHO0lBQ2xDLElBQUlFLE1BQU0zaUcsWUFBWUQsSUFBSVAsSUFBSUMsSUFBSXNMO0lBQ2xDLE9BQU93M0YsVUFBVUcsS0FBS0M7QUFDeEI7QUFDQWhCLE1BQU16TiwrQkFBK0IsR0FBRyxTQUFVaGxHLElBQUk7SUFDcEQsSUFBSTVmO0lBQ0osSUFBSXVhLEtBQUtxRixLQUFLaGtCLFFBQVE7SUFDdEIsSUFBSWdnSCxLQUFLcmhHLEdBQUd1QixRQUFRO0lBQ3BCLElBQUl2bEIsSUFBSSxJQUFJO0lBQ1osSUFBSWc4SCxVQUFVO1FBQ1poeEcsS0FBSzNCLEtBQUsrK0MsTUFBTSxDQUFDLFNBQVM4QyxRQUFRO1FBQ2xDcG5ELFFBQVF1RixLQUFLKytDLE1BQU0sQ0FBQyxnQkFBZ0I4QyxRQUFRO1FBQzVDbm5ELFFBQVFzRixLQUFLKytDLE1BQU0sQ0FBQyxnQkFBZ0I4QyxRQUFRO0lBQzlDO0lBQ0EsSUFBSTh3RCxRQUFRaHhHLEdBQUcsSUFBSWd4RyxRQUFRbDRHLE1BQU0sSUFBSWs0RyxRQUFRajRHLE1BQU07U0FBUztRQUMxRCxRQUFRLHdCQUF3QjtJQUNsQztJQUVBLG9FQUFvRTtJQUNwRSxFQUFFO0lBQ0Z0YSxJQUFJO1FBQ0YrSyxHQUFHNndHLEdBQUd6NkMsSUFBSTtRQUNWM3NELEdBQUdvbkcsR0FBR3g2QyxJQUFJO0lBQ1o7SUFDQSxJQUFJa3lELFFBQVEsU0FBU0EsTUFBTWg3RyxRQUFRLEVBQUVyYSxNQUFNLEVBQUU1RixLQUFLO1FBQ2hEa2dCLG9CQUFvQmdDLEdBQUd1QixRQUFRLEVBQUV4RCxVQUFVcmEsUUFBUTVGO1FBQ25Ea2dCLG9CQUFvQmdDLEdBQUdRLE1BQU0sRUFBRXpDLFVBQVVyYSxRQUFRNUY7SUFDbkQ7SUFDQWk3SCxNQUFNLFVBQVUsTUFBTXR6SCxFQUFFK0ssQ0FBQztJQUN6QnVvSCxNQUFNLFVBQVUsTUFBTXR6SCxFQUFFd1UsQ0FBQztJQUN6QixJQUFJKytHLFdBQVdQLG1CQUFtQnBYLEdBQUc4RSxRQUFRLEVBQUU5RSxHQUFHK0UsUUFBUTtJQUMxRDJTLE1BQU0sa0JBQWtCLE1BQU1DO0lBQzlCLElBQUlDLDBCQUEwQixTQUFTQztRQUNyQyxJQUFJRCx3QkFBd0JoMkgsS0FBSyxFQUFFO1lBQ2pDLE9BQU9nMkgsd0JBQXdCaDJILEtBQUs7UUFDdEMsRUFBRSxnQ0FBZ0M7UUFFbEMsSUFBSTRpSCxVQUFVLEVBQUU7UUFFaEIsOEJBQThCO1FBQzlCLElBQUssSUFBSXBuSCxJQUFJLEdBQUdBLElBQUksSUFBSTRpSCxHQUFHUSxNQUFNLENBQUMzbEgsTUFBTSxFQUFFdUMsS0FBSyxFQUFHO1lBQ2hELElBQUl5M0IsS0FBSztnQkFDUDFsQixHQUFHNndHLEdBQUdRLE1BQU0sQ0FBQ3BqSCxFQUFFO2dCQUNmd2IsR0FBR29uRyxHQUFHUSxNQUFNLENBQUNwakgsSUFBSSxFQUFFO1lBQ3JCO1lBQ0EsSUFBSWszQixLQUFLO2dCQUNQbmxCLEdBQUc2d0csR0FBR1EsTUFBTSxDQUFDcGpILElBQUksRUFBRTtnQkFDbkJ3YixHQUFHb25HLEdBQUdRLE1BQU0sQ0FBQ3BqSCxJQUFJLEVBQUU7WUFDckIsR0FBRyxTQUFTO1lBQ1osSUFBSW0zQixLQUFLO2dCQUNQcGxCLEdBQUc2d0csR0FBR1EsTUFBTSxDQUFDcGpILElBQUksRUFBRTtnQkFDbkJ3YixHQUFHb25HLEdBQUdRLE1BQU0sQ0FBQ3BqSCxJQUFJLEVBQUU7WUFDckI7WUFDQW9uSCxRQUFRbm5ILElBQUksQ0FBQztnQkFDWHczQixJQUFJQTtnQkFDSlAsSUFBSUE7Z0JBQ0pDLElBQUlBO2dCQUNKdWpHLFdBQVc7Z0JBQ1hqOUgsUUFBUTtnQkFDUjA0SCxVQUFVLEVBQUU7WUFDZDtRQUNGO1FBQ0EsSUFBSThDLE9BQU8xM0csR0FBR1EsTUFBTSxDQUFDd3JELFNBQVM7UUFDOUIsSUFBSW90RCxTQUFTcDlILEVBQUUyN0gsY0FBYyxDQUFDejdILE1BQU07UUFDcEMsU0FBU205SCxXQUFXQyxFQUFFLEVBQUVwakcsRUFBRSxFQUFFUCxFQUFFLEVBQUVpakcsRUFBRSxFQUFFMTNGLEVBQUU7WUFDcEMsSUFBSWhsQyxTQUFTdXRCLEtBQUt5TSxJQUFJUDtZQUN0QixJQUFJNGpHLGNBQWNELEdBQUcxRSxRQUFRLENBQUMwRSxHQUFHMUUsUUFBUSxDQUFDMTRILE1BQU0sR0FBRyxFQUFFO1lBQ3JELElBQUlzOUgsVUFBVTtnQkFDWnRqRyxJQUFJQTtnQkFDSlAsSUFBSUE7Z0JBQ0ppakcsSUFBSUE7Z0JBQ0oxM0YsSUFBSUE7Z0JBQ0ppNEYsV0FBV0ksY0FBY0EsWUFBWUosU0FBUyxHQUFHSSxZQUFZcjlILE1BQU0sR0FBRztnQkFDdEVBLFFBQVFBO1lBQ1Y7WUFDQW85SCxHQUFHMUUsUUFBUSxDQUFDbDJILElBQUksQ0FBQzg2SDtZQUNqQkYsR0FBR3A5SCxNQUFNLElBQUlBO1FBQ2Y7UUFFQSx1Q0FBdUM7UUFDdkMsSUFBSyxJQUFJaXBCLEtBQUssR0FBR0EsS0FBSzBnRyxRQUFRM3BILE1BQU0sRUFBRWlwQixLQUFNO1lBQzFDLElBQUltMEcsS0FBS3pULE9BQU8sQ0FBQzFnRyxHQUFHO1lBQ3BCLElBQUlzMEcsU0FBUzVULE9BQU8sQ0FBQzFnRyxLQUFLLEVBQUU7WUFDNUIsSUFBSXMwRyxRQUFRO2dCQUNWSCxHQUFHSCxTQUFTLEdBQUdNLE9BQU9OLFNBQVMsR0FBR00sT0FBT3Y5SCxNQUFNO1lBQ2pEO1lBQ0FtOUgsV0FBV0MsSUFBSUEsR0FBR3BqRyxFQUFFLEVBQUV3aEcsSUFBSSxDQUFDdnlHLEtBQUtpMEcsT0FBTyxFQUFFLEdBQUdwOUgsRUFBRTI3SCxjQUFjLENBQUMsRUFBRSxHQUFHLFFBQVE7WUFFMUUsSUFBSyxJQUFJN3lILElBQUksR0FBR0EsSUFBSXMwSCxTQUFTLEdBQUd0MEgsSUFBSztnQkFDbkN1MEgsV0FBV0MsSUFBSTVCLElBQUksQ0FBQ3Z5RyxLQUFLaTBHLFNBQVN0MEgsRUFBRSxFQUFFNHlILElBQUksQ0FBQ3Z5RyxLQUFLaTBHLFNBQVN0MEgsSUFBSSxFQUFFLEVBQUU5SSxFQUFFMjdILGNBQWMsQ0FBQzd5SCxFQUFFLEVBQUU5SSxFQUFFMjdILGNBQWMsQ0FBQzd5SCxJQUFJLEVBQUU7WUFDL0c7WUFDQXUwSCxXQUFXQyxJQUFJNUIsSUFBSSxDQUFDdnlHLEtBQUtpMEcsU0FBU0EsU0FBUyxFQUFFLEVBQUVFLEdBQUcxakcsRUFBRSxFQUFFNTVCLEVBQUUyN0gsY0FBYyxDQUFDeUIsU0FBUyxFQUFFLEVBQUUsSUFBSSxPQUFPO1FBQ2pHO1FBQ0EsT0FBT0gsd0JBQXdCaDJILEtBQUssR0FBRzRpSDtJQUN6QztJQUNBLElBQUk2VCx5QkFBeUIsU0FBU0EsdUJBQXVCaDJILE1BQU07UUFDakUsSUFBSTg2QjtRQUNKLElBQUltN0YsUUFBUWoySCxXQUFXO1FBQ3ZCLElBQUksQ0FBQ3MwSCxPQUFPLENBQUN0MEgsT0FBTyxFQUFFO1lBQ3BCO1FBQ0Y7UUFDQSxJQUFJaTZCLFNBQVN0WSxLQUFLKytDLE1BQU0sQ0FBQzFnRSxTQUFTLGdCQUFnQjJnRSxPQUFPO1FBQ3pELE9BQVFnOUMsR0FBR08sUUFBUTtZQUNqQixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIO29CQUNFLElBQUlnWSxNQUFNWDtvQkFDVixJQUFJcjRHO29CQUNKLElBQUl1NEcsWUFBWTtvQkFDaEIsSUFBSVUsWUFBWTtvQkFFaEIsNEJBQTRCO29CQUM1QixJQUFLLElBQUlwN0gsSUFBSSxHQUFHQSxJQUFJbTdILElBQUkxOUgsTUFBTSxFQUFFdUMsSUFBSzt3QkFDbkMsSUFBSXE3SCxNQUFNRixHQUFHLENBQUNELFFBQVFsN0gsSUFBSW03SCxJQUFJMTlILE1BQU0sR0FBRyxJQUFJdUMsRUFBRTt3QkFDN0MsSUFBSyxJQUFJcUcsSUFBSSxHQUFHQSxJQUFJZzFILElBQUlsRixRQUFRLENBQUMxNEgsTUFBTSxFQUFFNEksSUFBSzs0QkFDNUMsSUFBSWkxSCxPQUFPRCxJQUFJbEYsUUFBUSxDQUFDK0UsUUFBUTcwSCxJQUFJZzFILElBQUlsRixRQUFRLENBQUMxNEgsTUFBTSxHQUFHLElBQUk0SSxFQUFFOzRCQUNoRSxJQUFJazFILFVBQVV2N0gsTUFBTW03SCxJQUFJMTlILE1BQU0sR0FBRyxLQUFLNEksTUFBTWcxSCxJQUFJbEYsUUFBUSxDQUFDMTRILE1BQU0sR0FBRzs0QkFDbEVpOUgsWUFBWVU7NEJBQ1pBLGFBQWFFLEtBQUs3OUgsTUFBTTs0QkFDeEIsSUFBSTI5SCxhQUFhbDhGLFVBQVVxOEYsU0FBUztnQ0FDbENwNUcsV0FBVztvQ0FDVDA0RyxJQUFJUTtvQ0FDSk4sU0FBU087Z0NBQ1g7Z0NBQ0E7NEJBQ0Y7d0JBQ0Y7d0JBQ0EsSUFBSW41RyxVQUFVOzRCQUNaO3dCQUNGO29CQUNGO29CQUNBLElBQUkwNEcsS0FBSzE0RyxTQUFTMDRHLEVBQUU7b0JBQ3BCLElBQUlXLE1BQU1yNUcsU0FBUzQ0RyxPQUFPO29CQUMxQixJQUFJVSxXQUFXLENBQUN2OEYsU0FBU3c3RixTQUFRLElBQUtjLElBQUkvOUgsTUFBTTtvQkFDaEQsSUFBSWkrSCxRQUFRRixJQUFJLzRGLEVBQUUsR0FBRys0RixJQUFJckIsRUFBRTtvQkFDM0IsSUFBSWg4SCxJQUFJKzhILFFBQVFNLElBQUlyQixFQUFFLEdBQUd1QixRQUFRRCxXQUFXRCxJQUFJLzRGLEVBQUUsR0FBR2k1RixRQUFRRDtvQkFDN0R0OUgsSUFBSTQ1QixNQUFNLEdBQUc1NUIsR0FBRztvQkFDaEI2SSxJQUFJMHdCLFlBQVltakcsR0FBR3BqRyxFQUFFLEVBQUVvakcsR0FBRzNqRyxFQUFFLEVBQUUyakcsR0FBRzFqRyxFQUFFLEVBQUVoNUI7b0JBQ3JDNGhDLFFBQVFtNkYsWUFBWVcsR0FBR3BqRyxFQUFFLEVBQUVvakcsR0FBRzNqRyxFQUFFLEVBQUUyakcsR0FBRzFqRyxFQUFFLEVBQUVoNUI7b0JBQ3pDO2dCQUNGO1lBQ0YsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIO29CQUNFLElBQUlvdEIsSUFBSSxHQUNOb3dHLElBQ0FDO29CQUNGLElBQUlua0csSUFBSVA7b0JBQ1IsSUFBSW4zQixJQUFJNmlILEdBQUdRLE1BQU0sQ0FBQzNsSCxNQUFNO29CQUN4QixJQUFLLElBQUk2b0IsTUFBTSxHQUFHQSxNQUFNLElBQUl2bUIsR0FBR3VtQixPQUFPLEVBQUc7d0JBQ3ZDLElBQUk0MEcsT0FBTzs0QkFDVHpqRyxLQUFLO2dDQUNIMWxCLEdBQUc2d0csR0FBR1EsTUFBTSxDQUFDOThGLElBQUk7Z0NBQ2pCOUssR0FBR29uRyxHQUFHUSxNQUFNLENBQUM5OEYsTUFBTSxFQUFFOzRCQUN2Qjs0QkFDQTRRLEtBQUs7Z0NBQ0hubEIsR0FBRzZ3RyxHQUFHUSxNQUFNLENBQUM5OEYsTUFBTSxFQUFFO2dDQUNyQjlLLEdBQUdvbkcsR0FBR1EsTUFBTSxDQUFDOThGLE1BQU0sRUFBRTs0QkFDdkI7d0JBQ0YsT0FBTzs0QkFDTG1SLEtBQUs7Z0NBQ0gxbEIsR0FBRzZ3RyxHQUFHUSxNQUFNLENBQUNyakgsSUFBSSxJQUFJdW1CLElBQUk7Z0NBQ3pCOUssR0FBR29uRyxHQUFHUSxNQUFNLENBQUNyakgsSUFBSSxJQUFJdW1CLElBQUk7NEJBQzNCOzRCQUNBNFEsS0FBSztnQ0FDSG5sQixHQUFHNndHLEdBQUdRLE1BQU0sQ0FBQ3JqSCxJQUFJLElBQUl1bUIsSUFBSTtnQ0FDekI5SyxHQUFHb25HLEdBQUdRLE1BQU0sQ0FBQ3JqSCxJQUFJLElBQUl1bUIsSUFBSTs0QkFDM0I7d0JBQ0Y7d0JBQ0FxMUcsS0FBSzN3RyxLQUFLeU0sSUFBSVA7d0JBQ2Qwa0csS0FBS3J3Rzt3QkFDTEEsS0FBS293Rzt3QkFDTCxJQUFJcHdHLEtBQUsyVCxRQUFROzRCQUNmO3dCQUNGO29CQUNGO29CQUNBLElBQUkyOEYsS0FBSzM4RixTQUFTMDhGO29CQUNsQixJQUFJRSxLQUFLRCxLQUFLRjtvQkFDZEcsS0FBSy9qRyxNQUFNLEdBQUcrakcsSUFBSTtvQkFDbEI5MEgsSUFBSTJ3QixPQUFPRixJQUFJUCxJQUFJNGtHO29CQUNuQi83RixRQUFRazZGLFVBQVV4aUcsSUFBSVA7b0JBQ3RCO2dCQUNGO1FBQ0o7UUFDQW9qRyxNQUFNLFVBQVVyMUgsUUFBUStCLEVBQUUrSyxDQUFDO1FBQzNCdW9ILE1BQU0sVUFBVXIxSCxRQUFRK0IsRUFBRXdVLENBQUM7UUFDM0I4K0csTUFBTSxrQkFBa0JyMUgsUUFBUTg2QjtJQUNsQztJQUNBazdGLHVCQUF1QjtJQUN2QkEsdUJBQXVCO0lBQ3ZCLElBQUksQ0FBQ2xCLG9CQUFvQixDQUFDbnpHO0FBQzVCO0FBQ0F5eUcsTUFBTVUsb0JBQW9CLEdBQUcsU0FBVWg3RyxHQUFHO0lBQ3hDLElBQUksQ0FBQ2c5Ryw0QkFBNEIsQ0FBQ2g5RztJQUNsQyxJQUFJQSxJQUFJbTZCLE1BQU0sSUFBSTtRQUNoQixJQUFJLENBQUM2aUYsNEJBQTRCLENBQUNoOUcsS0FBSztRQUN2QyxJQUFJLENBQUNnOUcsNEJBQTRCLENBQUNoOUcsS0FBSztJQUN6QztBQUNGO0FBQ0FzNkcsTUFBTTBDLDRCQUE0QixHQUFHLFNBQVVoOUcsR0FBRyxFQUFFOVosTUFBTTtJQUN4RCxJQUFJc2MsS0FBS3hDLElBQUluYyxRQUFRO0lBQ3JCLElBQUlxOEQsT0FBTyxJQUFJLENBQUMrOEQsWUFBWSxDQUFDajlHLEtBQUs5WjtJQUNsQyxJQUFJZzNILFdBQVcvZ0gsV0FBVytqRCxNQUFNbGdELElBQUluYyxRQUFRLENBQUNzMUYsWUFBWTtJQUV6RCxpREFBaUQ7SUFDakQsSUFBSTc0RSxvQkFBb0JrQyxHQUFHdUIsUUFBUSxFQUFFLHdCQUF3QjdkLFlBQVlnM0gsVUFBVTtRQUNqRixRQUFRLGdEQUFnRDtJQUMxRDtJQUVBLGVBQWU7SUFDZjE4RyxvQkFBb0JnQyxHQUFHdUIsUUFBUSxFQUFFLHdCQUF3QjdkLFFBQVFnM0g7SUFDakUsSUFBSUMsWUFBWSxJQUFJLENBQUNDLHdCQUF3QixDQUFDcDlHLEtBQUtrZ0Q7SUFDbkQsSUFBSW05RCxhQUFhcjlHLElBQUk0bUQsTUFBTSxDQUFDLGVBQWVDLE9BQU87SUFDbEQsSUFBSTY5QixXQUFXMWtGLElBQUk0bUQsTUFBTSxDQUFDLGFBQWE4QyxRQUFRO0lBQy9DLElBQUkzakMsUUFBUXpsQixvQkFBb0JrQyxHQUFHdUIsUUFBUSxFQUFFLHdCQUF3QjdkLFdBQVcsRUFBRTtJQUNsRixJQUFJbzNILFdBQVc1NEIsYUFBYSxTQUFTLElBQUlsaEcsS0FBSzZVLEdBQUcsQ0FBQzB0QixNQUFNcm5DLE1BQU0sRUFBRTtJQUNoRSxJQUFJNitILG9CQUFvQkosVUFBVXRoRyxNQUFNLEdBQUd5aEc7SUFDM0MsSUFBSUUsa0JBQWtCRCxvQkFBb0JGO0lBQzFDLElBQUl6aEcsUUFBUXVoRyxVQUFVdmhHLEtBQUs7SUFDM0IsSUFBSUMsU0FBU3NoRyxVQUFVdGhHLE1BQU0sR0FBRyxDQUFDeWhHLFdBQVcsS0FBTUQsQ0FBQUEsYUFBYSxLQUFLRTtJQUNwRS84RyxvQkFBb0JnQyxHQUFHUSxNQUFNLEVBQUUsY0FBYzljLFFBQVEwMUI7SUFDckRwYixvQkFBb0JnQyxHQUFHdUIsUUFBUSxFQUFFLGNBQWM3ZCxRQUFRMDFCO0lBQ3ZEcGIsb0JBQW9CZ0MsR0FBR1EsTUFBTSxFQUFFLGVBQWU5YyxRQUFRMjFCO0lBQ3REcmIsb0JBQW9CZ0MsR0FBR3VCLFFBQVEsRUFBRSxlQUFlN2QsUUFBUTIxQjtJQUN4RHJiLG9CQUFvQmdDLEdBQUd1QixRQUFRLEVBQUUsbUJBQW1CN2QsUUFBUXMzSDtBQUM5RDtBQUNBbEQsTUFBTTJDLFlBQVksR0FBRyxTQUFVajlHLEdBQUcsRUFBRTlaLE1BQU07SUFDeEMsSUFBSXNjLEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQixJQUFJNDVILE1BQU12M0gsU0FBU0EsU0FBUyxNQUFNO0lBQ2xDLElBQUlnNkQsT0FBT2xnRCxJQUFJNG1ELE1BQU0sQ0FBQzYyRCxNQUFNLFNBQVMvekQsUUFBUTtJQUM3QyxJQUFJKzZCLGdCQUFnQnprRixJQUFJNG1ELE1BQU0sQ0FBQyxrQkFBa0J0bUUsS0FBSztJQUN0RCxJQUFJeWpCLFdBQVcsU0FBU0EsU0FBU3hELFFBQVEsRUFBRWpnQixLQUFLO1FBQzlDLElBQUlBLE9BQU87WUFDVGtnQixvQkFBb0JnQyxHQUFHdUIsUUFBUSxFQUFFeEQsVUFBVXJhLFFBQVE1RjtZQUNuRCxPQUFPQTtRQUNULE9BQU87WUFDTCxPQUFPZ2dCLG9CQUFvQmtDLEdBQUd1QixRQUFRLEVBQUV4RCxVQUFVcmE7UUFDcEQ7SUFDRjtJQUVBLHNDQUFzQztJQUN0QyxJQUFJLENBQUNnNkQsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLElBQUl1a0MsaUJBQWlCO1NBQWUsSUFBSUEsaUJBQWlCLGFBQWE7UUFDcEV2a0MsT0FBT0EsS0FBS2w2RCxXQUFXO0lBQ3pCLE9BQU8sSUFBSXkrRixpQkFBaUIsYUFBYTtRQUN2Q3ZrQyxPQUFPQSxLQUFLcDZELFdBQVc7SUFDekI7SUFDQSxJQUFJNDNILFlBQVkxOUcsSUFBSTRtRCxNQUFNLENBQUMsYUFBYXRtRSxLQUFLO0lBQzdDLElBQUlvOUgsY0FBYyxRQUFRO1FBQ3hCLElBQUlwa0MsV0FBV3YxRSxTQUFTO1FBRXhCLGlEQUFpRDtRQUNqRCxJQUFJdTFFLFlBQVksUUFBUXYxRSxTQUFTLG9CQUFvQnUxRSxVQUFVO1lBQzdELE9BQU92MUUsU0FBUztRQUNsQjtRQUNBLElBQUk0NUcsT0FBTztRQUNYLElBQUk1M0YsUUFBUW02QixLQUFLLzZDLEtBQUssQ0FBQztRQUN2QixJQUFJeTRHLE9BQU81OUcsSUFBSTRtRCxNQUFNLENBQUMsa0JBQWtCQyxPQUFPO1FBQy9DLElBQUlnM0QsV0FBVzc5RyxJQUFJNG1ELE1BQU0sQ0FBQyxzQkFBc0J0bUUsS0FBSztRQUNyRCxJQUFJdzlILGNBQWNELGFBQWE7UUFDL0IsSUFBSUUsZUFBZSxFQUFFO1FBQ3JCLElBQUlDLGlCQUFpQixrQkFBa0IseUNBQXlDO1FBRWhGLElBQUssSUFBSWg5SCxJQUFJLEdBQUdBLElBQUkra0MsTUFBTXJuQyxNQUFNLEVBQUVzQyxJQUFLO1lBQ3JDLElBQUlvL0IsT0FBTzJGLEtBQUssQ0FBQy9rQyxFQUFFO1lBQ25CLElBQUlpOUgsV0FBVyxJQUFJLENBQUNiLHdCQUF3QixDQUFDcDlHLEtBQUtvZ0I7WUFDbEQsSUFBSTg5RixRQUFRRCxTQUFTcmlHLEtBQUs7WUFDMUIsSUFBSWtpRyxhQUFhO2dCQUNmLElBQUlLLGdCQUFnQi85RixLQUFLamIsS0FBSyxDQUFDLElBQUlqZ0IsSUFBSSxDQUFDeTRIO2dCQUN4Q3Y5RixPQUFPKzlGO1lBQ1Q7WUFDQSxJQUFJRCxRQUFRTixNQUFNO2dCQUNoQixtQkFBbUI7Z0JBQ25CLElBQUlRLG1CQUFtQmgrRixLQUFLaStGLFFBQVEsQ0FBQ0w7Z0JBQ3JDLElBQUlNLFVBQVU7Z0JBQ2QsSUFBSUMsZ0JBQWdCO2dCQUNwQixpQkFBaUI7Z0JBQ2pCLElBQUluMkYsWUFBWXJvQywyQkFBMkJxK0gsbUJBQ3pDLzFGO2dCQUNGLElBQUk7b0JBQ0YsSUFBS0QsVUFBVWhvQyxDQUFDLElBQUksQ0FBQyxDQUFDaW9DLFFBQVFELFVBQVV4cEMsQ0FBQyxFQUFDLEVBQUd5QixJQUFJLEVBQUc7d0JBQ2xELElBQUltK0gsaUJBQWlCbjJGLE1BQU0vbkMsS0FBSzt3QkFDaEMsSUFBSW0rSCxnQkFBZ0JELGNBQWMsQ0FBQyxFQUFFO3dCQUNyQyxJQUFJRSxPQUFPdCtGLEtBQUtqNkIsU0FBUyxDQUFDbzRILGVBQWVDLGVBQWU1cEgsS0FBSzt3QkFDN0QycEgsZ0JBQWdCQyxlQUFlNXBILEtBQUssR0FBRzZwSCxjQUFjLy9ILE1BQU07d0JBQzNELElBQUlpZ0ksV0FBV0wsUUFBUTUvSCxNQUFNLEtBQUssSUFBSWdnSSxPQUFPSixVQUFVSSxPQUFPRDt3QkFDOUQsSUFBSUcsV0FBVyxJQUFJLENBQUN4Qix3QkFBd0IsQ0FBQ3A5RyxLQUFLMitHO3dCQUNsRCxJQUFJRSxRQUFRRCxTQUFTaGpHLEtBQUs7d0JBQzFCLElBQUlpakcsU0FBU2pCLE1BQU07NEJBQ2pCLDRCQUE0Qjs0QkFDNUJVLFdBQVdJLE9BQU9EO3dCQUNwQixPQUFPOzRCQUNMLHVCQUF1Qjs0QkFDdkIsSUFBSUgsU0FBUztnQ0FDWFAsYUFBYTc4SCxJQUFJLENBQUNvOUg7NEJBQ3BCOzRCQUNBQSxVQUFVSSxPQUFPRDt3QkFDbkI7b0JBQ0Y7Z0JBRUEsc0RBQXNEO2dCQUN4RCxFQUFFLE9BQU9qMkYsS0FBSztvQkFDWkosVUFBVXpwQyxDQUFDLENBQUM2cEM7Z0JBQ2QsU0FBVTtvQkFDUkosVUFBVTduQyxDQUFDO2dCQUNiO2dCQUNBLElBQUksQ0FBQys5SCxRQUFRbjZILEtBQUssQ0FBQyxrQkFBa0I7b0JBQ25DNDVILGFBQWE3OEgsSUFBSSxDQUFDbzlIO2dCQUNwQjtZQUNGLE9BQU87Z0JBQ0wsK0JBQStCO2dCQUMvQlAsYUFBYTc4SCxJQUFJLENBQUNrL0I7WUFDcEI7UUFDRixFQUFFLE1BQU07UUFFUnJjLFNBQVMsd0JBQXdCZzZHO1FBQ2pDNzlELE9BQU9uOEMsU0FBUyx1QkFBdUJnNkcsYUFBYTc0SCxJQUFJLENBQUM7UUFDekQ2ZSxTQUFTLGdCQUFnQnUxRTtJQUMzQixPQUFPLElBQUlva0MsY0FBYyxZQUFZO1FBQ25DLElBQUlvQixRQUFROStHLElBQUk0bUQsTUFBTSxDQUFDLGtCQUFrQkMsT0FBTztRQUNoRCxJQUFJazRELGFBQWE7UUFDakIsSUFBSUMsV0FBVztRQUNmLElBQUlDLFlBQVk7UUFDaEIsSUFBSSxJQUFJLENBQUM3Qix3QkFBd0IsQ0FBQ3A5RyxLQUFLa2dELE1BQU10a0MsS0FBSyxHQUFHa2pHLE9BQU87WUFDMUQseUJBQXlCO1lBQ3pCLE9BQU81K0Q7UUFDVDtRQUNBLElBQUssSUFBSWovRCxJQUFJLEdBQUdBLElBQUlpL0QsS0FBS3hoRSxNQUFNLEVBQUV1QyxJQUFLO1lBQ3BDLElBQUlpK0gsa0JBQWtCLElBQUksQ0FBQzlCLHdCQUF3QixDQUFDcDlHLEtBQUsrK0csYUFBYTcrRCxJQUFJLENBQUNqL0QsRUFBRSxHQUFHKzlILFVBQVVwakcsS0FBSztZQUMvRixJQUFJc2pHLGtCQUFrQkosT0FBTztnQkFDM0I7WUFDRjtZQUNBQyxjQUFjNytELElBQUksQ0FBQ2ovRCxFQUFFO1lBQ3JCLElBQUlBLE1BQU1pL0QsS0FBS3hoRSxNQUFNLEdBQUcsR0FBRztnQkFDekJ1Z0ksWUFBWTtZQUNkO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLFdBQVc7WUFDZEYsY0FBY0M7UUFDaEI7UUFDQSxPQUFPRDtJQUNULEVBQUUsZUFBZTtJQUVqQixPQUFPNytEO0FBQ1Q7QUFDQW82RCxNQUFNNkUscUJBQXFCLEdBQUcsU0FBVW4vRyxHQUFHO0lBQ3pDLElBQUlzbEYsZ0JBQWdCdGxGLElBQUk0bUQsTUFBTSxDQUFDLHNCQUFzQjhDLFFBQVE7SUFDN0QsSUFBSW94RCxhQUFhOTZHLElBQUk0bUQsTUFBTSxDQUFDLGVBQWU4QyxRQUFRO0lBQ25ELElBQUk0N0Isa0JBQWtCLFFBQVE7UUFDNUIsSUFBSXRsRixJQUFJb0UsTUFBTSxJQUFJO1lBQ2hCLE9BQVEwMkc7Z0JBQ04sS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7b0JBQ0gsT0FBTztnQkFDVDtvQkFDRSxPQUFPO1lBQ1g7UUFDRixPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0YsT0FBTztRQUNMLE9BQU94MUI7SUFDVDtBQUNGO0FBQ0FnMUIsTUFBTThDLHdCQUF3QixHQUFHLFNBQVVwOUcsR0FBRyxFQUFFa2dELElBQUk7SUFDbEQsSUFBSTFoRSxJQUFJLElBQUk7SUFDWixJQUFJMGdHLGtCQUFrQjFnRyxFQUFFeWpCLEVBQUUsQ0FBQy9mLE1BQU07SUFDakMsSUFBSUUsWUFBVzg4RixnQkFBZ0I5OEYsUUFBUTtJQUN2QyxJQUFJczNCLFVBQVUsR0FBRyx1RUFBdUU7SUFDeEYsSUFBSTBsRyxTQUFTcC9HLElBQUk0bUQsTUFBTSxDQUFDLGNBQWM4QyxRQUFRO0lBQzlDLElBQUlub0QsT0FBT3ZCLElBQUk0bUQsTUFBTSxDQUFDLGFBQWFDLE9BQU87SUFDMUMsSUFBSXc0RCxTQUFTci9HLElBQUk0bUQsTUFBTSxDQUFDLGVBQWU4QyxRQUFRO0lBQy9DLElBQUkvOUMsU0FBUzNMLElBQUk0bUQsTUFBTSxDQUFDLGVBQWU4QyxRQUFRO0lBQy9DLElBQUk0MUQsU0FBUyxJQUFJLENBQUNDLGVBQWU7SUFDakMsSUFBSUMsTUFBTSxJQUFJLENBQUNDLHNCQUFzQjtJQUNyQyxJQUFJLENBQUNILFFBQVE7UUFDWEEsU0FBUyxJQUFJLENBQUNDLGVBQWUsR0FBR245SCxVQUFTczlILGFBQWEsQ0FBQztRQUN2REYsTUFBTSxJQUFJLENBQUNDLHNCQUFzQixHQUFHSCxPQUFPSyxVQUFVLENBQUM7UUFDdEQsSUFBSUMsS0FBS04sT0FBT3Y4RyxLQUFLO1FBQ3JCNjhHLEdBQUduOUcsUUFBUSxHQUFHO1FBQ2RtOUcsR0FBRzlsRyxJQUFJLEdBQUc7UUFDVjhsRyxHQUFHeDBHLEdBQUcsR0FBRztRQUNUdzBHLEdBQUdDLE1BQU0sR0FBRztRQUNaRCxHQUFHejZCLFVBQVUsR0FBRztRQUNoQnk2QixHQUFHRSxhQUFhLEdBQUc7SUFDckI7SUFDQU4sSUFBSU8sSUFBSSxHQUFHLEdBQUd0MkcsTUFBTSxDQUFDMjFHLFFBQVEsS0FBSzMxRyxNQUFNLENBQUNrQyxRQUFRLEtBQUtsQyxNQUFNLENBQUNsSSxNQUFNLE9BQU9rSSxNQUFNLENBQUM0MUc7SUFDakYsSUFBSXpqRyxRQUFRO0lBQ1osSUFBSUMsU0FBUztJQUNiLElBQUlrSyxRQUFRbTZCLEtBQUsvNkMsS0FBSyxDQUFDO0lBQ3ZCLElBQUssSUFBSWxrQixJQUFJLEdBQUdBLElBQUk4a0MsTUFBTXJuQyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3JDLElBQUltL0IsT0FBTzJGLEtBQUssQ0FBQzlrQyxFQUFFO1FBQ25CLElBQUkrK0gsVUFBVVIsSUFBSVMsV0FBVyxDQUFDNy9GO1FBQzlCLElBQUl6aUIsSUFBSW5hLEtBQUs0eEIsSUFBSSxDQUFDNHFHLFFBQVFwa0csS0FBSztRQUMvQixJQUFJN3pCLElBQUl3WjtRQUNScWEsUUFBUXA0QixLQUFLNlUsR0FBRyxDQUFDc0YsR0FBR2llO1FBQ3BCQyxVQUFVOXpCO0lBQ1o7SUFDQTZ6QixTQUFTbEM7SUFDVG1DLFVBQVVuQztJQUNWLE9BQU87UUFDTGtDLE9BQU9BO1FBQ1BDLFFBQVFBO0lBQ1Y7QUFDRjtBQUNBeStGLE1BQU00RixtQkFBbUIsR0FBRyxTQUFVbGdILEdBQUcsRUFBRTlaLE1BQU07SUFDL0MsSUFBSXNjLEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQixJQUFJZ2dILEtBQUtyaEcsR0FBR3VCLFFBQVE7SUFDcEIsSUFBSW8yQixTQUFTbjZCLElBQUltNkIsTUFBTTtJQUN2QixJQUFJcXZCLGFBQWF0akUsU0FBU0EsU0FBUyxNQUFNO0lBQ3pDLElBQUlpNkgsTUFBTW5nSCxJQUFJNG1ELE1BQU0sQ0FBQzRDLGFBQWE7SUFDbEMsSUFBSTQyRCxTQUFTRCxJQUFJejJELFFBQVE7SUFDekIsSUFBSTAyRCxXQUFXLFFBQVE7UUFDckIsT0FBTztJQUNULE9BQU8sSUFBSWptRixVQUFVaW1GLFdBQVcsY0FBYztRQUM1QyxPQUFPdmMsR0FBR3djLGNBQWM7SUFDMUIsT0FBTyxJQUFJRCxXQUFXLGNBQWM7UUFDbEMsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPRCxJQUFJdDVELE9BQU87SUFDcEI7QUFDRjtBQUNBeXpELE1BQU14TixvQkFBb0IsR0FBRyxTQUFVOXNHLEdBQUc7SUFDeEMsSUFBSXhoQixJQUFJLElBQUk7SUFDWixJQUFJMjdDLFNBQVNuNkIsSUFBSW02QixNQUFNO0lBQ3ZCLElBQUkzM0IsS0FBS3hDLElBQUluYyxRQUFRO0lBQ3JCLElBQUlnZ0gsS0FBS3JoRyxHQUFHdUIsUUFBUTtJQUNwQjgvRixHQUFHeWMsVUFBVSxHQUFHOWhJLEVBQUUwaEksbUJBQW1CLENBQUNsZ0g7SUFDdEMsSUFBSW02QixRQUFRO1FBQ1YwcEUsR0FBRzBjLGdCQUFnQixHQUFHL2hJLEVBQUUwaEksbUJBQW1CLENBQUNsZ0gsS0FBSztRQUNqRDZqRyxHQUFHMmMsZ0JBQWdCLEdBQUdoaUksRUFBRTBoSSxtQkFBbUIsQ0FBQ2xnSCxLQUFLO0lBQ25EO0FBQ0Y7QUFFQSxJQUFJeWdILFFBQVEsQ0FBQztBQUNiLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQyxnQkFBZ0I7QUFDcEJGLE1BQU0zYyxZQUFZLEdBQUcsU0FBVWw4RixJQUFJO0lBQ2pDLElBQUlwcEIsSUFBSSxJQUFJO0lBQ1osSUFBSTh0RSxRQUFRMWtELEtBQUtnL0MsTUFBTSxDQUFDLFNBQVN0bUUsS0FBSztJQUN0QyxJQUFJZ3NFLFVBQVUsa0JBQW1CMWtELENBQUFBLEtBQUtnVSxLQUFLLEtBQUs4a0csc0JBQXNCOTRHLEtBQUtpVSxNQUFNLEtBQUs2a0csa0JBQWlCLEdBQUk7UUFDekcsSUFBSSxDQUFDQyxlQUFlO1lBQ2xCMWlILEtBQUs7WUFDTDBpSCxnQkFBZ0I7UUFDbEI7UUFDQSxPQUFPO0lBQ1Q7SUFDQSxJQUFJLzRHLEtBQUtxeEMsUUFBUSxJQUFJO1FBQ25CLElBQUlxVCxVQUFVLGVBQWVBLFVBQVUsb0JBQW9CQSxVQUFVLHFCQUFxQkEsVUFBVSxrQkFBa0JBLFVBQVUsbUJBQW1CQSxVQUFVLFVBQVU7WUFDckssT0FBT0E7UUFDVCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJQSxVQUFVLFdBQVc7UUFDdkIsSUFBSTVyQyxTQUFTOVksS0FBS2cvQyxNQUFNLENBQUMsd0JBQXdCdG1FLEtBQUs7UUFDdEQsT0FBTzlCLEVBQUVpdUUsVUFBVSxDQUFDbTBELFdBQVcsQ0FBQ2xnRyxRQUFRMytCLElBQUk7SUFDOUM7SUFDQSxPQUFPdXFFO0FBQ1Q7QUFFQSxJQUFJdTBELFFBQVEsQ0FBQztBQUNiQSxNQUFNQyw0QkFBNEIsR0FBRztJQUNuQyxJQUFJNytHLEtBQUssSUFBSSxDQUFDQSxFQUFFO0lBQ2hCLElBQUk4K0csZUFBZTkrRyxHQUFHcmUsVUFBVTtJQUNoQyxJQUFJcEYsSUFBSSxJQUFJO0lBQ1osSUFBSWt6RyxVQUFVLFNBQVNBLFFBQVEzbEYsSUFBSTtRQUNqQyxJQUFJaTFHLG1CQUFtQmg4SCxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDM0YrN0gsYUFBYXh5RyxLQUFLLENBQUN4QztRQUNuQixJQUFJaTFHLGtCQUFrQjtZQUNwQixJQUFLLElBQUkvL0gsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztnQkFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtnQkFDakIsSUFBSXVoQixLQUFLeEMsSUFBSW5jLFFBQVE7Z0JBQ3JCLElBQUltZixTQUFTUixHQUFHUSxNQUFNO2dCQUN0QkEsT0FBTzQ2QyxLQUFLLEdBQUc7Z0JBQ2Y1NkMsT0FBT2krRyxjQUFjLEdBQUc7WUFDMUI7UUFDRjtJQUNGO0lBQ0F6aUksRUFBRTBpSSxNQUFNLENBQUNqL0csSUFBSXN4QyxFQUFFLENBQUMsb0JBQW9CLFNBQVM0dEUsY0FBY3hpSSxDQUFDO1FBQzFELElBQUlxaEIsTUFBTXJoQixFQUFFNGpCLE1BQU07UUFDbEJtdkYsUUFBUTF4RjtJQUNWLEdBQUd1ekMsRUFBRSxDQUFDLHdCQUF3QixTQUFTNnRFLGFBQWF6aUksQ0FBQztRQUNuRCxJQUFJcWhCLE1BQU1yaEIsRUFBRTRqQixNQUFNO1FBQ2xCbXZGLFFBQVExeEYsS0FBSztJQUNmO0lBQ0EsSUFBSXFoSCxpQkFBaUIsU0FBU0EsZUFBZWx4QyxRQUFRO1FBQ25ELElBQUlBLFVBQVU7WUFDWixJQUFJbXhDLE1BQU05aUksRUFBRStpSSxtQkFBbUI7WUFFL0IscUVBQXFFO1lBQ3JFLHlFQUF5RTtZQUN6RVIsYUFBYTlpRCxVQUFVO1lBQ3ZCLElBQUssSUFBSWg5RSxJQUFJLEdBQUdBLElBQUk4L0gsYUFBYXJpSSxNQUFNLEVBQUV1QyxJQUFLO2dCQUM1QyxJQUFJK2UsTUFBTStnSCxZQUFZLENBQUM5L0gsRUFBRTtnQkFDekIsSUFBSStoQixTQUFTaEQsSUFBSW5jLFFBQVEsQ0FBQ21mLE1BQU07Z0JBQ2hDLElBQUloRCxJQUFJb0UsTUFBTSxNQUFNLENBQUNwQixPQUFPaStHLGNBQWMsRUFBRTtvQkFDMUN2dkIsUUFBUTF4RixJQUFJc0gsY0FBYztvQkFDMUJ0RSxPQUFPaStHLGNBQWMsR0FBRztnQkFDMUI7WUFDRjtZQUNBLElBQUlLLEtBQUs7Z0JBQ1AsSUFBSyxJQUFJMzVHLEtBQUssR0FBR0EsS0FBSzI1RyxJQUFJNWlJLE1BQU0sRUFBRWlwQixLQUFNO29CQUN0QyxJQUFJNWtCLEtBQUt1K0gsR0FBRyxDQUFDMzVHLEdBQUc7b0JBQ2hCNWtCLEdBQUdvdEYsVUFBVTR3QztnQkFDZjtZQUNGO1lBQ0F2aUksRUFBRTh4RSx3QkFBd0IsQ0FBQ3l3RDtZQUMzQkEsZUFBZTkrRyxHQUFHcmUsVUFBVTtRQUM5QjtJQUNGO0lBQ0FwRixFQUFFZ2pJLHVCQUF1QixHQUFHO1FBQzFCSCxlQUFlO0lBQ2pCO0lBQ0E3aUksRUFBRXl4RixZQUFZLENBQUNveEMsZ0JBQWdCN2lJLEVBQUU0eEYsc0JBQXNCLENBQUNxeEMsUUFBUTtBQUNsRTtBQUNBWixNQUFNYSxnQkFBZ0IsR0FBRyxTQUFVMytILEVBQUU7SUFDbkMsSUFBSXUrSCxNQUFNLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUcsSUFBSSxDQUFDQSxtQkFBbUIsSUFBSSxFQUFFO0lBQ25FRCxJQUFJcGdJLElBQUksQ0FBQzZCO0FBQ1g7QUFDQTg5SCxNQUFNdndELHdCQUF3QixHQUFHLFNBQVV2a0QsSUFBSSxFQUFFZzdDLFFBQVE7SUFDdkQsSUFBSTQ2RCxtQkFBbUIsU0FBU0EsaUJBQWlCM2hILEdBQUc7UUFDbEQsT0FBT0EsSUFBSW5jLFFBQVEsQ0FBQ21mLE1BQU0sQ0FBQ2krRyxjQUFjO0lBQzNDO0lBQ0EsSUFBSWwxRyxLQUFLcnRCLE1BQU0sS0FBSyxHQUFHO1FBQ3JCO0lBQ0Y7SUFDQSxJQUFJdWxCLFFBQVEsRUFBRTtJQUNkLElBQUlzQyxRQUFRLEVBQUU7SUFFZCw4RUFBOEU7SUFDOUUsSUFBSSxJQUFJLENBQUM2cUUsU0FBUyxFQUFFO1FBQ2xCO0lBQ0Y7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSXJxQixhQUFhdGxFLFdBQVc7UUFDMUJzbEUsV0FBVztJQUNiO0lBQ0EsSUFBSyxJQUFJOWxFLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtRQUNqQixJQUFJdWhCLEtBQUt4QyxJQUFJbmMsUUFBUTtRQUNyQixJQUFJbWYsU0FBU1IsR0FBR1EsTUFBTTtRQUV0QixvRUFBb0U7UUFDcEUsd0RBQXdEO1FBQ3hELElBQUloRCxJQUFJbTZCLE1BQU0sTUFBTyxFQUFDd25GLGlCQUFpQjNoSCxJQUFJc0MsTUFBTSxPQUFPLENBQUNxL0csaUJBQWlCM2hILElBQUl1QyxNQUFNLEdBQUUsR0FBSTtZQUN4RlMsT0FBTzQ2QyxLQUFLLEdBQUc7UUFDakI7UUFDQSxJQUFJNTlDLElBQUltNkIsTUFBTSxNQUFNbjZCLElBQUlvZ0UsZUFBZSxJQUFJO1lBQ3pDLElBQUlwZ0UsSUFBSTJqRSxhQUFhLEdBQUd0c0MsSUFBSSxDQUFDLFNBQVVyM0IsR0FBRztnQkFDeEMsT0FBTyxDQUFDQSxJQUFJbmMsUUFBUSxDQUFDbWYsTUFBTSxDQUFDNDZDLEtBQUssSUFBSTU5QyxJQUFJb2dFLGVBQWU7WUFDMUQsSUFBSTtnQkFDRnA5RCxPQUFPNDZDLEtBQUssR0FBRztZQUNqQjtRQUNGO1FBRUEsb0NBQW9DO1FBQ3BDLElBQUltSixZQUFZL2pELE9BQU80NkMsS0FBSyxJQUFJNTlDLElBQUltRCxPQUFPLElBQUk7WUFDN0M7UUFDRjtRQUVBLG1DQUFtQztRQUNuQyxJQUFJbkQsSUFBSTRtRCxNQUFNLENBQUMsV0FBV3RtRSxLQUFLLEtBQUssUUFBUTtZQUMxQztRQUNGO1FBQ0EsSUFBSWtpQixHQUFHSixLQUFLLEtBQUssU0FBUztZQUN4Qm1FLE1BQU1ybEIsSUFBSSxDQUFDOGU7UUFDYixPQUFPO1lBQ0wsUUFBUTtZQUNSaUUsTUFBTS9pQixJQUFJLENBQUM4ZTtRQUNiO1FBQ0FnRCxPQUFPNDZDLEtBQUssR0FBRztJQUNqQjtJQUVBLG9DQUFvQztJQUNwQyxJQUFLLElBQUlyMkMsTUFBTSxHQUFHQSxNQUFNaEIsTUFBTTduQixNQUFNLEVBQUU2b0IsTUFBTztRQUMzQyxJQUFJK3JDLE9BQU8vc0MsS0FBSyxDQUFDZ0IsSUFBSTtRQUNyQixJQUFJcTZHLE1BQU10dUUsS0FBS3p2RCxRQUFRO1FBQ3ZCLElBQUlnK0gsVUFBVUQsSUFBSTUrRyxNQUFNO1FBQ3hCLElBQUl2RixNQUFNNjFDLEtBQUs3d0MsUUFBUTtRQUN2QixJQUFJLENBQUM4M0csOEJBQThCLENBQUNqbkU7UUFDcEN1dUUsUUFBUTFsRyxLQUFLLEdBQUcxZSxJQUFJekssQ0FBQztRQUNyQjZ1SCxRQUFRemxHLEtBQUssR0FBRzNlLElBQUloQixDQUFDO1FBQ3JCb2xILFFBQVFDLEtBQUssR0FBR3h1RSxLQUFLc1QsTUFBTSxDQUFDLFNBQVNDLE9BQU87UUFDNUNnN0QsUUFBUUUsS0FBSyxHQUFHenVFLEtBQUtzVCxNQUFNLENBQUMsVUFBVUMsT0FBTztJQUMvQztJQUNBLElBQUksQ0FBQ3d6RCwwQkFBMEIsQ0FBQ3AyRztJQUVoQyxvQ0FBb0M7SUFDcEMsSUFBSyxJQUFJNlIsTUFBTSxHQUFHQSxNQUFNN1IsTUFBTXZsQixNQUFNLEVBQUVvM0IsTUFBTztRQUMzQyxJQUFJMnZDLFFBQVF4aEQsS0FBSyxDQUFDNlIsSUFBSTtRQUN0QixJQUFJa3NHLE1BQU12OEQsTUFBTTVoRSxRQUFRO1FBQ3hCLElBQUlvK0gsV0FBV0QsSUFBSWgvRyxNQUFNO1FBQ3pCLElBQUk2Z0csS0FBS21lLElBQUlqK0csUUFBUTtRQUVyQiwwQkFBMEI7UUFDMUJrK0csU0FBU2o1RCxJQUFJLEdBQUc2NkMsR0FBR1csV0FBVztRQUM5QnlkLFNBQVNoNUQsSUFBSSxHQUFHNDZDLEdBQUdZLFdBQVc7UUFDOUJ3ZCxTQUFTLzRELElBQUksR0FBRzI2QyxHQUFHYyxTQUFTO1FBQzVCc2QsU0FBUzk0RCxJQUFJLEdBQUcwNkMsR0FBR2UsU0FBUztRQUM1QnFkLFNBQVM3NEQsSUFBSSxHQUFHeTZDLEdBQUd6NkMsSUFBSTtRQUN2QjY0RCxTQUFTNTRELElBQUksR0FBR3c2QyxHQUFHeDZDLElBQUk7UUFDdkI0NEQsU0FBUzNCLFVBQVUsR0FBR3pjLEdBQUd5YyxVQUFVO1FBQ25DMkIsU0FBUzFCLGdCQUFnQixHQUFHMWMsR0FBRzBjLGdCQUFnQjtRQUMvQzBCLFNBQVN6QixnQkFBZ0IsR0FBRzNjLEdBQUcyYyxnQkFBZ0I7SUFDakQ7QUFDRjtBQUVBLElBQUkwQixRQUFRLENBQUM7QUFDYkEsTUFBTUMsdUJBQXVCLEdBQUc7SUFDOUIsSUFBSXAyRyxPQUFPLElBQUksQ0FBQ3EyRyxpQkFBaUI7SUFDakMsSUFBSSxDQUFDcjJHLE1BQU07UUFDVCx3REFBd0Q7UUFDeEQ7SUFDRjtJQUNBQSxLQUFLczJHLElBQUksR0FBRyxFQUFFO0lBQ2R0MkcsS0FBS3UyRyxPQUFPLEdBQUcsRUFBRTtJQUNqQixJQUFJQyxjQUFjLEVBQUU7SUFDcEIsSUFBSyxJQUFJdGhJLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSStlLE1BQU0rTCxJQUFJLENBQUM5cUIsRUFBRTtRQUNqQixJQUFJNGlILEtBQUs3akcsSUFBSW5jLFFBQVEsQ0FBQ2tnQixRQUFRO1FBQzlCLElBQUkvRCxJQUFJdUQsT0FBTyxNQUFNLENBQUN2RCxJQUFJaTVDLFFBQVEsSUFBSTtZQUNwQ3NwRSxZQUFZcmhJLElBQUksQ0FBQzhlO1FBQ25CLE9BQU8sSUFBSTZqRyxHQUFHMmUsV0FBVyxFQUFFO1lBQ3pCejJHLEtBQUtzMkcsSUFBSSxDQUFDbmhJLElBQUksQ0FBQzhlO1FBQ2pCLE9BQU87WUFDTCtMLEtBQUt1MkcsT0FBTyxDQUFDcGhJLElBQUksQ0FBQzhlO1FBQ3BCO0lBQ0Y7SUFFQSxxRUFBcUU7SUFDckUsSUFBSyxJQUFJL2UsSUFBSSxHQUFHQSxJQUFJc2hJLFlBQVk3akksTUFBTSxFQUFFdUMsSUFBSztRQUMzQyxJQUFJK2UsTUFBTXVpSCxXQUFXLENBQUN0aEksRUFBRTtRQUN4QjhxQixLQUFLczJHLElBQUksQ0FBQ25oSSxJQUFJLENBQUM4ZTtJQUNqQjtBQUNGO0FBQ0FraUgsTUFBTU8sMkJBQTJCLEdBQUc7SUFDbEMsSUFBSSxDQUFDTCxpQkFBaUIsR0FBRztBQUMzQjtBQUNBRixNQUFNbGYsb0JBQW9CLEdBQUcsU0FBVTBmLFdBQVc7SUFDaEQsSUFBSUEsZUFBZSxDQUFDLElBQUksQ0FBQ04saUJBQWlCLEVBQUU7UUFDMUMsSUFBSXIyRyxPQUFPLElBQUksQ0FBQzlKLEVBQUUsQ0FBQ3cxRCxlQUFlLEdBQUdqMkQsT0FBTztRQUM1Q3VLLEtBQUt6QixJQUFJLENBQUMwdkQ7UUFDVmp1RCxLQUFLZzBELFdBQVcsR0FBR2gwRCxLQUFLcEssTUFBTSxDQUFDLFNBQVUzQixHQUFHO1lBQzFDLE9BQU9BLElBQUkrL0QsV0FBVztRQUN4QjtRQUNBLElBQUksQ0FBQ3FpRCxpQkFBaUIsR0FBR3IyRztRQUN6QixJQUFJLENBQUNvMkcsdUJBQXVCO0lBQzlCLE9BQU87UUFDTHAyRyxPQUFPLElBQUksQ0FBQ3EyRyxpQkFBaUI7SUFDL0I7SUFDQSxPQUFPcjJHO0FBQ1Q7QUFFQSxJQUFJNDJHLFFBQVEsQ0FBQztBQUNiO0lBQUNqaEI7SUFBTzRGO0lBQU80RDtJQUFPMEw7SUFBT21EO0lBQU9PO0lBQU9tRztJQUFPSTtJQUFPcUI7Q0FBTSxDQUFDdGdILE9BQU8sQ0FBQyxTQUFVaTdCLEtBQUs7SUFDckY1MUMsT0FBTzA3SCxPQUFPOWxGO0FBQ2hCO0FBRUEsSUFBSStsRixRQUFRLENBQUM7QUFDYkEsTUFBTUMsY0FBYyxHQUFHLFNBQVVuOUIsR0FBRyxFQUFFbzlCLFdBQVcsRUFBRUMsTUFBTTtJQUN2RCxJQUFJdmtJLElBQUksSUFBSTtJQUNaLElBQUl3a0ksYUFBYXhrSSxFQUFFd2tJLFVBQVUsR0FBR3hrSSxFQUFFd2tJLFVBQVUsSUFBSSxDQUFDO0lBQ2pELElBQUl2OUgsUUFBUXU5SCxVQUFVLENBQUN0OUIsSUFBSTtJQUMzQixJQUFJamdHLE9BQU87UUFDVCxJQUFJLENBQUNBLE1BQU13OUgsS0FBSyxDQUFDdGpGLFFBQVEsRUFBRTtZQUN6Qmw2QyxNQUFNdzlILEtBQUssQ0FBQ0MsZ0JBQWdCLENBQUMsUUFBUUg7UUFDdkM7UUFDQSxPQUFPdDlILE1BQU13OUgsS0FBSztJQUNwQixPQUFPO1FBQ0x4OUgsUUFBUXU5SCxVQUFVLENBQUN0OUIsSUFBSSxHQUFHczlCLFVBQVUsQ0FBQ3Q5QixJQUFJLElBQUksQ0FBQztRQUM5QyxJQUFJdTlCLFFBQVF4OUgsTUFBTXc5SCxLQUFLLEdBQUcsSUFBSUUsU0FBUywrQkFBK0I7UUFFdEVGLE1BQU1DLGdCQUFnQixDQUFDLFFBQVFIO1FBQy9CRSxNQUFNQyxnQkFBZ0IsQ0FBQyxTQUFTO1lBQzlCRCxNQUFNcmtILEtBQUssR0FBRztRQUNoQjtRQUVBLGdFQUFnRTtRQUNoRSxpREFBaUQ7UUFDakQsSUFBSXdrSCxnQkFBZ0I7UUFDcEIsSUFBSUMsWUFBWTM5QixJQUFJdi9GLFNBQVMsQ0FBQyxHQUFHaTlILGNBQWMxa0ksTUFBTSxFQUFFb0gsV0FBVyxPQUFPczlIO1FBQ3pFLElBQUksQ0FBQ0MsV0FBVztZQUNkLHVFQUF1RTtZQUN2RVAsY0FBY0EsZ0JBQWdCLFNBQVMsT0FBT0E7WUFDOUNHLE1BQU1ILFdBQVcsR0FBR0EsYUFBYSx5QkFBeUI7UUFDNUQ7UUFDQUcsTUFBTS83RyxHQUFHLEdBQUd3K0U7UUFDWixPQUFPdTlCO0lBQ1Q7QUFDRjtBQUVBLElBQUlLLFFBQVEsQ0FBQztBQUViLHFEQUFxRCxHQUVyREEsTUFBTUMsZUFBZSxHQUFHLFNBQVVoaEgsTUFBTSxFQUFFdGUsS0FBSyxFQUFFc3hFLE9BQU8sRUFBRWl1RCxVQUFVO0lBQ2xFLHFDQUFxQztJQUNyQyxJQUFJditILE9BQU9wRyxNQUFNaUIsU0FBUyxDQUFDZ0MsS0FBSyxDQUFDMEQsS0FBSyxDQUFDUixXQUFXO1FBQUM7S0FBRSxHQUFHLE9BQU87SUFFL0QsSUFBSW5HLE1BQU1FLE9BQU8sQ0FBQ3dqQixTQUFTO1FBQ3pCLElBQUk4TyxNQUFNLEVBQUU7UUFDWixJQUFLLElBQUlwd0IsSUFBSSxHQUFHQSxJQUFJc2hCLE9BQU83akIsTUFBTSxFQUFFdUMsSUFBSztZQUN0QyxJQUFJN0IsSUFBSW1qQixNQUFNLENBQUN0aEIsRUFBRTtZQUNqQixJQUFJN0IsTUFBTXFDLFdBQVc7Z0JBQ25CLElBQUlzRixJQUFJLElBQUksQ0FBQ202SCxNQUFNLENBQUM5aEk7Z0JBQ3BCaXlCLElBQUlud0IsSUFBSSxDQUFDNkYsRUFBRXdzRCxFQUFFLENBQUMvdEQsS0FBSyxDQUFDdUIsR0FBRzlCO1lBQ3pCO1FBQ0Y7UUFDQSxPQUFPb3NCO0lBQ1Q7SUFDQSxJQUFJdHFCLElBQUksSUFBSSxDQUFDbTZILE1BQU0sQ0FBQzMrRztJQUNwQixPQUFPeGIsRUFBRXdzRCxFQUFFLENBQUMvdEQsS0FBSyxDQUFDdUIsR0FBRzlCO0FBQ3ZCO0FBQ0FxK0gsTUFBTXBDLE1BQU0sR0FBRyxTQUFVOTVILEdBQUc7SUFDMUIsSUFBSTVJLElBQUksSUFBSTtJQUNaLElBQUkwZ0csa0JBQWtCMWdHLEVBQUV5akIsRUFBRSxDQUFDL2YsTUFBTTtJQUNqQyxJQUFJdWhJLFdBQVdyOEgsUUFBUTgzRixtQkFBbUI5M0YsUUFBUTgzRixnQkFBZ0I5OEYsUUFBUSxJQUFJZ0YsUUFBUTgzRixnQkFBZ0I5OEYsUUFBUSxDQUFDc2hJLElBQUksSUFBSXQvSCxXQUFXZ0Q7SUFDbEksSUFBSTVJLEVBQUVtbEkscUJBQXFCLElBQUksTUFBTTtRQUNuQyxpR0FBaUc7UUFDakcsSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUk7WUFDRixJQUFJaGtILE9BQU9uZ0IsT0FBT0MsY0FBYyxDQUFDLENBQUMsR0FBRyxXQUFXO2dCQUM5Q3NoQixLQUFLLFNBQVNBO29CQUNaNGlILGtCQUFrQjtvQkFDbEIsT0FBTztnQkFDVDtZQUNGO1lBQ0Exa0MsZ0JBQWdCZ2tDLGdCQUFnQixDQUFDLFFBQVEsTUFBTXRqSDtRQUNqRCxFQUFFLE9BQU80b0IsS0FBSztRQUNaLGdCQUFnQjtRQUNsQjtRQUNBaHFDLEVBQUVtbEkscUJBQXFCLEdBQUdDO0lBQzVCO0lBQ0EsSUFBSXJ3RSxLQUFLLFNBQVNBLEdBQUd0dkQsS0FBSyxFQUFFc3hFLE9BQU8sRUFBRWl1RCxVQUFVO1FBQzdDLElBQUl2K0gsT0FBT3BHLE1BQU1pQixTQUFTLENBQUNnQyxLQUFLLENBQUNyQixJQUFJLENBQUN1RTtRQUN0QyxJQUFJeStILFlBQVlqbEksRUFBRW1sSSxxQkFBcUIsRUFBRTtZQUN2QyxpQ0FBaUM7WUFDakMxK0gsSUFBSSxDQUFDLEVBQUUsR0FBRztnQkFDUjQrSCxTQUFTTCxjQUFjLE9BQU9BLGFBQWE7Z0JBQzNDTSxTQUFTO2dCQUNUcHRELE1BQU07WUFDUjtRQUNGO1FBQ0FsNEUsRUFBRXVsSSxRQUFRLENBQUM3aUksSUFBSSxDQUFDO1lBQ2RxaEIsUUFBUW5iO1lBQ1JuQyxNQUFNQTtRQUNSO1FBQ0NtQyxDQUFBQSxJQUFJODdILGdCQUFnQixJQUFJOTdILElBQUltc0QsRUFBRSxFQUFFL3RELEtBQUssQ0FBQzRCLEtBQUtuQztRQUM1QyxPQUFPLElBQUk7SUFDYjtJQUNBLE9BQU87UUFDTHN1RCxJQUFJQTtRQUNKMnZFLGtCQUFrQjN2RTtRQUNsQmdCLGFBQWFoQjtRQUNicHNELE1BQU1vc0Q7SUFDUjtBQUNGO0FBQ0ErdkUsTUFBTVUsZUFBZSxHQUFHLFNBQVVwOEcsSUFBSTtJQUNwQyxPQUFPQSxRQUFRQSxLQUFLeEQsTUFBTSxNQUFNLENBQUN3RCxLQUFLdEUsTUFBTSxNQUFNc0UsS0FBS3BFLFNBQVM7QUFDbEU7QUFDQTgvRyxNQUFNVyxlQUFlLEdBQUcsU0FBVXI4RyxJQUFJO0lBQ3BDLE9BQU8sSUFBSSxDQUFDbzhHLGVBQWUsQ0FBQ3A4RyxTQUFTQSxLQUFLbTRELFdBQVc7QUFDdkQ7QUFDQXVqRCxNQUFNWSxJQUFJLEdBQUc7SUFDWCxJQUFJMWxJLElBQUksSUFBSTtJQUNaLElBQUkwZ0csa0JBQWtCMWdHLEVBQUV5akIsRUFBRSxDQUFDL2YsTUFBTTtJQUNqQyxJQUFJaWlJLGFBQWEsU0FBU0EsV0FBV25rSCxHQUFHO1FBQ3RDLE9BQU9BLElBQUlvRCxRQUFRO0lBQ3JCO0lBQ0EsSUFBSWdoSCxnQkFBZ0IsU0FBU0EsY0FBY3pnSSxPQUFPO1FBQ2hELElBQUkwZ0ksV0FBVzFnSSxRQUFRMmdJLFdBQVc7UUFDbEMsMENBQTBDO1FBQzFDLElBQUlELFlBQVlBLFNBQVNFLFFBQVEsS0FBSyxNQUFNRixTQUFTRyxJQUFJLEtBQUsvaUksV0FBVztZQUN2RSxPQUFPNGlJO1FBQ1Q7SUFDRjtJQUNBLElBQUlJLGdCQUFnQixTQUFTQSxjQUFjbGlILE1BQU0sRUFBRW94QyxLQUFLLEVBQUVoMUQsQ0FBQyxFQUFFOGpCLFFBQVE7UUFDbkUsSUFBSUYsVUFBVSxNQUFNO1lBQ2xCQSxTQUFTL2pCLEVBQUV5akIsRUFBRTtRQUNmO1FBQ0EsSUFBSyxJQUFJaGhCLElBQUksR0FBR0EsSUFBSTB5RCxNQUFNajFELE1BQU0sRUFBRXVDLElBQUs7WUFDckMsSUFBSWMsT0FBTzR4RCxLQUFLLENBQUMxeUQsRUFBRTtZQUNuQnNoQixPQUFPc3lDLElBQUksQ0FBQztnQkFDVmtmLGVBQWVwMUU7Z0JBQ2Y0VSxNQUFNeFI7Z0JBQ04wZ0IsVUFBVUE7WUFDWjtRQUNGO0lBQ0Y7SUFDQSxJQUFJaWlILG1CQUFtQixTQUFTQSxpQkFBaUIvbEksQ0FBQztRQUNoRCxPQUFPQSxFQUFFZ21JLFFBQVEsSUFBSWhtSSxFQUFFaW1JLE9BQU8sSUFBSWptSSxFQUFFa21JLE9BQU8sRUFBRSxpQkFBaUI7SUFDaEU7SUFDQSxJQUFJQywwQkFBMEIsU0FBU0Esd0JBQXdCQyxJQUFJLEVBQUVDLEtBQUs7UUFDeEUsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUl6bUksRUFBRXlqQixFQUFFLENBQUM2Z0QsZ0JBQWdCLE1BQU1paUUsUUFBUUEsS0FBS3RoSCxRQUFRLElBQUk7WUFDdEQsb0VBQW9FO1lBQ3BFLElBQUssSUFBSXhpQixJQUFJLEdBQUcrakksU0FBUy9qSSxJQUFJK2pJLE1BQU10bUksTUFBTSxFQUFFdUMsSUFBSztnQkFDOUMsSUFBSThqSSxPQUFPQyxLQUFLLENBQUMvakksRUFBRTtnQkFFbkIsMEVBQTBFO2dCQUMxRSxJQUFJOGpJLEtBQUszZ0gsTUFBTSxNQUFNMmdILEtBQUs5ckUsUUFBUSxNQUFNLENBQUM4ckUsS0FBS3RoSCxRQUFRLElBQUk7b0JBQ3hEd2hILG1CQUFtQjtvQkFDbkI7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU87WUFDTEEsbUJBQW1CO1FBQ3JCO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLElBQUlDLGFBQWEsU0FBU0EsV0FBV2xsSCxHQUFHO1FBQ3RDQSxHQUFHLENBQUMsRUFBRSxDQUFDbmMsUUFBUSxDQUFDMGYsT0FBTyxHQUFHO0lBQzVCO0lBQ0EsSUFBSTRoSCxXQUFXLFNBQVNBLFNBQVNubEgsR0FBRztRQUNsQ0EsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVEsQ0FBQzBmLE9BQU8sR0FBRztJQUM1QjtJQUNBLElBQUk2aEgsaUJBQWlCLFNBQVNBLGVBQWVwbEgsR0FBRztRQUM5Q0EsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVEsQ0FBQ2tnQixRQUFRLENBQUN5K0csV0FBVyxHQUFHO0lBQ3pDO0lBQ0EsSUFBSTZDLGtCQUFrQixTQUFTQSxnQkFBZ0JybEgsR0FBRztRQUNoREEsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVEsQ0FBQ2tnQixRQUFRLENBQUN5K0csV0FBVyxHQUFHO0lBQ3pDO0lBQ0EsSUFBSThDLGdCQUFnQixTQUFTQSxjQUFjdGxILEdBQUc7UUFDNUNBLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRLENBQUNrZ0IsUUFBUSxDQUFDd2hILFlBQVksR0FBRztJQUMxQztJQUNBLElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJ4bEgsR0FBRztRQUNsREEsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVEsQ0FBQ2tnQixRQUFRLENBQUN3aEgsWUFBWSxHQUFHO0lBQzFDO0lBQ0EsSUFBSUUsZ0JBQWdCLFNBQVNBLGNBQWN6bEgsR0FBRyxFQUFFSixJQUFJO1FBQ2xELElBQUk4bEgsT0FBTzlsSCxLQUFLK2xILFNBQVM7UUFDekIsSUFBSUMsYUFBYUYsS0FBSzNrSCxHQUFHLENBQUNmO1FBQzFCLElBQUksQ0FBQzRsSCxjQUFjNWxILElBQUl3RCxTQUFTLE1BQU0sQ0FBQ3hELElBQUlzRCxNQUFNLElBQUk7WUFDbkRvaUgsS0FBS24zRyxLQUFLLENBQUN2TztZQUNYa2xILFdBQVdsbEg7UUFDYjtJQUNGO0lBRUEsaUVBQWlFO0lBQ2pFLDZFQUE2RTtJQUM3RSxJQUFJNmxILHVCQUF1QixTQUFTQSxxQkFBcUJqK0csSUFBSSxFQUFFaEksSUFBSTtRQUNqRSxJQUFJLENBQUNnSSxLQUFLM0YsRUFBRSxHQUFHNmdELGdCQUFnQixJQUFJO1lBQ2pDO1FBQ0Y7UUFDQSxJQUFJbGpELEtBQUs0aUgsV0FBVyxJQUFJLFFBQVE1aUgsS0FBSytsSCxTQUFTLElBQUksTUFBTTtZQUN0RDtRQUNGLEVBQUUsZ0JBQWdCO1FBRWxCLElBQUlHLGFBQWFsK0csS0FBS280QyxXQUFXO1FBQ2pDLElBQUlwZ0QsS0FBSzRpSCxXQUFXLEVBQUU7WUFDcEJzRCxXQUFXbGtILE9BQU8sQ0FBQ3dqSDtZQUNuQlUsV0FBV3grRyxjQUFjLEdBQUcxRixPQUFPLENBQUN3akg7UUFDdEM7UUFDQSxJQUFJeGxILEtBQUsrbEgsU0FBUyxFQUFFO1lBQ2xCRixjQUFjSyxZQUFZbG1IO1FBQzVCO0lBQ0Y7SUFFQSwrREFBK0Q7SUFDL0QsSUFBSW1tSCxpQkFBaUIsU0FBU0EsZUFBZXgvRyxLQUFLLEVBQUUzRyxJQUFJO1FBQ3REQSxPQUFPQSxRQUFRLENBQUM7UUFDaEIsSUFBSWtqRCxtQkFBbUJ2OEMsTUFBTXRFLEVBQUUsR0FBRzZnRCxnQkFBZ0I7UUFDbEQsSUFBSWxqRCxLQUFLNGlILFdBQVcsRUFBRTtZQUNwQmo4RyxNQUFNM0UsT0FBTyxDQUFDd2pIO1lBQ2Q3K0csTUFBTThHLFlBQVksR0FBRzgwQyxTQUFTLENBQUMsU0FBVW5pRCxHQUFHO2dCQUMxQyxPQUFPLENBQUM4aUQsb0JBQW9COWlELElBQUltNkIsTUFBTTtZQUN4QyxHQUFHdjRCLE9BQU8sQ0FBQ3dqSDtRQUNiO1FBQ0EsSUFBSXhsSCxLQUFLK2xILFNBQVMsRUFBRTtZQUNsQnAvRyxNQUFNM0UsT0FBTyxDQUFDLFNBQVU1QixHQUFHO2dCQUN6QnlsSCxjQUFjemxILEtBQUtKO1lBQ3JCO1FBQ0Y7UUFDQWltSCxxQkFBcUJ0L0csT0FBTzNHLE9BQU8scUJBQXFCO1FBRXhELDJEQUEyRDtRQUMzRG9tSCwyQkFBMkJ6L0csT0FBTztZQUNoQ2k4RyxhQUFhNWlILEtBQUs0aUgsV0FBVztRQUMvQjtRQUNBaGtJLEVBQUUyakksdUJBQXVCO0lBQzNCO0lBQ0EsSUFBSThELGdCQUFnQkY7SUFDcEIsSUFBSUcsc0JBQXNCLFNBQVNBLG9CQUFvQkMsV0FBVztRQUNoRSxJQUFJLENBQUNBLGFBQWE7WUFDaEI7UUFDRjtRQUVBLHlGQUF5RjtRQUN6RjNuSSxFQUFFd2tILG9CQUFvQixHQUFHcGhHLE9BQU8sQ0FBQyxTQUFVNUIsR0FBRztZQUM1Q21sSCxTQUFTbmxIO1lBQ1RxbEgsZ0JBQWdCcmxIO1lBQ2hCd2xILGlCQUFpQnhsSDtRQUNuQjtRQUNBeGhCLEVBQUUyakksdUJBQXVCO0lBQzNCO0lBRUEsd0VBQXdFO0lBQ3hFLDREQUE0RDtJQUM1RCxJQUFJNkQsNkJBQTZCLFNBQVNBLDJCQUEyQnArRyxJQUFJLEVBQUVoSSxJQUFJO1FBQzdFLElBQUlBLEtBQUs0aUgsV0FBVyxJQUFJLFFBQVE1aUgsS0FBSytsSCxTQUFTLElBQUksTUFBTTtZQUN0RDtRQUNGLEVBQUUsZ0JBQWdCO1FBRWxCLElBQUksQ0FBQy85RyxLQUFLM0YsRUFBRSxHQUFHNmdELGdCQUFnQixJQUFJO1lBQ2pDO1FBQ0Y7UUFFQSx3QkFBd0I7UUFDeEIsSUFBSTMrQyxTQUFTeUQsS0FBS200QyxTQUFTLEdBQUdtQyxPQUFPO1FBRXJDLG9EQUFvRDtRQUNwRCxJQUFJLzlDLE9BQU9pRCxJQUFJLENBQUNRLE9BQU87WUFDckI7UUFDRjtRQUNBLElBQUlyQixRQUFRcEMsT0FBTzY3QyxXQUFXLEdBQUdvWSxTQUFTLEdBQUc3cEQsS0FBSyxDQUFDcEssUUFBUXkwRCxPQUFPLENBQUNoeEQsTUFBTWd4RCxPQUFPLENBQUNoeEQsS0FBS280QyxXQUFXO1FBQ2pHLElBQUkvN0MsUUFBUXNDLE1BQU1lLGNBQWM7UUFDaEMsSUFBSTFILEtBQUs0aUgsV0FBVyxFQUFFO1lBQ3BCditHLE1BQU1yQyxPQUFPLENBQUN3akg7WUFDZDcrRyxNQUFNM0UsT0FBTyxDQUFDd2pIO1FBQ2hCO1FBQ0EsSUFBSXhsSCxLQUFLK2xILFNBQVMsRUFBRTtZQUNsQnAvRyxNQUFNM0UsT0FBTyxDQUFDLFNBQVU1QixHQUFHO2dCQUN6QnlsSCxjQUFjemxILEtBQUtKO1lBQ3JCO1FBQ0Y7SUFDRjtJQUNBLElBQUl3bUgsdUJBQXVCLFNBQVNBO1FBQ2xDLElBQUloa0ksU0FBU2lrSSxhQUFhLElBQUksUUFBUWprSSxTQUFTaWtJLGFBQWEsQ0FBQ0MsSUFBSSxJQUFJLE1BQU07WUFDekVsa0ksU0FBU2lrSSxhQUFhLENBQUNDLElBQUk7UUFDN0I7SUFDRjtJQUNBLElBQUlDLG1CQUFtQixPQUFPQyxxQkFBcUI7SUFDbkQsSUFBSUMsd0JBQXdCLE9BQU9DLG1CQUFtQjtJQUV0RCwwREFBMEQ7SUFDMUQsSUFBSUgsa0JBQWtCO1FBQ3BCL25JLEVBQUVtb0ksY0FBYyxHQUFHLElBQUlILGlCQUFpQixTQUFVSSxLQUFLO1lBQ3JELCtCQUErQjtZQUMvQixJQUFLLElBQUkzbEksSUFBSSxHQUFHQSxJQUFJMmxJLE1BQU1sb0ksTUFBTSxFQUFFdUMsSUFBSztnQkFDckMsSUFBSTRsSSxPQUFPRCxLQUFLLENBQUMzbEksRUFBRTtnQkFDbkIsSUFBSTZsSSxTQUFTRCxLQUFLRSxZQUFZO2dCQUM5QixJQUFJRCxRQUFRO29CQUNWLElBQUssSUFBSXgvSCxJQUFJLEdBQUdBLElBQUl3L0gsT0FBT3BvSSxNQUFNLEVBQUU0SSxJQUFLO3dCQUN0QyxJQUFJMC9ILFFBQVFGLE1BQU0sQ0FBQ3gvSCxFQUFFO3dCQUNyQixJQUFJMC9ILFVBQVV4b0ksRUFBRWkxRixTQUFTLEVBQUU7NEJBQ3pCajFGLEVBQUVrdkcsT0FBTzs0QkFDVDt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJbHZHLEVBQUVpMUYsU0FBUyxDQUFDd3pDLFVBQVUsRUFBRTtZQUMxQnpvSSxFQUFFbW9JLGNBQWMsQ0FBQ08sT0FBTyxDQUFDMW9JLEVBQUVpMUYsU0FBUyxDQUFDd3pDLFVBQVUsRUFBRTtnQkFDL0NFLFdBQVc7WUFDYjtRQUNGO0lBQ0YsT0FBTztRQUNMM29JLEVBQUUra0ksZUFBZSxDQUFDL2tJLEVBQUVpMUYsU0FBUyxFQUFFLGtCQUFrQixTQUFVOTBGLENBQUM7WUFDMUQscUNBQXFDO1lBQ3JDSCxFQUFFa3ZHLE9BQU87UUFDWDtJQUNGO0lBQ0EsSUFBSTA1QixXQUFXNXVILFNBQVM7UUFDdEJoYSxFQUFFeWpCLEVBQUUsQ0FBQ2l4RSxNQUFNO0lBQ2IsR0FBRztJQUNILElBQUlxekMsa0JBQWtCO1FBQ3BCL25JLEVBQUU2b0ksYUFBYSxHQUFHLElBQUliLGlCQUFpQlksV0FBVywrQkFBK0I7UUFFakY1b0ksRUFBRTZvSSxhQUFhLENBQUNILE9BQU8sQ0FBQzFvSSxFQUFFaTFGLFNBQVMsRUFBRTtZQUNuQzVrRCxZQUFZO1FBQ2Q7SUFDRjtJQUVBLGNBQWM7SUFDZHJ3QyxFQUFFK2tJLGVBQWUsQ0FBQ3JrQyxpQkFBaUIsVUFBVWtvQyxXQUFXLCtCQUErQjtJQUV2RixJQUFJWCx1QkFBdUI7UUFDekJqb0ksRUFBRThvSSxjQUFjLEdBQUcsSUFBSVosZUFBZVUsV0FBVywrQkFBK0I7UUFFaEY1b0ksRUFBRThvSSxjQUFjLENBQUNKLE9BQU8sQ0FBQzFvSSxFQUFFaTFGLFNBQVM7SUFDdEM7SUFDQSxJQUFJdndCLFlBQVksU0FBU0EsVUFBVXN3QixNQUFNLEVBQUV6d0YsRUFBRTtRQUMzQyxNQUFPeXdGLFVBQVUsS0FBTTtZQUNyQnp3RixHQUFHeXdGO1lBQ0hBLFNBQVNBLE9BQU95ekMsVUFBVTtRQUM1QjtJQUNGO0lBQ0EsSUFBSU0sbUJBQW1CLFNBQVNBO1FBQzlCL29JLEVBQUVta0gsb0NBQW9DO0lBQ3hDO0lBQ0F6L0MsVUFBVTFrRSxFQUFFaTFGLFNBQVMsRUFBRSxTQUFVRCxNQUFNO1FBQ3JDaDFGLEVBQUUra0ksZUFBZSxDQUFDL3ZDLFFBQVEsaUJBQWlCK3pDO1FBQzNDL29JLEVBQUUra0ksZUFBZSxDQUFDL3ZDLFFBQVEsZ0JBQWdCK3pDO1FBQzFDL29JLEVBQUUra0ksZUFBZSxDQUFDL3ZDLFFBQVEsVUFBVSt6QztJQUN0QztJQUVBLDZDQUE2QztJQUM3Qy9vSSxFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxlQUFlLFNBQVU5MEYsQ0FBQztRQUN2REEsRUFBRWsxRSxjQUFjO0lBQ2xCO0lBQ0EsSUFBSTJ6RCxpQkFBaUIsU0FBU0E7UUFDNUIsT0FBT2hwSSxFQUFFaXBJLFNBQVMsQ0FBQyxFQUFFLEtBQUs7SUFDNUI7SUFDQSxJQUFJQyxtQkFBbUIsU0FBU0EsaUJBQWlCL29JLENBQUM7UUFDaEQsb0RBQW9EO1FBQ3BELElBQUlncEksc0JBQXNCbnBJLEVBQUV1akgseUJBQXlCO1FBQ3JELElBQUkvdUcsSUFBSTIwSCxtQkFBbUIsQ0FBQyxFQUFFO1FBQzlCLElBQUlsckgsSUFBSWtySCxtQkFBbUIsQ0FBQyxFQUFFO1FBQzlCLElBQUkvckcsUUFBUStyRyxtQkFBbUIsQ0FBQyxFQUFFO1FBQ2xDLElBQUk5ckcsU0FBUzhyRyxtQkFBbUIsQ0FBQyxFQUFFO1FBQ25DLElBQUk1aUUsWUFBWXBtRSxFQUFFaXBJLE9BQU8sR0FBR2pwSSxFQUFFaXBJLE9BQU8sR0FBRztZQUFDanBJO1NBQUU7UUFDM0MsSUFBSWtwSSxzQkFBc0I7UUFDMUIsSUFBSyxJQUFJNW1JLElBQUksR0FBR0EsSUFBSThqRSxVQUFVcm1FLE1BQU0sRUFBRXVDLElBQUs7WUFDekMsSUFBSWdILElBQUk4OEQsU0FBUyxDQUFDOWpFLEVBQUU7WUFDcEIsSUFBSStSLEtBQUsvSyxFQUFFMjVHLE9BQU8sSUFBSTM1RyxFQUFFMjVHLE9BQU8sSUFBSTV1RyxJQUFJNG9CLFNBQVNuZixLQUFLeFUsRUFBRTQ1RyxPQUFPLElBQUk1NUcsRUFBRTQ1RyxPQUFPLElBQUlwbEcsSUFBSW9mLFFBQVE7Z0JBQ3pGZ3NHLHNCQUFzQjtnQkFDdEI7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxxQkFBcUI7WUFDeEIsT0FBTztRQUNUO1FBQ0EsSUFBSXAwQyxZQUFZajFGLEVBQUVpMUYsU0FBUztRQUMzQixJQUFJbHhFLFNBQVM1akIsRUFBRTRqQixNQUFNO1FBQ3JCLElBQUl1bEgsVUFBVXZsSCxPQUFPMGtILFVBQVU7UUFDL0IsSUFBSWMsb0JBQW9CO1FBQ3hCLE1BQU9ELFFBQVM7WUFDZCxJQUFJQSxZQUFZcjBDLFdBQVc7Z0JBQ3pCczBDLG9CQUFvQjtnQkFDcEI7WUFDRjtZQUNBRCxVQUFVQSxRQUFRYixVQUFVO1FBQzlCO1FBQ0EsSUFBSSxDQUFDYyxtQkFBbUI7WUFDdEIsT0FBTztRQUNULEVBQUUsbUVBQW1FO1FBRXJFLE9BQU87SUFDVDtJQUVBLGNBQWM7SUFDZHZwSSxFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxhQUFhLFNBQVN1MEMsaUJBQWlCcnBJLENBQUM7UUFDckUsSUFBSSxDQUFDK29JLGlCQUFpQi9vSSxJQUFJO1lBQ3hCO1FBQ0Y7UUFFQSwwREFBMEQ7UUFDMUQsSUFBSUgsRUFBRXlwSSxTQUFTLENBQUNDLEtBQUssS0FBSyxLQUFLdnBJLEVBQUV1cEksS0FBSyxLQUFLLEdBQUc7WUFDNUM7UUFDRjtRQUNBdnBJLEVBQUVrMUUsY0FBYztRQUNoQnV5RDtRQUNBNW5JLEVBQUV5cEksU0FBUyxDQUFDcEUsT0FBTyxHQUFHO1FBQ3RCcmxJLEVBQUV5cEksU0FBUyxDQUFDQyxLQUFLLEdBQUd2cEksRUFBRXVwSSxLQUFLO1FBQzNCLElBQUlqbUgsS0FBS3pqQixFQUFFeWpCLEVBQUU7UUFDYixJQUFJa21ILE9BQU87WUFBQ3hwSSxFQUFFaWpILE9BQU87WUFBRWpqSCxFQUFFa2pILE9BQU87U0FBQztRQUNqQyxJQUFJcGtHLE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDd21CLElBQUksQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQyxFQUFFO1FBQ2hELElBQUlDLFNBQVM1cEksRUFBRWlwSSxTQUFTO1FBQ3hCLElBQUlZLFFBQVE3cEksRUFBRXVrSCxtQkFBbUIsQ0FBQ3RsRyxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFLE1BQU07UUFDeEQsSUFBSXdsRyxPQUFPb2xCLEtBQUssQ0FBQyxFQUFFO1FBQ25CLElBQUlDLGtCQUFrQjlwSSxFQUFFK3BJLFFBQVEsQ0FBQ0Msb0JBQW9CO1FBQ3JEaHFJLEVBQUV5cEksU0FBUyxDQUFDUSxRQUFRLEdBQUdockg7UUFDdkJqZixFQUFFeXBJLFNBQVMsQ0FBQ1MsU0FBUyxHQUFHUDtRQUN4QixJQUFJUSxZQUFZLFNBQVNBLFVBQVVwMUgsSUFBSTtZQUNyQyxPQUFPO2dCQUNMd2dFLGVBQWVwMUU7Z0JBQ2Y0VSxNQUFNQTtnQkFDTmtQLFVBQVU7b0JBQ1J6UCxHQUFHeUssR0FBRyxDQUFDLEVBQUU7b0JBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7Z0JBQ1g7WUFDRjtRQUNGO1FBQ0EsSUFBSW1ySCxrQkFBa0IsU0FBU0E7WUFDN0JwcUksRUFBRXlwSSxTQUFTLENBQUNZLGdCQUFnQixHQUFHO1lBQy9CNXVILGFBQWF6YixFQUFFeXBJLFNBQVMsQ0FBQ2EsY0FBYztZQUN2Q3RxSSxFQUFFeXBJLFNBQVMsQ0FBQ2EsY0FBYyxHQUFHdHZILFdBQVc7Z0JBQ3RDLElBQUloYixFQUFFeXBJLFNBQVMsQ0FBQ1ksZ0JBQWdCLEVBQUU7b0JBQ2hDO2dCQUNGLE9BQU87b0JBQ0wsSUFBSTdvSCxNQUFNeGhCLEVBQUV5cEksU0FBUyxDQUFDbEQsSUFBSTtvQkFDMUIsSUFBSS9rSCxLQUFLO3dCQUNQQSxJQUFJNjBDLElBQUksQ0FBQzh6RSxVQUFVO29CQUNyQixPQUFPO3dCQUNMMW1ILEdBQUc0eUMsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ3BCO2dCQUNGO1lBQ0YsR0FBR25xSSxFQUFFdXFJLGVBQWU7UUFDdEI7UUFFQSxxQkFBcUI7UUFDckIsSUFBSXBxSSxFQUFFdXBJLEtBQUssSUFBSSxHQUFHO1lBQ2hCMXBJLEVBQUV5cEksU0FBUyxDQUFDZSxVQUFVLEdBQUc7WUFDekIsSUFBSUMsU0FBUztnQkFDWGwxRCxlQUFlcDFFO2dCQUNmNFUsTUFBTTtnQkFDTmtQLFVBQVU7b0JBQ1J6UCxHQUFHeUssR0FBRyxDQUFDLEVBQUU7b0JBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7Z0JBQ1g7WUFDRjtZQUNBLElBQUl3bEcsTUFBTTtnQkFDUkEsS0FBS2ltQixRQUFRO2dCQUNiam1CLEtBQUtwdUQsSUFBSSxDQUFDbzBFO2dCQUNWenFJLEVBQUV5cEksU0FBUyxDQUFDbEQsSUFBSSxHQUFHOWhCO1lBQ3JCLE9BQU87Z0JBQ0xoaEcsR0FBRzR5QyxJQUFJLENBQUNvMEU7WUFDVjtZQUNBenFJLEVBQUV5cEksU0FBUyxDQUFDa0IsUUFBUSxHQUFHLElBQUk3MEgsT0FBTzgwSCxPQUFPO1lBQ3pDNXFJLEVBQUV5cEksU0FBUyxDQUFDb0IsVUFBVSxHQUFHO1FBRXpCLGlCQUFpQjtRQUNuQixPQUFPLElBQUkxcUksRUFBRXVwSSxLQUFLLElBQUksR0FBRztZQUN2QixJQUFJamxCLE1BQU07Z0JBQ1JBLEtBQUtpbUIsUUFBUTtZQUNmO1lBRUEsbUJBQW1CO1lBQ25CO2dCQUNFLDJFQUEyRTtnQkFDM0UsSUFBSWptQixRQUFRLE1BQU07b0JBQ2hCLElBQUl6a0gsRUFBRXlsSSxlQUFlLENBQUNoaEIsT0FBTzt3QkFDM0IsSUFBSXFtQixjQUFjLFNBQVNBLFlBQVl0cEgsR0FBRzs0QkFDeENBLElBQUk2MEMsSUFBSSxDQUFDOHpFLFVBQVU7d0JBQ3JCO3dCQUNBckQsY0FBY3JpQjt3QkFDZCxJQUFJLENBQUNBLEtBQUs3L0YsUUFBUSxJQUFJOzRCQUNwQmtsSCxrQkFBa0I5cEksRUFBRStwSSxRQUFRLENBQUNDLG9CQUFvQixHQUFHdm1ILEdBQUdyZSxVQUFVOzRCQUNqRXFpSSxjQUFjaGpCLE1BQU07Z0NBQ2xCMGlCLFdBQVcyQzs0QkFDYjs0QkFDQXJsQixLQUFLcHVELElBQUksQ0FBQzh6RSxVQUFVLFdBQVc5ekUsSUFBSSxDQUFDOHpFLFVBQVU7d0JBQ2hELE9BQU87NEJBQ0xMLGtCQUFrQjlwSSxFQUFFK3BJLFFBQVEsQ0FBQ0Msb0JBQW9CLEdBQUd2bUgsR0FBR3JlLFVBQVU7NEJBQ2pFLElBQUkybEksZ0JBQWdCdG5ILEdBQUdpUSxDQUFDLENBQUMsU0FBVWxTLEdBQUc7Z0NBQ3BDLE9BQU9BLElBQUlvRSxNQUFNLE1BQU1wRSxJQUFJb0QsUUFBUSxNQUFNNWtCLEVBQUV5bEksZUFBZSxDQUFDamtIOzRCQUM3RDs0QkFDQStsSCxlQUFld0QsZUFBZTtnQ0FDNUI1RCxXQUFXMkM7NEJBQ2I7NEJBQ0FybEIsS0FBS3B1RCxJQUFJLENBQUM4ekUsVUFBVTs0QkFDcEJZLGNBQWMzbkgsT0FBTyxDQUFDMG5IO3dCQUN4Qjt3QkFDQTlxSSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO3dCQUNyQmhySSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO29CQUN2QjtnQkFDRjtnQkFDQWhySSxFQUFFeXBJLFNBQVMsQ0FBQ2xELElBQUksR0FBRzloQjtnQkFDbkJ6a0gsRUFBRXlwSSxTQUFTLENBQUNqRCxLQUFLLEdBQUdxRDtnQkFDcEI3cEksRUFBRXlwSSxTQUFTLENBQUNrQixRQUFRLEdBQUcsSUFBSTcwSCxPQUFPODBILE9BQU87WUFDM0M7WUFDQTNFLGNBQWN4aEIsTUFBTTtnQkFBQztnQkFBYTtnQkFBWTthQUFhLEVBQUV0a0gsR0FBRztnQkFDOURxVSxHQUFHeUssR0FBRyxDQUFDLEVBQUU7Z0JBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7WUFDWDtZQUNBLElBQUl3bEcsUUFBUSxNQUFNO2dCQUNoQm1sQixNQUFNLENBQUMsRUFBRSxHQUFHO2dCQUNaNXBJLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixHQUFHO29CQUN6QnoySCxHQUFHeUssR0FBRyxDQUFDLEVBQUU7b0JBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7Z0JBQ1g7Z0JBQ0FqZixFQUFFZ3JJLFVBQVUsQ0FBQyxVQUFVO2dCQUN2QmhySSxFQUFFa3JJLE1BQU07WUFDVixPQUFPLElBQUl6bUIsS0FBS3gvRixRQUFRLElBQUk7Z0JBQzFCMmtILE1BQU0sQ0FBQyxFQUFFLEdBQUcsR0FBRyxpQkFBaUI7WUFDbEM7WUFDQVE7UUFDRjtRQUVBLHVDQUF1QztRQUN2Q1IsTUFBTSxDQUFDLEVBQUUsR0FBR0EsTUFBTSxDQUFDLEVBQUUsR0FBRzNxSCxHQUFHLENBQUMsRUFBRTtRQUM5QjJxSCxNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxHQUFHM3FILEdBQUcsQ0FBQyxFQUFFO0lBQ2hDLEdBQUc7SUFDSCxJQUFJa3NILGFBQWF2RixjQUFjNWxJLEVBQUVpMUYsU0FBUztJQUMxQ2oxRixFQUFFK2tJLGVBQWUsQ0FBQztRQUFDcmtDO1FBQWlCeXFDO0tBQVcsRUFBRSxhQUFhLFNBQVNDLGlCQUFpQmpySSxDQUFDO1FBQ3ZGLCtCQUErQjtRQUMvQixJQUFJa2xJLFVBQVVybEksRUFBRXlwSSxTQUFTLENBQUNwRSxPQUFPO1FBQ2pDLElBQUksQ0FBQ0EsV0FBVyxDQUFDNkQsaUJBQWlCL29JLElBQUk7WUFDcEM7UUFDRjtRQUNBLElBQUlrMUUsaUJBQWlCO1FBQ3JCLElBQUk1eEQsS0FBS3pqQixFQUFFeWpCLEVBQUU7UUFDYixJQUFJaUQsT0FBT2pELEdBQUdpRCxJQUFJO1FBQ2xCLElBQUlpakgsT0FBTztZQUFDeHBJLEVBQUVpakgsT0FBTztZQUFFampILEVBQUVrakgsT0FBTztTQUFDO1FBQ2pDLElBQUlwa0csTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUN3bUIsSUFBSSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEVBQUU7UUFDaEQsSUFBSU0sV0FBV2pxSSxFQUFFeXBJLFNBQVMsQ0FBQ1EsUUFBUTtRQUNuQyxJQUFJQyxZQUFZbHFJLEVBQUV5cEksU0FBUyxDQUFDUyxTQUFTO1FBQ3JDLElBQUlOLFNBQVM1cEksRUFBRWlwSSxTQUFTO1FBQ3hCLElBQUl4a0IsT0FBTztRQUNYLElBQUksQ0FBQ3prSCxFQUFFeXBJLFNBQVMsQ0FBQzRCLFlBQVksSUFBSSxDQUFDcnJJLEVBQUV5cEksU0FBUyxDQUFDNkIsUUFBUSxJQUFJLENBQUN0ckksRUFBRXlwSSxTQUFTLENBQUM4QixTQUFTLEVBQUU7WUFDaEY5bUIsT0FBT3prSCxFQUFFb2tILGtCQUFrQixDQUFDbmxHLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTTtRQUNwRDtRQUNBLElBQUlrOUQsT0FBT244RSxFQUFFeXBJLFNBQVMsQ0FBQ3R0RCxJQUFJO1FBQzNCLElBQUlvcUQsT0FBT3ZtSSxFQUFFeXBJLFNBQVMsQ0FBQ2xELElBQUk7UUFDM0IsSUFBSTMrRixPQUFPO1lBQUMzb0IsR0FBRyxDQUFDLEVBQUUsR0FBRzJxSCxNQUFNLENBQUMsRUFBRTtZQUFFM3FILEdBQUcsQ0FBQyxFQUFFLEdBQUcycUgsTUFBTSxDQUFDLEVBQUU7U0FBQztRQUNuRCxJQUFJRSxrQkFBa0I5cEksRUFBRStwSSxRQUFRLENBQUNDLG9CQUFvQjtRQUNyRCxJQUFJd0I7UUFDSixJQUFJdEIsV0FBVztZQUNiLElBQUlwd0csS0FBSzZ2RyxJQUFJLENBQUMsRUFBRSxHQUFHTyxTQUFTLENBQUMsRUFBRTtZQUMvQixJQUFJdUIsTUFBTTN4RyxLQUFLQTtZQUNmLElBQUlDLEtBQUs0dkcsSUFBSSxDQUFDLEVBQUUsR0FBR08sU0FBUyxDQUFDLEVBQUU7WUFDL0IsSUFBSXdCLE1BQU0zeEcsS0FBS0E7WUFDZixJQUFJNHhHLFFBQVFGLE1BQU1DO1lBQ2xCMXJJLEVBQUV5cEksU0FBUyxDQUFDK0IsbUJBQW1CLEdBQUdBLHNCQUFzQkcsU0FBUzNySSxFQUFFNHJJLG9CQUFvQjtRQUN6RjtRQUNBLElBQUlDLGlCQUFpQjNGLGlCQUFpQi9sSTtRQUN0QyxJQUFJcXJJLHFCQUFxQjtZQUN2QnhySSxFQUFFeXBJLFNBQVMsQ0FBQ1ksZ0JBQWdCLEdBQUc7UUFDakM7UUFDQSxJQUFJeUIsa0JBQWtCLFNBQVNBO1lBQzdCLElBQUlDLFlBQVkvckksRUFBRXlwSSxTQUFTLENBQUNzQyxTQUFTLEdBQUcvckksRUFBRXlwSSxTQUFTLENBQUNzQyxTQUFTLElBQUksRUFBRTtZQUNuRSxJQUFJQSxVQUFVN3JJLE1BQU0sS0FBSyxHQUFHO2dCQUMxQjZySSxVQUFVcnBJLElBQUksQ0FBQ2tsQyxJQUFJLENBQUMsRUFBRTtnQkFDdEJta0csVUFBVXJwSSxJQUFJLENBQUNrbEMsSUFBSSxDQUFDLEVBQUU7WUFDeEIsT0FBTztnQkFDTG1rRyxTQUFTLENBQUMsRUFBRSxJQUFJbmtHLElBQUksQ0FBQyxFQUFFO2dCQUN2Qm1rRyxTQUFTLENBQUMsRUFBRSxJQUFJbmtHLElBQUksQ0FBQyxFQUFFO1lBQ3pCO1FBQ0Y7UUFDQXl0QyxpQkFBaUI7UUFDakI0d0QsY0FBY3hoQixNQUFNO1lBQUM7WUFBYTtZQUFjO1NBQVUsRUFBRXRrSCxHQUFHO1lBQzdEcVUsR0FBR3lLLEdBQUcsQ0FBQyxFQUFFO1lBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7UUFDWDtRQUNBLElBQUlrckgsWUFBWSxTQUFTQSxVQUFVcDFILElBQUk7WUFDckMsT0FBTztnQkFDTHdnRSxlQUFlcDFFO2dCQUNmNFUsTUFBTUE7Z0JBQ05rUCxVQUFVO29CQUNSelAsR0FBR3lLLEdBQUcsQ0FBQyxFQUFFO29CQUNUaEIsR0FBR2dCLEdBQUcsQ0FBQyxFQUFFO2dCQUNYO1lBQ0Y7UUFDRjtRQUNBLElBQUkrc0gsZ0JBQWdCLFNBQVNBO1lBQzNCaHNJLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixHQUFHaG9JO1lBQzNCLElBQUksQ0FBQ2pELEVBQUV5cEksU0FBUyxDQUFDOEIsU0FBUyxFQUFFO2dCQUMxQjluSCxHQUFHNHlDLElBQUksQ0FBQzh6RSxVQUFVO1lBQ3BCO1lBQ0FQLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDWjVwSSxFQUFFeXBJLFNBQVMsQ0FBQzhCLFNBQVMsR0FBRztZQUN4QnZySSxFQUFFZ3JJLFVBQVUsQ0FBQyxVQUFVO1lBQ3ZCaHJJLEVBQUVrckksTUFBTTtRQUNWO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUlsckksRUFBRXlwSSxTQUFTLENBQUNDLEtBQUssS0FBSyxHQUFHO1lBQzNCLDZCQUE2QjtZQUM3QixJQUFJOEIscUJBQXFCO2dCQUN2QixJQUFJZixTQUFTTixVQUFVO2dCQUN2QixJQUFJNUQsTUFBTTtvQkFDUkEsS0FBS2x3RSxJQUFJLENBQUNvMEU7Z0JBQ1osT0FBTztvQkFDTGhuSCxHQUFHNHlDLElBQUksQ0FBQ28wRTtnQkFDVjtnQkFDQXpxSSxFQUFFeXBJLFNBQVMsQ0FBQ29CLFVBQVUsR0FBRztnQkFDekIsSUFBSSxDQUFDN3FJLEVBQUV5cEksU0FBUyxDQUFDd0MsT0FBTyxJQUFJeG5CLFNBQVN6a0gsRUFBRXlwSSxTQUFTLENBQUN3QyxPQUFPLEVBQUU7b0JBQ3hELElBQUlqc0ksRUFBRXlwSSxTQUFTLENBQUN3QyxPQUFPLEVBQUU7d0JBQ3ZCanNJLEVBQUV5cEksU0FBUyxDQUFDd0MsT0FBTyxDQUFDNTFFLElBQUksQ0FBQzh6RSxVQUFVO29CQUNyQztvQkFDQW5xSSxFQUFFeXBJLFNBQVMsQ0FBQ3dDLE9BQU8sR0FBR3huQjtvQkFDdEIsSUFBSUEsTUFBTTt3QkFDUkEsS0FBS3B1RCxJQUFJLENBQUM4ekUsVUFBVTtvQkFDdEI7Z0JBQ0Y7WUFDRjtRQUVBLGdEQUFnRDtRQUNsRCxPQUFPLElBQUlucUksRUFBRXlwSSxTQUFTLENBQUM2QixRQUFRLEVBQUU7WUFDL0JqMkQsaUJBQWlCO1lBQ2pCLElBQUk1eEQsR0FBR21wRixjQUFjLE1BQU1ucEYsR0FBR29wRixrQkFBa0IsSUFBSTtnQkFDbEQsSUFBSXEvQjtnQkFDSixJQUFJbHNJLEVBQUV5cEksU0FBUyxDQUFDMEMsY0FBYyxFQUFFO29CQUM5QixJQUFJQyxRQUFRcHNJLEVBQUV5cEksU0FBUyxDQUFDUSxRQUFRO29CQUNoQ2lDLFNBQVM7d0JBQ1AxM0gsR0FBRyxDQUFDeUssR0FBRyxDQUFDLEVBQUUsR0FBR210SCxLQUFLLENBQUMsRUFBRSxJQUFJMWxIO3dCQUN6QnpJLEdBQUcsQ0FBQ2dCLEdBQUcsQ0FBQyxFQUFFLEdBQUdtdEgsS0FBSyxDQUFDLEVBQUUsSUFBSTFsSDtvQkFDM0I7b0JBQ0ExbUIsRUFBRXlwSSxTQUFTLENBQUMwQyxjQUFjLEdBQUc7Z0JBQy9CLE9BQU87b0JBQ0xELFNBQVM7d0JBQ1AxM0gsR0FBR296QixJQUFJLENBQUMsRUFBRSxHQUFHbGhCO3dCQUNiekksR0FBRzJwQixJQUFJLENBQUMsRUFBRSxHQUFHbGhCO29CQUNmO2dCQUNGO2dCQUNBakQsR0FBR21nQyxLQUFLLENBQUNzb0Y7Z0JBQ1R6b0gsR0FBRzR5QyxJQUFJLENBQUM4ekUsVUFBVTtnQkFDbEJucUksRUFBRXlwSSxTQUFTLENBQUM0QyxPQUFPLEdBQUc7WUFDeEI7WUFFQSwrQ0FBK0M7WUFDL0NwdEgsTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUNoakgsRUFBRWlqSCxPQUFPLEVBQUVqakgsRUFBRWtqSCxPQUFPO1FBRWhELGtFQUFrRTtRQUNwRSxPQUFPLElBQUl1bUIsTUFBTSxDQUFDLEVBQUUsSUFBSSxLQUFNckQsQ0FBQUEsUUFBUSxRQUFRQSxLQUFLdGhILFFBQVEsRUFBQyxHQUFJO1lBQzlELElBQUl1bUgscUJBQXFCO2dCQUN2QixJQUFJLENBQUN4ckksRUFBRXlwSSxTQUFTLENBQUM2QixRQUFRLElBQUk3bkgsR0FBR3VwRixtQkFBbUIsTUFBTzYrQixDQUFBQSxrQkFBa0IsQ0FBQ3BvSCxHQUFHbXBGLGNBQWMsTUFBTSxDQUFDbnBGLEdBQUdvcEYsa0JBQWtCLEVBQUMsR0FBSTtvQkFDN0htL0I7Z0JBQ0YsT0FBTyxJQUFJLENBQUNoc0ksRUFBRXlwSSxTQUFTLENBQUM4QixTQUFTLElBQUk5bkgsR0FBR21wRixjQUFjLE1BQU1ucEYsR0FBR29wRixrQkFBa0IsSUFBSTtvQkFDbkYsSUFBSTQ1QixtQkFBbUJILHdCQUF3QkMsTUFBTXZtSSxFQUFFeXBJLFNBQVMsQ0FBQ2pELEtBQUs7b0JBQ3RFLElBQUlDLGtCQUFrQjt3QkFDcEJ6bUksRUFBRXlwSSxTQUFTLENBQUM2QixRQUFRLEdBQUc7d0JBQ3ZCdHJJLEVBQUV5cEksU0FBUyxDQUFDMEMsY0FBYyxHQUFHO3dCQUM3QnZDLE1BQU0sQ0FBQyxFQUFFLEdBQUc7d0JBQ1o1cEksRUFBRTZqQixJQUFJLENBQUNvbkgsaUJBQWlCLEdBQUd2eUcsWUFBWXV4Rzt3QkFDdkNqcUksRUFBRWdySSxVQUFVLENBQUMsVUFBVTt3QkFDdkJockksRUFBRWtySSxNQUFNO29CQUNWO2dCQUNGO2dCQUNBLElBQUkzRSxRQUFRQSxLQUFLdGhILFFBQVEsTUFBTXNoSCxLQUFLcmhILE1BQU0sSUFBSTtvQkFDNUNxaEgsS0FBSytGLFVBQVU7Z0JBQ2pCO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSS9GLFFBQVFBLEtBQUt0aEgsUUFBUSxNQUFNc2hILEtBQUtyaEgsTUFBTSxJQUFJO2dCQUM1Q3FoSCxLQUFLK0YsVUFBVTtZQUNqQjtZQUNBLElBQUksQ0FBQyxDQUFDL0YsUUFBUSxDQUFDQSxLQUFLeGhILE9BQU8sRUFBQyxLQUFNMC9GLFFBQVF0b0MsTUFBTTtnQkFDOUMsSUFBSUEsTUFBTTtvQkFDUjhwRCxjQUFjOXBELE1BQU07d0JBQUM7d0JBQVk7cUJBQWEsRUFBRWg4RSxHQUFHO3dCQUNqRHFVLEdBQUd5SyxHQUFHLENBQUMsRUFBRTt3QkFDVGhCLEdBQUdnQixHQUFHLENBQUMsRUFBRTtvQkFDWDtnQkFDRjtnQkFDQSxJQUFJd2xHLE1BQU07b0JBQ1J3aEIsY0FBY3hoQixNQUFNO3dCQUFDO3dCQUFhO3FCQUFjLEVBQUV0a0gsR0FBRzt3QkFDbkRxVSxHQUFHeUssR0FBRyxDQUFDLEVBQUU7d0JBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7b0JBQ1g7Z0JBQ0Y7Z0JBQ0FqZixFQUFFeXBJLFNBQVMsQ0FBQ3R0RCxJQUFJLEdBQUdzb0M7WUFDckI7WUFDQSxJQUFJOGhCLE1BQU07Z0JBQ1IsSUFBSWlGLHFCQUFxQjtvQkFDdkIsMEJBQTBCO29CQUUxQixJQUFJL25ILEdBQUd1cEYsbUJBQW1CLE1BQU02K0IsZ0JBQWdCO3dCQUM5QywyQkFBMkI7d0JBQzNCLElBQUl0RixRQUFRQSxLQUFLeGhILE9BQU8sSUFBSTs0QkFDMUIyaUgsb0JBQW9Cb0M7NEJBQ3BCdkQsS0FBS2x3RSxJQUFJLENBQUM4ekUsVUFBVTs0QkFDcEJMLGdCQUFnQnp6RSxJQUFJLENBQUM4ekUsVUFBVTs0QkFDL0IsSUFBSW5xSSxFQUFFK3BJLFFBQVEsQ0FBQ3dDLE9BQU8sRUFBRTtnQ0FDdEJoRyxLQUFLbHdFLElBQUksQ0FBQzh6RSxVQUFVO2dDQUNwQkwsZ0JBQWdCenpFLElBQUksQ0FBQzh6RSxVQUFVOzRCQUNqQzt3QkFDRjt3QkFDQTZCO29CQUNGLE9BQU8sSUFBSXpGLFFBQVFBLEtBQUt4aEgsT0FBTyxNQUFNL2tCLEVBQUV3bEksZUFBZSxDQUFDZSxPQUFPO3dCQUM1RCxZQUFZO3dCQUNaLElBQUlpRyxrQkFBa0IsQ0FBQ3hzSSxFQUFFK3BJLFFBQVEsQ0FBQ3dDLE9BQU87d0JBQ3pDLElBQUlDLGlCQUFpQjs0QkFDbkJ4c0ksRUFBRWdySSxVQUFVLENBQUMsUUFBUTt3QkFDdkI7d0JBQ0FockksRUFBRStwSSxRQUFRLENBQUN3QyxPQUFPLEdBQUcsTUFBTSw4Q0FBOEM7d0JBRXpFLDhEQUE4RDt3QkFDOUQsSUFBSSxDQUFDdnNJLEVBQUV5cEksU0FBUyxDQUFDNEIsWUFBWSxFQUFFOzRCQUM3QjlELGVBQWV1QyxpQkFBaUI7Z0NBQzlCOUYsYUFBYTs0QkFDZjt3QkFDRjt3QkFDQSxJQUFJeUksYUFBYTs0QkFDZmo0SCxHQUFHOzRCQUNIeUosR0FBRzt3QkFDTDt3QkFDQSxJQUFJclosU0FBU2dqQyxJQUFJLENBQUMsRUFBRSxLQUFLaGpDLFNBQVNnakMsSUFBSSxDQUFDLEVBQUUsR0FBRzs0QkFDMUM2a0csV0FBV2o0SCxDQUFDLElBQUlvekIsSUFBSSxDQUFDLEVBQUU7NEJBQ3ZCNmtHLFdBQVd4dUgsQ0FBQyxJQUFJMnBCLElBQUksQ0FBQyxFQUFFOzRCQUN2QixJQUFJNGtHLGlCQUFpQjtnQ0FDbkIsSUFBSVQsWUFBWS9ySSxFQUFFeXBJLFNBQVMsQ0FBQ3NDLFNBQVM7Z0NBQ3JDLElBQUlBLGFBQWFubkksU0FBU21uSSxTQUFTLENBQUMsRUFBRSxLQUFLbm5JLFNBQVNtbkksU0FBUyxDQUFDLEVBQUUsR0FBRztvQ0FDakVVLFdBQVdqNEgsQ0FBQyxJQUFJdTNILFNBQVMsQ0FBQyxFQUFFO29DQUM1QlUsV0FBV3h1SCxDQUFDLElBQUk4dEgsU0FBUyxDQUFDLEVBQUU7Z0NBQzlCOzRCQUNGO3dCQUNGO3dCQUNBL3JJLEVBQUV5cEksU0FBUyxDQUFDNEIsWUFBWSxHQUFHO3dCQUMzQnZCLGdCQUFnQmpqRSxXQUFXLENBQUM0bEUsWUFBWXAyRSxJQUFJLENBQUM4ekUsVUFBVSxhQUFhOXpFLElBQUksQ0FBQzh6RSxVQUFVO3dCQUNuRm5xSSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO3dCQUNyQmhySSxFQUFFa3JJLE1BQU07b0JBQ1Y7Z0JBQ0YsT0FBTztvQkFDTCxxR0FBcUc7b0JBQ3JHWTtnQkFDRjtZQUNGO1lBRUEsa0VBQWtFO1lBQ2xFejJELGlCQUFpQjtRQUNuQjtRQUNBdTBELE1BQU0sQ0FBQyxFQUFFLEdBQUczcUgsR0FBRyxDQUFDLEVBQUU7UUFDbEIycUgsTUFBTSxDQUFDLEVBQUUsR0FBRzNxSCxHQUFHLENBQUMsRUFBRTtRQUNsQixJQUFJbzJELGdCQUFnQjtZQUNsQixJQUFJbDFFLEVBQUV3MUUsZUFBZSxFQUFFeDFFLEVBQUV3MUUsZUFBZTtZQUN4QyxJQUFJeDFFLEVBQUVrMUUsY0FBYyxFQUFFbDFFLEVBQUVrMUUsY0FBYztZQUN0QyxPQUFPO1FBQ1Q7SUFDRixHQUFHO0lBQ0gsSUFBSXEzRCxjQUFjQyxnQkFBZ0JDO0lBQ2xDNXNJLEVBQUUra0ksZUFBZSxDQUFDcmtDLGlCQUFpQixXQUFXLFNBQVNtc0MsZUFBZTFzSSxDQUFDO1FBQ3JFLCtCQUErQjtRQUMvQiwwREFBMEQ7UUFDMUQsSUFBSUgsRUFBRXlwSSxTQUFTLENBQUNDLEtBQUssS0FBSyxLQUFLdnBJLEVBQUV1cEksS0FBSyxLQUFLLEtBQUsxcEksRUFBRXlwSSxTQUFTLENBQUNwRSxPQUFPLEVBQUU7WUFDbkU7UUFDRjtRQUNBLElBQUlBLFVBQVVybEksRUFBRXlwSSxTQUFTLENBQUNwRSxPQUFPO1FBQ2pDLElBQUksQ0FBQ0EsU0FBUztZQUNaO1FBQ0Y7UUFDQXJsSSxFQUFFeXBJLFNBQVMsQ0FBQ3BFLE9BQU8sR0FBRztRQUN0QixJQUFJNWhILEtBQUt6akIsRUFBRXlqQixFQUFFO1FBQ2IsSUFBSXhFLE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpakgsT0FBTyxFQUFFampILEVBQUVrakgsT0FBTztRQUNwRCxJQUFJdW1CLFNBQVM1cEksRUFBRWlwSSxTQUFTO1FBQ3hCLElBQUl4a0IsT0FBT3prSCxFQUFFb2tILGtCQUFrQixDQUFDbmxHLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTTtRQUN0RCxJQUFJNnFILGtCQUFrQjlwSSxFQUFFK3BJLFFBQVEsQ0FBQ0Msb0JBQW9CO1FBQ3JELElBQUl6RCxPQUFPdm1JLEVBQUV5cEksU0FBUyxDQUFDbEQsSUFBSTtRQUMzQixJQUFJc0YsaUJBQWlCM0YsaUJBQWlCL2xJO1FBQ3RDLElBQUlILEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixFQUFFO1lBQzVCanJJLEVBQUVnckksVUFBVSxDQUFDLFVBQVU7WUFDdkJockksRUFBRWtySSxNQUFNO1FBQ1Y7UUFDQWxySSxFQUFFeXBJLFNBQVMsQ0FBQ1ksZ0JBQWdCLEdBQUc7UUFDL0JycUksRUFBRTZqQixJQUFJLENBQUNvbkgsaUJBQWlCLEdBQUdob0ksV0FBVyxvQkFBb0I7UUFFMUQsSUFBSXNqSSxNQUFNO1lBQ1JBLEtBQUsrRixVQUFVO1FBQ2pCO1FBQ0EsSUFBSW5DLFlBQVksU0FBU0EsVUFBVXAxSCxJQUFJO1lBQ3JDLE9BQU87Z0JBQ0x3Z0UsZUFBZXAxRTtnQkFDZjRVLE1BQU1BO2dCQUNOa1AsVUFBVTtvQkFDUnpQLEdBQUd5SyxHQUFHLENBQUMsRUFBRTtvQkFDVGhCLEdBQUdnQixHQUFHLENBQUMsRUFBRTtnQkFDWDtZQUNGO1FBQ0Y7UUFDQSxJQUFJamYsRUFBRXlwSSxTQUFTLENBQUNDLEtBQUssS0FBSyxHQUFHO1lBQzNCLElBQUllLFNBQVNOLFVBQVU7WUFDdkIsSUFBSTVELE1BQU07Z0JBQ1JBLEtBQUtsd0UsSUFBSSxDQUFDbzBFO1lBQ1osT0FBTztnQkFDTGhuSCxHQUFHNHlDLElBQUksQ0FBQ28wRTtZQUNWO1lBQ0EsSUFBSSxDQUFDenFJLEVBQUV5cEksU0FBUyxDQUFDb0IsVUFBVSxFQUFFO2dCQUMzQixJQUFJaUMsU0FBUzNDLFVBQVU7Z0JBQ3ZCLElBQUk1RCxNQUFNO29CQUNSQSxLQUFLbHdFLElBQUksQ0FBQ3kyRTtnQkFDWixPQUFPO29CQUNMcnBILEdBQUc0eUMsSUFBSSxDQUFDeTJFO2dCQUNWO1lBQ0Y7WUFDQTlzSSxFQUFFeXBJLFNBQVMsQ0FBQ29CLFVBQVUsR0FBRztZQUN6QjdxSSxFQUFFeXBJLFNBQVMsQ0FBQ0MsS0FBSyxHQUFHO1FBQ3RCLE9BQU8sSUFBSTFwSSxFQUFFeXBJLFNBQVMsQ0FBQ0MsS0FBSyxLQUFLLEdBQUc7WUFDbEN6RCxjQUFjeGhCLE1BQU07Z0JBQUM7Z0JBQVc7Z0JBQVU7YUFBVyxFQUFFdGtILEdBQUc7Z0JBQ3hEcVUsR0FBR3lLLEdBQUcsQ0FBQyxFQUFFO2dCQUNUaEIsR0FBR2dCLEdBQUcsQ0FBQyxFQUFFO1lBQ1g7WUFDQSxJQUFJLENBQUNqZixFQUFFK3BJLFFBQVEsQ0FBQ3dDLE9BQU8sSUFDdkIsNEJBQTRCO1lBQzVCLENBQUN2c0ksRUFBRXlwSSxTQUFTLENBQUM0QyxPQUFPLElBQ3BCLGFBQWE7WUFDYixDQUFDcnNJLEVBQUV5cEksU0FBUyxDQUFDOEIsU0FBUyxJQUN0QixvQkFBb0I7WUFDcEIsQ0FBQ3ZySSxFQUFFeXBJLFNBQVMsQ0FBQytCLG1CQUFtQixDQUFDLHVCQUF1QjtjQUN0RDtnQkFDQXZGLGNBQWNNLE1BQU07b0JBQUM7b0JBQVM7b0JBQU87aUJBQVMsRUFBRXBtSSxHQUFHO29CQUNqRHFVLEdBQUd5SyxHQUFHLENBQUMsRUFBRTtvQkFDVGhCLEdBQUdnQixHQUFHLENBQUMsRUFBRTtnQkFDWDtnQkFDQTB0SCxpQkFBaUI7Z0JBQ2pCLElBQUl4c0ksRUFBRXUxRSxTQUFTLEdBQUdrM0Qsc0JBQXNCbnBILEdBQUdtckYsc0JBQXNCLElBQUk7b0JBQ25FODlCLGdCQUFnQmp4SCxhQUFhaXhIO29CQUM3QkMsaUJBQWlCO29CQUNqQkMscUJBQXFCO29CQUNyQjNHLGNBQWNNLE1BQU07d0JBQUM7d0JBQVk7d0JBQVU7cUJBQVksRUFBRXBtSSxHQUFHO3dCQUMxRHFVLEdBQUd5SyxHQUFHLENBQUMsRUFBRTt3QkFDVGhCLEdBQUdnQixHQUFHLENBQUMsRUFBRTtvQkFDWDtnQkFDRixPQUFPO29CQUNMeXRILGVBQWUxeEgsV0FBVzt3QkFDeEIsSUFBSTJ4SCxnQkFBZ0I7d0JBQ3BCMUcsY0FBY00sTUFBTTs0QkFBQzs0QkFBWTs0QkFBVTt5QkFBWSxFQUFFcG1JLEdBQUc7NEJBQzFEcVUsR0FBR3lLLEdBQUcsQ0FBQyxFQUFFOzRCQUNUaEIsR0FBR2dCLEdBQUcsQ0FBQyxFQUFFO3dCQUNYO29CQUNGLEdBQUd3RSxHQUFHbXJGLHNCQUFzQjtvQkFDNUJnK0IscUJBQXFCenNJLEVBQUV1MUUsU0FBUztnQkFDbEM7WUFDRjtZQUVBLHdHQUF3RztZQUN4RyxJQUFJNndELFFBQVEsS0FBSyx3QkFBd0I7Z0JBQ3RDLENBQUN2bUksRUFBRStwSSxRQUFRLENBQUN3QyxPQUFPLENBQUMsOEJBQThCO2dCQUNsRCxDQUFDdnNJLEVBQUV5cEksU0FBUyxDQUFDOEIsU0FBUyxDQUFDLG9CQUFvQjtnQkFDM0MsQ0FBQ3ZySSxFQUFFeXBJLFNBQVMsQ0FBQzRDLE9BQU8sQ0FBQyxhQUFhO2dCQUNsQyxDQUFDbkcsaUJBQWlCL2xJLElBQUk7Z0JBQ3ZCc2pCLEdBQUdpUSxDQUFDLENBQUNpeUcsWUFBWTdpRCxRQUFRLENBQUM7b0JBQUM7aUJBQWM7Z0JBQ3pDLElBQUlnbkQsZ0JBQWdCNXBJLE1BQU0sR0FBRyxHQUFHO29CQUM5QkYsRUFBRWdySSxVQUFVLENBQUMsUUFBUTtnQkFDdkI7Z0JBQ0FockksRUFBRStwSSxRQUFRLENBQUNDLG9CQUFvQixHQUFHRixrQkFBa0JybUgsR0FBR3JlLFVBQVU7WUFDbkU7WUFFQSxtQkFBbUI7WUFDbkIsSUFBSXEvRyxRQUFROGhCLFFBQVEsQ0FBQ3ZtSSxFQUFFK3BJLFFBQVEsQ0FBQ3dDLE9BQU8sSUFBSSxDQUFDdnNJLEVBQUV5cEksU0FBUyxDQUFDOEIsU0FBUyxFQUFFO2dCQUNqRSxJQUFJOW1CLFFBQVEsUUFBUUEsS0FBS3AvRyxRQUFRLENBQUN3ZixVQUFVLEVBQUU7b0JBQzVDLElBQUk3a0IsRUFBRXlwSSxTQUFTLENBQUM2QixRQUFRO3lCQUFTLElBQUk3bkgsR0FBR2lwRixhQUFhLE9BQU8sY0FBY20vQixnQkFBZ0I7d0JBQ3hGLElBQUlwbkIsS0FBSzcvRixRQUFRLElBQUk7NEJBQ25CNi9GLEtBQUszaEMsUUFBUSxDQUFDO2dDQUFDOzZCQUFjO3dCQUMvQixPQUFPOzRCQUNMMmhDLEtBQUttbEIsTUFBTSxDQUFDO2dDQUFDOzZCQUFZO3dCQUMzQjtvQkFDRixPQUFPO3dCQUNMLElBQUksQ0FBQ2lDLGdCQUFnQjs0QkFDbkJwb0gsR0FBR2lRLENBQUMsQ0FBQ2l5RyxZQUFZdnJELE9BQU8sQ0FBQ3FxQyxNQUFNM2hDLFFBQVEsQ0FBQztnQ0FBQzs2QkFBYzs0QkFDdkQyaEMsS0FBS21sQixNQUFNLENBQUM7Z0NBQUM7NkJBQVk7d0JBQzNCO29CQUNGO29CQUNBNXBJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7Z0JBQ3ZCO1lBQ0Y7WUFDQSxJQUFJaHJJLEVBQUV5cEksU0FBUyxDQUFDOEIsU0FBUyxFQUFFO2dCQUN6QixJQUFJcnNILE1BQU11RSxHQUFHcmUsVUFBVSxDQUFDcEYsRUFBRWduSCxXQUFXLENBQUM0aUIsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7Z0JBQ2hGNXBJLEVBQUVnckksVUFBVSxDQUFDLFVBQVU7Z0JBQ3ZCLElBQUk5ckgsSUFBSWhmLE1BQU0sR0FBRyxHQUFHO29CQUNsQkYsRUFBRWdySSxVQUFVLENBQUMsUUFBUTtnQkFDdkI7Z0JBQ0F2bkgsR0FBRzR5QyxJQUFJLENBQUM4ekUsVUFBVTtnQkFDbEIsSUFBSTRDLHFCQUFxQixTQUFTQSxtQkFBbUJ2ckgsR0FBRztvQkFDdEQsT0FBT0EsSUFBSXFELFVBQVUsTUFBTSxDQUFDckQsSUFBSW9ELFFBQVE7Z0JBQzFDO2dCQUNBLElBQUluQixHQUFHaXBGLGFBQWEsT0FBTyxZQUFZO29CQUNyQ3h0RixJQUFJbTNDLElBQUksQ0FBQzh6RSxVQUFVLFFBQVF4bUUsU0FBUyxDQUFDb3BFLG9CQUFvQm5ELE1BQU0sR0FBR3Z6RSxJQUFJLENBQUM4ekUsVUFBVTtnQkFDbkYsT0FBTztvQkFDTCxJQUFJLENBQUMwQixnQkFBZ0I7d0JBQ25CcG9ILEdBQUdpUSxDQUFDLENBQUNpeUcsWUFBWXZyRCxPQUFPLENBQUNsN0QsS0FBSzRqRSxRQUFRO29CQUN4QztvQkFDQTVqRSxJQUFJbTNDLElBQUksQ0FBQzh6RSxVQUFVLFFBQVF4bUUsU0FBUyxDQUFDb3BFLG9CQUFvQm5ELE1BQU0sR0FBR3Z6RSxJQUFJLENBQUM4ekUsVUFBVTtnQkFDbkY7Z0JBRUEsK0NBQStDO2dCQUMvQ25xSSxFQUFFa3JJLE1BQU07WUFDVjtZQUVBLGtCQUFrQjtZQUNsQixJQUFJbHJJLEVBQUV5cEksU0FBUyxDQUFDNkIsUUFBUSxFQUFFO2dCQUN4QnRySSxFQUFFeXBJLFNBQVMsQ0FBQzZCLFFBQVEsR0FBRztnQkFDdkJ0ckksRUFBRWdySSxVQUFVLENBQUMsVUFBVTtnQkFDdkJockksRUFBRWdySSxVQUFVLENBQUMsUUFBUTtnQkFDckJockksRUFBRWtySSxNQUFNO1lBQ1Y7WUFDQSxJQUFJLENBQUN0QixNQUFNLENBQUMsRUFBRSxFQUFFO2dCQUNkNXBJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7Z0JBQ3JCaHJJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7Z0JBQ3JCLElBQUlnQyxpQkFBaUJ6RyxRQUFRQSxLQUFLeGhILE9BQU87Z0JBQ3pDMmlILG9CQUFvQm9DO2dCQUNwQixJQUFJa0QsZ0JBQWdCO29CQUNsQnpHLEtBQUtsd0UsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ3BCTCxnQkFBZ0J6ekUsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQy9CLElBQUlucUksRUFBRStwSSxRQUFRLENBQUN3QyxPQUFPLEVBQUU7d0JBQ3RCaEcsS0FBS2x3RSxJQUFJLENBQUM4ekUsVUFBVTt3QkFDcEJMLGdCQUFnQnp6RSxJQUFJLENBQUM4ekUsVUFBVTtvQkFDakM7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsdUJBQXVCO1FBRXpCUCxNQUFNLENBQUMsRUFBRSxHQUFHO1FBQ1o1cEksRUFBRXlwSSxTQUFTLENBQUNsRCxJQUFJLEdBQUc7UUFDbkJ2bUksRUFBRXlwSSxTQUFTLENBQUNlLFVBQVUsR0FBRztRQUN6QnhxSSxFQUFFeXBJLFNBQVMsQ0FBQzRCLFlBQVksR0FBRztRQUMzQnJySSxFQUFFeXBJLFNBQVMsQ0FBQzhCLFNBQVMsR0FBRztRQUN4QnZySSxFQUFFeXBJLFNBQVMsQ0FBQytCLG1CQUFtQixHQUFHO1FBQ2xDeHJJLEVBQUUrcEksUUFBUSxDQUFDd0MsT0FBTyxHQUFHO1FBQ3JCdnNJLEVBQUV5cEksU0FBUyxDQUFDNEMsT0FBTyxHQUFHO1FBQ3RCcnNJLEVBQUV5cEksU0FBUyxDQUFDc0MsU0FBUyxHQUFHLEVBQUU7UUFDMUIvckksRUFBRXlwSSxTQUFTLENBQUNRLFFBQVEsR0FBRztRQUN2QmpxSSxFQUFFeXBJLFNBQVMsQ0FBQ1MsU0FBUyxHQUFHO1FBQ3hCbHFJLEVBQUV5cEksU0FBUyxDQUFDQyxLQUFLLEdBQUc7SUFDdEIsR0FBRztJQUNILElBQUl1RCxjQUFjLEVBQUUsRUFBRSw4QkFBOEI7SUFDcEQsSUFBSUMsY0FBYyxHQUFHLHlCQUF5QjtJQUM5QyxJQUFJQztJQUNKLElBQUlDLHlCQUF5QixRQUFRLHVGQUF1RjtJQUU1SCxJQUFJQyxvQkFBb0IsU0FBU0Esa0JBQWtCbkcsSUFBSSxFQUFFM1EsTUFBTTtRQUM3RCxJQUFLLElBQUk5ekgsSUFBSSxHQUFHQSxJQUFJeWtJLEtBQUtobkksTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJeWtJLElBQUksQ0FBQ3prSSxFQUFFLEdBQUc4ekgsV0FBVyxHQUFHO2dCQUMxQixPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBLElBQUkrVyxzQkFBc0IsU0FBU0Esb0JBQW9CcEcsSUFBSTtRQUN6RCxJQUFJcUcsV0FBV3ZvSSxLQUFLMjNCLEdBQUcsQ0FBQ3VxRyxJQUFJLENBQUMsRUFBRTtRQUMvQixJQUFLLElBQUl6a0ksSUFBSSxHQUFHQSxJQUFJeWtJLEtBQUtobkksTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJdUMsS0FBSzIzQixHQUFHLENBQUN1cUcsSUFBSSxDQUFDemtJLEVBQUUsTUFBTThxSSxVQUFVO2dCQUNsQyxPQUFPO1lBQ1Q7UUFDRjtRQUNBLE9BQU87SUFDVDtJQUNBLElBQUlDLGVBQWUsU0FBU0EsYUFBYXJ0SSxDQUFDO1FBQ3hDLElBQUlzdEksUUFBUTtRQUNaLElBQUkzaEcsUUFBUTNyQyxFQUFFdXRJLE1BQU07UUFDcEIsSUFBSTVoRyxTQUFTLE1BQU07WUFDakIsa0NBQWtDO1lBQ2xDLElBQUkzckMsRUFBRXd0SSxXQUFXLElBQUksTUFBTTtnQkFDekI3aEcsUUFBUTNyQyxFQUFFd3RJLFdBQVcsR0FBRztZQUMxQixPQUFPLElBQUl4dEksRUFBRXl0SSxVQUFVLElBQUksTUFBTTtnQkFDL0I5aEcsUUFBUTNyQyxFQUFFeXRJLFVBQVUsR0FBRztZQUN6QjtRQUNGO1FBQ0EsSUFBSTloRyxVQUFVLEdBQUc7WUFDZixRQUFRLDZGQUE2RjtRQUN2RztRQUNBLElBQUlxaEcsMEJBQTBCLE1BQU07WUFDbEMsSUFBSUYsWUFBWS9zSSxNQUFNLElBQUlndEksYUFBYTtnQkFDckMscUNBQXFDO2dCQUNyQyxJQUFJVyxNQUFNWjtnQkFDVkUseUJBQXlCRSxrQkFBa0JRLEtBQUs7Z0JBQ2hELElBQUksQ0FBQ1Ysd0JBQXdCO29CQUMzQixxREFBcUQ7b0JBQ3JELElBQUlJLFdBQVd2b0ksS0FBSzIzQixHQUFHLENBQUNreEcsR0FBRyxDQUFDLEVBQUU7b0JBQzlCVix5QkFBeUJHLG9CQUFvQk8sUUFBUU4sV0FBVztnQkFDbEU7Z0JBQ0EsSUFBSUosd0JBQXdCO29CQUMxQixJQUFLLElBQUkxcUksSUFBSSxHQUFHQSxJQUFJb3JJLElBQUkzdEksTUFBTSxFQUFFdUMsSUFBSzt3QkFDbkMycUkseUJBQXlCcG9JLEtBQUsrVSxHQUFHLENBQUMvVSxLQUFLMjNCLEdBQUcsQ0FBQ2t4RyxHQUFHLENBQUNwckksRUFBRSxHQUFHMnFJO29CQUN0RDtnQkFDRjtZQUVBLDZDQUE2QztZQUM3QyxrRUFBa0U7WUFDbEUsa0VBQWtFO1lBQ3BFLE9BQU87Z0JBQ0wsaUNBQWlDO2dCQUNqQ0gsWUFBWXZxSSxJQUFJLENBQUNvcEM7Z0JBQ2pCMmhHLFFBQVE7WUFDUiwyRUFBMkU7WUFDN0U7UUFDRixPQUFPLElBQUlOLHdCQUF3QjtZQUNqQyxnQkFBZ0I7WUFDaEJDLHlCQUF5QnBvSSxLQUFLK1UsR0FBRyxDQUFDL1UsS0FBSzIzQixHQUFHLENBQUNtUCxRQUFRc2hHO1FBQ25ELCtJQUErSTtRQUNqSjtRQUNBLElBQUlwdEksRUFBRTh0SSxhQUFhLEVBQUU7WUFDbkI7UUFDRixFQUFFLHdDQUF3QztRQUUxQyxJQUFJcnFILEtBQUt6akIsRUFBRXlqQixFQUFFO1FBQ2IsSUFBSWlELE9BQU9qRCxHQUFHaUQsSUFBSTtRQUNsQixJQUFJRCxNQUFNaEQsR0FBR2dELEdBQUc7UUFDaEIsSUFBSXhILE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpakgsT0FBTyxFQUFFampILEVBQUVrakgsT0FBTztRQUNwRCxJQUFJNzhGLE9BQU87WUFBQ3ZILEdBQUcsQ0FBQyxFQUFFLEdBQUd5SCxPQUFPRCxJQUFJalMsQ0FBQztZQUFFeUssR0FBRyxDQUFDLEVBQUUsR0FBR3lILE9BQU9ELElBQUl4SSxDQUFDO1NBQUM7UUFDekQsSUFBSWplLEVBQUV5cEksU0FBUyxDQUFDNEIsWUFBWSxJQUFJcnJJLEVBQUV5cEksU0FBUyxDQUFDNkIsUUFBUSxJQUFJdHJJLEVBQUV5cEksU0FBUyxDQUFDZSxVQUFVLElBQUl4QixrQkFBa0I7WUFDbEcsZ0VBQWdFO1lBQ2hFN29JLEVBQUVrMUUsY0FBYztZQUNoQjtRQUNGO1FBQ0EsSUFBSTV4RCxHQUFHbXBGLGNBQWMsTUFBTW5wRixHQUFHb3BGLGtCQUFrQixNQUFNcHBGLEdBQUdxcEYsY0FBYyxNQUFNcnBGLEdBQUdzcEYsa0JBQWtCLElBQUk7WUFDcEc1c0csRUFBRWsxRSxjQUFjO1lBQ2hCcjFFLEVBQUU2akIsSUFBSSxDQUFDa3FILFlBQVksR0FBRztZQUN0QnR5SCxhQUFhemIsRUFBRTZqQixJQUFJLENBQUNtcUgsWUFBWTtZQUNoQ2h1SSxFQUFFNmpCLElBQUksQ0FBQ21xSCxZQUFZLEdBQUdoekgsV0FBVztnQkFDL0JoYixFQUFFNmpCLElBQUksQ0FBQ2txSCxZQUFZLEdBQUc7Z0JBQ3RCL3RJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7Z0JBQ3JCaHJJLEVBQUVrckksTUFBTTtZQUNWLEdBQUc7WUFDSCxJQUFJdC9GO1lBQ0osSUFBSTZoRyxTQUFTem9JLEtBQUsyM0IsR0FBRyxDQUFDbVAsU0FBUyxHQUFHO2dCQUNoQ0EsUUFBUXBTLE9BQU9vUyxTQUFTO1lBQzFCO1lBQ0FGLE9BQU9FLFFBQVEsQ0FBQztZQUNoQixJQUFJcWhHLHdCQUF3QjtnQkFDMUJ2aEcsUUFBUXdoRztnQkFDUnhoRyxRQUFRO1lBQ1Y7WUFDQUEsT0FBT0EsT0FBTzVyQyxFQUFFMHpGLGdCQUFnQjtZQUVoQyx5RUFBeUU7WUFFekUsSUFBSXU2QyxnQkFBZ0I5dEksRUFBRSt0SSxTQUFTLEtBQUs7WUFDcEMsSUFBSUQsZUFBZTtnQkFDakIscURBQXFEO2dCQUNyRHJpRyxRQUFRO1lBQ1Y7WUFDQSxJQUFJdWlHLFVBQVUxcUgsR0FBR2lELElBQUksS0FBSzFoQixLQUFLNnhCLEdBQUcsQ0FBQyxJQUFJK1U7WUFDdkMsSUFBSXpyQyxFQUFFNFUsSUFBSSxLQUFLLGlCQUFpQjtnQkFDOUJvNUgsVUFBVW51SSxFQUFFb3VJLGdCQUFnQixHQUFHanVJLEVBQUUrN0IsS0FBSztZQUN4QztZQUNBelksR0FBR2lELElBQUksQ0FBQztnQkFDTittRixPQUFPMGdDO2dCQUNQNW5ILGtCQUFrQjtvQkFDaEIvUixHQUFHZ1MsSUFBSSxDQUFDLEVBQUU7b0JBQ1Z2SSxHQUFHdUksSUFBSSxDQUFDLEVBQUU7Z0JBQ1o7WUFDRjtZQUNBL0MsR0FBRzR5QyxJQUFJLENBQUM7Z0JBQ050aEQsTUFBTTVVLEVBQUU0VSxJQUFJLEtBQUssa0JBQWtCLGNBQWM7Z0JBQ2pEd2dFLGVBQWVwMUU7Z0JBQ2Y4akIsVUFBVTtvQkFDUnpQLEdBQUd5SyxHQUFHLENBQUMsRUFBRTtvQkFDVGhCLEdBQUdnQixHQUFHLENBQUMsRUFBRTtnQkFDWDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLG9FQUFvRTtJQUNwRSxLQUFLO0lBQ0xqZixFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxTQUFTdTRDLGNBQWM7SUFFdEQsbUNBQW1DO0lBQ25DLG9FQUFvRTtJQUNwRSx3RUFBd0U7SUFDeEUsOEZBQThGO0lBRTlGeHRJLEVBQUUra0ksZUFBZSxDQUFDcmtDLGlCQUFpQixVQUFVLFNBQVMydEMsY0FBY2x1SSxDQUFDO1FBQ25FLHFDQUFxQztRQUNyQ0gsRUFBRTh0SSxhQUFhLEdBQUc7UUFDbEJyeUgsYUFBYXpiLEVBQUVzdUksb0JBQW9CO1FBQ25DdHVJLEVBQUVzdUksb0JBQW9CLEdBQUd0ekgsV0FBVztZQUNsQ2hiLEVBQUU4dEksYUFBYSxHQUFHO1FBQ3BCLEdBQUc7SUFDTCxHQUFHO0lBRUgscUNBQXFDO0lBQ3JDOXRJLEVBQUUra0ksZUFBZSxDQUFDL2tJLEVBQUVpMUYsU0FBUyxFQUFFLGdCQUFnQixTQUFTczVDLG9CQUFvQnB1SSxDQUFDO1FBQzNFSCxFQUFFb3VJLGdCQUFnQixHQUFHcHVJLEVBQUV5akIsRUFBRSxDQUFDaUQsSUFBSTtRQUM5QixJQUFJLENBQUMxbUIsRUFBRXd1SSxlQUFlLEVBQUU7WUFDdEIseUNBQXlDO1lBQ3pDcnVJLEVBQUVrMUUsY0FBYztRQUNsQjtJQUNGLEdBQUc7SUFDSHIxRSxFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxpQkFBaUIsU0FBVTkwRixDQUFDO1FBQ3pELElBQUksQ0FBQ0gsRUFBRXd1SSxlQUFlLEVBQUU7WUFDdEIseUNBQXlDO1lBQ3pDaEIsYUFBYXJ0STtRQUNmO0lBQ0YsR0FBRztJQUVILGdGQUFnRjtJQUNoRix5Q0FBeUM7SUFDekNILEVBQUUra0ksZUFBZSxDQUFDL2tJLEVBQUVpMUYsU0FBUyxFQUFFLFlBQVksU0FBU3c1QyxnQkFBZ0J0dUksQ0FBQztRQUNuRSxJQUFJOGUsTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUNoakgsRUFBRWlqSCxPQUFPLEVBQUVqakgsRUFBRWtqSCxPQUFPO1FBQ3BEcmpILEVBQUV5akIsRUFBRSxDQUFDNHlDLElBQUksQ0FBQztZQUNSa2YsZUFBZXAxRTtZQUNmNFUsTUFBTTtZQUNOa1AsVUFBVTtnQkFDUnpQLEdBQUd5SyxHQUFHLENBQUMsRUFBRTtnQkFDVGhCLEdBQUdnQixHQUFHLENBQUMsRUFBRTtZQUNYO1FBQ0Y7SUFDRixHQUFHO0lBQ0hqZixFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxhQUFhLFNBQVN5NUMsaUJBQWlCdnVJLENBQUM7UUFDckUsSUFBSThlLE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpakgsT0FBTyxFQUFFampILEVBQUVrakgsT0FBTztRQUNwRHJqSCxFQUFFeWpCLEVBQUUsQ0FBQzR5QyxJQUFJLENBQUM7WUFDUmtmLGVBQWVwMUU7WUFDZjRVLE1BQU07WUFDTmtQLFVBQVU7Z0JBQ1J6UCxHQUFHeUssR0FBRyxDQUFDLEVBQUU7Z0JBQ1RoQixHQUFHZ0IsR0FBRyxDQUFDLEVBQUU7WUFDWDtRQUNGO0lBQ0YsR0FBRztJQUNILElBQUkwdkgsTUFBTUMsTUFBTUMsTUFBTUMsTUFBTSxvQ0FBb0M7SUFDaEUsSUFBSUMsV0FBV0MsYUFBYSxtRUFBbUU7SUFDL0YsSUFBSUMsU0FBU0MsY0FBYyxzQ0FBc0M7SUFDakUsSUFBSTFyQixZQUFZQztJQUNoQixJQUFJMHJCLGdCQUFnQkM7SUFDcEIsSUFBSUM7SUFDSixJQUFJNzlHLFdBQVcsU0FBU0EsU0FBUzFyQixFQUFFLEVBQUVFLEVBQUUsRUFBRUQsRUFBRSxFQUFFRSxFQUFFO1FBQzdDLE9BQU9qQixLQUFLMndCLElBQUksQ0FBQyxDQUFDNXZCLEtBQUtELEVBQUMsSUFBTUMsQ0FBQUEsS0FBS0QsRUFBQyxJQUFLLENBQUNHLEtBQUtELEVBQUMsSUFBTUMsQ0FBQUEsS0FBS0QsRUFBQztJQUM5RDtJQUNBLElBQUlzcEksYUFBYSxTQUFTQSxXQUFXeHBJLEVBQUUsRUFBRUUsRUFBRSxFQUFFRCxFQUFFLEVBQUVFLEVBQUU7UUFDakQsT0FBTyxDQUFDRixLQUFLRCxFQUFDLElBQU1DLENBQUFBLEtBQUtELEVBQUMsSUFBSyxDQUFDRyxLQUFLRCxFQUFDLElBQU1DLENBQUFBLEtBQUtELEVBQUM7SUFDcEQ7SUFDQSxJQUFJdXBJO0lBQ0p2dkksRUFBRStrSSxlQUFlLENBQUMva0ksRUFBRWkxRixTQUFTLEVBQUUsY0FBY3M2QyxvQkFBb0IsU0FBU0Esa0JBQWtCcHZJLENBQUM7UUFDM0ZILEVBQUV3dUksZUFBZSxHQUFHO1FBQ3BCLElBQUksQ0FBQ3RGLGlCQUFpQi9vSSxJQUFJO1lBQ3hCO1FBQ0Y7UUFDQXluSTtRQUNBNW5JLEVBQUV3dkksU0FBUyxDQUFDbkssT0FBTyxHQUFHO1FBQ3RCcmxJLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixHQUFHaG9JO1FBQzNCLElBQUl3Z0IsS0FBS3pqQixFQUFFeWpCLEVBQUU7UUFDYixJQUFJNU4sTUFBTTdWLEVBQUV3dkksU0FBUyxDQUFDMzVILEdBQUc7UUFDekIsSUFBSTQ1SCxVQUFVenZJLEVBQUV3dkksU0FBUyxDQUFDQyxPQUFPO1FBQ2pDLElBQUl0dkksRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxFQUFFO1lBQ2hCLElBQUlucUgsTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUNoakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU8sRUFBRWpqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUMvbEIsT0FBTztZQUMxRXh0RyxHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7WUFDZnBKLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtRQUNqQjtRQUNBLElBQUk5ZSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDaEIsSUFBSW5xSCxNQUFNamYsRUFBRW1qSCxtQkFBbUIsQ0FBQ2hqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxFQUFFampILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPO1lBQzFFeHRHLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtZQUNmcEosR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1FBQ2pCO1FBQ0EsSUFBSTllLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUNoQixJQUFJbnFILE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQ2htQixPQUFPLEVBQUVqakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU87WUFDMUV4dEcsR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1lBQ2ZwSixHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7UUFDakI7UUFDQSxJQUFJa3JILFlBQVksU0FBU0EsVUFBVXAxSCxJQUFJO1lBQ3JDLE9BQU87Z0JBQ0x3Z0UsZUFBZXAxRTtnQkFDZjRVLE1BQU1BO2dCQUNOa1AsVUFBVTtvQkFDUnpQLEdBQUdxQixHQUFHLENBQUMsRUFBRTtvQkFDVG9JLEdBQUdwSSxHQUFHLENBQUMsRUFBRTtnQkFDWDtZQUNGO1FBQ0Y7UUFFQSwyQ0FBMkM7UUFDM0MsSUFBSTFWLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUNoQnBwSSxFQUFFd3ZJLFNBQVMsQ0FBQ0UsZ0JBQWdCLEdBQUc7WUFDL0JoSSxvQkFBb0IxbkksRUFBRStwSSxRQUFRLENBQUM0RixhQUFhO1lBQzVDLElBQUlyc0IsVUFBVXRqSCxFQUFFdWpILHlCQUF5QjtZQUN6Q0MsYUFBYUYsT0FBTyxDQUFDLEVBQUU7WUFDdkJHLFlBQVlILE9BQU8sQ0FBQyxFQUFFO1lBQ3RCNnJCLGlCQUFpQjdyQixPQUFPLENBQUMsRUFBRTtZQUMzQjhyQixrQkFBa0I5ckIsT0FBTyxDQUFDLEVBQUU7WUFDNUJxckIsT0FBT3h1SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxHQUFHSTtZQUM5Qm9yQixPQUFPenVJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPLEdBQUdJO1lBQzlCb3JCLE9BQU8xdUksRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU8sR0FBR0k7WUFDOUJzckIsT0FBTzN1SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUMvbEIsT0FBTyxHQUFHSTtZQUM5QjRyQix3QkFBd0IsS0FBS1YsUUFBUUEsUUFBUVEsa0JBQWtCLEtBQUtOLFFBQVFBLFFBQVFNLGtCQUFrQixLQUFLUCxRQUFRQSxRQUFRUSxtQkFBbUIsS0FBS04sUUFBUUEsUUFBUU07WUFDbkssSUFBSTNvSCxNQUFNaEQsR0FBR2dELEdBQUc7WUFDaEIsSUFBSUMsT0FBT2pELEdBQUdpRCxJQUFJO1lBQ2xCcW9ILFlBQVl2OUcsU0FBU205RyxNQUFNQyxNQUFNQyxNQUFNQztZQUN2Q0UsY0FBY00sV0FBV1gsTUFBTUMsTUFBTUMsTUFBTUM7WUFDM0NHLFVBQVU7Z0JBQUVOLENBQUFBLE9BQU9FLElBQUcsSUFBSztnQkFBSUQsQ0FBQUEsT0FBT0UsSUFBRyxJQUFLO2FBQUU7WUFDaERJLGVBQWU7Z0JBQUVELENBQUFBLE9BQU8sQ0FBQyxFQUFFLEdBQUd4b0gsSUFBSWpTLENBQUMsSUFBSWtTO2dCQUFPdW9ILENBQUFBLE9BQU8sQ0FBQyxFQUFFLEdBQUd4b0gsSUFBSXhJLENBQUMsSUFBSXlJO2FBQUs7WUFFekUsdUJBQXVCO1lBQ3ZCLElBQUlrcEgsbUJBQW1CO1lBQ3ZCLElBQUlDLHFCQUFxQkQsbUJBQW1CQTtZQUM1QyxJQUFJWixjQUFjYSxzQkFBc0IsQ0FBQzF2SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JELElBQUkwRyxRQUFROXZJLEVBQUVva0gsa0JBQWtCLENBQUN2dUcsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRSxNQUFNO2dCQUN2RCxJQUFJazZILFFBQVEvdkksRUFBRW9rSCxrQkFBa0IsQ0FBQ3Z1RyxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFLE1BQU07Z0JBQ3ZELElBQUlpNkgsU0FBU0EsTUFBTWxxSCxNQUFNLElBQUk7b0JBQzNCa3FILE1BQU1wRixRQUFRLEdBQUdyMEUsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ2hDbnFJLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUssR0FBRzI2RztnQkFDdEIsT0FBTyxJQUFJQyxTQUFTQSxNQUFNbnFILE1BQU0sSUFBSTtvQkFDbENtcUgsTUFBTXJGLFFBQVEsR0FBR3IwRSxJQUFJLENBQUM4ekUsVUFBVTtvQkFDaENucUksRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxHQUFHNDZHO2dCQUN0QixPQUFPO29CQUNMdHNILEdBQUc0eUMsSUFBSSxDQUFDOHpFLFVBQVU7Z0JBQ3BCO2dCQUNBLElBQUlucUksRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxFQUFFO29CQUNyQm4xQixFQUFFd3ZJLFNBQVMsQ0FBQ3I2RyxLQUFLLENBQUM5dkIsUUFBUSxDQUFDMGYsT0FBTyxHQUFHO2dCQUN2QztnQkFDQS9rQixFQUFFd3ZJLFNBQVMsQ0FBQzM0QyxHQUFHLEdBQUc7Z0JBQ2xCNzJGLEVBQUV3dkksU0FBUyxDQUFDM0UsVUFBVSxHQUFHO2dCQUN6QjdxSSxFQUFFNmpCLElBQUksQ0FBQ29uSCxpQkFBaUIsR0FBR2hvSTtnQkFDM0JqRCxFQUFFa3JJLE1BQU07Z0JBQ1I7WUFDRjtRQUNGO1FBQ0EsSUFBSS9xSSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDaEIsU0FBUztZQUVULHdHQUF3RztZQUN4RyxJQUFJM2xILEdBQUd1cEYsbUJBQW1CLElBQUk7Z0JBQzVCN3NHLEVBQUVrMUUsY0FBYztZQUNsQjtRQUNGLE9BQU8sSUFBSWwxRSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFO2FBQVMsSUFBSWpwSSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDaEQsSUFBSVMsUUFBUTdwSSxFQUFFdWtILG1CQUFtQixDQUFDMXVHLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTTtZQUN4RCxJQUFJNHVHLE9BQU9vbEIsS0FBSyxDQUFDLEVBQUU7WUFDbkIsSUFBSXBsQixRQUFRLE1BQU07Z0JBQ2hCQSxLQUFLaW1CLFFBQVE7Z0JBQ2IxcUksRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxHQUFHc3ZGO2dCQUNwQnprSCxFQUFFd3ZJLFNBQVMsQ0FBQ1EsTUFBTSxHQUFHbkc7Z0JBQ3JCLElBQUk3cEksRUFBRXlsSSxlQUFlLENBQUNoaEIsT0FBTztvQkFDM0IsSUFBSXdyQixjQUFjandJLEVBQUUrcEksUUFBUSxDQUFDNEYsYUFBYSxHQUFHbHNILEdBQUdyZSxVQUFVO29CQUMxRCxJQUFJMmxJLGdCQUFnQjtvQkFDcEIvcUksRUFBRWdySSxVQUFVLENBQUMsUUFBUTtvQkFDckJockksRUFBRWdySSxVQUFVLENBQUMsUUFBUTtvQkFDckIsSUFBSXZtQixLQUFLNy9GLFFBQVEsSUFBSTt3QkFDbkIsc0RBQXNEO3dCQUV0RG1tSCxnQkFBZ0J0bkgsR0FBR2lRLENBQUMsQ0FBQyxTQUFVbFMsR0FBRzs0QkFDaEMsT0FBT0EsSUFBSW9ELFFBQVEsTUFBTTVrQixFQUFFeWxJLGVBQWUsQ0FBQ2prSDt3QkFDN0M7d0JBQ0ErbEgsZUFBZXdELGVBQWU7NEJBQzVCNUQsV0FBVzhJO3dCQUNiO29CQUNGLE9BQU87d0JBQ0x4SSxjQUFjaGpCLE1BQU07NEJBQ2xCMGlCLFdBQVc4STt3QkFDYjtvQkFDRjtvQkFDQW5KLGNBQWNyaUI7b0JBQ2RBLEtBQUtwdUQsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ3BCLElBQUlZLGVBQWU7d0JBQ2pCQSxjQUFjM25ILE9BQU8sQ0FBQyxTQUFVaGpCLENBQUM7NEJBQy9CQSxFQUFFaTJELElBQUksQ0FBQzh6RSxVQUFVO3dCQUNuQjtvQkFDRixPQUFPO3dCQUNMMWxCLEtBQUtwdUQsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ3RCO2dCQUNGO1lBQ0Y7WUFDQWxFLGNBQWN4aEIsTUFBTTtnQkFBQztnQkFBYztnQkFBWTthQUFhLEVBQUV0a0gsR0FBRztnQkFDL0RxVSxHQUFHcUIsR0FBRyxDQUFDLEVBQUU7Z0JBQ1RvSSxHQUFHcEksR0FBRyxDQUFDLEVBQUU7WUFDWDtZQUNBLElBQUk0dUcsUUFBUSxNQUFNO2dCQUNoQnprSCxFQUFFNmpCLElBQUksQ0FBQ29uSCxpQkFBaUIsR0FBRztvQkFDekJ6MkgsR0FBR3lLLEdBQUcsQ0FBQyxFQUFFO29CQUNUaEIsR0FBR2dCLEdBQUcsQ0FBQyxFQUFFO2dCQUNYO2dCQUNBamYsRUFBRWdySSxVQUFVLENBQUMsVUFBVTtnQkFDdkJockksRUFBRWtySSxNQUFNO1lBQ1Y7WUFFQSxlQUFlO1lBQ2YsUUFBUTtZQUVSbHJJLEVBQUV3dkksU0FBUyxDQUFDRSxnQkFBZ0IsR0FBRztZQUMvQjF2SSxFQUFFd3ZJLFNBQVMsQ0FBQ1Usb0JBQW9CLEdBQUcsQ0FBQyxJQUFJcDZIO1lBQ3hDMkYsYUFBYXpiLEVBQUV3dkksU0FBUyxDQUFDbEYsY0FBYztZQUN2Q3RxSSxFQUFFd3ZJLFNBQVMsQ0FBQ2xGLGNBQWMsR0FBR3R2SCxXQUFXO2dCQUN0QyxJQUFJaGIsRUFBRXd2SSxTQUFTLENBQUNFLGdCQUFnQixLQUFLLFNBQVMsQ0FBQzF2SSxFQUFFbXdJLFFBQVEsQ0FBQywyREFBMkQ7b0JBQ2xILENBQUNud0ksRUFBRXd2SSxTQUFTLENBQUNqRSxTQUFTLENBQUMsZ0RBQWdEO2tCQUN4RTtvQkFDQXRGLGNBQWNqbUksRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxFQUFFO3dCQUFDO3FCQUFVLEVBQUVoMUIsR0FBRzt3QkFDL0NxVSxHQUFHcUIsR0FBRyxDQUFDLEVBQUU7d0JBQ1RvSSxHQUFHcEksR0FBRyxDQUFDLEVBQUU7b0JBQ1g7Z0JBQ0Y7WUFDRixHQUFHN1YsRUFBRXVxSSxlQUFlO1FBQ3RCO1FBQ0EsSUFBSXBxSSxFQUFFaXBJLE9BQU8sQ0FBQ2xwSSxNQUFNLElBQUksR0FBRztZQUN6QixJQUFJa3dJLE9BQU9wd0ksRUFBRXd2SSxTQUFTLENBQUNwdUYsYUFBYSxHQUFHO2dCQUFDO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2FBQUs7WUFDM0UsSUFBSyxJQUFJMytDLElBQUksR0FBR0EsSUFBSW9ULElBQUkzVixNQUFNLEVBQUV1QyxJQUFLO2dCQUNuQzJ0SSxJQUFJLENBQUMzdEksRUFBRSxHQUFHZ3RJLE9BQU8sQ0FBQ2h0SSxFQUFFLEdBQUdvVCxHQUFHLENBQUNwVCxFQUFFO1lBQy9CO1lBQ0EsSUFBSTR0SSxTQUFTbHdJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUU7WUFDekJwcEksRUFBRXd2SSxTQUFTLENBQUNjLGNBQWMsR0FBRztnQkFBQ0QsT0FBT2p0QixPQUFPO2dCQUFFaXRCLE9BQU9odEIsT0FBTzthQUFDO1FBQy9EO0lBQ0YsR0FBRztJQUNILElBQUlrdEI7SUFDSnZ3SSxFQUFFK2tJLGVBQWUsQ0FBQ3JrQyxpQkFBaUIsYUFBYTZ2QyxtQkFBbUIsU0FBU0EsaUJBQWlCcHdJLENBQUM7UUFDNUYsK0JBQStCO1FBQy9CLElBQUlrbEksVUFBVXJsSSxFQUFFd3ZJLFNBQVMsQ0FBQ25LLE9BQU87UUFDakMsSUFBSSxDQUFDQSxXQUFXLENBQUM2RCxpQkFBaUIvb0ksSUFBSTtZQUNwQztRQUNGO1FBQ0EsSUFBSXlwSSxTQUFTNXBJLEVBQUVpcEksU0FBUztRQUN4QixJQUFJeGxILEtBQUt6akIsRUFBRXlqQixFQUFFO1FBQ2IsSUFBSTVOLE1BQU03VixFQUFFd3ZJLFNBQVMsQ0FBQzM1SCxHQUFHO1FBQ3pCLElBQUk0NUgsVUFBVXp2SSxFQUFFd3ZJLFNBQVMsQ0FBQ0MsT0FBTztRQUNqQyxJQUFJL29ILE9BQU9qRCxHQUFHaUQsSUFBSTtRQUNsQixJQUFJdm1CLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUNoQixJQUFJbnFILE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQ2htQixPQUFPLEVBQUVqakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU87WUFDMUV4dEcsR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1lBQ2ZwSixHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7UUFDakI7UUFDQSxJQUFJOWUsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxFQUFFO1lBQ2hCLElBQUlucUgsTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUNoakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU8sRUFBRWpqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUMvbEIsT0FBTztZQUMxRXh0RyxHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7WUFDZnBKLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtRQUNqQjtRQUNBLElBQUk5ZSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDaEIsSUFBSW5xSCxNQUFNamYsRUFBRW1qSCxtQkFBbUIsQ0FBQ2hqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxFQUFFampILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPO1lBQzFFeHRHLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtZQUNmcEosR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1FBQ2pCO1FBQ0EsSUFBSWtySCxZQUFZLFNBQVNBLFVBQVVwMUgsSUFBSTtZQUNyQyxPQUFPO2dCQUNMd2dFLGVBQWVwMUU7Z0JBQ2Y0VSxNQUFNQTtnQkFDTmtQLFVBQVU7b0JBQ1J6UCxHQUFHcUIsR0FBRyxDQUFDLEVBQUU7b0JBQ1RvSSxHQUFHcEksR0FBRyxDQUFDLEVBQUU7Z0JBQ1g7WUFDRjtRQUNGO1FBQ0EsSUFBSTI2SCxZQUFZeHdJLEVBQUV3dkksU0FBUyxDQUFDYyxjQUFjO1FBQzFDLElBQUk5RTtRQUNKLElBQUluRyxXQUFXbGxJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsSUFBSW9ILFdBQVc7WUFDeEMsSUFBSTVvRyxPQUFPLEVBQUU7WUFDYixJQUFLLElBQUk5K0IsSUFBSSxHQUFHQSxJQUFJK00sSUFBSTNWLE1BQU0sRUFBRTRJLElBQUs7Z0JBQ25DOCtCLElBQUksQ0FBQzkrQixFQUFFLEdBQUcrTSxHQUFHLENBQUMvTSxFQUFFLEdBQUcybUksT0FBTyxDQUFDM21JLEVBQUU7WUFDL0I7WUFDQSxJQUFJZ3hCLEtBQUszNUIsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU8sR0FBR290QixTQUFTLENBQUMsRUFBRTtZQUM1QyxJQUFJL0UsTUFBTTN4RyxLQUFLQTtZQUNmLElBQUlDLEtBQUs1NUIsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU8sR0FBR210QixTQUFTLENBQUMsRUFBRTtZQUM1QyxJQUFJOUUsTUFBTTN4RyxLQUFLQTtZQUNmLElBQUk0eEcsUUFBUUYsTUFBTUM7WUFDbEJGLHNCQUFzQkcsU0FBUzNySSxFQUFFeXdJLGtCQUFrQjtRQUNyRDtRQUVBLDJCQUEyQjtRQUMzQixJQUFJcEwsV0FBV3JsSSxFQUFFd3ZJLFNBQVMsQ0FBQzM0QyxHQUFHLEVBQUU7WUFDOUIxMkYsRUFBRWsxRSxjQUFjO1lBQ2hCLElBQUlxN0QsT0FBT3Z3SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxHQUFHSSxZQUNoQ210QixPQUFPeHdJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPLEdBQUdJO1lBQ2hDLElBQUltdEIsT0FBT3p3SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxHQUFHSSxZQUNoQ3F0QixPQUFPMXdJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPLEdBQUdJO1lBQ2hDLHNEQUFzRDtZQUN0RCxJQUFJcXRCLGNBQWN4QixXQUFXb0IsTUFBTUMsTUFBTUMsTUFBTUM7WUFDL0MsSUFBSUUsV0FBV0QsY0FBYzlCO1lBQzdCLElBQUlyeEIsZ0JBQWdCO1lBQ3BCLElBQUlxekIsa0JBQWtCcnpCLGdCQUFnQkE7WUFDdEMsSUFBSXN6QixrQkFBa0I7WUFDdEIsSUFBSUMsb0JBQW9CRCxrQkFBa0JBO1lBRTFDLGdFQUFnRTtZQUNoRSxJQUFJRixZQUFZRyxxQkFBcUJKLGVBQWVFLGlCQUFpQjtnQkFDbkVoeEksRUFBRXd2SSxTQUFTLENBQUMzNEMsR0FBRyxHQUFHO2dCQUNsQjcyRixFQUFFNmpCLElBQUksQ0FBQ29uSCxpQkFBaUIsR0FBR2hvSTtnQkFDM0JqRCxFQUFFZ3JJLFVBQVUsQ0FBQyxVQUFVO2dCQUN2QixJQUFJUCxTQUFTTixVQUFVO2dCQUN2QixJQUFJbnFJLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUssRUFBRTtvQkFDckJuMUIsRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxDQUFDbTNHLFVBQVUsR0FBR2oyRSxJQUFJLENBQUNvMEU7b0JBQ3BDenFJLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUssR0FBRztnQkFDdEIsT0FBTztvQkFDTDFSLEdBQUc0eUMsSUFBSSxDQUFDbzBFO2dCQUNWO1lBQ0Y7UUFDRjtRQUVBLGdCQUFnQjtRQUNoQixJQUFJcEYsV0FBV3JsSSxFQUFFd3ZJLFNBQVMsQ0FBQzM0QyxHQUFHLEVBQUU7WUFDOUIsSUFBSTR6QyxTQUFTTixVQUFVO1lBQ3ZCbnFJLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixHQUFHaG9JO1lBQzNCakQsRUFBRWdySSxVQUFVLENBQUMsVUFBVTtZQUN2QixJQUFJaHJJLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUssRUFBRTtnQkFDckJuMUIsRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxDQUFDa2hDLElBQUksQ0FBQ28wRTtZQUN6QixPQUFPO2dCQUNMaG5ILEdBQUc0eUMsSUFBSSxDQUFDbzBFO1lBQ1Y7WUFDQSxJQUFJenFJLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUssRUFBRTtnQkFDckJuMUIsRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxDQUFDOXZCLFFBQVEsQ0FBQzBmLE9BQU8sR0FBRztZQUN2QztZQUNBL2tCLEVBQUV3dkksU0FBUyxDQUFDM0UsVUFBVSxHQUFHO1lBQ3pCLElBQUlwbUIsT0FBT3prSCxFQUFFb2tILGtCQUFrQixDQUFDdnVHLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTTtZQUN0RCxJQUFJLENBQUM3VixFQUFFd3ZJLFNBQVMsQ0FBQ3ZELE9BQU8sSUFBSXhuQixTQUFTemtILEVBQUV3dkksU0FBUyxDQUFDdkQsT0FBTyxFQUFFO2dCQUN4RCxJQUFJanNJLEVBQUV3dkksU0FBUyxDQUFDdkQsT0FBTyxFQUFFO29CQUN2QmpzSSxFQUFFd3ZJLFNBQVMsQ0FBQ3ZELE9BQU8sQ0FBQzUxRSxJQUFJLENBQUM4ekUsVUFBVTtnQkFDckM7Z0JBQ0FucUksRUFBRXd2SSxTQUFTLENBQUN2RCxPQUFPLEdBQUd4bkI7Z0JBQ3RCLElBQUlBLE1BQU07b0JBQ1JBLEtBQUtwdUQsSUFBSSxDQUFDOHpFLFVBQVU7Z0JBQ3RCO1lBQ0Y7UUFFQSxnQkFBZ0I7UUFDbEIsT0FBTyxJQUFJOUUsV0FBV2xsSSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLElBQUkzbEgsR0FBR3VwRixtQkFBbUIsSUFBSTtZQUM5RDdzRyxFQUFFazFFLGNBQWM7WUFDaEJyMUUsRUFBRTZqQixJQUFJLENBQUNvbkgsaUJBQWlCLEdBQUdob0k7WUFDM0IsSUFBSSxDQUFDa3VJLGNBQWMsR0FBRyxDQUFDLElBQUlyN0g7WUFDM0IsSUFBSSxDQUFDOVYsRUFBRXd2SSxTQUFTLENBQUNqRSxTQUFTLEVBQUU7Z0JBQzFCOW5ILEdBQUc0eUMsSUFBSSxDQUFDOHpFLFVBQVU7WUFDcEI7WUFDQW5xSSxFQUFFd3ZJLFNBQVMsQ0FBQ2pFLFNBQVMsR0FBRztZQUN4QnZySSxFQUFFd3ZJLFNBQVMsQ0FBQzRCLFNBQVMsR0FBRztZQUN4QnhILE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDWixJQUFJLENBQUNBLFVBQVVBLE9BQU8xcEksTUFBTSxLQUFLLEtBQUswcEksTUFBTSxDQUFDLEVBQUUsS0FBSzNtSSxXQUFXO2dCQUM3RDJtSSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMvekgsR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsSUFBSTtnQkFDekMrekgsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDL3pILEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLElBQUk7Z0JBQ3pDK3pILE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQy96SCxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxJQUFJLElBQUk7Z0JBQzdDK3pILE1BQU0sQ0FBQyxFQUFFLEdBQUcsQ0FBQy96SCxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxJQUFJLElBQUk7WUFDL0MsT0FBTztnQkFDTCt6SCxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMvekgsR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsR0FBR0EsR0FBRyxDQUFDLEVBQUUsSUFBSTtnQkFDekMrekgsTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDL3pILEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLElBQUk7WUFDM0M7WUFDQTdWLEVBQUVnckksVUFBVSxDQUFDLFVBQVU7WUFDdkJockksRUFBRWtySSxNQUFNO1FBRVIsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSTdGLFdBQVdsbEksRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNwcEksRUFBRXd2SSxTQUFTLENBQUM0QixTQUFTLENBQUMsd0RBQXdEO1lBQ2xIM3RILEdBQUdxcEYsY0FBYyxNQUFNcnBGLEdBQUdtcEYsY0FBYyxNQUFNbnBGLEdBQUdzcEYsa0JBQWtCLE1BQU10cEYsR0FBR29wRixrQkFBa0IsSUFBSTtZQUNuRywrQkFBK0I7WUFDL0Ixc0csRUFBRWsxRSxjQUFjO1lBQ2hCcjFFLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixHQUFHaG9JO1lBQzNCakQsRUFBRWdySSxVQUFVLENBQUMsVUFBVTtZQUN2QixJQUFJaUYsY0FBY2p3SSxFQUFFK3BJLFFBQVEsQ0FBQzRGLGFBQWE7WUFDMUMsSUFBSU0sYUFBYTtnQkFDZmp3SSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO2dCQUNyQixJQUFLLElBQUl2b0ksSUFBSSxHQUFHQSxJQUFJd3RJLFlBQVkvdkksTUFBTSxFQUFFdUMsSUFBSztvQkFDM0MsSUFBSTR1SSxPQUFPcEIsV0FBVyxDQUFDeHRJLEVBQUUsQ0FBQzRDLFFBQVE7b0JBQ2xDZ3NJLEtBQUt0c0gsT0FBTyxHQUFHO29CQUNmc3NILEtBQUs5ckgsUUFBUSxDQUFDeStHLFdBQVcsR0FBRztnQkFDOUI7WUFDRjtZQUNBLElBQUlzTixTQUFTdHhJLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUs7WUFFOUIsK0JBQStCO1lBQy9CLElBQUl1N0csT0FBT3Z3SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxHQUFHSSxZQUNoQ210QixPQUFPeHdJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPLEdBQUdJO1lBQ2hDLElBQUltdEIsT0FBT3p3SSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxHQUFHSSxZQUNoQ3F0QixPQUFPMXdJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPLEdBQUdJO1lBQ2hDLElBQUk4dEIsWUFBWS8vRyxTQUFTay9HLE1BQU1DLE1BQU1DLE1BQU1DO1lBQzNDLDBEQUEwRDtZQUMxRCxvRUFBb0U7WUFDcEUsSUFBSXRhLFNBQVNnYixZQUFZeEM7WUFDekIsSUFBSU0sdUJBQXVCO2dCQUN6QixnQkFBZ0I7Z0JBQ2hCLElBQUltQyxPQUFPZCxPQUFPL0I7Z0JBQ2xCLElBQUk4QyxPQUFPZCxPQUFPL0I7Z0JBRWxCLGlCQUFpQjtnQkFDakIsSUFBSThDLE9BQU9kLE9BQU8vQjtnQkFDbEIsSUFBSThDLE9BQU9kLE9BQU8vQjtnQkFFbEIsbUVBQW1FO2dCQUNuRSx3REFBd0Q7Z0JBQ3hELElBQUk4QyxLQUFLLENBQUNKLE9BQU9FLElBQUcsSUFBSztnQkFDekIsSUFBSUcsS0FBSyxDQUFDSixPQUFPRSxJQUFHLElBQUs7Z0JBRXpCLHlCQUF5QjtnQkFDekIsSUFBSWhrQyxRQUFRbHFGLEdBQUdpRCxJQUFJO2dCQUNuQixJQUFJa25GLFFBQVFELFFBQVE0b0I7Z0JBQ3BCLElBQUk3b0IsT0FBT2pxRixHQUFHZ0QsR0FBRztnQkFFakIsK0RBQStEO2dCQUMvRCxJQUFJcXJILE9BQU81QyxZQUFZLENBQUMsRUFBRSxHQUFHdmhDLFFBQVFELEtBQUtsNUYsQ0FBQztnQkFDM0MsSUFBSXU5SCxPQUFPN0MsWUFBWSxDQUFDLEVBQUUsR0FBR3ZoQyxRQUFRRCxLQUFLenZGLENBQUM7Z0JBQzNDLElBQUk0dkYsT0FBTztvQkFDVHI1RixHQUFHLENBQUNvNUYsUUFBUUQsUUFBU21rQyxDQUFBQSxPQUFPcGtDLEtBQUtsNUYsQ0FBQyxHQUFHbzlILEVBQUMsSUFBS0U7b0JBQzNDN3pILEdBQUcsQ0FBQzJ2RixRQUFRRCxRQUFTb2tDLENBQUFBLE9BQU9ya0MsS0FBS3p2RixDQUFDLEdBQUc0ekgsRUFBQyxJQUFLRTtnQkFDN0M7Z0JBRUEsc0JBQXNCO2dCQUN0QixJQUFJVCxVQUFVQSxPQUFPcHNILE1BQU0sSUFBSTtvQkFDN0IsSUFBSStxSCxjQUFjandJLEVBQUUrcEksUUFBUSxDQUFDNEYsYUFBYTtvQkFDMUNqSSxvQkFBb0J1STtvQkFDcEJqd0ksRUFBRWdySSxVQUFVLENBQUMsUUFBUTtvQkFDckJockksRUFBRWdySSxVQUFVLENBQUMsUUFBUTtvQkFDckJzRyxPQUFPaEYsVUFBVSxHQUFHajJFLElBQUksQ0FBQzh6RSxVQUFVO29CQUNuQzhGLFlBQVk1NUUsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQzNCLElBQUlucUksRUFBRStwSSxRQUFRLENBQUN3QyxPQUFPLEVBQUU7d0JBQ3RCK0UsT0FBT2o3RSxJQUFJLENBQUM4ekUsVUFBVTt3QkFDdEI4RixZQUFZNTVFLElBQUksQ0FBQzh6RSxVQUFVO29CQUM3QjtnQkFDRjtnQkFDQTFtSCxHQUFHcXFGLFFBQVEsQ0FBQztvQkFDVnBuRixNQUFNa25GO29CQUNObm5GLEtBQUtvbkY7b0JBQ0xPLG9CQUFvQjtnQkFDdEI7Z0JBQ0EzcUYsR0FBRzR5QyxJQUFJLENBQUM4ekUsVUFBVTtnQkFDbEI0RSxZQUFZd0M7Z0JBQ1o1QyxPQUFPK0I7Z0JBQ1A5QixPQUFPK0I7Z0JBQ1A5QixPQUFPK0I7Z0JBQ1A5QixPQUFPK0I7Z0JBQ1A3d0ksRUFBRW13SSxRQUFRLEdBQUc7WUFDZjtZQUVBLGFBQWE7WUFDYixJQUFJaHdJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsRUFBRTtnQkFDaEIsSUFBSW5xSCxNQUFNamYsRUFBRW1qSCxtQkFBbUIsQ0FBQ2hqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxFQUFFampILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPO2dCQUMxRXh0RyxHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7Z0JBQ2ZwSixHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7WUFDakI7WUFDQSxJQUFJOWUsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxFQUFFO2dCQUNoQixJQUFJbnFILE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQ2htQixPQUFPLEVBQUVqakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU87Z0JBQzFFeHRHLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtnQkFDZnBKLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtZQUNqQjtZQUNBLElBQUk5ZSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hCLElBQUlucUgsTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUNoakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU8sRUFBRWpqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUMvbEIsT0FBTztnQkFDMUV4dEcsR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO2dCQUNmcEosR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1lBQ2pCO1FBQ0YsT0FBTyxJQUFJOWUsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNwcEksRUFBRXd2SSxTQUFTLENBQUM0QixTQUFTLENBQUMsNEVBQTRFO1VBQzVIO1lBQ0EsSUFBSWo4RyxRQUFRbjFCLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUs7WUFDN0IsSUFBSWduRCxPQUFPbjhFLEVBQUV3dkksU0FBUyxDQUFDcnpELElBQUk7WUFDM0IsSUFBSXNvQztZQUNKLElBQUksQ0FBQ3prSCxFQUFFeXBJLFNBQVMsQ0FBQzRCLFlBQVksSUFBSSxDQUFDcnJJLEVBQUVneUksWUFBWSxFQUFFO2dCQUNoRHZ0QixPQUFPemtILEVBQUVva0gsa0JBQWtCLENBQUN2dUcsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRSxNQUFNO1lBQ3BEO1lBQ0EsSUFBSXd2SCxXQUFXbHdHLFNBQVMsTUFBTTtnQkFDNUJoMUIsRUFBRWsxRSxjQUFjO1lBQ2xCO1lBRUEsaUJBQWlCO1lBQ2pCLElBQUlnd0QsV0FBV2x3RyxTQUFTLFFBQVFuMUIsRUFBRXdsSSxlQUFlLENBQUNyd0csUUFBUTtnQkFDeEQsSUFBSXEyRyxxQkFBcUI7b0JBQ3ZCLDJCQUEyQjtvQkFDM0IsSUFBSXlFLGNBQWNqd0ksRUFBRStwSSxRQUFRLENBQUM0RixhQUFhO29CQUMxQyxJQUFJbkQsa0JBQWtCLENBQUN4c0ksRUFBRStwSSxRQUFRLENBQUN3QyxPQUFPO29CQUN6QyxJQUFJQyxpQkFBaUI7d0JBQ25CakYsZUFBZTBJLGFBQWE7NEJBQzFCak0sYUFBYTt3QkFDZjtvQkFDRjtvQkFDQWhrSSxFQUFFK3BJLFFBQVEsQ0FBQ3dDLE9BQU8sR0FBRztvQkFDckIsSUFBSUUsYUFBYTt3QkFDZmo0SCxHQUFHO3dCQUNIeUosR0FBRztvQkFDTDtvQkFDQSxJQUFJclosU0FBU2dqQyxJQUFJLENBQUMsRUFBRSxLQUFLaGpDLFNBQVNnakMsSUFBSSxDQUFDLEVBQUUsR0FBRzt3QkFDMUM2a0csV0FBV2o0SCxDQUFDLElBQUlvekIsSUFBSSxDQUFDLEVBQUU7d0JBQ3ZCNmtHLFdBQVd4dUgsQ0FBQyxJQUFJMnBCLElBQUksQ0FBQyxFQUFFO3dCQUN2QixJQUFJNGtHLGlCQUFpQjs0QkFDbkJ4c0ksRUFBRWdySSxVQUFVLENBQUMsUUFBUTs0QkFDckIsSUFBSWUsWUFBWS9ySSxFQUFFd3ZJLFNBQVMsQ0FBQ3pELFNBQVM7NEJBQ3JDLElBQUlBLGFBQWFubkksU0FBU21uSSxTQUFTLENBQUMsRUFBRSxLQUFLbm5JLFNBQVNtbkksU0FBUyxDQUFDLEVBQUUsR0FBRztnQ0FDakVVLFdBQVdqNEgsQ0FBQyxJQUFJdTNILFNBQVMsQ0FBQyxFQUFFO2dDQUM1QlUsV0FBV3h1SCxDQUFDLElBQUk4dEgsU0FBUyxDQUFDLEVBQUU7NEJBQzlCO3dCQUNGO29CQUNGO29CQUNBL3JJLEVBQUV5cEksU0FBUyxDQUFDNEIsWUFBWSxHQUFHO29CQUMzQjRFLFlBQVlwcEUsV0FBVyxDQUFDNGxFLFlBQVlwMkUsSUFBSSxDQUFDOHpFLFVBQVUsYUFBYTl6RSxJQUFJLENBQUM4ekUsVUFBVTtvQkFDL0VucUksRUFBRWdySSxVQUFVLENBQUMsUUFBUTtvQkFDckIsSUFBSWhySSxFQUFFd3ZJLFNBQVMsQ0FBQ3B1RixhQUFhLENBQUMsRUFBRSxJQUFJcXVGLE9BQU8sQ0FBQyxFQUFFLElBQUl6dkksRUFBRXd2SSxTQUFTLENBQUNwdUYsYUFBYSxDQUFDLEVBQUUsSUFBSXF1RixPQUFPLENBQUMsRUFBRSxFQUFFO3dCQUM1Rnp2SSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO29CQUN2QjtvQkFDQWhySSxFQUFFa3JJLE1BQU07Z0JBQ1YsT0FBTztvQkFDTCwrQ0FBK0M7b0JBQy9DLElBQUlhLFlBQVkvckksRUFBRXd2SSxTQUFTLENBQUN6RCxTQUFTLEdBQUcvckksRUFBRXd2SSxTQUFTLENBQUN6RCxTQUFTLElBQUksRUFBRTtvQkFDbkUsSUFBSUEsVUFBVTdySSxNQUFNLEtBQUssR0FBRzt3QkFDMUI2ckksVUFBVXJwSSxJQUFJLENBQUNrbEMsSUFBSSxDQUFDLEVBQUU7d0JBQ3RCbWtHLFVBQVVycEksSUFBSSxDQUFDa2xDLElBQUksQ0FBQyxFQUFFO29CQUN4QixPQUFPO3dCQUNMbWtHLFNBQVMsQ0FBQyxFQUFFLElBQUlua0csSUFBSSxDQUFDLEVBQUU7d0JBQ3ZCbWtHLFNBQVMsQ0FBQyxFQUFFLElBQUlua0csSUFBSSxDQUFDLEVBQUU7b0JBQ3pCO2dCQUNGO1lBQ0Y7WUFFQSxZQUFZO1lBQ1o7Z0JBQ0VxK0YsY0FBYzl3RyxTQUFTc3ZGLE1BQU07b0JBQUM7b0JBQWE7b0JBQVc7aUJBQWEsRUFBRXRrSCxHQUFHO29CQUN0RXFVLEdBQUdxQixHQUFHLENBQUMsRUFBRTtvQkFDVG9JLEdBQUdwSSxHQUFHLENBQUMsRUFBRTtnQkFDWDtnQkFDQSxJQUFJLENBQUMsQ0FBQ3NmLFNBQVMsQ0FBQ0EsTUFBTXBRLE9BQU8sRUFBQyxLQUFNMC9GLFFBQVF0b0MsTUFBTTtvQkFDaEQsSUFBSUEsTUFBTTt3QkFDUkEsS0FBSzlsQixJQUFJLENBQUM4ekUsVUFBVTtvQkFDdEI7b0JBQ0EsSUFBSTFsQixNQUFNO3dCQUNSQSxLQUFLcHVELElBQUksQ0FBQzh6RSxVQUFVO29CQUN0QjtnQkFDRjtnQkFDQW5xSSxFQUFFd3ZJLFNBQVMsQ0FBQ3J6RCxJQUFJLEdBQUdzb0M7WUFDckI7WUFFQSwwQkFBMEI7WUFDMUIsSUFBSTRnQixTQUFTO2dCQUNYLElBQUssSUFBSTVpSSxJQUFJLEdBQUdBLElBQUlvVCxJQUFJM1YsTUFBTSxFQUFFdUMsSUFBSztvQkFDbkMsSUFBSW9ULEdBQUcsQ0FBQ3BULEVBQUUsSUFBSXpDLEVBQUV3dkksU0FBUyxDQUFDcHVGLGFBQWEsQ0FBQzMrQyxFQUFFLElBQUkrb0kscUJBQXFCO3dCQUNqRXhySSxFQUFFd3ZJLFNBQVMsQ0FBQ0UsZ0JBQWdCLEdBQUc7b0JBQ2pDO2dCQUNGO1lBQ0Y7WUFFQSxVQUFVO1lBQ1YsSUFBSXJLLFdBQVlsd0csQ0FBQUEsU0FBUyxRQUFRQSxNQUFNbFEsUUFBUSxFQUFDLEtBQU14QixHQUFHbXBGLGNBQWMsTUFBTW5wRixHQUFHb3BGLGtCQUFrQixJQUFJO2dCQUNwRyxJQUFJNDVCLG1CQUFtQkgsd0JBQXdCbnhHLE9BQU9uMUIsRUFBRXd2SSxTQUFTLENBQUNRLE1BQU07Z0JBQ3hFLElBQUl2SixrQkFBa0I7b0JBQ3BCdG1JLEVBQUVrMUUsY0FBYztvQkFDaEIsSUFBSSxDQUFDcjFFLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixFQUFFO3dCQUM3QmpySSxFQUFFNmpCLElBQUksQ0FBQ29uSCxpQkFBaUIsR0FBR3Z5RyxZQUFZMTRCLEVBQUV3dkksU0FBUyxDQUFDcHVGLGFBQWE7b0JBQ2xFO29CQUNBLElBQUlwaEQsRUFBRWd5SSxZQUFZLEVBQUU7d0JBQ2xCdnVILEdBQUdtZ0MsS0FBSyxDQUFDOzRCQUNQcHZDLEdBQUdvekIsSUFBSSxDQUFDLEVBQUUsR0FBR2xoQjs0QkFDYnpJLEdBQUcycEIsSUFBSSxDQUFDLEVBQUUsR0FBR2xoQjt3QkFDZjt3QkFDQWpELEdBQUc0eUMsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ3BCLE9BQU8sSUFBSXFCLHFCQUFxQjt3QkFDOUJ4ckksRUFBRWd5SSxZQUFZLEdBQUc7d0JBQ2pCdnVILEdBQUdtZ0MsS0FBSyxDQUFDOzRCQUNQcHZDLEdBQUdzbEIsS0FBS3BUOzRCQUNSekksR0FBRzhiLEtBQUtyVDt3QkFDVjt3QkFDQWpELEdBQUc0eUMsSUFBSSxDQUFDOHpFLFVBQVU7d0JBQ2xCLElBQUloMUcsT0FBTzs0QkFDVEEsTUFBTW0zRyxVQUFVOzRCQUNoQnRzSSxFQUFFZ3JJLFVBQVUsQ0FBQyxVQUFVOzRCQUN2QmhySSxFQUFFd3ZJLFNBQVMsQ0FBQ3I2RyxLQUFLLEdBQUc7d0JBQ3RCO29CQUNGO2dCQUNGO2dCQUVBLGFBQWE7Z0JBQ2IsSUFBSWxXLE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQ2htQixPQUFPLEVBQUVqakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU87Z0JBQzFFeHRHLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtnQkFDZnBKLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtZQUNqQjtRQUNGO1FBQ0EsSUFBSyxJQUFJblcsSUFBSSxHQUFHQSxJQUFJK00sSUFBSTNWLE1BQU0sRUFBRTRJLElBQUs7WUFDbkMybUksT0FBTyxDQUFDM21JLEVBQUUsR0FBRytNLEdBQUcsQ0FBQy9NLEVBQUU7UUFDckI7UUFFQSw4R0FBOEc7UUFDOUcsSUFBSXU4SCxXQUFXbGxJLEVBQUVpcEksT0FBTyxDQUFDbHBJLE1BQU0sR0FBRyxLQUFLLENBQUNGLEVBQUV5cEksU0FBUyxDQUFDNEIsWUFBWSxJQUFJLENBQUNyckksRUFBRWd5SSxZQUFZLElBQUloeUksRUFBRTZqQixJQUFJLENBQUNvbkgsaUJBQWlCLElBQUksTUFBTTtZQUN2SGpySSxFQUFFNmpCLElBQUksQ0FBQ29uSCxpQkFBaUIsR0FBR2hvSTtZQUMzQmpELEVBQUVnckksVUFBVSxDQUFDLFVBQVU7WUFDdkJockksRUFBRWtySSxNQUFNO1FBQ1Y7SUFDRixHQUFHO0lBQ0gsSUFBSStHO0lBQ0pqeUksRUFBRStrSSxlQUFlLENBQUNya0MsaUJBQWlCLGVBQWV1eEMscUJBQXFCLFNBQVNBLG1CQUFtQjl4SSxDQUFDO1FBQ2xHLHFDQUFxQztRQUNyQyxJQUFJZzFCLFFBQVFuMUIsRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSztRQUM3Qm4xQixFQUFFd3ZJLFNBQVMsQ0FBQ25LLE9BQU8sR0FBRztRQUN0QixJQUFJbHdHLE9BQU87WUFDVEEsTUFBTW0zRyxVQUFVO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJNEYsaUJBQWlCQyxnQkFBZ0JDLGNBQWNDO0lBQ25EcnlJLEVBQUUra0ksZUFBZSxDQUFDcmtDLGlCQUFpQixZQUFZd3hDLGtCQUFrQixTQUFTQSxnQkFBZ0IveEksQ0FBQztRQUN6RixxQ0FBcUM7UUFDckMsSUFBSWcxQixRQUFRbjFCLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUs7UUFDN0IsSUFBSWt3RyxVQUFVcmxJLEVBQUV3dkksU0FBUyxDQUFDbkssT0FBTztRQUNqQyxJQUFJQSxTQUFTO1lBQ1gsSUFBSWxsSSxFQUFFaXBJLE9BQU8sQ0FBQ2xwSSxNQUFNLEtBQUssR0FBRztnQkFDMUJGLEVBQUV3dkksU0FBUyxDQUFDbkssT0FBTyxHQUFHO1lBQ3hCO1lBQ0FsbEksRUFBRWsxRSxjQUFjO1FBQ2xCLE9BQU87WUFDTDtRQUNGO1FBQ0EsSUFBSXUwRCxTQUFTNXBJLEVBQUVpcEksU0FBUztRQUN4QmpwSSxFQUFFZ3lJLFlBQVksR0FBRztRQUNqQmh5SSxFQUFFeXBJLFNBQVMsQ0FBQzRCLFlBQVksR0FBRztRQUMzQixJQUFJNW5ILEtBQUt6akIsRUFBRXlqQixFQUFFO1FBQ2IsSUFBSWlELE9BQU9qRCxHQUFHaUQsSUFBSTtRQUNsQixJQUFJN1EsTUFBTTdWLEVBQUV3dkksU0FBUyxDQUFDMzVILEdBQUc7UUFDekIsSUFBSTQ1SCxVQUFVenZJLEVBQUV3dkksU0FBUyxDQUFDQyxPQUFPO1FBQ2pDLElBQUl0dkksRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxFQUFFO1lBQ2hCLElBQUlucUgsTUFBTWpmLEVBQUVtakgsbUJBQW1CLENBQUNoakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU8sRUFBRWpqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUMvbEIsT0FBTztZQUMxRXh0RyxHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7WUFDZnBKLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtRQUNqQjtRQUNBLElBQUk5ZSxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDaEIsSUFBSW5xSCxNQUFNamYsRUFBRW1qSCxtQkFBbUIsQ0FBQ2hqSCxFQUFFaXBJLE9BQU8sQ0FBQyxFQUFFLENBQUNobUIsT0FBTyxFQUFFampILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQy9sQixPQUFPO1lBQzFFeHRHLEdBQUcsQ0FBQyxFQUFFLEdBQUdvSixHQUFHLENBQUMsRUFBRTtZQUNmcEosR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1FBQ2pCO1FBQ0EsSUFBSTllLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUNoQixJQUFJbnFILE1BQU1qZixFQUFFbWpILG1CQUFtQixDQUFDaGpILEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsQ0FBQ2htQixPQUFPLEVBQUVqakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU87WUFDMUV4dEcsR0FBRyxDQUFDLEVBQUUsR0FBR29KLEdBQUcsQ0FBQyxFQUFFO1lBQ2ZwSixHQUFHLENBQUMsRUFBRSxHQUFHb0osR0FBRyxDQUFDLEVBQUU7UUFDakI7UUFDQSxJQUFJa3JILFlBQVksU0FBU0EsVUFBVXAxSCxJQUFJO1lBQ3JDLE9BQU87Z0JBQ0x3Z0UsZUFBZXAxRTtnQkFDZjRVLE1BQU1BO2dCQUNOa1AsVUFBVTtvQkFDUnpQLEdBQUdxQixHQUFHLENBQUMsRUFBRTtvQkFDVG9JLEdBQUdwSSxHQUFHLENBQUMsRUFBRTtnQkFDWDtZQUNGO1FBQ0Y7UUFDQSxJQUFJc2YsT0FBTztZQUNUQSxNQUFNbTNHLFVBQVU7UUFDbEI7UUFDQSxJQUFJZ0c7UUFDSixJQUFJdHlJLEVBQUV3dkksU0FBUyxDQUFDMzRDLEdBQUcsRUFBRTtZQUNuQnk3QyxZQUFZbkksVUFBVTtZQUN0QixJQUFJaDFHLE9BQU87Z0JBQ1RBLE1BQU1raEMsSUFBSSxDQUFDaThFO1lBQ2IsT0FBTztnQkFDTDd1SCxHQUFHNHlDLElBQUksQ0FBQ2k4RTtZQUNWO1lBQ0EsSUFBSSxDQUFDdHlJLEVBQUV3dkksU0FBUyxDQUFDM0UsVUFBVSxFQUFFO2dCQUMzQixJQUFJMEgsU0FBU3BJLFVBQVU7Z0JBQ3ZCLElBQUloMUcsT0FBTztvQkFDVEEsTUFBTWtoQyxJQUFJLENBQUNrOEU7Z0JBQ2IsT0FBTztvQkFDTDl1SCxHQUFHNHlDLElBQUksQ0FBQ2s4RTtnQkFDVjtZQUNGO1lBQ0EsSUFBSXZ5SSxFQUFFd3ZJLFNBQVMsQ0FBQ3I2RyxLQUFLLEVBQUU7Z0JBQ3JCbjFCLEVBQUV3dkksU0FBUyxDQUFDcjZHLEtBQUssQ0FBQzl2QixRQUFRLENBQUMwZixPQUFPLEdBQUc7WUFDdkM7WUFDQS9rQixFQUFFd3ZJLFNBQVMsQ0FBQzM0QyxHQUFHLEdBQUc7WUFDbEI3MkYsRUFBRXd2SSxTQUFTLENBQUNyNkcsS0FBSyxHQUFHO1lBQ3BCbjFCLEVBQUVrckksTUFBTTtZQUNSO1FBQ0Y7UUFFQSx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDL3FJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsSUFBSTNsSCxHQUFHdXBGLG1CQUFtQixNQUFNaHRHLEVBQUV3dkksU0FBUyxDQUFDakUsU0FBUyxFQUFFO1lBQ3RFdnJJLEVBQUV3dkksU0FBUyxDQUFDakUsU0FBUyxHQUFHO1lBQ3hCLElBQUlyc0gsTUFBTXVFLEdBQUdyZSxVQUFVLENBQUNwRixFQUFFZ25ILFdBQVcsQ0FBQzRpQixNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRTtZQUNoRkEsTUFBTSxDQUFDLEVBQUUsR0FBRzNtSTtZQUNaMm1JLE1BQU0sQ0FBQyxFQUFFLEdBQUczbUk7WUFDWjJtSSxNQUFNLENBQUMsRUFBRSxHQUFHM21JO1lBQ1oybUksTUFBTSxDQUFDLEVBQUUsR0FBRzNtSTtZQUNaMm1JLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDWjVwSSxFQUFFZ3JJLFVBQVUsQ0FBQyxVQUFVO1lBQ3ZCdm5ILEdBQUc0eUMsSUFBSSxDQUFDOHpFLFVBQVU7WUFDbEIsSUFBSTRDLHFCQUFxQixTQUFTQSxtQkFBbUJ2ckgsR0FBRztnQkFDdEQsT0FBT0EsSUFBSXFELFVBQVUsTUFBTSxDQUFDckQsSUFBSW9ELFFBQVE7WUFDMUM7WUFDQTFGLElBQUltM0MsSUFBSSxDQUFDOHpFLFVBQVUsUUFBUXhtRSxTQUFTLENBQUNvcEUsb0JBQW9CbkQsTUFBTSxHQUFHdnpFLElBQUksQ0FBQzh6RSxVQUFVO1lBQ2pGLElBQUlqckgsSUFBSXNrRCxRQUFRLElBQUk7Z0JBQ2xCeGpFLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7WUFDdkI7WUFDQWhySSxFQUFFa3JJLE1BQU07UUFDVjtRQUNBLElBQUkvMUcsU0FBUyxNQUFNO1lBQ2pCQSxNQUFNbTNHLFVBQVU7UUFDbEI7UUFDQSxJQUFJbnNJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUUsRUFBRTtZQUNoQnBwSSxFQUFFNmpCLElBQUksQ0FBQ29uSCxpQkFBaUIsR0FBR2hvSTtZQUMzQmpELEVBQUVnckksVUFBVSxDQUFDLFVBQVU7UUFDekIsT0FBTyxJQUFJN3FJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUU7YUFBUyxJQUFJanBJLEVBQUVpcEksT0FBTyxDQUFDLEVBQUU7YUFBUyxJQUFJLENBQUNqcEksRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxFQUFFO1lBQzFFcHBJLEVBQUU2akIsSUFBSSxDQUFDb25ILGlCQUFpQixHQUFHaG9JO1lBQzNCakQsRUFBRWdySSxVQUFVLENBQUMsVUFBVTtZQUN2QixJQUFJaUYsY0FBY2p3SSxFQUFFK3BJLFFBQVEsQ0FBQzRGLGFBQWE7WUFDMUMsSUFBSXg2RyxTQUFTLE1BQU07Z0JBQ2pCLElBQUlxOUcsa0JBQWtCcjlHLE1BQU05dkIsUUFBUSxDQUFDMGYsT0FBTztnQkFDNUMyaUgsb0JBQW9CdUk7Z0JBQ3BCandJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7Z0JBQ3JCaHJJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7Z0JBQ3JCLElBQUl3SCxpQkFBaUI7b0JBQ25CcjlHLE1BQU1raEMsSUFBSSxDQUFDOHpFLFVBQVU7b0JBQ3JCOEYsWUFBWTU1RSxJQUFJLENBQUM4ekUsVUFBVTtvQkFDM0IsSUFBSW5xSSxFQUFFK3BJLFFBQVEsQ0FBQ3dDLE9BQU8sRUFBRTt3QkFDdEJwM0csTUFBTWtoQyxJQUFJLENBQUM4ekUsVUFBVTt3QkFDckI4RixZQUFZNTVFLElBQUksQ0FBQzh6RSxVQUFVO29CQUM3QjtnQkFDRjtnQkFDQWxFLGNBQWM5d0csT0FBTztvQkFBQztvQkFBWTtvQkFBVTtvQkFBWTtpQkFBYSxFQUFFaDFCLEdBQUc7b0JBQ3hFcVUsR0FBR3FCLEdBQUcsQ0FBQyxFQUFFO29CQUNUb0ksR0FBR3BJLEdBQUcsQ0FBQyxFQUFFO2dCQUNYO2dCQUNBc2YsTUFBTW0zRyxVQUFVO2dCQUNoQnRzSSxFQUFFd3ZJLFNBQVMsQ0FBQ3I2RyxLQUFLLEdBQUc7WUFDdEIsT0FBTztnQkFDTCxJQUFJc3ZGLE9BQU96a0gsRUFBRW9rSCxrQkFBa0IsQ0FBQ3Z1RyxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFLE1BQU07Z0JBQ3REb3dILGNBQWN4aEIsTUFBTTtvQkFBQztvQkFBWTtvQkFBVTtvQkFBWTtpQkFBYSxFQUFFdGtILEdBQUc7b0JBQ3ZFcVUsR0FBR3FCLEdBQUcsQ0FBQyxFQUFFO29CQUNUb0ksR0FBR3BJLEdBQUcsQ0FBQyxFQUFFO2dCQUNYO1lBQ0Y7WUFDQSxJQUFJaWtCLEtBQUs5NUIsRUFBRXd2SSxTQUFTLENBQUNwdUYsYUFBYSxDQUFDLEVBQUUsR0FBR3ZyQyxHQUFHLENBQUMsRUFBRTtZQUM5QyxJQUFJNDFILE1BQU0zeEcsS0FBS0E7WUFDZixJQUFJQyxLQUFLLzVCLEVBQUV3dkksU0FBUyxDQUFDcHVGLGFBQWEsQ0FBQyxFQUFFLEdBQUd2ckMsR0FBRyxDQUFDLEVBQUU7WUFDOUMsSUFBSTYxSCxNQUFNM3hHLEtBQUtBO1lBQ2YsSUFBSTR4RyxRQUFRRixNQUFNQztZQUNsQixJQUFJK0csU0FBUzlHLFFBQVFqbEgsT0FBT0E7WUFFNUIseURBQXlEO1lBQ3pELElBQUksQ0FBQzFtQixFQUFFd3ZJLFNBQVMsQ0FBQ0UsZ0JBQWdCLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQ3Y2RyxPQUFPO29CQUNWMVIsR0FBR2lRLENBQUMsQ0FBQyxhQUFhb3ZELFFBQVEsQ0FBQzt3QkFBQztxQkFBYztnQkFDNUM7Z0JBQ0FtakQsY0FBYzl3RyxPQUFPO29CQUFDO29CQUFPO2lCQUFTLEVBQUVoMUIsR0FBRztvQkFDekNxVSxHQUFHcUIsR0FBRyxDQUFDLEVBQUU7b0JBQ1RvSSxHQUFHcEksR0FBRyxDQUFDLEVBQUU7Z0JBQ1g7Z0JBQ0FzOEgsaUJBQWlCO2dCQUNqQixJQUFJaHlJLEVBQUV1MUUsU0FBUyxHQUFHMjhELHNCQUFzQjV1SCxHQUFHbXJGLHNCQUFzQixJQUFJO29CQUNuRXdqQyxnQkFBZ0IzMkgsYUFBYTIySDtvQkFDN0JELGlCQUFpQjtvQkFDakJFLHFCQUFxQjtvQkFDckJwTSxjQUFjOXdHLE9BQU87d0JBQUM7d0JBQVU7cUJBQVksRUFBRWgxQixHQUFHO3dCQUMvQ3FVLEdBQUdxQixHQUFHLENBQUMsRUFBRTt3QkFDVG9JLEdBQUdwSSxHQUFHLENBQUMsRUFBRTtvQkFDWDtnQkFDRixPQUFPO29CQUNMdThILGVBQWVwM0gsV0FBVzt3QkFDeEIsSUFBSW0zSCxnQkFBZ0I7d0JBQ3BCbE0sY0FBYzl3RyxPQUFPOzRCQUFDOzRCQUFVO3lCQUFZLEVBQUVoMUIsR0FBRzs0QkFDL0NxVSxHQUFHcUIsR0FBRyxDQUFDLEVBQUU7NEJBQ1RvSSxHQUFHcEksR0FBRyxDQUFDLEVBQUU7d0JBQ1g7b0JBQ0YsR0FBRzROLEdBQUdtckYsc0JBQXNCO29CQUM1QnlqQyxxQkFBcUJseUksRUFBRXUxRSxTQUFTO2dCQUNsQztZQUNGO1lBRUEsdUdBQXVHO1lBQ3ZHLElBQUl2Z0QsU0FBUyxRQUFRLENBQUNuMUIsRUFBRStwSSxRQUFRLENBQUN3QyxPQUFPLENBQUMsMkJBQTJCO2dCQUNqRXAzRyxNQUFNOXZCLFFBQVEsQ0FBQ3dmLFVBQVUsSUFBSTR0SCxTQUFTenlJLEVBQUV5d0ksa0JBQWtCLElBQUksQ0FBQ3p3SSxFQUFFbXdJLFFBQVEsQ0FBQyw0Q0FBNEM7Y0FDdkg7Z0JBQ0EsSUFBSTFzSCxHQUFHaXBGLGFBQWEsT0FBTyxVQUFVO29CQUNuQ2pwRixHQUFHaVEsQ0FBQyxDQUFDaXlHLFlBQVl2ckQsT0FBTyxDQUFDamxELE9BQU8ydEQsUUFBUSxDQUFDO3dCQUFDO3FCQUFjO29CQUN4RDN0RCxNQUFNeTBHLE1BQU0sQ0FBQzt3QkFBQztxQkFBWTtnQkFDNUIsT0FBTztvQkFDTCxJQUFJejBHLE1BQU12USxRQUFRLElBQUk7d0JBQ3BCdVEsTUFBTTJ0RCxRQUFRLENBQUM7NEJBQUM7eUJBQWM7b0JBQ2hDLE9BQU87d0JBQ0wzdEQsTUFBTXkwRyxNQUFNLENBQUM7NEJBQUM7eUJBQVk7b0JBQzVCO2dCQUNGO2dCQUNBNXBJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7WUFDdkI7WUFDQWhySSxFQUFFd3ZJLFNBQVMsQ0FBQ0UsZ0JBQWdCLEdBQUc7UUFDakM7UUFDQSxJQUFLLElBQUk1bUksSUFBSSxHQUFHQSxJQUFJK00sSUFBSTNWLE1BQU0sRUFBRTRJLElBQUs7WUFDbkMybUksT0FBTyxDQUFDM21JLEVBQUUsR0FBRytNLEdBQUcsQ0FBQy9NLEVBQUU7UUFDckI7UUFDQTlJLEVBQUUrcEksUUFBUSxDQUFDd0MsT0FBTyxHQUFHLE9BQU8sNEJBQTRCO1FBRXhELElBQUlwc0ksRUFBRWlwSSxPQUFPLENBQUNscEksTUFBTSxLQUFLLEdBQUc7WUFDMUJGLEVBQUV3dkksU0FBUyxDQUFDekQsU0FBUyxHQUFHLEVBQUU7WUFDMUIvckksRUFBRXd2SSxTQUFTLENBQUNwdUYsYUFBYSxHQUFHO2dCQUFDO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2FBQUs7WUFDaEVwaEQsRUFBRXd2SSxTQUFTLENBQUNjLGNBQWMsR0FBRztZQUM3QnR3SSxFQUFFd3ZJLFNBQVMsQ0FBQzRCLFNBQVMsR0FBRztRQUMxQjtRQUNBLElBQUlqeEksRUFBRWlwSSxPQUFPLENBQUNscEksTUFBTSxHQUFHLEdBQUc7WUFDeEIsSUFBSUMsRUFBRWlwSSxPQUFPLENBQUNscEksTUFBTSxLQUFLLEdBQUc7Z0JBQzFCLHFFQUFxRTtnQkFDckVGLEVBQUV3dkksU0FBUyxDQUFDYyxjQUFjLEdBQUc7b0JBQUNud0ksRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDaG1CLE9BQU87b0JBQUVqakgsRUFBRWlwSSxPQUFPLENBQUMsRUFBRSxDQUFDL2xCLE9BQU87aUJBQUM7WUFDM0U7WUFDQXJqSCxFQUFFbXdJLFFBQVEsR0FBRztZQUNibndJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7WUFDckJockksRUFBRWtySSxNQUFNO1FBQ1Y7SUFFQSxhQUFhO0lBQ2YsR0FBRztJQUVILHFEQUFxRDtJQUNyRCxJQUFJLE9BQU93SCxlQUFlLGFBQWE7UUFDckMsSUFBSUMsV0FBVyxFQUFFO1FBQ2pCLElBQUlDLFlBQVksU0FBU0EsVUFBVXp5SSxDQUFDO1lBQ2xDLE9BQU87Z0JBQ0xpakgsU0FBU2pqSCxFQUFFaWpILE9BQU87Z0JBQ2xCQyxTQUFTbGpILEVBQUVrakgsT0FBTztnQkFDbEJyN0MsT0FBTztnQkFDUDZxRSxZQUFZMXlJLEVBQUUyeUksU0FBUztnQkFDdkJDLE9BQU81eUksRUFBRTR5SSxLQUFLO2dCQUNkQyxPQUFPN3lJLEVBQUU2eUksS0FBSztnQkFDZEMsU0FBUzl5SSxFQUFFaTlCLEtBQUssR0FBRztnQkFDbkI4MUcsU0FBUy95SSxFQUFFazlCLE1BQU0sR0FBRztnQkFDcEI4MUcsU0FBU2h6SSxFQUFFZ3pJLE9BQU87Z0JBQ2xCQyxTQUFTanpJLEVBQUVpekksT0FBTztnQkFDbEJydkgsUUFBUTVqQixFQUFFNGpCLE1BQU07WUFDbEI7UUFDRjtRQUNBLElBQUlzdkgsY0FBYyxTQUFTQSxZQUFZbHpJLENBQUM7WUFDdEMsT0FBTztnQkFDTHNGLE9BQU90RjtnQkFDUG16SSxPQUFPVixVQUFVenlJO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJb3pJLGFBQWEsU0FBU0EsV0FBV3B6SSxDQUFDO1lBQ3BDd3lJLFNBQVNqd0ksSUFBSSxDQUFDMndJLFlBQVlsekk7UUFDNUI7UUFDQSxJQUFJcXpJLGdCQUFnQixTQUFTQSxjQUFjcnpJLENBQUM7WUFDMUMsSUFBSyxJQUFJc0MsSUFBSSxHQUFHQSxJQUFJa3dJLFNBQVN6eUksTUFBTSxFQUFFdUMsSUFBSztnQkFDeEMsSUFBSWdILElBQUlrcEksUUFBUSxDQUFDbHdJLEVBQUU7Z0JBQ25CLElBQUlnSCxFQUFFaEUsS0FBSyxDQUFDcXRJLFNBQVMsS0FBSzN5SSxFQUFFMnlJLFNBQVMsRUFBRTtvQkFDckNILFNBQVNqeEgsTUFBTSxDQUFDamYsR0FBRztvQkFDbkI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSWd4SSxnQkFBZ0IsU0FBU0EsY0FBY3R6SSxDQUFDO1lBQzFDLElBQUlzSixJQUFJa3BJLFNBQVN4dkgsTUFBTSxDQUFDLFNBQVUxWixDQUFDO2dCQUNqQyxPQUFPQSxFQUFFaEUsS0FBSyxDQUFDcXRJLFNBQVMsS0FBSzN5SSxFQUFFMnlJLFNBQVM7WUFDMUMsRUFBRSxDQUFDLEVBQUU7WUFDTHJwSSxFQUFFaEUsS0FBSyxHQUFHdEY7WUFDVnNKLEVBQUU2cEksS0FBSyxHQUFHVixVQUFVenlJO1FBQ3RCO1FBQ0EsSUFBSXV6SSxvQkFBb0IsU0FBU0Esa0JBQWtCdnpJLENBQUM7WUFDbERBLEVBQUVpcEksT0FBTyxHQUFHdUosU0FBUzErSCxHQUFHLENBQUMsU0FBVXhLLENBQUM7Z0JBQ2xDLE9BQU9BLEVBQUU2cEksS0FBSztZQUNoQjtRQUNGO1FBQ0EsSUFBSUssaUJBQWlCLFNBQVNBLGVBQWV4ekksQ0FBQztZQUM1QyxPQUFPQSxFQUFFeXpJLFdBQVcsS0FBSyxXQUFXenpJLEVBQUV5ekksV0FBVyxLQUFLO1FBQ3hEO1FBQ0E1ekksRUFBRStrSSxlQUFlLENBQUMva0ksRUFBRWkxRixTQUFTLEVBQUUsZUFBZSxTQUFVOTBGLENBQUM7WUFDdkQsSUFBSXd6SSxlQUFleHpJLElBQUk7Z0JBQ3JCO1lBQ0YsRUFBRSx3QkFBd0I7WUFFMUJBLEVBQUVrMUUsY0FBYztZQUNoQmsrRCxXQUFXcHpJO1lBQ1h1ekksa0JBQWtCdnpJO1lBQ2xCb3ZJLGtCQUFrQnB2STtRQUNwQjtRQUNBSCxFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxhQUFhLFNBQVU5MEYsQ0FBQztZQUNyRCxJQUFJd3pJLGVBQWV4ekksSUFBSTtnQkFDckI7WUFDRixFQUFFLHdCQUF3QjtZQUUxQnF6SSxjQUFjcnpJO1lBQ2R1ekksa0JBQWtCdnpJO1lBQ2xCK3hJLGdCQUFnQi94STtRQUNsQjtRQUNBSCxFQUFFK2tJLGVBQWUsQ0FBQy9rSSxFQUFFaTFGLFNBQVMsRUFBRSxpQkFBaUIsU0FBVTkwRixDQUFDO1lBQ3pELElBQUl3ekksZUFBZXh6SSxJQUFJO2dCQUNyQjtZQUNGLEVBQUUsd0JBQXdCO1lBRTFCcXpJLGNBQWNyekk7WUFDZHV6SSxrQkFBa0J2ekk7WUFDbEI4eEksbUJBQW1COXhJO1FBQ3JCO1FBQ0FILEVBQUUra0ksZUFBZSxDQUFDL2tJLEVBQUVpMUYsU0FBUyxFQUFFLGVBQWUsU0FBVTkwRixDQUFDO1lBQ3ZELElBQUl3ekksZUFBZXh6SSxJQUFJO2dCQUNyQjtZQUNGLEVBQUUsd0JBQXdCO1lBRTFCQSxFQUFFazFFLGNBQWM7WUFDaEJvK0QsY0FBY3R6STtZQUNkdXpJLGtCQUFrQnZ6STtZQUNsQm93SSxpQkFBaUJwd0k7UUFDbkI7SUFDRjtBQUNGO0FBRUEsSUFBSTB6SSxRQUFRLENBQUM7QUFDYkEsTUFBTUMsZUFBZSxHQUFHLFNBQVV2d0ksSUFBSSxFQUFFMitCLE1BQU07SUFDNUMsT0FBTyxJQUFJLENBQUMrckMsVUFBVSxDQUFDMXFFLEtBQUssR0FBRztRQUM3QnlxRSxVQUFVLElBQUk7UUFDZHpxRSxNQUFNQTtRQUNOMitCLFFBQVFBO1FBQ1IrL0UsTUFBTSxTQUFTQSxLQUFLM3JDLE9BQU8sRUFBRXA0RCxPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTSxFQUFFUyxZQUFZO1lBQ3hFLElBQUksQ0FBQ2t3QyxRQUFRLENBQUMrbEUsYUFBYSxDQUFDLFdBQVd6OUQsU0FBU3A0RCxTQUFTQyxTQUFTaWYsT0FBT0MsUUFBUSxJQUFJLENBQUM2RSxNQUFNO1FBQzlGO1FBQ0EwekYsZUFBZSxTQUFTQSxjQUFjajRGLEtBQUssRUFBRUMsS0FBSyxFQUFFUixLQUFLLEVBQUVDLE1BQU0sRUFBRTdvQixDQUFDLEVBQUV5SixDQUFDLEVBQUVpZCxPQUFPLEVBQUU0QyxZQUFZO1lBQzVGLE9BQU9pSixxQkFBcUJ2eUIsR0FBR3lKLEdBQUcsSUFBSSxDQUFDaWtCLE1BQU0sRUFBRXZFLE9BQU9DLE9BQU9SLFFBQVEsR0FBR0MsU0FBUyxHQUFHbkM7UUFDdEY7UUFDQXFxRixZQUFZLFNBQVNBLFdBQVcvd0csQ0FBQyxFQUFFeUosQ0FBQyxFQUFFaWQsT0FBTyxFQUFFa0MsS0FBSyxFQUFFQyxNQUFNLEVBQUVuZixPQUFPLEVBQUVDLE9BQU8sRUFBRTJmLFlBQVk7WUFDMUYsT0FBT3NFLG1CQUFtQjV0QixHQUFHeUosR0FBRyxJQUFJLENBQUNpa0IsTUFBTSxFQUFFaGtCLFNBQVNDLFNBQVNpZixPQUFPQyxRQUFRO2dCQUFDO2dCQUFHLENBQUM7YUFBRSxFQUFFbkM7UUFDekY7UUFDQWl6QyxnQkFBZ0I1cUUsU0FBUztRQUN6QjhxRSxhQUFhLFNBQVNBLFlBQVlud0QsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFMDJHLGNBQWM7WUFDNUYsT0FBTzcyRyxTQUFTLElBQUksQ0FBQytFLE1BQU0sRUFBRWhrQixTQUFTQyxTQUFTaWYsT0FBT0MsUUFBUUM7UUFDaEU7SUFDRjtBQUNGO0FBQ0F1MkcsTUFBTUksZUFBZSxHQUFHO0lBQ3RCLE9BQU8sSUFBSSxDQUFDaG1FLFVBQVUsQ0FBQyxVQUFVLEdBQUc7UUFDbENELFVBQVUsSUFBSTtRQUNkenFFLE1BQU07UUFDTjArRyxNQUFNLFNBQVNBLEtBQUszckMsT0FBTyxFQUFFcDRELE9BQU8sRUFBRUMsT0FBTyxFQUFFaWYsS0FBSyxFQUFFQyxNQUFNLEVBQUVTLFlBQVk7WUFDeEUsSUFBSSxDQUFDa3dDLFFBQVEsQ0FBQytsRSxhQUFhLENBQUMsSUFBSSxDQUFDeHdJLElBQUksRUFBRSt5RSxTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQztRQUMzRTtRQUNBdTRGLGVBQWUsU0FBU0EsY0FBY2o0RixLQUFLLEVBQUVDLEtBQUssRUFBRVIsS0FBSyxFQUFFQyxNQUFNLEVBQUU3b0IsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFaWQsT0FBTyxFQUFFNEMsWUFBWTtZQUM1RixPQUFPOEcscUJBQXFCcHdCLEdBQUd5SixHQUFHMGYsT0FBT0MsT0FBT1IsUUFBUSxJQUFJbEMsU0FBU21DLFNBQVMsSUFBSW5DO1FBQ3BGO1FBQ0FxcUYsWUFBWSxTQUFTQSxXQUFXL3dHLENBQUMsRUFBRXlKLENBQUMsRUFBRWlkLE9BQU8sRUFBRWtDLEtBQUssRUFBRUMsTUFBTSxFQUFFbmYsT0FBTyxFQUFFQyxPQUFPLEVBQUUyZixZQUFZO1lBQzFGLE9BQU9tSCxlQUFlendCLEdBQUd5SixHQUFHbWYsT0FBT0MsUUFBUW5mLFNBQVNDLFNBQVMrYztRQUMvRDtJQUNGO0FBQ0Y7QUFDQTI0RyxNQUFNSyxvQkFBb0IsR0FBRyxTQUFVM3dJLElBQUksRUFBRTIrQixNQUFNO0lBQ2pELE9BQU8sSUFBSSxDQUFDK3JDLFVBQVUsQ0FBQzFxRSxLQUFLLEdBQUc7UUFDN0J5cUUsVUFBVSxJQUFJO1FBQ2R6cUUsTUFBTUE7UUFDTjIrQixRQUFRQTtRQUNSaXlHLG9CQUFvQixTQUFTQSxtQkFBbUJqMkgsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRVMsWUFBWSxFQUFFdW5GLEVBQUUsRUFBRTF4RCxLQUFLO1lBQ3RHLElBQUkweEQsRUFBRSxDQUFDMXhELE1BQU0sS0FBSzF3RCxhQUFhb2lILEVBQUUsQ0FBQzF4RCxRQUFRLE1BQU0sS0FBS3oxQyxXQUFXbW5HLEVBQUUsQ0FBQzF4RCxRQUFRLE1BQU0sS0FBS3gxQyxTQUFTO2dCQUM3RixPQUFPa25HLEVBQUUsQ0FBQzF4RCxNQUFNO1lBQ2xCO1lBQ0EweEQsRUFBRSxDQUFDMXhELE1BQU0sR0FBRyxJQUFJdHpELE1BQU02aEMsT0FBT2hpQyxNQUFNLEdBQUc7WUFDdENtbEgsRUFBRSxDQUFDMXhELFFBQVEsTUFBTSxHQUFHejFDO1lBQ3BCbW5HLEVBQUUsQ0FBQzF4RCxRQUFRLE1BQU0sR0FBR3gxQztZQUNwQixJQUFJMG9CLFFBQVF6SixRQUFRO1lBQ3BCLElBQUkwSixRQUFRekosU0FBUztZQUNyQlMsZUFBZUEsaUJBQWlCLFNBQVMrSyxzQkFBc0J6TCxPQUFPQyxVQUFVUztZQUNoRixJQUFJcjBCLElBQUksSUFBSXBKLE1BQU02aEMsT0FBT2hpQyxNQUFNLEdBQUc7WUFDbEMsSUFBSyxJQUFJaXBCLEtBQUssR0FBR0EsS0FBSytZLE9BQU9oaUMsTUFBTSxHQUFHLEdBQUdpcEIsS0FBTTtnQkFDN0MxZixDQUFDLENBQUMwZixHQUFHLEdBQUc7b0JBQ04zVSxHQUFHMEosVUFBVTJvQixRQUFRM0UsTUFBTSxDQUFDL1ksS0FBSyxFQUFFO29CQUNuQ2xMLEdBQUdFLFVBQVUyb0IsUUFBUTVFLE1BQU0sQ0FBQy9ZLEtBQUssSUFBSSxFQUFFO2dCQUN6QztZQUNGO1lBQ0EsSUFBSTFtQixHQUNGazNCLElBQ0FDLElBQ0E0QyxJQUNBdEQsTUFBTXp2QixFQUFFdkosTUFBTTtZQUNoQnk1QixLQUFLbHdCLENBQUMsQ0FBQ3l2QixNQUFNLEVBQUU7WUFDZixpQkFBaUI7WUFDakIsSUFBS3oyQixJQUFJLEdBQUdBLElBQUl5MkIsS0FBS3oyQixJQUFLO2dCQUN4Qm0zQixLQUFLbndCLENBQUMsQ0FBQ2hILElBQUl5MkIsSUFBSTtnQkFDZnNELEtBQUsveUIsQ0FBQyxDQUFDLENBQUNoSCxJQUFJLEtBQUt5MkIsSUFBSTtnQkFDckJtc0YsRUFBRSxDQUFDMXhELE1BQU0sQ0FBQ2x4RCxFQUFFLEdBQUc4cEgsZUFBZTV5RixJQUFJQyxJQUFJNEMsSUFBSXNCO2dCQUMxQ25FLEtBQUtDO2dCQUNMQSxLQUFLNEM7WUFDUDtZQUNBLE9BQU82b0YsRUFBRSxDQUFDMXhELE1BQU07UUFDbEI7UUFDQXN1RCxNQUFNLFNBQVNBLEtBQUszckMsT0FBTyxFQUFFcDRELE9BQU8sRUFBRUMsT0FBTyxFQUFFaWYsS0FBSyxFQUFFQyxNQUFNLEVBQUVTLFlBQVksRUFBRXVuRixFQUFFO1lBQzVFLElBQUksQ0FBQ3IzQyxRQUFRLENBQUMrbEUsYUFBYSxDQUFDLGlCQUFpQno5RCxTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQyxRQUFRLElBQUksQ0FBQzZFLE1BQU0sRUFBRSxJQUFJLENBQUNpeUcsa0JBQWtCLENBQUNqMkgsU0FBU0MsU0FBU2lmLE9BQU9DLFFBQVFTLGNBQWN1bkYsSUFBSTtRQUNqTDtRQUNBdVEsZUFBZSxTQUFTQSxjQUFjajRGLEtBQUssRUFBRUMsS0FBSyxFQUFFUixLQUFLLEVBQUVDLE1BQU0sRUFBRTdvQixDQUFDLEVBQUV5SixDQUFDLEVBQUVpZCxPQUFPLEVBQUU0QyxZQUFZLEVBQUV1bkYsRUFBRTtZQUNoRyxPQUFPLzlFLDBCQUEwQjl5QixHQUFHeUosR0FBRyxJQUFJLENBQUNpa0IsTUFBTSxFQUFFdkUsT0FBT0MsT0FBT1IsT0FBT0MsUUFBUW5DLFNBQVMsSUFBSSxDQUFDaTVHLGtCQUFrQixDQUFDeDJHLE9BQU9DLE9BQU9SLE9BQU9DLFFBQVFTLGNBQWN1bkYsSUFBSTtRQUNuSztRQUNBRSxZQUFZLFNBQVNBLFdBQVcvd0csQ0FBQyxFQUFFeUosQ0FBQyxFQUFFaWQsT0FBTyxFQUFFa0MsS0FBSyxFQUFFQyxNQUFNLEVBQUVuZixPQUFPLEVBQUVDLE9BQU8sRUFBRTJmLFlBQVksRUFBRXVuRixFQUFFO1lBQzlGLE9BQU94aUYsd0JBQXdCcnVCLEdBQUd5SixHQUFHLElBQUksQ0FBQ2lrQixNQUFNLEVBQUVoa0IsU0FBU0MsU0FBU2lmLE9BQU9DLFFBQVEsSUFBSSxDQUFDODJHLGtCQUFrQixDQUFDajJILFNBQVNDLFNBQVNpZixPQUFPQyxRQUFRUyxjQUFjdW5GLElBQUk7UUFDaEs7SUFDRjtBQUNGO0FBQ0F3dUIsTUFBTU8sc0JBQXNCLEdBQUc7SUFDN0IsT0FBTyxJQUFJLENBQUNubUUsVUFBVSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQ0EsVUFBVSxDQUFDLGlCQUFpQixHQUFHO1FBQzlFRCxVQUFVLElBQUk7UUFDZHpxRSxNQUFNO1FBQ04yK0IsUUFBUTRGLGtDQUFrQyxHQUFHO1FBQzdDbTZFLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUVwNEQsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRVMsWUFBWTtZQUN4RSxJQUFJLENBQUNrd0MsUUFBUSxDQUFDK2xFLGFBQWEsQ0FBQyxJQUFJLENBQUN4d0ksSUFBSSxFQUFFK3lFLFNBQVNwNEQsU0FBU0MsU0FBU2lmLE9BQU9DLFFBQVEsSUFBSSxDQUFDNkUsTUFBTSxFQUFFcEU7UUFDaEc7UUFDQTgzRixlQUFlLFNBQVNBLGNBQWNqNEYsS0FBSyxFQUFFQyxLQUFLLEVBQUVSLEtBQUssRUFBRUMsTUFBTSxFQUFFN29CLENBQUMsRUFBRXlKLENBQUMsRUFBRWlkLE9BQU8sRUFBRTRDLFlBQVk7WUFDNUYsT0FBT0osNEJBQTRCbHBCLEdBQUd5SixHQUFHMGYsT0FBT0MsT0FBT1IsT0FBT0MsUUFBUW5DLFNBQVM0QztRQUNqRjtRQUNBeW5GLFlBQVksU0FBU0EsV0FBVy93RyxDQUFDLEVBQUV5SixDQUFDLEVBQUVpZCxPQUFPLEVBQUVrQyxLQUFLLEVBQUVDLE1BQU0sRUFBRW5mLE9BQU8sRUFBRUMsT0FBTyxFQUFFMmYsWUFBWTtZQUMxRixJQUFJRSxZQUFZWixRQUFRO1lBQ3hCLElBQUlhLGFBQWFaLFNBQVM7WUFDMUJTLGVBQWVBLGlCQUFpQixTQUFTQyx3QkFBd0JYLE9BQU9DLFVBQVVTO1lBQ2xGQSxlQUFlOTRCLEtBQUsrVSxHQUFHLENBQUNpa0IsV0FBV0MsWUFBWUg7WUFDL0MsSUFBSXUyRyxPQUFPdjJHLGVBQWU7WUFFMUIsYUFBYTtZQUNiLElBQUlzRSxtQkFBbUI1dEIsR0FBR3lKLEdBQUcsSUFBSSxDQUFDaWtCLE1BQU0sRUFBRWhrQixTQUFTQyxTQUFTaWYsT0FBT0MsU0FBU2czRyxNQUFNO2dCQUFDO2dCQUFHLENBQUM7YUFBRSxFQUFFbjVHLFVBQVU7Z0JBQ25HLE9BQU87WUFDVDtZQUVBLGFBQWE7WUFDYixJQUFJa0gsbUJBQW1CNXRCLEdBQUd5SixHQUFHLElBQUksQ0FBQ2lrQixNQUFNLEVBQUVoa0IsU0FBU0MsU0FBU2lmLFFBQVFpM0csTUFBTWgzRyxRQUFRO2dCQUFDO2dCQUFHLENBQUM7YUFBRSxFQUFFbkMsVUFBVTtnQkFDbkcsT0FBTztZQUNUO1lBRUEsZ0NBQWdDO1lBQ2hDLElBQUkrSixlQUFlendCLEdBQUd5SixHQUFHbzJILE1BQU1BLE1BQU1uMkgsVUFBVThmLFlBQVlGLGNBQWMzZixVQUFVOGYsYUFBYUgsY0FBYzVDLFVBQVU7Z0JBQ3RILE9BQU87WUFDVDtZQUVBLGlDQUFpQztZQUNqQyxJQUFJK0osZUFBZXp3QixHQUFHeUosR0FBR28ySCxNQUFNQSxNQUFNbjJILFVBQVU4ZixZQUFZRixjQUFjM2YsVUFBVThmLGFBQWFILGNBQWM1QyxVQUFVO2dCQUN0SCxPQUFPO1lBQ1Q7WUFFQSxvQ0FBb0M7WUFDcEMsSUFBSStKLGVBQWV6d0IsR0FBR3lKLEdBQUdvMkgsTUFBTUEsTUFBTW4ySCxVQUFVOGYsWUFBWUYsY0FBYzNmLFVBQVU4ZixhQUFhSCxjQUFjNUMsVUFBVTtnQkFDdEgsT0FBTztZQUNUO1lBRUEsbUNBQW1DO1lBQ25DLElBQUkrSixlQUFlendCLEdBQUd5SixHQUFHbzJILE1BQU1BLE1BQU1uMkgsVUFBVThmLFlBQVlGLGNBQWMzZixVQUFVOGYsYUFBYUgsY0FBYzVDLFVBQVU7Z0JBQ3RILE9BQU87WUFDVDtZQUNBLE9BQU87UUFDVDtJQUNGO0FBQ0Y7QUFDQTI0RyxNQUFNUyxvQkFBb0IsR0FBRztJQUMzQixPQUFPLElBQUksQ0FBQ3JtRSxVQUFVLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUMsZUFBZSxHQUFHO1FBQzFFRCxVQUFVLElBQUk7UUFDZHpxRSxNQUFNO1FBQ05neEksY0FBY3pyRztRQUNkNUcsUUFBUTRGLGtDQUFrQyxHQUFHO1FBQzdDbTZFLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUVwNEQsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRVMsWUFBWTtZQUN4RSxJQUFJLENBQUNrd0MsUUFBUSxDQUFDK2xFLGFBQWEsQ0FBQyxJQUFJLENBQUN4d0ksSUFBSSxFQUFFK3lFLFNBQVNwNEQsU0FBU0MsU0FBU2lmLE9BQU9DLFFBQVEsTUFBTVM7UUFDekY7UUFDQTAyRyx3QkFBd0IsU0FBU0EsdUJBQXVCcDNHLEtBQUssRUFBRUMsTUFBTSxFQUFFbmYsT0FBTyxFQUFFQyxPQUFPLEVBQUUyZixZQUFZO1lBQ25HLElBQUkyMkcsS0FBSzMyRyxpQkFBaUIsU0FBUyxJQUFJLENBQUN5MkcsWUFBWSxHQUFHejJHO1lBQ3ZELElBQUlzbkYsS0FBSy9uRixTQUFTO1lBQ2xCLElBQUk4bkYsS0FBSy9uRixRQUFRO1lBQ2pCLElBQUlzM0csU0FBU3gySCxVQUFVaW5HO1lBQ3ZCLElBQUl3dkIsT0FBT3oySCxVQUFVaW5HO1lBQ3JCLElBQUl5dkIsU0FBU3oySCxVQUFVaW5HO1lBQ3ZCLElBQUl5dkIsT0FBTzEySCxVQUFVaW5HO1lBRXJCLHlFQUF5RTtZQUN6RSxPQUFPO2dCQUNMMHZCLFNBQVM7b0JBQUNKO29CQUFRRSxTQUFTSDtvQkFBSUMsU0FBU0Q7b0JBQUlHO29CQUFRRixTQUFTRDtvQkFBSUcsU0FBU0g7aUJBQUc7Z0JBQzdFTSxVQUFVO29CQUFDSixPQUFPRjtvQkFBSUc7b0JBQVFEO29CQUFNQyxTQUFTSDtvQkFBSUUsT0FBT0Y7b0JBQUlHLFNBQVNIO2lCQUFHO2dCQUN4RU8sYUFBYTtvQkFBQ0w7b0JBQU1FLE9BQU9KO29CQUFJRSxPQUFPRjtvQkFBSUk7b0JBQU1GLE9BQU9GO29CQUFJSSxPQUFPSjtpQkFBRztnQkFDckVRLFlBQVk7b0JBQUNQLFNBQVNEO29CQUFJSTtvQkFBTUg7b0JBQVFHLE9BQU9KO29CQUFJQyxTQUFTRDtvQkFBSUksT0FBT0o7aUJBQUc7WUFDNUU7UUFDRjtRQUNBN2UsZUFBZSxTQUFTQSxjQUFjajRGLEtBQUssRUFBRUMsS0FBSyxFQUFFUixLQUFLLEVBQUVDLE1BQU0sRUFBRTdvQixDQUFDLEVBQUV5SixDQUFDLEVBQUVpZCxPQUFPLEVBQUU0QyxZQUFZO1lBQzVGLElBQUlvM0csT0FBTyxJQUFJLENBQUNWLHNCQUFzQixDQUFDcDNHLFFBQVEsSUFBSWxDLFNBQVNtQyxTQUFTLElBQUluQyxTQUFTeUMsT0FBT0MsT0FBT0U7WUFDaEcsSUFBSXhCLE1BQU0sRUFBRSxDQUFDclIsTUFBTSxDQUFDamtCLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0JBQUNrdUksS0FBS0osT0FBTyxDQUFDcHpILE1BQU0sQ0FBQyxHQUFHO2dCQUFJd3pILEtBQUtILFFBQVEsQ0FBQ3J6SCxNQUFNLENBQUMsR0FBRztnQkFBSXd6SCxLQUFLRixXQUFXLENBQUN0ekgsTUFBTSxDQUFDLEdBQUc7Z0JBQUl3ekgsS0FBS0QsVUFBVSxDQUFDdnpILE1BQU0sQ0FBQyxHQUFHO2FBQUc7WUFDbEosT0FBT3FsQixxQkFBcUJ2eUIsR0FBR3lKLEdBQUdxZSxLQUFLcUIsT0FBT0M7UUFDaEQ7UUFDQTJuRixZQUFZLFNBQVNBLFdBQVcvd0csQ0FBQyxFQUFFeUosQ0FBQyxFQUFFaWQsT0FBTyxFQUFFa0MsS0FBSyxFQUFFQyxNQUFNLEVBQUVuZixPQUFPLEVBQUVDLE9BQU8sRUFBRTJmLFlBQVk7WUFDMUYsSUFBSTIyRyxLQUFLMzJHLGlCQUFpQixTQUFTLElBQUksQ0FBQ3kyRyxZQUFZLEdBQUd6Mkc7WUFDdkQsYUFBYTtZQUNiLElBQUlzRSxtQkFBbUI1dEIsR0FBR3lKLEdBQUcsSUFBSSxDQUFDaWtCLE1BQU0sRUFBRWhrQixTQUFTQyxTQUFTaWYsT0FBT0MsU0FBUyxJQUFJbzNHLElBQUk7Z0JBQUM7Z0JBQUcsQ0FBQzthQUFFLEVBQUV2NUcsVUFBVTtnQkFDckcsT0FBTztZQUNUO1lBRUEsYUFBYTtZQUNiLElBQUlrSCxtQkFBbUI1dEIsR0FBR3lKLEdBQUcsSUFBSSxDQUFDaWtCLE1BQU0sRUFBRWhrQixTQUFTQyxTQUFTaWYsUUFBUSxJQUFJcTNHLElBQUlwM0csUUFBUTtnQkFBQztnQkFBRyxDQUFDO2FBQUUsRUFBRW5DLFVBQVU7Z0JBQ3JHLE9BQU87WUFDVDtZQUNBLElBQUlpNkcsaUJBQWlCLElBQUksQ0FBQ1gsc0JBQXNCLENBQUNwM0csT0FBT0MsUUFBUW5mLFNBQVNDO1lBQ3pFLE9BQU84akIseUJBQXlCenRCLEdBQUd5SixHQUFHazNILGVBQWVMLE9BQU8sS0FBSzd5Ryx5QkFBeUJ6dEIsR0FBR3lKLEdBQUdrM0gsZUFBZUosUUFBUSxLQUFLOXlHLHlCQUF5Qnp0QixHQUFHeUosR0FBR2szSCxlQUFlSCxXQUFXLEtBQUsveUcseUJBQXlCenRCLEdBQUd5SixHQUFHazNILGVBQWVGLFVBQVU7UUFDcFA7SUFDRjtBQUNGO0FBQ0FwQixNQUFNdUIsY0FBYyxHQUFHO0lBQ3JCLE9BQU8sSUFBSSxDQUFDbm5FLFVBQVUsQ0FBQyxTQUFTLEdBQUc7UUFDakNELFVBQVUsSUFBSTtRQUNkenFFLE1BQU07UUFDTjIrQixRQUFRNEYsa0NBQWtDLEdBQUc7UUFDN0NtNkUsTUFBTSxTQUFTQSxLQUFLM3JDLE9BQU8sRUFBRXA0RCxPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTSxFQUFFUyxZQUFZO1lBQ3hFLElBQUksQ0FBQ2t3QyxRQUFRLENBQUMrbEUsYUFBYSxDQUFDLElBQUksQ0FBQ3h3SSxJQUFJLEVBQUUreUUsU0FBU3A0RCxTQUFTQyxTQUFTaWYsT0FBT0M7UUFDM0U7UUFDQXU0RixlQUFlLFNBQVNBLGNBQWNqNEYsS0FBSyxFQUFFQyxLQUFLLEVBQUVSLEtBQUssRUFBRUMsTUFBTSxFQUFFN29CLENBQUMsRUFBRXlKLENBQUMsRUFBRWlkLE9BQU8sRUFBRTRDLFlBQVk7WUFDNUYsNERBQTREO1lBRTVELElBQUk4K0YsS0FBSztZQUNULElBQUkxM0YsS0FBSztZQUNULElBQUlDLEtBQUs7WUFDVCxJQUFJa3dHLE9BQU8sSUFBSSxDQUFDQyx1QkFBdUIsQ0FBQ2w0RyxRQUFRLElBQUlsQyxTQUFTbUMsU0FBUyxJQUFJbkMsU0FBU3lDLE9BQU9DO1lBQzFGLElBQUkyM0csNEJBQTRCLFNBQVNBLDBCQUEwQmo1RyxHQUFHO2dCQUNwRSxrREFBa0Q7Z0JBQ2xELElBQUlrNUcsS0FBS3I3RyxZQUFZO29CQUNuQjNsQixHQUFHOG5CLEdBQUcsQ0FBQyxFQUFFO29CQUNUcmUsR0FBR3FlLEdBQUcsQ0FBQyxFQUFFO2dCQUNYLEdBQUc7b0JBQ0Q5bkIsR0FBRzhuQixHQUFHLENBQUMsRUFBRTtvQkFDVHJlLEdBQUdxZSxHQUFHLENBQUMsRUFBRTtnQkFDWCxHQUFHO29CQUNEOW5CLEdBQUc4bkIsR0FBRyxDQUFDLEVBQUU7b0JBQ1RyZSxHQUFHcWUsR0FBRyxDQUFDLEVBQUU7Z0JBQ1gsR0FBR3NnRztnQkFDSCxJQUFJNlksS0FBS3Q3RyxZQUFZO29CQUNuQjNsQixHQUFHOG5CLEdBQUcsQ0FBQyxFQUFFO29CQUNUcmUsR0FBR3FlLEdBQUcsQ0FBQyxFQUFFO2dCQUNYLEdBQUc7b0JBQ0Q5bkIsR0FBRzhuQixHQUFHLENBQUMsRUFBRTtvQkFDVHJlLEdBQUdxZSxHQUFHLENBQUMsRUFBRTtnQkFDWCxHQUFHO29CQUNEOW5CLEdBQUc4bkIsR0FBRyxDQUFDLEVBQUU7b0JBQ1RyZSxHQUFHcWUsR0FBRyxDQUFDLEVBQUU7Z0JBQ1gsR0FBRzRJO2dCQUNILElBQUl3d0csS0FBS3Y3RyxZQUFZO29CQUNuQjNsQixHQUFHOG5CLEdBQUcsQ0FBQyxFQUFFO29CQUNUcmUsR0FBR3FlLEdBQUcsQ0FBQyxFQUFFO2dCQUNYLEdBQUc7b0JBQ0Q5bkIsR0FBRzhuQixHQUFHLENBQUMsRUFBRTtvQkFDVHJlLEdBQUdxZSxHQUFHLENBQUMsRUFBRTtnQkFDWCxHQUFHO29CQUNEOW5CLEdBQUc4bkIsR0FBRyxDQUFDLEVBQUU7b0JBQ1RyZSxHQUFHcWUsR0FBRyxDQUFDLEVBQUU7Z0JBQ1gsR0FBRzZJO2dCQUNILE9BQU87b0JBQUM3SSxHQUFHLENBQUMsRUFBRTtvQkFBRUEsR0FBRyxDQUFDLEVBQUU7b0JBQUVrNUcsR0FBR2hoSSxDQUFDO29CQUFFZ2hJLEdBQUd2M0gsQ0FBQztvQkFBRXczSCxHQUFHamhJLENBQUM7b0JBQUVpaEksR0FBR3gzSCxDQUFDO29CQUFFeTNILEdBQUdsaEksQ0FBQztvQkFBRWtoSSxHQUFHejNILENBQUM7b0JBQUVxZSxHQUFHLENBQUMsRUFBRTtvQkFBRUEsR0FBRyxDQUFDLEVBQUU7aUJBQUM7WUFDN0U7WUFDQSxJQUFJQSxNQUFNLEVBQUUsQ0FBQ3JSLE1BQU0sQ0FBQ3NxSCwwQkFBMEJGLEtBQUtQLE9BQU8sR0FBR1MsMEJBQTBCRixLQUFLTixRQUFRLEdBQUdRLDBCQUEwQkYsS0FBS0wsV0FBVyxHQUFHTywwQkFBMEJGLEtBQUtKLFVBQVU7WUFDN0wsT0FBT2x1RyxxQkFBcUJ2eUIsR0FBR3lKLEdBQUdxZSxLQUFLcUIsT0FBT0M7UUFDaEQ7UUFDQTAzRyx5QkFBeUIsU0FBU0Esd0JBQXdCbDRHLEtBQUssRUFBRUMsTUFBTSxFQUFFbmYsT0FBTyxFQUFFQyxPQUFPO1lBQ3ZGLElBQUlpbkcsS0FBSy9uRixTQUFTO1lBQ2xCLElBQUk4bkYsS0FBSy9uRixRQUFRO1lBQ2pCLElBQUlzM0csU0FBU3gySCxVQUFVaW5HO1lBQ3ZCLElBQUl3dkIsT0FBT3oySCxVQUFVaW5HO1lBQ3JCLElBQUl5dkIsU0FBU3oySCxVQUFVaW5HO1lBQ3ZCLElBQUl5dkIsT0FBTzEySCxVQUFVaW5HO1lBQ3JCLElBQUl1d0IsaUJBQWlCM3NHLHdCQUF3QjVMLE9BQU9DO1lBQ3BELElBQUl1NEcsVUFBVUQsZUFBZTFzRyxZQUFZO1lBQ3pDLElBQUk0c0csVUFBVUYsZUFBZXpzRyxXQUFXO1lBQ3hDLElBQUk0c0csZ0JBQWdCSCxlQUFleHNHLGVBQWUsR0FBRy9MO1lBRXJELHdFQUF3RTtZQUN4RSxJQUFJZCxNQUFNO2dCQUNSdzRHLFNBQVM7b0JBQUNKO29CQUFRRSxTQUFTZ0I7b0JBQVNsQixTQUFTb0I7b0JBQWVsQjtvQkFBUUYsU0FBU21CO29CQUFTakI7aUJBQU87Z0JBQzdGRyxVQUFVO29CQUFDSixPQUFPa0I7b0JBQVNqQjtvQkFBUUQsT0FBT21CO29CQUFlbEI7b0JBQVFEO29CQUFNQyxTQUFTZ0I7aUJBQVE7Z0JBQ3hGWixhQUFhO29CQUFDTDtvQkFBTUUsT0FBT2U7b0JBQVNqQixPQUFPbUI7b0JBQWVqQjtvQkFBTUYsT0FBT2tCO29CQUFTaEI7aUJBQUs7Z0JBQ3JGSSxZQUFZO29CQUFDUCxTQUFTbUI7b0JBQVNoQjtvQkFBTUgsU0FBU29CO29CQUFlakI7b0JBQU1IO29CQUFRRyxPQUFPZTtpQkFBUTtZQUM1RjtZQUNBdDVHLElBQUl3NEcsT0FBTyxDQUFDaUIsS0FBSyxHQUFHO1lBQ3BCejVHLElBQUl5NEcsUUFBUSxDQUFDZ0IsS0FBSyxHQUFHO1lBQ3JCejVHLElBQUkyNEcsVUFBVSxDQUFDZSxRQUFRLEdBQUc7WUFDMUIxNUcsSUFBSTA0RyxXQUFXLENBQUNnQixRQUFRLEdBQUc7WUFDM0IsT0FBTzE1RztRQUNUO1FBQ0FpcEYsWUFBWSxTQUFTQSxXQUFXL3dHLENBQUMsRUFBRXlKLENBQUMsRUFBRWlkLE9BQU8sRUFBRWtDLEtBQUssRUFBRUMsTUFBTSxFQUFFbmYsT0FBTyxFQUFFQyxPQUFPLEVBQUUyZixZQUFZO1lBQzFGLElBQUk2M0csaUJBQWlCM3NHLHdCQUF3QjVMLE9BQU9DO1lBQ3BELElBQUl1NEcsVUFBVUQsZUFBZTFzRyxZQUFZO1lBQ3pDLElBQUk0c0csVUFBVUYsZUFBZXpzRyxXQUFXO1lBRXhDLGFBQWE7WUFDYixJQUFJOUcsbUJBQW1CNXRCLEdBQUd5SixHQUFHLElBQUksQ0FBQ2lrQixNQUFNLEVBQUVoa0IsU0FBU0MsU0FBU2lmLE9BQU9DLFNBQVMsSUFBSXU0RyxTQUFTO2dCQUFDO2dCQUFHLENBQUM7YUFBRSxFQUFFMTZHLFVBQVU7Z0JBQzFHLE9BQU87WUFDVDtZQUVBLGFBQWE7WUFDYixJQUFJa0gsbUJBQW1CNXRCLEdBQUd5SixHQUFHLElBQUksQ0FBQ2lrQixNQUFNLEVBQUVoa0IsU0FBU0MsU0FBU2lmLFFBQVEsSUFBSXk0RyxTQUFTeDRHLFFBQVE7Z0JBQUM7Z0JBQUcsQ0FBQzthQUFFLEVBQUVuQyxVQUFVO2dCQUMxRyxPQUFPO1lBQ1Q7WUFDQSxJQUFJKzZHLGlCQUFpQixJQUFJLENBQUNYLHVCQUF1QixDQUFDbDRHLE9BQU9DLFFBQVFuZixTQUFTQztZQUMxRSxJQUFJKzNILFlBQVksU0FBU0EsVUFBVTFoSSxDQUFDLEVBQUV5SixDQUFDLEVBQUVrNEgsUUFBUTtnQkFDL0MsSUFBSUMsS0FBS0QsUUFBUSxDQUFDLEVBQUU7Z0JBQ3BCLElBQUlyd0ksS0FBS3F3SSxRQUFRLENBQUMsRUFBRTtnQkFDcEIsSUFBSXB3SSxLQUFLb3dJLFFBQVEsQ0FBQyxFQUFFO2dCQUNwQixJQUFJbHpCLEtBQUtrekIsUUFBUSxDQUFDLEVBQUU7Z0JBQ3BCLDBCQUEwQjtnQkFDMUIsSUFBSWx3SSxLQUFLa3dJLFFBQVEsQ0FBQyxFQUFFO2dCQUNwQixJQUFJRSxPQUFPcnhJLEtBQUsrVSxHQUFHLENBQUNxOEgsSUFBSXJ3STtnQkFDeEIsSUFBSXV3SSxPQUFPdHhJLEtBQUs2VSxHQUFHLENBQUN1OEgsSUFBSXJ3STtnQkFDeEIsSUFBSXd3SSxPQUFPdnhJLEtBQUsrVSxHQUFHLENBQUNrcEcsSUFBSWg5RztnQkFDeEIsSUFBSXV3SSxPQUFPeHhJLEtBQUs2VSxHQUFHLENBQUNvcEcsSUFBSWg5RztnQkFDeEIsSUFBSW93SSxRQUFRN2hJLEtBQUtBLEtBQUs4aEksUUFBUUMsUUFBUXQ0SCxLQUFLQSxLQUFLdTRILE1BQU07b0JBQ3BELElBQUlDLFFBQVExdEcscUJBQXFCcXRHLElBQUl0d0ksSUFBSUM7b0JBQ3pDLElBQUlxaEIsUUFBUXFaLGVBQWVnMkcsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRWppSTtvQkFDekQsSUFBSWtpSSxhQUFhdHZILE1BQU1qRSxNQUFNLENBQUMsU0FBVW5qQixDQUFDO3dCQUN2QyxPQUFPLEtBQUtBLEtBQUtBLEtBQUs7b0JBQ3hCO29CQUNBLElBQUkwMkksV0FBV3gySSxNQUFNLEdBQUcsR0FBRzt3QkFDekIsT0FBT3cySSxVQUFVLENBQUMsRUFBRTtvQkFDdEI7Z0JBQ0Y7Z0JBQ0EsT0FBTztZQUNUO1lBQ0EsSUFBSUMsZUFBZTExSSxPQUFPNEgsSUFBSSxDQUFDb3RJO1lBQy9CLElBQUssSUFBSXh6SSxJQUFJLEdBQUdBLElBQUlrMEksYUFBYXoySSxNQUFNLEVBQUV1QyxJQUFLO2dCQUM1QyxJQUFJdWdDLFNBQVMyekcsWUFBWSxDQUFDbDBJLEVBQUU7Z0JBQzVCLElBQUltMEksWUFBWVgsY0FBYyxDQUFDanpHLE9BQU87Z0JBQ3RDLElBQUlwaUMsSUFBSXMxSSxVQUFVMWhJLEdBQUd5SixHQUFHMjRIO2dCQUN4QixJQUFJaDJJLEtBQUssTUFBTTtvQkFDYjtnQkFDRjtnQkFDQSxJQUFJcWlILEtBQUsyekIsU0FBUyxDQUFDLEVBQUU7Z0JBQ3JCLElBQUk1d0ksS0FBSzR3SSxTQUFTLENBQUMsRUFBRTtnQkFDckIsSUFBSTN3SSxLQUFLMndJLFNBQVMsQ0FBQyxFQUFFO2dCQUNyQixJQUFJQyxPQUFPNThHLFVBQVVncEYsSUFBSWo5RyxJQUFJQyxJQUFJckY7Z0JBQ2pDLElBQUlnMkksVUFBVWIsS0FBSyxJQUFJYyxRQUFRNTRILEdBQUc7b0JBQ2hDLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSTI0SCxVQUFVWixRQUFRLElBQUkvM0gsS0FBSzQ0SCxNQUFNO29CQUNuQyxPQUFPO2dCQUNUO1lBQ0Y7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBQ0FoRCxNQUFNaUQsNEJBQTRCLEdBQUc7SUFDbkMsT0FBTyxJQUFJLENBQUM3b0UsVUFBVSxDQUFDLHlCQUF5QixHQUFHLElBQUksQ0FBQ0EsVUFBVSxDQUFDLHVCQUF1QixHQUFHO1FBQzNGRCxVQUFVLElBQUk7UUFDZHpxRSxNQUFNO1FBQ04yK0IsUUFBUTRGLGtDQUFrQyxHQUFHO1FBQzdDbTZFLE1BQU0sU0FBU0EsS0FBSzNyQyxPQUFPLEVBQUVwNEQsT0FBTyxFQUFFQyxPQUFPLEVBQUVpZixLQUFLLEVBQUVDLE1BQU0sRUFBRVMsWUFBWTtZQUN4RSxJQUFJLENBQUNrd0MsUUFBUSxDQUFDK2xFLGFBQWEsQ0FBQyxJQUFJLENBQUN4d0ksSUFBSSxFQUFFK3lFLFNBQVNwNEQsU0FBU0MsU0FBU2lmLE9BQU9DLFFBQVEsSUFBSSxDQUFDNkUsTUFBTSxFQUFFcEU7UUFDaEc7UUFDQTgzRixlQUFlLFNBQVNBLGNBQWNqNEYsS0FBSyxFQUFFQyxLQUFLLEVBQUVSLEtBQUssRUFBRUMsTUFBTSxFQUFFN29CLENBQUMsRUFBRXlKLENBQUMsRUFBRWlkLE9BQU8sRUFBRTRDLFlBQVk7WUFDNUYsSUFBSU8sWUFBWVYsUUFBU1AsQ0FBQUEsUUFBUSxJQUFJbEMsT0FBTTtZQUMzQyxJQUFJb0QsWUFBWVYsUUFBU1AsQ0FBQUEsU0FBUyxJQUFJbkMsT0FBTTtZQUM1QyxJQUFJc0QsVUFBVUY7WUFDZCxJQUFJQyxVQUFVWixRQUFTUCxDQUFBQSxRQUFRLElBQUlsQyxPQUFNO1lBQ3pDLElBQUk2N0csbUJBQW1CdDRHLHFCQUFxQmpxQixHQUFHeUosR0FBRzBmLE9BQU9DLE9BQU9TLFdBQVdDLFdBQVdDLFNBQVNDLFNBQVM7WUFDeEcsSUFBSXU0RyxpQkFBaUI3MkksTUFBTSxHQUFHLEdBQUc7Z0JBQy9CLE9BQU82Mkk7WUFDVDtZQUNBLE9BQU9yNUcsNEJBQTRCbHBCLEdBQUd5SixHQUFHMGYsT0FBT0MsT0FBT1IsT0FBT0MsUUFBUW5DLFNBQVM0QztRQUNqRjtRQUNBeW5GLFlBQVksU0FBU0EsV0FBVy93RyxDQUFDLEVBQUV5SixDQUFDLEVBQUVpZCxPQUFPLEVBQUVrQyxLQUFLLEVBQUVDLE1BQU0sRUFBRW5mLE9BQU8sRUFBRUMsT0FBTyxFQUFFMmYsWUFBWTtZQUMxRkEsZUFBZUEsaUJBQWlCLFNBQVNDLHdCQUF3QlgsT0FBT0MsVUFBVVM7WUFDbEYsSUFBSXUyRyxPQUFPLElBQUl2Mkc7WUFFZixhQUFhO1lBQ2IsSUFBSXNFLG1CQUFtQjV0QixHQUFHeUosR0FBRyxJQUFJLENBQUNpa0IsTUFBTSxFQUFFaGtCLFNBQVNDLFNBQVNpZixPQUFPQyxTQUFTZzNHLE1BQU07Z0JBQUM7Z0JBQUcsQ0FBQzthQUFFLEVBQUVuNUcsVUFBVTtnQkFDbkcsT0FBTztZQUNUO1lBRUEsYUFBYTtZQUNiLElBQUlrSCxtQkFBbUI1dEIsR0FBR3lKLEdBQUcsSUFBSSxDQUFDaWtCLE1BQU0sRUFBRWhrQixTQUFTQyxTQUFTaWYsUUFBUWkzRyxNQUFNaDNHLFFBQVE7Z0JBQUM7Z0JBQUcsQ0FBQzthQUFFLEVBQUVuQyxVQUFVO2dCQUNuRyxPQUFPO1lBQ1Q7WUFFQSw2QkFBNkI7WUFDN0IsSUFBSXMwQyxhQUFhcHlDLFFBQVEsSUFBSSxJQUFJbEM7WUFDakMsSUFBSXUwQyxjQUFjcHlDLFNBQVMsSUFBSSxJQUFJbkM7WUFDbkMsSUFBSWdILFNBQVM7Z0JBQUNoa0IsVUFBVXN4RDtnQkFBWXJ4RCxVQUFVc3hEO2dCQUFhdnhELFVBQVVzeEQ7Z0JBQVlyeEQ7Z0JBQVNELFVBQVVzeEQ7Z0JBQVlyeEQ7Z0JBQVNELFVBQVVzeEQ7Z0JBQVlyeEQsVUFBVXN4RDthQUFZO1lBQ3JLLElBQUl4dEMseUJBQXlCenRCLEdBQUd5SixHQUFHaWtCLFNBQVM7Z0JBQzFDLE9BQU87WUFDVDtZQUVBLG9DQUFvQztZQUNwQyxJQUFJK0MsZUFBZXp3QixHQUFHeUosR0FBR28ySCxNQUFNQSxNQUFNbjJILFVBQVVrZixRQUFRLElBQUlVLGNBQWMzZixVQUFVa2YsU0FBUyxJQUFJUyxjQUFjNUMsVUFBVTtnQkFDdEgsT0FBTztZQUNUO1lBRUEsbUNBQW1DO1lBQ25DLElBQUkrSixlQUFlendCLEdBQUd5SixHQUFHbzJILE1BQU1BLE1BQU1uMkgsVUFBVWtmLFFBQVEsSUFBSVUsY0FBYzNmLFVBQVVrZixTQUFTLElBQUlTLGNBQWM1QyxVQUFVO2dCQUN0SCxPQUFPO1lBQ1Q7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EyNEcsTUFBTW1ELGtCQUFrQixHQUFHO0lBQ3pCLElBQUkvb0UsYUFBYSxJQUFJLENBQUNBLFVBQVUsR0FBRyxDQUFDO0lBQ3BDLElBQUlELFdBQVcsSUFBSTtJQUNuQixJQUFJLENBQUNpbUUsZUFBZTtJQUNwQixJQUFJLENBQUNILGVBQWUsQ0FBQyxZQUFZaHNHLGtDQUFrQyxHQUFHO0lBQ3RFLElBQUksQ0FBQ29zRyxvQkFBb0IsQ0FBQyxrQkFBa0Jwc0csa0NBQWtDLEdBQUc7SUFDakYsSUFBSSxDQUFDZ3NHLGVBQWUsQ0FBQyxhQUFhaHNHLGtDQUFrQyxHQUFHO0lBQ3ZFbW1DLFVBQVUsQ0FBQyxTQUFTLEdBQUdBLFVBQVUsQ0FBQyxZQUFZO0lBQzlDLElBQUksQ0FBQ21tRSxzQkFBc0I7SUFDM0IsSUFBSSxDQUFDRSxvQkFBb0I7SUFDekIsSUFBSSxDQUFDYyxjQUFjO0lBQ25CLElBQUksQ0FBQzBCLDRCQUE0QjtJQUNqQztRQUNFLElBQUlHLGdCQUFnQjtZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRyxDQUFDO1lBQUcsQ0FBQztZQUFHO1NBQUU7UUFDOUMsSUFBSSxDQUFDbkQsZUFBZSxDQUFDLFdBQVdtRDtRQUNoQyxJQUFJLENBQUMvQyxvQkFBb0IsQ0FBQyxpQkFBaUIrQztJQUM3QztJQUNBLElBQUksQ0FBQ25ELGVBQWUsQ0FBQyxZQUFZaHNHLGtDQUFrQyxHQUFHO0lBQ3RFLElBQUksQ0FBQ29zRyxvQkFBb0IsQ0FBQyxrQkFBa0Jwc0csa0NBQWtDLEdBQUc7SUFDakYsSUFBSSxDQUFDZ3NHLGVBQWUsQ0FBQyxXQUFXaHNHLGtDQUFrQyxHQUFHO0lBQ3JFLElBQUksQ0FBQ29zRyxvQkFBb0IsQ0FBQyxpQkFBaUJwc0csa0NBQWtDLEdBQUc7SUFDaEYsSUFBSSxDQUFDZ3NHLGVBQWUsQ0FBQyxZQUFZaHNHLGtDQUFrQyxHQUFHO0lBQ3RFLElBQUksQ0FBQ29zRyxvQkFBb0IsQ0FBQyxrQkFBa0Jwc0csa0NBQWtDLEdBQUc7SUFDakYsSUFBSSxDQUFDZ3NHLGVBQWUsQ0FBQyxXQUFXaHNHLGtDQUFrQyxHQUFHO0lBQ3JFLElBQUksQ0FBQ29zRyxvQkFBb0IsQ0FBQyxpQkFBaUJwc0csa0NBQWtDLEdBQUc7SUFDaEYsSUFBSW92RyxjQUFjLElBQUk3MkksTUFBTTtJQUM1QjtRQUNFLElBQUk4MkksY0FBY2x2Ryx1QkFBdUIsR0FBRztRQUM1QyxJQUFJbXZHLGNBQWNudkcsdUJBQXVCLEdBQUdqakMsS0FBS3NaLEVBQUUsR0FBRztRQUV0RCxxREFBcUQ7UUFDckQsSUFBSSs0SCxjQUFjLE1BQU8sS0FBSXJ5SSxLQUFLMndCLElBQUksQ0FBQyxFQUFDO1FBQ3hDMGhILGVBQWU7UUFDZixJQUFLLElBQUk1MEksSUFBSSxHQUFHQSxJQUFJMjBJLFlBQVlsM0ksTUFBTSxHQUFHLEdBQUd1QyxJQUFLO1lBQy9DMjBJLFdBQVcsQ0FBQzMwSSxJQUFJLEVBQUUsSUFBSTQwSTtZQUN0QkQsV0FBVyxDQUFDMzBJLElBQUksSUFBSSxFQUFFLElBQUk0MEk7UUFDNUI7UUFDQSxJQUFLLElBQUk1MEksSUFBSSxHQUFHQSxJQUFJLEtBQUssR0FBR0EsSUFBSztZQUMvQnkwSSxXQUFXLENBQUN6MEksSUFBSSxFQUFFLEdBQUcwMEksV0FBVyxDQUFDMTBJLElBQUksRUFBRTtZQUN2Q3kwSSxXQUFXLENBQUN6MEksSUFBSSxJQUFJLEVBQUUsR0FBRzAwSSxXQUFXLENBQUMxMEksSUFBSSxJQUFJLEVBQUU7WUFDL0N5MEksV0FBVyxDQUFDejBJLElBQUksSUFBSSxFQUFFLEdBQUcyMEksV0FBVyxDQUFDMzBJLElBQUksRUFBRTtZQUMzQ3kwSSxXQUFXLENBQUN6MEksSUFBSSxJQUFJLEVBQUUsR0FBRzIwSSxXQUFXLENBQUMzMEksSUFBSSxJQUFJLEVBQUU7UUFDakQ7SUFDRjtJQUNBeTBJLGNBQWNodkcsbUJBQW1CZ3ZHO0lBQ2pDLElBQUksQ0FBQ3BELGVBQWUsQ0FBQyxRQUFRb0Q7SUFDN0IsSUFBSSxDQUFDcEQsZUFBZSxDQUFDLE9BQU87UUFBQyxDQUFDO1FBQUcsQ0FBQztRQUFHO1FBQUcsQ0FBQztRQUFPO1FBQUcsQ0FBQztRQUFHO1FBQUc7S0FBRTtJQUM1RCxJQUFJLENBQUNBLGVBQWUsQ0FBQyxZQUFZO1FBQUMsQ0FBQztRQUFHLENBQUM7UUFBRztRQUFPLENBQUM7UUFBRztRQUFHO1FBQUcsQ0FBQztRQUFPO0tBQUU7SUFDckUsSUFBSSxDQUFDQSxlQUFlLENBQUMsa0JBQWtCO1FBQUMsQ0FBQztRQUFPLENBQUM7UUFBRztRQUFHLENBQUM7UUFBRztRQUFPO1FBQUcsQ0FBQztRQUFHO0tBQUU7SUFDM0UsSUFBSSxDQUFDN2xFLFVBQVUsQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM2bEUsZUFBZSxDQUFDLG1CQUFtQjtRQUFDLENBQUM7UUFBRyxDQUFDO1FBQU0sQ0FBQztRQUFNO1FBQUcsQ0FBQztRQUFHO1FBQU07UUFBRztRQUFNO1FBQU07UUFBRztRQUFHLENBQUM7S0FBSztJQUN2STtRQUNFLElBQUl3RCxZQUFZO1lBQUMsQ0FBQztZQUFHLENBQUM7WUFBRztZQUFNLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBTTtZQUFHLENBQUM7WUFBRztTQUFFO1FBQ3hELElBQUksQ0FBQ3hELGVBQWUsQ0FBQyxPQUFPd0Q7UUFDNUIsSUFBSSxDQUFDcEQsb0JBQW9CLENBQUMsYUFBYW9EO0lBQ3pDO0lBQ0FycEUsV0FBV20wRCxXQUFXLEdBQUcsU0FBVWxnRyxNQUFNO1FBQ3ZDLDhFQUE4RTtRQUU5RSxJQUFJOWdDLE1BQU04Z0MsT0FBT3g3QixJQUFJLENBQUM7UUFDdEIsSUFBSW5ELE9BQU8sYUFBYW5DO1FBQ3hCLElBQUkwc0U7UUFDSixJQUFJQSxRQUFRLElBQUksQ0FBQ3ZxRSxLQUFLLEVBQUU7WUFDdEIsbUJBQW1CO1lBQ25CLE9BQU91cUU7UUFDVDtRQUVBLDZCQUE2QjtRQUM3QixPQUFPRSxTQUFTOGxFLGVBQWUsQ0FBQ3Z3SSxNQUFNMitCO0lBQ3hDO0FBQ0Y7QUFFQSxJQUFJcTFHLFFBQVEsQ0FBQztBQUNiQSxNQUFNQyxZQUFZLEdBQUc7SUFDbkIsT0FBTyxJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJLENBQUNDLFdBQVc7QUFDaEQ7QUFDQUgsTUFBTXJNLE1BQU0sR0FBRyxTQUFVbDNILE9BQU87SUFDOUJBLFVBQVVBLFdBQVdnTjtJQUNyQixJQUFJaGhCLElBQUksSUFBSTtJQUNaLElBQUlBLEVBQUUyM0ksaUJBQWlCLEtBQUsxMEksV0FBVztRQUNyQ2pELEVBQUUyM0ksaUJBQWlCLEdBQUc7SUFDeEI7SUFDQSxJQUFJMzNJLEVBQUU0M0ksY0FBYyxLQUFLMzBJLFdBQVc7UUFDbENqRCxFQUFFNDNJLGNBQWMsR0FBRztJQUNyQjtJQUNBLElBQUk1M0ksRUFBRTYzSSxZQUFZLEtBQUs1MEksV0FBVztRQUNoQ2pELEVBQUU2M0ksWUFBWSxHQUFHO0lBQ25CO0lBQ0E3M0ksRUFBRTgzSSxjQUFjLEdBQUc7SUFDbkI5M0ksRUFBRSszSSxhQUFhLEdBQUcvakk7QUFDcEI7QUFDQXVqSSxNQUFNOWxELFlBQVksR0FBRyxTQUFVbHRGLEVBQUUsRUFBRXl6SSxRQUFRO0lBQ3pDLHVEQUF1RDtJQUN2RCxJQUFJLElBQUksQ0FBQ3BsRCxTQUFTLEVBQUU7UUFDbEI7SUFDRjtJQUNBLElBQUlvbEQsWUFBWSxNQUFNO1FBQ3BCNTNILE1BQU07SUFDUjtJQUNBLElBQUk2M0gsTUFBTSxJQUFJLENBQUNDLHFCQUFxQjtJQUNwQ0QsSUFBSXYxSSxJQUFJLENBQUM7UUFDUDZCLElBQUlBO1FBQ0p5ekksVUFBVUE7SUFDWjtJQUVBLDJDQUEyQztJQUMzQ0MsSUFBSW5zSCxJQUFJLENBQUMsU0FBVTdyQixDQUFDLEVBQUVzSSxDQUFDO1FBQ3JCLE9BQU9BLEVBQUV5dkksUUFBUSxHQUFHLzNJLEVBQUUrM0ksUUFBUTtJQUNoQztBQUNGO0FBQ0EsSUFBSUUsd0JBQXdCLFNBQVNBLHNCQUFzQmw0SSxDQUFDLEVBQUUyeEYsUUFBUSxFQUFFbkMsU0FBUztJQUMvRSxJQUFJeW9ELE1BQU1qNEksRUFBRWs0SSxxQkFBcUI7SUFDakMsSUFBSyxJQUFJejFJLElBQUksR0FBR0EsSUFBSXcxSSxJQUFJLzNJLE1BQU0sRUFBRXVDLElBQUs7UUFDbkN3MUksR0FBRyxDQUFDeDFJLEVBQUUsQ0FBQzhCLEVBQUUsQ0FBQ290RixVQUFVbkM7SUFDdEI7QUFDRjtBQUNBK25ELE1BQU1ZLGVBQWUsR0FBRztJQUN0QixJQUFJbjRJLElBQUksSUFBSTtJQUNaLElBQUl5akIsS0FBS3pqQixFQUFFeWpCLEVBQUU7SUFDYixJQUFJempCLEVBQUVvNEksaUJBQWlCLEVBQUU7UUFDdkI7SUFDRixPQUFPO1FBQ0xwNEksRUFBRW80SSxpQkFBaUIsR0FBRztJQUN4QjtJQUNBLElBQUlDLFlBQVksU0FBU0MsU0FBU0MsV0FBVztRQUMzQyxJQUFJdjRJLEVBQUU0eUYsU0FBUyxFQUFFO1lBQ2Y7UUFDRjtRQUNBLElBQUludkUsR0FBR3drRCxRQUFRO2FBQVcsSUFBSWpvRSxFQUFFODNJLGNBQWMsSUFBSSxDQUFDOTNJLEVBQUV3NEksU0FBUyxFQUFFO1lBQzlETixzQkFBc0JsNEksR0FBRyxNQUFNdTRJO1lBQy9CLElBQUkvb0QsWUFBWWx6RTtZQUNoQnRjLEVBQUV5NEksTUFBTSxDQUFDejRJLEVBQUUrM0ksYUFBYTtZQUN4QixJQUFJVyxVQUFVMTRJLEVBQUU2M0ksWUFBWSxHQUFHdjdIO1lBQy9CLElBQUl0YyxFQUFFMjNJLGlCQUFpQixLQUFLMTBJLFdBQVc7Z0JBQ3JDakQsRUFBRTIzSSxpQkFBaUIsR0FBR2UsVUFBVWxwRDtZQUNsQztZQUNBLElBQUl4dkYsRUFBRTAzSSxXQUFXLEtBQUt6MEksV0FBVztnQkFDL0JqRCxFQUFFMDNJLFdBQVcsR0FBRztZQUNsQjtZQUNBMTNJLEVBQUUwM0ksV0FBVztZQUNiLElBQUkxM0ksRUFBRXkzSSxlQUFlLEtBQUt4MEksV0FBVztnQkFDbkNqRCxFQUFFeTNJLGVBQWUsR0FBRztZQUN0QjtZQUNBLElBQUk5MkYsV0FBVyszRixVQUFVbHBEO1lBQ3pCeHZGLEVBQUV5M0ksZUFBZSxJQUFJOTJGO1lBQ3JCM2dELEVBQUU0M0ksY0FBYyxHQUFHajNGO1lBRW5CLDJGQUEyRjtZQUMzRjNnRCxFQUFFMjNJLGlCQUFpQixHQUFHMzNJLEVBQUUyM0ksaUJBQWlCLEdBQUcsSUFBSWgzRixXQUFXO1lBQzNEM2dELEVBQUU4M0ksY0FBYyxHQUFHO1FBQ3JCLE9BQU87WUFDTEksc0JBQXNCbDRJLEdBQUcsT0FBT3U0STtRQUNsQztRQUNBdjRJLEVBQUV3NEksU0FBUyxHQUFHO1FBQ2R0OEgsc0JBQXNCbThIO0lBQ3hCO0lBQ0FuOEgsc0JBQXNCbThIO0FBQ3hCO0FBRUEsSUFBSU0sZUFBZSxTQUFTQSxhQUFhM2tJLE9BQU87SUFDOUMsSUFBSSxDQUFDaS9CLElBQUksQ0FBQ2ovQjtBQUNaO0FBQ0EsSUFBSTRrSSxLQUFLRDtBQUNULElBQUlFLE1BQU1ELEdBQUd0M0ksU0FBUztBQUN0QnUzSSxJQUFJQyxlQUFlLEdBQUc7SUFBQztJQUFjO0lBQVU7SUFBWTtJQUFtQjtJQUFpQjtDQUFpQjtBQUNoSEQsSUFBSTVsRyxJQUFJLEdBQUcsU0FBVWovQixPQUFPO0lBQzFCLElBQUloVSxJQUFJLElBQUk7SUFDWkEsRUFBRWdVLE9BQU8sR0FBR0E7SUFDWmhVLEVBQUV5akIsRUFBRSxHQUFHelAsUUFBUXlQLEVBQUU7SUFDakIsSUFBSXMxSCxNQUFNLzRJLEVBQUVpMUYsU0FBUyxHQUFHamhGLFFBQVF5UCxFQUFFLENBQUN3eEUsU0FBUztJQUM1QyxJQUFJeUwsa0JBQWtCMWdHLEVBQUV5akIsRUFBRSxDQUFDL2YsTUFBTTtJQUVqQyw2Q0FBNkM7SUFDN0MsSUFBSWc5RixpQkFBaUI7UUFDbkIsSUFBSTk4RixZQUFXODhGLGdCQUFnQjk4RixRQUFRO1FBQ3ZDLElBQUl3ckcsT0FBT3hyRyxVQUFTd3JHLElBQUk7UUFDeEIsSUFBSTRwQyxlQUFlO1FBQ25CLElBQUl4aEYsWUFBWTtRQUNoQixJQUFJeWhGLDBCQUEwQnIxSSxVQUFTMnJDLGNBQWMsQ0FBQ3lwRyxpQkFBaUI7UUFDdkUsSUFBSUQsSUFBSXZoRixTQUFTLENBQUM1ckMsT0FBTyxDQUFDNHJDLGFBQWEsR0FBRztZQUN4Q3VoRixJQUFJdmhGLFNBQVMsR0FBRyxDQUFDdWhGLElBQUl2aEYsU0FBUyxJQUFJLEVBQUMsSUFBSyxNQUFNQTtRQUNoRDtRQUNBLElBQUksQ0FBQ3loRix5QkFBeUI7WUFDNUIsSUFBSXp6SSxhQUFhNUIsVUFBU3M5SCxhQUFhLENBQUM7WUFDeEMxN0gsV0FBVzBpQixFQUFFLEdBQUc4d0g7WUFDaEJ4ekksV0FBVzB6SSxXQUFXLEdBQUcsTUFBTTFoRixZQUFZO1lBQzNDNDNDLEtBQUsrcEMsWUFBWSxDQUFDM3pJLFlBQVk0cEcsS0FBSzFwRixRQUFRLENBQUMsRUFBRSxHQUFHLDJCQUEyQjtRQUM5RTtRQUNBLElBQUkwekgsZ0JBQWdCMTRDLGdCQUFnQkMsZ0JBQWdCLENBQUNvNEM7UUFDckQsSUFBSTkwSCxXQUFXbTFILGNBQWN4NEMsZ0JBQWdCLENBQUM7UUFDOUMsSUFBSTM4RSxhQUFhLFVBQVU7WUFDekJ4RSxLQUFLO1FBQ1A7SUFDRjtJQUNBemYsRUFBRWlwSSxTQUFTLEdBQUc7UUFBQ2htSTtRQUFXQTtRQUFXQTtRQUFXQTtRQUFXO0tBQUUsRUFBRSxtREFBbUQ7SUFFbEhqRCxFQUFFMjdILGNBQWMsR0FBRztRQUFDO1FBQU07UUFBTztRQUFLO1FBQUs7UUFBSztRQUFPO0tBQUs7SUFFNUQsd0JBQXdCO0lBQ3hCMzdILEVBQUV5cEksU0FBUyxHQUFHO1FBQ1psRCxNQUFNO1FBQ05wcUQsTUFBTTtRQUNOd3VELFVBQVU7UUFDVjBPLGFBQWE7UUFDYi9OLFVBQVU7UUFDVmdPLFlBQVk7WUFBQztZQUFNO1NBQUs7UUFDeEJqVSxTQUFTO0lBQ1g7SUFDQXJsSSxFQUFFK3BJLFFBQVEsR0FBRztRQUNYQyxzQkFBc0IsRUFBRTtJQUMxQjtJQUNBaHFJLEVBQUV3dkksU0FBUyxHQUFHO1FBQ1pyNkcsT0FBTztRQUNQa3dHLFNBQVM7UUFDVCxnREFBZ0Q7UUFDaERqa0YsZUFBZTtZQUFDO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtTQUFLO1FBQ25EOHVGLHNCQUFzQjtRQUN0QlIsa0JBQWtCO1FBQ2xCNzVILEtBQUs7WUFBQztZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07U0FBSztRQUN6QzQ1SCxTQUFTO1lBQUM7WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1NBQUs7SUFDL0M7SUFDQXp2SSxFQUFFdTVJLE9BQU8sR0FBRztJQUNadjVJLEVBQUU0ekYsT0FBTyxHQUFHNS9FLFFBQVE0L0UsT0FBTztJQUMzQjV6RixFQUFFMnpGLEtBQUssR0FBRzMvRSxRQUFRMi9FLEtBQUs7SUFDdkIzekYsRUFBRTZ6RixLQUFLLEdBQUc3L0UsUUFBUTYvRSxLQUFLO0lBQ3ZCN3pGLEVBQUVtekYsbUJBQW1CLEdBQUduL0UsUUFBUW0vRSxtQkFBbUI7SUFDbkRuekYsRUFBRW96RixpQkFBaUIsR0FBR3AvRSxRQUFRby9FLGlCQUFpQjtJQUMvQ3B6RixFQUFFMHpGLGdCQUFnQixHQUFHMS9FLFFBQVEwL0UsZ0JBQWdCO0lBQzdDMXpGLEVBQUV3NUksaUJBQWlCLEdBQUd4bEksUUFBUXEvRSxVQUFVLEVBQUUsZ0JBQWdCO0lBQzFEcnpGLEVBQUV5NUksZ0JBQWdCLEdBQUc3MEksU0FBU29QLFFBQVF1L0UsVUFBVSxJQUFJdi9FLFFBQVF1L0UsVUFBVSxHQUFHO0lBQ3pFdnpGLEVBQUVxekYsVUFBVSxHQUFHci9FLFFBQVFxL0UsVUFBVSxFQUFFLHVCQUF1QjtJQUMxRHJ6RixFQUFFc3pGLGlCQUFpQixHQUFHdC9FLFFBQVFzL0UsaUJBQWlCO0lBQy9DdHpGLEVBQUUwNUksc0JBQXNCLEdBQUcsSUFBSTE1SSxFQUFFc3pGLGlCQUFpQjtJQUNsRHR6RixFQUFFMjVJLGlCQUFpQixHQUFHO0lBQ3RCMzVJLEVBQUU0NUksV0FBVyxHQUFHLEdBQUcsTUFBTTtJQUN6QjU1SSxFQUFFNjVJLGtCQUFrQixHQUFHO0lBQ3ZCNzVJLEVBQUU4NUksYUFBYSxHQUFHO0lBQ2xCOTVJLEVBQUUrNUksb0JBQW9CLEdBQUcsRUFBRTtJQUMzQi81SSxFQUFFd3pGLG1CQUFtQixHQUFHeC9FLFFBQVF3L0UsbUJBQW1CO0lBQ25EeHpGLEVBQUU0ckksb0JBQW9CLEdBQUc1M0gsUUFBUXcvRSxtQkFBbUIsR0FBR3gvRSxRQUFRdy9FLG1CQUFtQjtJQUNsRnh6RixFQUFFeXpGLGlCQUFpQixHQUFHei9FLFFBQVF5L0UsaUJBQWlCO0lBQy9DenpGLEVBQUV5d0ksa0JBQWtCLEdBQUd6OEgsUUFBUXkvRSxpQkFBaUIsR0FBR3ovRSxRQUFReS9FLGlCQUFpQjtJQUM1RXp6RixFQUFFdXFJLGVBQWUsR0FBRztJQUNwQnZxSSxFQUFFdWxJLFFBQVEsR0FBRyxFQUFFO0lBQ2Z2bEksRUFBRWs0SSxxQkFBcUIsR0FBRyxFQUFFO0lBQzVCbDRJLEVBQUU0eEYsc0JBQXNCLEdBQUc7UUFDekIseUNBQXlDO1FBQ3pDclUsWUFBWTtRQUNaMGxELFVBQVU7UUFDVitXLFdBQVc7UUFDWEMsV0FBVztRQUNYQyxZQUFZO0lBQ2Q7SUFDQWw2SSxFQUFFZzNJLGtCQUFrQjtJQUNwQmgzSSxFQUFFK2dILG1CQUFtQjtJQUNyQi9nSCxFQUFFc2lJLDRCQUE0QjtBQUNoQztBQUNBdVcsSUFBSTl6RixNQUFNLEdBQUcsU0FBVXl0QyxTQUFTLEVBQUVqbEUsSUFBSTtJQUNwQyxJQUFJdnRCLElBQUksSUFBSTtJQUNaLElBQUl5akIsS0FBS3pqQixFQUFFeWpCLEVBQUU7SUFFYixzREFBc0Q7SUFDdEQsSUFBSSxJQUFJLENBQUNtdkUsU0FBUyxFQUFFO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFJSixjQUFjLFFBQVE7UUFDeEJ4eUYsRUFBRTBsSSxJQUFJO1FBQ047SUFDRjtJQUNBLElBQUlsekMsY0FBYyxXQUFXO1FBQzNCeHlGLEVBQUVrdkcsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJMWMsY0FBYyxTQUFTQSxjQUFjLFlBQVlBLGNBQWMsVUFBVS91RSxHQUFHNmdELGdCQUFnQixNQUFNa3VCLGNBQWMsVUFBVUEsY0FBYyxZQUFZQSxjQUFjLFNBQVM7UUFDN0t4eUYsRUFBRWlrSSwyQkFBMkI7SUFDL0I7SUFDQSxJQUFJenhDLGNBQWMsWUFBWTtRQUM1Qnh5RixFQUFFZ3JJLFVBQVUsQ0FBQyxVQUFVO0lBQ3pCO0lBQ0EsSUFBSXg0QyxjQUFjLE1BQU07UUFDdEJ4eUYsRUFBRWdySSxVQUFVLENBQUMsTUFBTTtJQUNyQjtJQUNBLElBQUl4NEMsY0FBYyxVQUFVQSxjQUFjLFlBQVlBLGNBQWMsU0FBUztRQUMzRXh5RixFQUFFbWtILG9DQUFvQztRQUN0Q25rSCxFQUFFbTZJLGVBQWUsQ0FBQ242SSxFQUFFaTFGLFNBQVM7SUFDL0I7SUFDQWoxRixFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO0lBQ3JCaHJJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7SUFDckIsSUFBSSxDQUFDbU4sZUFBZTtJQUNwQixJQUFJLENBQUNqTixNQUFNO0FBQ2I7QUFDQTJOLElBQUkzcEMsT0FBTyxHQUFHO0lBQ1osSUFBSWx2RyxJQUFJLElBQUk7SUFDWkEsRUFBRTR5RixTQUFTLEdBQUc7SUFDZDV5RixFQUFFeWpCLEVBQUUsQ0FBQzJ0RSxpQkFBaUI7SUFDdEIsSUFBSyxJQUFJM3VGLElBQUksR0FBR0EsSUFBSXpDLEVBQUV1bEksUUFBUSxDQUFDcmxJLE1BQU0sRUFBRXVDLElBQUs7UUFDMUMsSUFBSTIzSSxVQUFVcDZJLEVBQUV1bEksUUFBUSxDQUFDOWlJLEVBQUU7UUFDM0IsSUFBSThGLElBQUk2eEk7UUFDUixJQUFJeHhJLE1BQU1MLEVBQUV3YixNQUFNO1FBQ2pCbmIsQ0FBQUEsSUFBSXF3QixHQUFHLElBQUlyd0IsSUFBSXl4SSxtQkFBbUIsRUFBRXJ6SSxLQUFLLENBQUM0QixLQUFLTCxFQUFFOUIsSUFBSTtJQUN4RDtJQUNBekcsRUFBRXVsSSxRQUFRLEdBQUcsRUFBRTtJQUNmdmxJLEVBQUVrNEkscUJBQXFCLEdBQUcsRUFBRTtJQUM1Qmw0SSxFQUFFK2lJLG1CQUFtQixHQUFHLEVBQUU7SUFDMUIsSUFBSS9pSSxFQUFFbW9JLGNBQWMsRUFBRTtRQUNwQm5vSSxFQUFFbW9JLGNBQWMsQ0FBQ21TLFVBQVU7SUFDN0I7SUFDQSxJQUFJdDZJLEVBQUU2b0ksYUFBYSxFQUFFO1FBQ25CN29JLEVBQUU2b0ksYUFBYSxDQUFDeVIsVUFBVTtJQUM1QjtJQUNBLElBQUl0NkksRUFBRThvSSxjQUFjLEVBQUU7UUFDcEI5b0ksRUFBRThvSSxjQUFjLENBQUN3UixVQUFVO0lBQzdCO0lBQ0EsSUFBSXQ2SSxFQUFFdTZJLFlBQVksRUFBRTtRQUNsQixJQUFJO1lBQ0YzMkksU0FBU3NoSSxJQUFJLENBQUM5dkMsV0FBVyxDQUFDcDFGLEVBQUV1NkksWUFBWSxHQUFHLCtCQUErQjtRQUM1RSxFQUFFLE9BQU9wNkksR0FBRztRQUNWLG1CQUFtQjtRQUNyQjtJQUNGO0FBQ0Y7QUFDQTA0SSxJQUFJdm9DLFVBQVUsR0FBRztJQUNmLE9BQU87QUFDVDtBQUNBO0lBQUN1UTtJQUFPc2pCO0lBQU9DO0lBQU9VO0lBQU8rTztJQUFPMEQ7Q0FBTSxDQUFDbjBILE9BQU8sQ0FBQyxTQUFVaTdCLEtBQUs7SUFDaEU1MUMsT0FBT293SSxLQUFLeDZGO0FBQ2Q7QUFFQSxJQUFJbThGLGNBQWMsT0FBTyxJQUFJLDhCQUE4QjtBQUUzRCxJQUFJQyxPQUFPO0lBQ1RDLGlCQUFpQixTQUFTQSxnQkFBZ0J0NUgsSUFBSTtRQUM1QyxPQUFPLFNBQVN1NUg7WUFDZCxJQUFJOXpJLFFBQU8sSUFBSTtZQUNmLElBQUk3RyxJQUFJLElBQUksQ0FBQ2d1RSxRQUFRO1lBQ3JCLElBQUlubkUsTUFBSyt6SSxlQUFlLEVBQUU7Z0JBQ3hCO1lBQ0YsT0FBTztnQkFDTC96SSxNQUFLK3pJLGVBQWUsR0FBRztZQUN6QjtZQUNBLElBQUlDLGNBQWM3Z0ksU0FBUztnQkFDekJoYSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO2dCQUNyQmhySSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO2dCQUNyQmhySSxFQUFFa3JJLE1BQU07WUFDVixHQUFHOXBILEtBQUswNUgsa0JBQWtCO1lBQzFCLElBQUkzbkMsVUFBVSxTQUFTQSxRQUFReGhCLFFBQVEsRUFBRW9wRCxjQUFjO2dCQUNyRCxJQUFJdnJELFlBQVlsekU7Z0JBQ2hCLElBQUkwK0gsZ0JBQWdCaDdJLEVBQUUyM0ksaUJBQWlCO2dCQUN2QyxJQUFJc0QsYUFBYWo3SSxFQUFFNDNJLGNBQWM7Z0JBQ2pDLElBQUlzRCxPQUFPLEVBQUU7Z0JBQ2IsSUFBSXpzQyxTQUFTenVHLEVBQUV5akIsRUFBRSxDQUFDZ3JGLE1BQU07Z0JBQ3hCLElBQUlsYixhQUFhdnpGLEVBQUVtN0ksYUFBYTtnQkFFaEMscUVBQXFFO2dCQUNyRSxnRUFBZ0U7Z0JBQ2hFLElBQUksQ0FBQ3hwRCxVQUFVO29CQUNiM3hGLEVBQUVnakksdUJBQXVCO2dCQUMzQjtnQkFDQSxNQUFPLEtBQU07b0JBQ1gsNENBQTRDO29CQUM1QyxJQUFJbnRILE1BQU15RztvQkFDVixJQUFJcWtDLFdBQVc5cUMsTUFBTTI1RTtvQkFDckIsSUFBSTRyRCxnQkFBZ0J2bEksTUFBTWtsSTtvQkFDMUIsSUFBSUUsYUFBYVQsYUFBYTt3QkFDNUIsbUVBQW1FO3dCQUNuRSx5Q0FBeUM7d0JBRXpDLElBQUlhLGdCQUFnQmIsY0FBZTdvRCxDQUFBQSxXQUFXcXBELGdCQUFnQjt3QkFDOUQsSUFBSUksaUJBQWlCaDZILEtBQUtrNkgsV0FBVyxHQUFHRCxlQUFlOzRCQUNyRDt3QkFDRjtvQkFDRixPQUFPO3dCQUNMLElBQUkxcEQsVUFBVTs0QkFDWixJQUFJaHhDLFlBQVl2L0IsS0FBS202SCxPQUFPLEdBQUdOLGNBQWN0NkYsWUFBWXYvQixLQUFLbzZILFVBQVUsR0FBR1IsZUFBZTtnQ0FDeEY7NEJBQ0Y7d0JBQ0YsT0FBTyxJQUFJSSxpQkFBaUJoNkgsS0FBS3E2SCxhQUFhLEdBQUdqQixhQUFhOzRCQUM1RDt3QkFDRjtvQkFDRjtvQkFDQSxJQUFJa0IsV0FBV3Q2SCxLQUFLdTZILEdBQUcsQ0FBQzkwSSxPQUFNMHNGLFlBQVlrYjtvQkFDMUMsSUFBSWl0QyxTQUFTeDdJLE1BQU0sR0FBRyxHQUFHO3dCQUN2QixJQUFLLElBQUl1QyxJQUFJLEdBQUdBLElBQUlpNUksU0FBU3g3SSxNQUFNLEVBQUV1QyxJQUFLOzRCQUN4Q3k0SSxLQUFLeDRJLElBQUksQ0FBQ2c1SSxRQUFRLENBQUNqNUksRUFBRTt3QkFDdkI7b0JBQ0YsT0FBTzt3QkFDTDtvQkFDRjtnQkFDRjtnQkFFQSx1QkFBdUI7Z0JBQ3ZCLElBQUl5NEksS0FBS2g3SSxNQUFNLEdBQUcsR0FBRztvQkFDbkJraEIsS0FBS3c2SCxNQUFNLENBQUMvMEksT0FBTXEwSTtvQkFDbEIsSUFBSSxDQUFDdnBELFlBQVl2d0UsS0FBS3k2SCxZQUFZLENBQUNoMUksT0FBTXEwSSxNQUFNM25ELFlBQVlrYixTQUFTO3dCQUNsRW9zQztvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsSUFBSTdDLFdBQVc1MkgsS0FBSzQySCxRQUFRLElBQUk5M0g7WUFDaENsZ0IsRUFBRXl4RixZQUFZLENBQUMwaEIsU0FBUzZrQyxTQUFTbnhJO1FBQ25DO0lBQ0Y7QUFDRjtBQUVBLDBDQUEwQztBQUMxQyxrREFBa0Q7QUFDbEQsSUFBSWkxSSw0QkFBNEIsV0FBVyxHQUFFO0lBQzNDLFNBQVNBLDBCQUEwQi9xRSxNQUFNO1FBQ3ZDLElBQUlnckUsdUJBQXVCdjFJLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBR3daO1FBQy9GdmYsZ0JBQWdCLElBQUksRUFBRXE3STtRQUN0QixJQUFJLENBQUNFLFFBQVEsR0FBRyxJQUFJdjVIO1FBQ3BCLElBQUksQ0FBQ3c1SCxRQUFRLEdBQUcsSUFBSXg1SDtRQUNwQixJQUFJLENBQUN5NUgsV0FBVyxHQUFHLElBQUl6NUg7UUFDdkIsSUFBSSxDQUFDMDVILElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDcHJFLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNnckUsb0JBQW9CLEdBQUdBO0lBQzlCO0lBQ0EsT0FBTzE2SSxhQUFheTZJLDJCQUEyQjtRQUFDO1lBQzlDMTZJLEtBQUs7WUFDTFUsT0FBTyxTQUFTczZJLFVBQVVoN0ksR0FBRztnQkFDM0IsSUFBSUEsT0FBTyxNQUFNO29CQUNmZ2YsTUFBTTtnQkFDUjtnQkFDQSxJQUFJNDdILFdBQVcsSUFBSSxDQUFDQSxRQUFRO2dCQUM1QixJQUFJM3lELE1BQU0sSUFBSSxDQUFDMnlELFFBQVEsQ0FBQ3g1SCxHQUFHLENBQUNwaEI7Z0JBQzVCLElBQUksQ0FBQ2lvRixLQUFLO29CQUNSQSxNQUFNLElBQUkvbEU7b0JBQ1YwNEgsU0FBUzc1SCxHQUFHLENBQUMvZ0IsS0FBS2lvRjtnQkFDcEI7Z0JBQ0EsT0FBT0E7WUFDVDtRQUNGO1FBQUc7WUFDRGpvRixLQUFLO1lBQ0xVLE9BQU8sU0FBU3U2SSxZQUFZajdJLEdBQUcsRUFBRThtQixFQUFFO2dCQUNqQyxJQUFJOW1CLE9BQU8sTUFBTTtvQkFDZixJQUFJLENBQUNnN0ksU0FBUyxDQUFDaDdJLEtBQUs2aEIsR0FBRyxDQUFDaUY7Z0JBQzFCO1lBQ0Y7UUFDRjtRQUFHO1lBQ0Q5bUIsS0FBSztZQUNMVSxPQUFPLFNBQVN3NkksZUFBZWw3SSxHQUFHLEVBQUU4bUIsRUFBRTtnQkFDcEMsSUFBSTltQixPQUFPLE1BQU07b0JBQ2YsSUFBSSxDQUFDZzdJLFNBQVMsQ0FBQ2g3SSxJQUFJLENBQUMsU0FBUyxDQUFDOG1CO2dCQUNoQztZQUNGO1FBQ0Y7UUFBRztZQUNEOW1CLEtBQUs7WUFDTFUsT0FBTyxTQUFTeTZJLHFCQUFxQm43SSxHQUFHO2dCQUN0QyxJQUFJQSxPQUFPLE1BQU07b0JBQ2YsT0FBTztnQkFDVCxPQUFPO29CQUNMLE9BQU8sSUFBSSxDQUFDZzdJLFNBQVMsQ0FBQ2g3SSxLQUFLMmhCLElBQUk7Z0JBQ2pDO1lBQ0Y7UUFDRjtRQUFHO1lBQ0QzaEIsS0FBSztZQUNMVSxPQUFPLFNBQVMwNkksb0JBQW9CaDdILEdBQUc7Z0JBQ3JDLElBQUkwRyxLQUFLMUcsSUFBSTBHLEVBQUU7Z0JBQ2YsSUFBSXF2RSxVQUFVLElBQUksQ0FBQzBrRCxRQUFRLENBQUN6NUgsR0FBRyxDQUFDMEY7Z0JBQ2hDLElBQUl1MEgsVUFBVSxJQUFJLENBQUMxckUsTUFBTSxDQUFDdnZEO2dCQUMxQixJQUFJLENBQUM4NkgsY0FBYyxDQUFDL2tELFNBQVNydkU7Z0JBQzdCLElBQUksQ0FBQ20wSCxXQUFXLENBQUNJLFNBQVN2MEg7Z0JBQzFCLElBQUksQ0FBQyt6SCxRQUFRLENBQUM5NUgsR0FBRyxDQUFDK0YsSUFBSXUwSDtZQUN4QjtRQUNGO1FBQUc7WUFDRHI3SSxLQUFLO1lBQ0xVLE9BQU8sU0FBUzQ2SSxvQkFBb0JsN0gsR0FBRztnQkFDckMsSUFBSTBHLEtBQUsxRyxJQUFJMEcsRUFBRTtnQkFDZixJQUFJcXZFLFVBQVUsSUFBSSxDQUFDMGtELFFBQVEsQ0FBQ3o1SCxHQUFHLENBQUMwRjtnQkFDaEMsSUFBSSxDQUFDbzBILGNBQWMsQ0FBQy9rRCxTQUFTcnZFO2dCQUM3QixJQUFJLENBQUMrekgsUUFBUSxDQUFDLFNBQVMsQ0FBQy96SDtZQUMxQjtRQUNGO1FBQUc7WUFDRDltQixLQUFLO1lBQ0xVLE9BQU8sU0FBUzY2SSxpQkFBaUJuN0gsR0FBRztnQkFDbEMsSUFBSTBHLEtBQUsxRyxJQUFJMEcsRUFBRTtnQkFDZixJQUFJcXZFLFVBQVUsSUFBSSxDQUFDMGtELFFBQVEsQ0FBQ3o1SCxHQUFHLENBQUMwRjtnQkFDaEMsSUFBSTAwSCxTQUFTLElBQUksQ0FBQzdyRSxNQUFNLENBQUN2dkQ7Z0JBQ3pCLE9BQU8rMUUsWUFBWXFsRDtZQUNyQjtRQUNGO1FBQUc7WUFDRHg3SSxLQUFLO1lBQ0xVLE9BQU8sU0FBUys2SSxVQUFVcjdILEdBQUc7Z0JBQzNCLE9BQU8sSUFBSSxDQUFDbTdILGdCQUFnQixDQUFDbjdILFFBQVEsSUFBSSxDQUFDdTZILG9CQUFvQixDQUFDdjZIO1lBQ2pFO1FBQ0Y7UUFBRztZQUNEcGdCLEtBQUs7WUFDTFUsT0FBTyxTQUFTZzdJLFlBQVlDLEdBQUc7Z0JBQzdCLElBQUliLGNBQWMsSUFBSSxDQUFDQSxXQUFXLEVBQ2hDQyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtnQkFDbEIsSUFBSWEsU0FBU2QsWUFBWTE1SCxHQUFHLENBQUN1Nkg7Z0JBQzdCLElBQUksQ0FBQ0MsUUFBUTtvQkFDWEEsU0FBUyxJQUFJdjZIO29CQUNieTVILFlBQVkvNUgsR0FBRyxDQUFDNDZILEtBQUtDO29CQUNyQmIsS0FBS3o1SSxJQUFJLENBQUNxNkk7Z0JBQ1o7Z0JBQ0EsT0FBT0M7WUFDVDtRQUNGO1FBQUc7WUFDRDU3SSxLQUFLO1lBQ0xVLE9BQU8sU0FBU203SSxTQUFTNzdJLEdBQUcsRUFBRTI3SSxHQUFHO2dCQUMvQixPQUFPLElBQUksQ0FBQ0QsV0FBVyxDQUFDQyxLQUFLdjZILEdBQUcsQ0FBQ3BoQjtZQUNuQztRQUNGO1FBQUc7WUFDREEsS0FBSztZQUNMVSxPQUFPLFNBQVMwZ0IsSUFBSWhCLEdBQUcsRUFBRXU3SCxHQUFHO2dCQUMxQixJQUFJMzdJLE1BQU0sSUFBSSxDQUFDMnZFLE1BQU0sQ0FBQ3Z2RDtnQkFDdEIsSUFBSXZhLFFBQVEsSUFBSSxDQUFDZzJJLFFBQVEsQ0FBQzc3SSxLQUFLMjdJO2dCQUUvQixnRkFBZ0Y7Z0JBQ2hGLElBQUk5MUksU0FBUyxNQUFNO29CQUNqQixJQUFJLENBQUN1MUksbUJBQW1CLENBQUNoN0g7Z0JBQzNCO2dCQUNBLE9BQU92YTtZQUNUO1FBQ0Y7UUFBRztZQUNEN0YsS0FBSztZQUNMVSxPQUFPLFNBQVNvN0ksZ0JBQWdCMTdILEdBQUcsRUFBRXU3SCxHQUFHO2dCQUN0QyxJQUFJMzdJLE1BQU0sSUFBSSxDQUFDNjZJLFFBQVEsQ0FBQ3o1SCxHQUFHLENBQUNoQixJQUFJMEcsRUFBRSxLQUFLLDhDQUE4QztnQkFDckYsSUFBSWpoQixRQUFRLElBQUksQ0FBQ2cySSxRQUFRLENBQUM3N0ksS0FBSzI3STtnQkFDL0IsT0FBTzkxSTtZQUNUO1FBQ0Y7UUFBRztZQUNEN0YsS0FBSztZQUNMVSxPQUFPLFNBQVNxN0ksU0FBUy83SSxHQUFHLEVBQUUyN0ksR0FBRztnQkFDL0IsT0FBTyxJQUFJLENBQUNELFdBQVcsQ0FBQ0MsS0FBS3g2SCxHQUFHLENBQUNuaEI7WUFDbkM7UUFDRjtRQUFHO1lBQ0RBLEtBQUs7WUFDTFUsT0FBTyxTQUFTeWdCLElBQUlmLEdBQUcsRUFBRXU3SCxHQUFHO2dCQUMxQixJQUFJMzdJLE1BQU0sSUFBSSxDQUFDMnZFLE1BQU0sQ0FBQ3Z2RDtnQkFDdEIsT0FBTyxJQUFJLENBQUMyN0gsUUFBUSxDQUFDLzdJLEtBQUsyN0k7WUFDNUI7UUFDRjtRQUFHO1lBQ0QzN0ksS0FBSztZQUNMVSxPQUFPLFNBQVNzN0ksU0FBU2g4SSxHQUFHLEVBQUUyN0ksR0FBRyxFQUFFOTFJLEtBQUs7Z0JBQ3RDQSxNQUFNN0YsR0FBRyxHQUFHQTtnQkFDWixJQUFJLENBQUMwN0ksV0FBVyxDQUFDQyxLQUFLNTZILEdBQUcsQ0FBQy9nQixLQUFLNkY7WUFDakM7UUFDRjtRQUFHO1lBQ0Q3RixLQUFLO1lBQ0xVLE9BQU8sU0FBU3FnQixJQUFJWCxHQUFHLEVBQUV1N0gsR0FBRyxFQUFFOTFJLEtBQUs7Z0JBQ2pDLElBQUk3RixNQUFNLElBQUksQ0FBQzJ2RSxNQUFNLENBQUN2dkQ7Z0JBQ3RCLElBQUksQ0FBQzQ3SCxRQUFRLENBQUNoOEksS0FBSzI3SSxLQUFLOTFJO2dCQUN4QixJQUFJLENBQUN1MUksbUJBQW1CLENBQUNoN0g7WUFDM0I7UUFDRjtRQUFHO1lBQ0RwZ0IsS0FBSztZQUNMVSxPQUFPLFNBQVN1N0ksWUFBWWo4SSxHQUFHLEVBQUUyN0ksR0FBRztnQkFDbEMsSUFBSSxDQUFDRCxXQUFXLENBQUNDLElBQUksQ0FBQyxTQUFTLENBQUMzN0k7WUFDbEM7UUFDRjtRQUFHO1lBQ0RBLEtBQUs7WUFDTFUsT0FBTyxTQUFTdWdCLFFBQVFiLEdBQUcsRUFBRXU3SCxHQUFHO2dCQUM5QixJQUFJMzdJLE1BQU0sSUFBSSxDQUFDMnZFLE1BQU0sQ0FBQ3Z2RDtnQkFDdEIsSUFBSSxDQUFDNjdILFdBQVcsQ0FBQ2o4SSxLQUFLMjdJO1lBQ3hCO1FBQ0Y7UUFBRztZQUNEMzdJLEtBQUs7WUFDTFUsT0FBTyxTQUFTdzdJLGNBQWNsOEksR0FBRztnQkFDL0IsSUFBSThoQixRQUFRLElBQUk7Z0JBQ2hCLElBQUksQ0FBQ2k1SCxJQUFJLENBQUMvNEgsT0FBTyxDQUFDLFNBQVUyNUgsR0FBRztvQkFDN0IsT0FBTzc1SCxNQUFNbTZILFdBQVcsQ0FBQ2o4SSxLQUFLMjdJO2dCQUNoQztZQUNGO1FBR0Y7UUFBRztZQUNEMzdJLEtBQUs7WUFDTFUsT0FBTyxTQUFTeTdJLFdBQVcvN0gsR0FBRztnQkFDNUIsSUFBSTBHLEtBQUsxRyxJQUFJMEcsRUFBRTtnQkFDZixJQUFJOW1CLE1BQU0sSUFBSSxDQUFDNjZJLFFBQVEsQ0FBQ3o1SCxHQUFHLENBQUMwRixLQUFLLDBEQUEwRDtnQkFFM0YsSUFBSSxDQUFDdzBILG1CQUFtQixDQUFDbDdIO2dCQUN6QixJQUFJZzhILHVCQUF1QixJQUFJLENBQUN6QixvQkFBb0IsQ0FBQ3Y2SDtnQkFDckQsSUFBSWc4SCxzQkFBc0I7b0JBQ3hCLGdDQUFnQztvQkFDaEMsSUFBSSxDQUFDRixhQUFhLENBQUNsOEk7Z0JBQ3JCO2dCQUNBLE9BQU9vOEksd0JBQXdCLElBQUksQ0FBQ2pCLG9CQUFvQixDQUFDbjdJLFNBQVM7WUFDcEU7UUFDRjtLQUFFO0FBQ0o7QUFFQSxJQUFJcThJLFVBQVUsSUFBSSxxRUFBcUU7QUFDdkYsSUFBSUMsV0FBVyxJQUFJLGlGQUFpRjtBQUNwRyxJQUFJQyxXQUFXLENBQUMsR0FBRyw0REFBNEQ7QUFDL0UsSUFBSUMsV0FBVyxHQUFHLDRFQUE0RTtBQUM5RixJQUFJQyxZQUFZLE1BQU0sd0RBQXdEO0FBQzlFLElBQUlDLGdCQUFnQixHQUFHLGtFQUFrRTtBQUN6RixJQUFJQyxjQUFjLE1BQU0sZ0NBQWdDO0FBQ3hELElBQUlDLFVBQVUsTUFBTSxpQ0FBaUM7QUFDckQsSUFBSUMsVUFBVSxNQUFNLGtDQUFrQztBQUN0RCxJQUFJQyxhQUFhLEtBQUssdURBQXVEO0FBQzdFLElBQUlDLGNBQWMsS0FBSywyREFBMkQ7QUFDbEYsSUFBSUMsb0JBQW9CLElBQUksa0NBQWtDO0FBQzlELElBQUlDLFlBQVksTUFBTSx3RUFBd0U7QUFDOUYsSUFBSUMsZUFBZSxLQUFLLG9FQUFvRTtBQUM1RixJQUFJQyxrQkFBa0IsS0FBSyx1RUFBdUU7QUFDbEcsSUFBSUMsZ0JBQWdCLEtBQUsseUNBQXlDO0FBQ2xFLElBQUlDLHVCQUF1QixLQUFLLDJHQUEyRztBQUMzSSxJQUFJQyxlQUFlLEdBQUcsdUVBQXVFO0FBRTdGLElBQUlDLGdCQUFnQjtJQUNsQnhyQyxTQUFTO0lBQ1R5ckMsV0FBVztJQUNYQyxhQUFhO0FBQ2Y7QUFDQSxJQUFJQyxlQUFlNzlILFdBQVc7SUFDNUI4dkQsUUFBUTtJQUNSZ3JFLHNCQUFzQi83SDtJQUN0QisrSCxhQUFhO0lBQ2JDLGdCQUFnQjtJQUNoQkMsa0JBQWtCO0lBQ2xCQyxtQkFBbUI7SUFDbkJDLFdBQVdwL0g7SUFDWHEvSCxxQkFBcUI7SUFDckJDLHVCQUF1QjtBQUN6QjtBQUNBLElBQUlDLHNCQUFzQixTQUFTQSxvQkFBb0J0eEUsUUFBUSxFQUFFdXhFLFdBQVc7SUFDMUUsSUFBSTE0SSxRQUFPLElBQUk7SUFDZkEsTUFBS21uRSxRQUFRLEdBQUdBO0lBQ2hCbm5FLE1BQUsyNEksVUFBVSxHQUFHLEVBQUU7SUFDcEIsSUFBSXArSCxPQUFPMDlILGFBQWFTO0lBQ3hCOTJJLE9BQU81QixPQUFNdWE7SUFDYnZhLE1BQUtpMEQsTUFBTSxHQUFHLElBQUlnaEYsMEJBQTBCMTZILEtBQUsydkQsTUFBTSxFQUFFM3ZELEtBQUsyNkgsb0JBQW9CO0lBQ2xGbDFJLE1BQUs2ekksZUFBZTtBQUN0QjtBQUNBLElBQUkrRSxPQUFPSCxvQkFBb0JoK0ksU0FBUztBQUN4Q20rSSxLQUFLQyxPQUFPLEdBQUdmO0FBRWYsMkVBQTJFO0FBQzNFYyxLQUFLRSxlQUFlLEdBQUcsU0FBVUMsSUFBSTtJQUNuQyxJQUFJLzRJLFFBQU8sSUFBSTtJQUNmQSxNQUFLZzVJLFlBQVksR0FBR2g1SSxNQUFLZzVJLFlBQVksSUFBSSxDQUFDO0lBQzFDLE9BQU9oNUksTUFBS2c1SSxZQUFZLENBQUNELEtBQUssR0FBRy80SSxNQUFLZzVJLFlBQVksQ0FBQ0QsS0FBSyxJQUFJLEVBQUU7QUFDaEU7QUFFQSw4RUFBOEU7QUFDOUVILEtBQUtLLHNCQUFzQixHQUFHLFNBQVVGLElBQUk7SUFDMUMsSUFBSS80SSxRQUFPLElBQUk7SUFDZixJQUFJazVJLFVBQVVsNUksTUFBS2c1SSxZQUFZLENBQUNHLE9BQU8sR0FBR241SSxNQUFLZzVJLFlBQVksQ0FBQ0csT0FBTyxJQUFJLENBQUM7SUFDeEUsSUFBSUMsU0FBU0YsT0FBTyxDQUFDSCxLQUFLLEdBQUdHLE9BQU8sQ0FBQ0gsS0FBSyxJQUFJLEVBQUU7SUFDaEQsT0FBT0s7QUFDVDtBQUVBLDJEQUEyRDtBQUMzRFIsS0FBS1MsZUFBZSxHQUFHO0lBQ3JCLElBQUlyNUksUUFBTyxJQUFJO0lBQ2YsSUFBSTZDLElBQUk3QyxNQUFLczVJLGFBQWEsR0FBR3Q1SSxNQUFLczVJLGFBQWEsSUFBSSxJQUFJbjJILEtBQUssU0FBVS9wQixDQUFDLEVBQUVzSSxDQUFDO1FBQ3hFLE9BQU9BLEVBQUU2M0ksSUFBSSxHQUFHbmdKLEVBQUVtZ0osSUFBSTtJQUN4QjtJQUNBLE9BQU8xMkk7QUFDVDtBQUVBLCtFQUErRTtBQUMvRSsxSSxLQUFLWSxvQkFBb0IsR0FBRztJQUMxQixJQUFJeDVJLFFBQU8sSUFBSTtJQUNmLElBQUl5NUksTUFBTXo1SSxNQUFLMDVJLGtCQUFrQixHQUFHMTVJLE1BQUswNUksa0JBQWtCLElBQUksQ0FBQztJQUNoRSxPQUFPRDtBQUNUO0FBQ0FiLEtBQUtlLFVBQVUsR0FBRyxTQUFVaC9ILEdBQUcsRUFBRWtaLEVBQUUsRUFBRTg1RCxPQUFPLEVBQUV1b0QsR0FBRyxFQUFFMEQsTUFBTTtJQUN2RCxJQUFJNTVJLFFBQU8sSUFBSTtJQUNmLElBQUk3RyxJQUFJLElBQUksQ0FBQ2d1RSxRQUFRO0lBQ3JCLElBQUl0bkQsT0FBTzFtQixFQUFFeWpCLEVBQUUsQ0FBQ2lELElBQUk7SUFDcEIsSUFBSW8wQyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtJQUN4QixJQUFJLENBQUNwZ0MsTUFBTUEsR0FBR3ZiLENBQUMsS0FBSyxLQUFLdWIsR0FBR254QixDQUFDLEtBQUssS0FBS3pFLE1BQU00MUIsR0FBR3ZiLENBQUMsS0FBS3JhLE1BQU00MUIsR0FBR254QixDQUFDLEtBQUssQ0FBQ2lZLElBQUlnNUMsT0FBTyxNQUFNaDVDLElBQUltRCxPQUFPLElBQUk7UUFDcEcsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDOWQsTUFBS3U0SSxtQkFBbUIsSUFBSTU5SCxJQUFJbTZCLE1BQU0sTUFBTSxDQUFDOTBDLE1BQUt3NEkscUJBQXFCLElBQUk3OUgsSUFBSWk1QyxRQUFRLElBQUk7UUFDOUYsT0FBTztJQUNUO0lBQ0EsSUFBSXNpRixPQUFPLE1BQU07UUFDZkEsTUFBTS8zSSxLQUFLNHhCLElBQUksQ0FBQzZDLEtBQUsvUyxPQUFPOHRFO0lBQzlCO0lBQ0EsSUFBSXVvRCxNQUFNWSxVQUFVO1FBQ2xCWixNQUFNWTtJQUNSLE9BQU8sSUFBSWozSCxRQUFRbTNILGFBQWFkLE1BQU1hLFVBQVU7UUFDOUMsT0FBTztJQUNUO0lBQ0EsSUFBSTFoSCxRQUFRbDNCLEtBQUs2eEIsR0FBRyxDQUFDLEdBQUdrbUg7SUFDeEIsSUFBSTJELGFBQWFobUgsR0FBR254QixDQUFDLEdBQUcyeUI7SUFDeEIsSUFBSXlrSCxhQUFham1ILEdBQUd2YixDQUFDLEdBQUcrYztJQUN4QixJQUFJMGtILG1CQUFtQjVnSixFQUFFNmdKLG9CQUFvQixDQUFDci9ILEtBQUswYTtJQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDaWpILFNBQVMsQ0FBQzM5SCxLQUFLby9ILG1CQUFtQjtRQUMxQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJRSxXQUFXaG1GLE9BQU90NEMsR0FBRyxDQUFDaEIsS0FBS3U3SDtJQUUvQix3RkFBd0Y7SUFDeEYsSUFBSStELFlBQVlBLFNBQVNDLFdBQVcsRUFBRTtRQUNwQ0QsU0FBU0MsV0FBVyxHQUFHO1FBQ3ZCRCxTQUFTRSxPQUFPLENBQUNDLGdCQUFnQixJQUFJSCxTQUFTMWpILEtBQUs7SUFDckQ7SUFDQSxJQUFJMGpILFVBQVU7UUFDWixPQUFPQTtJQUNUO0lBQ0EsSUFBSWxCLE1BQU0sMkNBQTJDO0lBRXJELElBQUljLGNBQWNqRCxTQUFTO1FBQ3pCbUMsT0FBT25DO0lBQ1QsT0FBTyxJQUFJaUQsY0FBY2hELFVBQVU7UUFDakNrQyxPQUFPbEM7SUFDVCxPQUFPO1FBQ0xrQyxPQUFPNTZJLEtBQUs0eEIsSUFBSSxDQUFDOHBILGFBQWFoRCxZQUFZQTtJQUM1QztJQUNBLElBQUlnRCxhQUFhekMsV0FBVzBDLGFBQWEzQyxTQUFTO1FBQ2hELE9BQU8sTUFBTSwwQ0FBMEM7SUFDekQ7SUFDQSxJQUFJa0QsT0FBT3I2SSxNQUFLODRJLGVBQWUsQ0FBQ0M7SUFFaEMsZ0VBQWdFO0lBQ2hFLElBQUl1QixNQUFNRCxJQUFJLENBQUNBLEtBQUtoaEosTUFBTSxHQUFHLEVBQUU7SUFDL0IsSUFBSWtoSixZQUFZLFNBQVNBO1FBQ3ZCLE9BQU92NkksTUFBS3c2SSxjQUFjLENBQUN6QixNQUFNZSxlQUFlOTVJLE1BQUt5NkksVUFBVSxDQUFDMUIsTUFBTWU7SUFDeEU7SUFFQSxrREFBa0Q7SUFDbEQsSUFBSSxDQUFDUSxLQUFLO1FBQ1JBLE1BQU1ELElBQUksQ0FBQ0EsS0FBS2hoSixNQUFNLEdBQUcsRUFBRTtJQUM3QjtJQUVBLHFEQUFxRDtJQUNyRCxJQUFJLENBQUNpaEosS0FBSztRQUNSQSxNQUFNQztJQUNSO0lBRUEsK0RBQStEO0lBQy9ELElBQUlELElBQUkvakgsS0FBSyxHQUFHK2pILElBQUlJLFNBQVMsR0FBR1osWUFBWTtRQUMxQ1EsTUFBTUM7SUFDUjtJQUNBLElBQUlJLGVBQWUsU0FBU0EsYUFBYUMsVUFBVTtRQUNqRCxPQUFPQSxjQUFjQSxXQUFXYixnQkFBZ0IsS0FBS0E7SUFDdkQ7SUFDQSxJQUFJYyxTQUFTakIsVUFBVUEsV0FBVzlCLGNBQWN4ckMsT0FBTztJQUN2RCxJQUFJd3VDLGlCQUFpQmxCLFVBQVVBLFdBQVc5QixjQUFjRSxXQUFXO0lBQ25FLElBQUkrQyxlQUFlbkIsVUFBVUEsV0FBVzlCLGNBQWNDLFNBQVM7SUFDL0QsSUFBSWlELGFBQWEsd0NBQXdDO0lBQ3pELElBQUssSUFBSXIvSSxJQUFJdTZJLE1BQU0sR0FBR3Y2SSxLQUFLbzdJLFVBQVVwN0ksSUFBSztRQUN4QyxJQUFJZ3pCLElBQUlzbEMsT0FBT3Q0QyxHQUFHLENBQUNoQixLQUFLaGY7UUFDeEIsSUFBSWd6QixHQUFHO1lBQ0xxc0gsY0FBY3JzSDtZQUNkO1FBQ0Y7SUFDRjtJQUNBLElBQUlzc0gsYUFBYUQsZUFBZUEsWUFBWXAwQyxLQUFLLEtBQUtzdkMsTUFBTSxJQUFJOEUsY0FBYztJQUM5RSxJQUFJakQsWUFBWSxTQUFTQTtRQUN2QnVDLElBQUk3cUUsT0FBTyxDQUFDeXJFLFNBQVMsQ0FBQ0QsV0FBV2QsT0FBTyxDQUFDbGdCLE1BQU0sRUFBRWdoQixXQUFXdHRJLENBQUMsRUFBRSxHQUFHc3RJLFdBQVcxa0gsS0FBSyxFQUFFMGtILFdBQVd6a0gsTUFBTSxFQUFFOGpILElBQUlJLFNBQVMsRUFBRSxHQUFHWixZQUFZRDtJQUN2STtJQUVBLDRCQUE0QjtJQUM1QlMsSUFBSTdxRSxPQUFPLENBQUMwckUsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztJQUN4Q2IsSUFBSTdxRSxPQUFPLENBQUMyckUsU0FBUyxDQUFDZCxJQUFJSSxTQUFTLEVBQUUsR0FBR1osWUFBWWY7SUFDcEQsSUFBSTRCLGFBQWFNLGFBQWE7UUFDNUIsNEVBQTRFO1FBQzVFbEQ7SUFDRixPQUFPLElBQUk0QyxhQUFhSyxjQUFjO1FBQ3BDLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFFN0MsSUFBSUYsZ0JBQWdCO1lBQ2xCLElBQUssSUFBSTc2RCxLQUFLKzZELFlBQVlwMEMsS0FBSyxFQUFFM21CLEtBQUtpMkQsS0FBS2oyRCxLQUFNO2dCQUMvQ2c3RCxhQUFhajdJLE1BQUsyNUksVUFBVSxDQUFDaC9ILEtBQUtrWixJQUFJODVELFNBQVMxTixJQUFJNjNELGNBQWNDLFNBQVM7WUFDNUU7WUFDQUE7UUFDRixPQUFPO1lBQ0wvM0ksTUFBS3E3SSxZQUFZLENBQUMxZ0ksS0FBS3FnSSxZQUFZcDBDLEtBQUssR0FBRztZQUMzQyxPQUFPbzBDO1FBQ1Q7SUFDRixPQUFPO1FBQ0wsSUFBSU0sWUFBWSx1Q0FBdUM7UUFDdkQsSUFBSSxDQUFDVCxVQUFVLENBQUNDLGtCQUFrQixDQUFDQyxjQUFjO1lBQy9DLElBQUssSUFBSVEsTUFBTXJGLE1BQU0sR0FBR3FGLE9BQU96RSxVQUFVeUUsTUFBTztnQkFDOUMsSUFBSXhzRyxLQUFLa2xCLE9BQU90NEMsR0FBRyxDQUFDaEIsS0FBSzRnSTtnQkFDekIsSUFBSXhzRyxJQUFJO29CQUNOdXNHLGFBQWF2c0c7b0JBQ2I7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSTRyRyxhQUFhVyxhQUFhO1lBQzVCLDhFQUE4RTtZQUU5RXQ3SSxNQUFLcTdJLFlBQVksQ0FBQzFnSSxLQUFLdTdIO1lBQ3ZCLE9BQU9vRjtRQUNUO1FBQ0FoQixJQUFJN3FFLE9BQU8sQ0FBQytyRSxTQUFTLENBQUNsQixJQUFJSSxTQUFTLEVBQUU7UUFDckNKLElBQUk3cUUsT0FBTyxDQUFDcDZDLEtBQUssQ0FBQ0EsT0FBT0E7UUFDekIsSUFBSSxDQUFDNmlILFdBQVcsQ0FBQ29DLElBQUk3cUUsT0FBTyxFQUFFOTBELEtBQUtrWixJQUFJa21ILGtCQUFrQjtRQUN6RE8sSUFBSTdxRSxPQUFPLENBQUNwNkMsS0FBSyxDQUFDLElBQUlBLE9BQU8sSUFBSUE7UUFDakNpbEgsSUFBSTdxRSxPQUFPLENBQUMrckUsU0FBUyxDQUFDLENBQUNsQixJQUFJSSxTQUFTLEVBQUU7SUFDeEM7SUFDQVQsV0FBVztRQUNUdHNJLEdBQUcyc0ksSUFBSUksU0FBUztRQUNoQlAsU0FBU0c7UUFDVDF6QyxPQUFPc3ZDO1FBQ1A3Z0gsT0FBT0E7UUFDUGtCLE9BQU91akg7UUFDUHRqSCxRQUFRcWpIO1FBQ1JFLGtCQUFrQkE7SUFDcEI7SUFDQU8sSUFBSUksU0FBUyxJQUFJdjhJLEtBQUs0eEIsSUFBSSxDQUFDK3BILGFBQWE3QztJQUN4Q3FELElBQUltQixTQUFTLENBQUM1L0ksSUFBSSxDQUFDbytJO0lBQ25CaG1GLE9BQU8zNEMsR0FBRyxDQUFDWCxLQUFLdTdILEtBQUsrRDtJQUNyQmo2SSxNQUFLMDdJLG9CQUFvQixDQUFDcEI7SUFDMUIsT0FBT0w7QUFDVDtBQUNBckIsS0FBSytDLGtCQUFrQixHQUFHLFNBQVVqMUgsSUFBSTtJQUN0QyxJQUFLLElBQUk5cUIsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJLENBQUNnZ0osaUJBQWlCLENBQUNsMUgsSUFBSSxDQUFDOXFCLEVBQUU7SUFDaEM7QUFDRjtBQUNBZzlJLEtBQUtnRCxpQkFBaUIsR0FBRyxTQUFVamhJLEdBQUc7SUFDcEMsSUFBSTNhLFFBQU8sSUFBSTtJQUNmLElBQUlpMEQsU0FBU2owRCxNQUFLaTBELE1BQU07SUFDeEIsSUFBSWtpRixTQUFTLEVBQUU7SUFDZixJQUFJbDdFLFVBQVVoSCxPQUFPK2hGLFNBQVMsQ0FBQ3I3SDtJQUMvQixJQUFJLENBQUNzZ0QsU0FBUztRQUNaLFFBQVEsdUVBQXVFO0lBQ2pGO0lBQ0EsSUFBSyxJQUFJaTdFLE1BQU1ZLFVBQVVaLE9BQU9hLFVBQVViLE1BQU87UUFDL0MsSUFBSTkxSSxRQUFRNnpELE9BQU9vaUYsZUFBZSxDQUFDMTdILEtBQUt1N0g7UUFDeEMsSUFBSTkxSSxPQUFPO1lBQ1QrMUksT0FBT3Q2SSxJQUFJLENBQUN1RTtRQUNkO0lBQ0Y7SUFDQSxJQUFJeTdJLHNCQUFzQjVuRixPQUFPeWlGLFVBQVUsQ0FBQy83SDtJQUM1QyxJQUFJa2hJLHFCQUFxQjtRQUN2QixJQUFLLElBQUlqZ0osSUFBSSxHQUFHQSxJQUFJdTZJLE9BQU85OEksTUFBTSxFQUFFdUMsSUFBSztZQUN0QyxJQUFJa2dKLFNBQVMzRixNQUFNLENBQUN2NkksRUFBRTtZQUN0QixJQUFJMCtJLE1BQU13QixPQUFPM0IsT0FBTztZQUV4Qiw4Q0FBOEM7WUFDOUNHLElBQUlGLGdCQUFnQixJQUFJMEIsT0FBT3ZsSCxLQUFLO1lBRXBDLGdDQUFnQztZQUNoQ3VsSCxPQUFPNUIsV0FBVyxHQUFHO1lBRXJCLDJDQUEyQztZQUMzQ2w2SSxNQUFLKzdJLG1CQUFtQixDQUFDekI7UUFDM0I7SUFDRjtJQUVBLDREQUE0RDtJQUM1RHQ2SSxNQUFLZzhJLGVBQWUsQ0FBQ3JoSTtBQUN2QjtBQUNBaStILEtBQUttRCxtQkFBbUIsR0FBRyxTQUFVekIsR0FBRztJQUN0QyxpRUFBaUU7SUFDakUsSUFBSUEsSUFBSUYsZ0JBQWdCLElBQUkvQyxhQUFhaUQsSUFBSS9qSCxLQUFLLEVBQUU7UUFDbEQsSUFBSSxDQUFDMGxILGFBQWEsQ0FBQzNCO0lBQ3JCO0FBQ0Y7QUFDQTFCLEtBQUs4QyxvQkFBb0IsR0FBRyxTQUFVcEIsR0FBRztJQUN2QywwRUFBMEU7SUFDMUUsbUZBQW1GO0lBRW5GLElBQUl0NkksUUFBTyxJQUFJO0lBQ2YsSUFBSXE2SSxPQUFPcjZJLE1BQUs4NEksZUFBZSxDQUFDd0IsSUFBSTlqSCxNQUFNO0lBQzFDLElBQUk4akgsSUFBSUksU0FBUyxHQUFHSixJQUFJL2pILEtBQUssR0FBRytnSCxlQUFlZ0QsSUFBSTRCLGNBQWMsSUFBSTNFLG1CQUFtQjtRQUN0Rjc4SCxnQkFBZ0IyL0gsTUFBTUM7SUFDeEIsT0FBTztRQUNMQSxJQUFJNEIsY0FBYztJQUNwQjtBQUNGO0FBQ0F0RCxLQUFLcUQsYUFBYSxHQUFHLFNBQVUzQixHQUFHO0lBQ2hDLElBQUl0NkksUUFBTyxJQUFJO0lBQ2YsSUFBSSs0SSxPQUFPdUIsSUFBSTlqSCxNQUFNO0lBQ3JCLElBQUk2akgsT0FBT3I2SSxNQUFLODRJLGVBQWUsQ0FBQ0M7SUFDaEMsSUFBSTlrRixTQUFTLElBQUksQ0FBQ0EsTUFBTTtJQUV4Qix5REFBeUQ7SUFFekR2NUMsZ0JBQWdCMi9ILE1BQU1DO0lBQ3RCQSxJQUFJbkIsT0FBTyxHQUFHO0lBRWQsK0NBQStDO0lBRS9DLElBQUlzQyxZQUFZbkIsSUFBSW1CLFNBQVM7SUFDN0IsSUFBSyxJQUFJNy9JLElBQUksR0FBR0EsSUFBSTYvSSxVQUFVcGlKLE1BQU0sRUFBRXVDLElBQUs7UUFDekMsSUFBSXErSSxXQUFXd0IsU0FBUyxDQUFDNy9JLEVBQUU7UUFDM0JxNEQsT0FBT3VpRixXQUFXLENBQUN5RCxTQUFTMS9JLEdBQUcsRUFBRTAvSSxTQUFTcnpDLEtBQUs7SUFDakQ7SUFDQTlyRixXQUFXMmdJO0lBRVgsc0VBQXNFO0lBRXRFLElBQUlyQyxTQUFTcDVJLE1BQUtpNUksc0JBQXNCLENBQUNGO0lBQ3pDSyxPQUFPdjlJLElBQUksQ0FBQ3krSTtBQUNkO0FBQ0ExQixLQUFLNkIsVUFBVSxHQUFHLFNBQVUxQixJQUFJLEVBQUVvRCxJQUFJO0lBQ3BDLElBQUluOEksUUFBTyxJQUFJO0lBQ2YsSUFBSXE2SSxPQUFPcjZJLE1BQUs4NEksZUFBZSxDQUFDQztJQUNoQyxJQUFJdUIsTUFBTSxDQUFDO0lBQ1hELEtBQUt4K0ksSUFBSSxDQUFDeStJO0lBQ1ZBLElBQUltQixTQUFTLEdBQUcsRUFBRTtJQUNsQm5CLElBQUk5akgsTUFBTSxHQUFHdWlIO0lBQ2J1QixJQUFJL2pILEtBQUssR0FBR3A0QixLQUFLNlUsR0FBRyxDQUFDa2tJLGFBQWFpRjtJQUNsQzdCLElBQUlJLFNBQVMsR0FBRztJQUNoQkosSUFBSUYsZ0JBQWdCLEdBQUc7SUFDdkJFLElBQUk0QixjQUFjLEdBQUc7SUFDckI1QixJQUFJcmdCLE1BQU0sR0FBR2o2SCxNQUFLbW5FLFFBQVEsQ0FBQ2kxRSxtQkFBbUIsQ0FBQzlCLElBQUkvakgsS0FBSyxFQUFFK2pILElBQUk5akgsTUFBTTtJQUNwRThqSCxJQUFJN3FFLE9BQU8sR0FBRzZxRSxJQUFJcmdCLE1BQU0sQ0FBQ0ssVUFBVSxDQUFDO0lBQ3BDLE9BQU9nZ0I7QUFDVDtBQUNBMUIsS0FBSzRCLGNBQWMsR0FBRyxTQUFVekIsSUFBSSxFQUFFb0QsSUFBSTtJQUN4QyxJQUFJbjhJLFFBQU8sSUFBSTtJQUNmLElBQUlxNkksT0FBT3I2SSxNQUFLODRJLGVBQWUsQ0FBQ0M7SUFDaEMsSUFBSUssU0FBU3A1SSxNQUFLaTVJLHNCQUFzQixDQUFDRjtJQUN6QyxJQUFLLElBQUluOUksSUFBSSxHQUFHQSxJQUFJdzlJLE9BQU8vL0ksTUFBTSxFQUFFdUMsSUFBSztRQUN0QyxJQUFJMCtJLE1BQU1sQixNQUFNLENBQUN4OUksRUFBRTtRQUNuQixJQUFJMCtJLElBQUkvakgsS0FBSyxJQUFJNGxILE1BQU07WUFDckI3QixJQUFJbkIsT0FBTyxHQUFHO1lBQ2RtQixJQUFJSSxTQUFTLEdBQUc7WUFDaEJKLElBQUlGLGdCQUFnQixHQUFHO1lBQ3ZCRSxJQUFJNEIsY0FBYyxHQUFHO1lBQ3JCcGhJLFdBQVd3L0gsSUFBSW1CLFNBQVM7WUFDeEJuQixJQUFJN3FFLE9BQU8sQ0FBQzByRSxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1lBQ3hDYixJQUFJN3FFLE9BQU8sQ0FBQzJyRSxTQUFTLENBQUMsR0FBRyxHQUFHZCxJQUFJL2pILEtBQUssRUFBRStqSCxJQUFJOWpILE1BQU07WUFDakQ5YixnQkFBZ0IwK0gsUUFBUWtCO1lBQ3hCRCxLQUFLeCtJLElBQUksQ0FBQ3krSTtZQUNWLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGO0FBQ0ExQixLQUFLeUMsWUFBWSxHQUFHLFNBQVUxZ0ksR0FBRyxFQUFFdTdILEdBQUc7SUFDcEMsSUFBSWwySSxRQUFPLElBQUk7SUFDZixJQUFJNkMsSUFBSTdDLE1BQUtxNUksZUFBZTtJQUM1QixJQUFJSSxNQUFNejVJLE1BQUt3NUksb0JBQW9CO0lBQ25DLElBQUlqL0ksTUFBTSxJQUFJLENBQUMydkUsTUFBTSxDQUFDdnZEO0lBQ3RCLElBQUkwaEksY0FBYzVDLEdBQUcsQ0FBQ2wvSSxJQUFJO0lBQzFCLElBQUk4aEosYUFBYTtRQUNmLHdEQUF3RDtRQUN4REEsWUFBWXoxQyxLQUFLLEdBQUd6b0csS0FBSzZVLEdBQUcsQ0FBQ3FwSSxZQUFZejFDLEtBQUssRUFBRXN2QztRQUNoRG1HLFlBQVkzMUgsSUFBSSxDQUFDd0MsS0FBSyxDQUFDdk87UUFDdkIwaEksWUFBWTlDLElBQUk7UUFDaEIxMkksRUFBRWdoQixVQUFVLENBQUN3NEg7SUFDZixPQUFPO1FBQ0wsSUFBSUMsTUFBTTtZQUNSNTFILE1BQU0vTCxJQUFJNE4sS0FBSyxHQUFHVyxLQUFLLENBQUN2TztZQUN4QmlzRixPQUFPc3ZDO1lBQ1BxRCxNQUFNO1lBQ05oL0ksS0FBS0E7UUFDUDtRQUNBc0ksRUFBRWhILElBQUksQ0FBQ3lnSjtRQUNQN0MsR0FBRyxDQUFDbC9JLElBQUksR0FBRytoSjtJQUNiO0FBQ0Y7QUFDQTFELEtBQUt0c0MsT0FBTyxHQUFHLFNBQVUzZSxRQUFRLFVBQVUsR0FBWDtJQUM5QixJQUFJM3RGLFFBQU8sSUFBSTtJQUNmLElBQUk2QyxJQUFJN0MsTUFBS3E1SSxlQUFlO0lBQzVCLElBQUlJLE1BQU16NUksTUFBS3c1SSxvQkFBb0I7SUFDbkMsSUFBSStDLFdBQVcsRUFBRTtJQUNqQixJQUFJdG9GLFNBQVNqMEQsTUFBS2kwRCxNQUFNO0lBQ3hCLElBQUssSUFBSXI0RCxJQUFJLEdBQUdBLElBQUlpOEksY0FBY2o4SSxJQUFLO1FBQ3JDLElBQUlpSCxFQUFFcVosSUFBSSxLQUFLLEdBQUc7WUFDaEIsSUFBSW9nSSxNQUFNejVJLEVBQUU0ZSxHQUFHO1lBQ2YsSUFBSWxuQixNQUFNK2hKLElBQUkvaEosR0FBRztZQUNqQixJQUFJb2dCLE1BQU0yaEksSUFBSTUxSCxJQUFJLENBQUMsRUFBRSxFQUFFLDZCQUE2QjtZQUNwRCxJQUFJODFILGNBQWN2b0YsT0FBT3FpRixRQUFRLENBQUMzN0gsS0FBSzJoSSxJQUFJMTFDLEtBQUs7WUFFaEQsa0NBQWtDO1lBQ2xDNnlDLEdBQUcsQ0FBQ2wvSSxJQUFJLEdBQUc7WUFFWCxvREFBb0Q7WUFDcEQsSUFBSWlpSixhQUFhO2dCQUNmO1lBQ0Y7WUFDQUQsU0FBUzFnSixJQUFJLENBQUN5Z0o7WUFDZCxJQUFJem9ILEtBQUs3ekIsTUFBS200SSxjQUFjLENBQUN4OUg7WUFDN0IzYSxNQUFLMjVJLFVBQVUsQ0FBQ2gvSCxLQUFLa1osSUFBSTg1RCxTQUFTMnVELElBQUkxMUMsS0FBSyxFQUFFa3hDLGNBQWN4ckMsT0FBTztRQUNwRSxPQUFPO1lBQ0w7UUFDRjtJQUNGO0lBQ0EsT0FBT2l3QztBQUNUO0FBQ0EzRCxLQUFLb0QsZUFBZSxHQUFHLFNBQVVyaEksR0FBRztJQUNsQyxJQUFJM2EsUUFBTyxJQUFJO0lBQ2YsSUFBSTZDLElBQUk3QyxNQUFLcTVJLGVBQWU7SUFDNUIsSUFBSUksTUFBTXo1SSxNQUFLdzVJLG9CQUFvQjtJQUNuQyxJQUFJai9JLE1BQU0sSUFBSSxDQUFDMnZFLE1BQU0sQ0FBQ3Z2RDtJQUN0QixJQUFJMmhJLE1BQU03QyxHQUFHLENBQUNsL0ksSUFBSTtJQUNsQixJQUFJK2hKLE9BQU8sTUFBTTtRQUNmLElBQUlBLElBQUk1MUgsSUFBSSxDQUFDcnRCLE1BQU0sS0FBSyxHQUFHO1lBQ3pCLGdDQUFnQztZQUNoQywwQkFBMEI7WUFDMUJpakosSUFBSS9DLElBQUksR0FBR3hnSTtZQUNYbFcsRUFBRWdoQixVQUFVLENBQUN5NEg7WUFDYno1SSxFQUFFNGUsR0FBRyxJQUFJLG9CQUFvQjtZQUU3Qmc0SCxHQUFHLENBQUNsL0ksSUFBSSxHQUFHLE1BQU0seUJBQXlCO1FBQzVDLE9BQU87WUFDTCxxQ0FBcUM7WUFDckMraEosSUFBSTUxSCxJQUFJLENBQUM2c0QsT0FBTyxDQUFDNTREO1FBQ25CO0lBQ0Y7QUFDRjtBQUNBaStILEtBQUs2RCxTQUFTLEdBQUcsU0FBVS8rSSxFQUFFO0lBQzNCLElBQUksQ0FBQ2k3SSxVQUFVLENBQUM5OEksSUFBSSxDQUFDNkI7QUFDdkI7QUFDQWs3SSxLQUFLOEQsVUFBVSxHQUFHLFNBQVVoL0ksRUFBRTtJQUM1QmdkLGdCQUFnQixJQUFJLENBQUNpK0gsVUFBVSxFQUFFajdJO0FBQ25DO0FBQ0FrN0ksS0FBSy9FLGVBQWUsR0FBR0QsS0FBS0MsZUFBZSxDQUFDO0lBQzFDSSxvQkFBb0IyRDtJQUNwQmxELFNBQVM4QztJQUNUN0MsWUFBWThDO0lBQ1o3QyxlQUFlOEM7SUFDZmpELGFBQWFrRDtJQUNiN0MsS0FBSyxTQUFTQSxJQUFJOTBJLEtBQUksRUFBRTJ0RixPQUFPLEVBQUVpYSxNQUFNO1FBQ3JDLE9BQU81bkcsTUFBS3NzRyxPQUFPLENBQUMzZSxTQUFTaWE7SUFDL0I7SUFDQW10QyxRQUFRLFNBQVNBLE9BQU8vMEksS0FBSSxFQUFFcTBJLElBQUk7UUFDaEMsSUFBSyxJQUFJejRJLElBQUksR0FBR0EsSUFBSW9FLE1BQUsyNEksVUFBVSxDQUFDdC9JLE1BQU0sRUFBRXVDLElBQUs7WUFDL0MsSUFBSThCLEtBQUtzQyxNQUFLMjRJLFVBQVUsQ0FBQy84SSxFQUFFO1lBQzNCOEIsR0FBRzIySTtRQUNMO0lBQ0Y7SUFDQVcsY0FBYyxTQUFTQSxhQUFhaDFJLEtBQUksRUFBRXEwSSxJQUFJLEVBQUUxbUQsT0FBTyxFQUFFaWEsTUFBTTtRQUM3RCxJQUFLLElBQUloc0csSUFBSSxHQUFHQSxJQUFJeTRJLEtBQUtoN0ksTUFBTSxFQUFFdUMsSUFBSztZQUNwQyxJQUFJOHFCLE9BQU8ydEgsSUFBSSxDQUFDejRJLEVBQUUsQ0FBQzhxQixJQUFJO1lBQ3ZCLElBQUssSUFBSXprQixJQUFJLEdBQUdBLElBQUl5a0IsS0FBS3J0QixNQUFNLEVBQUU0SSxJQUFLO2dCQUNwQyxJQUFJNHhCLEtBQUtuTixJQUFJLENBQUN6a0IsRUFBRSxDQUFDakQsV0FBVztnQkFDNUIsSUFBSTQxQix1QkFBdUJmLElBQUkrekUsU0FBUztvQkFDdEMsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFDQXVwQyxVQUFVLFNBQVNBLFNBQVNueEksS0FBSTtRQUM5QixPQUFPQSxNQUFLbW5FLFFBQVEsQ0FBQzRqQixzQkFBc0IsQ0FBQ29vRCxTQUFTO0lBQ3ZEO0FBQ0Y7QUFFQSxJQUFJd0osZUFBZSxHQUFHLGtDQUFrQztBQUN4RCxJQUFJQyxTQUFTLENBQUMsR0FBRyw0REFBNEQ7QUFDN0UsSUFBSUMsU0FBUyxHQUFHLDRFQUE0RTtBQUM1RixJQUFJdnpELFVBQVUsTUFBTSx3REFBd0Q7QUFDNUUsSUFBSTJxRCxxQkFBcUIsSUFBSSwyR0FBMkc7QUFDeEksSUFBSTZJLHdCQUF3QixJQUFJLCtDQUErQztBQUMvRSxJQUFJcEksVUFBVSxNQUFNLHdFQUF3RTtBQUM1RixJQUFJQyxhQUFhLEtBQUssb0VBQW9FO0FBQzFGLElBQUlDLGdCQUFnQixLQUFLLHVFQUF1RTtBQUNoRyxJQUFJSCxjQUFjLEtBQUsseUNBQXlDO0FBQ2hFLElBQUlzSSxhQUFhLEdBQUcsdUVBQXVFO0FBQzNGLElBQUlDLG1CQUFtQixLQUFLLG9EQUFvRDtBQUNoRixJQUFJQyxlQUFlLE9BQU8sTUFBTSxtQ0FBbUM7QUFDbkUsSUFBSUMsY0FBYyxPQUFPLHNEQUFzRDtBQUMvRSxJQUFJQywyQkFBMkIsTUFBTSw4RkFBOEY7QUFFbkksb0VBQW9FO0FBRXBFLElBQUlDLHNCQUFzQixTQUFTQSxvQkFBb0JqMkUsUUFBUTtJQUM3RCxJQUFJbm5FLFFBQU8sSUFBSTtJQUNmLElBQUk3RyxJQUFJNkcsTUFBS21uRSxRQUFRLEdBQUdBO0lBQ3hCLElBQUl2cUQsS0FBS3pqQixFQUFFeWpCLEVBQUU7SUFDYjVjLE1BQUtxOUksYUFBYSxHQUFHLENBQUMsR0FBRyw0Q0FBNEM7SUFFckVyOUksTUFBS3M5SSxRQUFRLEdBQUc7SUFDaEJ0OUksTUFBS3U5SSxvQkFBb0IsR0FBRzluSSxtQkFBbUIsSUFBSXVuSTtJQUNuRGg5SSxNQUFLdzlJLFFBQVEsR0FBRztJQUNoQng5SSxNQUFLeTlJLFVBQVUsR0FBRzdnSSxHQUFHcmUsVUFBVTtJQUMvQnlCLE1BQUswOUkseUJBQXlCLEdBQUd2cUksU0FBUztRQUN4Q25ULE1BQUsyOUkscUJBQXFCLENBQUMzOUksTUFBS3k5SSxVQUFVO1FBQzFDejlJLE1BQUt5OUksVUFBVSxDQUFDbHFFLE9BQU8sQ0FBQ3Z6RSxNQUFLeTlJLFVBQVU7SUFDekMsR0FBR1g7SUFDSDNqSixFQUFFeXhGLFlBQVksQ0FBQyxTQUFVRSxRQUFRLEVBQUU5N0UsR0FBRztRQUNwQyxJQUFJQSxNQUFNaFAsTUFBS3U5SSxvQkFBb0IsSUFBSVAsa0JBQWtCO1lBQ3ZEaDlJLE1BQUt3OUksUUFBUSxHQUFHO1FBQ2xCLE9BQU87WUFDTHg5SSxNQUFLdzlJLFFBQVEsR0FBRztRQUNsQjtJQUNGLEdBQUdya0osRUFBRTR4RixzQkFBc0IsQ0FBQ3NvRCxVQUFVO0lBQ3RDLElBQUl1SyxRQUFRLFNBQVNBLE1BQU14a0osQ0FBQyxFQUFFc0ksQ0FBQztRQUM3QixPQUFPQSxFQUFFNjNJLElBQUksR0FBR25nSixFQUFFbWdKLElBQUk7SUFDeEI7SUFDQXY1SSxNQUFLNjlJLFdBQVcsR0FBRyxJQUFJMTZILEtBQUt5Nkg7SUFDNUI1OUksTUFBSzZ6SSxlQUFlO0FBQ3RCO0FBQ0EsSUFBSWlLLE9BQU9WLG9CQUFvQjNpSixTQUFTO0FBQ3hDLElBQUlzakosY0FBYztBQUNsQixJQUFJQyxVQUFVNy9JLEtBQUs2eEIsR0FBRyxDQUFDLEdBQUcsTUFBTTtBQUNoQzh0SCxLQUFLRyxTQUFTLEdBQUcsU0FBVXBxSCxFQUFFLEVBQUVxaUgsR0FBRztJQUNoQyxJQUFJN2dILFFBQVFsM0IsS0FBSzZ4QixHQUFHLENBQUMsR0FBR2ttSDtJQUN4QixJQUFJNTlILElBQUluYSxLQUFLNHhCLElBQUksQ0FBQzhELEdBQUd2YixDQUFDLEdBQUcrYztJQUN6QixJQUFJM3lCLElBQUl2RSxLQUFLNHhCLElBQUksQ0FBQzhELEdBQUdueEIsQ0FBQyxHQUFHMnlCO0lBQ3pCLElBQUk0a0csU0FBUyxJQUFJLENBQUM5eUQsUUFBUSxDQUFDaTFFLG1CQUFtQixDQUFDOWpJLEdBQUc1VjtJQUNsRCxJQUFJdzdJLFFBQVE7UUFDVjc4SCxJQUFJMDhILGNBQWMsRUFBRUEsY0FBY0M7UUFDbENucUgsSUFBSUE7UUFDSit5RSxPQUFPc3ZDO1FBQ1AzL0csT0FBT2plO1FBQ1BrZSxRQUFROXpCO1FBQ1J1M0gsUUFBUUE7UUFDUnhxRCxTQUFTd3FELE9BQU9LLFVBQVUsQ0FBQztRQUMzQjV6RyxNQUFNLEVBQUU7UUFDUnkzSCxXQUFXLEVBQUU7UUFDYjVFLE1BQU07SUFDUjtJQUVBLHdHQUF3RztJQUV4RyxJQUFJdnBELE1BQU1rdUQsTUFBTXp1RSxPQUFPO0lBQ3ZCLElBQUl4OEMsS0FBSyxDQUFDaXJILE1BQU1ycUgsRUFBRSxDQUFDNTBCLEVBQUU7SUFDckIsSUFBSWkwQixLQUFLLENBQUNnckgsTUFBTXJxSCxFQUFFLENBQUMxMEIsRUFBRTtJQUVyQiwyRUFBMkU7SUFDM0U2d0YsSUFBSTM2RCxLQUFLLENBQUNBLE9BQU9BO0lBQ2pCMjZELElBQUl3ckQsU0FBUyxDQUFDdm9ILElBQUlDO0lBQ2xCLE9BQU9nckg7QUFDVDtBQUNBSixLQUFLTSxTQUFTLEdBQUcsU0FBVTEzSCxJQUFJLEVBQUVpbkUsT0FBTyxFQUFFdW9ELEdBQUc7SUFDM0MsSUFBSWwySSxRQUFPLElBQUk7SUFDZixJQUFJN0csSUFBSTZHLE1BQUttbkUsUUFBUTtJQUNyQixJQUFJdnFELEtBQUt6akIsRUFBRXlqQixFQUFFO0lBQ2IsSUFBSWlELE9BQU9qRCxHQUFHaUQsSUFBSTtJQUNsQixJQUFJeTlILFdBQVd0OUksTUFBS3M5SSxRQUFRO0lBQzVCdDlJLE1BQUtzOUksUUFBUSxHQUFHO0lBRWhCLG1EQUFtRDtJQUNuRCxtREFBbUQ7SUFFbkQsSUFBSXBILE9BQU8sTUFBTTtRQUNmQSxNQUFNLzNJLEtBQUs0eEIsSUFBSSxDQUFDNkMsS0FBSy9TLE9BQU84dEU7UUFDNUIsSUFBSXVvRCxNQUFNMEcsUUFBUTtZQUNoQjFHLE1BQU0wRztRQUNSLE9BQU8sSUFBSS84SCxRQUFReXBFLFdBQVc0c0QsTUFBTTJHLFFBQVE7WUFDMUMsT0FBTztRQUNUO0lBQ0Y7SUFDQTc4SSxNQUFLcStJLDBCQUEwQixDQUFDbkksS0FBS3h2SDtJQUNyQyxJQUFJNDNILGNBQWN0K0ksTUFBS3E5SSxhQUFhO0lBQ3BDLElBQUlob0gsUUFBUWwzQixLQUFLNnhCLEdBQUcsQ0FBQyxHQUFHa21IO0lBQ3hCLElBQUlxSSxTQUFTRCxXQUFXLENBQUNwSSxJQUFJLEdBQUdvSSxXQUFXLENBQUNwSSxJQUFJLElBQUksRUFBRTtJQUN0RCxJQUFJcmlIO0lBQ0osSUFBSTJxSCxjQUFjeCtJLE1BQUt5K0ksZUFBZSxDQUFDdkksS0FBS3h2SDtJQUM1QyxJQUFJZzRIO0lBQ0osSUFBSUMsa0JBQWtCLFNBQVNBO1FBQzdCLElBQUlDLGlCQUFpQixTQUFTQSxlQUFlampKLENBQUM7WUFDNUNxRSxNQUFLcStJLDBCQUEwQixDQUFDMWlKLEdBQUcrcUI7WUFDbkMsSUFBSTFtQixNQUFLeStJLGVBQWUsQ0FBQzlpSixHQUFHK3FCLE9BQU87Z0JBQ2pDZzRILFlBQVlKLFdBQVcsQ0FBQzNpSixFQUFFO2dCQUMxQixPQUFPO1lBQ1Q7UUFDRjtRQUNBLElBQUlrakosWUFBWSxTQUFTQSxVQUFVQyxHQUFHO1lBQ3BDLElBQUlKLFdBQVc7Z0JBQ2I7WUFDRjtZQUNBLElBQUssSUFBSS9pSixJQUFJdTZJLE1BQU00SSxLQUFLbEMsVUFBVWpoSixLQUFLQSxLQUFLa2hKLFFBQVFsaEosS0FBS21qSixJQUFLO2dCQUM1RCxJQUFJRixlQUFlampKLElBQUk7b0JBQ3JCO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBa2pKLFVBQVU7UUFDVkEsVUFBVSxDQUFDO1FBRVgsb0ZBQW9GO1FBQ3BGLElBQUssSUFBSWpqSixJQUFJMmlKLE9BQU9sbEosTUFBTSxHQUFHLEdBQUd1QyxLQUFLLEdBQUdBLElBQUs7WUFDM0MsSUFBSXNpSixRQUFRSyxNQUFNLENBQUMzaUosRUFBRTtZQUNyQixJQUFJc2lKLE1BQU1qakYsT0FBTyxFQUFFO2dCQUNqQnZnRCxnQkFBZ0I2akksUUFBUUw7WUFDMUI7UUFDRjtJQUNGO0lBQ0EsSUFBSSxDQUFDTSxhQUFhO1FBQ2hCLDhGQUE4RjtRQUM5RixtRkFBbUY7UUFFbkZHO0lBQ0YsT0FBTztRQUNMLG9EQUFvRDtRQUNwRCxPQUFPSjtJQUNUO0lBQ0EsSUFBSVEsUUFBUSxTQUFTQTtRQUNuQixJQUFJLENBQUNsckgsSUFBSTtZQUNQQSxLQUFLRDtZQUNMLElBQUssSUFBSWg0QixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO2dCQUNwQ280QixrQkFBa0JILElBQUluTixJQUFJLENBQUM5cUIsRUFBRSxDQUFDb0QsV0FBVztZQUMzQztRQUNGO1FBQ0EsT0FBTzYwQjtJQUNUO0lBQ0EsSUFBSW9xSCxZQUFZLFNBQVNBLFVBQVUxakksSUFBSTtRQUNyQ0EsT0FBT0EsUUFBUSxDQUFDO1FBQ2hCLElBQUl5a0ksUUFBUXprSSxLQUFLeWtJLEtBQUs7UUFDdEJEO1FBQ0EsSUFBSXptSSxJQUFJbmEsS0FBSzR4QixJQUFJLENBQUM4RCxHQUFHdmIsQ0FBQyxHQUFHK2M7UUFDekIsSUFBSTN5QixJQUFJdkUsS0FBSzR4QixJQUFJLENBQUM4RCxHQUFHbnhCLENBQUMsR0FBRzJ5QjtRQUN6QixJQUFJL2MsSUFBSTRrSSxlQUFleDZJLElBQUl3NkksYUFBYTtZQUN0QyxPQUFPO1FBQ1Q7UUFDQSxJQUFJK0IsT0FBTzNtSSxJQUFJNVY7UUFDZixJQUFJdThJLE9BQU9oQyxjQUFjO1lBQ3ZCLE9BQU87UUFDVDtRQUNBLElBQUlpQixRQUFRbCtJLE1BQUtpK0ksU0FBUyxDQUFDcHFILElBQUlxaUg7UUFDL0IsSUFBSThJLFNBQVMsTUFBTTtZQUNqQixJQUFJenZJLFFBQVFndkksT0FBT3g1SCxPQUFPLENBQUNpNkgsU0FBUztZQUNwQ1QsT0FBTzFqSSxNQUFNLENBQUN0TCxPQUFPLEdBQUcydUk7UUFDMUIsT0FBTyxJQUFJM2pJLEtBQUt1TCxNQUFNLEtBQUsxcEIsYUFBYW1lLEtBQUt1TCxNQUFNLEVBQUU7WUFDbkQseURBQXlEO1lBQ3pEeTRILE9BQU9qOUgsT0FBTyxDQUFDNDhIO1FBQ2pCO1FBRUEsbUJBQW1CO1FBQ25CLDJCQUEyQjtRQUMzQixJQUFJO1FBRUosT0FBT0E7SUFDVDtJQUNBLElBQUlsK0ksTUFBS3c5SSxRQUFRLElBQUksQ0FBQ0YsVUFBVTtRQUM5QixzQkFBc0I7UUFDdEIsT0FBTztJQUNUO0lBRUEsb0JBQW9CO0lBRXBCLElBQUlZLFFBQVE7SUFDWixJQUFJZ0Isa0JBQWtCeDRILEtBQUtydEIsTUFBTSxHQUFHc2pKO0lBQ3BDLElBQUl3QyxvQkFBb0IsQ0FBQzdCO0lBQ3pCLElBQUssSUFBSTFoSixJQUFJLEdBQUdBLElBQUk4cUIsS0FBS3J0QixNQUFNLEVBQUV1QyxJQUFLO1FBQ3BDLElBQUkrZSxNQUFNK0wsSUFBSSxDQUFDOXFCLEVBQUU7UUFDakIsSUFBSTRpSCxLQUFLN2pHLElBQUluYyxRQUFRLENBQUNrZ0IsUUFBUTtRQUM5QixJQUFJeTNILFNBQVMzM0IsR0FBRzRnQyxjQUFjLEdBQUc1Z0MsR0FBRzRnQyxjQUFjLElBQUksQ0FBQztRQUV2RCxnQ0FBZ0M7UUFFaEMsSUFBSUMsZ0JBQWdCbEosTUFBTSxDQUFDRCxJQUFJO1FBQy9CLElBQUltSixlQUFlO1lBQ2pCLDZCQUE2QjtZQUM3QixvQ0FBb0M7WUFDcENuQixRQUFRbUI7WUFDUjtRQUNGO1FBQ0EsSUFBSSxDQUFDbkIsU0FBU0EsTUFBTXgzSCxJQUFJLENBQUNydEIsTUFBTSxJQUFJNmxKLG1CQUFtQixDQUFDbHFILHlCQUF5QmtwSCxNQUFNcnFILEVBQUUsRUFBRWxaLElBQUkzYixXQUFXLEtBQUs7WUFDNUcsOENBQThDO1lBRTlDay9JLFFBQVFELFVBQVU7Z0JBQ2hCbjRILFFBQVE7Z0JBQ1JrNUgsT0FBT2Q7WUFDVDtZQUVBLG1FQUFtRTtZQUNuRSxJQUFJLENBQUNBLE9BQU87Z0JBQ1YsT0FBTztZQUNUO1FBRUEseUNBQXlDO1FBQzNDO1FBQ0EsSUFBSVEsYUFBYVMsbUJBQW1CO1lBQ2xDLHVEQUF1RDtZQUN2RG4vSSxNQUFLcy9JLFVBQVUsQ0FBQ3BCLE9BQU92akk7UUFDekIsT0FBTztZQUNMLHNEQUFzRDtZQUN0RDNhLE1BQUt1L0ksY0FBYyxDQUFDckIsT0FBT3ZqSSxLQUFLdTdILEtBQUt2b0Q7UUFDdkM7UUFDQXV3RCxNQUFNeDNILElBQUksQ0FBQzdxQixJQUFJLENBQUM4ZTtRQUNoQnc3SCxNQUFNLENBQUNELElBQUksR0FBR2dJO0lBQ2hCO0lBRUEsYUFBYTtJQUViLElBQUlRLFdBQVc7UUFDYixpRUFBaUU7UUFDakUsT0FBT0E7SUFDVDtJQUNBLElBQUlTLG1CQUFtQjtRQUNyQixnQ0FBZ0M7UUFDaEMsT0FBTztJQUNUO0lBQ0EsT0FBT1o7QUFDVDtBQUVBLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkRULEtBQUswQix3QkFBd0IsR0FBRyxTQUFVdEosR0FBRyxFQUFFdm9ELE9BQU87SUFDcEQsT0FBT3VvRDtBQUNUO0FBQ0E0SCxLQUFLeUIsY0FBYyxHQUFHLFNBQVVyQixLQUFLLEVBQUV2akksR0FBRyxFQUFFdTdILEdBQUcsRUFBRXZvRCxPQUFPO0lBQ3RELElBQUkzdEYsUUFBTyxJQUFJO0lBQ2YsSUFBSTdHLElBQUksSUFBSSxDQUFDZ3VFLFFBQVE7SUFDckIsSUFBSXNJLFVBQVV5dUUsTUFBTXp1RSxPQUFPO0lBQzNCLElBQUk1N0MsS0FBS2xaLElBQUkzYixXQUFXO0lBQ3hCLElBQUk2MEIsR0FBR3ZiLENBQUMsS0FBSyxLQUFLdWIsR0FBR254QixDQUFDLEtBQUssS0FBSyxDQUFDaVksSUFBSWc1QyxPQUFPLElBQUk7UUFDOUM7SUFDRjtJQUNBdWlGLE1BQU1sMkksTUFBS3cvSSx3QkFBd0IsQ0FBQ3RKLEtBQUt2b0Q7SUFDekM7UUFDRXgwRixFQUFFc21KLGVBQWUsQ0FBQ2h3RSxTQUFTO0lBQzdCO0lBQ0E7UUFDRXQyRSxFQUFFdW1KLGlCQUFpQixDQUFDandFLFNBQVM5MEQsS0FBSyxNQUFNLE1BQU11N0gsS0FBS2lIO0lBQ3JEO0lBQ0E7UUFDRWhrSixFQUFFc21KLGVBQWUsQ0FBQ2h3RSxTQUFTO0lBQzdCO0FBQ0Y7QUFDQXF1RSxLQUFLVyxlQUFlLEdBQUcsU0FBVXZJLEdBQUcsRUFBRXh2SCxJQUFJO0lBQ3hDLElBQUkxbUIsUUFBTyxJQUFJO0lBQ2YsSUFBSXUrSSxTQUFTditJLE1BQUtxOUksYUFBYSxDQUFDbkgsSUFBSTtJQUNwQyxJQUFJLENBQUNxSSxVQUFVQSxPQUFPbGxKLE1BQU0sS0FBSyxHQUFHO1FBQ2xDLE9BQU87SUFDVDtJQUNBLElBQUlzbUosa0JBQWtCO0lBQ3RCLElBQUssSUFBSS9qSixJQUFJLEdBQUdBLElBQUkyaUosT0FBT2xsSixNQUFNLEVBQUV1QyxJQUFLO1FBQ3RDLElBQUlzaUosUUFBUUssTUFBTSxDQUFDM2lKLEVBQUU7UUFFckIsMEVBQTBFO1FBQzFFLElBQUlzaUosTUFBTTNFLElBQUksR0FBRyxHQUFHO1lBQ2xCLE9BQU87UUFDVDtRQUVBLHFEQUFxRDtRQUNyRCxJQUFJMkUsTUFBTWpqRixPQUFPLEVBQUU7WUFDakIsT0FBTztRQUNUO1FBQ0Ewa0YsbUJBQW1CekIsTUFBTXgzSCxJQUFJLENBQUNydEIsTUFBTTtJQUN0QztJQUVBLHFFQUFxRTtJQUNyRSxJQUFJc21KLG9CQUFvQmo1SCxLQUFLcnRCLE1BQU0sRUFBRTtRQUNuQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQXlrSixLQUFLTywwQkFBMEIsR0FBRyxTQUFVbkksR0FBRyxFQUFFeHZILElBQUk7SUFDbkQsSUFBSTYzSCxTQUFTLElBQUksQ0FBQ2xCLGFBQWEsQ0FBQ25ILElBQUk7SUFDcEMsSUFBSSxDQUFDcUksUUFBUTtRQUNYO0lBQ0Y7SUFFQSw4RUFBOEU7SUFDOUUsMERBQTBEO0lBRTFELElBQUssSUFBSTNpSixJQUFJLEdBQUdBLElBQUkyaUosT0FBT2xsSixNQUFNLEVBQUV1QyxJQUFLO1FBQ3RDLElBQUlzaUosUUFBUUssTUFBTSxDQUFDM2lKLEVBQUU7UUFDckIsSUFBSWsvQixTQUFTLENBQUM7UUFFZCxrQkFBa0I7UUFDbEIsSUFBSyxJQUFJNzRCLElBQUksR0FBR0EsSUFBSXlrQixLQUFLcnRCLE1BQU0sRUFBRTRJLElBQUs7WUFDcEMsSUFBSWk4SSxNQUFNeDNILElBQUksQ0FBQyxFQUFFLEtBQUtBLElBQUksQ0FBQ3prQixFQUFFLEVBQUU7Z0JBQzdCNjRCLFNBQVM3NEI7Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsSUFBSTY0QixTQUFTLEdBQUc7WUFDZCx5REFBeUQ7WUFDekQsSUFBSSxDQUFDOGtILGVBQWUsQ0FBQzFCO1lBQ3JCO1FBQ0Y7UUFFQSx3RkFBd0Y7UUFFeEYsSUFBSWxrSixJQUFJOGdDO1FBQ1IsSUFBSyxJQUFJNzRCLElBQUksR0FBR0EsSUFBSWk4SSxNQUFNeDNILElBQUksQ0FBQ3J0QixNQUFNLEVBQUU0SSxJQUFLO1lBQzFDLElBQUlpOEksTUFBTXgzSCxJQUFJLENBQUN6a0IsRUFBRSxLQUFLeWtCLElBQUksQ0FBQzFzQixJQUFJaUksRUFBRSxFQUFFO2dCQUNqQyxpREFBaUQ7Z0JBRWpELElBQUksQ0FBQzI5SSxlQUFlLENBQUMxQjtnQkFDckI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBSixLQUFLK0Isc0JBQXNCLEdBQUcsU0FBVW41SCxJQUFJLEVBQUUyNkMsTUFBTTtJQUNsRCxJQUFJcmhFLFFBQU8sSUFBSTtJQUNmLElBQUk0OEMsU0FBU3QrQyxRQUFRb29CLElBQUksQ0FBQyxFQUFFO0lBRTVCLHNFQUFzRTtJQUN0RSw2QkFBNkI7SUFDN0IsSUFBSyxJQUFJOXFCLElBQUksR0FBR0EsSUFBSThxQixLQUFLcnRCLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSTBnSixNQUFNMS9GLFNBQVMsT0FBT2wyQixJQUFJLENBQUM5cUIsRUFBRTtRQUNqQyxJQUFJK2UsTUFBTWlpQyxTQUFTbDJCLElBQUksQ0FBQzlxQixFQUFFLEdBQUc4cUIsSUFBSSxDQUFDOXFCLEVBQUUsQ0FBQytlLEdBQUc7UUFDeEMsSUFBSTZqRyxLQUFLN2pHLElBQUluYyxRQUFRLENBQUNrZ0IsUUFBUTtRQUM5QixJQUFJeTNILFNBQVMzM0IsR0FBRzRnQyxjQUFjLEdBQUc1Z0MsR0FBRzRnQyxjQUFjLElBQUksQ0FBQztRQUN2RCxJQUFLLElBQUl6akosSUFBSWloSixRQUFRamhKLEtBQUtraEosUUFBUWxoSixJQUFLO1lBQ3JDLElBQUl1aUosUUFBUS9ILE1BQU0sQ0FBQ3g2SSxFQUFFO1lBQ3JCLElBQUksQ0FBQ3VpSixPQUFPO2dCQUNWO1lBQ0Y7WUFFQSxrRUFBa0U7WUFDbEUscUJBQXFCO1lBQ3JCLElBQUk1QixPQUFPdDhJLE1BQUt3L0ksd0JBQXdCLENBQUN0QixNQUFNdDNDLEtBQUssTUFBTTAxQyxJQUFJMTFDLEtBQUssRUFBRTtnQkFDbkU7WUFDRjtZQUNBdmxDLE9BQU82OEUsT0FBT3ZqSSxLQUFLMmhJO1FBQ3JCO0lBQ0Y7QUFDRjtBQUNBd0IsS0FBS2dDLFVBQVUsR0FBRztJQUNoQixJQUFJOS9JLFFBQU8sSUFBSTtJQUNmLElBQUk4L0ksYUFBYTtJQUNqQixJQUFLLElBQUlua0osSUFBSWloSixRQUFRamhKLEtBQUtraEosUUFBUWxoSixJQUFLO1FBQ3JDLElBQUk0aUosU0FBU3YrSSxNQUFLcTlJLGFBQWEsQ0FBQzFoSixFQUFFO1FBQ2xDLElBQUk0aUosVUFBVUEsT0FBT2xsSixNQUFNLEdBQUcsR0FBRztZQUMvQnltSixhQUFhO1lBQ2I7UUFDRjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUNBaEMsS0FBS25DLGtCQUFrQixHQUFHLFNBQVVqMUgsSUFBSTtJQUN0QyxJQUFJMW1CLFFBQU8sSUFBSTtJQUNmLElBQUkwbUIsS0FBS3J0QixNQUFNLEtBQUssR0FBRztRQUNyQjtJQUNGO0lBQ0EyRyxNQUFLdTlJLG9CQUFvQixHQUFHOW5JO0lBRTVCLGlEQUFpRDtJQUVqRCxJQUFJaVIsS0FBS3J0QixNQUFNLEtBQUssS0FBSyxDQUFDMkcsTUFBSzgvSSxVQUFVLElBQUk7UUFDM0M7SUFDRjtJQUNBOS9JLE1BQUs2L0ksc0JBQXNCLENBQUNuNUgsTUFBTSxTQUFTcTVILGlCQUFpQjdCLEtBQUssRUFBRXZqSSxHQUFHLEVBQUUyaEksR0FBRztRQUN6RXQ4SSxNQUFLNC9JLGVBQWUsQ0FBQzFCO0lBQ3ZCO0FBQ0Y7QUFDQUosS0FBSzhCLGVBQWUsR0FBRyxTQUFVMUIsS0FBSztJQUNwQyx1Q0FBdUM7SUFFdkMsSUFBSSxDQUFDWCxvQkFBb0IsR0FBRzluSTtJQUM1QixJQUFJeW9JLE1BQU1qakYsT0FBTyxFQUFFO1FBQ2pCO0lBQ0YsRUFBRSxjQUFjO0lBRWhCLElBQUlpN0UsTUFBTWdJLE1BQU10M0MsS0FBSztJQUNyQixJQUFJbGdGLE9BQU93M0gsTUFBTXgzSCxJQUFJO0lBQ3JCLElBQUk2M0gsU0FBUyxJQUFJLENBQUNsQixhQUFhLENBQUNuSCxJQUFJO0lBRXBDLHNDQUFzQztJQUV0Q3g3SCxnQkFBZ0I2akksUUFBUUw7SUFDeEIsbUJBQW1CO0lBRW5CQSxNQUFNQyxTQUFTLEdBQUcsRUFBRTtJQUNwQkQsTUFBTWpqRixPQUFPLEdBQUc7SUFDaEIsSUFBSWlqRixNQUFNOEIsV0FBVyxFQUFFO1FBQ3JCOUIsTUFBTThCLFdBQVcsQ0FBQy9rRixPQUFPLEdBQUc7SUFDOUI7SUFDQSxJQUFLLElBQUlyL0QsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJdTZJLFNBQVN6dkgsSUFBSSxDQUFDOXFCLEVBQUUsQ0FBQzRDLFFBQVEsQ0FBQ2tnQixRQUFRLENBQUMwZ0ksY0FBYztRQUNyRCxJQUFJakosUUFBUTtZQUNWQSxNQUFNLENBQUNELElBQUksR0FBRztRQUNoQjtJQUNGO0FBQ0Y7QUFDQTRILEtBQUtILHFCQUFxQixHQUFHLFNBQVVqM0gsSUFBSTtJQUN6QyxJQUFJMW1CLFFBQU8sSUFBSTtJQUVmLDhCQUE4QjtJQUU5QkEsTUFBSzYvSSxzQkFBc0IsQ0FBQ241SCxNQUFNLFNBQVN1NUgsY0FBYy9CLEtBQUssRUFBRXZqSSxHQUFHLEVBQUUyaEksR0FBRztRQUN0RSxJQUFJNEQsT0FBT2hDLE1BQU04QixXQUFXO1FBQzVCLElBQUksQ0FBQ0UsTUFBTTtZQUNUQSxPQUFPaEMsTUFBTThCLFdBQVcsR0FBR2hnSixNQUFLaStJLFNBQVMsQ0FBQ0MsTUFBTXJxSCxFQUFFLEVBQUVxcUgsTUFBTXQzQyxLQUFLO1lBQy9EczVDLEtBQUtDLFFBQVEsR0FBR2pDO1lBQ2hCZ0MsS0FBS3g1SCxJQUFJLEdBQUd3M0gsTUFBTXgzSCxJQUFJO1FBRXRCLHdGQUF3RjtRQUMxRjtRQUNBLElBQUksQ0FBQ3c1SCxLQUFLM0csSUFBSSxFQUFFO1lBQ2QsSUFBSyxJQUFJMzlJLElBQUksR0FBR0EsSUFBSXNrSixLQUFLeDVILElBQUksQ0FBQ3J0QixNQUFNLEVBQUV1QyxJQUFLO2dCQUN6Q29FLE1BQUtzL0ksVUFBVSxDQUFDWSxNQUFNQSxLQUFLeDVILElBQUksQ0FBQzlxQixFQUFFO1lBQ3BDO1FBRUEsc0RBQXNEO1FBQ3hEO0lBQ0Y7QUFDRjtBQUNBa2lKLEtBQUtzQyx3QkFBd0IsR0FBRyxTQUFVemxJLEdBQUc7SUFDM0MsSUFBSSxDQUFDOGlJLFVBQVUsQ0FBQ3YwSCxLQUFLLENBQUN2TztJQUN0QixJQUFJLENBQUMraUkseUJBQXlCO0FBQ2hDO0FBQ0FJLEtBQUt3QixVQUFVLEdBQUcsU0FBVXBCLEtBQUssRUFBRXZqSSxHQUFHO0lBQ3BDLElBQUkzYSxRQUFPLElBQUk7SUFDZixJQUFJNkMsSUFBSTdDLE1BQUs2OUksV0FBVztJQUN4QixJQUFJd0MsUUFBUW5DLE1BQU1DLFNBQVM7SUFDM0IsSUFBSW1DLFFBQVFELE1BQU1DLEtBQUssR0FBR0QsTUFBTUMsS0FBSyxJQUFJLENBQUM7SUFFMUMsaUVBQWlFO0lBQ2pFLElBQUlwQyxNQUFNOEIsV0FBVyxFQUFFO1FBQ3JCO0lBQ0Y7SUFDQSxJQUFJcmxJLEtBQUs7UUFDUCxJQUFJMmxJLEtBQUssQ0FBQzNsSSxJQUFJMEcsRUFBRSxHQUFHLEVBQUU7WUFDbkI7UUFDRjtRQUNBZy9ILE1BQU14a0osSUFBSSxDQUFDOGU7UUFDWDJsSSxLQUFLLENBQUMzbEksSUFBSTBHLEVBQUUsR0FBRyxHQUFHO0lBQ3BCO0lBQ0EsSUFBSTY4SCxNQUFNM0UsSUFBSSxFQUFFO1FBQ2QyRSxNQUFNM0UsSUFBSTtRQUNWMTJJLEVBQUVnaEIsVUFBVSxDQUFDcTZIO0lBQ2YsT0FBTztRQUNMQSxNQUFNM0UsSUFBSSxHQUFHO1FBQ2IxMkksRUFBRWhILElBQUksQ0FBQ3FpSjtJQUNUO0FBQ0Y7QUFDQUosS0FBS3h4QyxPQUFPLEdBQUcsU0FBVTNlLE9BQU87SUFDOUIsSUFBSTN0RixRQUFPLElBQUk7SUFDZixJQUFJNkMsSUFBSTdDLE1BQUs2OUksV0FBVztJQUN4QixJQUFJeEosT0FBTyxFQUFFO0lBQ2IsSUFBSWtNLFVBQVU7SUFDZCxNQUFPQSxVQUFVeEQsV0FBWTtRQUMzQixJQUFJbDZJLEVBQUVxWixJQUFJLE9BQU8sR0FBRztZQUNsQjtRQUNGO1FBQ0EsSUFBSWdpSSxRQUFRcjdJLEVBQUU2aUIsSUFBSTtRQUVsQix5RUFBeUU7UUFDekUsSUFBSXc0SCxNQUFNOEIsV0FBVyxFQUFFO1lBQ3JCLCtFQUErRTtZQUMvRW45SSxFQUFFNGUsR0FBRztZQUNMO1FBQ0Y7UUFFQSwwRUFBMEU7UUFDMUUsSUFBSXk4SCxNQUFNaUMsUUFBUSxJQUFJakMsVUFBVUEsTUFBTWlDLFFBQVEsQ0FBQ0gsV0FBVyxFQUFFO1lBQzFELDhFQUE4RTtZQUM5RW45SSxFQUFFNGUsR0FBRztZQUNMO1FBQ0Y7UUFDQSxJQUFJeThILE1BQU1qakYsT0FBTyxFQUFFO1lBQ2pCLDhEQUE4RDtZQUM5RHA0RCxFQUFFNGUsR0FBRztZQUNMO1FBQ0Y7UUFDQSxJQUFJOUcsTUFBTXVqSSxNQUFNQyxTQUFTLENBQUMzOEgsS0FBSztRQUMvQixJQUFJN0csS0FBSztZQUNQLHFDQUFxQztZQUVyQzNhLE1BQUt1L0ksY0FBYyxDQUFDckIsT0FBT3ZqSSxLQUFLdWpJLE1BQU10M0MsS0FBSyxFQUFFalo7WUFDN0M0eUQ7UUFDRjtRQUNBLElBQUlsTSxLQUFLaDdJLE1BQU0sS0FBSyxHQUFHO1lBQ3JCLHdEQUF3RDtZQUN4RGc3SSxLQUFLeDRJLElBQUksQ0FBQztRQUNaO1FBRUEsaUVBQWlFO1FBQ2pFLElBQUlxaUosTUFBTUMsU0FBUyxDQUFDOWtKLE1BQU0sS0FBSyxHQUFHO1lBQ2hDd0osRUFBRTRlLEdBQUc7WUFDTHk4SCxNQUFNM0UsSUFBSSxHQUFHO1lBRWIsaURBQWlEO1lBRWpELCtFQUErRTtZQUMvRSxJQUFJMkUsTUFBTWlDLFFBQVEsRUFBRTtnQkFDbEJuZ0osTUFBS3dnSixxQkFBcUIsQ0FBQ3RDO1lBQzdCO1lBQ0FsK0ksTUFBS3lnSixhQUFhO1FBQ3BCO0lBQ0Y7SUFDQSxPQUFPcE07QUFDVDtBQUNBeUosS0FBSzBDLHFCQUFxQixHQUFHLFNBQVV0QyxLQUFLO0lBQzFDLElBQUlsK0ksUUFBTyxJQUFJO0lBQ2YsSUFBSTBnSixnQkFBZ0IxZ0osTUFBS3E5SSxhQUFhLENBQUNhLE1BQU10M0MsS0FBSyxDQUFDO0lBQ25ELElBQUkrNUMsV0FBV3pDLE1BQU1pQyxRQUFRO0lBQzdCLElBQUk1d0ksUUFBUW14SSxjQUFjMzdILE9BQU8sQ0FBQzQ3SDtJQUVsQyxnRkFBZ0Y7SUFDaEYsbUVBQW1FO0lBQ25FLElBQUlweEksUUFBUSxLQUFLb3hJLFNBQVMxbEYsT0FBTyxFQUFFO1FBQ2pDLDJEQUEyRDtRQUMzRDtJQUNGO0lBQ0F5bEYsYUFBYSxDQUFDbnhJLE1BQU0sR0FBRzJ1SSxPQUFPLG9CQUFvQjtJQUVsRCx1QkFBdUI7SUFDdkIsSUFBSyxJQUFJdGlKLElBQUksR0FBR0EsSUFBSXNpSixNQUFNeDNILElBQUksQ0FBQ3J0QixNQUFNLEVBQUV1QyxJQUFLO1FBQzFDLElBQUl1aEIsS0FBSytnSSxNQUFNeDNILElBQUksQ0FBQzlxQixFQUFFLENBQUM0QyxRQUFRO1FBQy9CLElBQUk0QixRQUFRK2MsR0FBR2lpSSxjQUFjLEdBQUdqaUksR0FBR2lpSSxjQUFjLElBQUksQ0FBQztRQUN0RCxJQUFJaC9JLE9BQU87WUFDVEEsS0FBSyxDQUFDODlJLE1BQU10M0MsS0FBSyxDQUFDLEdBQUdzM0M7UUFDdkI7SUFDRjtJQUVBLG9FQUFvRTtJQUVwRWwrSSxNQUFLeWdKLGFBQWE7QUFDcEI7QUFDQTNDLEtBQUsyQyxhQUFhLEdBQUd0dEksU0FBUztJQUM1QixJQUFJaGEsSUFBSSxJQUFJLENBQUNndUUsUUFBUTtJQUNyQmh1RSxFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO0lBQ3JCaHJJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7SUFDckJockksRUFBRWtySSxNQUFNO0FBQ1YsR0FBRztBQUNIeVosS0FBS2pLLGVBQWUsR0FBR0QsS0FBS0MsZUFBZSxDQUFDO0lBQzFDSSxvQkFBb0JBO0lBQ3BCUyxTQUFTQTtJQUNUQyxZQUFZQTtJQUNaQyxlQUFlQTtJQUNmSCxhQUFhQTtJQUNiSyxLQUFLLFNBQVNBLElBQUk5MEksS0FBSSxFQUFFMnRGLE9BQU87UUFDN0IsT0FBTzN0RixNQUFLc3NHLE9BQU8sQ0FBQzNlO0lBQ3RCO0lBQ0FvbkQsUUFBUTE3SDtJQUNSMjdILGNBQWM5N0g7SUFDZGk0SCxVQUFVLFNBQVNBLFNBQVNueEksS0FBSTtRQUM5QixPQUFPQSxNQUFLbW5FLFFBQVEsQ0FBQzRqQixzQkFBc0IsQ0FBQ3FvRCxTQUFTO0lBQ3ZEO0FBQ0Y7QUFFQSxJQUFJd04sUUFBUSxDQUFDO0FBQ2IsSUFBSTd6RztBQUNKLFNBQVM1WCxRQUFRczZDLE9BQU8sRUFBRXAwQyxNQUFNO0lBQzlCLElBQUssSUFBSXovQixJQUFJLEdBQUdBLElBQUl5L0IsT0FBT2hpQyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3RDLElBQUltNUIsS0FBS3NHLE1BQU0sQ0FBQ3ovQixFQUFFO1FBQ2xCNnpFLFFBQVE2MUMsTUFBTSxDQUFDdndGLEdBQUdwbkIsQ0FBQyxFQUFFb25CLEdBQUczZCxDQUFDO0lBQzNCO0FBQ0Y7QUFDQSxTQUFTeXBJLGtCQUFrQnB4RSxPQUFPLEVBQUVwMEMsTUFBTSxFQUFFa2dGLFlBQVk7SUFDdEQsSUFBSXVsQztJQUNKLElBQUssSUFBSWxsSixJQUFJLEdBQUdBLElBQUl5L0IsT0FBT2hpQyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3RDLElBQUltNUIsS0FBS3NHLE1BQU0sQ0FBQ3ovQixFQUFFO1FBQ2xCLElBQUlBLE1BQU0sR0FBRztZQUNYa2xKLFVBQVUvckg7UUFDWjtRQUNBMDZDLFFBQVE2MUMsTUFBTSxDQUFDdndGLEdBQUdwbkIsQ0FBQyxFQUFFb25CLEdBQUczZCxDQUFDO0lBQzNCO0lBQ0FxNEQsUUFBUXN4RSxnQkFBZ0IsQ0FBQ3hsQyxhQUFhNXRHLENBQUMsRUFBRTR0RyxhQUFhbmtHLENBQUMsRUFBRTBwSSxRQUFRbnpJLENBQUMsRUFBRW16SSxRQUFRMXBJLENBQUM7QUFDL0U7QUFDQSxTQUFTNHBJLFlBQVl2eEUsT0FBTyxFQUFFd3hFLGNBQWMsRUFBRUMsU0FBUztJQUNyRCxJQUFJenhFLFFBQVEweEUsU0FBUyxFQUFFO1FBQ3JCMXhFLFFBQVEweEUsU0FBUztJQUNuQjtJQUNBLElBQUl2bEMsU0FBU3FsQztJQUNiLElBQUssSUFBSXJsSixJQUFJLEdBQUdBLElBQUlnZ0gsT0FBT3ZpSCxNQUFNLEVBQUV1QyxJQUFLO1FBQ3RDLElBQUltNUIsS0FBSzZtRixNQUFNLENBQUNoZ0gsRUFBRTtRQUNsQjZ6RSxRQUFRNjFDLE1BQU0sQ0FBQ3Z3RixHQUFHcG5CLENBQUMsRUFBRW9uQixHQUFHM2QsQ0FBQztJQUMzQjtJQUNBLElBQUl5a0csU0FBU3FsQztJQUNiLElBQUlFLGFBQWFGLFNBQVMsQ0FBQyxFQUFFO0lBQzdCenhFLFFBQVE0eEUsTUFBTSxDQUFDRCxXQUFXenpJLENBQUMsRUFBRXl6SSxXQUFXaHFJLENBQUM7SUFDekMsSUFBSyxJQUFJeGIsSUFBSSxHQUFHQSxJQUFJaWdILE9BQU94aUgsTUFBTSxFQUFFdUMsSUFBSztRQUN0QyxJQUFJbTVCLEtBQUs4bUYsTUFBTSxDQUFDamdILEVBQUU7UUFDbEI2ekUsUUFBUTYxQyxNQUFNLENBQUN2d0YsR0FBR3BuQixDQUFDLEVBQUVvbkIsR0FBRzNkLENBQUM7SUFDM0I7SUFDQSxJQUFJcTRELFFBQVE2eEUsU0FBUyxFQUFFO1FBQ3JCN3hFLFFBQVE2eEUsU0FBUztJQUNuQjtBQUNGO0FBQ0EsU0FBU0MsZUFBZTl4RSxPQUFPLEVBQUV3eEUsY0FBYyxFQUFFcnlDLEVBQUUsRUFBRUMsRUFBRSxFQUFFMTFHLENBQUM7SUFDeEQsSUFBSXMyRSxRQUFRMHhFLFNBQVMsRUFBRTtRQUNyQjF4RSxRQUFRMHhFLFNBQVM7SUFDbkI7SUFDQTF4RSxRQUFRODFDLEdBQUcsQ0FBQzNXLElBQUlDLElBQUkxMUcsR0FBRyxHQUFHZ0YsS0FBS3NaLEVBQUUsR0FBRyxHQUFHO0lBQ3ZDLElBQUlta0csU0FBU3FsQztJQUNiLElBQUlPLFlBQVk1bEMsTUFBTSxDQUFDLEVBQUU7SUFDekJuc0MsUUFBUTR4RSxNQUFNLENBQUNHLFVBQVU3ekksQ0FBQyxFQUFFNnpJLFVBQVVwcUksQ0FBQztJQUN2QyxJQUFLLElBQUl4YixJQUFJLEdBQUdBLElBQUlnZ0gsT0FBT3ZpSCxNQUFNLEVBQUV1QyxJQUFLO1FBQ3RDLElBQUltNUIsS0FBSzZtRixNQUFNLENBQUNoZ0gsRUFBRTtRQUNsQjZ6RSxRQUFRNjFDLE1BQU0sQ0FBQ3Z3RixHQUFHcG5CLENBQUMsRUFBRW9uQixHQUFHM2QsQ0FBQztJQUMzQjtJQUNBLElBQUlxNEQsUUFBUTZ4RSxTQUFTLEVBQUU7UUFDckI3eEUsUUFBUTZ4RSxTQUFTO0lBQ25CO0FBQ0Y7QUFDQSxTQUFTRyxTQUFTaHlFLE9BQU8sRUFBRW0vQixFQUFFLEVBQUVDLEVBQUUsRUFBRTExRyxDQUFDO0lBQ2xDczJFLFFBQVE4MUMsR0FBRyxDQUFDM1csSUFBSUMsSUFBSTExRyxHQUFHLEdBQUdnRixLQUFLc1osRUFBRSxHQUFHLEdBQUc7QUFDekM7QUFDQW1wSSxNQUFNdmxDLGNBQWMsR0FBRyxTQUFVMytHLElBQUk7SUFDbkMsT0FBTyxDQUFDcXdDLFFBQVNBLENBQUFBLE9BQU87UUFDdEIsV0FBVzVYO1FBQ1gsc0JBQXNCMHJIO1FBQ3RCLGdCQUFnQkc7UUFDaEIsbUJBQW1CTztRQUNuQixrQkFBa0JQO1FBQ2xCLFVBQVVTO0lBQ1osRUFBQyxDQUFFLENBQUMva0osS0FBSztBQUNYO0FBRUEsSUFBSWdsSixRQUFRLENBQUM7QUFDYkEsTUFBTXhKLFdBQVcsR0FBRyxTQUFVem9FLE9BQU8sRUFBRTkwRCxHQUFHLEVBQUVnbkksbUJBQW1CLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxXQUFXO0lBQ2xHLElBQUkzb0osSUFBSSxJQUFJO0lBQ1osSUFBSXdoQixJQUFJb0UsTUFBTSxJQUFJO1FBQ2hCNWxCLEVBQUU0b0osUUFBUSxDQUFDdHlFLFNBQVM5MEQsS0FBS2duSSxxQkFBcUJDLFdBQVdDLGFBQWFDO0lBQ3hFLE9BQU87UUFDTDNvSixFQUFFNm9KLFFBQVEsQ0FBQ3Z5RSxTQUFTOTBELEtBQUtnbkkscUJBQXFCQyxXQUFXQyxhQUFhQztJQUN4RTtBQUNGO0FBQ0FKLE1BQU1PLGtCQUFrQixHQUFHLFNBQVV4eUUsT0FBTyxFQUFFOTBELEdBQUc7SUFDL0MsSUFBSXhoQixJQUFJLElBQUk7SUFDWixJQUFJd2hCLElBQUlvRSxNQUFNLElBQUk7UUFDaEI1bEIsRUFBRStvSixlQUFlLENBQUN6eUUsU0FBUzkwRDtJQUM3QixPQUFPO1FBQ0x4aEIsRUFBRWdwSixlQUFlLENBQUMxeUUsU0FBUzkwRDtJQUM3QjtBQUNGO0FBQ0ErbUksTUFBTVUsbUJBQW1CLEdBQUcsU0FBVTN5RSxPQUFPLEVBQUU5MEQsR0FBRztJQUNoRCxJQUFJeGhCLElBQUksSUFBSTtJQUNaLElBQUl3aEIsSUFBSW9FLE1BQU0sSUFBSTtRQUNoQjVsQixFQUFFa3BKLGdCQUFnQixDQUFDNXlFLFNBQVM5MEQ7SUFDOUIsT0FBTztRQUNMeGhCLEVBQUVtcEosZ0JBQWdCLENBQUM3eUUsU0FBUzkwRDtJQUM5QjtBQUNGO0FBQ0ErbUksTUFBTWEsd0JBQXdCLEdBQUcsU0FBVTl5RSxPQUFPLEVBQUU5MEQsR0FBRyxFQUFFNm5JLFdBQVcsRUFBRTcwRCxPQUFPLEVBQUV1b0QsR0FBRyxFQUFFMEQsTUFBTSxFQUFFNkksV0FBVyxFQUFFQyxVQUFVO0lBQ2pILElBQUl2cEosSUFBSSxJQUFJO0lBQ1osSUFBSTA2QixLQUFLMnVILFlBQVlySyxjQUFjLENBQUN4OUg7SUFDcEMsSUFBSWtaLEdBQUd2YixDQUFDLEtBQUssS0FBS3ViLEdBQUdueEIsQ0FBQyxLQUFLLEdBQUc7UUFDNUI7SUFDRixFQUFFLHdCQUF3QjtJQUUxQixJQUFJdTNJLFdBQVd1SSxZQUFZN0ksVUFBVSxDQUFDaC9ILEtBQUtrWixJQUFJODVELFNBQVN1b0QsS0FBSzBEO0lBQzdELElBQUlLLFlBQVksTUFBTTtRQUNwQixJQUFJcHpFLFVBQVU2N0UsV0FBV3ZwSixHQUFHd2hCO1FBQzVCLElBQUlrc0QsWUFBWSxHQUFHO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJZixRQUFRMjhFLFlBQVl0cEosR0FBR3doQjtRQUMzQixJQUFJMWIsS0FBSzQwQixHQUFHNTBCLEVBQUUsRUFDWkUsS0FBSzAwQixHQUFHMTBCLEVBQUUsRUFDVm1aLElBQUl1YixHQUFHdmIsQ0FBQyxFQUNSNVYsSUFBSW14QixHQUFHbnhCLENBQUM7UUFDVixJQUFJaUwsR0FBR3lKLEdBQUdzcUIsSUFBSUMsSUFBSWdoSDtRQUNsQixJQUFJNzhFLFVBQVUsR0FBRztZQUNmLElBQUk4OEUsUUFBUUosWUFBWXBLLGdCQUFnQixDQUFDejlIO1lBQ3pDK21CLEtBQUtraEgsTUFBTWoxSSxDQUFDO1lBQ1pnMEIsS0FBS2loSCxNQUFNeHJJLENBQUM7WUFDWnE0RCxRQUFRK3JFLFNBQVMsQ0FBQzk1RyxJQUFJQztZQUN0Qjh0QyxRQUFReEosTUFBTSxDQUFDSDtZQUNmNjhFLFNBQVN4cEosRUFBRTBwSixlQUFlLENBQUNwekU7WUFDM0IsSUFBSSxDQUFDa3pFLFFBQVE7Z0JBQ1h4cEosRUFBRXNtSixlQUFlLENBQUNod0UsU0FBUztZQUM3QjtZQUNBLElBQUlyOUMsTUFBTW93SCxZQUFZbkssaUJBQWlCLENBQUMxOUg7WUFDeENoTixJQUFJeWtCLElBQUl6a0IsQ0FBQztZQUNUeUosSUFBSWdiLElBQUloYixDQUFDO1FBQ1gsT0FBTztZQUNMekosSUFBSTFPO1lBQ0ptWSxJQUFJalk7UUFDTjtRQUNBLElBQUkyako7UUFDSixJQUFJajhFLFlBQVksR0FBRztZQUNqQmk4RSxpQkFBaUJyekUsUUFBUXN6RSxXQUFXO1lBQ3BDdHpFLFFBQVFzekUsV0FBVyxHQUFHRCxpQkFBaUJqOEU7UUFDekM7UUFDQTRJLFFBQVF5ckUsU0FBUyxDQUFDakIsU0FBU0UsT0FBTyxDQUFDbGdCLE1BQU0sRUFBRWdnQixTQUFTdHNJLENBQUMsRUFBRSxHQUFHc3NJLFNBQVMxakgsS0FBSyxFQUFFMGpILFNBQVN6akgsTUFBTSxFQUFFN29CLEdBQUd5SixHQUFHa0IsR0FBRzVWO1FBQ3BHLElBQUlta0UsWUFBWSxHQUFHO1lBQ2pCNEksUUFBUXN6RSxXQUFXLEdBQUdEO1FBQ3hCO1FBQ0EsSUFBSWg5RSxVQUFVLEdBQUc7WUFDZjJKLFFBQVF4SixNQUFNLENBQUMsQ0FBQ0g7WUFDaEIySixRQUFRK3JFLFNBQVMsQ0FBQyxDQUFDOTVHLElBQUksQ0FBQ0M7WUFDeEIsSUFBSSxDQUFDZ2hILFFBQVE7Z0JBQ1h4cEosRUFBRXNtSixlQUFlLENBQUNod0UsU0FBUztZQUM3QjtRQUNGO0lBQ0YsT0FBTztRQUNMK3lFLFlBQVl0SyxXQUFXLENBQUN6b0UsU0FBUzkwRCxNQUFNLHVCQUF1QjtJQUNoRTtBQUNGO0FBQ0EsSUFBSXFvSSxrQkFBa0IsU0FBU0E7SUFDN0IsT0FBTztBQUNUO0FBQ0EsSUFBSUMsbUJBQW1CLFNBQVNBLGlCQUFpQjlwSixDQUFDLEVBQUV3aEIsR0FBRztJQUNyRCxPQUFPeGhCLEVBQUUrcEosWUFBWSxDQUFDdm9JLEtBQUs7QUFDN0I7QUFDQSxJQUFJd29JLHlCQUF5QixTQUFTQSx1QkFBdUJocUosQ0FBQyxFQUFFd2hCLEdBQUc7SUFDakUsT0FBT3hoQixFQUFFK3BKLFlBQVksQ0FBQ3ZvSSxLQUFLO0FBQzdCO0FBQ0EsSUFBSXlvSSx5QkFBeUIsU0FBU0EsdUJBQXVCanFKLENBQUMsRUFBRXdoQixHQUFHO0lBQ2pFLE9BQU94aEIsRUFBRStwSixZQUFZLENBQUN2b0ksS0FBSztBQUM3QjtBQUNBLElBQUkrbkksYUFBYSxTQUFTQSxXQUFXdnBKLENBQUMsRUFBRXdoQixHQUFHO0lBQ3pDLE9BQU9BLElBQUlvL0QsZ0JBQWdCO0FBQzdCO0FBQ0EsSUFBSXNwRSxpQkFBaUIsU0FBU0EsZUFBZS9wSixDQUFDLEVBQUVxaEIsR0FBRztJQUNqRCxPQUFPQSxJQUFJNG1ELE1BQU0sQ0FBQyxnQkFBZ0JDLE9BQU8sR0FBRzdtRCxJQUFJby9ELGdCQUFnQjtBQUNsRTtBQUNBMm5FLE1BQU1oQyxpQkFBaUIsR0FBRyxTQUFVandFLE9BQU8sRUFBRTkwRCxHQUFHLEVBQUVnekUsT0FBTyxFQUFFaWEsTUFBTSxFQUFFc3VDLEdBQUcsRUFBRW9OLGtCQUFrQjtJQUN4RixJQUFJbnFKLElBQUksSUFBSTtJQUNaLElBQUlvcUosVUFBVXBxSixFQUFFNmpCLElBQUksRUFDbEJ3bEksY0FBY2UsUUFBUWYsV0FBVyxFQUNqQ2dCLGNBQWNELFFBQVFDLFdBQVcsRUFDakNDLGNBQWNGLFFBQVFFLFdBQVcsRUFDakNDLGNBQWNILFFBQVFHLFdBQVc7SUFDbkMsSUFBSTd2SCxLQUFLbFosSUFBSTNiLFdBQVc7SUFDeEIsSUFBSTQ2SSxTQUFTMEosdUJBQXVCLE9BQU9kLFlBQVkzSixPQUFPLENBQUNiLFdBQVcsR0FBRztJQUM3RSxJQUFJbmtILEdBQUd2YixDQUFDLEtBQUssS0FBS3ViLEdBQUdueEIsQ0FBQyxLQUFLLEtBQUssQ0FBQ2lZLElBQUlnNUMsT0FBTyxJQUFJO1FBQzlDO0lBQ0Y7SUFDQSxJQUFJLENBQUNpMEMsVUFBVWh6RSx1QkFBdUJmLElBQUkrekUsU0FBUztRQUNqRCxJQUFJOXlELFNBQVNuNkIsSUFBSW02QixNQUFNO1FBQ3ZCLElBQUkyL0UsVUFBVTk1RyxJQUFJcmMsT0FBTyxHQUFHRSxRQUFRLENBQUNrZ0IsUUFBUSxDQUFDKzFHLE9BQU87UUFDckR0N0gsRUFBRWlwSixtQkFBbUIsQ0FBQzN5RSxTQUFTOTBEO1FBQy9CeGhCLEVBQUVvcEosd0JBQXdCLENBQUM5eUUsU0FBUzkwRCxLQUFLNm5JLGFBQWE3MEQsU0FBU3VvRCxLQUFLMEQsUUFBUW9KLGlCQUFpQk47UUFDN0YsSUFBSSxDQUFDNXRHLFVBQVUsQ0FBQzIvRSxTQUFTO1lBQ3ZCdDdILEVBQUVvcEosd0JBQXdCLENBQUM5eUUsU0FBUzkwRCxLQUFLNm9JLGFBQWE3MUQsU0FBU3VvRCxLQUFLMEQsUUFBUXFKLGtCQUFrQkk7UUFDaEc7UUFDQSxJQUFJdnVHLFVBQVUsQ0FBQzIvRSxTQUFTO1lBQ3RCdDdILEVBQUVvcEosd0JBQXdCLENBQUM5eUUsU0FBUzkwRCxLQUFLOG9JLGFBQWE5MUQsU0FBU3VvRCxLQUFLMEQsUUFBUXVKLHdCQUF3QkU7WUFDcEdscUosRUFBRW9wSix3QkFBd0IsQ0FBQzl5RSxTQUFTOTBELEtBQUsrb0ksYUFBYS8xRCxTQUFTdW9ELEtBQUswRCxRQUFRd0osd0JBQXdCQztRQUN0RztRQUNBbHFKLEVBQUU4b0osa0JBQWtCLENBQUN4eUUsU0FBUzkwRDtJQUNoQztBQUNGO0FBQ0ErbUksTUFBTWlDLFlBQVksR0FBRyxTQUFVbDBFLE9BQU8sRUFBRS9vRCxJQUFJO0lBQzFDLElBQUl2dEIsSUFBSSxJQUFJO0lBQ1osSUFBSyxJQUFJeUMsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO1FBQ2pCekMsRUFBRSsrSSxXQUFXLENBQUN6b0UsU0FBUzkwRDtJQUN6QjtBQUNGO0FBQ0ErbUksTUFBTWtDLGtCQUFrQixHQUFHLFNBQVVuMEUsT0FBTyxFQUFFL29ELElBQUksRUFBRWluRSxPQUFPLEVBQUVpYSxNQUFNO0lBQ2pFLElBQUl6dUcsSUFBSSxJQUFJO0lBQ1osSUFBSyxJQUFJeUMsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO1FBQ2pCekMsRUFBRXVtSixpQkFBaUIsQ0FBQ2p3RSxTQUFTOTBELEtBQUtnekUsU0FBU2lhO0lBQzdDO0FBQ0Y7QUFDQTg1QyxNQUFNbUMsZUFBZSxHQUFHLFNBQVVwMEUsT0FBTyxFQUFFL29ELElBQUksRUFBRWluRSxPQUFPLEVBQUVpYSxNQUFNO0lBQzlELElBQUl6dUcsSUFBSSxJQUFJO0lBQ1osSUFBSyxJQUFJeUMsSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUtydEIsTUFBTSxFQUFFdUMsSUFBSztRQUNwQyxJQUFJK2UsTUFBTStMLElBQUksQ0FBQzlxQixFQUFFO1FBQ2pCLElBQUksQ0FBQytlLElBQUlvRSxNQUFNLElBQUk7WUFDakI7UUFDRjtRQUNBNWxCLEVBQUV1bUosaUJBQWlCLENBQUNqd0UsU0FBUzkwRCxLQUFLZ3pFLFNBQVNpYTtJQUM3QztBQUNGO0FBQ0E4NUMsTUFBTW9DLG1CQUFtQixHQUFHLFNBQVVyMEUsT0FBTyxFQUFFL29ELElBQUksRUFBRWluRSxPQUFPLEVBQUVpYSxNQUFNO0lBQ2xFLElBQUl6dUcsSUFBSSxJQUFJO0lBQ1osSUFBSW9sSixTQUFTcGxKLEVBQUU2akIsSUFBSSxDQUFDK21JLFdBQVcsQ0FBQzNGLFNBQVMsQ0FBQzEzSCxNQUFNaW5FO0lBQ2hELElBQUk0d0QsUUFBUTtRQUNWLElBQUssSUFBSTNpSixJQUFJLEdBQUdBLElBQUkyaUosT0FBT2xsSixNQUFNLEVBQUV1QyxJQUFLO1lBQ3RDLElBQUlzaUosUUFBUUssTUFBTSxDQUFDM2lKLEVBQUU7WUFDckIsSUFBSWk0QixLQUFLcXFILE1BQU1ycUgsRUFBRTtZQUNqQixJQUFJQSxHQUFHdmIsQ0FBQyxLQUFLLEtBQUt1YixHQUFHbnhCLENBQUMsS0FBSyxHQUFHO2dCQUM1QjtZQUNGO1lBQ0Erc0UsUUFBUXlyRSxTQUFTLENBQUNnRCxNQUFNamtCLE1BQU0sRUFBRXBtRyxHQUFHNTBCLEVBQUUsRUFBRTQwQixHQUFHMTBCLEVBQUUsRUFBRTAwQixHQUFHdmIsQ0FBQyxFQUFFdWIsR0FBR254QixDQUFDO1FBQzFEO0lBQ0YsT0FBTztRQUNMLDBDQUEwQztRQUMxQ3ZKLEVBQUV5cUosa0JBQWtCLENBQUNuMEUsU0FBUy9vRCxNQUFNaW5FLFNBQVNpYTtJQUMvQztBQUNGO0FBRUEsSUFBSW84QyxRQUFRLENBQUM7QUFDYkEsTUFBTWhDLFFBQVEsR0FBRyxTQUFVdnlFLE9BQU8sRUFBRWp0RCxJQUFJLEVBQUVtL0gsbUJBQW1CO0lBQzNELElBQUlzQyxZQUFZdGtKLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNwRixJQUFJdWtKLG9CQUFvQnZrSixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDNUYsSUFBSXdrSixvQkFBb0J4a0osVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzVGLElBQUl4RyxJQUFJLElBQUk7SUFDWixJQUFJcWxILEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJeWxJLHFCQUFxQixDQUFDM2hJLEtBQUtteEMsT0FBTyxJQUFJO1FBQ3hDO0lBQ0Y7SUFFQSxxREFBcUQ7SUFDckQsSUFBSTZxRCxHQUFHaVcsT0FBTyxJQUFJalcsR0FBR1EsTUFBTSxJQUFJLFFBQVEvZ0gsTUFBTXVnSCxHQUFHUSxNQUFNLENBQUMsRUFBRSxHQUFHO1FBQzFELGtFQUFrRTtRQUNsRTtJQUNGO0lBQ0EsSUFBSW5yRjtJQUNKLElBQUk4dEgscUJBQXFCO1FBQ3ZCOXRILEtBQUs4dEg7UUFDTGx5RSxRQUFRK3JFLFNBQVMsQ0FBQyxDQUFDM25ILEdBQUc1MEIsRUFBRSxFQUFFLENBQUM0MEIsR0FBRzEwQixFQUFFO0lBQ2xDO0lBQ0EsSUFBSTBuRSxVQUFVczlFLG9CQUFvQjNoSSxLQUFLKytDLE1BQU0sQ0FBQyxXQUFXdG1FLEtBQUssR0FBRztJQUNqRSxJQUFJbXBKLGNBQWNELG9CQUFvQjNoSSxLQUFLKytDLE1BQU0sQ0FBQyxnQkFBZ0J0bUUsS0FBSyxHQUFHO0lBQzFFLElBQUk4dEUsYUFBYXZtRCxLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7SUFDakQsSUFBSXlqRyxZQUFZbDhFLEtBQUsrK0MsTUFBTSxDQUFDLGNBQWN0bUUsS0FBSztJQUMvQyxJQUFJcS9HLFlBQVk5M0YsS0FBSysrQyxNQUFNLENBQUMsU0FBU0MsT0FBTztJQUM1QyxJQUFJbTlCLFVBQVVuOEUsS0FBSysrQyxNQUFNLENBQUMsWUFBWXRtRSxLQUFLO0lBQzNDLElBQUlvcEosbUJBQW1CN2hJLEtBQUsrK0MsTUFBTSxDQUFDLHNCQUFzQnRtRSxLQUFLO0lBQzlELElBQUlxcEosbUJBQW1COWhJLEtBQUsrK0MsTUFBTSxDQUFDLHNCQUFzQnRtRSxLQUFLO0lBQzlELElBQUlzcEosdUJBQXVCMTlFLFVBQVV1OUU7SUFDckMsOERBQThEO0lBQzlELElBQUlJLHdCQUF3QjM5RSxVQUFVdTlFO0lBQ3RDLElBQUlLLFdBQVcsU0FBU0E7UUFDdEIsSUFBSUMsZ0JBQWdCL2tKLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRzRrSjtRQUN4RixJQUFJeDdFLGVBQWUscUJBQXFCO1lBQ3RDNXZFLEVBQUV3ckosY0FBYyxDQUFDbDFFLFNBQVNqdEQsTUFBTWtpSTtZQUNoQ3ZySixFQUFFeXJKLG9CQUFvQixDQUFDcGlJLE1BQU1pdEQsU0FBUyt1QyxHQUFHUSxNQUFNO1FBQ2pELE9BQU87WUFDTHZ2QyxRQUFRbzFFLFNBQVMsR0FBR3ZxQztZQUNwQjdxQyxRQUFRa3ZCLE9BQU8sR0FBR0E7WUFDbEJ4bEcsRUFBRXdySixjQUFjLENBQUNsMUUsU0FBU2p0RCxNQUFNa2lJO1lBQ2hDdnJKLEVBQUUyckosWUFBWSxDQUFDdGlJLE1BQU1pdEQsU0FBUyt1QyxHQUFHUSxNQUFNLEVBQUV0Z0I7WUFDekNqdkIsUUFBUWt2QixPQUFPLEdBQUcsUUFBUSxvQ0FBb0M7UUFDaEU7SUFDRjtJQUNBLElBQUlvbUQsa0JBQWtCLFNBQVNBO1FBQzdCLElBQUlMLGdCQUFnQi9rSixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc0a0o7UUFDeEY5MEUsUUFBUW8xRSxTQUFTLEdBQUd2cUMsWUFBWStwQztRQUNoQzUwRSxRQUFRa3ZCLE9BQU8sR0FBR0E7UUFDbEIsSUFBSTBsRCxtQkFBbUIsR0FBRztZQUN4QmxySixFQUFFNnJKLGdCQUFnQixDQUFDdjFFLFNBQVM2MEUsZ0JBQWdCLENBQUMsRUFBRSxFQUFFQSxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVBLGdCQUFnQixDQUFDLEVBQUUsRUFBRUk7UUFDN0YsT0FBTztZQUNMLDhCQUE4QjtZQUM5QmoxRSxRQUFRa3ZCLE9BQU8sR0FBRyxRQUFRLG9DQUFvQztZQUM5RDtRQUNGO1FBQ0EsSUFBSTUxQixlQUFlLHFCQUFxQjtZQUN0QzV2RSxFQUFFeXJKLG9CQUFvQixDQUFDcGlJLE1BQU1pdEQsU0FBUyt1QyxHQUFHUSxNQUFNO1FBQ2pELE9BQU87WUFDTDdsSCxFQUFFMnJKLFlBQVksQ0FBQ3RpSSxNQUFNaXRELFNBQVMrdUMsR0FBR1EsTUFBTSxFQUFFdGdCO1lBQ3pDanZCLFFBQVFrdkIsT0FBTyxHQUFHLFFBQVEsb0NBQW9DO1FBQ2hFO0lBQ0Y7SUFDQSxJQUFJc21ELGNBQWMsU0FBU0E7UUFDekIsSUFBSSxDQUFDZixtQkFBbUI7WUFDdEI7UUFDRjtRQUNBL3FKLEVBQUVncEosZUFBZSxDQUFDMXlFLFNBQVNqdEQ7SUFDN0I7SUFDQSxJQUFJMGlJLGVBQWUsU0FBU0E7UUFDMUIsSUFBSSxDQUFDaEIsbUJBQW1CO1lBQ3RCO1FBQ0Y7UUFDQS9xSixFQUFFbXBKLGdCQUFnQixDQUFDN3lFLFNBQVNqdEQ7SUFDOUI7SUFDQSxJQUFJMmlJLGFBQWEsU0FBU0E7UUFDeEIsSUFBSUMsZUFBZXpsSixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc2a0o7UUFDdkZyckosRUFBRWtzSixjQUFjLENBQUM1MUUsU0FBU2p0RCxNQUFNNGlJO0lBQ2xDO0lBQ0EsSUFBSUUsV0FBVyxTQUFTQTtRQUN0Qm5zSixFQUFFb3NKLGVBQWUsQ0FBQzkxRSxTQUFTanRELE1BQU0sTUFBTXloSTtJQUN6QztJQUNBeDBFLFFBQVFvdkIsUUFBUSxHQUFHO0lBQ25CLElBQUlwMUIsUUFBUWpuRCxLQUFLKytDLE1BQU0sQ0FBQyxTQUFTdG1FLEtBQUssS0FBSztJQUMzQyxJQUFJd3VFLE9BQU87UUFDVCxJQUFJQyxLQUFLbG5ELEtBQUsrK0MsTUFBTSxDQUFDLGtCQUFrQkMsT0FBTztRQUM5QyxJQUFJbUksS0FBS25uRCxLQUFLKytDLE1BQU0sQ0FBQyxrQkFBa0JDLE9BQU87UUFDOUMsSUFBSWdrRixlQUFlaGpJLEtBQUsrK0MsTUFBTSxDQUFDLGlCQUFpQnRtRSxLQUFLO1FBQ3JELElBQUl3cUosd0JBQXdCbEIsdUJBQXVCaUI7UUFDbkQvMUUsUUFBUStyRSxTQUFTLENBQUM5eEUsSUFBSUM7UUFDdEI4NkUsU0FBU2dCO1FBQ1ROLFdBQVdNO1FBQ1hoMkUsUUFBUStyRSxTQUFTLENBQUMsQ0FBQzl4RSxJQUFJLENBQUNDO0lBQzFCLE9BQU87UUFDTG83RTtJQUNGO0lBQ0FHO0lBQ0FUO0lBQ0FVO0lBQ0FGO0lBQ0FLO0lBQ0EsSUFBSTNELHFCQUFxQjtRQUN2Qmx5RSxRQUFRK3JFLFNBQVMsQ0FBQzNuSCxHQUFHNTBCLEVBQUUsRUFBRTQwQixHQUFHMTBCLEVBQUU7SUFDaEM7QUFDRjtBQUNBLElBQUl1bUosMEJBQTBCLFNBQVNBLHdCQUF3QkMsaUJBQWlCO0lBQzlFLElBQUksQ0FBQztRQUFDO1FBQVc7S0FBVyxDQUFDQyxRQUFRLENBQUNELG9CQUFvQjtRQUN4RCxNQUFNLElBQUl0NEksTUFBTTtJQUNsQjtJQUNBLE9BQU8sU0FBVW9pRSxPQUFPLEVBQUVqdEQsSUFBSTtRQUM1QixJQUFJLENBQUNBLEtBQUtteEMsT0FBTyxJQUFJO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJa1QsVUFBVXJrRCxLQUFLKytDLE1BQU0sQ0FBQyxHQUFHbjlDLE1BQU0sQ0FBQ3VoSSxtQkFBbUIsYUFBYTFxSixLQUFLO1FBQ3pFLElBQUk0ckUsWUFBWSxHQUFHO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJMXRFLElBQUksSUFBSTtRQUNaLElBQUkwc0osV0FBVzFzSixFQUFFMHNKLFFBQVE7UUFDekIsSUFBSXJuQyxLQUFLaDhGLEtBQUtoa0IsUUFBUSxDQUFDa2dCLFFBQVE7UUFDL0IsSUFBSTJWLFVBQVU3UixLQUFLKytDLE1BQU0sQ0FBQyxHQUFHbjlDLE1BQU0sQ0FBQ3VoSSxtQkFBbUIsYUFBYW5rRixPQUFPO1FBQzNFLElBQUlqckMsUUFBUSxJQUFJbEM7UUFDaEIsSUFBSTF3QixRQUFRNmUsS0FBSysrQyxNQUFNLENBQUMsR0FBR245QyxNQUFNLENBQUN1aEksbUJBQW1CLFdBQVcxcUosS0FBSztRQUNyRXcwRSxRQUFRbzFFLFNBQVMsR0FBR3R1SDtRQUNwQixJQUFJaW9GLEdBQUdPLFFBQVEsS0FBSyxVQUFVLENBQUM4bUMsVUFBVTtZQUN2Q3AyRSxRQUFRa3ZCLE9BQU8sR0FBRztRQUNwQixPQUFPO1lBQ0xsdkIsUUFBUWt2QixPQUFPLEdBQUc7UUFDcEI7UUFDQXhsRyxFQUFFNnJKLGdCQUFnQixDQUFDdjFFLFNBQVM5ckUsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRWtqRTtRQUMxRDF0RSxFQUFFMnJKLFlBQVksQ0FBQ3RpSSxNQUFNaXRELFNBQVMrdUMsR0FBR1EsTUFBTSxFQUFFO0lBQzNDO0FBQ0Y7QUFDQWdsQyxNQUFNN0IsZUFBZSxHQUFHdUQsd0JBQXdCO0FBQ2hEMUIsTUFBTTFCLGdCQUFnQixHQUFHb0Qsd0JBQXdCO0FBQ2pEMUIsTUFBTWMsWUFBWSxHQUFHLFNBQVV0aUksSUFBSSxFQUFFaXRELE9BQU8sRUFBRWg2QyxHQUFHLEVBQUV2bkIsSUFBSTtJQUNyRCxJQUFJc3dHLEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJb25JLFlBQVlyMkU7SUFDaEIsSUFBSWh0RDtJQUNKLElBQUlzakksZUFBZTtJQUNuQixJQUFJRixXQUFXLElBQUksQ0FBQ0EsUUFBUTtJQUM1QixJQUFJRyxrQkFBa0J4akksS0FBSysrQyxNQUFNLENBQUMscUJBQXFCQyxPQUFPO0lBQzlELElBQUl5a0YsaUJBQWlCempJLEtBQUsrK0MsTUFBTSxDQUFDLG9CQUFvQkMsT0FBTztJQUM1RCxJQUFJcWtGLFVBQVU7UUFDWixJQUFJSyxlQUFlendILElBQUk1MUIsSUFBSSxDQUFDO1FBQzVCLElBQUlzbUosYUFBYTNuQyxHQUFHMG5DLFlBQVksSUFBSTFuQyxHQUFHMG5DLFlBQVksS0FBS0E7UUFDeEQsSUFBSUMsWUFBWTtZQUNkMWpJLE9BQU9ndEQsVUFBVSt1QyxHQUFHNG5DLFNBQVM7WUFDN0JMLGVBQWU7UUFDakIsT0FBTztZQUNMdGpJLE9BQU9ndEQsVUFBVSxJQUFJNDJFO1lBQ3JCN25DLEdBQUcwbkMsWUFBWSxHQUFHQTtZQUNsQjFuQyxHQUFHNG5DLFNBQVMsR0FBRzNqSTtRQUNqQjtJQUNGO0lBQ0EsSUFBSXFqSSxVQUFVUSxXQUFXLEVBQUU7UUFDekIsOEJBQThCO1FBQzlCLE9BQVFwNEk7WUFDTixLQUFLO2dCQUNINDNJLFVBQVVRLFdBQVcsQ0FBQztvQkFBQztvQkFBRztpQkFBRTtnQkFDNUI7WUFDRixLQUFLO2dCQUNIUixVQUFVUSxXQUFXLENBQUNOO2dCQUN0QkYsVUFBVUcsY0FBYyxHQUFHQTtnQkFDM0I7WUFDRixLQUFLO2dCQUNISCxVQUFVUSxXQUFXLENBQUMsRUFBRTtnQkFDeEI7UUFDSjtJQUNGO0lBQ0EsSUFBSSxDQUFDUCxnQkFBZ0IsQ0FBQ3ZuQyxHQUFHaVcsT0FBTyxFQUFFO1FBQ2hDLElBQUlobEQsUUFBUTB4RSxTQUFTLEVBQUU7WUFDckIxeEUsUUFBUTB4RSxTQUFTO1FBQ25CO1FBQ0ExeEUsUUFBUTR4RSxNQUFNLENBQUM1ckgsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7UUFDN0IsT0FBUStvRixHQUFHTyxRQUFRO1lBQ2pCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0gsSUFBSyxJQUFJbmpILElBQUksR0FBR0EsSUFBSSxJQUFJNjVCLElBQUlwOEIsTUFBTSxFQUFFdUMsS0FBSyxFQUFHO29CQUMxQzZ6RSxRQUFRc3hFLGdCQUFnQixDQUFDdHJILEdBQUcsQ0FBQzc1QixFQUFFLEVBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxFQUFFNjVCLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFO2dCQUNyRTtnQkFDQTtZQUNGLEtBQUs7WUFDTCxLQUFLO2dCQUNILElBQUssSUFBSTBtQixLQUFLLEdBQUdBLEtBQUssSUFBSW1ULElBQUlwOEIsTUFBTSxFQUFFaXBCLE1BQU0sRUFBRztvQkFDN0NtdEQsUUFBUTYxQyxNQUFNLENBQUM3dkYsR0FBRyxDQUFDblQsR0FBRyxFQUFFbVQsR0FBRyxDQUFDblQsS0FBSyxFQUFFO2dCQUNyQztnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsSUFBSWs4RixHQUFHcUUsT0FBTyxFQUFFO29CQUNkLElBQUk5L0UsWUFBWXJvQywyQkFBMkI4akgsR0FBR2lSLFlBQVksR0FDeER6c0Y7b0JBQ0YsSUFBSTt3QkFDRixJQUFLRCxVQUFVaG9DLENBQUMsSUFBSSxDQUFDLENBQUNpb0MsUUFBUUQsVUFBVXhwQyxDQUFDLEVBQUMsRUFBR3lCLElBQUksRUFBRzs0QkFDbEQsSUFBSW1oQyxTQUFTNkcsTUFBTS9uQyxLQUFLOzRCQUN4QmtxSCx3QkFBd0IxMUMsU0FBU3R6Qzt3QkFDbkM7b0JBQ0YsRUFBRSxPQUFPZ0gsS0FBSzt3QkFDWkosVUFBVXpwQyxDQUFDLENBQUM2cEM7b0JBQ2QsU0FBVTt3QkFDUkosVUFBVTduQyxDQUFDO29CQUNiO29CQUNBdTBFLFFBQVE2MUMsTUFBTSxDQUFDN3ZGLEdBQUcsQ0FBQ0EsSUFBSXA4QixNQUFNLEdBQUcsRUFBRSxFQUFFbzhCLEdBQUcsQ0FBQ0EsSUFBSXA4QixNQUFNLEdBQUcsRUFBRTtnQkFDekQsT0FBTztvQkFDTCxJQUFLLElBQUk2b0IsTUFBTSxHQUFHQSxNQUFNLElBQUl1VCxJQUFJcDhCLE1BQU0sRUFBRTZvQixPQUFPLEVBQUc7d0JBQ2hEdXRELFFBQVE2MUMsTUFBTSxDQUFDN3ZGLEdBQUcsQ0FBQ3ZULElBQUksRUFBRXVULEdBQUcsQ0FBQ3ZULE1BQU0sRUFBRTtvQkFDdkM7Z0JBQ0Y7Z0JBQ0E7UUFDSjtJQUNGO0lBQ0F1dEQsVUFBVXEyRTtJQUNWLElBQUlELFVBQVU7UUFDWnAyRSxRQUFRODJFLE1BQU0sQ0FBQzlqSTtJQUNqQixPQUFPO1FBQ0xndEQsUUFBUTgyRSxNQUFNO0lBQ2hCO0lBRUEsd0JBQXdCO0lBQ3hCLElBQUk5MkUsUUFBUTYyRSxXQUFXLEVBQUU7UUFDdkIsOEJBQThCO1FBQzlCNzJFLFFBQVE2MkUsV0FBVyxDQUFDLEVBQUU7SUFDeEI7QUFDRjtBQUNBdEMsTUFBTVksb0JBQW9CLEdBQUcsU0FBVXBpSSxJQUFJLEVBQUVpdEQsT0FBTyxFQUFFaDZDLEdBQUc7SUFDdkQsZ0RBQWdEO0lBQ2hEZzZDLFFBQVErMkUsU0FBUyxHQUFHLzJFLFFBQVFnM0UsV0FBVztJQUN2QyxJQUFJbnNDLFlBQVk5M0YsS0FBSysrQyxNQUFNLENBQUMsU0FBU0MsT0FBTztJQUM1QyxJQUFLLElBQUk1bEUsSUFBSSxHQUFHQSxJQUFJLElBQUk2NUIsSUFBSXA4QixNQUFNLEVBQUV1QyxLQUFLLEVBQUc7UUFDMUMsSUFBSXMxSCxTQUFTO1lBQUN6N0YsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxHQUFHNjVCLEdBQUcsQ0FBQzc1QixFQUFFO1lBQUU2NUIsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxHQUFHNjVCLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUU7U0FBQztRQUMzRCxJQUFJdkMsU0FBUzhFLEtBQUsyd0IsSUFBSSxDQUFDb2lHLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBLE1BQU0sQ0FBQyxFQUFFO1FBQ3BFLElBQUl0dUYsU0FBUztZQUFDc3VGLE1BQU0sQ0FBQyxFQUFFLEdBQUc3M0g7WUFBUSxDQUFDNjNILE1BQU0sQ0FBQyxFQUFFLEdBQUc3M0g7U0FBTztRQUN0RCxJQUFJcXRKLGVBQWU7WUFBQzlqSCxNQUFNLENBQUMsRUFBRSxHQUFHMDNFLFlBQVk7WUFBRzEzRSxNQUFNLENBQUMsRUFBRSxHQUFHMDNFLFlBQVk7U0FBRTtRQUN6RTdxQyxRQUFRMHhFLFNBQVM7UUFDakIxeEUsUUFBUTR4RSxNQUFNLENBQUM1ckgsR0FBRyxDQUFDNzVCLEVBQUUsR0FBRzhxSixZQUFZLENBQUMsRUFBRSxFQUFFanhILEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsR0FBRzhxSixZQUFZLENBQUMsRUFBRTtRQUNyRWozRSxRQUFRNjFDLE1BQU0sQ0FBQzd2RixHQUFHLENBQUM3NUIsRUFBRSxHQUFHOHFKLFlBQVksQ0FBQyxFQUFFLEVBQUVqeEgsR0FBRyxDQUFDNzVCLElBQUksRUFBRSxHQUFHOHFKLFlBQVksQ0FBQyxFQUFFO1FBQ3JFajNFLFFBQVE2MUMsTUFBTSxDQUFDN3ZGLEdBQUcsQ0FBQzc1QixJQUFJLEVBQUUsRUFBRTY1QixHQUFHLENBQUM3NUIsSUFBSSxFQUFFO1FBQ3JDNnpFLFFBQVE2eEUsU0FBUztRQUNqQjd4RSxRQUFRK3VCLElBQUk7SUFDZDtBQUNGO0FBQ0F3bEQsTUFBTXFCLGNBQWMsR0FBRyxTQUFVNTFFLE9BQU8sRUFBRWp0RCxJQUFJLEVBQUVxa0QsT0FBTztJQUNyRCxJQUFJMjNDLEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtJQUMvQixJQUFJeWpHLGFBQWEzRCxHQUFHTyxRQUFRLEtBQUs7SUFDakMsSUFBSSxDQUFDb0QsWUFBWTtRQUNmLElBQUksQ0FBQ3drQyxhQUFhLENBQUNsM0UsU0FBU2p0RCxNQUFNLFVBQVVnOEYsR0FBR1csV0FBVyxFQUFFWCxHQUFHWSxXQUFXLEVBQUVaLEdBQUdhLGFBQWEsRUFBRXg0QztJQUNoRztJQUNBLElBQUksQ0FBQzgvRSxhQUFhLENBQUNsM0UsU0FBU2p0RCxNQUFNLGNBQWNnOEYsR0FBR3o2QyxJQUFJLEVBQUV5NkMsR0FBR3g2QyxJQUFJLEVBQUV3NkMsR0FBR2tCLGdCQUFnQixFQUFFNzRDO0lBQ3ZGLElBQUksQ0FBQzgvRSxhQUFhLENBQUNsM0UsU0FBU2p0RCxNQUFNLGNBQWNnOEYsR0FBR3o2QyxJQUFJLEVBQUV5NkMsR0FBR3g2QyxJQUFJLEVBQUV3NkMsR0FBR2lCLGdCQUFnQixFQUFFNTRDO0lBQ3ZGLElBQUksQ0FBQ3M3QyxZQUFZO1FBQ2YsSUFBSSxDQUFDd2tDLGFBQWEsQ0FBQ2wzRSxTQUFTanRELE1BQU0sVUFBVWc4RixHQUFHYyxTQUFTLEVBQUVkLEdBQUdlLFNBQVMsRUFBRWYsR0FBR2dCLGFBQWEsRUFBRTM0QztJQUM1RjtBQUNGO0FBQ0FtOUUsTUFBTTJDLGFBQWEsR0FBRyxTQUFVbDNFLE9BQU8sRUFBRWp0RCxJQUFJLEVBQUUzaEIsTUFBTSxFQUFFOE0sQ0FBQyxFQUFFeUosQ0FBQyxFQUFFdWtCLEtBQUssRUFBRWtyQyxPQUFPO0lBQ3pFLElBQUk1b0UsTUFBTTBQLE1BQU1BLEtBQUssUUFBUTFQLE1BQU1tWixNQUFNQSxLQUFLLFFBQVFuWixNQUFNMDlCLFVBQVVBLFNBQVMsTUFBTTtRQUNuRjtJQUNGO0lBQ0EsSUFBSTM3QixRQUFPLElBQUk7SUFDZixJQUFJMi9GLGFBQWFuOUUsS0FBSysrQyxNQUFNLENBQUMxZ0UsU0FBUyxnQkFBZ0I1RixLQUFLO0lBQzNELElBQUkwa0csZUFBZSxRQUFRO1FBQ3pCO0lBQ0Y7SUFDQSxJQUFJaW5ELGlCQUFpQnBrSSxLQUFLKytDLE1BQU0sQ0FBQzFnRSxTQUFTLGVBQWU1RixLQUFLLEtBQUssV0FBVyxTQUFTO0lBQ3ZGLElBQUkya0csWUFBWXA5RSxLQUFLKytDLE1BQU0sQ0FBQzFnRSxTQUFTLGVBQWU1RixLQUFLO0lBQ3pELElBQUlxL0csWUFBWTkzRixLQUFLKytDLE1BQU0sQ0FBQyxTQUFTQyxPQUFPO0lBQzVDLElBQUlxbEYsY0FBY3JrSSxLQUFLKytDLE1BQU0sQ0FBQzFnRSxTQUFTO0lBQ3ZDLElBQUk0aUUsYUFBYW9qRixZQUFZNXJKLEtBQUssS0FBSyxlQUFlcS9HLFlBQVl1c0MsWUFBWXJsRixPQUFPO0lBQ3JGLElBQUlxbEYsWUFBWXhrRixLQUFLLEtBQUssS0FBS29CLGNBQWM2MkM7SUFDN0MsSUFBSXdzQyxjQUFjdGtJLEtBQUsrK0MsTUFBTSxDQUFDLFdBQVd0bUUsS0FBSztJQUM5QyxJQUFJNHJFLFlBQVl6cUUsV0FBVztRQUN6QnlxRSxVQUFVaWdGO0lBQ1o7SUFDQSxJQUFJQyxNQUFNdDNFLFFBQVF1M0Usd0JBQXdCO0lBQzFDLElBQUluZ0YsWUFBWSxLQUFLKzRCLGNBQWMsVUFBVTtRQUMzQyw2QkFBNkI7UUFDN0Jud0IsUUFBUXUzRSx3QkFBd0IsR0FBRztRQUNuQ2huSixNQUFLaW5KLGNBQWMsQ0FBQ3gzRSxTQUFTLEtBQUssS0FBSyxLQUFLO1FBQzVDenZFLE1BQUtnbEosZ0JBQWdCLENBQUN2MUUsU0FBUyxLQUFLLEtBQUssS0FBSztRQUM5Q3p2RSxNQUFLa25KLGNBQWMsQ0FBQzFrSSxNQUFNaXRELFNBQVNtM0UsZ0JBQWdCdHNDLFdBQVczYSxZQUFZbDhCLFlBQVk5MUQsR0FBR3lKLEdBQUd1a0I7UUFDNUY4ekMsUUFBUXUzRSx3QkFBd0IsR0FBR0Q7SUFDckMsRUFBRSxvREFBb0Q7SUFFdEQsSUFBSXBqSixRQUFRNmUsS0FBSysrQyxNQUFNLENBQUMxZ0UsU0FBUyxnQkFBZ0I1RixLQUFLO0lBQ3REK0UsTUFBS2luSixjQUFjLENBQUN4M0UsU0FBUzlyRSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFa2pFO0lBQzNEN21FLE1BQUtnbEosZ0JBQWdCLENBQUN2MUUsU0FBUzlyRSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFa2pFO0lBQzdEN21FLE1BQUtrbkosY0FBYyxDQUFDMWtJLE1BQU1pdEQsU0FBU213QixXQUFXMGEsV0FBVzNhLFlBQVlsOEIsWUFBWTkxRCxHQUFHeUosR0FBR3VrQjtBQUN6RjtBQUNBcW9ILE1BQU1rRCxjQUFjLEdBQUcsU0FBVTFrSSxJQUFJLEVBQUVpdEQsT0FBTyxFQUFFK3VCLElBQUksRUFBRThiLFNBQVMsRUFBRXJ6QyxLQUFLLEVBQUVrZ0YsVUFBVSxFQUFFeDVJLENBQUMsRUFBRXlKLENBQUMsRUFBRXVrQixLQUFLO0lBQzdGLElBQUl4aUMsSUFBSSxJQUFJO0lBQ1osSUFBSTBzSixXQUFXLElBQUksQ0FBQ0EsUUFBUSxNQUFNNStFLFVBQVU7SUFDNUMsSUFBSTgrRSxlQUFlO0lBQ25CLElBQUl0akk7SUFDSixJQUFJMmtJLGdCQUFnQjMzRTtJQUNwQixJQUFJNHFDLGNBQWM7UUFDaEIxc0csR0FBR0E7UUFDSHlKLEdBQUdBO0lBQ0w7SUFDQSxJQUFJaWUsUUFBUTdTLEtBQUsrK0MsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztJQUM1QyxJQUFJaWhCLE9BQU8sSUFBSSxDQUFDOC9GLGFBQWEsQ0FBQzFCLFdBQVdqbEY7SUFDekMsSUFBSWd5SCxZQUFZbHVKLEVBQUVnaEgsV0FBVyxDQUFDbHpDLE1BQU07SUFDcEMsSUFBSTQrRSxVQUFVO1FBQ1osSUFBSXpsSixRQUFRakgsRUFBRW11SixjQUFjLEdBQUdudUosRUFBRW11SixjQUFjLElBQUksRUFBRTtRQUNyRCxJQUFJL3NKLE1BQU11YyxXQUFXbXdEO1FBQ3JCLElBQUlzZ0YsYUFBYW5uSixLQUFLLENBQUM3RixJQUFJO1FBQzNCLElBQUlndEosY0FBYyxNQUFNO1lBQ3RCOWtJLE9BQU9ndEQsVUFBVTgzRTtZQUNqQnhCLGVBQWU7UUFDakIsT0FBTztZQUNMdGpJLE9BQU9ndEQsVUFBVSxJQUFJNDJFO1lBQ3JCam1KLEtBQUssQ0FBQzdGLElBQUksR0FBR2tvQjtRQUNmO0lBQ0Y7SUFDQSxJQUFJLENBQUNzakksY0FBYztRQUNqQixJQUFJdDJFLFFBQVEweEUsU0FBUyxFQUFFO1lBQ3JCMXhFLFFBQVEweEUsU0FBUztRQUNuQjtRQUNBLElBQUkwRSxVQUFVO1lBQ1osK0RBQStEO1lBQy9Ed0IsVUFBVWpzQyxJQUFJLENBQUMzckMsU0FBUyxHQUFHLEdBQUc7Z0JBQzVCOWhFLEdBQUc7Z0JBQ0h5SixHQUFHO1lBQ0wsR0FBRztRQUNMLE9BQU87WUFDTGl3SSxVQUFVanNDLElBQUksQ0FBQzNyQyxTQUFTdnpELE1BQU15ZixPQUFPMCtFLGFBQWFDO1FBQ3BEO1FBQ0EsSUFBSTdxQyxRQUFRNnhFLFNBQVMsRUFBRTtZQUNyQjd4RSxRQUFRNnhFLFNBQVM7UUFDbkI7SUFDRjtJQUNBN3hFLFVBQVUyM0U7SUFDVixJQUFJdkIsVUFBVTtRQUNaLDhDQUE4QztRQUM5Q3AyRSxRQUFRK3JFLFNBQVMsQ0FBQzd0SSxHQUFHeUo7UUFDckJxNEQsUUFBUXhKLE1BQU0sQ0FBQ3RxQztRQUNmOHpDLFFBQVFwNkMsS0FBSyxDQUFDblosTUFBTUE7SUFDdEI7SUFDQSxJQUFJc2lGLFNBQVMsWUFBWUEsU0FBUyxRQUFRO1FBQ3hDLElBQUlxbkQsVUFBVTtZQUNacDJFLFFBQVErdUIsSUFBSSxDQUFDLzdFO1FBQ2YsT0FBTztZQUNMZ3RELFFBQVErdUIsSUFBSTtRQUNkO0lBQ0Y7SUFDQSxJQUFJQSxTQUFTLFlBQVlBLFNBQVMsUUFBUTtRQUN4Qy91QixRQUFRbzFFLFNBQVMsR0FBR3NDLGFBQWN0QixDQUFBQSxXQUFXM3BJLE9BQU87UUFDcER1ekQsUUFBUW92QixRQUFRLEdBQUc7UUFDbkIsSUFBSWduRCxVQUFVO1lBQ1pwMkUsUUFBUTgyRSxNQUFNLENBQUM5akk7UUFDakIsT0FBTztZQUNMZ3RELFFBQVE4MkUsTUFBTTtRQUNoQjtJQUNGO0lBQ0EsSUFBSVYsVUFBVTtRQUNaLHNDQUFzQztRQUN0Q3AyRSxRQUFRcDZDLEtBQUssQ0FBQyxJQUFJblosTUFBTSxJQUFJQTtRQUM1QnV6RCxRQUFReEosTUFBTSxDQUFDLENBQUN0cUM7UUFDaEI4ekMsUUFBUStyRSxTQUFTLENBQUMsQ0FBQzd0SSxHQUFHLENBQUN5SjtJQUN6QjtBQUNGO0FBRUEsSUFBSW93SSxRQUFRLENBQUM7QUFDYkEsTUFBTUMsYUFBYSxHQUFHLFNBQVVoNEUsT0FBTyxFQUFFaTRFLEdBQUcsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFbjZJLENBQUMsRUFBRXlKLENBQUMsRUFBRWtCLENBQUMsRUFBRTVWLENBQUM7SUFDdEUscUZBQXFGO0lBQ3JGLElBQUltbEosTUFBTSxLQUFLQyxNQUFNLEtBQUt4dkksS0FBSyxLQUFLNVYsS0FBSyxHQUFHO1FBQzFDO0lBQ0Y7SUFDQSxJQUFJO1FBQ0Yrc0UsUUFBUXlyRSxTQUFTLENBQUN3TSxLQUFLQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJbjZJLEdBQUd5SixHQUFHa0IsR0FBRzVWO0lBQ2xELEVBQUUsT0FBT3BKLEdBQUc7UUFDVnNmLEtBQUt0ZjtJQUNQO0FBQ0Y7QUFDQWt1SixNQUFNTyxrQkFBa0IsR0FBRyxTQUFVdDRFLE9BQU8sRUFBRWk0RSxHQUFHLEVBQUVubEksSUFBSSxFQUFFaFQsS0FBSyxFQUFFeTRJLFdBQVc7SUFDekUsSUFBSTd1SixJQUFJLElBQUk7SUFDWixJQUFJaWYsTUFBTW1LLEtBQUtuRixRQUFRO0lBQ3ZCLElBQUkwWixRQUFRMWUsSUFBSXpLLENBQUM7SUFDakIsSUFBSW9wQixRQUFRM2UsSUFBSWhCLENBQUM7SUFDakIsSUFBSTZ3SSxXQUFXMWxJLEtBQUszRixFQUFFLEdBQUdjLEtBQUs7SUFDOUIsSUFBSXc4RSxrQkFBa0IrdEQsU0FBUy90RCxlQUFlLENBQUNwNEYsSUFBSSxDQUFDbW1KO0lBQ3BELElBQUk1cUcsTUFBTTY4QyxnQkFBZ0IzM0UsTUFBTSxrQkFBa0IsU0FBU2hUO0lBQzNELElBQUkyNEksU0FBU2h1RCxnQkFBZ0IzM0UsTUFBTSxxQkFBcUIsU0FBU2hUO0lBQ2pFLElBQUlrdEgsUUFBUWw2RyxLQUFLZ1UsS0FBSztJQUN0QixJQUFJbW1HLFFBQVFuNkcsS0FBS2lVLE1BQU07SUFDdkIsSUFBSTJ4SCxZQUFZNWxJLEtBQUs4UixPQUFPLEtBQUs7SUFDakMsSUFBSSt6SCxTQUFTM3JCLFFBQVN2aUMsQ0FBQUEsZ0JBQWdCMzNFLE1BQU0sZ0NBQWdDLFNBQVNoVCxXQUFXLFVBQVUsSUFBSTQ0SSxTQUFRO0lBQ3RILElBQUlFLFNBQVMzckIsUUFBU3hpQyxDQUFBQSxnQkFBZ0IzM0UsTUFBTSxpQ0FBaUMsU0FBU2hULFdBQVcsVUFBVSxJQUFJNDRJLFNBQVE7SUFDdkgsSUFBSTNwQyxLQUFLajhGLEtBQUsvakIsUUFBUSxDQUFDa2dCLFFBQVE7SUFDL0IsSUFBSTRwSSxPQUFPcHVELGdCQUFnQjMzRSxNQUFNLG1CQUFtQixTQUFTaFQ7SUFDN0QsSUFBSWc1SSxhQUFhRCxTQUFTO0lBQzFCLElBQUlFLGFBQWF0dUQsZ0JBQWdCMzNFLE1BQU0sNEJBQTRCLFNBQVNoVCxTQUFTeTRJO0lBQ3JGLElBQUlyRixTQUFTem9ELGdCQUFnQjMzRSxNQUFNLDhCQUE4QixTQUFTaFQ7SUFDMUUsSUFBSTBuQixlQUFlMVUsS0FBS2cvQyxNQUFNLENBQUMsaUJBQWlCdG1FLEtBQUs7SUFDckQsSUFBSWc4QixpQkFBaUIsUUFBUUEsZUFBZTFVLEtBQUtnL0MsTUFBTSxDQUFDLGlCQUFpQkMsT0FBTztJQUNoRixJQUFJaW5GLE9BQU9mLElBQUlueEgsS0FBSyxJQUFJbXhILElBQUlnQixPQUFPO0lBQ25DLElBQUlDLE9BQU9qQixJQUFJbHhILE1BQU0sSUFBSWt4SCxJQUFJa0IsT0FBTztJQUVwQyx5Q0FBeUM7SUFDekMsSUFBSSxRQUFRSCxRQUFRLFFBQVFFLE1BQU07UUFDaEM1ckosU0FBU3NoSSxJQUFJLENBQUN3cUIsV0FBVyxDQUFDbkIsTUFBTSwrQkFBK0I7UUFFL0RlLE9BQU9mLElBQUlnQixPQUFPLEdBQUdoQixJQUFJbnhILEtBQUssSUFBSW14SCxJQUFJb0IsV0FBVztRQUNqREgsT0FBT2pCLElBQUlrQixPQUFPLEdBQUdsQixJQUFJbHhILE1BQU0sSUFBSWt4SCxJQUFJcUIsWUFBWTtRQUNuRGhzSixTQUFTc2hJLElBQUksQ0FBQzl2QyxXQUFXLENBQUNtNUQsTUFBTSwrQkFBK0I7SUFDakU7SUFDQSxJQUFJcHZJLElBQUltd0k7SUFDUixJQUFJL2xKLElBQUlpbUo7SUFDUixJQUFJenVELGdCQUFnQjMzRSxNQUFNLG9CQUFvQixTQUFTaFQsV0FBVyxRQUFRO1FBQ3hFLElBQUkycUYsZ0JBQWdCMzNFLE1BQU0sb0JBQW9CLFNBQVNoVCxXQUFXLEtBQUs7WUFDckUrSSxJQUFJNGhGLGdCQUFnQjMzRSxNQUFNLG9CQUFvQixXQUFXaFQsU0FBUzY0STtRQUNwRSxPQUFPO1lBQ0w5dkksSUFBSTRoRixnQkFBZ0IzM0UsTUFBTSxvQkFBb0IsV0FBV2hUO1FBQzNEO0lBQ0Y7SUFDQSxJQUFJMnFGLGdCQUFnQjMzRSxNQUFNLHFCQUFxQixTQUFTaFQsV0FBVyxRQUFRO1FBQ3pFLElBQUkycUYsZ0JBQWdCMzNFLE1BQU0scUJBQXFCLFNBQVNoVCxXQUFXLEtBQUs7WUFDdEU3TSxJQUFJdzNGLGdCQUFnQjMzRSxNQUFNLHFCQUFxQixXQUFXaFQsU0FBUzg0STtRQUNyRSxPQUFPO1lBQ0wzbEosSUFBSXczRixnQkFBZ0IzM0UsTUFBTSxxQkFBcUIsV0FBV2hUO1FBQzVEO0lBQ0Y7SUFDQSxJQUFJK0ksTUFBTSxLQUFLNVYsTUFBTSxHQUFHO1FBQ3RCLFFBQVEsc0VBQXNFO0lBQ2hGO0lBQ0EsSUFBSTI2QyxRQUFRLFdBQVc7UUFDckIsSUFBSWhvQixRQUFRbDNCLEtBQUsrVSxHQUFHLENBQUNrMUksU0FBUzl2SSxHQUFHK3ZJLFNBQVMzbEo7UUFDMUM0VixLQUFLK2M7UUFDTDN5QixLQUFLMnlCO0lBQ1AsT0FBTyxJQUFJZ29CLFFBQVEsU0FBUztRQUMxQixJQUFJaG9CLFFBQVFsM0IsS0FBSzZVLEdBQUcsQ0FBQ28xSSxTQUFTOXZJLEdBQUcrdkksU0FBUzNsSjtRQUMxQzRWLEtBQUsrYztRQUNMM3lCLEtBQUsyeUI7SUFDUDtJQUNBLElBQUkxbkIsSUFBSW1wQixRQUFRc3hILFNBQVMsR0FBRyxPQUFPO0lBQ25DLElBQUlZLFlBQVk5dUQsZ0JBQWdCMzNFLE1BQU0seUJBQXlCLFNBQVNoVDtJQUN4RSxJQUFJMDVJLFlBQVkvdUQsZ0JBQWdCMzNFLE1BQU0seUJBQXlCLFdBQVdoVDtJQUMxRSxJQUFJeTVJLGNBQWMsS0FBSztRQUNyQnI3SSxLQUFLLENBQUN5NkksU0FBUzl2SSxDQUFBQSxJQUFLMndJO0lBQ3RCLE9BQU87UUFDTHQ3SSxLQUFLczdJO0lBQ1A7SUFDQSxJQUFJQyxZQUFZaHZELGdCQUFnQjMzRSxNQUFNLHVCQUF1QixTQUFTaFQ7SUFDdEUsSUFBSTQ1SSxZQUFZanZELGdCQUFnQjMzRSxNQUFNLHVCQUF1QixXQUFXaFQ7SUFDeEUsSUFBSTI1SSxjQUFjLEtBQUs7UUFDckJ2N0ksS0FBSyxDQUFDeTZJLFNBQVM5dkksQ0FBQUEsSUFBSzZ3STtJQUN0QixPQUFPO1FBQ0x4N0ksS0FBS3c3STtJQUNQO0lBQ0EsSUFBSS94SSxJQUFJMmYsUUFBUXN4SCxTQUFTLEdBQUcsTUFBTTtJQUNsQyxJQUFJZSxZQUFZbHZELGdCQUFnQjMzRSxNQUFNLHlCQUF5QixTQUFTaFQ7SUFDeEUsSUFBSTg1SSxZQUFZbnZELGdCQUFnQjMzRSxNQUFNLHlCQUF5QixXQUFXaFQ7SUFDMUUsSUFBSTY1SSxjQUFjLEtBQUs7UUFDckJoeUksS0FBSyxDQUFDaXhJLFNBQVMzbEosQ0FBQUEsSUFBSzJtSjtJQUN0QixPQUFPO1FBQ0xqeUksS0FBS2l5STtJQUNQO0lBQ0EsSUFBSUMsWUFBWXB2RCxnQkFBZ0IzM0UsTUFBTSx1QkFBdUIsU0FBU2hUO0lBQ3RFLElBQUlnNkksWUFBWXJ2RCxnQkFBZ0IzM0UsTUFBTSx1QkFBdUIsV0FBV2hUO0lBQ3hFLElBQUkrNUksY0FBYyxLQUFLO1FBQ3JCbHlJLEtBQUssQ0FBQ2l4SSxTQUFTM2xKLENBQUFBLElBQUs2bUo7SUFDdEIsT0FBTztRQUNMbnlJLEtBQUtteUk7SUFDUDtJQUNBLElBQUkvcUMsR0FBRzRuQyxTQUFTLEVBQUU7UUFDaEJ6NEksS0FBS21wQjtRQUNMMWYsS0FBSzJmO1FBQ0xELFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsSUFBSXl5SCxTQUFTLzVFLFFBQVFzekUsV0FBVztJQUNoQ3R6RSxRQUFRc3pFLFdBQVcsR0FBR3lGO0lBQ3RCLElBQUlpQixtQkFBbUJ0d0osRUFBRTBwSixlQUFlLENBQUNwekU7SUFDekMsSUFBSWk2RSxzQkFBc0I7SUFDMUIsSUFBSS9HLFdBQVcsUUFBUThHLGtCQUFrQjtRQUN2Q3R3SixFQUFFc21KLGVBQWUsQ0FBQ2h3RSxTQUFTO1FBQzNCaTZFLHNCQUFzQjtJQUN4QixPQUFPLElBQUkvRyxXQUFXLFNBQVMsQ0FBQzhHLGtCQUFrQjtRQUNoRHR3SixFQUFFc21KLGVBQWUsQ0FBQ2h3RSxTQUFTO1FBQzNCaTZFLHNCQUFzQjtJQUN4QjtJQUNBLElBQUl4QixXQUFXLGFBQWE7UUFDMUIsSUFBSUssWUFBWTtZQUNkOTRFLFFBQVFrNkUsSUFBSTtZQUNaLElBQUluckMsR0FBRzRuQyxTQUFTLEVBQUU7Z0JBQ2hCMzJFLFFBQVE2NEUsSUFBSSxDQUFDOXBDLEdBQUc0bkMsU0FBUztZQUMzQixPQUFPO2dCQUNManRKLEVBQUVpdUUsVUFBVSxDQUFDanVFLEVBQUVzbEgsWUFBWSxDQUFDbDhGLE1BQU0sQ0FBQzY0RixJQUFJLENBQUMzckMsU0FBUzM0QyxPQUFPQyxPQUFPcXhILFFBQVFDLFFBQVFweEgsY0FBY3VuRjtnQkFDN0YvdUMsUUFBUTY0RSxJQUFJO1lBQ2Q7UUFDRjtRQUNBbnZKLEVBQUVzdUosYUFBYSxDQUFDaDRFLFNBQVNpNEUsS0FBSyxHQUFHLEdBQUdlLE1BQU1FLE1BQU1oN0ksR0FBR3lKLEdBQUdrQixHQUFHNVY7UUFDekQsSUFBSTZsSixZQUFZO1lBQ2Q5NEUsUUFBUTN5RCxPQUFPO1FBQ2pCO0lBQ0YsT0FBTztRQUNMLElBQUk2akMsVUFBVTh1QixRQUFRbTZFLGFBQWEsQ0FBQ2xDLEtBQUtRO1FBQ3pDejRFLFFBQVErMkUsU0FBUyxHQUFHN2xHO1FBQ3BCeG5ELEVBQUVpdUUsVUFBVSxDQUFDanVFLEVBQUVzbEgsWUFBWSxDQUFDbDhGLE1BQU0sQ0FBQzY0RixJQUFJLENBQUMzckMsU0FBUzM0QyxPQUFPQyxPQUFPcXhILFFBQVFDLFFBQVFweEgsY0FBY3VuRjtRQUM3Ri91QyxRQUFRK3JFLFNBQVMsQ0FBQzd0SSxHQUFHeUo7UUFDckJxNEQsUUFBUSt1QixJQUFJO1FBQ1ovdUIsUUFBUStyRSxTQUFTLENBQUMsQ0FBQzd0SSxHQUFHLENBQUN5SjtJQUN6QjtJQUNBcTRELFFBQVFzekUsV0FBVyxHQUFHeUc7SUFDdEIsSUFBSUUscUJBQXFCO1FBQ3ZCdndKLEVBQUVzbUosZUFBZSxDQUFDaHdFLFNBQVNnNkU7SUFDN0I7QUFDRjtBQUVBLElBQUlJLFFBQVEsQ0FBQztBQUNiQSxNQUFNN1Asb0JBQW9CLEdBQUcsU0FBVXIvSCxHQUFHLEVBQUUwYSxLQUFLO0lBQy9DLElBQUksQ0FBQ0EsT0FBTztRQUNWLElBQUl4VixPQUFPbEYsSUFBSWlDLEVBQUUsR0FBR2lELElBQUk7UUFDeEIsSUFBSTh0RSxVQUFVLElBQUksQ0FBQzJtRCxhQUFhO1FBQ2hDLElBQUk0QixNQUFNLzNJLEtBQUs0eEIsSUFBSSxDQUFDNkMsS0FBSy9TLE9BQU84dEUsV0FBVyw4QkFBOEI7UUFFekV0NEQsUUFBUWwzQixLQUFLNnhCLEdBQUcsQ0FBQyxHQUFHa21IO0lBQ3RCO0lBQ0EsSUFBSTRULGVBQWVudkksSUFBSTRtRCxNQUFNLENBQUMsYUFBYUMsT0FBTyxHQUFHbnNDO0lBQ3JELElBQUkwMEgsVUFBVXB2SSxJQUFJNG1ELE1BQU0sQ0FBQyx3QkFBd0JDLE9BQU87SUFDeEQsSUFBSXNvRixlQUFlQyxTQUFTO1FBQzFCLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBRixNQUFNdEUsZUFBZSxHQUFHLFNBQVU5MUUsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWduSSxtQkFBbUIsRUFBRXhnRixLQUFLLEVBQUV0Z0UsTUFBTTtJQUNoRixJQUFJbXBKLGdCQUFnQnJxSixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDeEYsSUFBSXhHLElBQUksSUFBSTtJQUNaLElBQUlnb0UsU0FBUyxNQUFNO1FBQ2pCLElBQUk2b0YsaUJBQWlCLENBQUM3d0osRUFBRTZnSixvQkFBb0IsQ0FBQ3IvSCxNQUFNO1lBQ2pEO1FBQ0Y7SUFDRixPQUFPLElBQUl3bUQsVUFBVSxPQUFPO1FBQzFCO0lBQ0Y7SUFDQSxJQUFJeG1ELElBQUlvRSxNQUFNLElBQUk7UUFDaEIsSUFBSXFsRCxRQUFRenBELElBQUk0bUQsTUFBTSxDQUFDO1FBQ3ZCLElBQUksQ0FBQzZDLFNBQVMsQ0FBQ0EsTUFBTW5wRSxLQUFLLEVBQUU7WUFDMUI7UUFDRjtRQUNBLElBQUlnbEcsZ0JBQWdCOW1HLEVBQUUyZ0kscUJBQXFCLENBQUNuL0c7UUFDNUM4MEQsUUFBUXc2RSxTQUFTLEdBQUdocUQ7UUFDcEJ4d0IsUUFBUXk2RSxZQUFZLEdBQUc7SUFDekIsT0FBTztRQUNMLElBQUl6MUIsVUFBVTk1RyxJQUFJcmMsT0FBTyxHQUFHRSxRQUFRLENBQUNrZ0IsUUFBUSxDQUFDKzFHLE9BQU87UUFDckQsSUFBSTAxQixTQUFTeHZJLElBQUk0bUQsTUFBTSxDQUFDO1FBQ3hCLElBQUk2b0YsV0FBV3p2SSxJQUFJNG1ELE1BQU0sQ0FBQztRQUMxQixJQUFJOG9GLFdBQVcxdkksSUFBSTRtRCxNQUFNLENBQUM7UUFDMUIsSUFBSWt6RCxXQUFXLENBQUMsQ0FBQzAxQixVQUFVLENBQUNBLE9BQU9sdkosS0FBSyxLQUFNLEVBQUNtdkosWUFBWSxDQUFDQSxTQUFTbnZKLEtBQUssS0FBTSxFQUFDb3ZKLFlBQVksQ0FBQ0EsU0FBU3B2SixLQUFLLEdBQUc7WUFDN0c7UUFDRjtRQUNBdzBFLFFBQVF3NkUsU0FBUyxHQUFHO1FBQ3BCeDZFLFFBQVF5NkUsWUFBWSxHQUFHO0lBQ3pCO0lBQ0EsSUFBSUksZ0JBQWdCLENBQUMzSTtJQUNyQixJQUFJOXRIO0lBQ0osSUFBSTh0SCxxQkFBcUI7UUFDdkI5dEgsS0FBSzh0SDtRQUNMbHlFLFFBQVErckUsU0FBUyxDQUFDLENBQUMzbkgsR0FBRzUwQixFQUFFLEVBQUUsQ0FBQzQwQixHQUFHMTBCLEVBQUU7SUFDbEM7SUFDQSxJQUFJMEIsVUFBVSxNQUFNO1FBQ2xCMUgsRUFBRW1zSixRQUFRLENBQUM3MUUsU0FBUzkwRCxLQUFLLE1BQU0ydkksZUFBZU47UUFDOUMsSUFBSXJ2SSxJQUFJbTZCLE1BQU0sSUFBSTtZQUNoQjM3QyxFQUFFbXNKLFFBQVEsQ0FBQzcxRSxTQUFTOTBELEtBQUssVUFBVTJ2SSxlQUFlTjtZQUNsRDd3SixFQUFFbXNKLFFBQVEsQ0FBQzcxRSxTQUFTOTBELEtBQUssVUFBVTJ2SSxlQUFlTjtRQUNwRDtJQUNGLE9BQU87UUFDTDd3SixFQUFFbXNKLFFBQVEsQ0FBQzcxRSxTQUFTOTBELEtBQUs5WixRQUFReXBKLGVBQWVOO0lBQ2xEO0lBQ0EsSUFBSXJJLHFCQUFxQjtRQUN2Qmx5RSxRQUFRK3JFLFNBQVMsQ0FBQzNuSCxHQUFHNTBCLEVBQUUsRUFBRTQwQixHQUFHMTBCLEVBQUU7SUFDaEM7QUFDRjtBQUNBMHFKLE1BQU1VLFlBQVksR0FBRyxTQUFVOTZFLE9BQU87SUFDcEMsSUFBSXJ2RTtJQUNKLElBQUksQ0FBQ29xSixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLElBQUksRUFBRTtJQUN2QyxJQUFLLElBQUk1dUosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzR1SixVQUFVLENBQUNueEosTUFBTSxFQUFFdUMsSUFBSztRQUMvQ3dFLFFBQVEsSUFBSSxDQUFDb3FKLFVBQVUsQ0FBQzV1SixFQUFFO1FBQzFCLElBQUl3RSxNQUFNcXZFLE9BQU8sS0FBS0EsU0FBUztZQUM3QixPQUFPcnZFO1FBQ1Q7SUFDRjtJQUNBQSxRQUFRO1FBQ05xdkUsU0FBU0E7SUFDWDtJQUNBLElBQUksQ0FBQys2RSxVQUFVLENBQUMzdUosSUFBSSxDQUFDdUU7SUFDckIsT0FBT0E7QUFDVDtBQUVBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEN5cEosTUFBTVksY0FBYyxHQUFHLFNBQVVoN0UsT0FBTyxFQUFFOTBELEdBQUc7SUFDM0MsSUFBSXF2SSxnQkFBZ0JycUosVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ3hGLGFBQWE7SUFDYixJQUFJK3FKLGFBQWEvdkksSUFBSTRtRCxNQUFNLENBQUMsY0FBYzhDLFFBQVE7SUFDbEQsSUFBSXNtRixZQUFZaHdJLElBQUk0bUQsTUFBTSxDQUFDLGFBQWFDLE9BQU8sR0FBRztJQUNsRCxJQUFJb3BGLGNBQWNqd0ksSUFBSTRtRCxNQUFNLENBQUMsZUFBZThDLFFBQVE7SUFDcEQsSUFBSXdtRixjQUFjbHdJLElBQUk0bUQsTUFBTSxDQUFDLGVBQWU4QyxRQUFRO0lBQ3BELElBQUl3QyxVQUFVbWpGLGdCQUFnQnJ2SSxJQUFJby9ELGdCQUFnQixLQUFLcC9ELElBQUk0bUQsTUFBTSxDQUFDLGdCQUFnQnRtRSxLQUFLLEdBQUc7SUFDMUYsSUFBSXdyRSxpQkFBaUI5ckQsSUFBSTRtRCxNQUFNLENBQUMsd0JBQXdCdG1FLEtBQUssR0FBRzRyRTtJQUNoRSxJQUFJbGpFLFFBQVFnWCxJQUFJNG1ELE1BQU0sQ0FBQyxTQUFTdG1FLEtBQUs7SUFDckMsSUFBSTZ2SixlQUFlbndJLElBQUk0bUQsTUFBTSxDQUFDLHNCQUFzQnRtRSxLQUFLO0lBQ3pEdzBFLFFBQVFpckQsSUFBSSxHQUFHZ3dCLGFBQWEsTUFBTUcsY0FBYyxNQUFNRixZQUFZLE1BQU1DO0lBQ3hFbjdFLFFBQVFvdkIsUUFBUSxHQUFHLFNBQVMsaUNBQWlDO0lBRTdELElBQUksQ0FBQ29vRCxjQUFjLENBQUN4M0UsU0FBUzlyRSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFa2pFO0lBQzNELElBQUksQ0FBQ20rRSxnQkFBZ0IsQ0FBQ3YxRSxTQUFTcTdFLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVya0Y7QUFDcEY7QUFDQSxTQUFTOGpDLE9BQU82YSxHQUFHLEVBQUV6M0csQ0FBQyxFQUFFeUosQ0FBQyxFQUFFbWYsS0FBSyxFQUFFQyxNQUFNO0lBQ3RDLElBQUl1MEgsV0FBVzVzSixLQUFLK1UsR0FBRyxDQUFDcWpCLE9BQU9DO0lBQy9CLElBQUlRLFNBQVMrekgsV0FBVztJQUN4QixJQUFJMXpJLFVBQVUxSixJQUFJNG9CLFFBQVE7SUFDMUIsSUFBSWpmLFVBQVVGLElBQUlvZixTQUFTO0lBQzNCNHVGLElBQUkrN0IsU0FBUztJQUNiLzdCLElBQUlHLEdBQUcsQ0FBQ2x1RyxTQUFTQyxTQUFTMGYsUUFBUSxHQUFHNzRCLEtBQUtzWixFQUFFLEdBQUc7SUFDL0MydEcsSUFBSWs4QixTQUFTO0FBQ2Y7QUFDQSxTQUFTMEosVUFBVTVsQyxHQUFHLEVBQUV6M0csQ0FBQyxFQUFFeUosQ0FBQyxFQUFFbWYsS0FBSyxFQUFFQyxNQUFNO0lBQ3pDLElBQUlRLFNBQVNyM0IsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2pGLElBQUl4RyxJQUFJZ0YsS0FBSytVLEdBQUcsQ0FBQzhqQixRQUFRVCxRQUFRLEdBQUdDLFNBQVMsSUFBSSxtQkFBbUI7SUFDcEU0dUYsSUFBSSs3QixTQUFTO0lBQ2IvN0IsSUFBSWk4QixNQUFNLENBQUMxekksSUFBSXhVLEdBQUdpZTtJQUNsQmd1RyxJQUFJRSxNQUFNLENBQUMzM0csSUFBSTRvQixRQUFRcDlCLEdBQUdpZTtJQUMxQmd1RyxJQUFJMjdCLGdCQUFnQixDQUFDcHpJLElBQUk0b0IsT0FBT25mLEdBQUd6SixJQUFJNG9CLE9BQU9uZixJQUFJamU7SUFDbERpc0gsSUFBSUUsTUFBTSxDQUFDMzNHLElBQUk0b0IsT0FBT25mLElBQUlvZixTQUFTcjlCO0lBQ25DaXNILElBQUkyN0IsZ0JBQWdCLENBQUNwekksSUFBSTRvQixPQUFPbmYsSUFBSW9mLFFBQVE3b0IsSUFBSTRvQixRQUFRcDlCLEdBQUdpZSxJQUFJb2Y7SUFDL0Q0dUYsSUFBSUUsTUFBTSxDQUFDMzNHLElBQUl4VSxHQUFHaWUsSUFBSW9mO0lBQ3RCNHVGLElBQUkyN0IsZ0JBQWdCLENBQUNwekksR0FBR3lKLElBQUlvZixRQUFRN29CLEdBQUd5SixJQUFJb2YsU0FBU3I5QjtJQUNwRGlzSCxJQUFJRSxNQUFNLENBQUMzM0csR0FBR3lKLElBQUlqZTtJQUNsQmlzSCxJQUFJMjdCLGdCQUFnQixDQUFDcHpJLEdBQUd5SixHQUFHekosSUFBSXhVLEdBQUdpZTtJQUNsQ2d1RyxJQUFJazhCLFNBQVM7QUFDZjtBQUNBdUksTUFBTTNHLFlBQVksR0FBRyxTQUFVdm9JLEdBQUcsRUFBRTlaLE1BQU07SUFDeEMsSUFBSWlsRTtJQUNKLElBQUkzb0QsS0FBS3hDLElBQUluYyxRQUFRO0lBQ3JCLElBQUlrZ0IsV0FBV3ZCLEdBQUd1QixRQUFRO0lBQzFCLElBQUl1c0ksUUFBUXBxSixTQUFTQSxTQUFTLE1BQU07SUFDcEMsSUFBSWlrRSxXQUFXbnFELElBQUk0bUQsTUFBTSxDQUFDMHBGLFFBQVE7SUFDbEMsSUFBSW5tRixTQUFTVCxRQUFRLEtBQUssY0FBYztRQUN0QyxJQUFJNm1GLFlBQVlqd0ksb0JBQW9CeUQsVUFBVSxjQUFjN2Q7UUFDNURpbEUsUUFBUW5yRCxJQUFJbTZCLE1BQU0sS0FBS28yRyxZQUFZO0lBQ3JDLE9BQU8sSUFBSXBtRixTQUFTVCxRQUFRLEtBQUssUUFBUTtRQUN2Q3lCLFFBQVE7SUFDVixPQUFPO1FBQ0xBLFFBQVFoQixTQUFTdEQsT0FBTztJQUMxQjtJQUNBLE9BQU9zRTtBQUNUO0FBQ0ErakYsTUFBTXZFLFFBQVEsR0FBRyxTQUFVNzFFLE9BQU8sRUFBRTkwRCxHQUFHLEVBQUU5WixNQUFNO0lBQzdDLElBQUl5cEosZ0JBQWdCM3FKLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUN4RixJQUFJcXFKLGdCQUFnQnJxSixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDeEYsSUFBSXdkLEtBQUt4QyxJQUFJbmMsUUFBUTtJQUNyQixJQUFJa2dCLFdBQVd2QixHQUFHdUIsUUFBUTtJQUMxQixJQUFJczdELGdCQUFnQmd3RSxnQkFBZ0JydkksSUFBSW8vRCxnQkFBZ0IsS0FBSztJQUM3RCxJQUFJaXdFLGlCQUFrQmh3RSxDQUFBQSxrQkFBa0IsS0FBS3IvRCxJQUFJNG1ELE1BQU0sQ0FBQyxnQkFBZ0J0bUUsS0FBSyxLQUFLLElBQUk7UUFDcEY7SUFDRjtJQUVBLCtEQUErRDtJQUMvRCxJQUFJNEYsV0FBVyxRQUFRO1FBQ3JCQSxTQUFTO0lBQ1g7SUFDQSxJQUFJdTBILFFBQVFuNkcsb0JBQW9CeUQsVUFBVSxVQUFVN2Q7SUFDcEQsSUFBSXcwSCxRQUFRcDZHLG9CQUFvQnlELFVBQVUsVUFBVTdkO0lBQ3BELElBQUlzcUosVUFBVUMsVUFBVSxvQkFBb0I7SUFDNUMsSUFBSXZ3RixPQUFPLElBQUksQ0FBQys4RCxZQUFZLENBQUNqOUcsS0FBSzlaO0lBQ2xDLElBQUlnNkQsUUFBUSxRQUFRQSxTQUFTLE1BQU0sQ0FBQzU4RCxNQUFNbTNILFVBQVUsQ0FBQ24zSCxNQUFNbzNILFFBQVE7UUFDakUsSUFBSSxDQUFDbzFCLGNBQWMsQ0FBQ2g3RSxTQUFTOTBELEtBQUtxdkk7UUFDbEMsSUFBSWlCLFFBQVFwcUosU0FBU0EsU0FBUyxNQUFNO1FBQ3BDLElBQUl3cUosUUFBUXB3SSxvQkFBb0J5RCxVQUFVLGNBQWM3ZDtRQUN4RCxJQUFJeXFKLFFBQVFyd0ksb0JBQW9CeUQsVUFBVSxlQUFlN2Q7UUFDekQsSUFBSStqRSxVQUFVanFELElBQUk0bUQsTUFBTSxDQUFDMHBGLFFBQVEsaUJBQWlCenBGLE9BQU87UUFDekQsSUFBSXFELFVBQVVscUQsSUFBSTRtRCxNQUFNLENBQUMwcEYsUUFBUSxpQkFBaUJ6cEYsT0FBTztRQUN6RCxJQUFJMXNCLFNBQVNuNkIsSUFBSW02QixNQUFNO1FBQ3ZCLElBQUl3dkIsU0FBUzNwRCxJQUFJNG1ELE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7UUFDNUMsSUFBSXNwRSxTQUFTNXBELElBQUk0bUQsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztRQUM1QyxJQUFJNjVDLFFBQVE7WUFDVnd2QixTQUFTO1lBQ1RDLFNBQVM7UUFDWDtRQUNBNndELFNBQVN4d0Q7UUFDVHl3RCxTQUFTeHdEO1FBQ1QsSUFBSWlCO1FBQ0osSUFBSSxDQUFDd2tGLGVBQWU7WUFDbEJ4a0YsUUFBUTtRQUNWLE9BQU87WUFDTEEsUUFBUSxJQUFJLENBQUNvOUUsWUFBWSxDQUFDdm9JLEtBQUs5WjtRQUNqQztRQUNBLElBQUlpbEUsVUFBVSxHQUFHO1lBQ2ZxbEYsV0FBVy8xQjtZQUNYZzJCLFdBQVcvMUI7WUFDWDVsRCxRQUFRK3JFLFNBQVMsQ0FBQzJQLFVBQVVDO1lBQzVCMzdFLFFBQVF4SixNQUFNLENBQUNIO1lBQ2ZzdkQsUUFBUTtZQUNSQyxRQUFRO1FBQ1Y7UUFDQSxPQUFROXdEO1lBQ04sS0FBSztnQkFDSDtZQUNGLEtBQUs7Z0JBQ0g4d0QsU0FBU2kyQixRQUFRO2dCQUNqQjtZQUNGLEtBQUs7Z0JBQ0hqMkIsU0FBU2kyQjtnQkFDVDtRQUNKO1FBQ0EsSUFBSUMsb0JBQW9CNXdJLElBQUk0bUQsTUFBTSxDQUFDLDJCQUEyQnRtRSxLQUFLO1FBQ25FLElBQUl5c0UsZ0JBQWdCL3NELElBQUk0bUQsTUFBTSxDQUFDLHVCQUF1QnRtRSxLQUFLO1FBQzNELElBQUl1d0osa0JBQWtCN3dJLElBQUk0bUQsTUFBTSxDQUFDLHFCQUFxQkMsT0FBTztRQUM3RCxJQUFJaXFGLG9CQUFvQjl3SSxJQUFJNG1ELE1BQU0sQ0FBQywyQkFBMkJDLE9BQU87UUFDckUsSUFBSWtxRixhQUFhL3dJLElBQUk0bUQsTUFBTSxDQUFDLHlCQUF5QjhDLFFBQVE7UUFDN0QsSUFBSXNuRixVQUFVRCxlQUFlLHFCQUFxQkEsZUFBZTtRQUNqRSxJQUFJRSxVQUFVRixlQUFlO1FBQzdCLElBQUlHLGNBQWM7UUFDbEIsSUFBSU4sb0JBQW9CLEtBQUtDLGtCQUFrQixLQUFLOWpGLGdCQUFnQixHQUFHO1lBQ3JFLElBQUlva0YsV0FBV3I4RSxRQUFRKzJFLFNBQVM7WUFDaEMsSUFBSXVGLGFBQWF0OEUsUUFBUWczRSxXQUFXO1lBQ3BDLElBQUl1RixnQkFBZ0J2OEUsUUFBUW8xRSxTQUFTO1lBQ3JDLElBQUlvSCxzQkFBc0J0eEksSUFBSTRtRCxNQUFNLENBQUMseUJBQXlCdG1FLEtBQUs7WUFDbkUsSUFBSWl4SixrQkFBa0J2eEksSUFBSTRtRCxNQUFNLENBQUMscUJBQXFCdG1FLEtBQUs7WUFDM0QsSUFBSWt4SixrQkFBa0J4eEksSUFBSTRtRCxNQUFNLENBQUMscUJBQXFCdG1FLEtBQUs7WUFDM0QsSUFBSW14SixTQUFTYixvQkFBb0I7WUFDakMsSUFBSWMsV0FBV2Isa0JBQWtCLEtBQUs5akYsZ0JBQWdCO1lBQ3RELElBQUk0a0YsTUFBTWwzQixRQUFRcTJCO1lBQ2xCLE9BQVFubkY7Z0JBQ04sS0FBSztvQkFDSGdvRixPQUFPakI7b0JBQ1A7Z0JBQ0YsS0FBSztvQkFDSGlCLE9BQU9qQixRQUFRO29CQUNmO1lBQ0o7WUFDQSxJQUFJa0IsTUFBTWwzQixRQUFRaTJCLFFBQVFHO1lBQzFCLElBQUllLE1BQU1uQixRQUFRLElBQUlJO1lBQ3RCLElBQUlnQixNQUFNbkIsUUFBUSxJQUFJRztZQUN0QixJQUFJVyxRQUFRO2dCQUNWMzhFLFFBQVErMkUsU0FBUyxHQUFHLFFBQVFwaUksTUFBTSxDQUFDNm5JLG1CQUFtQixDQUFDLEVBQUUsRUFBRSxLQUFLN25JLE1BQU0sQ0FBQzZuSSxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsS0FBSzduSSxNQUFNLENBQUM2bkksbUJBQW1CLENBQUMsRUFBRSxFQUFFLEtBQUs3bkksTUFBTSxDQUFDbW5JLG9CQUFvQnZ4RSxlQUFlO1lBQ3BMO1lBQ0EsSUFBSXF5RSxVQUFVO2dCQUNaNThFLFFBQVFnM0UsV0FBVyxHQUFHLFFBQVFyaUksTUFBTSxDQUFDOG5JLGVBQWUsQ0FBQyxFQUFFLEVBQUUsS0FBSzluSSxNQUFNLENBQUM4bkksZUFBZSxDQUFDLEVBQUUsRUFBRSxLQUFLOW5JLE1BQU0sQ0FBQzhuSSxlQUFlLENBQUMsRUFBRSxFQUFFLEtBQUs5bkksTUFBTSxDQUFDc2pELGdCQUFnQnNTLGVBQWU7Z0JBQ3BLdkssUUFBUW8xRSxTQUFTLEdBQUcyRztnQkFDcEIsSUFBSS83RSxRQUFRNjJFLFdBQVcsRUFBRTtvQkFDdkIsT0FBUTZGO3dCQUNOLEtBQUs7NEJBQ0gxOEUsUUFBUTYyRSxXQUFXLENBQUM7Z0NBQUM7Z0NBQUc7NkJBQUU7NEJBQzFCO3dCQUNGLEtBQUs7NEJBQ0g3MkUsUUFBUTYyRSxXQUFXLENBQUM7Z0NBQUM7Z0NBQUc7NkJBQUU7NEJBQzFCO3dCQUNGLEtBQUs7NEJBQ0g3MkUsUUFBUW8xRSxTQUFTLEdBQUcyRyxrQkFBa0I7NEJBQ3RDLzdFLFFBQVE2MkUsV0FBVyxDQUFDLEVBQUU7NEJBQ3RCO3dCQUNGLEtBQUs7d0JBQ0w7NEJBQ0U3MkUsUUFBUTYyRSxXQUFXLENBQUMsRUFBRTs0QkFDdEI7b0JBQ0o7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlxRixTQUFTO2dCQUNYbDhFLFFBQVEweEUsU0FBUztnQkFDakI2SixVQUFVdjdFLFNBQVM2OEUsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS1o7WUFDekMsT0FBTyxJQUFJRCxTQUFTO2dCQUNsQm44RSxRQUFRMHhFLFNBQVM7Z0JBQ2pCNTJDLE9BQU85NkIsU0FBUzY4RSxLQUFLQyxLQUFLQyxLQUFLQztZQUNqQyxPQUFPO2dCQUNMaDlFLFFBQVEweEUsU0FBUztnQkFDakIxeEUsUUFBUXF0QyxJQUFJLENBQUN3dkMsS0FBS0MsS0FBS0MsS0FBS0M7WUFDOUI7WUFDQSxJQUFJTCxRQUFRMzhFLFFBQVErdUIsSUFBSTtZQUN4QixJQUFJNnRELFVBQVU1OEUsUUFBUTgyRSxNQUFNO1lBRTVCLHdDQUF3QztZQUN4QyxJQUFJOEYsWUFBWUYsb0JBQW9CLFVBQVU7Z0JBQzVDLElBQUlPLGFBQWFsQixrQkFBa0I7Z0JBQ25DLzdFLFFBQVEweEUsU0FBUztnQkFDakIsSUFBSXdLLFNBQVM7b0JBQ1hYLFVBQVV2N0UsU0FBUzY4RSxNQUFNSSxZQUFZSCxNQUFNRyxZQUFZRixNQUFNLElBQUlFLFlBQVlELE1BQU0sSUFBSUMsWUFBWWI7Z0JBQ3JHLE9BQU87b0JBQ0xwOEUsUUFBUXF0QyxJQUFJLENBQUN3dkMsTUFBTUksWUFBWUgsTUFBTUcsWUFBWUYsTUFBTSxJQUFJRSxZQUFZRCxNQUFNLElBQUlDO2dCQUNuRjtnQkFDQWo5RSxRQUFRODJFLE1BQU07WUFDaEI7WUFDQTkyRSxRQUFRKzJFLFNBQVMsR0FBR3NGO1lBQ3BCcjhFLFFBQVFnM0UsV0FBVyxHQUFHc0Y7WUFDdEJ0OEUsUUFBUW8xRSxTQUFTLEdBQUdtSDtZQUNwQixJQUFJdjhFLFFBQVE2MkUsV0FBVyxFQUFFNzJFLFFBQVE2MkUsV0FBVyxDQUFDLEVBQUU7UUFDakQ7UUFDQSxJQUFJekIsWUFBWSxJQUFJbHFJLElBQUk0bUQsTUFBTSxDQUFDLHNCQUFzQkMsT0FBTyxFQUFFLG1EQUFtRDtRQUVqSCxJQUFJcWpGLFlBQVksR0FBRztZQUNqQnAxRSxRQUFRbzFFLFNBQVMsR0FBR0E7UUFDdEI7UUFDQSxJQUFJbHFJLElBQUk0bUQsTUFBTSxDQUFDLGFBQWF0bUUsS0FBSyxLQUFLLFFBQVE7WUFDNUMsSUFBSXlsQyxRQUFRemxCLG9CQUFvQnlELFVBQVUsd0JBQXdCN2Q7WUFDbEUsSUFBSW0zSCxhQUFhLzhHLG9CQUFvQnlELFVBQVUsbUJBQW1CN2Q7WUFDbEUsSUFBSThySixZQUFZdEIsUUFBUTtZQUN4QixJQUFJcHJELGdCQUFnQixJQUFJLENBQUM2NUIscUJBQXFCLENBQUNuL0c7WUFDL0MsSUFBSXNsRixrQkFBa0I7aUJBQWUsSUFBSTM3QixXQUFXLFFBQVE7Z0JBQzFELDZCQUE2QjtnQkFDN0IsSUFBSTI3QixrQkFBa0IsUUFBUTtvQkFDNUJtMUIsU0FBUyxDQUFDaTJCO2dCQUNaLE9BQU8sSUFBSXByRCxrQkFBa0IsVUFBVTtvQkFDckNtMUIsU0FBUyxDQUFDdTNCO2dCQUNaLEVBQUUsb0JBQW9CO1lBQ3hCLE9BQU8sSUFBSXJvRixXQUFXLFVBQVU7Z0JBQzlCLDZCQUE2QjtnQkFDN0IsSUFBSTI3QixrQkFBa0IsUUFBUTtvQkFDNUJtMUIsU0FBUyxDQUFDdTNCO2dCQUNaLE9BQU8sSUFBSTFzRCxrQkFBa0IsU0FBUztvQkFDcENtMUIsU0FBU3UzQjtnQkFDWCxFQUFFLG9CQUFvQjtZQUN4QixPQUFPLElBQUlyb0YsV0FBVyxTQUFTO2dCQUM3Qiw0QkFBNEI7Z0JBQzVCLElBQUkyN0Isa0JBQWtCLFVBQVU7b0JBQzlCbTFCLFNBQVN1M0I7Z0JBQ1gsT0FBTyxJQUFJMXNELGtCQUFrQixTQUFTO29CQUNwQ20xQixTQUFTaTJCO2dCQUNYLEVBQUUsb0JBQW9CO1lBQ3hCO1lBQ0EsT0FBUTltRjtnQkFDTixLQUFLO29CQUNIOHdELFNBQVMsQ0FBQzMwRixNQUFNcm5DLE1BQU0sR0FBRyxLQUFLMitIO29CQUM5QjtnQkFDRixLQUFLO2dCQUNMLEtBQUs7b0JBQ0gzQyxTQUFTLENBQUMzMEYsTUFBTXJuQyxNQUFNLEdBQUcsS0FBSzIrSDtvQkFDOUI7WUFDSjtZQUNBLElBQUssSUFBSXI4SCxJQUFJLEdBQUdBLElBQUkra0MsTUFBTXJuQyxNQUFNLEVBQUVzQyxJQUFLO2dCQUNyQyxJQUFJa3BKLFlBQVksR0FBRztvQkFDakJwMUUsUUFBUW05RSxVQUFVLENBQUNsc0gsS0FBSyxDQUFDL2tDLEVBQUUsRUFBRXk1SCxPQUFPQztnQkFDdEM7Z0JBQ0E1bEQsUUFBUW85RSxRQUFRLENBQUNuc0gsS0FBSyxDQUFDL2tDLEVBQUUsRUFBRXk1SCxPQUFPQztnQkFDbENBLFNBQVMyQztZQUNYO1FBQ0YsT0FBTztZQUNMLElBQUk2c0IsWUFBWSxHQUFHO2dCQUNqQnAxRSxRQUFRbTlFLFVBQVUsQ0FBQy94RixNQUFNdTZELE9BQU9DO1lBQ2xDO1lBQ0E1bEQsUUFBUW85RSxRQUFRLENBQUNoeUYsTUFBTXU2RCxPQUFPQztRQUNoQztRQUNBLElBQUl2dkQsVUFBVSxHQUFHO1lBQ2YySixRQUFReEosTUFBTSxDQUFDLENBQUNIO1lBQ2hCMkosUUFBUStyRSxTQUFTLENBQUMsQ0FBQzJQLFVBQVUsQ0FBQ0M7UUFDaEM7SUFDRjtBQUNGO0FBRUEsaUJBQWlCLEdBRWpCLElBQUkwQixRQUFRLENBQUM7QUFDYkEsTUFBTS9LLFFBQVEsR0FBRyxTQUFVdHlFLE9BQU8sRUFBRWx0RCxJQUFJLEVBQUVvL0gsbUJBQW1CO0lBQzNELElBQUlzQyxZQUFZdGtKLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNwRixJQUFJdWtKLG9CQUFvQnZrSixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDNUYsSUFBSXdrSixvQkFBb0J4a0osVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQzVGLElBQUl4RyxJQUFJLElBQUk7SUFDWixJQUFJbThILFdBQVdDO0lBQ2YsSUFBSXA0RyxLQUFLb0YsS0FBSy9qQixRQUFRO0lBQ3RCLElBQUlnZ0gsS0FBS3JoRyxHQUFHdUIsUUFBUTtJQUNwQixJQUFJdEcsTUFBTW1LLEtBQUtuRixRQUFRO0lBQ3ZCLElBQUksQ0FBQ3JmLFNBQVNxYSxJQUFJekssQ0FBQyxLQUFLLENBQUM1UCxTQUFTcWEsSUFBSWhCLENBQUMsR0FBRztRQUN4QyxRQUFRLDBDQUEwQztJQUNwRDtJQUNBLElBQUkrc0kscUJBQXFCLENBQUM1aEksS0FBS294QyxPQUFPLElBQUk7UUFDeEM7SUFDRjtJQUNBLElBQUlvNUYsYUFBYTVJLG9CQUFvQjVoSSxLQUFLdzNELGdCQUFnQixLQUFLO0lBQy9ELElBQUk4ckUsV0FBVzFzSixFQUFFMHNKLFFBQVE7SUFDekIsSUFBSXBqSTtJQUNKLElBQUlzakksZUFBZTtJQUNuQixJQUFJMXhILFVBQVU5UixLQUFLOFIsT0FBTztJQUMxQmloRyxZQUFZL3lHLEtBQUtnVSxLQUFLLEtBQUssSUFBSWxDO0lBQy9Ca2hHLGFBQWFoekcsS0FBS2lVLE1BQU0sS0FBSyxJQUFJbkM7SUFFakMsRUFBRTtJQUNGLGNBQWM7SUFFZCxJQUFJUjtJQUNKLElBQUk4dEgscUJBQXFCO1FBQ3ZCOXRILEtBQUs4dEg7UUFDTGx5RSxRQUFRK3JFLFNBQVMsQ0FBQyxDQUFDM25ILEdBQUc1MEIsRUFBRSxFQUFFLENBQUM0MEIsR0FBRzEwQixFQUFFO0lBQ2xDO0lBRUEsRUFBRTtJQUNGLGdCQUFnQjtJQUVoQixJQUFJNnRKLFlBQVl6cUksS0FBS2cvQyxNQUFNLENBQUM7SUFDNUIsSUFBSWkvQixPQUFPd3NELFVBQVUveEosS0FBSztJQUMxQixJQUFJZ3lKLGFBQWEsSUFBSXp6SixNQUFNZ25HLEtBQUtubkcsTUFBTTtJQUN0QyxJQUFJdWtJLFFBQVEsSUFBSXBrSSxNQUFNZ25HLEtBQUtubkcsTUFBTTtJQUNqQyxJQUFJNnpKLFlBQVk7SUFDaEIsSUFBSyxJQUFJdHhKLElBQUksR0FBR0EsSUFBSTRrRyxLQUFLbm5HLE1BQU0sRUFBRXVDLElBQUs7UUFDcEMsSUFBSXlrRyxNQUFNRyxJQUFJLENBQUM1a0csRUFBRTtRQUNqQixJQUFJdXhKLE9BQU9GLFVBQVUsQ0FBQ3J4SixFQUFFLEdBQUd5a0csT0FBTyxRQUFRQSxRQUFRO1FBQ2xELElBQUk4c0QsTUFBTTtZQUNSLElBQUlDLG1CQUFtQjdxSSxLQUFLM0YsRUFBRSxHQUFHYyxLQUFLLEdBQUd3OEUsZUFBZSxDQUFDMzNFLE1BQU0sZ0NBQWdDLFNBQVMzbUI7WUFDeEdzeEo7WUFFQSxvRUFBb0U7WUFDcEV0dkIsS0FBSyxDQUFDaGlJLEVBQUUsR0FBR3pDLEVBQUVxa0ksY0FBYyxDQUFDbjlCLEtBQUsrc0Qsa0JBQWtCO2dCQUNqRGp3SSxHQUFHa3dJLG1CQUFtQixHQUFHcCtJLEtBQUtELEdBQUc7Z0JBQ2pDdVQsS0FBSzIrQyxhQUFhLENBQUM7WUFDckI7UUFDRjtJQUNGO0lBRUEsRUFBRTtJQUNGLGVBQWU7SUFFZixJQUFJb3NGLFdBQVcvcUksS0FBS2cvQyxNQUFNLENBQUMsc0JBQXNCdG1FLEtBQUs7SUFDdEQsSUFBSStwRSxjQUFjemlELEtBQUtnL0MsTUFBTSxDQUFDLGdCQUFnQkMsT0FBTztJQUNyRCxJQUFJK3JGLFlBQVlockksS0FBS2cvQyxNQUFNLENBQUMsc0JBQXNCdG1FLEtBQUssR0FBRzh4SjtJQUMxRCxJQUFJUyxjQUFjanJJLEtBQUtnL0MsTUFBTSxDQUFDLGdCQUFnQnRtRSxLQUFLO0lBQ25ELElBQUk2akcsY0FBY3Y4RSxLQUFLZy9DLE1BQU0sQ0FBQyxnQkFBZ0J0bUUsS0FBSztJQUNuRCxJQUFJd3lKLGFBQWFsckksS0FBS2cvQyxNQUFNLENBQUMsZUFBZXRtRSxLQUFLO0lBQ2pELElBQUl5eUosWUFBWW5ySSxLQUFLZy9DLE1BQU0sQ0FBQyxjQUFjdG1FLEtBQUs7SUFDL0MsSUFBSTBzRSxpQkFBaUJwbEQsS0FBS2cvQyxNQUFNLENBQUMsbUJBQW1CdG1FLEtBQUs7SUFDekQsSUFBSTB5SixnQkFBZ0JwckksS0FBS2cvQyxNQUFNLENBQUMsdUJBQXVCQyxPQUFPO0lBQzlELElBQUlvc0YsZUFBZXJySSxLQUFLZy9DLE1BQU0sQ0FBQyxzQkFBc0JDLE9BQU87SUFDNUQsSUFBSWtHLGdCQUFnQm5sRCxLQUFLZy9DLE1BQU0sQ0FBQyxrQkFBa0J0bUUsS0FBSyxHQUFHOHhKO0lBQzFELElBQUlob0YsZUFBZXhpRCxLQUFLZy9DLE1BQU0sQ0FBQyxpQkFBaUJDLE9BQU87SUFDdkQsSUFBSXNwRixlQUFldm9JLEtBQUtnL0MsTUFBTSxDQUFDLGlCQUFpQnRtRSxLQUFLO0lBQ3JELElBQUk0eUosZUFBZXRySSxLQUFLZy9DLE1BQU0sQ0FBQyxpQkFBaUJ0bUUsS0FBSztJQUNyRCxJQUFJd3JFLGlCQUFpQmxrRCxLQUFLZy9DLE1BQU0sQ0FBQyxtQkFBbUJ0bUUsS0FBSyxHQUFHOHhKO0lBQzVELElBQUlybUYsZ0JBQWdCbmtELEtBQUtnL0MsTUFBTSxDQUFDLGtCQUFrQnRtRSxLQUFLO0lBQ3ZELElBQUlnOEIsZUFBZTFVLEtBQUtnL0MsTUFBTSxDQUFDLGlCQUFpQnRtRSxLQUFLO0lBQ3JELElBQUlnOEIsaUJBQWlCLFFBQVFBLGVBQWUxVSxLQUFLZy9DLE1BQU0sQ0FBQyxpQkFBaUJDLE9BQU87SUFDaEYsSUFBSXNzRixrQkFBa0IsU0FBU0E7UUFDN0IsSUFBSUMsUUFBUXB1SixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc0dEo7UUFDaEZwMEosRUFBRTYwSixZQUFZLENBQUN2K0UsU0FBU2x0RCxNQUFNd3JJO0lBQ2hDO0lBQ0EsSUFBSUUsbUJBQW1CLFNBQVNBO1FBQzlCLElBQUlDLFNBQVN2dUosVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHK25FO1FBQ2pGdnVFLEVBQUU2ckosZ0JBQWdCLENBQUN2MUUsU0FBUys5RSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFVTtJQUM5RTtJQUNBLElBQUlDLG9CQUFvQixTQUFTQTtRQUMvQixJQUFJQyxVQUFVenVKLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRzhtRTtRQUNsRnR0RSxFQUFFNnJKLGdCQUFnQixDQUFDdjFFLFNBQVNxN0UsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUUsRUFBRUEsWUFBWSxDQUFDLEVBQUUsRUFBRXNEO0lBQ2pGO0lBRUEsRUFBRTtJQUNGLGNBQWM7SUFFZCxJQUFJQyxVQUFVLFNBQVNBLFFBQVE5M0gsS0FBSyxFQUFFQyxNQUFNLEVBQUV5d0MsS0FBSyxFQUFFNXJDLE1BQU07UUFDekQsSUFBSStxSCxZQUFZanRKLEVBQUVtMUosYUFBYSxHQUFHbjFKLEVBQUVtMUosYUFBYSxJQUFJLEVBQUU7UUFDdkQsSUFBSS96SixNQUFNeWMsWUFBWWl3RCxVQUFVLFlBQVlBLFFBQVEsTUFBTTVyQyxPQUFPeDdCLElBQUksQ0FBQyxPQUFPb25FLE9BQU8sS0FBS3p3QyxRQUFRLEtBQUtELE9BQU8sS0FBS1U7UUFDbEgsSUFBSXN3SCxhQUFhbkIsU0FBUyxDQUFDN3JKLElBQUk7UUFDL0IsSUFBSWtvQjtRQUNKLElBQUkrNUMsV0FBVztRQUNmLElBQUkrcUYsY0FBYyxNQUFNO1lBQ3RCOWtJLE9BQU84a0k7WUFDUC9xRixXQUFXO1lBQ1hnaUQsR0FBRzRuQyxTQUFTLEdBQUczakk7UUFDakIsT0FBTztZQUNMQSxPQUFPLElBQUk0akk7WUFDWEQsU0FBUyxDQUFDN3JKLElBQUksR0FBR2lrSCxHQUFHNG5DLFNBQVMsR0FBRzNqSTtRQUNsQztRQUNBLE9BQU87WUFDTEEsTUFBTUE7WUFDTis1QyxVQUFVQTtRQUNaO0lBQ0Y7SUFDQSxJQUFJa3ZGLGFBQWFucEksS0FBS2cvQyxNQUFNLENBQUMsU0FBUzhDLFFBQVE7SUFDOUMsSUFBSWtxRixXQUFXaHNJLEtBQUtnL0MsTUFBTSxDQUFDLHdCQUF3QkMsT0FBTztJQUMxRCxJQUFJcWtGLFVBQVU7UUFDWnAyRSxRQUFRK3JFLFNBQVMsQ0FBQ3BqSSxJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUM7UUFDOUIsSUFBSW8zSSxZQUFZSCxRQUFRLzRCLFdBQVdDLFlBQVltMkIsWUFBWTZDO1FBQzNEOXJJLE9BQU8rckksVUFBVS9ySSxJQUFJO1FBQ3JCc2pJLGVBQWV5SSxVQUFVaHlGLFFBQVE7SUFDbkM7SUFDQSxJQUFJaXlGLFlBQVksU0FBU0E7UUFDdkIsSUFBSSxDQUFDMUksY0FBYztZQUNqQixJQUFJdjBCLE9BQU9wNUc7WUFDWCxJQUFJeXRJLFVBQVU7Z0JBQ1pyMEIsT0FBTztvQkFDTDdqSCxHQUFHO29CQUNIeUosR0FBRztnQkFDTDtZQUNGO1lBQ0FqZSxFQUFFaXVFLFVBQVUsQ0FBQ2p1RSxFQUFFc2xILFlBQVksQ0FBQ2w4RixNQUFNLENBQUM2NEYsSUFBSSxDQUFDMzRGLFFBQVFndEQsU0FBUytoRCxLQUFLN2pILENBQUMsRUFBRTZqSCxLQUFLcDZHLENBQUMsRUFBRWsrRyxXQUFXQyxZQUFZdCtGLGNBQWN1bkY7UUFDaEg7UUFDQSxJQUFJcW5DLFVBQVU7WUFDWnAyRSxRQUFRK3VCLElBQUksQ0FBQy83RTtRQUNmLE9BQU87WUFDTGd0RCxRQUFRK3VCLElBQUk7UUFDZDtJQUNGO0lBQ0EsSUFBSWt3RCxhQUFhLFNBQVNBO1FBQ3hCLElBQUkxRyxjQUFjcm9KLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBR290SjtRQUN0RixJQUFJanJFLFNBQVNuaUYsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ2pGLElBQUlndkosWUFBWXh4SSxHQUFHOEIsYUFBYTtRQUNoQyxJQUFJMnZJLGlCQUFpQjtRQUNyQixJQUFLLElBQUl0c0ksS0FBSyxHQUFHQSxLQUFLczdHLE1BQU12a0ksTUFBTSxFQUFFaXBCLEtBQU07WUFDeEMsSUFBSWc4RSxnQkFBZ0IvN0UsS0FBSzNGLEVBQUUsR0FBR2MsS0FBSyxHQUFHdzhFLGVBQWUsQ0FBQzMzRSxNQUFNLGdDQUFnQyxTQUFTRDtZQUNyRyxJQUFJdy9ELFVBQVV3YyxrQkFBa0IsVUFBVSxDQUFDeGMsVUFBVXdjLGtCQUFrQixVQUFVO2dCQUMvRXN3RDtnQkFDQTtZQUNGO1lBQ0EsSUFBSTNCLFVBQVUsQ0FBQzNxSSxHQUFHLElBQUlzN0csS0FBSyxDQUFDdDdHLEdBQUcsQ0FBQ2c0QixRQUFRLElBQUksQ0FBQ3NqRixLQUFLLENBQUN0N0csR0FBRyxDQUFDL0ksS0FBSyxFQUFFO2dCQUM1RHExSTtnQkFDQXoxSixFQUFFNHVKLGtCQUFrQixDQUFDdDRFLFNBQVNtdUQsS0FBSyxDQUFDdDdHLEdBQUcsRUFBRUMsTUFBTUQsSUFBSTBsSTtZQUNyRDtRQUNGO1FBQ0E3cUksR0FBRzhCLGFBQWEsR0FBRyxDQUFFMnZJLENBQUFBLG1CQUFtQjFCLFNBQVE7UUFDaEQsSUFBSXlCLGNBQWN4eEksR0FBRzhCLGFBQWEsRUFBRTtZQUNsQyxnREFBZ0Q7WUFDaERzRCxLQUFLZ3JDLFdBQVcsQ0FBQztRQUNuQjtJQUNGO0lBQ0EsSUFBSXNoRyxVQUFVLFNBQVNBO1FBQ3JCLElBQUlDLGNBQWNudkosVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3RGLElBQUlvdkosYUFBYXB2SixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUdvdEo7UUFDckYsSUFBSTV6SixFQUFFZzhGLE1BQU0sQ0FBQzV5RSxPQUFPO1lBQ2xCcHBCLEVBQUUwMUosT0FBTyxDQUFDcC9FLFNBQVNsdEQsTUFBTXdzSTtZQUV6QixpREFBaUQ7WUFDakQsSUFBSUQsYUFBYTtnQkFDZixJQUFJLENBQUNqSixVQUFVO29CQUNiMXNKLEVBQUVpdUUsVUFBVSxDQUFDanVFLEVBQUVzbEgsWUFBWSxDQUFDbDhGLE1BQU0sQ0FBQzY0RixJQUFJLENBQUMzckMsU0FBU3IzRCxJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUMsRUFBRWsrRyxXQUFXQyxZQUFZdCtGLGNBQWN1bkY7Z0JBQ3RHO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsSUFBSXd3QyxhQUFhLFNBQVNBO1FBQ3hCLElBQUlGLGNBQWNudkosVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3RGLElBQUlzdkosZ0JBQWdCdHZKLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBR290SjtRQUN4RixJQUFJNXpKLEVBQUVpOEYsU0FBUyxDQUFDN3lFLE9BQU87WUFDckJrdEQsUUFBUWs2RSxJQUFJO1lBQ1osSUFBSTlELFVBQVU7Z0JBQ1pwMkUsUUFBUTY0RSxJQUFJLENBQUM5cEMsR0FBRzRuQyxTQUFTO1lBQzNCLE9BQU87Z0JBQ0xqdEosRUFBRWl1RSxVQUFVLENBQUNqdUUsRUFBRXNsSCxZQUFZLENBQUNsOEYsTUFBTSxDQUFDNjRGLElBQUksQ0FBQzNyQyxTQUFTcjNELElBQUl6SyxDQUFDLEVBQUV5SyxJQUFJaEIsQ0FBQyxFQUFFaytHLFdBQVdDLFlBQVl0K0YsY0FBY3VuRjtnQkFDcEcvdUMsUUFBUTY0RSxJQUFJO1lBQ2Q7WUFDQW52SixFQUFFNjFKLFVBQVUsQ0FBQ3YvRSxTQUFTbHRELE1BQU0wc0k7WUFDNUJ4L0UsUUFBUTN5RCxPQUFPO1lBRWYscURBQXFEO1lBQ3JELElBQUlneUksYUFBYTtnQkFDZixJQUFJLENBQUNqSixVQUFVO29CQUNiMXNKLEVBQUVpdUUsVUFBVSxDQUFDanVFLEVBQUVzbEgsWUFBWSxDQUFDbDhGLE1BQU0sQ0FBQzY0RixJQUFJLENBQUMzckMsU0FBU3IzRCxJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUMsRUFBRWsrRyxXQUFXQyxZQUFZdCtGLGNBQWN1bkY7Z0JBQ3RHO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsSUFBSTB3QyxTQUFTLFNBQVNBO1FBQ3BCLElBQUlDLGdCQUFnQnh2SixVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUdvdEo7UUFDeEYsSUFBSWxtRixVQUFVLENBQUN5bUYsV0FBVyxJQUFJQSxXQUFXLENBQUNBLFFBQU8sSUFBSzZCO1FBQ3RELElBQUl4Z0ksSUFBSTIrSCxXQUFXLElBQUksSUFBSTtRQUMzQixJQUFJQSxhQUFhLEdBQUc7WUFDbEJuMEosRUFBRTh0SixjQUFjLENBQUN4M0UsU0FBUzlnRCxHQUFHQSxHQUFHQSxHQUFHazRDO1lBQ25DLElBQUlnL0UsVUFBVTtnQkFDWnAyRSxRQUFRK3VCLElBQUksQ0FBQy83RTtZQUNmLE9BQU87Z0JBQ0xndEQsUUFBUSt1QixJQUFJO1lBQ2Q7UUFDRjtJQUNGO0lBQ0EsSUFBSTR3RCxhQUFhLFNBQVNBO1FBQ3hCLElBQUlwcUYsY0FBYyxHQUFHO1lBQ25CeUssUUFBUW8xRSxTQUFTLEdBQUc3L0U7WUFDcEJ5SyxRQUFRa3ZCLE9BQU8sR0FBRyt1RDtZQUNsQmorRSxRQUFRb3ZCLFFBQVEsR0FBRzR1RDtZQUNuQixJQUFJaCtFLFFBQVE2MkUsV0FBVyxFQUFFO2dCQUN2Qiw4QkFBOEI7Z0JBQzlCLE9BQVF4bkQ7b0JBQ04sS0FBSzt3QkFDSHJ2QixRQUFRNjJFLFdBQVcsQ0FBQzs0QkFBQzs0QkFBRzt5QkFBRTt3QkFDMUI7b0JBQ0YsS0FBSzt3QkFDSDcyRSxRQUFRNjJFLFdBQVcsQ0FBQ3FIO3dCQUNwQmwrRSxRQUFRdzJFLGNBQWMsR0FBRzJIO3dCQUN6QjtvQkFDRixLQUFLO29CQUNMLEtBQUs7d0JBQ0huK0UsUUFBUTYyRSxXQUFXLENBQUMsRUFBRTt3QkFDdEI7Z0JBQ0o7WUFDRjtZQUNBLElBQUkzK0UsbUJBQW1CLFVBQVU7Z0JBQy9COEgsUUFBUWs2RSxJQUFJO2dCQUNabDZFLFFBQVFvMUUsU0FBUyxJQUFJO2dCQUNyQixJQUFJbDlFLG1CQUFtQixVQUFVO29CQUMvQmsrRSxXQUFXcDJFLFFBQVE2NEUsSUFBSSxDQUFDN2xJLFFBQVFndEQsUUFBUTY0RSxJQUFJO2dCQUM5QyxPQUFPO29CQUNMLElBQUkrRyxTQUFTLElBQUloSjtvQkFDakJnSixPQUFPdnlDLElBQUksQ0FBQyxDQUFDd1ksWUFBWSxJQUFJdHdELGFBQWEsQ0FBQ3V3RCxhQUFhLElBQUl2d0QsYUFBYXN3RCxZQUFZLElBQUl0d0QsYUFBYXV3RCxhQUFhLElBQUl2d0Q7b0JBQ3ZIcXFGLE9BQU9DLE9BQU8sQ0FBQzdzSTtvQkFDZmd0RCxRQUFRNjRFLElBQUksQ0FBQytHLFFBQVE7Z0JBQ3ZCO2dCQUNBeEosV0FBV3AyRSxRQUFRODJFLE1BQU0sQ0FBQzlqSSxRQUFRZ3RELFFBQVE4MkUsTUFBTTtnQkFDaEQ5MkUsUUFBUTN5RCxPQUFPO1lBQ2pCLE9BQU87Z0JBQ0wrb0ksV0FBV3AyRSxRQUFRODJFLE1BQU0sQ0FBQzlqSSxRQUFRZ3RELFFBQVE4MkUsTUFBTTtZQUNsRDtZQUNBLElBQUl6bkQsZ0JBQWdCLFVBQVU7Z0JBQzVCcnZCLFFBQVFvMUUsU0FBUyxHQUFHNy9FLGNBQWM7Z0JBQ2xDLElBQUkraEYsTUFBTXQzRSxRQUFRdTNFLHdCQUF3QjtnQkFDMUN2M0UsUUFBUXUzRSx3QkFBd0IsR0FBRztnQkFDbkMsSUFBSW5CLFVBQVU7b0JBQ1pwMkUsUUFBUTgyRSxNQUFNLENBQUM5akk7Z0JBQ2pCLE9BQU87b0JBQ0xndEQsUUFBUTgyRSxNQUFNO2dCQUNoQjtnQkFDQTkyRSxRQUFRdTNFLHdCQUF3QixHQUFHRDtZQUNyQztZQUVBLDRDQUE0QztZQUM1QyxJQUFJdDNFLFFBQVE2MkUsV0FBVyxFQUFFO2dCQUN2Qiw4QkFBOEI7Z0JBQzlCNzJFLFFBQVE2MkUsV0FBVyxDQUFDLEVBQUU7WUFDeEI7UUFDRjtJQUNGO0lBQ0EsSUFBSWlKLGNBQWMsU0FBU0E7UUFDekIsSUFBSXhxRixlQUFlLEdBQUc7WUFDcEIwSyxRQUFRbzFFLFNBQVMsR0FBRzkvRTtZQUNwQjBLLFFBQVFrdkIsT0FBTyxHQUFHO1lBQ2xCLElBQUlsdkIsUUFBUTYyRSxXQUFXLEVBQUU7Z0JBQ3ZCLDhCQUE4QjtnQkFDOUIsT0FBUXVIO29CQUNOLEtBQUs7d0JBQ0hwK0UsUUFBUTYyRSxXQUFXLENBQUM7NEJBQUM7NEJBQUc7eUJBQUU7d0JBQzFCO29CQUNGLEtBQUs7d0JBQ0g3MkUsUUFBUTYyRSxXQUFXLENBQUM7NEJBQUM7NEJBQUc7eUJBQUU7d0JBQzFCO29CQUNGLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSDcyRSxRQUFRNjJFLFdBQVcsQ0FBQyxFQUFFO3dCQUN0QjtnQkFDSjtZQUNGO1lBQ0EsSUFBSTkwQixPQUFPcDVHO1lBQ1gsSUFBSXl0SSxVQUFVO2dCQUNacjBCLE9BQU87b0JBQ0w3akgsR0FBRztvQkFDSHlKLEdBQUc7Z0JBQ0w7WUFDRjtZQUNBLElBQUk2dkQsUUFBUTl0RSxFQUFFc2xILFlBQVksQ0FBQ2w4RjtZQUMzQixJQUFJaXRJLFNBQVN4cUY7WUFDYixJQUFJMkMsbUJBQW1CLFVBQVU2bkYsU0FBUztZQUMxQyxJQUFJN25GLG1CQUFtQixXQUFXNm5GLFVBQVU7WUFDNUMsSUFBSUMsU0FBUyxDQUFDbjZCLFlBQVlrNkIsU0FBVXpxRixDQUFBQSxlQUFlMkIsYUFBWSxDQUFDLElBQUs0dUQ7WUFDckUsSUFBSW82QixTQUFTLENBQUNuNkIsYUFBYWk2QixTQUFVenFGLENBQUFBLGVBQWUyQixhQUFZLENBQUMsSUFBSzZ1RDtZQUN0RSxJQUFJbzZCLFNBQVNyNkIsWUFBWW02QjtZQUN6QixJQUFJRyxVQUFVcjZCLGFBQWFtNkI7WUFDM0IsSUFBSXIwSCxTQUFTbGlDLEVBQUVpdUUsVUFBVSxDQUFDSCxNQUFNLENBQUM1ckMsTUFBTTtZQUN2QyxJQUFJdzBIO1lBQ0osSUFBSWhLLFVBQVU7Z0JBQ1osSUFBSWlLLGNBQWN6QixRQUFRc0IsUUFBUUMsU0FBUzNvRixPQUFPNXJDO2dCQUNsRHcwSCxRQUFRQyxZQUFZcnRJLElBQUk7WUFDMUI7WUFFQSx3RUFBd0U7WUFDeEUscUNBQXFDO1lBQ3JDLElBQUl3a0QsVUFBVSxXQUFXO2dCQUN2Qjl0RSxFQUFFNDJKLGVBQWUsQ0FBQ0YsU0FBU3BnRixTQUFTK2hELEtBQUs3akgsQ0FBQyxFQUFFNmpILEtBQUtwNkcsQ0FBQyxFQUFFdTRJLFFBQVFDO1lBQzlELE9BQU8sSUFBSTtnQkFBQztnQkFBaUI7Z0JBQWtCO2dCQUFpQjtnQkFBaUI7Z0JBQWtCO2dCQUFpQjtnQkFBa0I7YUFBWSxDQUFDaEssUUFBUSxDQUFDMytFLFFBQVE7Z0JBQ2xLLElBQUkrb0YsUUFBUTtnQkFDWixJQUFJdHlILFVBQVU7Z0JBQ2QsSUFBSUMsVUFBVTtnQkFDZCxJQUFJc3BDLFVBQVUsaUJBQWlCO29CQUM3QitvRixRQUFRLENBQUNSLFNBQVM5b0YsZ0JBQWdCM0IsWUFBVyxJQUFLO2dCQUNwRCxPQUFPLElBQUlrQyxVQUFVLGtCQUFrQjtvQkFDckMrb0YsUUFBUSxDQUFDUixTQUFTOW9GLGdCQUFnQjNCLFlBQVcsSUFBSztvQkFDbERwbkMsVUFBVSxDQUFFNnhILENBQUFBLFNBQVMsSUFBSTlvRixnQkFBZ0IzQixZQUFXLElBQUs7Z0JBQzNELE9BQU8sSUFBSWtDLFVBQVUsaUJBQWlCO29CQUNwQytvRixRQUFRLENBQUNSLFNBQVM5b0YsZ0JBQWdCM0IsWUFBVyxJQUFLO2dCQUNwRCxPQUFPLElBQUlrQyxVQUFVLGtCQUFrQjtvQkFDckMrb0YsUUFBUSxDQUFDUixTQUFTOW9GLGdCQUFnQjNCLFlBQVcsSUFBSztvQkFDbERwbkMsVUFBVSxDQUFFNnhILENBQUFBLFNBQVMsSUFBSTlvRixnQkFBZ0IzQixZQUFXLElBQUs7Z0JBQzNELE9BQU8sSUFBSWtDLFVBQVUsYUFBYTtvQkFDaEMrb0YsUUFBUSxDQUFDUixTQUFTOW9GLGdCQUFnQjNCLFlBQVcsSUFBSztvQkFDbERybkMsVUFBVSxDQUFDOHhILFNBQVMsSUFBSXpxRixlQUFlMkIsYUFBWSxJQUFLO2dCQUMxRCxPQUFPLElBQUlPLFVBQVUsa0JBQWtCO29CQUNyQytvRixRQUFRLENBQUNSLFNBQVM5b0YsZ0JBQWdCM0IsWUFBVyxJQUFNNW1FLENBQUFBLEtBQUtzWixFQUFFLEdBQUc7b0JBQzdEa21CLFVBQVUsQ0FBRTZ4SCxDQUFBQSxTQUFTOW9GLGdCQUFnQixJQUFJM0IsWUFBVyxJQUFLNW1FLEtBQUtzWixFQUFFO2dCQUNsRTtnQkFDQSxJQUFJdTRJLFVBQVUsR0FBRztvQkFDZlAsU0FBUyxDQUFDbjZCLFlBQVkwNkIsS0FBSSxJQUFLMTZCO29CQUMvQnE2QixTQUFTcjZCLFlBQVltNkI7b0JBQ3JCLElBQUksQ0FBQzt3QkFBQzt3QkFBaUI7cUJBQVksQ0FBQzdKLFFBQVEsQ0FBQzMrRSxRQUFRO3dCQUNuRHlvRixTQUFTLENBQUNuNkIsYUFBYXk2QixLQUFJLElBQUt6NkI7d0JBQ2hDcTZCLFVBQVVyNkIsYUFBYW02QjtvQkFDekI7Z0JBQ0Y7Z0JBQ0F6NEgsZUFBZUEsaUJBQWlCLFNBQVMrSyxzQkFBc0IydEgsUUFBUUMsV0FBVzM0SDtnQkFDbEYsSUFBSStJLFFBQVEydkgsU0FBUztnQkFDckIsSUFBSTF2SCxRQUFRMnZILFVBQVU7Z0JBQ3RCLElBQUk1NEgsU0FBU0MsZUFBZSxDQUFDdTRILFNBQVN6cUYsZUFBZTJCLGFBQVksSUFBSztnQkFDdEUsSUFBSTlqRSxJQUFJLElBQUlwSixNQUFNNmhDLE9BQU9oaUMsTUFBTSxHQUFHO2dCQUNsQyxJQUFJNGlDLFVBQVUsSUFBSXppQyxNQUFNNmhDLE9BQU9oaUMsTUFBTSxHQUFHO2dCQUN4QyxJQUFLLElBQUk2b0IsTUFBTSxHQUFHQSxNQUFNbVosT0FBT2hpQyxNQUFNLEdBQUcsR0FBRzZvQixNQUFPO29CQUNoRHRmLENBQUMsQ0FBQ3NmLElBQUksR0FBRzt3QkFDUHZVLEdBQUc2akgsS0FBSzdqSCxDQUFDLEdBQUcrdkIsVUFBVXNDLFFBQVEzRSxNQUFNLENBQUNuWixNQUFNLEVBQUU7d0JBQzdDOUssR0FBR282RyxLQUFLcDZHLENBQUMsR0FBR3VtQixVQUFVc0MsUUFBUTVFLE1BQU0sQ0FBQ25aLE1BQU0sSUFBSSxFQUFFO29CQUNuRDtnQkFDRjtnQkFDQSxJQUFJdU8sS0FDRnFDLElBQ0FDLElBQ0E0QyxJQUNBdEQsTUFBTXp2QixFQUFFdkosTUFBTTtnQkFDaEJ5NUIsS0FBS2x3QixDQUFDLENBQUN5dkIsTUFBTSxFQUFFO2dCQUNmLGlCQUFpQjtnQkFDakIsSUFBSzVCLE1BQU0sR0FBR0EsTUFBTTRCLEtBQUs1QixNQUFPO29CQUM5QnNDLEtBQUtud0IsQ0FBQyxDQUFDNnRCLE1BQU00QixJQUFJO29CQUNqQnNELEtBQUsveUIsQ0FBQyxDQUFDLENBQUM2dEIsTUFBTSxLQUFLNEIsSUFBSTtvQkFDdkI0SixPQUFPLENBQUN4TCxJQUFJLEdBQUdpMUYsZUFBZTV5RixJQUFJQyxJQUFJNEMsSUFBSXFCO29CQUMxQ2xFLEtBQUtDO29CQUNMQSxLQUFLNEM7Z0JBQ1A7Z0JBQ0F4OEIsRUFBRTgySixvQkFBb0IsQ0FBQ0osU0FBU3BnRixTQUFTK2hELEtBQUs3akgsQ0FBQyxHQUFHK3ZCLFNBQVM4ekYsS0FBS3A2RyxDQUFDLEdBQUd1bUIsU0FBUzIzRixZQUFZbTZCLFFBQVFsNkIsYUFBYW02QixRQUFRcjBILFFBQVFZO1lBQ2hJLE9BQU8sSUFBSTtnQkFBQztnQkFBa0I7YUFBa0IsQ0FBQzJwSCxRQUFRLENBQUMzK0UsUUFBUTtnQkFDaEVod0MsZUFBZUEsaUJBQWlCLFNBQVNDLHdCQUF3Qnk0SCxRQUFRQyxXQUFXMzRIO2dCQUNwRjk5QixFQUFFKzJKLHNCQUFzQixDQUFDTCxTQUFTcGdGLFNBQVMraEQsS0FBSzdqSCxDQUFDLEVBQUU2akgsS0FBS3A2RyxDQUFDLEVBQUV1NEksUUFBUUMsU0FBUzM0SCxlQUFlLENBQUN1NEgsU0FBU3pxRixlQUFlMkIsYUFBWSxJQUFLO1lBQ3ZJLE9BQU8sSUFBSTtnQkFBQztnQkFBZ0I7YUFBZ0IsQ0FBQ2svRSxRQUFRLENBQUMzK0UsUUFBUTtnQkFDNURod0MsZUFBZUEsaUJBQWlCLFNBQVNnTCxnQ0FBZ0NoTDtnQkFDekU5OUIsRUFBRWczSixvQkFBb0IsQ0FBQ04sU0FBU3BnRixTQUFTK2hELEtBQUs3akgsQ0FBQyxFQUFFNmpILEtBQUtwNkcsQ0FBQyxFQUFFdTRJLFFBQVFDLFNBQVMsTUFBTTM0SCxlQUFlLENBQUN1NEgsU0FBU3pxRixlQUFlMkIsYUFBWSxJQUFLO1lBQzNJLE9BQU8sSUFBSTtnQkFBQztnQkFBd0I7YUFBeUIsQ0FBQ2svRSxRQUFRLENBQUMzK0UsUUFBUTtnQkFDN0Vod0MsZUFBZUEsaUJBQWlCLFNBQVNDLHdCQUF3Qnk0SCxRQUFRQyxXQUFXMzRIO2dCQUNwRjk5QixFQUFFaTNKLDRCQUE0QixDQUFDUCxTQUFTcGdGLFNBQVMraEQsS0FBSzdqSCxDQUFDLEVBQUU2akgsS0FBS3A2RyxDQUFDLEVBQUV1NEksUUFBUUMsU0FBUzM0SCxlQUFlLENBQUN1NEgsU0FBU3pxRixlQUFlMkIsYUFBWSxJQUFLO1lBQzdJLE9BQU8sSUFBSU8sVUFBVSxVQUFVO2dCQUM3Qjl0RSxFQUFFazNKLGNBQWMsQ0FBQ1IsU0FBU3BnRixTQUFTK2hELEtBQUs3akgsQ0FBQyxFQUFFNmpILEtBQUtwNkcsQ0FBQyxFQUFFdTRJLFFBQVFDO1lBQzdELE9BQU8sSUFBSTNvRixNQUFNb3FELFVBQVUsQ0FBQyxjQUFjO2dCQUFDO2dCQUFZO2dCQUFrQjtnQkFBYTtnQkFBTzthQUFNLENBQUN1MEIsUUFBUSxDQUFDMytFLFFBQVE7Z0JBQ25ILElBQUk1cEMsTUFBTSxDQUFDbXlILFNBQVN6cUYsZUFBZTJCLGFBQVksSUFBSzR1RDtnQkFDcERqNkYsU0FBU1UsVUFBVUQsY0FBY1QsUUFBUWdDO2dCQUN6Q2xrQyxFQUFFbTNKLGVBQWUsQ0FBQ1QsU0FBU3BnRixTQUFTK2hELEtBQUs3akgsQ0FBQyxFQUFFNmpILEtBQUtwNkcsQ0FBQyxFQUFFaytHLFdBQVdDLFlBQVlsNkY7WUFDN0UsT0FBTztnQkFDTCxJQUFJazFILE9BQU8sQ0FBQ2YsU0FBU3pxRixlQUFlMkIsYUFBWSxJQUFLNHVEO2dCQUNyRGo2RixTQUFTVSxVQUFVRCxjQUFjVCxRQUFRLENBQUNrMUg7Z0JBQzFDcDNKLEVBQUVtM0osZUFBZSxDQUFDVCxTQUFTcGdGLFNBQVMraEQsS0FBSzdqSCxDQUFDLEVBQUU2akgsS0FBS3A2RyxDQUFDLEVBQUVrK0csV0FBV0MsWUFBWWw2RjtZQUM3RTtZQUNBLElBQUl3cUgsVUFBVTtnQkFDWnAyRSxRQUFRODJFLE1BQU0sQ0FBQ3NKO1lBQ2pCLE9BQU87Z0JBQ0xwZ0YsUUFBUTgyRSxNQUFNO1lBQ2hCO1lBQ0EsSUFBSXNILGlCQUFpQixVQUFVO2dCQUM3QnArRSxRQUFRbzFFLFNBQVMsR0FBRzJLLFNBQVM7Z0JBQzdCLElBQUl6SSxNQUFNdDNFLFFBQVF1M0Usd0JBQXdCO2dCQUMxQ3YzRSxRQUFRdTNFLHdCQUF3QixHQUFHO2dCQUNuQyxJQUFJbkIsVUFBVTtvQkFDWnAyRSxRQUFRODJFLE1BQU0sQ0FBQ3NKO2dCQUNqQixPQUFPO29CQUNMcGdGLFFBQVE4MkUsTUFBTTtnQkFDaEI7Z0JBQ0E5MkUsUUFBUXUzRSx3QkFBd0IsR0FBR0Q7WUFDckM7WUFFQSw0Q0FBNEM7WUFDNUMsSUFBSXQzRSxRQUFRNjJFLFdBQVcsRUFBRTtnQkFDdkIsOEJBQThCO2dCQUM5QjcyRSxRQUFRNjJFLFdBQVcsQ0FBQyxFQUFFO1lBQ3hCO1FBQ0Y7SUFDRjtJQUNBLElBQUlyQixjQUFjLFNBQVNBO1FBQ3pCLElBQUlmLG1CQUFtQjtZQUNyQi9xSixFQUFFK29KLGVBQWUsQ0FBQ3p5RSxTQUFTbHRELE1BQU1uSyxLQUFLazlHLFdBQVdDO1FBQ25EO0lBQ0Y7SUFDQSxJQUFJMnZCLGVBQWUsU0FBU0E7UUFDMUIsSUFBSWhCLG1CQUFtQjtZQUNyQi9xSixFQUFFa3BKLGdCQUFnQixDQUFDNXlFLFNBQVNsdEQsTUFBTW5LLEtBQUtrOUcsV0FBV0M7UUFDcEQ7SUFDRjtJQUNBLElBQUkrdkIsV0FBVyxTQUFTQTtRQUN0Qm5zSixFQUFFb3NKLGVBQWUsQ0FBQzkxRSxTQUFTbHRELE1BQU0sTUFBTTBoSTtJQUN6QztJQUNBLElBQUl4NkUsUUFBUWxuRCxLQUFLZy9DLE1BQU0sQ0FBQyxTQUFTdG1FLEtBQUssS0FBSztJQUMzQyxJQUFJd3VFLE9BQU87UUFDVCxJQUFJQyxLQUFLbm5ELEtBQUtnL0MsTUFBTSxDQUFDLGtCQUFrQkMsT0FBTztRQUM5QyxJQUFJbUksS0FBS3BuRCxLQUFLZy9DLE1BQU0sQ0FBQyxrQkFBa0JDLE9BQU87UUFDOUMsSUFBSWdrRixlQUFlampJLEtBQUtnL0MsTUFBTSxDQUFDLGlCQUFpQnRtRSxLQUFLO1FBQ3JELElBQUl1MUosa0JBQWtCaEwsZUFBZXVIO1FBQ3JDdDlFLFFBQVErckUsU0FBUyxDQUFDOXhFLElBQUlDO1FBQ3RCd2tGO1FBQ0FvQjtRQUNBekIsZ0JBQWdCdEksZUFBZStIO1FBQy9Ca0I7UUFDQUMsV0FBVzhCLGlCQUFpQjtRQUM1QnZDLGlCQUFpQnpJLGVBQWU5OUU7UUFDaEMwbkY7UUFDQVAsUUFBUXZCLGFBQWEsS0FBS3RvRixnQkFBZ0I7UUFDMUNncUYsV0FBVzFCLGFBQWEsS0FBS3RvRixnQkFBZ0I7UUFDN0MwcEYsV0FBVzhCLGlCQUFpQjtRQUM1QnRCLE9BQU9zQjtRQUNQL2dGLFFBQVErckUsU0FBUyxDQUFDLENBQUM5eEUsSUFBSSxDQUFDQztJQUMxQjtJQUNBLElBQUlrOEUsVUFBVTtRQUNacDJFLFFBQVErckUsU0FBUyxDQUFDLENBQUNwakksSUFBSXpLLENBQUMsRUFBRSxDQUFDeUssSUFBSWhCLENBQUM7SUFDbEM7SUFDQTh0STtJQUNBLElBQUlXLFVBQVU7UUFDWnAyRSxRQUFRK3JFLFNBQVMsQ0FBQ3BqSSxJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUM7SUFDaEM7SUFDQSsySTtJQUNBb0I7SUFDQXpCO0lBQ0FXO0lBQ0FDLFdBQVczQixZQUFZO0lBQ3ZCa0I7SUFDQW1CO0lBQ0FQLFFBQVF2QixhQUFhLEtBQUt0b0YsZ0JBQWdCO0lBQzFDZ3FGLFdBQVcxQixhQUFhLEtBQUt0b0YsZ0JBQWdCO0lBQzdDMHBGLFdBQVczQixZQUFZO0lBQ3ZCbUM7SUFDQSxJQUFJckosVUFBVTtRQUNacDJFLFFBQVErckUsU0FBUyxDQUFDLENBQUNwakksSUFBSXpLLENBQUMsRUFBRSxDQUFDeUssSUFBSWhCLENBQUM7SUFDbEM7SUFDQWt1STtJQUNBTDtJQUVBLEVBQUU7SUFDRixpQkFBaUI7SUFFakIsSUFBSXRELHFCQUFxQjtRQUN2Qmx5RSxRQUFRK3JFLFNBQVMsQ0FBQzNuSCxHQUFHNTBCLEVBQUUsRUFBRTQwQixHQUFHMTBCLEVBQUU7SUFDaEM7QUFDRjtBQUNBLElBQUlzeEosMEJBQTBCLFNBQVNBLHdCQUF3QjlLLGlCQUFpQjtJQUM5RSxJQUFJLENBQUM7UUFBQztRQUFXO0tBQVcsQ0FBQ0MsUUFBUSxDQUFDRCxvQkFBb0I7UUFDeEQsTUFBTSxJQUFJdDRJLE1BQU07SUFDbEI7SUFDQSxPQUFPLFNBQVVvaUUsT0FBTyxFQUFFbHRELElBQUksRUFBRW5LLEdBQUcsRUFBRWs5RyxTQUFTLEVBQUVDLFVBQVU7UUFDeEQsSUFBSXA4SCxJQUFJLElBQUk7UUFDWixJQUFJLENBQUNvcEIsS0FBS294QyxPQUFPLElBQUk7WUFDbkI7UUFDRjtRQUNBLElBQUl0L0IsVUFBVTlSLEtBQUtnL0MsTUFBTSxDQUFDLEdBQUduOUMsTUFBTSxDQUFDdWhJLG1CQUFtQixhQUFhbmtGLE9BQU87UUFDM0UsSUFBSXFGLFVBQVV0a0QsS0FBS2cvQyxNQUFNLENBQUMsR0FBR245QyxNQUFNLENBQUN1aEksbUJBQW1CLGFBQWExcUosS0FBSztRQUN6RSxJQUFJMEksUUFBUTRlLEtBQUtnL0MsTUFBTSxDQUFDLEdBQUduOUMsTUFBTSxDQUFDdWhJLG1CQUFtQixXQUFXMXFKLEtBQUs7UUFDckUsSUFBSWdzRSxRQUFRMWtELEtBQUtnL0MsTUFBTSxDQUFDLEdBQUduOUMsTUFBTSxDQUFDdWhJLG1CQUFtQixXQUFXMXFKLEtBQUs7UUFDckUsSUFBSSs3QixTQUFTelUsS0FBS2cvQyxNQUFNLENBQUMsR0FBR245QyxNQUFNLENBQUN1aEksbUJBQW1CLG1CQUFtQjFxSixLQUFLO1FBQzlFLElBQUk0ckUsVUFBVSxHQUFHO1lBQ2Z6dUQsTUFBTUEsT0FBT21LLEtBQUtuRixRQUFRO1lBQzFCLElBQUlrNEcsYUFBYSxRQUFRQyxjQUFjLE1BQU07Z0JBQzNDLElBQUk3Z0csV0FBV25TLEtBQUs4UixPQUFPO2dCQUMzQmloRyxZQUFZL3lHLEtBQUtnVSxLQUFLLEtBQUssSUFBSTdCO2dCQUMvQjZnRyxhQUFhaHpHLEtBQUtpVSxNQUFNLEtBQUssSUFBSTlCO1lBQ25DO1lBQ0F2N0IsRUFBRTh0SixjQUFjLENBQUN4M0UsU0FBUzlyRSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFQSxLQUFLLENBQUMsRUFBRSxFQUFFa2pFO1lBQ3hEMXRFLEVBQUVpdUUsVUFBVSxDQUFDSCxNQUFNLENBQUNtMEMsSUFBSSxDQUFDM3JDLFNBQVNyM0QsSUFBSXpLLENBQUMsRUFBRXlLLElBQUloQixDQUFDLEVBQUVrK0csWUFBWWpoRyxVQUFVLEdBQUdraEcsYUFBYWxoRyxVQUFVLEdBQUcyQztZQUNuR3k0QyxRQUFRK3VCLElBQUk7UUFDZDtJQUNGO0FBQ0Y7QUFDQXN1RCxNQUFNNUssZUFBZSxHQUFHdU8sd0JBQXdCO0FBQ2hEM0QsTUFBTXpLLGdCQUFnQixHQUFHb08sd0JBQXdCO0FBRWpELDZDQUE2QztBQUM3QzNELE1BQU0zM0QsTUFBTSxHQUFHLFNBQVU1eUUsSUFBSTtJQUMzQkEsT0FBT0EsSUFBSSxDQUFDLEVBQUUsRUFBRSxpQkFBaUI7SUFFakMsT0FBT0EsS0FBSy9qQixRQUFRLENBQUMyMkYsTUFBTTtBQUM3QjtBQUNBMjNELE1BQU0xM0QsU0FBUyxHQUFHLFNBQVU3eUUsSUFBSTtJQUM5QkEsT0FBT0EsSUFBSSxDQUFDLEVBQUUsRUFBRSxpQkFBaUI7SUFFakMsT0FBT0EsS0FBSy9qQixRQUFRLENBQUM0MkYsU0FBUztBQUNoQztBQUNBMDNELE1BQU0rQixPQUFPLEdBQUcsU0FBVXAvRSxPQUFPLEVBQUVsdEQsSUFBSSxFQUFFeWxJLFdBQVcsRUFBRTV2SSxHQUFHO0lBQ3ZEbUssT0FBT0EsSUFBSSxDQUFDLEVBQUUsRUFBRSxpQkFBaUI7SUFDakNuSyxNQUFNQSxPQUFPbUssS0FBS25GLFFBQVE7SUFDMUIsSUFBSXN6SSxVQUFVbnVJLEtBQUszRixFQUFFLEdBQUdjLEtBQUs7SUFDN0IsSUFBSWl6SSxVQUFVcHVJLEtBQUtnL0MsTUFBTSxDQUFDO0lBQzFCLElBQUlxdkYsT0FBT3J1SSxLQUFLZy9DLE1BQU0sQ0FBQztJQUN2QixJQUFJc3ZGLG9CQUFvQnR1SSxLQUFLZy9DLE1BQU0sQ0FBQyxtQkFBbUJDLE9BQU87SUFDOUQsSUFBSTd6RCxJQUFJeUssSUFBSXpLLENBQUM7SUFDYixJQUFJeUosSUFBSWdCLElBQUloQixDQUFDO0lBQ2IsSUFBSXFsSCxRQUFRbDZHLEtBQUtnVSxLQUFLO0lBQ3RCLElBQUltbUcsUUFBUW42RyxLQUFLaVUsTUFBTTtJQUN2QixJQUFJUSxTQUFTNzRCLEtBQUsrVSxHQUFHLENBQUN1cEgsT0FBT0MsU0FBUyxHQUFHLG1CQUFtQjtJQUM1RCxJQUFJbzBCO0lBQ0osSUFBSUMsY0FBYyxHQUFHLHVEQUF1RDtJQUM1RSxJQUFJbEwsV0FBVyxJQUFJLENBQUNBLFFBQVE7SUFDNUIsSUFBSUEsVUFBVTtRQUNabDRJLElBQUk7UUFDSnlKLElBQUk7SUFDTjtJQUNBLElBQUl1NUksUUFBUXR1RixLQUFLLEtBQUssS0FBSztRQUN6QnJyQyxTQUFTQSxTQUFTMjVILFFBQVFudkYsT0FBTztJQUNuQyxPQUFPLElBQUltdkYsUUFBUW52RixPQUFPLEtBQUtwbEUsV0FBVztRQUN4QzQ2QixTQUFTMjVILFFBQVFudkYsT0FBTyxHQUFHLEdBQUcsK0JBQStCO0lBQy9EO0lBQ0EsSUFBSW92RixLQUFLdnVGLEtBQUssS0FBSyxLQUFLO1FBQ3RCeXVGLGFBQWE5NUgsU0FBUzQ1SCxLQUFLcHZGLE9BQU87SUFDcEMsT0FBTyxJQUFJb3ZGLEtBQUtwdkYsT0FBTyxLQUFLcGxFLFdBQVc7UUFDckMwMEosYUFBYUYsS0FBS3B2RixPQUFPLEdBQUcsR0FBRywrQkFBK0I7SUFDaEU7SUFDQSxJQUFJc3ZGLGNBQWM5NUgsUUFBUTtRQUN4QixRQUFRLG9DQUFvQztJQUM5QztJQUNBLElBQUssSUFBSXA3QixJQUFJLEdBQUdBLEtBQUs4MEosUUFBUW51RCxjQUFjLEVBQUUzbUcsSUFBSztRQUNoRCxPQUFPO1FBQ1AsSUFBSXNnQixPQUFPcUcsS0FBS2cvQyxNQUFNLENBQUMsU0FBUzNsRSxJQUFJLG9CQUFvQlgsS0FBSztRQUM3RCxJQUFJMEksUUFBUTRlLEtBQUtnL0MsTUFBTSxDQUFDLFNBQVMzbEUsSUFBSSxxQkFBcUJYLEtBQUs7UUFDL0QsSUFBSTRyRSxVQUFVdGtELEtBQUtnL0MsTUFBTSxDQUFDLFNBQVMzbEUsSUFBSSx1QkFBdUJYLEtBQUssR0FBRytzSjtRQUN0RSxJQUFJcGdFLFVBQVUxckUsT0FBTyxLQUFLLHVDQUF1QztRQUVqRSw4QkFBOEI7UUFDOUIsSUFBSTByRSxVQUFVbXBFLGNBQWMsR0FBRztZQUM3Qm5wRSxVQUFVLElBQUltcEU7UUFDaEI7UUFDQSxJQUFJQyxhQUFhLE1BQU03eUosS0FBS3NaLEVBQUUsR0FBRyxJQUFJdFosS0FBS3NaLEVBQUUsR0FBR3M1SSxhQUFhLHVDQUF1QztRQUNuR0MsY0FBY0gsbUJBQW1CLHVDQUF1QztRQUN4RSxJQUFJSSxhQUFhLElBQUk5eUosS0FBS3NaLEVBQUUsR0FBR213RTtRQUMvQixJQUFJc3BFLFdBQVdGLGFBQWFDO1FBRTVCLFlBQVk7UUFDWixjQUFjO1FBQ2QseUNBQXlDO1FBQ3pDLDZEQUE2RDtRQUM3RCxJQUFJLzBJLFNBQVMsS0FBSzYwSSxlQUFlLEtBQUtBLGNBQWNucEUsVUFBVSxHQUFHO1lBQy9EO1FBQ0Y7UUFDQSxJQUFJa3BFLGVBQWUsR0FBRztZQUNwQixtQkFBbUI7WUFDbkJyaEYsUUFBUTB4RSxTQUFTO1lBQ2pCMXhFLFFBQVE0eEUsTUFBTSxDQUFDMXpJLEdBQUd5SjtZQUNsQnE0RCxRQUFRODFDLEdBQUcsQ0FBQzUzRyxHQUFHeUosR0FBRzRmLFFBQVFnNkgsWUFBWUU7WUFDdEN6aEYsUUFBUTZ4RSxTQUFTO1FBQ25CLE9BQU87WUFDTCx1RUFBdUU7WUFDdkU3eEUsUUFBUTB4RSxTQUFTO1lBQ2pCMXhFLFFBQVE4MUMsR0FBRyxDQUFDNTNHLEdBQUd5SixHQUFHNGYsUUFBUWc2SCxZQUFZRTtZQUN0Q3poRixRQUFRODFDLEdBQUcsQ0FBQzUzRyxHQUFHeUosR0FBRzA1SSxZQUFZSSxVQUFVRixZQUFZLE9BQU8seUJBQXlCO1lBQ3BGdmhGLFFBQVE2eEUsU0FBUztRQUNuQjtRQUNBLElBQUksQ0FBQzJGLGNBQWMsQ0FBQ3gzRSxTQUFTOXJFLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVrakU7UUFDM0Q0SSxRQUFRK3VCLElBQUk7UUFDWnV5RCxlQUFlbnBFO0lBQ2pCO0FBQ0Y7QUFDQWtsRSxNQUFNa0MsVUFBVSxHQUFHLFNBQVV2L0UsT0FBTyxFQUFFbHRELElBQUksRUFBRXlsSSxXQUFXLEVBQUU1dkksR0FBRztJQUMxRG1LLE9BQU9BLElBQUksQ0FBQyxFQUFFLEVBQUUsaUJBQWlCO0lBQ2pDbkssTUFBTUEsT0FBT21LLEtBQUtuRixRQUFRO0lBQzFCLElBQUlzekksVUFBVW51SSxLQUFLM0YsRUFBRSxHQUFHYyxLQUFLO0lBQzdCLElBQUkvUCxJQUFJeUssSUFBSXpLLENBQUM7SUFDYixJQUFJeUosSUFBSWdCLElBQUloQixDQUFDO0lBQ2IsSUFBSXFsSCxRQUFRbDZHLEtBQUtnVSxLQUFLO0lBQ3RCLElBQUltbUcsUUFBUW42RyxLQUFLaVUsTUFBTTtJQUN2QixJQUFJdTZILGNBQWMsR0FBRyx1REFBdUQ7SUFDNUUsSUFBSWxMLFdBQVcsSUFBSSxDQUFDQSxRQUFRO0lBQzVCcDJFLFFBQVFrNkUsSUFBSTtJQUNaLElBQUlsdUgsWUFBWWxaLEtBQUtnL0MsTUFBTSxDQUFDLG9CQUFvQnRtRSxLQUFLO0lBQ3JELElBQUlrMkosYUFBYTV1SSxLQUFLZy9DLE1BQU0sQ0FBQztJQUM3QixPQUFROWxDO1FBQ04sS0FBSztZQUNIO1FBQ0YsVUFBVTtRQUNWLEtBQUs7WUFDSGcwQyxRQUFReEosTUFBTSxDQUFDLENBQUM5bkUsS0FBS3NaLEVBQUUsR0FBRztZQUMxQjtJQUNKO0lBQ0EsSUFBSTI1SSxVQUFVMzBCO0lBQ2QsSUFBSTQwQixVQUFVMzBCO0lBQ2QsSUFBSXkwQixXQUFXOXVGLEtBQUssS0FBSyxLQUFLO1FBQzVCK3VGLFVBQVVBLFVBQVVELFdBQVczdkYsT0FBTztRQUN0QzZ2RixVQUFVQSxVQUFVRixXQUFXM3ZGLE9BQU87SUFDeEMsT0FBTyxJQUFJMnZGLFdBQVczdkYsT0FBTyxLQUFLcGxFLFdBQVc7UUFDM0NnMUosVUFBVUQsV0FBVzN2RixPQUFPO1FBQzVCNnZGLFVBQVVGLFdBQVczdkYsT0FBTztJQUM5QjtJQUNBLElBQUlxa0YsVUFBVTtRQUNabDRJLElBQUk7UUFDSnlKLElBQUk7SUFDTjtJQUVBLDhEQUE4RDtJQUM5REEsS0FBS2c2SSxVQUFVO0lBQ2Z6akosS0FBSzBqSixVQUFVO0lBQ2YsSUFBSyxJQUFJejFKLElBQUksR0FBR0EsS0FBSzgwSixRQUFRbHVELGlCQUFpQixFQUFFNW1HLElBQUs7UUFDbkQsT0FBTztRQUNQLElBQUlzZ0IsT0FBT3FHLEtBQUtnL0MsTUFBTSxDQUFDLFlBQVkzbEUsSUFBSSxvQkFBb0JYLEtBQUs7UUFDaEUsSUFBSTBJLFFBQVE0ZSxLQUFLZy9DLE1BQU0sQ0FBQyxZQUFZM2xFLElBQUkscUJBQXFCWCxLQUFLO1FBQ2xFLElBQUk0ckUsVUFBVXRrRCxLQUFLZy9DLE1BQU0sQ0FBQyxZQUFZM2xFLElBQUksdUJBQXVCWCxLQUFLLEdBQUcrc0o7UUFDekUsSUFBSXBnRSxVQUFVMXJFLE9BQU8sS0FBSyx1Q0FBdUM7UUFFakUsOEJBQThCO1FBQzlCLElBQUkwckUsVUFBVW1wRSxjQUFjLEdBQUc7WUFDN0JucEUsVUFBVSxJQUFJbXBFO1FBQ2hCO1FBRUEsWUFBWTtRQUNaLGNBQWM7UUFDZCx3Q0FBd0M7UUFDeEMsNERBQTREO1FBQzVELElBQUk3MEksU0FBUyxLQUFLNjBJLGVBQWUsS0FBS0EsY0FBY25wRSxVQUFVLEdBQUc7WUFDL0Q7UUFDRjtRQUVBLG1DQUFtQztRQUNuQ25ZLFFBQVEweEUsU0FBUztRQUNqQjF4RSxRQUFRcXRDLElBQUksQ0FBQ252RyxHQUFHeUosSUFBSWk2SSxVQUFVTixhQUFhSyxTQUFTQyxVQUFVenBFO1FBQzlEblksUUFBUTZ4RSxTQUFTO1FBQ2pCLElBQUksQ0FBQzJGLGNBQWMsQ0FBQ3gzRSxTQUFTOXJFLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUVrakU7UUFDM0Q0SSxRQUFRK3VCLElBQUk7UUFDWnV5RCxlQUFlbnBFO0lBQ2pCO0lBQ0FuWSxRQUFRM3lELE9BQU87QUFDakI7QUFFQSxJQUFJdzBJLFFBQVEsQ0FBQztBQUNiLElBQUlDLGtCQUFrQjtBQUV0Qix5REFBeUQ7QUFFekRELE1BQU1oZCxhQUFhLEdBQUc7SUFDcEIsSUFBSTdrRSxVQUFVLElBQUksQ0FBQ3p5RCxJQUFJLENBQUN3MEksUUFBUSxDQUFDLEVBQUU7SUFDbkMsSUFBSSxJQUFJLENBQUM1ZSxnQkFBZ0IsSUFBSSxNQUFNO1FBQ2pDLE9BQU8sSUFBSSxDQUFDQSxnQkFBZ0I7SUFDOUI7SUFDQSxJQUFJLzRDLGtCQUFrQixJQUFJLENBQUNqOUUsRUFBRSxDQUFDL2YsTUFBTTtJQUNwQyxJQUFJNDBKLGVBQWVoaUYsUUFBUWlpRixzQkFBc0IsSUFBSWppRixRQUFRa2lGLDRCQUE0QixJQUFJbGlGLFFBQVFtaUYseUJBQXlCLElBQUluaUYsUUFBUW9pRix3QkFBd0IsSUFBSXBpRixRQUFRcWlGLHVCQUF1QixJQUFJcmlGLFFBQVFpaUYsc0JBQXNCLElBQUk7SUFDM08sT0FBTyxDQUFDNzNELGdCQUFnQms0RCxnQkFBZ0IsSUFBSSxLQUFLTixjQUFjLCtCQUErQjtBQUNoRztBQUNBSCxNQUFNVSxVQUFVLEdBQUcsU0FBVXZpRixPQUFPO0lBQ2xDLElBQUkwbUUsU0FBUyxJQUFJLENBQUM4YixXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLElBQUksRUFBRTtJQUN0RCxJQUFJQyxvQkFBb0I7SUFDeEIsSUFBSTl4SjtJQUNKLElBQUssSUFBSXhFLElBQUksR0FBR0EsSUFBSXU2SSxPQUFPOThJLE1BQU0sRUFBRXVDLElBQUs7UUFDdEN3RSxRQUFRKzFJLE1BQU0sQ0FBQ3Y2SSxFQUFFO1FBQ2pCLElBQUl3RSxNQUFNcXZFLE9BQU8sS0FBS0EsU0FBUztZQUM3QnlpRixvQkFBb0I7WUFDcEI7UUFDRjtJQUNGO0lBQ0EsSUFBSUEsbUJBQW1CO1FBQ3JCOXhKLFFBQVE7WUFDTnF2RSxTQUFTQTtRQUNYO1FBQ0EwbUUsT0FBT3Q2SSxJQUFJLENBQUN1RTtJQUNkO0lBQ0EsT0FBT0E7QUFDVDtBQUNBa3hKLE1BQU1hLHNCQUFzQixHQUFHLFNBQVUxaUYsT0FBTyxFQUFFMmlGLGNBQWMsRUFBRXozSSxHQUFHLEVBQUU2akYsSUFBSSxFQUFFMzNCLE9BQU87SUFDbEYsSUFBSXdyRjtJQUNKLElBQUl4TSxXQUFXLElBQUksQ0FBQ0EsUUFBUTtJQUM1QixJQUFJamlKLFNBQVMrVyxJQUFJNG1ELE1BQU0sQ0FBQzZ3RixpQkFBaUIseUJBQXlCbjNKLEtBQUssRUFDckV5a0UsWUFBWS9rRCxJQUFJNG1ELE1BQU0sQ0FBQzZ3RixpQkFBaUIsNEJBQTRCNXdGLE9BQU87SUFDN0UsSUFBSWc5QixTQUFTLG1CQUFtQjtRQUM5QixJQUFJN2pGLElBQUltNkIsTUFBTSxJQUFJO1lBQ2hCLElBQUl4bUIsUUFBUTNULElBQUl5eUQsY0FBYyxJQUM1QnJnRCxNQUFNcFMsSUFBSTJ5RCxjQUFjLElBQ3hCbnBELE1BQU14SixJQUFJNnlELFFBQVE7WUFDcEIsSUFBSTU0QixLQUFLaHVCLEtBQUswSCxPQUFPbks7WUFDckIsSUFBSTB3QixLQUFLanVCLEtBQUttRyxLQUFLNUk7WUFDbkJrdUksZ0JBQWdCNWlGLFFBQVE2aUYsb0JBQW9CLENBQUNudUksSUFBSXhXLENBQUMsRUFBRXdXLElBQUkvTSxDQUFDLEVBQUUsR0FBRytNLElBQUl4VyxDQUFDLEVBQUV3VyxJQUFJL00sQ0FBQyxFQUFFalosS0FBSzZVLEdBQUcsQ0FBQzRoQyxJQUFJQztRQUMzRixPQUFPO1lBQ0wsSUFBSXo4QixNQUFNeXRJLFdBQVc7Z0JBQ2pCbDRJLEdBQUc7Z0JBQ0h5SixHQUFHO1lBQ0wsSUFBSXVELElBQUl5QyxRQUFRLElBQ2hCbVosUUFBUTViLElBQUk2eEQsV0FBVyxJQUN2QmgyQyxTQUFTN2IsSUFBSTR4RCxZQUFZO1lBQzNCOGxGLGdCQUFnQjVpRixRQUFRNmlGLG9CQUFvQixDQUFDbDZJLElBQUl6SyxDQUFDLEVBQUV5SyxJQUFJaEIsQ0FBQyxFQUFFLEdBQUdnQixJQUFJekssQ0FBQyxFQUFFeUssSUFBSWhCLENBQUMsRUFBRWpaLEtBQUs2VSxHQUFHLENBQUN1akIsT0FBT0M7UUFDOUY7SUFDRixPQUFPO1FBQ0wsSUFBSTdiLElBQUltNkIsTUFBTSxJQUFJO1lBQ2hCLElBQUkyMUYsU0FBUzl2SCxJQUFJeXlELGNBQWMsSUFDN0JtbEYsT0FBTzUzSSxJQUFJMnlELGNBQWM7WUFDM0Ira0YsZ0JBQWdCNWlGLFFBQVEraUYsb0JBQW9CLENBQUMvbkIsT0FBTzk4SCxDQUFDLEVBQUU4OEgsT0FBT3J6SCxDQUFDLEVBQUVtN0ksS0FBSzVrSixDQUFDLEVBQUU0a0osS0FBS243SSxDQUFDO1FBQ2pGLE9BQU87WUFDTCxJQUFJeW9ELE9BQU9nbUYsV0FBVztnQkFDbEJsNEksR0FBRztnQkFDSHlKLEdBQUc7WUFDTCxJQUFJdUQsSUFBSXlDLFFBQVEsSUFDaEJxMUksU0FBUzkzSSxJQUFJNnhELFdBQVcsSUFDeEJrbUYsVUFBVS8zSSxJQUFJNHhELFlBQVksSUFDMUJwMUMsWUFBWXM3SCxTQUFTLEdBQ3JCcjdILGFBQWFzN0gsVUFBVTtZQUN6QixJQUFJajNILFlBQVk5Z0IsSUFBSTRtRCxNQUFNLENBQUMsaUNBQWlDdG1FLEtBQUs7WUFDakUsT0FBUXdnQztnQkFDTixLQUFLO29CQUNINDJILGdCQUFnQjVpRixRQUFRK2lGLG9CQUFvQixDQUFDM3lGLEtBQUtseUQsQ0FBQyxFQUFFa3lELEtBQUt6b0QsQ0FBQyxHQUFHZ2dCLFlBQVl5b0MsS0FBS2x5RCxDQUFDLEVBQUVreUQsS0FBS3pvRCxDQUFDLEdBQUdnZ0I7b0JBQzNGO2dCQUNGLEtBQUs7b0JBQ0hpN0gsZ0JBQWdCNWlGLFFBQVEraUYsb0JBQW9CLENBQUMzeUYsS0FBS2x5RCxDQUFDLEVBQUVreUQsS0FBS3pvRCxDQUFDLEdBQUdnZ0IsWUFBWXlvQyxLQUFLbHlELENBQUMsRUFBRWt5RCxLQUFLem9ELENBQUMsR0FBR2dnQjtvQkFDM0Y7Z0JBQ0YsS0FBSztvQkFDSGk3SCxnQkFBZ0I1aUYsUUFBUStpRixvQkFBb0IsQ0FBQzN5RixLQUFLbHlELENBQUMsR0FBR3dwQixXQUFXMG9DLEtBQUt6b0QsQ0FBQyxFQUFFeW9ELEtBQUtseUQsQ0FBQyxHQUFHd3BCLFdBQVcwb0MsS0FBS3pvRCxDQUFDO29CQUNuRztnQkFDRixLQUFLO29CQUNIaTdJLGdCQUFnQjVpRixRQUFRK2lGLG9CQUFvQixDQUFDM3lGLEtBQUtseUQsQ0FBQyxHQUFHd3BCLFdBQVcwb0MsS0FBS3pvRCxDQUFDLEVBQUV5b0QsS0FBS2x5RCxDQUFDLEdBQUd3cEIsV0FBVzBvQyxLQUFLem9ELENBQUM7b0JBQ25HO2dCQUNGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSGk3SSxnQkFBZ0I1aUYsUUFBUStpRixvQkFBb0IsQ0FBQzN5RixLQUFLbHlELENBQUMsR0FBR3dwQixXQUFXMG9DLEtBQUt6b0QsQ0FBQyxHQUFHZ2dCLFlBQVl5b0MsS0FBS2x5RCxDQUFDLEdBQUd3cEIsV0FBVzBvQyxLQUFLem9ELENBQUMsR0FBR2dnQjtvQkFDbkg7Z0JBQ0YsS0FBSztnQkFDTCxLQUFLO29CQUNIaTdILGdCQUFnQjVpRixRQUFRK2lGLG9CQUFvQixDQUFDM3lGLEtBQUtseUQsQ0FBQyxHQUFHd3BCLFdBQVcwb0MsS0FBS3pvRCxDQUFDLEdBQUdnZ0IsWUFBWXlvQyxLQUFLbHlELENBQUMsR0FBR3dwQixXQUFXMG9DLEtBQUt6b0QsQ0FBQyxHQUFHZ2dCO29CQUNuSDtnQkFDRixLQUFLO2dCQUNMLEtBQUs7b0JBQ0hpN0gsZ0JBQWdCNWlGLFFBQVEraUYsb0JBQW9CLENBQUMzeUYsS0FBS2x5RCxDQUFDLEdBQUd3cEIsV0FBVzBvQyxLQUFLem9ELENBQUMsR0FBR2dnQixZQUFZeW9DLEtBQUtseUQsQ0FBQyxHQUFHd3BCLFdBQVcwb0MsS0FBS3pvRCxDQUFDLEdBQUdnZ0I7b0JBQ25IO2dCQUNGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSGk3SCxnQkFBZ0I1aUYsUUFBUStpRixvQkFBb0IsQ0FBQzN5RixLQUFLbHlELENBQUMsR0FBR3dwQixXQUFXMG9DLEtBQUt6b0QsQ0FBQyxHQUFHZ2dCLFlBQVl5b0MsS0FBS2x5RCxDQUFDLEdBQUd3cEIsV0FBVzBvQyxLQUFLem9ELENBQUMsR0FBR2dnQjtvQkFDbkg7WUFDSjtRQUNGO0lBQ0Y7SUFDQSxJQUFJLENBQUNpN0gsZUFBZSxPQUFPLE1BQU0seUJBQXlCO0lBRTFELElBQUlNLGVBQWVqekYsVUFBVXJtRSxNQUFNLEtBQUt1SyxPQUFPdkssTUFBTTtJQUNyRCxJQUFJQSxTQUFTdUssT0FBT3ZLLE1BQU07SUFDMUIsSUFBSyxJQUFJdUMsSUFBSSxHQUFHQSxJQUFJdkMsUUFBUXVDLElBQUs7UUFDL0J5MkosY0FBY08sWUFBWSxDQUFDRCxlQUFlanpGLFNBQVMsQ0FBQzlqRSxFQUFFLEdBQUdBLElBQUt2QyxDQUFBQSxTQUFTLElBQUksVUFBVXVLLE1BQU0sQ0FBQ2hJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWdJLE1BQU0sQ0FBQ2hJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWdJLE1BQU0sQ0FBQ2hJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWlyRSxVQUFVO0lBQ2hLO0lBQ0EsT0FBT3dyRjtBQUNUO0FBQ0FmLE1BQU11QixpQkFBaUIsR0FBRyxTQUFVcGpGLE9BQU8sRUFBRTkwRCxHQUFHLEVBQUU2akYsSUFBSSxFQUFFMzNCLE9BQU87SUFDN0QsSUFBSXdyRixnQkFBZ0IsSUFBSSxDQUFDRixzQkFBc0IsQ0FBQzFpRixTQUFTLGNBQWM5MEQsS0FBSzZqRixNQUFNMzNCO0lBQ2xGLElBQUksQ0FBQ3dyRixlQUFlLE9BQU8sTUFBTSxRQUFRO0lBQ3pDNWlGLFFBQVErMkUsU0FBUyxHQUFHNkw7QUFDdEI7QUFDQWYsTUFBTXJLLGNBQWMsR0FBRyxTQUFVeDNFLE9BQU8sRUFBRXQyRSxDQUFDLEVBQUVrSixDQUFDLEVBQUVYLENBQUMsRUFBRXRJLENBQUM7SUFDbERxMkUsUUFBUSsyRSxTQUFTLEdBQUcsVUFBVXJ0SixJQUFJLE1BQU1rSixJQUFJLE1BQU1YLElBQUksTUFBTXRJLElBQUk7QUFDaEUsdURBQXVEO0FBRXZELHdDQUF3QztBQUV4QyxtRUFBbUU7QUFFbkUsdUNBQXVDO0FBQ3ZDLHFEQUFxRDtBQUNyRCxJQUFJO0FBQ047QUFDQWs0SixNQUFNdEQsWUFBWSxHQUFHLFNBQVV2K0UsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWtzRCxPQUFPO0lBQ2xELElBQUlpc0YsaUJBQWlCbjRJLElBQUk0bUQsTUFBTSxDQUFDLG1CQUFtQnRtRSxLQUFLO0lBQ3hELElBQUk2M0osbUJBQW1CLHFCQUFxQkEsbUJBQW1CLG1CQUFtQjtRQUNoRixJQUFJLENBQUNELGlCQUFpQixDQUFDcGpGLFNBQVM5MEQsS0FBS200SSxnQkFBZ0Jqc0Y7SUFDdkQsT0FBTztRQUNMLElBQUlrc0Ysa0JBQWtCcDRJLElBQUk0bUQsTUFBTSxDQUFDLG9CQUFvQnRtRSxLQUFLO1FBQzFELElBQUksQ0FBQ2dzSixjQUFjLENBQUN4M0UsU0FBU3NqRixlQUFlLENBQUMsRUFBRSxFQUFFQSxlQUFlLENBQUMsRUFBRSxFQUFFQSxlQUFlLENBQUMsRUFBRSxFQUFFbHNGO0lBQzNGO0FBQ0Y7QUFDQXlxRixNQUFNMEIsbUJBQW1CLEdBQUcsU0FBVXZqRixPQUFPLEVBQUU5MEQsR0FBRyxFQUFFNmpGLElBQUksRUFBRTMzQixPQUFPO0lBQy9ELElBQUl3ckYsZ0JBQWdCLElBQUksQ0FBQ0Ysc0JBQXNCLENBQUMxaUYsU0FBUyxRQUFROTBELEtBQUs2akYsTUFBTTMzQjtJQUM1RSxJQUFJLENBQUN3ckYsZUFBZSxPQUFPLE1BQU0sUUFBUTtJQUN6QzVpRixRQUFRZzNFLFdBQVcsR0FBRzRMO0FBQ3hCO0FBQ0FmLE1BQU10TSxnQkFBZ0IsR0FBRyxTQUFVdjFFLE9BQU8sRUFBRXQyRSxDQUFDLEVBQUVrSixDQUFDLEVBQUVYLENBQUMsRUFBRXRJLENBQUM7SUFDcERxMkUsUUFBUWczRSxXQUFXLEdBQUcsVUFBVXR0SixJQUFJLE1BQU1rSixJQUFJLE1BQU1YLElBQUksTUFBTXRJLElBQUk7QUFDbEUsdURBQXVEO0FBRXZELHdDQUF3QztBQUV4QyxxRUFBcUU7QUFFckUsMkNBQTJDO0FBQzNDLDJEQUEyRDtBQUMzRCxJQUFJO0FBQ047QUFDQWs0SixNQUFNM00sY0FBYyxHQUFHLFNBQVVsMUUsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWtzRCxPQUFPO0lBQ3BELElBQUlvc0YsV0FBV3Q0SSxJQUFJNG1ELE1BQU0sQ0FBQyxhQUFhdG1FLEtBQUs7SUFDNUMsSUFBSWc0SixhQUFhLHFCQUFxQkEsYUFBYSxtQkFBbUI7UUFDcEUsSUFBSSxDQUFDRCxtQkFBbUIsQ0FBQ3ZqRixTQUFTOTBELEtBQUtzNEksVUFBVXBzRjtJQUNuRCxPQUFPO1FBQ0wsSUFBSXFzRixZQUFZdjRJLElBQUk0bUQsTUFBTSxDQUFDLGNBQWN0bUUsS0FBSztRQUM5QyxJQUFJLENBQUMrcEosZ0JBQWdCLENBQUN2MUUsU0FBU3lqRixTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRSxFQUFFcnNGO0lBQzNFO0FBQ0Y7QUFFQSxnQkFBZ0I7QUFDaEJ5cUYsTUFBTWhlLGVBQWUsR0FBRyxTQUFVbGxELFNBQVM7SUFDekMsSUFBSWoxRixJQUFJLElBQUk7SUFDWixJQUFJNmpCLE9BQU83akIsRUFBRTZqQixJQUFJO0lBQ2pCLElBQUk2VyxLQUFLMTZCLEVBQUV1akgseUJBQXlCO0lBQ3BDLElBQUlubUYsUUFBUTFDLEVBQUUsQ0FBQyxFQUFFO0lBQ2pCLElBQUkyQyxTQUFTM0MsRUFBRSxDQUFDLEVBQUU7SUFDbEIsSUFBSTY0RCxhQUFhdnpGLEVBQUVtN0ksYUFBYTtJQUNoQyxJQUFJNmUsWUFBWWg2SixFQUFFMjVJLGlCQUFpQjtJQUNuQyxJQUFJMWtELGNBQWNqMUYsRUFBRTZqQixJQUFJLENBQUNvMkksY0FBYyxDQUFDajZKLEVBQUVrNkosc0JBQXNCLENBQUMsSUFBSWpsRSxjQUFjajFGLEVBQUU2akIsSUFBSSxDQUFDbzJJLGNBQWMsQ0FBQ2o2SixFQUFFbTZKLHNCQUFzQixDQUFDLEVBQUU7UUFDbEk1bUUsYUFBYXltRTtJQUNmO0lBQ0EsSUFBSUksY0FBY2g5SCxRQUFRbTJEO0lBQzFCLElBQUk4bUUsZUFBZWg5SCxTQUFTazJEO0lBQzVCLElBQUl1dEM7SUFDSixJQUFJczVCLGdCQUFnQnA2SixFQUFFbzZKLFdBQVcsSUFBSUMsaUJBQWlCcjZKLEVBQUVxNkosWUFBWSxFQUFFO1FBQ3BFLFFBQVEsc0JBQXNCO0lBQ2hDO0lBQ0FyNkosRUFBRXF4SixVQUFVLEdBQUcsTUFBTSw0QkFBNEI7SUFFakQsSUFBSWlKLGtCQUFrQnoySSxLQUFLeTJJLGVBQWU7SUFDMUNBLGdCQUFnQi8xSSxLQUFLLENBQUM2WSxLQUFLLEdBQUdBLFFBQVE7SUFDdENrOUgsZ0JBQWdCLzFJLEtBQUssQ0FBQzhZLE1BQU0sR0FBR0EsU0FBUztJQUN4QyxJQUFLLElBQUk1NkIsSUFBSSxHQUFHQSxJQUFJekMsRUFBRXU2SixhQUFhLEVBQUU5M0osSUFBSztRQUN4Q3ErSCxTQUFTajlHLEtBQUsyMkksUUFBUSxDQUFDLzNKLEVBQUU7UUFDekJxK0gsT0FBTzFqRyxLQUFLLEdBQUdnOUg7UUFDZnQ1QixPQUFPempHLE1BQU0sR0FBR2c5SDtRQUNoQnY1QixPQUFPdjhHLEtBQUssQ0FBQzZZLEtBQUssR0FBR0EsUUFBUTtRQUM3QjBqRyxPQUFPdjhHLEtBQUssQ0FBQzhZLE1BQU0sR0FBR0EsU0FBUztJQUNqQztJQUNBLElBQUssSUFBSTU2QixJQUFJLEdBQUdBLElBQUl6QyxFQUFFeTZKLFlBQVksRUFBRWg0SixJQUFLO1FBQ3ZDcStILFNBQVNqOUcsS0FBS28ySSxjQUFjLENBQUN4M0osRUFBRTtRQUMvQnErSCxPQUFPMWpHLEtBQUssR0FBR2c5SDtRQUNmdDVCLE9BQU96akcsTUFBTSxHQUFHZzlIO1FBQ2hCdjVCLE9BQU92OEcsS0FBSyxDQUFDNlksS0FBSyxHQUFHQSxRQUFRO1FBQzdCMGpHLE9BQU92OEcsS0FBSyxDQUFDOFksTUFBTSxHQUFHQSxTQUFTO0lBQ2pDO0lBQ0FyOUIsRUFBRTA2SixXQUFXLEdBQUc7SUFDaEIsSUFBSW5uRSxjQUFjLEdBQUc7UUFDbkJ1dEMsU0FBU2o5RyxLQUFLbzJJLGNBQWMsQ0FBQ2o2SixFQUFFMjZKLGNBQWMsQ0FBQztRQUM5QzM2SixFQUFFMDZKLFdBQVcsR0FBRztRQUNoQjU1QixPQUFPMWpHLEtBQUssR0FBR2c5SCxjQUFjcDZKLEVBQUUwNkosV0FBVztRQUMxQzU1QixPQUFPempHLE1BQU0sR0FBR2c5SCxlQUFlcjZKLEVBQUUwNkosV0FBVztJQUM5QztJQUNBMTZKLEVBQUVvNkosV0FBVyxHQUFHQTtJQUNoQnA2SixFQUFFcTZKLFlBQVksR0FBR0E7SUFDakJyNkosRUFBRXV6RixVQUFVLEdBQUdBO0FBQ2pCO0FBQ0E0a0UsTUFBTTVqRSxRQUFRLEdBQUcsU0FBVXNDLEdBQUcsRUFBRW53RSxJQUFJLEVBQUVELEdBQUcsRUFBRSt0RSxPQUFPO0lBQ2hELElBQUksQ0FBQ2lrRCxNQUFNLENBQUM7UUFDVm1pQixlQUFlL2pFO1FBQ2Zna0UsWUFBWW4wSTtRQUNabzBJLFdBQVdyMEk7UUFDWHMwSSxlQUFlO1FBQ2ZDLGVBQWV4bUU7SUFDakI7QUFDRjtBQUNBMmpFLE1BQU04QyxXQUFXLEdBQUc7SUFDbEIsSUFBSWo3SixJQUFJLElBQUk7SUFDWixJQUFJNmpCLE9BQU83akIsRUFBRTZqQixJQUFJO0lBQ2pCLFNBQVN2QixNQUFNZzBELE9BQU87UUFDcEJBLFFBQVEyckUsU0FBUyxDQUFDLEdBQUcsR0FBR2ppSixFQUFFbzZKLFdBQVcsRUFBRXA2SixFQUFFcTZKLFlBQVk7SUFDdkQ7SUFDQS8zSSxNQUFNdUIsS0FBS3cwSSxRQUFRLENBQUNyNEosRUFBRWs3SixJQUFJLENBQUM7SUFDM0I1NEksTUFBTXVCLEtBQUt3MEksUUFBUSxDQUFDcjRKLEVBQUVtN0osSUFBSSxDQUFDO0FBQzdCO0FBQ0FoRCxNQUFNMWYsTUFBTSxHQUFHLFNBQVV6a0ksT0FBTztJQUM5QixJQUFJaFUsSUFBSSxJQUFJO0lBQ1pnVSxVQUFVQSxXQUFXZ047SUFDckIsSUFBSXlDLEtBQUt6akIsRUFBRXlqQixFQUFFO0lBQ2IsSUFBSW0zSSxnQkFBZ0I1bUosUUFBUTRtSixhQUFhO0lBQ3pDLElBQUlHLGdCQUFnQi9tSixRQUFRK21KLGFBQWE7SUFDekMsSUFBSUssb0JBQW9CcG5KLFFBQVFvbkosaUJBQWlCO0lBQ2pELElBQUlQLGFBQWE3bUosUUFBUTZtSixVQUFVO0lBQ25DLElBQUlDLFlBQVk5bUosUUFBUThtSixTQUFTO0lBQ2pDLElBQUl2bkUsYUFBYXYvRSxRQUFRZ25KLGFBQWEsS0FBSy8zSixZQUFZLElBQUksQ0FBQ2s0SSxhQUFhLEtBQUtubkksUUFBUWduSixhQUFhO0lBQ25HLElBQUluM0ksT0FBTzdqQixFQUFFNmpCLElBQUk7SUFDakIsSUFBSXczSSxXQUFXeDNJLEtBQUt5M0ksaUJBQWlCO0lBQ3JDLElBQUlDLGNBQWN2N0osRUFBRW96RixpQkFBaUIsSUFBSSxDQUFDd25FLGlCQUFrQjU2SixDQUFBQSxFQUFFbXdJLFFBQVEsSUFBSW53SSxFQUFFeXBJLFNBQVMsQ0FBQzZCLFFBQVEsSUFBSXRySSxFQUFFZ3lJLFlBQVksSUFBSWh5SSxFQUFFNmpCLElBQUksQ0FBQ2txSCxZQUFZO0lBQ3ZJLElBQUkxNkMsYUFBYXIvRSxRQUFRcS9FLFVBQVUsS0FBS3B3RixZQUFZK1EsUUFBUXEvRSxVQUFVLEdBQUdyekYsRUFBRXF6RixVQUFVO0lBQ3JGLElBQUkybUUsWUFBWWg2SixFQUFFMjVJLGlCQUFpQjtJQUNuQyxJQUFJcjFFLG1CQUFtQjdnRCxHQUFHNmdELGdCQUFnQjtJQUMxQyxJQUFJazNGLG9CQUFvQng3SixFQUFFeXBJLFNBQVMsQ0FBQzRCLFlBQVk7SUFDaEQsSUFBSXJDLGlCQUFpQmhwSSxFQUFFeXBJLFNBQVMsQ0FBQzhCLFNBQVMsSUFBSXZySSxFQUFFd3ZJLFNBQVMsQ0FBQ2pFLFNBQVMsR0FBRyxPQUFPO0lBQzdFbDRDLGFBQWFBLGNBQWMsQ0FBQ3VuRSxpQkFBaUI1NkosRUFBRXc1SSxpQkFBaUIsSUFBSSxDQUFDeFE7SUFDckUsSUFBSXl5Qix1QkFBdUJwb0U7SUFDM0IsSUFBSSxDQUFDdW5FLGVBQWU7UUFDbEIsSUFBSTU2SixFQUFFMDdKLFdBQVcsS0FBS25vRSxZQUFZO1lBQ2hDdnpGLEVBQUVta0gsb0NBQW9DO1lBQ3RDbmtILEVBQUVtNkksZUFBZSxDQUFDbjZJLEVBQUVpMUYsU0FBUztZQUM3QmoxRixFQUFFZ3JJLFVBQVUsQ0FBQyxRQUFRO1lBQ3JCaHJJLEVBQUVnckksVUFBVSxDQUFDLFFBQVE7UUFDdkI7UUFDQWhySSxFQUFFMDdKLFdBQVcsR0FBR25vRTtJQUNsQjtJQUNBLElBQUksQ0FBQ3FuRSxpQkFBaUI1NkosRUFBRTI3SixpQkFBaUIsRUFBRTtRQUN6Q2xnSixhQUFhemIsRUFBRTI3SixpQkFBaUI7SUFDbEM7SUFDQSxJQUFJdG9FLFlBQVk7UUFDZCxJQUFJcnpGLEVBQUU0N0osUUFBUSxJQUFJLE1BQU07WUFDdEI1N0osRUFBRTQ3SixRQUFRLEdBQUc7UUFDZjtRQUNBNTdKLEVBQUU0N0osUUFBUTtRQUNWLElBQUk1N0osRUFBRTQ3SixRQUFRLEdBQUcsR0FBRztZQUNsQiwwREFBMEQ7WUFDMURILHVCQUF1QjtRQUN6QjtRQUVBLGlHQUFpRztRQUNqRyxJQUFJejdKLEVBQUU0N0osUUFBUSxHQUFHNTdKLEVBQUU2NUksa0JBQWtCLEVBQUU7WUFDckMsMEJBQTBCO1lBQzFCNzVJLEVBQUUyNUksaUJBQWlCLEdBQUczNUksRUFBRTQ1SSxXQUFXO1FBQ3JDO0lBQ0Y7SUFDQSxJQUFJNTVJLEVBQUU2N0osa0JBQWtCLEVBQUU7UUFDeEI3N0osRUFBRTI1SSxpQkFBaUIsR0FBRztJQUN4QjtJQUVBLHFGQUFxRjtJQUNyRiwyREFBMkQ7SUFDM0QsSUFBSTM1SSxFQUFFODdKLG9CQUFvQixJQUFJLENBQUNQLGFBQWE7UUFDMUNGLFFBQVEsQ0FBQ3I3SixFQUFFazdKLElBQUksQ0FBQyxHQUFHO1FBQ25CRyxRQUFRLENBQUNyN0osRUFBRSs3SixVQUFVLENBQUMsR0FBRztJQUMzQjtJQUNBLElBQUl4M0ksUUFBUWQsR0FBR2MsS0FBSztJQUNwQixJQUFJbUMsT0FBT2pELEdBQUdpRCxJQUFJO0lBQ2xCLElBQUlzMUksZ0JBQWdCbkIsZUFBZTUzSixZQUFZNDNKLGFBQWFuMEk7SUFDNUQsSUFBSUQsTUFBTWhELEdBQUdnRCxHQUFHO0lBQ2hCLElBQUl3MUksZUFBZTtRQUNqQnpuSixHQUFHaVMsSUFBSWpTLENBQUM7UUFDUnlKLEdBQUd3SSxJQUFJeEksQ0FBQztJQUNWO0lBQ0EsSUFBSW9tQyxLQUFLO1FBQ1AzOUIsTUFBTUE7UUFDTkQsS0FBSztZQUNIalMsR0FBR2lTLElBQUlqUyxDQUFDO1lBQ1J5SixHQUFHd0ksSUFBSXhJLENBQUM7UUFDVjtJQUNGO0lBQ0EsSUFBSWkrSSxTQUFTbDhKLEVBQUVtOEosWUFBWTtJQUMzQixJQUFJQyxpQkFBaUJGLFdBQVdqNUosYUFBYW9oRCxHQUFHMzlCLElBQUksS0FBS3cxSSxPQUFPeDFJLElBQUksSUFBSTI5QixHQUFHNTlCLEdBQUcsQ0FBQ2pTLENBQUMsS0FBSzBuSixPQUFPejFJLEdBQUcsQ0FBQ2pTLENBQUMsSUFBSTZ2QyxHQUFHNTlCLEdBQUcsQ0FBQ3hJLENBQUMsS0FBS2krSSxPQUFPejFJLEdBQUcsQ0FBQ3hJLENBQUM7SUFFOUgsOEdBQThHO0lBQzlHLElBQUksQ0FBQ20rSSxrQkFBa0IsQ0FBRVosQ0FBQUEscUJBQXFCLENBQUNsM0YsZ0JBQWUsR0FBSTtRQUNoRXRrRSxFQUFFMjVJLGlCQUFpQixHQUFHO0lBQ3hCO0lBQ0EsSUFBSW1oQixXQUFXO1FBQ2JtQixlQUFlbkI7SUFDakI7SUFFQSxvQkFBb0I7SUFFcEJrQixpQkFBaUJ6b0U7SUFDakIwb0UsYUFBYXpuSixDQUFDLElBQUkrK0U7SUFDbEIwb0UsYUFBYWgrSSxDQUFDLElBQUlzMUU7SUFDbEIsSUFBSWhtRSxPQUFPdnRCLEVBQUV3a0gsb0JBQW9CO0lBQ2pDLFNBQVM2M0MsUUFBUS9sRixPQUFPLEVBQUU5aEUsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFa0IsQ0FBQyxFQUFFNVYsQ0FBQztRQUNsQyxJQUFJcWtKLE1BQU10M0UsUUFBUXUzRSx3QkFBd0I7UUFDMUN2M0UsUUFBUXUzRSx3QkFBd0IsR0FBRztRQUNuQzd0SixFQUFFOHRKLGNBQWMsQ0FBQ3gzRSxTQUFTLEtBQUssS0FBSyxLQUFLdDJFLEVBQUUwNUksc0JBQXNCO1FBQ2pFcGpFLFFBQVFnbUYsUUFBUSxDQUFDOW5KLEdBQUd5SixHQUFHa0IsR0FBRzVWO1FBQzFCK3NFLFFBQVF1M0Usd0JBQXdCLEdBQUdEO0lBQ3JDO0lBQ0EsU0FBUzJPLG9CQUFvQmptRixPQUFPLEVBQUVoMEQsS0FBSztRQUN6QyxJQUFJazZJLE1BQU1DLE9BQU90OUksR0FBRzVWO1FBQ3BCLElBQUksQ0FBQ3ZKLEVBQUU2N0osa0JBQWtCLElBQUt2bEYsQ0FBQUEsWUFBWXp5RCxLQUFLNjRJLGNBQWMsQ0FBQzE4SixFQUFFazZKLHNCQUFzQixDQUFDLElBQUk1akYsWUFBWXp5RCxLQUFLNjRJLGNBQWMsQ0FBQzE4SixFQUFFbTZKLHNCQUFzQixDQUFDLEdBQUc7WUFDckpxQyxPQUFPO2dCQUNMaG9KLEdBQUdpUyxJQUFJalMsQ0FBQyxHQUFHd2xKO2dCQUNYLzdJLEdBQUd3SSxJQUFJeEksQ0FBQyxHQUFHKzdJO1lBQ2I7WUFDQXlDLFFBQVEvMUksT0FBT3N6STtZQUNmNzZJLElBQUluZixFQUFFbzZKLFdBQVcsR0FBR0o7WUFDcEJ6d0osSUFBSXZKLEVBQUVxNkosWUFBWSxHQUFHTDtRQUN2QixPQUFPO1lBQ0x3QyxPQUFPUDtZQUNQUSxRQUFRVDtZQUNSNzhJLElBQUluZixFQUFFbzZKLFdBQVc7WUFDakI3d0osSUFBSXZKLEVBQUVxNkosWUFBWTtRQUNwQjtRQUNBL2pGLFFBQVEwckUsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztRQUNwQyxJQUFJMS9ILFVBQVUsY0FBYztZQUMxQis1SSxRQUFRL2xGLFNBQVMsR0FBRyxHQUFHbjNELEdBQUc1VjtRQUM1QixPQUFPLElBQUksQ0FBQ3F4SixpQkFBa0J0NEksQ0FBQUEsVUFBVXJmLGFBQWFxZixLQUFJLEdBQUk7WUFDM0RnMEQsUUFBUTJyRSxTQUFTLENBQUMsR0FBRyxHQUFHOWlJLEdBQUc1VjtRQUM3QjtRQUNBLElBQUksQ0FBQ3d4SixlQUFlO1lBQ2xCemtGLFFBQVErckUsU0FBUyxDQUFDbWEsS0FBS2hvSixDQUFDLEVBQUVnb0osS0FBS3YrSSxDQUFDO1lBQ2hDcTRELFFBQVFwNkMsS0FBSyxDQUFDdWdJLE9BQU9BO1FBQ3ZCO1FBQ0EsSUFBSTNCLFdBQVc7WUFDYnhrRixRQUFRK3JFLFNBQVMsQ0FBQ3lZLFVBQVV0bUosQ0FBQyxFQUFFc21KLFVBQVU3OEksQ0FBQztRQUM1QztRQUNBLElBQUk0OEksWUFBWTtZQUNkdmtGLFFBQVFwNkMsS0FBSyxDQUFDMitILFlBQVlBO1FBQzVCO0lBQ0Y7SUFDQSxJQUFJLENBQUNVLGFBQWE7UUFDaEJ2N0osRUFBRTg3SixvQkFBb0IsR0FBRztJQUMzQjtJQUNBLElBQUlQLGFBQWE7UUFDZnY3SixFQUFFODdKLG9CQUFvQixHQUFHO1FBQ3pCLElBQUksQ0FBQzk3SixFQUFFMjhKLFlBQVksRUFBRTtZQUNuQjM4SixFQUFFMjhKLFlBQVksR0FBRyxDQUFDO1lBQ2xCMzhKLEVBQUUyOEosWUFBWSxDQUFDamlJLEVBQUUsR0FBR2pYLEdBQUd3MUQsZUFBZSxHQUFHcHpFLFdBQVc7WUFDcEQ3RixFQUFFMjhKLFlBQVksQ0FBQzNiLE9BQU8sR0FBR2hoSixFQUFFNmpCLElBQUksQ0FBQ28ySSxjQUFjLENBQUNqNkosRUFBRTI2SixjQUFjLENBQUM7WUFDaEUsSUFBSTlqRSxNQUFNNzJGLEVBQUU2akIsSUFBSSxDQUFDNjRJLGNBQWMsQ0FBQzE4SixFQUFFMjZKLGNBQWMsQ0FBQztZQUNqRDlqRSxJQUFJbXJELFlBQVksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7WUFDaENuckQsSUFBSW9yRCxTQUFTLENBQUMsR0FBRyxHQUFHamlKLEVBQUVvNkosV0FBVyxHQUFHcDZKLEVBQUUwNkosV0FBVyxFQUFFMTZKLEVBQUVxNkosWUFBWSxHQUFHcjZKLEVBQUUwNkosV0FBVztZQUNqRjE2SixFQUFFeTRJLE1BQU0sQ0FBQztnQkFDUG1pQixlQUFlL2pFO2dCQUNmdWtFLG1CQUFtQjtnQkFDbkJKLGVBQWV6bkUsYUFBYXZ6RixFQUFFMDZKLFdBQVc7WUFDM0M7WUFDQSxJQUFJcjJHLEtBQUtya0QsRUFBRTI4SixZQUFZLENBQUM3dUQsUUFBUSxHQUFHO2dCQUNqQ3BuRixNQUFNakQsR0FBR2lELElBQUk7Z0JBQ2JELEtBQUtoRCxHQUFHZ0QsR0FBRztnQkFDWDJXLE9BQU9wOUIsRUFBRW82SixXQUFXO2dCQUNwQi84SCxRQUFRcjlCLEVBQUVxNkosWUFBWTtZQUN4QjtZQUNBaDJHLEdBQUd1NEcsSUFBSSxHQUFHO2dCQUNScG9KLEdBQUcsQ0FBQyxJQUFJNnZDLEdBQUc1OUIsR0FBRyxDQUFDalMsQ0FBQyxJQUFJNnZDLEdBQUczOUIsSUFBSTtnQkFDM0J6SSxHQUFHLENBQUMsSUFBSW9tQyxHQUFHNTlCLEdBQUcsQ0FBQ3hJLENBQUMsSUFBSW9tQyxHQUFHMzlCLElBQUk7WUFDN0I7UUFDRjtRQUNBMjBJLFFBQVEsQ0FBQ3I3SixFQUFFbTdKLElBQUksQ0FBQyxHQUFHO1FBQ25CRSxRQUFRLENBQUNyN0osRUFBRWs3SixJQUFJLENBQUMsR0FBRztRQUNuQixJQUFJNWtGLFVBQVV6eUQsS0FBS3cwSSxRQUFRLENBQUNyNEosRUFBRWs3SixJQUFJLENBQUM7UUFDbkMsSUFBSWxhLFVBQVVoaEosRUFBRTI4SixZQUFZLENBQUMzYixPQUFPO1FBQ3BDLElBQUkzOEYsS0FBS3JrRCxFQUFFMjhKLFlBQVksQ0FBQzd1RCxRQUFRO1FBQ2hDeDNCLFFBQVEwckUsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztRQUNwQyxJQUFJM3VELFlBQVk7WUFDZGdwRSxRQUFRL2xGLFNBQVMsR0FBRyxHQUFHanlCLEdBQUdqbkIsS0FBSyxFQUFFaW5CLEdBQUdobkIsTUFBTTtRQUM1QyxPQUFPO1lBQ0xpNUMsUUFBUTJyRSxTQUFTLENBQUMsR0FBRyxHQUFHNTlGLEdBQUdqbkIsS0FBSyxFQUFFaW5CLEdBQUdobkIsTUFBTTtRQUM3QztRQUNBLElBQUl3L0gsaUJBQWlCdDRJLE1BQU1oZixJQUFJLENBQUMsNEJBQTRCekQsS0FBSztRQUNqRSxJQUFJZzdKLG1CQUFtQnY0SSxNQUFNaGYsSUFBSSxDQUFDLDhCQUE4QnpELEtBQUs7UUFDckU5QixFQUFFOHRKLGNBQWMsQ0FBQ3gzRSxTQUFTdW1GLGNBQWMsQ0FBQyxFQUFFLEVBQUVBLGNBQWMsQ0FBQyxFQUFFLEVBQUVBLGNBQWMsQ0FBQyxFQUFFLEVBQUVDO1FBQ25GeG1GLFFBQVFnbUYsUUFBUSxDQUFDLEdBQUcsR0FBR2o0RyxHQUFHam5CLEtBQUssRUFBRWluQixHQUFHaG5CLE1BQU07UUFDMUMsSUFBSTNXLE9BQU9qRCxHQUFHaUQsSUFBSTtRQUNsQjYxSSxvQkFBb0JqbUYsU0FBUztRQUM3QkEsUUFBUTJyRSxTQUFTLENBQUM1OUYsR0FBR3U0RyxJQUFJLENBQUNwb0osQ0FBQyxFQUFFNnZDLEdBQUd1NEcsSUFBSSxDQUFDMytJLENBQUMsRUFBRW9tQyxHQUFHam5CLEtBQUssR0FBR2luQixHQUFHMzlCLElBQUksR0FBRzZzRSxZQUFZbHZDLEdBQUdobkIsTUFBTSxHQUFHZ25CLEdBQUczOUIsSUFBSSxHQUFHNnNFO1FBQy9GamQsUUFBUXlyRSxTQUFTLENBQUNmLFNBQVMzOEYsR0FBR3U0RyxJQUFJLENBQUNwb0osQ0FBQyxFQUFFNnZDLEdBQUd1NEcsSUFBSSxDQUFDMytJLENBQUMsRUFBRW9tQyxHQUFHam5CLEtBQUssR0FBR2luQixHQUFHMzlCLElBQUksR0FBRzZzRSxZQUFZbHZDLEdBQUdobkIsTUFBTSxHQUFHZ25CLEdBQUczOUIsSUFBSSxHQUFHNnNFO0lBQzFHLE9BQU8sSUFBSXZ6RixFQUFFb3pGLGlCQUFpQixJQUFJLENBQUN3bkUsZUFBZTtRQUNoRCx5Q0FBeUM7UUFDekM1NkosRUFBRTI4SixZQUFZLEdBQUc7SUFDbkI7SUFDQSxJQUFJbHVELFNBQVNockYsR0FBR2dyRixNQUFNO0lBQ3RCLElBQUlzdUQsVUFBVS84SixFQUFFbXdJLFFBQVEsSUFBSW53SSxFQUFFeXBJLFNBQVMsQ0FBQzZCLFFBQVEsSUFBSXRySSxFQUFFZ3lJLFlBQVksSUFBSWh5SSxFQUFFNmpCLElBQUksQ0FBQ2txSCxZQUFZLElBQUkvdEksRUFBRXlwSSxTQUFTLENBQUM0QixZQUFZLElBQUlyckksRUFBRXlqQixFQUFFLENBQUNtL0IsUUFBUTtJQUN0SSxJQUFJbzZHLFlBQVloOUosRUFBRW16RixtQkFBbUIsSUFBSTRwRTtJQUN6QyxJQUFJRSxjQUFjLEVBQUU7SUFDcEJBLFdBQVcsQ0FBQ2o5SixFQUFFazdKLElBQUksQ0FBQyxHQUFHLENBQUNHLFFBQVEsQ0FBQ3I3SixFQUFFazdKLElBQUksQ0FBQyxJQUFJN25FLGNBQWMsQ0FBQ3J6RixFQUFFKzVJLG9CQUFvQixDQUFDLzVJLEVBQUVrN0osSUFBSSxDQUFDLElBQUlsN0osRUFBRTY3SixrQkFBa0I7SUFDaEgsSUFBSW9CLFdBQVcsQ0FBQ2o5SixFQUFFazdKLElBQUksQ0FBQyxFQUFFO1FBQ3ZCbDdKLEVBQUUrNUksb0JBQW9CLENBQUMvNUksRUFBRWs3SixJQUFJLENBQUMsR0FBRztJQUNuQztJQUNBK0IsV0FBVyxDQUFDajlKLEVBQUVtN0osSUFBSSxDQUFDLEdBQUcsQ0FBQ0UsUUFBUSxDQUFDcjdKLEVBQUVtN0osSUFBSSxDQUFDLElBQUk5bkUsY0FBYyxDQUFDcnpGLEVBQUUrNUksb0JBQW9CLENBQUMvNUksRUFBRW03SixJQUFJLENBQUMsSUFBSW43SixFQUFFNjdKLGtCQUFrQjtJQUNoSCxJQUFJb0IsV0FBVyxDQUFDajlKLEVBQUVtN0osSUFBSSxDQUFDLEVBQUU7UUFDdkJuN0osRUFBRSs1SSxvQkFBb0IsQ0FBQy81SSxFQUFFbTdKLElBQUksQ0FBQyxHQUFHO0lBQ25DO0lBQ0EsSUFBSUUsUUFBUSxDQUFDcjdKLEVBQUVrN0osSUFBSSxDQUFDLElBQUlILGlCQUFpQksscUJBQXFCNkIsV0FBVyxDQUFDajlKLEVBQUVrN0osSUFBSSxDQUFDLEVBQUU7UUFDakYsSUFBSWdDLFlBQVk3cEUsY0FBYyxDQUFDNHBFLFdBQVcsQ0FBQ2o5SixFQUFFazdKLElBQUksQ0FBQyxJQUFJbEIsY0FBYztRQUNwRSxJQUFJMWpGLFVBQVVza0YsaUJBQWtCc0MsQ0FBQUEsWUFBWWw5SixFQUFFNmpCLElBQUksQ0FBQzY0SSxjQUFjLENBQUMxOEosRUFBRWs2SixzQkFBc0IsQ0FBQyxHQUFHcjJJLEtBQUt3MEksUUFBUSxDQUFDcjRKLEVBQUVrN0osSUFBSSxDQUFDO1FBQ25ILElBQUk1NEksUUFBUSt3RSxjQUFjLENBQUM2cEUsWUFBWSxlQUFlajZKO1FBQ3REczVKLG9CQUFvQmptRixTQUFTaDBEO1FBQzdCLElBQUkwNkksV0FBVztZQUNiaDlKLEVBQUUwcUosZUFBZSxDQUFDcDBFLFNBQVMvb0QsS0FBS3UyRyxPQUFPLEVBQUV2d0MsWUFBWWtiO1FBQ3ZELE9BQU87WUFDTHp1RyxFQUFFMnFKLG1CQUFtQixDQUFDcjBFLFNBQVMvb0QsS0FBS3UyRyxPQUFPLEVBQUV2d0MsWUFBWWtiO1FBQzNEO1FBQ0EsSUFBSXp1RyxFQUFFMnpGLEtBQUssRUFBRTtZQUNYM3pGLEVBQUVtOUosZUFBZSxDQUFDN21GLFNBQVMvb0QsS0FBS3UyRyxPQUFPO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDaTNCLGlCQUFpQixDQUFDMW5FLFlBQVk7WUFDakNnb0UsUUFBUSxDQUFDcjdKLEVBQUVrN0osSUFBSSxDQUFDLEdBQUc7UUFDckI7SUFDRjtJQUNBLElBQUksQ0FBQ0UscUJBQXNCQyxDQUFBQSxRQUFRLENBQUNyN0osRUFBRW03SixJQUFJLENBQUMsSUFBSUosaUJBQWlCa0MsV0FBVyxDQUFDajlKLEVBQUVtN0osSUFBSSxDQUFDLEdBQUc7UUFDcEYsSUFBSStCLFlBQVk3cEUsY0FBYyxDQUFDNHBFLFdBQVcsQ0FBQ2o5SixFQUFFbTdKLElBQUksQ0FBQyxJQUFJbkIsY0FBYztRQUNwRSxJQUFJMWpGLFVBQVVza0YsaUJBQWtCc0MsQ0FBQUEsWUFBWWw5SixFQUFFNmpCLElBQUksQ0FBQzY0SSxjQUFjLENBQUMxOEosRUFBRW02SixzQkFBc0IsQ0FBQyxHQUFHdDJJLEtBQUt3MEksUUFBUSxDQUFDcjRKLEVBQUVtN0osSUFBSSxDQUFDO1FBQ25Ib0Isb0JBQW9Cam1GLFNBQVMrYyxjQUFjLENBQUM2cEUsWUFBWSxlQUFlajZKO1FBQ3ZFLElBQUkrNUosV0FBVztZQUNiaDlKLEVBQUUwcUosZUFBZSxDQUFDcDBFLFNBQVMvb0QsS0FBS3MyRyxJQUFJLEVBQUV0d0MsWUFBWWtiO1FBQ3BELE9BQU87WUFDTHp1RyxFQUFFeXFKLGtCQUFrQixDQUFDbjBFLFNBQVMvb0QsS0FBS3MyRyxJQUFJLEVBQUV0d0MsWUFBWWtiO1FBQ3ZEO1FBQ0EsSUFBSXp1RyxFQUFFMnpGLEtBQUssRUFBRTtZQUNYM3pGLEVBQUVtOUosZUFBZSxDQUFDN21GLFNBQVMvb0QsS0FBS3MyRyxJQUFJO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDazNCLGlCQUFpQixDQUFDMW5FLFlBQVk7WUFDakNnb0UsUUFBUSxDQUFDcjdKLEVBQUVtN0osSUFBSSxDQUFDLEdBQUc7UUFDckI7SUFDRjtJQUNBLElBQUksQ0FBQ2lDLHNCQUFzQixDQUFDcHBKLFNBQVN1b0o7SUFFckMsMENBQTBDO0lBQzFDLElBQUlscEUsY0FBYzJtRSxjQUFjLEdBQUc7UUFDakMsSUFBSXFELFVBQVV4NUksS0FBS3cwSSxRQUFRLENBQUNyNEosRUFBRWs3SixJQUFJLENBQUM7UUFDbkMsSUFBSW9DLFVBQVV0OUosRUFBRTZqQixJQUFJLENBQUNvMkksY0FBYyxDQUFDajZKLEVBQUVrNkosc0JBQXNCLENBQUM7UUFDN0QsSUFBSXFELFVBQVUxNUksS0FBS3cwSSxRQUFRLENBQUNyNEosRUFBRW03SixJQUFJLENBQUM7UUFDbkMsSUFBSXFDLFVBQVV4OUosRUFBRTZqQixJQUFJLENBQUNvMkksY0FBYyxDQUFDajZKLEVBQUVtNkosc0JBQXNCLENBQUM7UUFDN0QsSUFBSXNELGlCQUFpQixTQUFTQSxlQUFlNW1FLEdBQUcsRUFBRTZtRSxHQUFHLEVBQUVDLFNBQVM7WUFDOUQ5bUUsSUFBSW1yRCxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1lBQ2hDLElBQUkyYixhQUFhLENBQUNsQyxzQkFBc0I7Z0JBQ3RDNWtFLElBQUlvckQsU0FBUyxDQUFDLEdBQUcsR0FBR2ppSixFQUFFbzZKLFdBQVcsRUFBRXA2SixFQUFFcTZKLFlBQVk7WUFDbkQsT0FBTztnQkFDTGdDLFFBQVF4bEUsS0FBSyxHQUFHLEdBQUc3MkYsRUFBRW82SixXQUFXLEVBQUVwNkosRUFBRXE2SixZQUFZO1lBQ2xEO1lBQ0EsSUFBSXVELE1BQU01RDtZQUNWbmpFLElBQUlrckQsU0FBUyxDQUFDMmIsS0FDZCxNQUFNO1lBQ04sR0FBRyxHQUNILFNBQVM7WUFDVDE5SixFQUFFbzZKLFdBQVcsR0FBR3dELEtBQUs1OUosRUFBRXE2SixZQUFZLEdBQUd1RCxLQUN0QyxTQUFTO1lBQ1QsR0FBRyxHQUNILE9BQU87WUFDUDU5SixFQUFFbzZKLFdBQVcsRUFBRXA2SixFQUFFcTZKLFlBQVksQ0FBQyxPQUFPOztRQUV2QztRQUNBLElBQUlnQixRQUFRLENBQUNyN0osRUFBRWs3SixJQUFJLENBQUMsSUFBSStCLFdBQVcsQ0FBQ2o5SixFQUFFazdKLElBQUksQ0FBQyxFQUFFO1lBQzNDdUMsZUFBZUosU0FBU0MsU0FBU0wsV0FBVyxDQUFDajlKLEVBQUVrN0osSUFBSSxDQUFDO1lBQ3BERyxRQUFRLENBQUNyN0osRUFBRWs3SixJQUFJLENBQUMsR0FBRztRQUNyQjtRQUNBLElBQUlHLFFBQVEsQ0FBQ3I3SixFQUFFbTdKLElBQUksQ0FBQyxJQUFJOEIsV0FBVyxDQUFDajlKLEVBQUVtN0osSUFBSSxDQUFDLEVBQUU7WUFDM0NzQyxlQUFlRixTQUFTQyxTQUFTUCxXQUFXLENBQUNqOUosRUFBRW03SixJQUFJLENBQUM7WUFDcERFLFFBQVEsQ0FBQ3I3SixFQUFFbTdKLElBQUksQ0FBQyxHQUFHO1FBQ3JCO0lBQ0Y7SUFDQW43SixFQUFFbThKLFlBQVksR0FBRzkzRztJQUNqQixJQUFJcmtELEVBQUU2N0osa0JBQWtCLEVBQUU7UUFDeEI3N0osRUFBRTY3SixrQkFBa0IsR0FBRztRQUN2Qjc3SixFQUFFNjlKLGlCQUFpQixHQUFHO1FBQ3RCNzlKLEVBQUVxekYsVUFBVSxHQUFHO0lBQ2pCO0lBQ0EsSUFBSUEsWUFBWTtRQUNkcnpGLEVBQUUyN0osaUJBQWlCLEdBQUczZ0osV0FBVztZQUMvQmhiLEVBQUUyN0osaUJBQWlCLEdBQUc7WUFDdEIzN0osRUFBRSs1SSxvQkFBb0IsQ0FBQy81SSxFQUFFazdKLElBQUksQ0FBQyxHQUFHO1lBQ2pDbDdKLEVBQUUrNUksb0JBQW9CLENBQUMvNUksRUFBRW03SixJQUFJLENBQUMsR0FBRztZQUNqQ243SixFQUFFcXpGLFVBQVUsR0FBRztZQUNmcnpGLEVBQUU2N0osa0JBQWtCLEdBQUcsQ0FBQ047WUFDeEJ2N0osRUFBRTQ3SixRQUFRLEdBQUc7WUFDYlAsUUFBUSxDQUFDcjdKLEVBQUVrN0osSUFBSSxDQUFDLEdBQUc7WUFDbkJHLFFBQVEsQ0FBQ3I3SixFQUFFbTdKLElBQUksQ0FBQyxHQUFHO1lBQ25CbjdKLEVBQUVrckksTUFBTTtRQUNWLEdBQUdrdEI7SUFDTDtJQUNBLElBQUksQ0FBQ3dDLGVBQWU7UUFDbEJuM0ksR0FBRzR5QyxJQUFJLENBQUM7SUFDVjtBQUNGO0FBQ0EsSUFBSXluRztBQUNKM0YsTUFBTWlGLHNCQUFzQixHQUFHLFNBQVVwcEosT0FBTyxFQUFFdW9KLG1CQUFtQjtJQUNuRSxJQUFJdjhKLElBQUksSUFBSTtJQUNaLElBQUl5akIsS0FBS3pqQixFQUFFeWpCLEVBQUU7SUFDYixJQUFJSSxPQUFPN2pCLEVBQUU2akIsSUFBSTtJQUNqQixJQUFJVSxRQUFRZCxHQUFHYyxLQUFLO0lBQ3BCLElBQUk2Mkksb0JBQW9CcG5KLFFBQVFvbkosaUJBQWlCO0lBQ2pELElBQUlMLGdCQUFnQi9tSixRQUFRK21KLGFBQWE7SUFDekMsSUFBSU0sV0FBV3gzSSxLQUFLeTNJLGlCQUFpQjtJQUNyQyxJQUFJVixnQkFBZ0I1bUosUUFBUTRtSixhQUFhO0lBQ3pDLElBQUk1NkosRUFBRTR6RixPQUFPLElBQUksQ0FBQ3duRSxxQkFBcUJDLFFBQVEsQ0FBQ3I3SixFQUFFKzdKLFVBQVUsQ0FBQyxJQUFJLENBQUNoQixlQUFlO1FBQy9FLElBQUl6a0YsVUFBVXNrRixpQkFBaUIvMkksS0FBS3cwSSxRQUFRLENBQUNyNEosRUFBRSs3SixVQUFVLENBQUM7UUFDMURRLG9CQUFvQmptRjtRQUNwQixJQUFJdDJFLEVBQUVpcEksU0FBUyxDQUFDLEVBQUUsSUFBSSxLQUFNanBJLENBQUFBLEVBQUV5cEksU0FBUyxDQUFDOEIsU0FBUyxJQUFJdnJJLEVBQUV3dkksU0FBUyxDQUFDakUsU0FBUyxHQUFHO1lBQzNFLElBQUk3a0gsT0FBTzFtQixFQUFFeWpCLEVBQUUsQ0FBQ2lELElBQUk7WUFDcEIsSUFBSW1sRCxjQUFjdG5ELE1BQU1oZixJQUFJLENBQUMsOEJBQThCekQsS0FBSyxHQUFHNGtCO1lBQ25FNHZELFFBQVFvMUUsU0FBUyxHQUFHNy9FO1lBQ3BCeUssUUFBUSsyRSxTQUFTLEdBQUcsVUFBVTlvSSxNQUFNaGYsSUFBSSxDQUFDLHVCQUF1QnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLHVCQUF1QnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLHVCQUF1QnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLHlCQUF5QnpELEtBQUssR0FBRztZQUNuT3cwRSxRQUFRZ21GLFFBQVEsQ0FBQ3Q4SixFQUFFaXBJLFNBQVMsQ0FBQyxFQUFFLEVBQUVqcEksRUFBRWlwSSxTQUFTLENBQUMsRUFBRSxFQUFFanBJLEVBQUVpcEksU0FBUyxDQUFDLEVBQUUsR0FBR2pwSSxFQUFFaXBJLFNBQVMsQ0FBQyxFQUFFLEVBQUVqcEksRUFBRWlwSSxTQUFTLENBQUMsRUFBRSxHQUFHanBJLEVBQUVpcEksU0FBUyxDQUFDLEVBQUU7WUFDakgsSUFBSXA5RCxjQUFjLEdBQUc7Z0JBQ25CeUssUUFBUWczRSxXQUFXLEdBQUcsVUFBVS9vSSxNQUFNaGYsSUFBSSxDQUFDLDhCQUE4QnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLDhCQUE4QnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLDhCQUE4QnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLHlCQUF5QnpELEtBQUssR0FBRztnQkFDMVB3MEUsUUFBUXluRixVQUFVLENBQUMvOUosRUFBRWlwSSxTQUFTLENBQUMsRUFBRSxFQUFFanBJLEVBQUVpcEksU0FBUyxDQUFDLEVBQUUsRUFBRWpwSSxFQUFFaXBJLFNBQVMsQ0FBQyxFQUFFLEdBQUdqcEksRUFBRWlwSSxTQUFTLENBQUMsRUFBRSxFQUFFanBJLEVBQUVpcEksU0FBUyxDQUFDLEVBQUUsR0FBR2pwSSxFQUFFaXBJLFNBQVMsQ0FBQyxFQUFFO1lBQ3JIO1FBQ0Y7UUFDQSxJQUFJcGxILEtBQUtvbkgsaUJBQWlCLElBQUksQ0FBQ2pySSxFQUFFeXBJLFNBQVMsQ0FBQzhCLFNBQVMsRUFBRTtZQUNwRCxJQUFJN2tILE9BQU8xbUIsRUFBRXlqQixFQUFFLENBQUNpRCxJQUFJO1lBQ3BCLElBQUl6SCxNQUFNNEUsS0FBS29uSCxpQkFBaUI7WUFDaEMzMEQsUUFBUSsyRSxTQUFTLEdBQUcsVUFBVTlvSSxNQUFNaGYsSUFBSSxDQUFDLG1CQUFtQnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLG1CQUFtQnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLG1CQUFtQnpELEtBQUssQ0FBQyxFQUFFLEdBQUcsTUFBTXlpQixNQUFNaGYsSUFBSSxDQUFDLHFCQUFxQnpELEtBQUssR0FBRztZQUNuTncwRSxRQUFRMHhFLFNBQVM7WUFDakIxeEUsUUFBUTgxQyxHQUFHLENBQUNudEcsSUFBSXpLLENBQUMsRUFBRXlLLElBQUloQixDQUFDLEVBQUVzRyxNQUFNaGYsSUFBSSxDQUFDLGtCQUFrQjhpRSxPQUFPLEdBQUczaEQsTUFBTSxHQUFHLElBQUkxaEIsS0FBS3NaLEVBQUU7WUFDckZnNEQsUUFBUSt1QixJQUFJO1FBQ2Q7UUFDQSxJQUFJbXlDLGVBQWV4M0ksRUFBRTQzSSxjQUFjO1FBQ25DLElBQUk1M0ksRUFBRTR6RixPQUFPLElBQUk0akQsY0FBYztZQUM3QkEsZUFBZXh5SSxLQUFLK0UsS0FBSyxDQUFDeXRJO1lBQzFCLElBQUl3bUIsTUFBTWg1SixLQUFLK0UsS0FBSyxDQUFDLE9BQU95dEk7WUFDNUIsSUFBSTkxRSxPQUFPLGVBQWU4MUUsZUFBZSxXQUFXd21CLE1BQU07WUFDMUQxbkYsUUFBUTByRSxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO1lBQ3BDMXJFLFFBQVErMkUsU0FBUyxHQUFHO1lBQ3BCLzJFLFFBQVFnM0UsV0FBVyxHQUFHO1lBQ3RCLHlCQUF5QjtZQUN6QmgzRSxRQUFRaXJELElBQUksR0FBRztZQUNmLElBQUksQ0FBQ3U4QixXQUFXO2dCQUNkLElBQUk3Z0YsT0FBTzNHLFFBQVFtckQsV0FBVyxDQUFDLy9EO2dCQUMvQm84RixZQUFZN2dGLEtBQUtnaEYsdUJBQXVCO1lBQzFDO1lBQ0EzbkYsUUFBUW85RSxRQUFRLENBQUNoeUYsTUFBTSxHQUFHbzhGO1lBQzFCLElBQUlJLFNBQVM7WUFDYjVuRixRQUFReW5GLFVBQVUsQ0FBQyxHQUFHRCxZQUFZLElBQUksS0FBSztZQUMzQ3huRixRQUFRZ21GLFFBQVEsQ0FBQyxHQUFHd0IsWUFBWSxJQUFJLE1BQU05NEosS0FBSytVLEdBQUcsQ0FBQ2lrSixNQUFNRSxRQUFRLElBQUk7UUFDdkU7UUFDQSxJQUFJLENBQUNuRCxlQUFlO1lBQ2xCTSxRQUFRLENBQUNyN0osRUFBRSs3SixVQUFVLENBQUMsR0FBRztRQUMzQjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBRUQsU0FBU29DLGNBQWNDLEVBQUUsRUFBRXJwSixJQUFJLEVBQUUrTyxNQUFNO0lBQ3JDLElBQUl1NkksU0FBU0QsR0FBR0UsWUFBWSxDQUFDdnBKO0lBQzdCcXBKLEdBQUdHLFlBQVksQ0FBQ0YsUUFBUXY2STtJQUN4QnM2SSxHQUFHRCxhQUFhLENBQUNFO0lBQ2pCLElBQUksQ0FBQ0QsR0FBR0ksa0JBQWtCLENBQUNILFFBQVFELEdBQUdLLGNBQWMsR0FBRztRQUNyRCxNQUFNLElBQUl2cUosTUFBTWtxSixHQUFHTSxnQkFBZ0IsQ0FBQ0w7SUFDdEM7SUFDQSw0Q0FBNEM7SUFDNUMsT0FBT0E7QUFDVDtBQUNBLFNBQVNNLGNBQWNQLEVBQUUsRUFBRVEsWUFBWSxFQUFFQyxlQUFlO0lBQ3RELElBQUlDLGVBQWVYLGNBQWNDLElBQUlBLEdBQUdXLGFBQWEsRUFBRUg7SUFDdkQsSUFBSUksaUJBQWlCYixjQUFjQyxJQUFJQSxHQUFHYSxlQUFlLEVBQUVKO0lBQzNELElBQUlLLFVBQVVkLEdBQUdPLGFBQWE7SUFDOUJQLEdBQUdlLFlBQVksQ0FBQ0QsU0FBU0o7SUFDekJWLEdBQUdlLFlBQVksQ0FBQ0QsU0FBU0Y7SUFDekJaLEdBQUdnQixXQUFXLENBQUNGO0lBQ2YsSUFBSSxDQUFDZCxHQUFHaUIsbUJBQW1CLENBQUNILFNBQVNkLEdBQUdrQixXQUFXLEdBQUc7UUFDcEQsTUFBTSxJQUFJcHJKLE1BQU07SUFDbEI7SUFDQSxPQUFPZ3JKO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSyxvQkFBb0J2L0osQ0FBQyxFQUFFbzlCLEtBQUssRUFBRUMsTUFBTTtJQUMzQyxJQUFJQSxXQUFXcDZCLFdBQVc7UUFDeEJvNkIsU0FBU0Q7SUFDWDtJQUNBLElBQUkwakcsU0FBUzlnSSxFQUFFaWpKLG1CQUFtQixDQUFDN2xILE9BQU9DO0lBQzFDLElBQUk0dUYsTUFBTTZVLE9BQU94cUQsT0FBTyxHQUFHd3FELE9BQU9LLFVBQVUsQ0FBQztJQUM3Q0wsT0FBT3grRyxLQUFLLEdBQUc7UUFDYixPQUFPMnBHLElBQUlnMkIsU0FBUyxDQUFDLEdBQUcsR0FBR25oQixPQUFPMWpHLEtBQUssRUFBRTBqRyxPQUFPempHLE1BQU07SUFDeEQ7SUFDQXlqRyxPQUFPeCtHLEtBQUs7SUFDWixPQUFPdytHO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELFNBQVMwK0Isb0JBQW9CeC9KLENBQUM7SUFDNUIsSUFBSXV6RixhQUFhdnpGLEVBQUV1ekYsVUFBVTtJQUM3QixJQUFJN3NFLE9BQU8xbUIsRUFBRXlqQixFQUFFLENBQUNpRCxJQUFJO0lBQ3BCLElBQUlELE1BQU16bUIsRUFBRXlqQixFQUFFLENBQUNnRCxHQUFHO0lBQ2xCLE9BQU87UUFDTEMsTUFBTUEsT0FBTzZzRTtRQUNiOXNFLEtBQUs7WUFDSGpTLEdBQUdpUyxJQUFJalMsQ0FBQyxHQUFHKytFO1lBQ1h0MUUsR0FBR3dJLElBQUl4SSxDQUFDLEdBQUdzMUU7UUFDYjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVNrc0UsaUJBQWlCei9KLENBQUM7SUFDekIsSUFBSXV6RixhQUFhdnpGLEVBQUV1ekYsVUFBVTtJQUM3QixJQUFJN3NFLE9BQU8xbUIsRUFBRXlqQixFQUFFLENBQUNpRCxJQUFJO0lBQ3BCLE9BQU9BLE9BQU82c0U7QUFDaEI7QUFDQSxTQUFTLzZELHdCQUF3Qng0QixDQUFDLEVBQUV5bUIsR0FBRyxFQUFFQyxJQUFJLEVBQUVsUyxDQUFDLEVBQUV5SixDQUFDO0lBQ2pELElBQUl3M0YsS0FBS2poRyxJQUFJa1MsT0FBT0QsSUFBSWpTLENBQUM7SUFDekIsSUFBSWtoRyxLQUFLejNGLElBQUl5SSxPQUFPRCxJQUFJeEksQ0FBQztJQUN6QnkzRixLQUFLMXdHLEtBQUsrRSxLQUFLLENBQUMvSixFQUFFcTZKLFlBQVksR0FBRzNrRCxLQUFLLG1CQUFtQjtJQUN6RCxPQUFPO1FBQUNEO1FBQUlDO0tBQUc7QUFDakI7QUFDQSxTQUFTZ3FELGNBQWN0MkksSUFBSTtJQUN6Qiw0RUFBNEU7SUFDNUUsc0VBQXNFO0lBQ3RFLElBQUlBLEtBQUtnL0MsTUFBTSxDQUFDLG1CQUFtQnRtRSxLQUFLLEtBQUssU0FBUyxPQUFPO0lBQzdELElBQUlzbkIsS0FBS2cvQyxNQUFNLENBQUMsb0JBQW9COEMsUUFBUSxLQUFLLFFBQVEsT0FBTztJQUNoRSxJQUFJOWhELEtBQUtnL0MsTUFBTSxDQUFDLGdCQUFnQnRtRSxLQUFLLEtBQUssR0FBRyxPQUFPO0lBQ3BELElBQUlzbkIsS0FBS2cvQyxNQUFNLENBQUMsa0JBQWtCdG1FLEtBQUssS0FBSyxHQUFHLE9BQU87SUFDdEQseUNBQXlDO0lBQ3pDLElBQUlzbkIsS0FBS2cvQyxNQUFNLENBQUMsZ0JBQWdCdG1FLEtBQUssS0FBSyxTQUFTLE9BQU87SUFDMUQsMEVBQTBFO0lBQzFFLE9BQU87QUFDVDtBQUNBLFNBQVM2OUosV0FBV2xpRSxFQUFFLEVBQUVDLEVBQUU7SUFDeEIsSUFBSUQsR0FBR3Y5RixNQUFNLEtBQUt3OUYsR0FBR3g5RixNQUFNLEVBQUU7UUFDM0IsT0FBTztJQUNUO0lBQ0EsSUFBSyxJQUFJdUMsSUFBSSxHQUFHQSxJQUFJZzdGLEdBQUd2OUYsTUFBTSxFQUFFdUMsSUFBSztRQUNsQyxJQUFJZzdGLEVBQUUsQ0FBQ2g3RixFQUFFLEtBQUtpN0YsRUFBRSxDQUFDajdGLEVBQUUsRUFBRTtZQUNuQixPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNtOUosYUFBYXAxSixLQUFLLEVBQUVrakUsT0FBTyxFQUFFbXlGLFFBQVE7SUFDNUMsSUFBSTcvSixJQUFJd0ssS0FBSyxDQUFDLEVBQUUsR0FBRztJQUNuQixJQUFJdEIsSUFBSXNCLEtBQUssQ0FBQyxFQUFFLEdBQUc7SUFDbkIsSUFBSWpDLElBQUlpQyxLQUFLLENBQUMsRUFBRSxHQUFHO0lBQ25CLElBQUl2SyxJQUFJeXRFO0lBQ1IsSUFBSTlzRCxNQUFNaS9JLFlBQVksSUFBSXgvSixNQUFNO0lBQ2hDdWdCLEdBQUcsQ0FBQyxFQUFFLEdBQUc1Z0IsSUFBSUM7SUFDYjJnQixHQUFHLENBQUMsRUFBRSxHQUFHMVgsSUFBSWpKO0lBQ2IyZ0IsR0FBRyxDQUFDLEVBQUUsR0FBR3JZLElBQUl0STtJQUNiMmdCLEdBQUcsQ0FBQyxFQUFFLEdBQUczZ0I7SUFDVCxPQUFPMmdCO0FBQ1Q7QUFDQSxTQUFTay9JLFlBQVkxcEosS0FBSyxFQUFFeXBKLFFBQVE7SUFDbEMsSUFBSWovSSxNQUFNaS9JLFlBQVksSUFBSXgvSixNQUFNO0lBQ2hDdWdCLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQ3hLLFNBQVMsSUFBSSxJQUFHLElBQUs7SUFDL0J3SyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUN4SyxTQUFTLElBQUksSUFBRyxJQUFLO0lBQy9Cd0ssR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDeEssU0FBUyxLQUFLLElBQUcsSUFBSztJQUNoQ3dLLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQ3hLLFNBQVMsS0FBSyxJQUFHLElBQUs7SUFDaEMsT0FBT3dLO0FBQ1Q7QUFDQSxTQUFTbS9JLFlBQVlDLElBQUk7SUFDdkIsT0FBT0EsSUFBSSxDQUFDLEVBQUUsR0FBSUEsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsSUFBSSxLQUFNQSxDQUFBQSxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUMsSUFBTUEsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFDO0FBQ25FO0FBQ0EsU0FBU0MsY0FBYzdCLEVBQUUsRUFBRThCLE9BQU87SUFDaEMsSUFBSWxmLFVBQVVvZCxHQUFHNkIsYUFBYTtJQUM5QmpmLFFBQVFtZixNQUFNLEdBQUcsU0FBVUMsZUFBZTtRQUN4Q2hDLEdBQUdpQyxXQUFXLENBQUNqQyxHQUFHa0MsVUFBVSxFQUFFdGY7UUFDOUJvZCxHQUFHbUMsYUFBYSxDQUFDbkMsR0FBR2tDLFVBQVUsRUFBRWxDLEdBQUdvQyxjQUFjLEVBQUVwQyxHQUFHcUMsYUFBYTtRQUNuRXJDLEdBQUdtQyxhQUFhLENBQUNuQyxHQUFHa0MsVUFBVSxFQUFFbEMsR0FBR3NDLGNBQWMsRUFBRXRDLEdBQUdxQyxhQUFhO1FBQ25FckMsR0FBR21DLGFBQWEsQ0FBQ25DLEdBQUdrQyxVQUFVLEVBQUVsQyxHQUFHdUMsa0JBQWtCLEVBQUV2QyxHQUFHd0MsTUFBTTtRQUNoRXhDLEdBQUdtQyxhQUFhLENBQUNuQyxHQUFHa0MsVUFBVSxFQUFFbEMsR0FBR3lDLGtCQUFrQixFQUFFekMsR0FBRzBDLHFCQUFxQjtRQUUvRSw4RUFBOEU7UUFDOUUxQyxHQUFHMkMsV0FBVyxDQUFDM0MsR0FBRzRDLDhCQUE4QixFQUFFO1FBQ2xENUMsR0FBRzZDLFVBQVUsQ0FBQzdDLEdBQUdrQyxVQUFVLEVBQUUsR0FBR2xDLEdBQUc4QyxJQUFJLEVBQUU5QyxHQUFHOEMsSUFBSSxFQUFFOUMsR0FBRytDLGFBQWEsRUFBRWY7UUFDcEVoQyxHQUFHZ0QsY0FBYyxDQUFDaEQsR0FBR2tDLFVBQVU7UUFDL0JsQyxHQUFHaUMsV0FBVyxDQUFDakMsR0FBR2tDLFVBQVUsRUFBRTtJQUNoQztJQUNBdGYsUUFBUXFnQixhQUFhLEdBQUc7UUFDdEJqRCxHQUFHaUQsYUFBYSxDQUFDcmdCO0lBQ25CO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVNzZ0IsWUFBWWxELEVBQUUsRUFBRW1ELFFBQVE7SUFDL0IsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztnQkFBQztnQkFBR25ELEdBQUdvRCxLQUFLO2dCQUFFO2FBQUU7UUFDekIsS0FBSztZQUNILE9BQU87Z0JBQUM7Z0JBQUdwRCxHQUFHb0QsS0FBSztnQkFBRTthQUFFO1FBQ3pCLEtBQUs7WUFDSCxPQUFPO2dCQUFDO2dCQUFHcEQsR0FBR29ELEtBQUs7Z0JBQUU7YUFBRTtRQUN6QixLQUFLO1lBQ0gsT0FBTztnQkFBQztnQkFBR3BELEdBQUdvRCxLQUFLO2dCQUFFO2FBQUU7UUFDekIsS0FBSztZQUNILE9BQU87Z0JBQUM7Z0JBQUdwRCxHQUFHcUQsR0FBRztnQkFBRTthQUFFO1FBQ3ZCLEtBQUs7WUFDSCxPQUFPO2dCQUFDO2dCQUFHckQsR0FBR3FELEdBQUc7Z0JBQUU7YUFBRTtJQUN6QjtBQUNGO0FBQ0EsU0FBU0MsaUJBQWlCdEQsRUFBRSxFQUFFdUQsTUFBTSxFQUFFQyxVQUFVO0lBQzlDLE9BQVFEO1FBQ04sS0FBS3ZELEdBQUdvRCxLQUFLO1lBQ1gsT0FBTyxJQUFJNTFFLGFBQWFnMkU7UUFDMUIsS0FBS3hELEdBQUdxRCxHQUFHO1lBQ1QsT0FBTyxJQUFJSSxXQUFXRDtJQUMxQjtBQUNGO0FBQ0EsU0FBU0UscUJBQXFCMUQsRUFBRSxFQUFFdUQsTUFBTSxFQUFFbjlKLEtBQUssRUFBRXU5SixNQUFNLEVBQUVoL0ksSUFBSSxFQUFFdGdCLENBQUM7SUFDOUQsT0FBUWsvSjtRQUNOLEtBQUt2RCxHQUFHb0QsS0FBSztZQUNYLE9BQU8sSUFBSTUxRSxhQUFhcG5GLE1BQU0yN0osTUFBTSxFQUFFMTlKLElBQUlzL0osUUFBUWgvSTtRQUNwRCxLQUFLcTdJLEdBQUdxRCxHQUFHO1lBQ1QsT0FBTyxJQUFJSSxXQUFXcjlKLE1BQU0yN0osTUFBTSxFQUFFMTlKLElBQUlzL0osUUFBUWgvSTtJQUNwRDtBQUNGO0FBRUEsc0NBQXNDLEdBQ3RDLFNBQVNpL0ksdUJBQXVCNUQsRUFBRSxFQUFFcnBKLElBQUksRUFBRWt0SixZQUFZLEVBQUVDLFNBQVM7SUFDL0QsSUFBSUMsZUFBZWIsWUFBWWxELElBQUlycEosT0FDakNxdEosZ0JBQWdCdi9KLGVBQWVzL0osY0FBYyxJQUM3Q3AvSSxPQUFPcS9JLGFBQWEsQ0FBQyxFQUFFLEVBQ3ZCVCxTQUFTUyxhQUFhLENBQUMsRUFBRTtJQUMzQixJQUFJditJLE9BQU82OUksaUJBQWlCdEQsSUFBSXVELFFBQVFPO0lBQ3hDLElBQUkvQixTQUFTL0IsR0FBR2lFLFlBQVk7SUFDNUJqRSxHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRXBDO0lBQy9CL0IsR0FBR29FLFVBQVUsQ0FBQ3BFLEdBQUdtRSxZQUFZLEVBQUUxK0ksTUFBTXU2SSxHQUFHcUUsV0FBVztJQUNuRCxJQUFJZCxXQUFXdkQsR0FBR29ELEtBQUssRUFBRTtRQUN2QnBELEdBQUdzRSxtQkFBbUIsQ0FBQ1QsY0FBY2wvSSxNQUFNNCtJLFFBQVEsT0FBTyxHQUFHO0lBQy9ELE9BQU8sSUFBSUEsV0FBV3ZELEdBQUdxRCxHQUFHLEVBQUU7UUFDNUJyRCxHQUFHdUUsb0JBQW9CLENBQUNWLGNBQWNsL0ksTUFBTTQrSSxRQUFRLEdBQUc7SUFDekQ7SUFDQXZELEdBQUd3RSx1QkFBdUIsQ0FBQ1g7SUFDM0I3RCxHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRTtJQUMvQixPQUFPcEM7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTMEMsd0JBQXdCekUsRUFBRSxFQUFFMEUsU0FBUyxFQUFFL3RKLElBQUksRUFBRWt0SixZQUFZO0lBQ2hFLElBQUljLGdCQUFnQnpCLFlBQVlsRCxJQUFJcnBKLE9BQ2xDaXVKLGdCQUFnQm5nSyxlQUFla2dLLGVBQWUsSUFDOUNoZ0osT0FBT2lnSixhQUFhLENBQUMsRUFBRSxFQUN2QnJCLFNBQVNxQixhQUFhLENBQUMsRUFBRSxFQUN6QkMsUUFBUUQsYUFBYSxDQUFDLEVBQUU7SUFDMUIsSUFBSWQsWUFBWVIsaUJBQWlCdEQsSUFBSXVELFFBQVFtQixZQUFZLy9JO0lBQ3pELElBQUlnL0ksU0FBU2gvSSxPQUFPa2dKO0lBQ3BCLElBQUk5QyxTQUFTL0IsR0FBR2lFLFlBQVk7SUFDNUJqRSxHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRXBDO0lBQy9CL0IsR0FBR29FLFVBQVUsQ0FBQ3BFLEdBQUdtRSxZQUFZLEVBQUVPLFlBQVlmLFFBQVEzRCxHQUFHOEUsWUFBWTtJQUNsRTlFLEdBQUd3RSx1QkFBdUIsQ0FBQ1g7SUFDM0IsSUFBSU4sV0FBV3ZELEdBQUdvRCxLQUFLLEVBQUU7UUFDdkJwRCxHQUFHc0UsbUJBQW1CLENBQUNULGNBQWNsL0ksTUFBTTQrSSxRQUFRLE9BQU9JLFFBQVE7SUFDcEUsT0FBTyxJQUFJSixXQUFXdkQsR0FBR3FELEdBQUcsRUFBRTtRQUM1QnJELEdBQUd1RSxvQkFBb0IsQ0FBQ1YsY0FBY2wvSSxNQUFNNCtJLFFBQVFJLFFBQVE7SUFDOUQ7SUFDQTNELEdBQUcrRSxtQkFBbUIsQ0FBQ2xCLGNBQWM7SUFDckM3RCxHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRTtJQUUvQiwrREFBK0Q7SUFDL0QsSUFBSWEsUUFBUSxJQUFJL2lLLE1BQU15aUs7SUFDdEIsSUFBSyxJQUFJcmdLLElBQUksR0FBR0EsSUFBSXFnSyxXQUFXcmdLLElBQUs7UUFDbEMyZ0ssS0FBSyxDQUFDM2dLLEVBQUUsR0FBR3EvSixxQkFBcUIxRCxJQUFJdUQsUUFBUU8sV0FBV0gsUUFBUWgvSSxNQUFNdGdCO0lBQ3ZFO0lBQ0EwOUosT0FBTytCLFNBQVMsR0FBR0E7SUFDbkIvQixPQUFPNEIsTUFBTSxHQUFHQTtJQUNoQjVCLE9BQU9wOUksSUFBSSxHQUFHQTtJQUNkbzlJLE9BQU9rRCxPQUFPLEdBQUcsU0FBVTVnSyxDQUFDO1FBQzFCLE9BQU8yZ0ssS0FBSyxDQUFDM2dLLEVBQUU7SUFDakI7SUFDQTA5SixPQUFPbUQsUUFBUSxHQUFHLFNBQVU3Z0ssQ0FBQyxFQUFFK1IsQ0FBQyxFQUFFeUosQ0FBQztRQUNqQyxJQUFJc2xKLE9BQU9ILEtBQUssQ0FBQzNnSyxFQUFFO1FBQ25COGdLLElBQUksQ0FBQyxFQUFFLEdBQUcvdUo7UUFDVit1SixJQUFJLENBQUMsRUFBRSxHQUFHdGxKO0lBQ1o7SUFDQWtpSixPQUFPcUQsYUFBYSxHQUFHLFNBQVVyb0QsS0FBSztRQUNwQ2lqRCxHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRXBDO1FBQy9CLElBQUlobEQsT0FBTztZQUNUaWpELEdBQUdvRixhQUFhLENBQUNwRixHQUFHbUUsWUFBWSxFQUFFLEdBQUdMLFdBQVcsR0FBRy9tRCxRQUFRcDRGO1FBQzdELE9BQU87WUFDTHE3SSxHQUFHb0YsYUFBYSxDQUFDcEYsR0FBR21FLFlBQVksRUFBRSxHQUFHTDtRQUN2QztJQUNGO0lBQ0EsT0FBTy9CO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTc0QsaUNBQWlDckYsRUFBRSxFQUFFMEUsU0FBUyxFQUFFYixZQUFZO0lBQ25FLElBQUl5QixhQUFhLEdBQUcsYUFBYTtJQUNqQyxJQUFJQyxhQUFhLElBQUkvM0UsYUFBYWszRSxZQUFZWTtJQUU5QyxvRUFBb0U7SUFDcEUsSUFBSUUsY0FBYyxJQUFJdmpLLE1BQU15aUs7SUFDNUIsSUFBSyxJQUFJcmdLLElBQUksR0FBR0EsSUFBSXFnSyxXQUFXcmdLLElBQUs7UUFDbEMsSUFBSW9oSyxhQUFhcGhLLElBQUlpaEssYUFBYSxHQUFHLG9CQUFvQjtRQUN6REUsV0FBVyxDQUFDbmhLLEVBQUUsR0FBRyxJQUFJbXBGLGFBQWErM0UsV0FBV3hELE1BQU0sRUFBRTBELFlBQVlILGFBQWEsYUFBYTtJQUM3RjtJQUNBLElBQUl2RCxTQUFTL0IsR0FBR2lFLFlBQVk7SUFDNUJqRSxHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRXBDO0lBQy9CL0IsR0FBR29FLFVBQVUsQ0FBQ3BFLEdBQUdtRSxZQUFZLEVBQUVvQixXQUFXRyxVQUFVLEVBQUUxRixHQUFHOEUsWUFBWTtJQUVyRSwwREFBMEQ7SUFDMUQsSUFBSyxJQUFJLzVJLEtBQUssR0FBR0EsS0FBSyxHQUFHQSxLQUFNO1FBQzdCLElBQUk0NkksTUFBTTlCLGVBQWU5NEk7UUFDekJpMUksR0FBR3dFLHVCQUF1QixDQUFDbUI7UUFDM0IzRixHQUFHc0UsbUJBQW1CLENBQUNxQixLQUFLLEdBQUczRixHQUFHb0QsS0FBSyxFQUFFLE9BQU8sSUFBSSxJQUFJcjRJLEtBQUs7UUFDN0RpMUksR0FBRytFLG1CQUFtQixDQUFDWSxLQUFLO0lBQzlCO0lBQ0EzRixHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRTtJQUMvQnBDLE9BQU82RCxhQUFhLEdBQUcsU0FBVXZoSyxDQUFDO1FBQ2hDLE9BQU9taEssV0FBVyxDQUFDbmhLLEVBQUU7SUFDdkI7SUFFQSw4RkFBOEY7SUFDOUYwOUosT0FBTzhELE9BQU8sR0FBRyxTQUFVbjVILE1BQU0sRUFBRXJvQyxDQUFDO1FBQ2xDbWhLLFdBQVcsQ0FBQ25oSyxFQUFFLENBQUMwZixHQUFHLENBQUMyb0IsUUFBUTtJQUM3QjtJQUNBcTFILE9BQU9xRCxhQUFhLEdBQUc7UUFDckJwRixHQUFHa0UsVUFBVSxDQUFDbEUsR0FBR21FLFlBQVksRUFBRXBDO1FBQy9CL0IsR0FBR29GLGFBQWEsQ0FBQ3BGLEdBQUdtRSxZQUFZLEVBQUUsR0FBR29CO0lBQ3ZDO0lBQ0EsT0FBT3hEO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTK0QseUJBQXlCOUYsRUFBRTtJQUNsQyxrQ0FBa0M7SUFDbEMsSUFBSStGLEtBQUsvRixHQUFHZ0csaUJBQWlCO0lBQzdCaEcsR0FBR2lHLGVBQWUsQ0FBQ2pHLEdBQUdrRyxXQUFXLEVBQUVIO0lBRW5DLGdDQUFnQztJQUNoQyxJQUFJSSxnQkFBZ0JuRyxHQUFHNkIsYUFBYTtJQUNwQzdCLEdBQUdpQyxXQUFXLENBQUNqQyxHQUFHa0MsVUFBVSxFQUFFaUU7SUFDOUJuRyxHQUFHbUMsYUFBYSxDQUFDbkMsR0FBR2tDLFVBQVUsRUFBRWxDLEdBQUd5QyxrQkFBa0IsRUFBRXpDLEdBQUd3QyxNQUFNO0lBQ2hFeEMsR0FBR21DLGFBQWEsQ0FBQ25DLEdBQUdrQyxVQUFVLEVBQUVsQyxHQUFHb0MsY0FBYyxFQUFFcEMsR0FBR3FDLGFBQWE7SUFDbkVyQyxHQUFHbUMsYUFBYSxDQUFDbkMsR0FBR2tDLFVBQVUsRUFBRWxDLEdBQUdzQyxjQUFjLEVBQUV0QyxHQUFHcUMsYUFBYTtJQUVuRSxtREFBbUQ7SUFDbkRyQyxHQUFHb0csb0JBQW9CLENBQUNwRyxHQUFHa0csV0FBVyxFQUFFbEcsR0FBR3FHLGlCQUFpQixFQUFFckcsR0FBR2tDLFVBQVUsRUFBRWlFLGVBQWU7SUFDNUZuRyxHQUFHaUcsZUFBZSxDQUFDakcsR0FBR2tHLFdBQVcsRUFBRTtJQUNuQ0gsR0FBR08sNkJBQTZCLEdBQUcsU0FBVXRuSSxLQUFLLEVBQUVDLE1BQU07UUFDeEQrZ0ksR0FBR2lDLFdBQVcsQ0FBQ2pDLEdBQUdrQyxVQUFVLEVBQUVpRTtRQUM5Qm5HLEdBQUc2QyxVQUFVLENBQUM3QyxHQUFHa0MsVUFBVSxFQUFFLEdBQUdsQyxHQUFHOEMsSUFBSSxFQUFFOWpJLE9BQU9DLFFBQVEsR0FBRytnSSxHQUFHOEMsSUFBSSxFQUFFOUMsR0FBRytDLGFBQWEsRUFBRTtJQUN4RjtJQUNBLE9BQU9nRDtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsMEJBQTBCO0FBQzFCLElBQUlRLGFBQWEsT0FBTy80RSxpQkFBaUIsY0FBY0EsZUFBZXZyRjtBQUN0RSxJQUFJLENBQUMyRSxLQUFLODJCLEtBQUssRUFBRTkyQixLQUFLODJCLEtBQUssR0FBRztJQUM1QixJQUFJN2QsSUFBSSxHQUNKeGIsSUFBSStELFVBQVV0RyxNQUFNO0lBRXhCLE1BQU91QyxJQUFLO1FBQ1Z3YixLQUFLelgsU0FBUyxDQUFDL0QsRUFBRSxHQUFHK0QsU0FBUyxDQUFDL0QsRUFBRTtJQUNsQztJQUVBLE9BQU91QyxLQUFLMndCLElBQUksQ0FBQzFYO0FBQ25CO0FBRUE7OztDQUdDLEdBRUQ7Ozs7Q0FJQyxHQUVELFNBQVM2RTtJQUNQLElBQUkrWixNQUFNLElBQUk4bkksV0FBVztJQUV6QixJQUFJQSxjQUFjLzRFLGNBQWM7UUFDOUIvdUQsR0FBRyxDQUFDLEVBQUUsR0FBRztRQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO1FBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7UUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRztRQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO1FBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDWDtJQUVBQSxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNULE9BQU9BO0FBQ1Q7QUFDQTs7Ozs7Q0FLQyxHQUVELFNBQVMyVixTQUFTM1YsR0FBRztJQUNuQkEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVCxPQUFPQTtBQUNUO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUVELFNBQVMrbkksU0FBUy9uSSxHQUFHLEVBQUU1OEIsQ0FBQyxFQUFFc0ksQ0FBQztJQUN6QixJQUFJczhKLE1BQU01a0ssQ0FBQyxDQUFDLEVBQUUsRUFDVjZrSyxNQUFNN2tLLENBQUMsQ0FBQyxFQUFFLEVBQ1Y4a0ssTUFBTTlrSyxDQUFDLENBQUMsRUFBRTtJQUNkLElBQUkra0ssTUFBTS9rSyxDQUFDLENBQUMsRUFBRSxFQUNWZ2xLLE1BQU1obEssQ0FBQyxDQUFDLEVBQUUsRUFDVmlsSyxNQUFNamxLLENBQUMsQ0FBQyxFQUFFO0lBQ2QsSUFBSWtsSyxNQUFNbGxLLENBQUMsQ0FBQyxFQUFFLEVBQ1ZtbEssTUFBTW5sSyxDQUFDLENBQUMsRUFBRSxFQUNWb2xLLE1BQU1wbEssQ0FBQyxDQUFDLEVBQUU7SUFDZCxJQUFJcWxLLE1BQU0vOEosQ0FBQyxDQUFDLEVBQUUsRUFDVmc5SixNQUFNaDlKLENBQUMsQ0FBQyxFQUFFLEVBQ1ZpOUosTUFBTWo5SixDQUFDLENBQUMsRUFBRTtJQUNkLElBQUlrOUosTUFBTWw5SixDQUFDLENBQUMsRUFBRSxFQUNWbTlKLE1BQU1uOUosQ0FBQyxDQUFDLEVBQUUsRUFDVm85SixNQUFNcDlKLENBQUMsQ0FBQyxFQUFFO0lBQ2QsSUFBSXE5SixNQUFNcjlKLENBQUMsQ0FBQyxFQUFFLEVBQ1ZzOUosTUFBTXQ5SixDQUFDLENBQUMsRUFBRSxFQUNWdTlKLE1BQU12OUosQ0FBQyxDQUFDLEVBQUU7SUFDZHMwQixHQUFHLENBQUMsRUFBRSxHQUFHeW9JLE1BQU1ULE1BQU1VLE1BQU1QLE1BQU1RLE1BQU1MO0lBQ3ZDdG9JLEdBQUcsQ0FBQyxFQUFFLEdBQUd5b0ksTUFBTVIsTUFBTVMsTUFBTU4sTUFBTU8sTUFBTUo7SUFDdkN2b0ksR0FBRyxDQUFDLEVBQUUsR0FBR3lvSSxNQUFNUCxNQUFNUSxNQUFNTCxNQUFNTSxNQUFNSDtJQUN2Q3hvSSxHQUFHLENBQUMsRUFBRSxHQUFHNG9JLE1BQU1aLE1BQU1hLE1BQU1WLE1BQU1XLE1BQU1SO0lBQ3ZDdG9JLEdBQUcsQ0FBQyxFQUFFLEdBQUc0b0ksTUFBTVgsTUFBTVksTUFBTVQsTUFBTVUsTUFBTVA7SUFDdkN2b0ksR0FBRyxDQUFDLEVBQUUsR0FBRzRvSSxNQUFNVixNQUFNVyxNQUFNUixNQUFNUyxNQUFNTjtJQUN2Q3hvSSxHQUFHLENBQUMsRUFBRSxHQUFHK29JLE1BQU1mLE1BQU1nQixNQUFNYixNQUFNYyxNQUFNWDtJQUN2Q3RvSSxHQUFHLENBQUMsRUFBRSxHQUFHK29JLE1BQU1kLE1BQU1lLE1BQU1aLE1BQU1hLE1BQU1WO0lBQ3ZDdm9JLEdBQUcsQ0FBQyxFQUFFLEdBQUcrb0ksTUFBTWIsTUFBTWMsTUFBTVgsTUFBTVksTUFBTVQ7SUFDdkMsT0FBT3hvSTtBQUNUO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUVELFNBQVN3bEgsVUFBVXhsSCxHQUFHLEVBQUU1OEIsQ0FBQyxFQUFFb0gsQ0FBQztJQUMxQixJQUFJdzlKLE1BQU01a0ssQ0FBQyxDQUFDLEVBQUUsRUFDVjZrSyxNQUFNN2tLLENBQUMsQ0FBQyxFQUFFLEVBQ1Y4a0ssTUFBTTlrSyxDQUFDLENBQUMsRUFBRSxFQUNWK2tLLE1BQU0va0ssQ0FBQyxDQUFDLEVBQUUsRUFDVmdsSyxNQUFNaGxLLENBQUMsQ0FBQyxFQUFFLEVBQ1ZpbEssTUFBTWpsSyxDQUFDLENBQUMsRUFBRSxFQUNWa2xLLE1BQU1sbEssQ0FBQyxDQUFDLEVBQUUsRUFDVm1sSyxNQUFNbmxLLENBQUMsQ0FBQyxFQUFFLEVBQ1ZvbEssTUFBTXBsSyxDQUFDLENBQUMsRUFBRSxFQUNWdVUsSUFBSW5OLENBQUMsQ0FBQyxFQUFFLEVBQ1I0VyxJQUFJNVcsQ0FBQyxDQUFDLEVBQUU7SUFDWncxQixHQUFHLENBQUMsRUFBRSxHQUFHZ29JO0lBQ1Rob0ksR0FBRyxDQUFDLEVBQUUsR0FBR2lvSTtJQUNUam9JLEdBQUcsQ0FBQyxFQUFFLEdBQUdrb0k7SUFDVGxvSSxHQUFHLENBQUMsRUFBRSxHQUFHbW9JO0lBQ1Rub0ksR0FBRyxDQUFDLEVBQUUsR0FBR29vSTtJQUNUcG9JLEdBQUcsQ0FBQyxFQUFFLEdBQUdxb0k7SUFDVHJvSSxHQUFHLENBQUMsRUFBRSxHQUFHcm9CLElBQUlxd0osTUFBTTVtSixJQUFJK21KLE1BQU1HO0lBQzdCdG9JLEdBQUcsQ0FBQyxFQUFFLEdBQUdyb0IsSUFBSXN3SixNQUFNN21KLElBQUlnbkosTUFBTUc7SUFDN0J2b0ksR0FBRyxDQUFDLEVBQUUsR0FBR3JvQixJQUFJdXdKLE1BQU05bUosSUFBSWluSixNQUFNRztJQUM3QixPQUFPeG9JO0FBQ1Q7QUFDQTs7Ozs7OztDQU9DLEdBRUQsU0FBU2l3QyxPQUFPandDLEdBQUcsRUFBRTU4QixDQUFDLEVBQUU4bEssR0FBRztJQUN6QixJQUFJbEIsTUFBTTVrSyxDQUFDLENBQUMsRUFBRSxFQUNWNmtLLE1BQU03a0ssQ0FBQyxDQUFDLEVBQUUsRUFDVjhrSyxNQUFNOWtLLENBQUMsQ0FBQyxFQUFFLEVBQ1Yra0ssTUFBTS9rSyxDQUFDLENBQUMsRUFBRSxFQUNWZ2xLLE1BQU1obEssQ0FBQyxDQUFDLEVBQUUsRUFDVmlsSyxNQUFNamxLLENBQUMsQ0FBQyxFQUFFLEVBQ1ZrbEssTUFBTWxsSyxDQUFDLENBQUMsRUFBRSxFQUNWbWxLLE1BQU1ubEssQ0FBQyxDQUFDLEVBQUUsRUFDVm9sSyxNQUFNcGxLLENBQUMsQ0FBQyxFQUFFLEVBQ1YyQixJQUFJb0QsS0FBS3laLEdBQUcsQ0FBQ3NuSixNQUNidndJLElBQUl4d0IsS0FBS3daLEdBQUcsQ0FBQ3VuSjtJQUNqQmxwSSxHQUFHLENBQUMsRUFBRSxHQUFHckgsSUFBSXF2SSxNQUFNampLLElBQUlvaks7SUFDdkJub0ksR0FBRyxDQUFDLEVBQUUsR0FBR3JILElBQUlzdkksTUFBTWxqSyxJQUFJcWpLO0lBQ3ZCcG9JLEdBQUcsQ0FBQyxFQUFFLEdBQUdySCxJQUFJdXZJLE1BQU1uakssSUFBSXNqSztJQUN2QnJvSSxHQUFHLENBQUMsRUFBRSxHQUFHckgsSUFBSXd2SSxNQUFNcGpLLElBQUlpaks7SUFDdkJob0ksR0FBRyxDQUFDLEVBQUUsR0FBR3JILElBQUl5dkksTUFBTXJqSyxJQUFJa2pLO0lBQ3ZCam9JLEdBQUcsQ0FBQyxFQUFFLEdBQUdySCxJQUFJMHZJLE1BQU10akssSUFBSW1qSztJQUN2QmxvSSxHQUFHLENBQUMsRUFBRSxHQUFHc29JO0lBQ1R0b0ksR0FBRyxDQUFDLEVBQUUsR0FBR3VvSTtJQUNUdm9JLEdBQUcsQ0FBQyxFQUFFLEdBQUd3b0k7SUFDVCxPQUFPeG9JO0FBQ1Q7QUFDQTs7Ozs7OztFQU9FLEdBRUYsU0FBU1gsTUFBTVcsR0FBRyxFQUFFNThCLENBQUMsRUFBRW9ILENBQUM7SUFDdEIsSUFBSW1OLElBQUluTixDQUFDLENBQUMsRUFBRSxFQUNSNFcsSUFBSTVXLENBQUMsQ0FBQyxFQUFFO0lBQ1p3MUIsR0FBRyxDQUFDLEVBQUUsR0FBR3JvQixJQUFJdlUsQ0FBQyxDQUFDLEVBQUU7SUFDakI0OEIsR0FBRyxDQUFDLEVBQUUsR0FBR3JvQixJQUFJdlUsQ0FBQyxDQUFDLEVBQUU7SUFDakI0OEIsR0FBRyxDQUFDLEVBQUUsR0FBR3JvQixJQUFJdlUsQ0FBQyxDQUFDLEVBQUU7SUFDakI0OEIsR0FBRyxDQUFDLEVBQUUsR0FBRzVlLElBQUloZSxDQUFDLENBQUMsRUFBRTtJQUNqQjQ4QixHQUFHLENBQUMsRUFBRSxHQUFHNWUsSUFBSWhlLENBQUMsQ0FBQyxFQUFFO0lBQ2pCNDhCLEdBQUcsQ0FBQyxFQUFFLEdBQUc1ZSxJQUFJaGUsQ0FBQyxDQUFDLEVBQUU7SUFDakI0OEIsR0FBRyxDQUFDLEVBQUUsR0FBRzU4QixDQUFDLENBQUMsRUFBRTtJQUNiNDhCLEdBQUcsQ0FBQyxFQUFFLEdBQUc1OEIsQ0FBQyxDQUFDLEVBQUU7SUFDYjQ4QixHQUFHLENBQUMsRUFBRSxHQUFHNThCLENBQUMsQ0FBQyxFQUFFO0lBQ2IsT0FBTzQ4QjtBQUNUO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUVELFNBQVNrTixXQUFXbE4sR0FBRyxFQUFFTyxLQUFLLEVBQUVDLE1BQU07SUFDcENSLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSU87SUFDYlAsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNUQSxHQUFHLENBQUMsRUFBRSxHQUFHO0lBQ1RBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUlRO0lBQ2RSLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDO0lBQ1ZBLEdBQUcsQ0FBQyxFQUFFLEdBQUc7SUFDVEEsR0FBRyxDQUFDLEVBQUUsR0FBRztJQUNULE9BQU9BO0FBQ1Q7QUFFQSwrRkFBK0Y7QUFFL0Y7O0NBRUMsR0FDRCxJQUFJbXBJLFFBQVEsV0FBVyxHQUFFO0lBQ3ZCLFNBQVNBLE1BQU1obUssQ0FBQyxFQUFFaW1LLE9BQU8sRUFBRUMsT0FBTyxFQUFFM0csbUJBQW1CO1FBQ3JEOStKLGdCQUFnQixJQUFJLEVBQUV1bEs7UUFDdEIsSUFBSSxDQUFDOUYsT0FBTyxHQUFHbDdKLEtBQUtDLEtBQUssQ0FBQ0QsS0FBSzhiLE1BQU0sS0FBSztRQUMxQyxJQUFJLENBQUM5Z0IsQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ2ltSyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxTQUFTLEdBQUduaEssS0FBS0MsS0FBSyxDQUFDZ2hLLFVBQVVDO1FBQ3RDLElBQUksQ0FBQ0UsY0FBYyxHQUFHLE1BQU0sMkNBQTJDO1FBRXZFLElBQUksQ0FBQ3RoSixNQUFNLEdBQUcsT0FBTyx1REFBdUQ7UUFDNUUsSUFBSSxDQUFDazhILE9BQU8sR0FBRyxNQUFNLHNCQUFzQjtRQUMzQyxJQUFJLENBQUNxbEIsV0FBVyxHQUFHO1FBRW5CLHdFQUF3RTtRQUN4RSxJQUFJLENBQUNDLFdBQVcsR0FBRztZQUNqQjl4SixHQUFHO1lBQ0hzOEIsS0FBSztRQUNQO1FBRUEsK0RBQStEO1FBQy9ELHNEQUFzRDtRQUN0RCxJQUFJLENBQUN5MUgsYUFBYSxHQUFHLElBQUk3akosT0FBTyxxQ0FBcUM7UUFFckUsSUFBSSxDQUFDbytHLE1BQU0sR0FBR3krQixvQkFBb0J2L0osR0FBR2ltSyxTQUFTQTtRQUM5QyxJQUFJLENBQUN6Z0osT0FBTyxHQUFHKzVJLG9CQUFvQnYvSixHQUFHaW1LLFNBQVMsSUFBSSxDQUFDRSxTQUFTLEVBQUU7SUFDakU7SUFDQSxPQUFPOWtLLGFBQWEya0ssT0FBTztRQUFDO1lBQzFCNWtLLEtBQUs7WUFDTFUsT0FBTyxTQUFTMGtLO2dCQUNkLElBQUksQ0FBQzFoSixNQUFNLEdBQUc7WUFDaEI7UUFDRjtRQUFHO1lBQ0QxakIsS0FBSztZQUNMVSxPQUFPLFNBQVMya0s7Z0JBQ2QsT0FBTyxJQUFJbGpKLElBQUksSUFBSSxDQUFDZ2pKLGFBQWEsQ0FBQzE5SixJQUFJO1lBQ3hDO1FBQ0Y7UUFBRztZQUNEekgsS0FBSztZQUNMVSxPQUFPLFNBQVM0a0ssU0FBU3I3SSxJQUFJO2dCQUMzQixJQUFJbE0sSUFBSWtNLEtBQUtsTSxDQUFDLEVBQ1o1VixJQUFJOGhCLEtBQUs5aEIsQ0FBQztnQkFDWixJQUFJNDhKLFlBQVksSUFBSSxDQUFDQSxTQUFTLEVBQzVCUSxjQUFjLElBQUksQ0FBQ1YsT0FBTztnQkFDNUIsb0NBQW9DO2dCQUNwQyxJQUFJL3BJLFFBQVFpcUksWUFBWTU4SixHQUFHLDhCQUE4QjtnQkFDekQsSUFBSXE5SixPQUFPem5KLElBQUkrYztnQkFDZixJQUFJMnFJLE9BQU90OUosSUFBSTJ5QjtnQkFDZixzRUFBc0U7Z0JBQ3RFLElBQUkwcUksT0FBT0QsYUFBYTtvQkFDdEJ6cUksUUFBUXlxSSxjQUFjeG5KO29CQUN0QnluSixPQUFPem5KLElBQUkrYztvQkFDWDJxSSxPQUFPdDlKLElBQUkyeUI7Z0JBQ2I7Z0JBQ0EsT0FBTztvQkFDTEEsT0FBT0E7b0JBQ1AwcUksTUFBTUE7b0JBQ05DLE1BQU1BO2dCQUNSO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R6bEssS0FBSztZQUNMVSxPQUFPLFNBQVNtZ0gsS0FBSzdnSCxHQUFHLEVBQUVzNUIsRUFBRSxFQUFFb3NJLFNBQVM7Z0JBQ3JDLElBQUk1akosUUFBUSxJQUFJO2dCQUNoQixJQUFJLElBQUksQ0FBQzRCLE1BQU0sRUFBRSxNQUFNLElBQUk1USxNQUFNO2dCQUNqQyxJQUFJK3hKLFVBQVUsSUFBSSxDQUFDQSxPQUFPLEVBQ3hCQyxVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUN0QkMsWUFBWSxJQUFJLENBQUNBLFNBQVM7Z0JBQzVCLElBQUlZLGlCQUFpQixJQUFJLENBQUNMLFFBQVEsQ0FBQ2hzSSxLQUNqQ3dCLFFBQVE2cUksZUFBZTdxSSxLQUFLLEVBQzVCMHFJLE9BQU9HLGVBQWVILElBQUksRUFDMUJDLE9BQU9FLGVBQWVGLElBQUk7Z0JBQzVCLElBQUlHLFNBQVMsU0FBU0EsT0FBT0MsUUFBUSxFQUFFbm1DLE1BQU07b0JBQzNDLElBQUlnbUMsYUFBYWhtQyxRQUFRO3dCQUN2QixJQUFJeHFELFVBQVV3cUQsT0FBT3hxRCxPQUFPO3dCQUM1QixJQUFJOWhFLElBQUl5eUosU0FBU3p5SixDQUFDLEVBQ2hCczhCLE1BQU1tMkgsU0FBU24ySCxHQUFHO3dCQUNwQixJQUFJbzJILFVBQVUxeUo7d0JBQ2QsSUFBSTJ5SixVQUFVaEIsWUFBWXIxSDt3QkFDMUJ3bEMsUUFBUWs2RSxJQUFJO3dCQUNabDZFLFFBQVErckUsU0FBUyxDQUFDNmtCLFNBQVNDO3dCQUMzQjd3RixRQUFRcDZDLEtBQUssQ0FBQ0EsT0FBT0E7d0JBQ3JCNHFJLFVBQVV4d0YsU0FBUzU3Qzt3QkFDbkI0N0MsUUFBUTN5RCxPQUFPO29CQUNqQjtnQkFDRjtnQkFDQSxJQUFJeWpKLFlBQVk7b0JBQUM7b0JBQU07aUJBQUs7Z0JBQzVCLElBQUlDLGFBQWEsU0FBU0E7b0JBQ3hCLGtEQUFrRDtvQkFDbERMLE9BQU85akosTUFBTW9qSixXQUFXLEVBQUVwakosTUFBTTQ5RyxNQUFNO29CQUN0Q3NtQyxTQUFTLENBQUMsRUFBRSxHQUFHO3dCQUNiNXlKLEdBQUcwTyxNQUFNb2pKLFdBQVcsQ0FBQzl4SixDQUFDO3dCQUN0QnlKLEdBQUdpRixNQUFNb2pKLFdBQVcsQ0FBQ3gxSCxHQUFHLEdBQUdxMUg7d0JBQzNCaG5KLEdBQUd5bko7d0JBQ0hyOUosR0FBR3M5SjtvQkFDTDtvQkFDQU8sU0FBUyxDQUFDLEVBQUUsR0FBRzt3QkFDYiw4REFBOEQ7d0JBQzlENXlKLEdBQUcwTyxNQUFNb2pKLFdBQVcsQ0FBQzl4SixDQUFDLEdBQUdveUo7d0JBQ3pCM29KLEdBQUdpRixNQUFNb2pKLFdBQVcsQ0FBQ3gxSCxHQUFHLEdBQUdxMUg7d0JBQzNCaG5KLEdBQUc7d0JBQ0g1VixHQUFHczlKO29CQUNMO29CQUVBLDZDQUE2QztvQkFDN0MzakosTUFBTW9qSixXQUFXLENBQUM5eEosQ0FBQyxJQUFJb3lKO29CQUN2QixJQUFJMWpKLE1BQU1vakosV0FBVyxDQUFDOXhKLENBQUMsSUFBSXl4SixTQUFTO3dCQUNsQy9pSixNQUFNb2pKLFdBQVcsQ0FBQzl4SixDQUFDLEdBQUc7d0JBQ3RCME8sTUFBTW9qSixXQUFXLENBQUN4MUgsR0FBRztvQkFDdkI7Z0JBQ0Y7Z0JBQ0EsSUFBSXcySCxjQUFjLFNBQVNBO29CQUN6QixJQUFJOWhKLFVBQVV0QyxNQUFNc0MsT0FBTyxFQUN6QnM3RyxTQUFTNTlHLE1BQU00OUcsTUFBTTtvQkFFdkIsNkJBQTZCO29CQUM3QnQ3RyxRQUFRbEQsS0FBSztvQkFDYjBrSixPQUFPO3dCQUNMeHlKLEdBQUc7d0JBQ0hzOEIsS0FBSztvQkFDUCxHQUFHdHJCO29CQUNILElBQUkraEosWUFBWXRCLFVBQVUvaUosTUFBTW9qSixXQUFXLENBQUM5eEosQ0FBQztvQkFDN0MsSUFBSWd6SixhQUFhWixPQUFPVztvQkFDeEIsSUFBSWgrSixJQUFJNDhKO29CQUNSO3dCQUNFLGtEQUFrRDt3QkFDbEQsSUFBSXJzSSxLQUFLNVcsTUFBTW9qSixXQUFXLENBQUM5eEosQ0FBQzt3QkFDNUIsSUFBSXVsQixLQUFLN1csTUFBTW9qSixXQUFXLENBQUN4MUgsR0FBRyxHQUFHcTFIO3dCQUNqQyxJQUFJaG5KLElBQUlvb0o7d0JBQ1J6bUMsT0FBT3hxRCxPQUFPLENBQUN5ckUsU0FBUyxDQUFDdjhILFNBQVMsR0FBRyxHQUFHckcsR0FBRzVWLEdBQUd1d0IsSUFBSUMsSUFBSTVhLEdBQUc1Vjt3QkFDekQ2OUosU0FBUyxDQUFDLEVBQUUsR0FBRzs0QkFDYjV5SixHQUFHc2xCOzRCQUNIN2IsR0FBRzhiOzRCQUNINWEsR0FBR0E7NEJBQ0g1VixHQUFHczlKO3dCQUNMO29CQUNGO29CQUNBO3dCQUNFLG9EQUFvRDt3QkFDcEQsSUFBSXQrSCxLQUFLZy9IO3dCQUNULElBQUlFLE1BQU0sQ0FBQ3ZrSixNQUFNb2pKLFdBQVcsQ0FBQ3gxSCxHQUFHLEdBQUcsS0FBS3ExSDt3QkFDeEMsSUFBSTEySCxLQUFLKzNIO3dCQUNULElBQUkxbUMsUUFBUTs0QkFDVkEsT0FBT3hxRCxPQUFPLENBQUN5ckUsU0FBUyxDQUFDdjhILFNBQVMraUIsSUFBSSxHQUFHa0gsSUFBSWxtQyxHQUFHLEdBQUdrK0osS0FBS2g0SCxJQUFJbG1DO3dCQUM5RDt3QkFDQTY5SixTQUFTLENBQUMsRUFBRSxHQUFHOzRCQUNiNXlKLEdBQUc7NEJBQ0h5SixHQUFHd3BKOzRCQUNIdG9KLEdBQUdzd0I7NEJBQ0hsbUMsR0FBR3M5Sjt3QkFDTDtvQkFDRjtvQkFDQTNqSixNQUFNb2pKLFdBQVcsQ0FBQzl4SixDQUFDLEdBQUdneko7b0JBQ3RCdGtKLE1BQU1vakosV0FBVyxDQUFDeDFILEdBQUc7Z0JBQ3ZCO2dCQUNBLElBQUk0MkgsdUJBQXVCLFNBQVNBO29CQUNsQ3hrSixNQUFNb2pKLFdBQVcsQ0FBQzl4SixDQUFDLEdBQUc7b0JBQ3RCME8sTUFBTW9qSixXQUFXLENBQUN4MUgsR0FBRztnQkFDdkI7Z0JBQ0EsSUFBSSxJQUFJLENBQUN3MUgsV0FBVyxDQUFDOXhKLENBQUMsR0FBR295SixRQUFRWCxTQUFTO29CQUN4QywwQ0FBMEM7b0JBQzFDb0I7Z0JBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ2YsV0FBVyxDQUFDeDFILEdBQUcsSUFBSW8xSCxVQUFVLEdBQUc7b0JBQzlDLDJFQUEyRTtvQkFDM0UsT0FBTztnQkFDVCxPQUFPLElBQUksSUFBSSxDQUFDSSxXQUFXLENBQUM5eEosQ0FBQyxLQUFLeXhKLFNBQVM7b0JBQ3pDLDJDQUEyQztvQkFDM0N5QjtvQkFDQUw7Z0JBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ2pCLGNBQWMsRUFBRTtvQkFDOUIsbUZBQW1GO29CQUNuRmtCO2dCQUNGLE9BQU87b0JBQ0wsd0RBQXdEO29CQUN4REk7b0JBQ0FMO2dCQUNGO2dCQUNBLElBQUksQ0FBQ2QsYUFBYSxDQUFDcGtKLEdBQUcsQ0FBQy9nQixLQUFLZ21LO2dCQUM1QixJQUFJLENBQUNmLFdBQVcsR0FBRztnQkFDbkIsT0FBT2U7WUFDVDtRQUNGO1FBQUc7WUFDRGhtSyxLQUFLO1lBQ0xVLE9BQU8sU0FBUzZsSyxXQUFXdm1LLEdBQUc7Z0JBQzVCLE9BQU8sSUFBSSxDQUFDbWxLLGFBQWEsQ0FBQy9qSixHQUFHLENBQUNwaEI7WUFDaEM7UUFDRjtRQUFHO1lBQ0RBLEtBQUs7WUFDTFUsT0FBTyxTQUFTOGxLO2dCQUNkLE9BQU8sSUFBSSxDQUFDdEIsV0FBVyxDQUFDOXhKLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQzh4SixXQUFXLENBQUN4MUgsR0FBRyxLQUFLO1lBQzlEO1FBQ0Y7UUFBRztZQUNEMXZDLEtBQUs7WUFDTFUsT0FBTyxTQUFTK2xLLE9BQU9udEksRUFBRTtnQkFDdkIsSUFBSSxJQUFJLENBQUM1VixNQUFNLEVBQUUsT0FBTztnQkFDeEIsSUFBSW1oSixVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUN4QkMsVUFBVSxJQUFJLENBQUNBLE9BQU87Z0JBQ3hCLElBQUk0QixrQkFBa0IsSUFBSSxDQUFDcEIsUUFBUSxDQUFDaHNJLEtBQ2xDa3NJLE9BQU9rQixnQkFBZ0JsQixJQUFJO2dCQUM3QixJQUFJLElBQUksQ0FBQ04sV0FBVyxDQUFDOXhKLENBQUMsR0FBR295SixPQUFPWCxTQUFTO29CQUN2QyxlQUFlO29CQUNmLE9BQU8sSUFBSSxDQUFDSyxXQUFXLENBQUN4MUgsR0FBRyxHQUFHbzFILFVBQVUsR0FBRywwQ0FBMEM7Z0JBQ3ZGO2dCQUNBLE9BQU87WUFDVDtRQUdGO1FBQUc7WUFDRDlrSyxLQUFLO1lBQ0xVLE9BQU8sU0FBU2ltSyxlQUFlM0osRUFBRTtnQkFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ3BkLE9BQU8sRUFBRTtvQkFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdpZixjQUFjN0IsSUFBSSxJQUFJLENBQUM4QixPQUFPO2dCQUMvQztnQkFDQSxJQUFJLElBQUksQ0FBQ21HLFdBQVcsRUFBRTtvQkFDcEIsSUFBSSxDQUFDcmxCLE9BQU8sQ0FBQ21mLE1BQU0sQ0FBQyxJQUFJLENBQUNyL0IsTUFBTTtvQkFDL0IsSUFBSSxDQUFDdWxDLFdBQVcsR0FBRztvQkFDbkIsSUFBSSxJQUFJLENBQUN2aEosTUFBTSxFQUFFO3dCQUNmLElBQUksQ0FBQ2c4RyxNQUFNLEdBQUc7d0JBQ2QsSUFBSSxDQUFDdDdHLE9BQU8sR0FBRztvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQUc7WUFDRHBrQixLQUFLO1lBQ0xVLE9BQU8sU0FBU2ttSztnQkFDZCxJQUFJLElBQUksQ0FBQ2huQixPQUFPLEVBQUU7b0JBQ2hCLElBQUksQ0FBQ0EsT0FBTyxDQUFDcWdCLGFBQWE7b0JBQzFCLElBQUksQ0FBQ3JnQixPQUFPLEdBQUc7Z0JBQ2pCO2dCQUNBLElBQUksQ0FBQ2xnQixNQUFNLEdBQUc7Z0JBQ2QsSUFBSSxDQUFDdDdHLE9BQU8sR0FBRztnQkFDZixJQUFJLENBQUNWLE1BQU0sR0FBRztZQUNoQjtRQUNGO0tBQUU7QUFDSjtBQUVBOzs7OztDQUtDLEdBQ0QsSUFBSW1qSixrQkFBa0IsV0FBVyxHQUFFO0lBQ2pDLFNBQVNBLGdCQUFnQmpvSyxDQUFDLEVBQUVpbUssT0FBTyxFQUFFQyxPQUFPLEVBQUUzRyxtQkFBbUI7UUFDL0Q5K0osZ0JBQWdCLElBQUksRUFBRXduSztRQUN0QixJQUFJLENBQUNqb0ssQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ2ltSyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDM0csbUJBQW1CLEdBQUdBO1FBQzNCLElBQUksQ0FBQzJJLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUl6bEo7UUFDM0IsSUFBSSxDQUFDMGxKLFVBQVUsR0FBRyxJQUFJN2tKLE9BQU8sZ0NBQWdDO0lBQy9EO0lBQ0EsT0FBT2xpQixhQUFhNG1LLGlCQUFpQjtRQUFDO1lBQ3BDN21LLEtBQUs7WUFDTFUsT0FBTyxTQUFTMmtLO2dCQUNkLE9BQU8sSUFBSWxqSixJQUFJLElBQUksQ0FBQzRrSixlQUFlLENBQUN0L0osSUFBSTtZQUMxQztRQUNGO1FBQUc7WUFDRHpILEtBQUs7WUFDTFUsT0FBTyxTQUFTdW1LO2dCQUNkLElBQUlyb0ssSUFBSSxJQUFJLENBQUNBLENBQUMsRUFDWmltSyxVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUN0QkMsVUFBVSxJQUFJLENBQUNBLE9BQU8sRUFDdEIzRyxzQkFBc0IsSUFBSSxDQUFDQSxtQkFBbUI7Z0JBQ2hELE9BQU8sSUFBSXlHLE1BQU1obUssR0FBR2ltSyxTQUFTQyxTQUFTM0c7WUFDeEM7UUFDRjtRQUFHO1lBQ0RuK0osS0FBSztZQUNMVSxPQUFPLFNBQVN3bUs7Z0JBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQzlpSixPQUFPLEVBQUU7b0JBQ2pCLElBQUl4bEIsSUFBSSxJQUFJLENBQUNBLENBQUMsRUFDWmltSyxVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUN0QkMsVUFBVSxJQUFJLENBQUNBLE9BQU8sRUFDdEIzRyxzQkFBc0IsSUFBSSxDQUFDQSxtQkFBbUI7b0JBQ2hELElBQUk0RyxZQUFZbmhLLEtBQUtDLEtBQUssQ0FBQ2doSyxVQUFVQztvQkFDckMsSUFBSSxDQUFDMWdKLE9BQU8sR0FBRys1SSxvQkFBb0J2L0osR0FBR2ltSyxTQUFTRSxXQUFXO2dCQUM1RDtnQkFDQSxPQUFPLElBQUksQ0FBQzNnSixPQUFPO1lBQ3JCO1FBQ0Y7UUFBRztZQUNEcGtCLEtBQUs7WUFDTFUsT0FBTyxTQUFTbWdILEtBQUs3Z0gsR0FBRyxFQUFFczVCLEVBQUUsRUFBRW9zSSxTQUFTO2dCQUNyQyxJQUFJeUIsUUFBUSxJQUFJLENBQUNKLGVBQWUsQ0FBQzNsSixHQUFHLENBQUNwaEI7Z0JBQ3JDLElBQUksQ0FBQ21uSyxPQUFPO29CQUNWLCtDQUErQztvQkFDL0NBLFFBQVEsSUFBSSxDQUFDTCxPQUFPLENBQUMsSUFBSSxDQUFDQSxPQUFPLENBQUNob0ssTUFBTSxHQUFHLEVBQUU7b0JBQzdDLElBQUksQ0FBQ3FvSyxTQUFTLENBQUNBLE1BQU1WLE1BQU0sQ0FBQ250SSxLQUFLO3dCQUMvQixJQUFJNnRJLE9BQU9BLE1BQU0vQixJQUFJO3dCQUNyQixxQkFBcUI7d0JBQ3JCK0IsUUFBUSxJQUFJLENBQUNGLFlBQVk7d0JBQ3pCLElBQUksQ0FBQ0gsT0FBTyxDQUFDeGxLLElBQUksQ0FBQzZsSztvQkFDcEI7b0JBQ0FBLE1BQU10bUQsSUFBSSxDQUFDN2dILEtBQUtzNUIsSUFBSW9zSTtvQkFDcEIsSUFBSSxDQUFDcUIsZUFBZSxDQUFDaG1KLEdBQUcsQ0FBQy9nQixLQUFLbW5LO2dCQUNoQztnQkFDQSxPQUFPQTtZQUNUO1FBQ0Y7UUFBRztZQUNEbm5LLEtBQUs7WUFDTFUsT0FBTyxTQUFTMG1LLFNBQVNwbkssR0FBRztnQkFDMUIsT0FBTyxJQUFJLENBQUMrbUssZUFBZSxDQUFDM2xKLEdBQUcsQ0FBQ3BoQjtZQUNsQztRQUNGO1FBQUc7WUFDREEsS0FBSztZQUNMVSxPQUFPLFNBQVMybUssU0FBU3JuSyxHQUFHO2dCQUMxQixPQUFPLElBQUksQ0FBQyttSyxlQUFlLENBQUM1bEosR0FBRyxDQUFDbmhCO1lBQ2xDO1FBQ0Y7UUFBRztZQUNEQSxLQUFLO1lBQ0xVLE9BQU8sU0FBUzRtSyxhQUFhdG5LLEdBQUc7Z0JBQzlCLElBQUksQ0FBQ2duSyxVQUFVLENBQUNubEosR0FBRyxDQUFDN2hCO1lBQ3RCO1FBQ0Y7UUFBRztZQUNEQSxLQUFLO1lBQ0xVLE9BQU8sU0FBU29yRztnQkFDZCxJQUFJeTdELFNBQVMsSUFBSTtnQkFDakIsSUFBSVAsYUFBYSxJQUFJLENBQUNBLFVBQVU7Z0JBQ2hDLElBQUlBLFdBQVdybEosSUFBSSxLQUFLLEdBQUc7b0JBQ3pCdkQsUUFBUWdCLEdBQUcsQ0FBQztvQkFDWjtnQkFDRjtnQkFDQSxJQUFJb29KLGFBQWEsRUFBRTtnQkFDbkIsSUFBSUMscUJBQXFCLElBQUlubUo7Z0JBQzdCLElBQUlvbUosV0FBVztnQkFDZixJQUFJbC9ILFlBQVlyb0MsMkJBQTJCLElBQUksQ0FBQzJtSyxPQUFPLEdBQ3JEcitIO2dCQUNGLElBQUk7b0JBQ0YsSUFBSXpoQixRQUFRLFNBQVNBO3dCQUNuQixJQUFJbWdKLFFBQVExK0gsTUFBTS9uQyxLQUFLO3dCQUN2QixJQUFJK0csT0FBTzAvSixNQUFNOUIsT0FBTzt3QkFDeEIsSUFBSXNDLGdCQUFnQjlrSSxhQUFhbWtJLFlBQVl2L0o7d0JBQzdDLElBQUlrZ0ssY0FBY2htSixJQUFJLEtBQUssR0FBRzs0QkFDNUIsK0JBQStCOzRCQUMvQjZsSixXQUFXbG1LLElBQUksQ0FBQzZsSzs0QkFDaEIxL0osS0FBS3VhLE9BQU8sQ0FBQyxTQUFVcmMsQ0FBQztnQ0FDdEIsT0FBTzhoSyxtQkFBbUIxbUosR0FBRyxDQUFDcGIsR0FBR3doSzs0QkFDbkM7NEJBQ0EsT0FBTyxHQUFHLFdBQVc7d0JBQ3ZCO3dCQUNBLElBQUksQ0FBQ08sVUFBVTs0QkFDYkEsV0FBV0gsT0FBT04sWUFBWTs0QkFDOUJPLFdBQVdsbUssSUFBSSxDQUFDb21LO3dCQUNsQjt3QkFDQSxJQUFJMStILGFBQWE3b0MsMkJBQTJCc0gsT0FDMUN3aEM7d0JBQ0YsSUFBSTs0QkFDRixJQUFLRCxXQUFXeG9DLENBQUMsSUFBSSxDQUFDLENBQUN5b0MsU0FBU0QsV0FBV2hxQyxDQUFDLEVBQUMsRUFBR3lCLElBQUksRUFBRztnQ0FDckQsSUFBSVQsTUFBTWlwQyxPQUFPdm9DLEtBQUs7Z0NBQ3RCLElBQUksQ0FBQ2luSyxjQUFjeG1KLEdBQUcsQ0FBQ25oQixNQUFNO29DQUMzQixJQUFJNG5LLG9CQUFvQlQsTUFBTVosVUFBVSxDQUFDdm1LLE1BQ3ZDNm5LLHFCQUFxQnBtSyxlQUFlbW1LLG1CQUFtQixJQUN2REUsS0FBS0Qsa0JBQWtCLENBQUMsRUFBRSxFQUMxQkUsS0FBS0Ysa0JBQWtCLENBQUMsRUFBRTtvQ0FDNUIsSUFBSSxDQUFDSCxTQUFTakIsTUFBTSxDQUFDO3dDQUNuQjFvSixHQUFHK3BKLEdBQUcvcEosQ0FBQyxHQUFHZ3FKLEdBQUdocUosQ0FBQzt3Q0FDZDVWLEdBQUcyL0osR0FBRzMvSixDQUFDO29DQUNULElBQUk7d0NBQ0Z1L0osU0FBU3RDLElBQUk7d0NBQ2JzQyxXQUFXSCxPQUFPTixZQUFZO3dDQUM5Qk8sV0FBV2xtSyxJQUFJLENBQUNvbUs7b0NBQ2xCO29DQUNBLElBQUlQLE1BQU16bkMsTUFBTSxFQUFFO3dDQUNoQixtRkFBbUY7d0NBQ25GNm5DLE9BQU9TLHNCQUFzQixDQUFDaG9LLEtBQUttbkssT0FBT087d0NBQzFDRCxtQkFBbUIxbUosR0FBRyxDQUFDL2dCLEtBQUswbks7b0NBQzlCO2dDQUNGOzRCQUNGO3dCQUNGLEVBQUUsT0FBTzkrSCxLQUFLOzRCQUNaSSxXQUFXanFDLENBQUMsQ0FBQzZwQzt3QkFDZixTQUFVOzRCQUNSSSxXQUFXcm9DLENBQUM7d0JBQ2Q7d0JBQ0F3bUssTUFBTVAsT0FBTztvQkFDZjtvQkFDQSxJQUFLcCtILFVBQVVob0MsQ0FBQyxJQUFJLENBQUMsQ0FBQ2lvQyxRQUFRRCxVQUFVeHBDLENBQUMsRUFBQyxFQUFHeUIsSUFBSSxFQUFHO3dCQUNsRCxJQUFJdW1CLFNBQVM7b0JBQ2Y7Z0JBQ0YsRUFBRSxPQUFPNGhCLEtBQUs7b0JBQ1pKLFVBQVV6cEMsQ0FBQyxDQUFDNnBDO2dCQUNkLFNBQVU7b0JBQ1JKLFVBQVU3bkMsQ0FBQztnQkFDYjtnQkFDQSxJQUFJLENBQUNtbUssT0FBTyxHQUFHVTtnQkFDZixJQUFJLENBQUNULGVBQWUsR0FBR1U7Z0JBQ3ZCLElBQUksQ0FBQ1QsVUFBVSxHQUFHLElBQUk3a0o7WUFDeEI7UUFDRjtRQUFHO1lBQ0RuaUIsS0FBSztZQUNMVSxPQUFPLFNBQVNzbkssdUJBQXVCaG9LLEdBQUcsRUFBRWlvSyxRQUFRLEVBQUVQLFFBQVE7Z0JBQzVELElBQUlRLHVCQUF1QkQsU0FBUzFCLFVBQVUsQ0FBQ3ZtSyxNQUM3Q21vSyx3QkFBd0IxbUssZUFBZXltSyxzQkFBc0IsSUFDN0RKLEtBQUtLLHFCQUFxQixDQUFDLEVBQUUsRUFDN0JKLEtBQUtJLHFCQUFxQixDQUFDLEVBQUU7Z0JBQy9CLElBQUlKLEdBQUdocUosQ0FBQyxLQUFLLEdBQUc7b0JBQ2Qsd0RBQXdEO29CQUN4RDJwSixTQUFTN21ELElBQUksQ0FBQzdnSCxLQUFLOG5LLElBQUksU0FBVTV5RixPQUFPO3dCQUN0Q0EsUUFBUXlyRSxTQUFTLENBQUNzbkIsU0FBU3ZvQyxNQUFNLEVBQUVvb0MsR0FBRzEwSixDQUFDLEVBQUUwMEosR0FBR2pySixDQUFDLEVBQUVpckosR0FBRy9wSixDQUFDLEVBQUUrcEosR0FBRzMvSixDQUFDLEVBQUUsR0FBRyxHQUFHMi9KLEdBQUcvcEosQ0FBQyxFQUFFK3BKLEdBQUczL0osQ0FBQztvQkFDN0U7Z0JBQ0YsT0FBTztvQkFDTCwrREFBK0Q7b0JBQy9ELElBQUlpYyxVQUFVLElBQUksQ0FBQzhpSixpQkFBaUI7b0JBQ3BDOWlKLFFBQVFsRCxLQUFLO29CQUNia0QsUUFBUTh3RCxPQUFPLENBQUN5ckUsU0FBUyxDQUFDc25CLFNBQVN2b0MsTUFBTSxFQUFFb29DLEdBQUcxMEosQ0FBQyxFQUFFMDBKLEdBQUdqckosQ0FBQyxFQUFFaXJKLEdBQUcvcEosQ0FBQyxFQUFFK3BKLEdBQUczL0osQ0FBQyxFQUFFLEdBQUcsR0FBRzIvSixHQUFHL3BKLENBQUMsRUFBRStwSixHQUFHMy9KLENBQUM7b0JBQ25GaWMsUUFBUTh3RCxPQUFPLENBQUN5ckUsU0FBUyxDQUFDc25CLFNBQVN2b0MsTUFBTSxFQUFFcW9DLEdBQUczMEosQ0FBQyxFQUFFMjBKLEdBQUdsckosQ0FBQyxFQUFFa3JKLEdBQUdocUosQ0FBQyxFQUFFZ3FKLEdBQUc1L0osQ0FBQyxFQUFFMi9KLEdBQUcvcEosQ0FBQyxFQUFFLEdBQUdncUosR0FBR2hxSixDQUFDLEVBQUVncUosR0FBRzUvSixDQUFDO29CQUV0Rix3Q0FBd0M7b0JBQ3hDLElBQUk0VixJQUFJK3BKLEdBQUcvcEosQ0FBQyxHQUFHZ3FKLEdBQUdocUosQ0FBQztvQkFDbkIsSUFBSTVWLElBQUkyL0osR0FBRzMvSixDQUFDO29CQUNadS9KLFNBQVM3bUQsSUFBSSxDQUFDN2dILEtBQUs7d0JBQ2pCK2QsR0FBR0E7d0JBQ0g1VixHQUFHQTtvQkFDTCxHQUFHLFNBQVUrc0UsT0FBTzt3QkFDbEJBLFFBQVF5ckUsU0FBUyxDQUFDdjhILFNBQVMsR0FBRyxHQUFHckcsR0FBRzVWLEdBQUcsR0FBRyxHQUFHNFYsR0FBRzVWLEVBQUUsOEVBQThFOztvQkFFbEk7Z0JBQ0Y7WUFDRjtRQUNGO1FBQUc7WUFDRG5JLEtBQUs7WUFDTFUsT0FBTyxTQUFTMG5LO2dCQUNkLE9BQU87b0JBQ0xDLFVBQVUsSUFBSSxDQUFDdEIsZUFBZSxDQUFDcGxKLElBQUk7b0JBQ25DMm1KLFlBQVksSUFBSW5tSixJQUFJLElBQUksQ0FBQzRrSixlQUFlLENBQUN3QixNQUFNLElBQUk1bUosSUFBSTtnQkFDekQ7WUFDRjtRQUNGO0tBQUU7QUFDSjtBQUNBLFNBQVNraEIsYUFBYTJsSSxJQUFJLEVBQUVDLElBQUk7SUFDOUIsNkNBQTZDO0lBQzdDLElBQUlELEtBQUszbEksWUFBWSxFQUFFLE9BQU8ybEksS0FBSzNsSSxZQUFZLENBQUM0bEk7U0FBVyxPQUFPLElBQUl0bUosSUFBSXpnQixtQkFBbUI4bUssTUFBTXptSixNQUFNLENBQUMsU0FBVTNPLENBQUM7UUFDbkgsT0FBT3ExSixLQUFLdG5KLEdBQUcsQ0FBQy9OO0lBQ2xCO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxJQUFJczFKLGVBQWUsV0FBVyxHQUFFO0lBQzlCLFNBQVNBLGFBQWE5cEssQ0FBQyxFQUFFK3BLLGFBQWE7UUFDcEN0cEssZ0JBQWdCLElBQUksRUFBRXFwSztRQUN0QixJQUFJLENBQUM5cEssQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQytwSyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ0MsU0FBUyxHQUFHRCxjQUFjLzFFLFlBQVk7UUFDM0MsSUFBSSxDQUFDaTJFLGtCQUFrQixHQUFHRixjQUFjMzFFLGdCQUFnQjtRQUN4RCxJQUFJLENBQUM4MUUsV0FBVyxHQUFHLElBQUl4bkosT0FBTyx5Q0FBeUM7UUFDdkUsSUFBSSxDQUFDeW5KLFdBQVcsR0FBRyxJQUFJem5KLE9BQU8sMkNBQTJDO1FBRXpFLElBQUksQ0FBQzBuSixjQUFjLEdBQUcsSUFBSTFuSixPQUFPLHNDQUFzQztJQUN6RTtJQUNBLE9BQU9yaEIsYUFBYXlvSyxjQUFjO1FBQUM7WUFDakMxb0ssS0FBSztZQUNMVSxPQUFPLFNBQVN1b0s7Z0JBQ2QsT0FBTyxJQUFJLENBQUNMLFNBQVM7WUFDdkI7UUFDRjtRQUFHO1lBQ0Q1b0ssS0FBSztZQUNMVSxPQUFPLFNBQVN3b0ssbUJBQW1CQyxjQUFjLEVBQUVDLHNCQUFzQjtnQkFDdkUsSUFBSUMsc0JBQXNCLElBQUksQ0FBQ1YsYUFBYSxFQUMxQy8xRSxlQUFleTJFLG9CQUFvQnoyRSxZQUFZLEVBQy9DdXJFLHNCQUFzQmtMLG9CQUFvQmxMLG1CQUFtQjtnQkFDL0QsSUFBSTJHLFVBQVVzRSx1QkFBdUJ0RSxPQUFPO2dCQUM1QyxJQUFJd0UsNEJBQTRCLElBQUksQ0FBQ0MsbUJBQW1CLENBQUNwTDtnQkFDekQsSUFBSXFMLGtCQUFrQixJQUFJM0MsZ0JBQWdCLElBQUksQ0FBQ2pvSyxDQUFDLEVBQUVnMEYsY0FBY2t5RSxTQUFTd0U7Z0JBQ3pFLElBQUksQ0FBQ1AsV0FBVyxDQUFDaG9KLEdBQUcsQ0FBQ29vSixnQkFBZ0JLO1lBQ3ZDO1FBQ0Y7UUFBRztZQUNEeHBLLEtBQUs7WUFDTFUsT0FBTyxTQUFTK29LLGNBQWM5MUosSUFBSSxFQUFFKzFKLGlCQUFpQjtnQkFDbkQsSUFBSTFsSyxhQUFhMGxLLGtCQUFrQjFsSyxVQUFVO2dCQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDK2tLLFdBQVcsQ0FBQzVuSixHQUFHLENBQUNuZCxhQUFhLE1BQU0sSUFBSThPLE1BQU0sa0NBQWtDK1csTUFBTSxDQUFDN2xCLFlBQVk7Z0JBQzVHLElBQUl3bEssa0JBQWtCLElBQUksQ0FBQ1QsV0FBVyxDQUFDM25KLEdBQUcsQ0FBQ3BkO2dCQUMzQyxJQUFJZ2MsT0FBTzNZLE9BQU87b0JBQ2hCc00sTUFBTUE7b0JBQ042MUosaUJBQWlCQTtnQkFDbkIsR0FBR0U7Z0JBQ0gsSUFBSSxDQUFDWixXQUFXLENBQUMvbkosR0FBRyxDQUFDcE4sTUFBTXFNO1lBQzdCO1FBQ0Y7UUFBRztZQUNEaGdCLEtBQUs7WUFDTFUsT0FBTyxTQUFTaXBLLGtCQUFrQmgySixJQUFJO2dCQUNwQyxPQUFPLElBQUksQ0FBQ20xSixXQUFXLENBQUMxbkosR0FBRyxDQUFDek47WUFDOUI7UUFDRjtRQUFHO1lBQ0QzVCxLQUFLO1lBQ0xVLE9BQU8sU0FBU2twSyxtQkFBbUJ6bkssSUFBSTtnQkFDckMsT0FBTyxJQUFJLENBQUM0bUssV0FBVyxDQUFDM25KLEdBQUcsQ0FBQ2pmO1lBQzlCO1FBQ0Y7UUFBRztZQUNEbkMsS0FBSztZQUNMVSxPQUFPLFNBQVM2b0ssb0JBQW9CcEwsbUJBQW1CO2dCQUNyRCw2R0FBNkc7Z0JBQzdHLCtEQUErRDtnQkFDL0QsSUFBSTBMLFFBQVEsQ0FBQztnQkFDYixJQUFJQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSUMsZ0JBQWdCO2dCQUNwQixPQUFPLFNBQVVuckssQ0FBQyxFQUFFbWYsQ0FBQyxFQUFFNVYsQ0FBQyxFQUFFaWMsT0FBTztvQkFDL0IsSUFBSUEsU0FBUzt3QkFDWCxJQUFJLENBQUMybEosaUJBQWlCaHNKLEtBQUs4ckosU0FBUzFoSyxLQUFLMmhLLE9BQU87NEJBQzlDRCxRQUFROXJKOzRCQUNSK3JKLFFBQVEzaEs7NEJBQ1I0aEssZ0JBQWdCNUwsb0JBQW9Cdi9KLEdBQUdtZixHQUFHNVY7d0JBQzVDO3dCQUNBLE9BQU80aEs7b0JBQ1QsT0FBTzt3QkFDTCxPQUFPNUwsb0JBQW9Cdi9KLEdBQUdtZixHQUFHNVY7b0JBQ25DO2dCQUNGO1lBQ0Y7UUFDRjtRQUFHO1lBQ0RuSSxLQUFLO1lBQ0xVLE9BQU8sU0FBUzR6RCxLQUFLMDFHLFVBQVUsRUFBRWxqSixFQUFFO2dCQUNqQyxPQUFPLEdBQUcrQyxNQUFNLENBQUNtZ0osWUFBWSxLQUFLbmdKLE1BQU0sQ0FBQy9DLEtBQUssMEJBQTBCO1lBQzFFO1FBR0Y7UUFBRztZQUNEOW1CLEtBQUs7WUFDTFUsT0FBTyxTQUFTeTdJLFdBQVdod0gsSUFBSTtnQkFDN0IsSUFBSTg5SSxTQUFTLElBQUk7Z0JBQ2pCLElBQUl6dkcsUUFBUXAxRCxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUMvRThrSyxvQkFBb0IxdkcsTUFBTTJ2RyxXQUFXLEVBQ3JDQSxjQUFjRCxzQkFBc0Jyb0ssWUFBWSxRQUFRcW9LLG1CQUN4REUsa0JBQWtCNXZHLE1BQU02dkcsU0FBUyxFQUNqQ0EsWUFBWUQsb0JBQW9Cdm9LLFlBQVk7b0JBQzFDLE9BQU87Z0JBQ1QsSUFBSXVvSyxpQkFDSkUsbUJBQW1COXZHLE1BQU0rdkcsVUFBVSxFQUNuQ0EsYUFBYUQscUJBQXFCem9LLFlBQVk7b0JBQzVDLE9BQU87Z0JBQ1QsSUFBSXlvSztnQkFDTixJQUFJRSxTQUFTO2dCQUNiLElBQUlDLFdBQVc7Z0JBQ2YsSUFBSUMsYUFBYXZxSywyQkFBMkJnc0IsT0FDMUN3K0k7Z0JBQ0YsSUFBSTtvQkFDRixJQUFLRCxXQUFXbHFLLENBQUMsSUFBSSxDQUFDLENBQUNtcUssU0FBU0QsV0FBVzFySyxDQUFDLEVBQUMsRUFBR3lCLElBQUksRUFBRzt3QkFDckQsSUFBSTJmLE1BQU11cUosT0FBT2pxSyxLQUFLO3dCQUN0QixJQUFJMnBLLFVBQVVqcUosTUFBTTs0QkFDbEIsSUFBSXdxSixhQUFhenFLLDJCQUEyQixJQUFJLENBQUMyb0ssV0FBVyxDQUFDUCxNQUFNLEtBQ2pFc0M7NEJBQ0YsSUFBSTtnQ0FDRixJQUFJbjBGLFNBQVMsU0FBU0E7b0NBQ3BCLElBQUkxMkQsT0FBTzZxSixPQUFPbnFLLEtBQUs7b0NBQ3ZCLElBQUlzcEssYUFBYWhxSixLQUFLck0sSUFBSTtvQ0FDMUIsSUFBSTQySixXQUFXUCxhQUFhO3dDQUMxQixJQUFJUixrQkFBa0JTLE9BQU9sQixXQUFXLENBQUMzbkosR0FBRyxDQUFDcEIsS0FBS2hjLFVBQVU7d0NBQzVELElBQUloRSxNQUFNZ2dCLEtBQUsydkQsTUFBTSxDQUFDdnZEO3dDQUN0QixJQUFJMHFKLFdBQVc3ckssTUFBTUUsT0FBTyxDQUFDYSxPQUFPQSxNQUFNOzRDQUFDQTt5Q0FBSTt3Q0FFL0MsOEdBQThHO3dDQUM5RyxJQUFJbXFLLGFBQWE7NENBQ2ZXLFNBQVM5b0osT0FBTyxDQUFDLFNBQVVoaUIsR0FBRztnREFDNUIsT0FBT3dwSyxnQkFBZ0JsQyxZQUFZLENBQUN0bks7NENBQ3RDOzRDQUNBeXFLLFdBQVcsTUFBTSxrR0FBa0c7d0NBQ3JILE9BQU87NENBQ0wsSUFBSTNqSixLQUFLOUcsS0FBSytxSixLQUFLLEdBQUcvcUosS0FBSytxSixLQUFLLENBQUMzcUosT0FBT0EsSUFBSTBHLEVBQUU7NENBQzlDLElBQUlra0osU0FBU2YsT0FBTzMxRyxJQUFJLENBQUMwMUcsWUFBWWxqSjs0Q0FDckMsSUFBSW1rSixjQUFjaEIsT0FBT2pCLGNBQWMsQ0FBQzVuSixHQUFHLENBQUM0cEo7NENBQzVDLElBQUlDLGdCQUFnQnBwSyxhQUFhLENBQUMwOEosV0FBV3VNLFVBQVVHLGNBQWM7Z0RBQ25FLGlGQUFpRjtnREFDakZULFNBQVM7Z0RBQ1RQLE9BQU9qQixjQUFjLENBQUMsU0FBUyxDQUFDZ0M7Z0RBQ2hDQyxZQUFZanBKLE9BQU8sQ0FBQyxTQUFVa3BKLE1BQU07b0RBQ2xDLE9BQU8xQixnQkFBZ0JsQyxZQUFZLENBQUM0RDtnREFDdEM7NENBQ0Y7d0NBQ0Y7b0NBQ0Y7Z0NBQ0Y7Z0NBQ0EsSUFBS04sV0FBV3BxSyxDQUFDLElBQUksQ0FBQyxDQUFDcXFLLFNBQVNELFdBQVc1ckssQ0FBQyxFQUFDLEVBQUd5QixJQUFJLEVBQUc7b0NBQ3JEaTJFO2dDQUNGOzRCQUNGLEVBQUUsT0FBTzl0QyxLQUFLO2dDQUNaZ2lJLFdBQVc3ckssQ0FBQyxDQUFDNnBDOzRCQUNmLFNBQVU7Z0NBQ1JnaUksV0FBV2pxSyxDQUFDOzRCQUNkO3dCQUNGO29CQUNGO2dCQUNGLEVBQUUsT0FBT2lvQyxLQUFLO29CQUNaOGhJLFdBQVczckssQ0FBQyxDQUFDNnBDO2dCQUNmLFNBQVU7b0JBQ1I4aEksV0FBVy9wSyxDQUFDO2dCQUNkO2dCQUNBLElBQUk4cEssVUFBVTtvQkFDWixJQUFJLENBQUMzK0QsRUFBRTtvQkFDUDArRCxTQUFTO2dCQUNYO2dCQUNBLE9BQU9BO1lBQ1Q7UUFHRjtRQUFHO1lBQ0R4cUssS0FBSztZQUNMVSxPQUFPLFNBQVNvckc7Z0JBQ2QsSUFBSXEvRCxhQUFhaHJLLDJCQUEyQixJQUFJLENBQUM0b0ssV0FBVyxDQUFDUixNQUFNLEtBQ2pFNkM7Z0JBQ0YsSUFBSTtvQkFDRixJQUFLRCxXQUFXM3FLLENBQUMsSUFBSSxDQUFDLENBQUM0cUssU0FBU0QsV0FBV25zSyxDQUFDLEVBQUMsRUFBR3lCLElBQUksRUFBRzt3QkFDckQsSUFBSXVELGFBQWFvbkssT0FBTzFxSyxLQUFLO3dCQUM3QnNELFdBQVc4bkcsRUFBRTtvQkFDZjtnQkFDRixFQUFFLE9BQU9sakUsS0FBSztvQkFDWnVpSSxXQUFXcHNLLENBQUMsQ0FBQzZwQztnQkFDZixTQUFVO29CQUNSdWlJLFdBQVd4cUssQ0FBQztnQkFDZDtZQUNGO1FBQ0Y7UUFBRztZQUNEWCxLQUFLO1lBQ0xVLE9BQU8sU0FBUzJxSyxpQkFBaUJqckosR0FBRyxFQUFFek0sSUFBSSxFQUFFMmxCLEVBQUUsRUFBRXkrRCxRQUFRO2dCQUN0RCxnQ0FBZ0M7Z0JBQ2hDLElBQUkvM0UsT0FBTyxJQUFJLENBQUM4b0osV0FBVyxDQUFDMW5KLEdBQUcsQ0FBQ3pOO2dCQUNoQyxJQUFJNjFKLGtCQUFrQixJQUFJLENBQUNULFdBQVcsQ0FBQzNuSixHQUFHLENBQUNwQixLQUFLaGMsVUFBVTtnQkFFMUQsbUNBQW1DO2dCQUNuQyxJQUFJc25LLFFBQVE7Z0JBQ1osSUFBSW5FLFFBQVFxQyxnQkFBZ0Izb0QsSUFBSSxDQUFDOW9CLFVBQVV6K0QsSUFBSSxTQUFVNDdDLE9BQU87b0JBQzlELElBQUlsMUQsS0FBS3VySixXQUFXLEVBQUU7d0JBQ3BCcjJGLFFBQVFrNkUsSUFBSTt3QkFDWmw2RSxRQUFRMHhFLFNBQVM7d0JBQ2pCMXhFLFFBQVFxdEMsSUFBSSxDQUFDLEdBQUcsR0FBR2pwRixHQUFHdmIsQ0FBQyxFQUFFdWIsR0FBR254QixDQUFDO3dCQUM3QitzRSxRQUFRNjRFLElBQUk7d0JBQ1ovdEksS0FBSzI5SCxXQUFXLENBQUN6b0UsU0FBUzkwRCxLQUFLa1osSUFBSSxNQUFNO3dCQUN6QzQ3QyxRQUFRM3lELE9BQU87b0JBQ2pCLE9BQU87d0JBQ0x2QyxLQUFLMjlILFdBQVcsQ0FBQ3pvRSxTQUFTOTBELEtBQUtrWixJQUFJLE1BQU07b0JBQzNDO29CQUNBZ3lJLFFBQVE7Z0JBQ1Y7Z0JBQ0EsSUFBSUEsT0FBTztvQkFDVCxJQUFJeGtKLEtBQUs5RyxLQUFLK3FKLEtBQUssR0FBRy9xSixLQUFLK3FKLEtBQUssQ0FBQzNxSixPQUFPQSxJQUFJMEcsRUFBRSxJQUFJLGNBQWM7b0JBQ2hFLElBQUlra0osU0FBUyxJQUFJLENBQUMxMkcsSUFBSSxDQUFDM2dELE1BQU1tVDtvQkFDN0IsSUFBSSxJQUFJLENBQUNraUosY0FBYyxDQUFDN25KLEdBQUcsQ0FBQzZwSixTQUFTO3dCQUNuQyxJQUFJLENBQUNoQyxjQUFjLENBQUM1bkosR0FBRyxDQUFDNHBKLFFBQVExcEssSUFBSSxDQUFDeTJGO29CQUN2QyxPQUFPO3dCQUNMLElBQUksQ0FBQ2l4RSxjQUFjLENBQUNqb0osR0FBRyxDQUFDaXFKLFFBQVE7NEJBQUNqekU7eUJBQVM7b0JBQzVDO2dCQUNGO2dCQUNBLE9BQU9vdkU7WUFDVDtRQUNGO1FBQUc7WUFDRG5uSyxLQUFLO1lBQ0xVLE9BQU8sU0FBUzhxSyxhQUFhcHJKLEdBQUcsRUFBRXpNLElBQUk7Z0JBQ3BDLElBQUk4M0osU0FBUyxJQUFJO2dCQUNqQixJQUFJenJKLE9BQU8sSUFBSSxDQUFDOG9KLFdBQVcsQ0FBQzFuSixHQUFHLENBQUN6TjtnQkFDaEMsSUFBSTNULE1BQU1nZ0IsS0FBSzJ2RCxNQUFNLENBQUN2dkQ7Z0JBQ3RCLElBQUkwcUosV0FBVzdySyxNQUFNRSxPQUFPLENBQUNhLE9BQU9BLE1BQU07b0JBQUNBO2lCQUFJO2dCQUMvQyxPQUFPOHFLLFNBQVNqNEosR0FBRyxDQUFDLFNBQVVrbEYsUUFBUTtvQkFDcEMsSUFBSXorRCxLQUFLdFosS0FBSzQ5SCxjQUFjLENBQUN4OUgsS0FBSzIzRSxXQUFXLGlEQUFpRDtvQkFDOUYsSUFBSW92RSxRQUFRc0UsT0FBT0osZ0JBQWdCLENBQUNqckosS0FBS3pNLE1BQU0ybEIsSUFBSXkrRDtvQkFDbkQsSUFBSTJ6RSxxQkFBcUJ2RSxNQUFNWixVQUFVLENBQUN4dUUsV0FDeEM0ekUscUJBQXFCbHFLLGVBQWVpcUssb0JBQW9CLElBQ3hERSxPQUFPRCxrQkFBa0IsQ0FBQyxFQUFFLEVBQzVCRSxPQUFPRixrQkFBa0IsQ0FBQyxFQUFFO29CQUM5QixPQUFPO3dCQUNMeEUsT0FBT0E7d0JBQ1AyRSxLQUFLRjt3QkFDTEEsTUFBTUE7d0JBQ05DLE1BQU1BO3dCQUNOdnlJLElBQUlBO29CQUNOO2dCQUNGO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R0NUIsS0FBSztZQUNMVSxPQUFPLFNBQVNxcks7Z0JBQ2QsSUFBSUMsWUFBWSxFQUFFO2dCQUNsQixJQUFJQyxhQUFhOXJLLDJCQUEyQixJQUFJLENBQUM0b0ssV0FBVyxHQUMxRG1EO2dCQUNGLElBQUk7b0JBQ0YsSUFBS0QsV0FBV3pySyxDQUFDLElBQUksQ0FBQyxDQUFDMHJLLFNBQVNELFdBQVdqdEssQ0FBQyxFQUFDLEVBQUd5QixJQUFJLEVBQUc7d0JBQ3JELElBQUkwckssZUFBZTFxSyxlQUFleXFLLE9BQU94ckssS0FBSyxFQUFFLElBQzlDeUIsT0FBT2dxSyxZQUFZLENBQUMsRUFBRSxFQUN0Qm5vSyxhQUFhbW9LLFlBQVksQ0FBQyxFQUFFO3dCQUM5QixJQUFJQyx3QkFBd0Jwb0ssV0FBV29rSyxTQUFTLElBQzlDQyxXQUFXK0Qsc0JBQXNCL0QsUUFBUSxFQUN6Q0MsYUFBYThELHNCQUFzQjlELFVBQVU7d0JBQy9DMEQsVUFBVTFxSyxJQUFJLENBQUM7NEJBQ2JxUyxNQUFNeFI7NEJBQ05rbUssVUFBVUE7NEJBQ1ZDLFlBQVlBO3dCQUNkO29CQUNGO2dCQUNGLEVBQUUsT0FBTzEvSCxLQUFLO29CQUNacWpJLFdBQVdsdEssQ0FBQyxDQUFDNnBDO2dCQUNmLFNBQVU7b0JBQ1JxakksV0FBV3RySyxDQUFDO2dCQUNkO2dCQUNBLE9BQU9xcks7WUFDVDtRQUNGO0tBQUU7QUFDSjtBQUNBLElBQUlLLG9CQUFvQixXQUFXLEdBQUU7SUFDbkMsU0FBU0Esa0JBQWtCMUQsYUFBYTtRQUN0Q3RwSyxnQkFBZ0IsSUFBSSxFQUFFZ3RLO1FBQ3RCLElBQUksQ0FBQzFELGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUdELGNBQWMvMUUsWUFBWTtRQUMzQyxJQUFJLENBQUNpMkUsa0JBQWtCLEdBQUdGLGNBQWMzMUUsZ0JBQWdCO1FBQ3hELElBQUksQ0FBQ3M1RSxZQUFZLEdBQUcsRUFBRTtJQUN4QjtJQUNBLE9BQU9yc0ssYUFBYW9zSyxtQkFBbUI7UUFBQztZQUN0Q3JzSyxLQUFLO1lBQ0xVLE9BQU8sU0FBUzZySztnQkFDZCxPQUFPLElBQUksQ0FBQzFELGtCQUFrQjtZQUNoQztRQUNGO1FBQUc7WUFDRDdvSyxLQUFLO1lBQ0xVLE9BQU8sU0FBU3VvSztnQkFDZCxPQUFPLElBQUksQ0FBQ0wsU0FBUztZQUN2QjtRQUNGO1FBQUc7WUFDRDVvSyxLQUFLO1lBQ0xVLE9BQU8sU0FBUzhySztnQkFDZCxPQUFPdnRLLE1BQU1pQyxJQUFJLENBQUM7b0JBQ2hCcEMsUUFBUSxJQUFJLENBQUMrcEssa0JBQWtCO2dCQUNqQyxHQUFHLFNBQVU1aUssQ0FBQyxFQUFFNUUsQ0FBQztvQkFDZixPQUFPQTtnQkFDVDtZQUNGO1FBQ0Y7UUFBRztZQUNEckIsS0FBSztZQUNMVSxPQUFPLFNBQVMya0U7Z0JBQ2QsSUFBSSxDQUFDaW5HLFlBQVksR0FBRyxFQUFFO1lBQ3hCO1FBQ0Y7UUFBRztZQUNEdHNLLEtBQUs7WUFDTFUsT0FBTyxTQUFTK3JLO2dCQUNkLE9BQU8sSUFBSSxDQUFDSCxZQUFZLENBQUN4dEssTUFBTTtZQUNqQztRQUNGO1FBQUc7WUFDRGtCLEtBQUs7WUFDTFUsT0FBTyxTQUFTZ3NLO2dCQUNkLE9BQU8sSUFBSSxDQUFDSixZQUFZO1lBQzFCO1FBQ0Y7UUFBRztZQUNEdHNLLEtBQUs7WUFDTFUsT0FBTyxTQUFTaXNLLHFCQUFxQnhGLEtBQUs7Z0JBQ3hDLElBQUksSUFBSSxDQUFDbUYsWUFBWSxDQUFDeHRLLE1BQU0sS0FBSyxJQUFJLENBQUMrcEssa0JBQWtCLEVBQUU7b0JBQ3hELE9BQU8sSUFBSSxDQUFDeUQsWUFBWSxDQUFDamhCLFFBQVEsQ0FBQzhiO2dCQUNwQztnQkFDQSxPQUFPLE1BQU0sV0FBVztZQUMxQjtRQUNGO1FBQUc7WUFDRG5uSyxLQUFLO1lBQ0xVLE9BQU8sU0FBU2tzSyxzQkFBc0J6RixLQUFLO2dCQUN6QyxJQUFJMEYsVUFBVSxJQUFJLENBQUNQLFlBQVksQ0FBQzloSixPQUFPLENBQUMyOEk7Z0JBQ3hDLElBQUkwRixVQUFVLEdBQUc7b0JBQ2YsSUFBSSxJQUFJLENBQUNQLFlBQVksQ0FBQ3h0SyxNQUFNLEtBQUssSUFBSSxDQUFDK3BLLGtCQUFrQixFQUFFO3dCQUN4RCxNQUFNLElBQUkvMUosTUFBTTtvQkFDbEI7b0JBQ0EsSUFBSSxDQUFDdzVKLFlBQVksQ0FBQ2hySyxJQUFJLENBQUM2bEs7b0JBQ3ZCMEYsVUFBVSxJQUFJLENBQUNQLFlBQVksQ0FBQ3h0SyxNQUFNLEdBQUc7Z0JBQ3ZDO2dCQUNBLE9BQU8rdEs7WUFDVDtRQUNGO0tBQUU7QUFDSjtBQUVBLHlEQUF5RDtBQUN6RCxtREFBbUQ7QUFDbkQsa0RBQWtEO0FBRWxEOzs7Q0FHQyxHQUNELElBQUlDLFdBQVc7QUFFZjs7O0NBR0MsR0FDRCxJQUFJQyxjQUFjO0FBRWxCOzs7O0NBSUMsR0FDRCxJQUFJQyxtQkFBbUI7QUFFdkI7OztDQUdDLEdBQ0QsSUFBSUMsWUFBWTtBQUVoQjs7OztDQUlDLEdBQ0QsSUFBSUMsZ0JBQWdCO0lBQ2xCQyxRQUFRO1FBQ05ockssTUFBTTtRQUNOaXJLLFFBQVE7SUFDVjtJQUNBQyxTQUFTO1FBQ1BsckssTUFBTTtRQUNObXJLLFNBQVM7SUFDWDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxJQUFJQyxtQkFBbUI7SUFDckIsNERBQTREO0lBQzVEQyxRQUFRO0lBQ1Isa0NBQWtDO0lBQ2xDQyxRQUFRLEVBQUUsaURBQWlEO0FBQzdEO0FBRUEsZ0JBQWdCO0FBQ2hCLG1EQUFtRDtBQUNuRCxnR0FBZ0c7QUFDaEcsaUdBQWlHO0FBQ2pHLCtGQUErRjtBQUMvRixJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsZ0JBQWdCO0FBQ3BCLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLHlCQUF5QjtBQUM3QixJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsc0JBQXNCLFdBQVcsR0FBRTtJQUNyQzs7R0FFQyxHQUNELFNBQVNBLG9CQUFvQnR2SyxDQUFDLEVBQUVvK0osRUFBRSxFQUFFaDlJLElBQUk7UUFDdEMzZ0IsZ0JBQWdCLElBQUksRUFBRTZ1SztRQUN0QixJQUFJLENBQUN0dkssQ0FBQyxHQUFHQSxHQUFHLG1DQUFtQztRQUMvQyxJQUFJLENBQUNvK0osRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ21SLFlBQVksR0FBR251SixLQUFLK3lFLGNBQWM7UUFDdkMsSUFBSSxDQUFDNjFFLFNBQVMsR0FBRzVvSixLQUFLNHlFLFlBQVk7UUFDbEMsSUFBSSxDQUFDdzdFLE9BQU8sR0FBR3B1SixLQUFLb3VKLE9BQU87UUFDM0IsSUFBSSxDQUFDNzdFLEtBQUssR0FBR3Z5RSxLQUFLMHlFLFVBQVU7UUFDNUIsSUFBSSxDQUFDMjdFLGNBQWMsR0FBRyxFQUFFO1FBQ3hCcnVKLEtBQUtnbEosY0FBYyxHQUFHO1FBQ3RCaGxKLEtBQUttK0ksbUJBQW1CLEdBQUdBLHFCQUFxQix1QkFBdUI7UUFFdkUsSUFBSSxDQUFDbVEsWUFBWSxHQUFHLElBQUk1RixhQUFhOXBLLEdBQUdvaEI7UUFDeEMsSUFBSSxDQUFDdXVKLFlBQVksR0FBRyxJQUFJbEMsa0JBQWtCcnNKO1FBQzFDLElBQUksQ0FBQ3d1SixrQkFBa0IsR0FBRyxJQUFJbHRKO1FBQzlCLElBQUksQ0FBQ3c4SSxPQUFPLEdBQUcsSUFBSSxDQUFDMlEsb0JBQW9CLENBQUN2QixjQUFjQyxNQUFNO1FBQzdELElBQUksQ0FBQ3VCLGNBQWMsR0FBRyxJQUFJLENBQUNELG9CQUFvQixDQUFDdkIsY0FBY0csT0FBTztRQUNyRSxJQUFJLENBQUNzQixHQUFHLEdBQUcsSUFBSSxDQUFDQyxVQUFVO0lBQzVCO0lBRUE7OztHQUdDLEdBQ0QsT0FBTzN1SyxhQUFhaXVLLHFCQUFxQjtRQUFDO1lBQ3hDbHVLLEtBQUs7WUFDTFUsT0FBTyxTQUFTd29LLG1CQUFtQkMsY0FBYyxFQUFFbnBKLElBQUk7Z0JBQ3JELElBQUksQ0FBQ3N1SixZQUFZLENBQUNwRixrQkFBa0IsQ0FBQ0MsZ0JBQWdCbnBKO1lBQ3ZEO1FBbUJGO1FBQUc7WUFDRGhnQixLQUFLO1lBQ0xVLE9BQU8sU0FBU211SywwQkFBMEJDLFFBQVEsRUFBRTl1SixJQUFJO2dCQUN0RCxJQUFJLENBQUNzdUosWUFBWSxDQUFDN0UsYUFBYSxDQUFDcUYsVUFBVTl1SjtZQUM1QztRQXNCRjtRQUFHO1lBQ0RoZ0IsS0FBSztZQUNMVSxPQUFPLFNBQVNxdUsseUJBQXlCRCxRQUFRLEVBQUU5dUosSUFBSTtnQkFDckQsSUFBSSxDQUFDd3VKLGtCQUFrQixDQUFDenRKLEdBQUcsQ0FBQyt0SixVQUFVOXVKO1lBQ3hDO1FBTUY7UUFBRztZQUNEaGdCLEtBQUs7WUFDTFUsT0FBTyxTQUFTeTdJLFdBQVdod0gsSUFBSTtnQkFDN0IsSUFBSWxDLE9BQU83a0IsVUFBVXRHLE1BQU0sR0FBRyxLQUFLc0csU0FBUyxDQUFDLEVBQUUsS0FBS3ZELFlBQVl1RCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsR0FDOUV1TyxPQUFPc1csS0FBS3RXLElBQUk7Z0JBQ2xCLElBQUkyNkosZUFBZSxJQUFJLENBQUNBLFlBQVk7Z0JBQ3BDLElBQUkzNkosTUFBTTtvQkFDUixPQUFPMjZKLGFBQWFueUIsVUFBVSxDQUFDaHdILE1BQU07d0JBQ25DbytJLFlBQVksU0FBU0EsV0FBVy9xSyxDQUFDOzRCQUMvQixPQUFPQSxNQUFNbVU7d0JBQ2Y7d0JBQ0F3MkosYUFBYTtvQkFDZjtnQkFDRixPQUFPO29CQUNMLE9BQU9tRSxhQUFhbnlCLFVBQVUsQ0FBQ2h3SDtnQkFDakM7WUFDRjtRQUtGO1FBQUc7WUFDRG5zQixLQUFLO1lBQ0xVLE9BQU8sU0FBU29yRztnQkFDZCxJQUFJLENBQUN3aUUsWUFBWSxDQUFDeGlFLEVBQUU7WUFDdEI7UUFDRjtRQUFHO1lBQ0Q5ckcsS0FBSztZQUNMVSxPQUFPLFNBQVMrdEsscUJBQXFCTyxZQUFZO2dCQUMvQyxJQUFJaFMsS0FBSyxJQUFJLENBQUNBLEVBQUU7Z0JBQ2hCLElBQUlpUyxxQkFBcUIsc2pEQUFzakRwbEosTUFBTSxDQUFDNmpKLFNBQVMsd2xCQUF3bEI3akosTUFBTSxDQUFDaWtKLFdBQVcscUJBQXFCamtKLE1BQU0sQ0FBQ29rSixTQUFTLG9DQUFvQ3BrSixNQUFNLENBQUNra0osaUJBQWlCLHFCQUFxQmxrSixNQUFNLENBQUNta0osd0JBQXdCLHlwQkFBeXBCbmtKLE1BQU0sQ0FBQzhqSixlQUFlLDhtQkFBOG1COWpKLE1BQU0sQ0FBQytqSixvQkFBb0IscTNEQUFxM0QvakosTUFBTSxDQUFDZ2tKLFlBQVk7Z0JBQzloTCxJQUFJcUIsT0FBTyxJQUFJLENBQUNYLFlBQVksQ0FBQy9CLGFBQWE7Z0JBQzFDLElBQUkyQyx1QkFBdUIsNkhBQTZIdGxKLE1BQU0sQ0FBQ3FsSixLQUFLcjhKLEdBQUcsQ0FBQyxTQUFVeFIsQ0FBQztvQkFDakwsT0FBTyw2QkFBNkJ3b0IsTUFBTSxDQUFDeG9CLEdBQUc7Z0JBQ2hELEdBQUdpRSxJQUFJLENBQUMsUUFBUyxxY0FBcWN1a0IsTUFBTSxDQUFDaWpKLFVBQVUsWUFBWWpqSixNQUFNLENBQUNrakosYUFBYSxZQUFZbGpKLE1BQU0sQ0FBQ21qSixrQkFBa0IsWUFBWW5qSixNQUFNLENBQUNvakosV0FBVywwbUJBQTBtQnBqSixNQUFNLENBQUM2akosU0FBUyx5RUFBeUU3akosTUFBTSxDQUFDcWxKLEtBQUtyOEosR0FBRyxDQUFDLFNBQVV4UixDQUFDO29CQUN0eUMsT0FBTyxrQkFBa0J3b0IsTUFBTSxDQUFDeG9CLEdBQUcsaUNBQWlDd29CLE1BQU0sQ0FBQ3hvQixHQUFHO2dCQUNoRixHQUFHaUUsSUFBSSxDQUFDLGFBQWMsK0NBQStDdWtCLE1BQU0sQ0FBQ2drSixZQUFZLDRRQUE0UWhrSixNQUFNLENBQUNpa0osV0FBVyxxT0FBcU9qa0osTUFBTSxDQUFDaWtKLFdBQVcscUJBQXFCamtKLE1BQU0sQ0FBQ29rSixTQUFTLGlDQUFpQ3BrSixNQUFNLENBQUNra0osaUJBQWlCLHFCQUFxQmxrSixNQUFNLENBQUNta0osd0JBQXdCLCtpQkFBK2lCbmtKLE1BQU0sQ0FBQ2lrSixXQUFXLDhFQUE4RWprSixNQUFNLENBQUNva0osU0FBUyw4R0FBOEdwa0osTUFBTSxDQUFDb2tKLFNBQVMsKzFDQUErMUNwa0osTUFBTSxDQUFDbWxKLGFBQWExQixPQUFPLEdBQUcseUVBQXlFLElBQUk7Z0JBQ3QrRixJQUFJeFAsVUFBVVAsY0FBY1AsSUFBSWlTLG9CQUFvQkU7Z0JBRXBELG9CQUFvQjtnQkFDcEJyUixRQUFRc1IsU0FBUyxHQUFHcFMsR0FBR3FTLGlCQUFpQixDQUFDdlIsU0FBUztnQkFFbEQsYUFBYTtnQkFDYkEsUUFBUXdSLE1BQU0sR0FBR3RTLEdBQUdxUyxpQkFBaUIsQ0FBQ3ZSLFNBQVM7Z0JBQy9DQSxRQUFReVIsU0FBUyxHQUFHdlMsR0FBR3FTLGlCQUFpQixDQUFDdlIsU0FBUztnQkFDbERBLFFBQVEwUixVQUFVLEdBQUd4UyxHQUFHcVMsaUJBQWlCLENBQUN2UixTQUFTO2dCQUNuREEsUUFBUTJSLFFBQVEsR0FBR3pTLEdBQUdxUyxpQkFBaUIsQ0FBQ3ZSLFNBQVM7Z0JBQ2pEQSxRQUFRNFIsSUFBSSxHQUFHMVMsR0FBR3FTLGlCQUFpQixDQUFDdlIsU0FBUztnQkFDN0NBLFFBQVE2UixhQUFhLEdBQUczUyxHQUFHcVMsaUJBQWlCLENBQUN2UixTQUFTO2dCQUN0REEsUUFBUThSLGFBQWEsR0FBRzVTLEdBQUdxUyxpQkFBaUIsQ0FBQ3ZSLFNBQVM7Z0JBQ3REQSxRQUFRK1IsVUFBVSxHQUFHN1MsR0FBR3FTLGlCQUFpQixDQUFDdlIsU0FBUztnQkFDbkRBLFFBQVFnUyxNQUFNLEdBQUc5UyxHQUFHcVMsaUJBQWlCLENBQUN2UixTQUFTO2dCQUMvQ0EsUUFBUWlTLGFBQWEsR0FBRy9TLEdBQUdxUyxpQkFBaUIsQ0FBQ3ZSLFNBQVM7Z0JBQ3REQSxRQUFRa1MsWUFBWSxHQUFHaFQsR0FBR3FTLGlCQUFpQixDQUFDdlIsU0FBUztnQkFFckQsV0FBVztnQkFDWEEsUUFBUW1TLGNBQWMsR0FBR2pULEdBQUdrVCxrQkFBa0IsQ0FBQ3BTLFNBQVM7Z0JBQ3hEQSxRQUFRcVMsVUFBVSxHQUFHblQsR0FBR2tULGtCQUFrQixDQUFDcFMsU0FBUztnQkFDcERBLFFBQVFzUyxRQUFRLEdBQUdwVCxHQUFHa1Qsa0JBQWtCLENBQUNwUyxTQUFTO2dCQUNsREEsUUFBUXVTLEtBQUssR0FBR3JULEdBQUdrVCxrQkFBa0IsQ0FBQ3BTLFNBQVM7Z0JBQy9DQSxRQUFRd1MsU0FBUyxHQUFHLEVBQUU7Z0JBQ3RCLElBQUssSUFBSWp2SyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDa3RLLFlBQVksQ0FBQ2hDLHFCQUFxQixJQUFJbHJLLElBQUs7b0JBQ2xFeThKLFFBQVF3UyxTQUFTLENBQUNodkssSUFBSSxDQUFDMDdKLEdBQUdrVCxrQkFBa0IsQ0FBQ3BTLFNBQVMsV0FBV2owSSxNQUFNLENBQUN4b0I7Z0JBQzFFO2dCQUNBLE9BQU95OEo7WUFDVDtRQUNGO1FBQUc7WUFDRDk5SixLQUFLO1lBQ0xVLE9BQU8sU0FBU2t1SztnQkFDZCxJQUFJMkIsYUFBYTtvQkFBQztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztpQkFBRTtnQkFDckQsSUFBSSxDQUFDQyxXQUFXLEdBQUdELFdBQVd6eEssTUFBTSxHQUFHO2dCQUN2QyxJQUFJRSxJQUFJLElBQUksQ0FBQ212SyxZQUFZO2dCQUN6QixJQUFJblIsS0FBSyxJQUFJLENBQUNBLEVBQUUsRUFDZGMsVUFBVSxJQUFJLENBQUNBLE9BQU87Z0JBQ3hCLElBQUk2USxNQUFNM1IsR0FBR3lULGlCQUFpQjtnQkFDOUJ6VCxHQUFHMFQsZUFBZSxDQUFDL0I7Z0JBQ25CL04sdUJBQXVCNUQsSUFBSSxRQUFRYyxRQUFRc1IsU0FBUyxFQUFFbUI7Z0JBRXRELHdDQUF3QztnQkFDeEMsSUFBSSxDQUFDSSxlQUFlLEdBQUd0TyxpQ0FBaUNyRixJQUFJaCtKLEdBQUc4K0osUUFBUTBSLFVBQVU7Z0JBQ2pGLElBQUksQ0FBQ29CLFdBQVcsR0FBR25QLHdCQUF3QnpFLElBQUloK0osR0FBRyxRQUFROCtKLFFBQVF3UixNQUFNO2dCQUN4RSxJQUFJLENBQUN1QixjQUFjLEdBQUdwUCx3QkFBd0J6RSxJQUFJaCtKLEdBQUcsT0FBTzgrSixRQUFReVIsU0FBUztnQkFDN0UsSUFBSSxDQUFDdUIsYUFBYSxHQUFHclAsd0JBQXdCekUsSUFBSWgrSixHQUFHLE9BQU84K0osUUFBUTJSLFFBQVE7Z0JBQzNFLElBQUksQ0FBQ3NCLFNBQVMsR0FBR3RQLHdCQUF3QnpFLElBQUloK0osR0FBRyxRQUFROCtKLFFBQVE0UixJQUFJO2dCQUNwRSxJQUFJLENBQUNzQixrQkFBa0IsR0FBR3ZQLHdCQUF3QnpFLElBQUloK0osR0FBRyxRQUFROCtKLFFBQVE2UixhQUFhO2dCQUN0RixJQUFJLENBQUNzQixrQkFBa0IsR0FBR3hQLHdCQUF3QnpFLElBQUloK0osR0FBRyxRQUFROCtKLFFBQVE4UixhQUFhO2dCQUN0RixJQUFJLENBQUNzQixlQUFlLEdBQUd6UCx3QkFBd0J6RSxJQUFJaCtKLEdBQUcsUUFBUTgrSixRQUFRK1IsVUFBVTtnQkFDaEYsSUFBSSxDQUFDc0IsV0FBVyxHQUFHMVAsd0JBQXdCekUsSUFBSWgrSixHQUFHLFFBQVE4K0osUUFBUWdTLE1BQU07Z0JBQ3hFLElBQUksQ0FBQ3NCLGtCQUFrQixHQUFHM1Asd0JBQXdCekUsSUFBSWgrSixHQUFHLFFBQVE4K0osUUFBUWlTLGFBQWE7Z0JBQ3RGLElBQUksQ0FBQ3NCLGlCQUFpQixHQUFHNVAsd0JBQXdCekUsSUFBSWgrSixHQUFHLFFBQVE4K0osUUFBUWtTLFlBQVk7Z0JBQ3BGaFQsR0FBRzBULGVBQWUsQ0FBQztnQkFDbkIsT0FBTy9CO1lBQ1Q7UUFDRjtRQUFHO1lBQ0QzdUssS0FBSztZQUNMb2hCLEtBQUssU0FBU0E7Z0JBQ1osSUFBSVUsUUFBUSxJQUFJO2dCQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDd3ZKLFFBQVEsRUFBRTtvQkFDbEIsSUFBSSxDQUFDQSxRQUFRLEdBQUd6eEssT0FBTzRILElBQUksQ0FBQyxJQUFJLEVBQUVzYSxNQUFNLENBQUMsU0FBVXBjLENBQUM7d0JBQ2xELE9BQU9lLFNBQVNmLEdBQUc7b0JBQ3JCLEdBQUdrTixHQUFHLENBQUMsU0FBVWxOLENBQUM7d0JBQ2hCLE9BQU9tYyxLQUFLLENBQUNuYyxFQUFFO29CQUNqQjtnQkFDRjtnQkFDQSxPQUFPLElBQUksQ0FBQzJySyxRQUFRO1lBQ3RCO1FBQ0Y7UUFBRztZQUNEdHhLLEtBQUs7WUFDTFUsT0FBTyxTQUFTNndLLFdBQVdDLGFBQWE7Z0JBQ3RDLElBQUl4QyxlQUFlNXBLLFVBQVV0RyxNQUFNLEdBQUcsS0FBS3NHLFNBQVMsQ0FBQyxFQUFFLEtBQUt2RCxZQUFZdUQsU0FBUyxDQUFDLEVBQUUsR0FBRzhuSyxjQUFjQyxNQUFNO2dCQUMzRyxJQUFJLENBQUNxRSxhQUFhLEdBQUdBO2dCQUNyQixJQUFJLENBQUN4QyxZQUFZLEdBQUdBO2dCQUNwQixJQUFJLENBQUNYLGNBQWMsR0FBRyxFQUFFO2dCQUN4QixJQUFJLENBQUNvRCxZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO2dCQUNuQixJQUFJLENBQUNyc0csVUFBVTtZQUNqQjtRQUNGO1FBQUc7WUFDRHJsRSxLQUFLO1lBQ0xVLE9BQU8sU0FBUzJrRTtnQkFDZCxJQUFJLENBQUNzc0csYUFBYSxHQUFHO2dCQUNyQixJQUFJLENBQUNwRCxZQUFZLENBQUNscEcsVUFBVTtZQUM5QjtRQUNGO1FBQUc7WUFDRHJsRSxLQUFLO1lBQ0xVLE9BQU8sU0FBU2t4SztnQkFDZCxJQUFJLENBQUNyc0csUUFBUTtZQUNmO1FBQ0Y7UUFBRztZQUNEdmxFLEtBQUs7WUFDTFUsT0FBTyxTQUFTbXhLLFdBQVd6eEosR0FBRyxFQUFFSixJQUFJO2dCQUNsQyxJQUFJSSxJQUFJZzVDLE9BQU8sSUFBSTtvQkFDakIsSUFBSXA1QyxRQUFRQSxLQUFLKzlILFNBQVMsRUFBRTt3QkFDMUIsT0FBTy85SCxLQUFLKzlILFNBQVMsQ0FBQzM5SDtvQkFDeEI7b0JBQ0EsT0FBTztnQkFDVDtnQkFDQSxPQUFPO1lBQ1Q7UUFLRjtRQUFHO1lBQ0RwZ0IsS0FBSztZQUNMVSxPQUFPLFNBQVNveEssWUFBWTF4SixHQUFHLEVBQUUyeEosUUFBUSxFQUFFcCtKLElBQUk7Z0JBQzdDLElBQUkyNkosZUFBZSxJQUFJLENBQUNBLFlBQVksRUFDbENDLGVBQWUsSUFBSSxDQUFDQSxZQUFZO2dCQUNsQyxJQUFJdnVKLE9BQU9zdUosYUFBYTNFLGlCQUFpQixDQUFDaDJKO2dCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDaytKLFVBQVUsQ0FBQ3p4SixLQUFLSixPQUFPO29CQUMvQjtnQkFDRjtnQkFFQSwwRUFBMEU7Z0JBQzFFLGtHQUFrRztnQkFDbEcsd0RBQXdEO2dCQUN4RCxJQUFJSSxJQUFJbTZCLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQ3kzSCxZQUFZLENBQUM1eEosTUFBTTtvQkFDM0M7Z0JBQ0Y7Z0JBQ0EsSUFBSSxJQUFJLENBQUM0dUosWUFBWSxDQUFDMUIsT0FBTyxJQUFJdHRKLEtBQUtpeUosaUJBQWlCLEVBQUU7b0JBQ3ZELElBQUlsL0gsT0FBTy95QixLQUFLaXlKLGlCQUFpQixDQUFDN3hKO29CQUNsQyxJQUFJMnlCLFNBQVN3NkgsaUJBQWlCQyxNQUFNLEVBQUU7d0JBQ3BDO29CQUNGLE9BQU8sSUFBSXo2SCxRQUFRdzZILGlCQUFpQkUsTUFBTSxFQUFFO3dCQUMxQyxJQUFJLENBQUN5RSxvQkFBb0IsQ0FBQzl4SixLQUFLMnhKLFVBQVVwK0o7d0JBQ3pDO29CQUNGO2dCQUNGO2dCQUVBLCtGQUErRjtnQkFDL0YsMkVBQTJFO2dCQUMzRSxJQUFJdytKLGlCQUFpQjdELGFBQWE5QyxZQUFZLENBQUNwckosS0FBS3pNO2dCQUNwRCxJQUFJNjBCLFlBQVlyb0MsMkJBQTJCZ3lLLGlCQUN6QzFwSTtnQkFDRixJQUFJO29CQUNGLElBQUtELFVBQVVob0MsQ0FBQyxJQUFJLENBQUMsQ0FBQ2lvQyxRQUFRRCxVQUFVeHBDLENBQUMsRUFBQyxFQUFHeUIsSUFBSSxFQUFHO3dCQUNsRCxJQUFJMnhLLFlBQVkzcEksTUFBTS9uQyxLQUFLO3dCQUMzQixJQUFJeW1LLFFBQVFpTCxVQUFVakwsS0FBSyxFQUN6QnlFLE9BQU93RyxVQUFVeEcsSUFBSSxFQUNyQkMsT0FBT3VHLFVBQVV2RyxJQUFJLEVBQUUsNkRBQTZEO3dCQUV0RixJQUFJLENBQUMwQyxhQUFhNUIsb0JBQW9CLENBQUN4RixRQUFROzRCQUM3QyxJQUFJLENBQUM1aEcsUUFBUTt3QkFDZjt3QkFDQSxJQUFJOHNHLGFBQWE5RCxhQUFhM0IscUJBQXFCLENBQUN6Rjt3QkFDcEQsSUFBSyxJQUFJcC9JLEtBQUssR0FBR3VxSixPQUFPOzRCQUFDO2dDQUFDMUc7Z0NBQU07NkJBQUs7NEJBQUU7Z0NBQUNDO2dDQUFNOzZCQUFNO3lCQUFDLEVBQUU5akosS0FBS3VxSixLQUFLeHpLLE1BQU0sRUFBRWlwQixLQUFNOzRCQUM3RSxJQUFJd3FKLFVBQVU5d0ssZUFBZTZ3SyxJQUFJLENBQUN2cUosR0FBRyxFQUFFLElBQ3JDK2pKLE1BQU15RyxPQUFPLENBQUMsRUFBRSxFQUNoQnozRixRQUFReTNGLE9BQU8sQ0FBQyxFQUFFOzRCQUNwQixJQUFJekcsSUFBSS90SixDQUFDLElBQUksR0FBRztnQ0FDZCxJQUFJeTBKLFdBQVcsSUFBSSxDQUFDYixhQUFhO2dDQUNqQyxJQUFJLENBQUNkLGNBQWMsQ0FBQzVPLE9BQU8sQ0FBQ3VRLFNBQVMsQ0FBQyxFQUFFLEdBQUc5RTtnQ0FDM0MsSUFBSStFLFlBQVksSUFBSSxDQUFDN0IsV0FBVyxDQUFDM08sT0FBTyxDQUFDdVE7Z0NBQ3pDOVQsWUFBWXFULFVBQVVVO2dDQUV0QixxRUFBcUU7Z0NBQ3JFLElBQUlDLGNBQWMsSUFBSSxDQUFDNUIsYUFBYSxDQUFDN08sT0FBTyxDQUFDdVE7Z0NBQzdDRSxXQUFXLENBQUMsRUFBRSxHQUFHTDtnQ0FFakIsZ0dBQWdHO2dDQUNoRyxJQUFJTSxVQUFVLElBQUksQ0FBQzVCLFNBQVMsQ0FBQzlPLE9BQU8sQ0FBQ3VRO2dDQUNyQ0csT0FBTyxDQUFDLEVBQUUsR0FBRzdHLElBQUkxNEosQ0FBQztnQ0FDbEJ1L0osT0FBTyxDQUFDLEVBQUUsR0FBRzdHLElBQUlqdkosQ0FBQztnQ0FDbEI4MUosT0FBTyxDQUFDLEVBQUUsR0FBRzdHLElBQUkvdEosQ0FBQztnQ0FDbEI0MEosT0FBTyxDQUFDLEVBQUUsR0FBRzdHLElBQUkzakssQ0FBQztnQ0FDbEIsSUFBSXlxSyxhQUFhLElBQUksQ0FBQ2pDLGVBQWUsQ0FBQy9OLGFBQWEsQ0FBQzRQO2dDQUNwRCxJQUFJLENBQUNLLGtCQUFrQixDQUFDenlKLEtBQUt3eUosWUFBWTV5SixNQUFNb3lKLFdBQVd0M0Y7Z0NBQzFELElBQUksQ0FBQzYyRixhQUFhO2dDQUNsQixJQUFJLENBQUM3MkYsT0FBTyxJQUFJLENBQUMyMkYsWUFBWTtnQ0FDN0IsSUFBSSxJQUFJLENBQUNFLGFBQWEsSUFBSSxJQUFJLENBQUN4RCxZQUFZLEVBQUU7b0NBQzNDLElBQUksQ0FBQzVvRyxRQUFRO2dDQUNmOzRCQUNGO3dCQUNGO29CQUNGO2dCQUNGLEVBQUUsT0FBTzM4QixLQUFLO29CQUNaSixVQUFVenBDLENBQUMsQ0FBQzZwQztnQkFDZCxTQUFVO29CQUNSSixVQUFVN25DLENBQUM7Z0JBQ2I7WUFDRjtRQU1GO1FBQUc7WUFDRFgsS0FBSztZQUNMVSxPQUFPLFNBQVNteUssbUJBQW1CenlKLEdBQUcsRUFBRXNwQixNQUFNLEVBQUUxcEIsSUFBSSxFQUFFb3lKLFNBQVM7Z0JBQzdELElBQUl0M0YsUUFBUTExRSxVQUFVdEcsTUFBTSxHQUFHLEtBQUtzRyxTQUFTLENBQUMsRUFBRSxLQUFLdkQsWUFBWXVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7Z0JBQ2hGLElBQUkwMEIsVUFBVTtnQkFDZCxJQUFJOVosS0FBSzh5SixVQUFVLElBQUk5eUosS0FBSzh5SixVQUFVLENBQUNoNUksT0FBTyxFQUFFO29CQUM5Q0EsVUFBVTFaLElBQUk0bUQsTUFBTSxDQUFDaG5ELEtBQUs4eUosVUFBVSxDQUFDaDVJLE9BQU8sRUFBRW10QyxPQUFPO2dCQUN2RDtnQkFDQSxJQUFJbXJHLFdBQVc7b0JBQ2IsNkRBQTZEO29CQUM3RCxJQUFJOTRJLEtBQUs4NEksVUFBVTk0SSxFQUFFLEVBQ25Cc3lJLE9BQU93RyxVQUFVeEcsSUFBSSxFQUNyQkMsT0FBT3VHLFVBQVV2RyxJQUFJO29CQUN2QixzREFBc0Q7b0JBQ3RELElBQUlrSCxRQUFRbkgsS0FBSzd0SixDQUFDLEdBQUk2dEosQ0FBQUEsS0FBSzd0SixDQUFDLEdBQUc4dEosS0FBSzl0SixDQUFDO29CQUNyQyxJQUFJLENBQUMrOEQsT0FBTzt3QkFDViwrREFBK0Q7d0JBQy9EaTRGLFFBQVEsSUFBSUE7b0JBQ2Q7b0JBQ0EsSUFBSUMsUUFBUSxJQUFJLENBQUNDLGNBQWMsQ0FBQzM1SSxJQUFJUSxTQUFTZ2hELE9BQU9pNEY7b0JBQ3BELElBQUksQ0FBQ0cscUJBQXFCLENBQUN4cEksUUFBUXNwSSxPQUFPaHpKLE1BQU1JO2dCQUNsRCxPQUFPO29CQUNMLG9GQUFvRjtvQkFDcEYsSUFBSSt5SixNQUFNbnpKLEtBQUs0OUgsY0FBYyxDQUFDeDlIO29CQUM5QixJQUFJZ3pKLFNBQVMsSUFBSSxDQUFDSCxjQUFjLENBQUNFLEtBQUtyNUksU0FBUyxNQUFNO29CQUNyRCxJQUFJLENBQUNvNUkscUJBQXFCLENBQUN4cEksUUFBUTBwSSxRQUFRcHpKLE1BQU1JO2dCQUNuRDtZQUNGO1FBQ0Y7UUFBRztZQUNEcGdCLEtBQUs7WUFDTFUsT0FBTyxTQUFTd3lLLHNCQUFzQnhwSSxNQUFNLEVBQUVzcEksS0FBSyxFQUFFaHpKLElBQUksRUFBRUksR0FBRztnQkFDNUQsSUFBSWhOLEdBQUd5SjtnQkFDUHUwQixTQUFTMUg7Z0JBQ1QsSUFBSTZoQyxRQUFRdnJELEtBQUtrb0ksV0FBVyxHQUFHbG9JLEtBQUtrb0ksV0FBVyxDQUFDOW5JLE9BQU87Z0JBQ3ZELElBQUltckQsVUFBVSxHQUFHO29CQUNmLElBQUk4bkcsd0JBQXdCcnpKLEtBQUs2OUgsZ0JBQWdCLENBQUN6OUgsTUFDaEQrbUIsS0FBS2tzSSxzQkFBc0JqZ0ssQ0FBQyxFQUM1QmcwQixLQUFLaXNJLHNCQUFzQngySixDQUFDO29CQUM5Qm9rSSxVQUFVdjNHLFFBQVFBLFFBQVE7d0JBQUN2Qzt3QkFBSUM7cUJBQUc7b0JBQ2xDc2tDLE9BQU9oaUMsUUFBUUEsUUFBUTZoQztvQkFDdkIsSUFBSWhyQyxTQUFTdmdCLEtBQUs4OUgsaUJBQWlCLENBQUMxOUg7b0JBQ3BDaE4sSUFBSW10QixPQUFPbnRCLENBQUMsR0FBSTQvSixDQUFBQSxNQUFNbE4sT0FBTyxJQUFJO29CQUNqQ2pwSixJQUFJMGpCLE9BQU8xakIsQ0FBQyxHQUFJbTJKLENBQUFBLE1BQU1qTixPQUFPLElBQUk7Z0JBQ25DLE9BQU87b0JBQ0wzeUosSUFBSTQvSixNQUFNdHVLLEVBQUU7b0JBQ1ptWSxJQUFJbTJKLE1BQU1wdUssRUFBRTtnQkFDZDtnQkFDQXE4SSxVQUFVdjNHLFFBQVFBLFFBQVE7b0JBQUN0MkI7b0JBQUd5SjtpQkFBRTtnQkFDaENpZSxNQUFNNE8sUUFBUUEsUUFBUTtvQkFBQ3NwSSxNQUFNajFKLENBQUM7b0JBQUVpMUosTUFBTTdxSyxDQUFDO2lCQUFDO1lBQzFDO1FBU0Y7UUFBRztZQUNEbkksS0FBSztZQUNMVSxPQUFPLFNBQVN1eUssZUFBZTM1SSxFQUFFLEVBQUVRLE9BQU8sRUFBRWdoRCxLQUFLLEVBQUVpNEYsS0FBSztnQkFDdEQsSUFBSXJ1SyxLQUFLNDBCLEdBQUc1MEIsRUFBRSxFQUNaRSxLQUFLMDBCLEdBQUcxMEIsRUFBRSxFQUNWbVosSUFBSXViLEdBQUd2YixDQUFDLEVBQ1I1VixJQUFJbXhCLEdBQUdueEIsQ0FBQyxFQUNSNDlKLFVBQVV6c0ksR0FBR3lzSSxPQUFPO2dCQUN0QixJQUFJanNJLFNBQVM7b0JBQ1hwMUIsTUFBTW8xQjtvQkFDTmwxQixNQUFNazFCO29CQUNOL2IsS0FBSyxJQUFJK2I7b0JBQ1QzeEIsS0FBSyxJQUFJMnhCO2dCQUNYO2dCQUNBLElBQUlnc0ksVUFBVTtnQkFDZCxJQUFJd04sT0FBT3YxSixJQUFJZzFKO2dCQUNmLElBQUlqNEYsU0FBU2k0RixRQUFRLEdBQUc7b0JBQ3RCaDFKLElBQUl1MUo7Z0JBQ04sT0FBTyxJQUFJLENBQUN4NEYsU0FBU2k0RixRQUFRLEdBQUc7b0JBQzlCak4sVUFBVS9uSixJQUFJdTFKO29CQUNkNXVLLE1BQU1vaEs7b0JBQ04vbkosSUFBSXUxSjtnQkFDTjtnQkFDQSxPQUFPO29CQUNMNXVLLElBQUlBO29CQUNKRSxJQUFJQTtvQkFDSm1aLEdBQUdBO29CQUNINVYsR0FBR0E7b0JBQ0gyOUosU0FBU0E7b0JBQ1RDLFNBQVNBO2dCQUNYO1lBQ0Y7UUFNRjtRQUFHO1lBQ0QvbEssS0FBSztZQUNMVSxPQUFPLFNBQVN3eEsscUJBQXFCOXhKLEdBQUcsRUFBRTJ4SixRQUFRLEVBQUVwK0osSUFBSTtnQkFDdEQsSUFBSXFNLE9BQU8sSUFBSSxDQUFDc3VKLFlBQVksQ0FBQzNFLGlCQUFpQixDQUFDaDJKO2dCQUMvQyxJQUFJNitKLFdBQVcsSUFBSSxDQUFDYixhQUFhO2dCQUNqQyxJQUFJLENBQUNkLGNBQWMsQ0FBQzVPLE9BQU8sQ0FBQ3VRLFNBQVMsQ0FBQyxFQUFFLEdBQUcxRTtnQkFDM0MsSUFBSTJFLFlBQVksSUFBSSxDQUFDN0IsV0FBVyxDQUFDM08sT0FBTyxDQUFDdVE7Z0JBQ3pDOVQsWUFBWXFULFVBQVVVO2dCQUN0QixJQUFJYyxZQUFZLElBQUksQ0FBQ3BDLFdBQVcsQ0FBQ2xQLE9BQU8sQ0FBQ3VRO2dCQUN6Q2hVLGFBQWE7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUUsRUFBRSxHQUFHK1UsWUFBWSwwQ0FBMEM7Z0JBRWpGLElBQUlYLGFBQWEsSUFBSSxDQUFDakMsZUFBZSxDQUFDL04sYUFBYSxDQUFDNFA7Z0JBQ3BELElBQUksQ0FBQ0ssa0JBQWtCLENBQUN6eUosS0FBS3d5SixZQUFZNXlKO2dCQUN6QyxJQUFJLENBQUMweEosV0FBVztnQkFDaEIsSUFBSSxDQUFDQyxhQUFhO2dCQUNsQixJQUFJLElBQUksQ0FBQ0EsYUFBYSxJQUFJLElBQUksQ0FBQ3hELFlBQVksRUFBRTtvQkFDM0MsSUFBSSxDQUFDNW9HLFFBQVE7Z0JBQ2Y7WUFDRjtRQUtGO1FBQUc7WUFDRHZsRSxLQUFLO1lBQ0xVLE9BQU8sU0FBUzhtSixTQUFTeC9ILElBQUksRUFBRStwSixRQUFRLEVBQUVwK0osSUFBSTtnQkFDM0MsSUFBSXFNLE9BQU8sSUFBSSxDQUFDd3VKLGtCQUFrQixDQUFDcHRKLEdBQUcsQ0FBQ3pOO2dCQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDaytKLFVBQVUsQ0FBQzdwSixNQUFNaEksT0FBTztvQkFDaEM7Z0JBQ0Y7Z0JBQ0EsSUFBSWk5QixRQUFRajlCLEtBQUs4eUosVUFBVTtnQkFFM0Isb0NBQW9DO2dCQUNwQyxJQUFJVSxXQUFXLElBQUksQ0FBQ0Msb0JBQW9CLENBQUN6ckosTUFBTWkxQixNQUFNeXZCLEtBQUs7Z0JBQzFELElBQUk4bUcsYUFBYTN4SyxhQUFhbWUsS0FBS3k1QyxRQUFRLElBQUksQ0FBQ3o1QyxLQUFLeTVDLFFBQVEsQ0FBQ3p4QyxPQUFPO29CQUNuRSxJQUFJLENBQUM4cEosV0FBVyxDQUFDOXBKLE1BQU0rcEosVUFBVXArSjtvQkFDakM7Z0JBQ0Y7Z0JBRUEsNkRBQTZEO2dCQUM3RCxJQUFJNitKLFdBQVcsSUFBSSxDQUFDYixhQUFhO2dCQUNqQyxJQUFJLENBQUNkLGNBQWMsQ0FBQzVPLE9BQU8sQ0FBQ3VRLFNBQVMsQ0FBQyxFQUFFLEdBQUdnQjtnQkFDM0MsSUFBSUEsYUFBYXpGLG1CQUFtQnlGLGFBQWF4Rix3QkFBd0I7b0JBQ3ZFLG9CQUFvQjtvQkFDcEIsSUFBSTEwSSxLQUFLdFosS0FBSzQ5SCxjQUFjLENBQUM1MUg7b0JBQzdCLElBQUl5VSxTQUFTLElBQUksQ0FBQ2kzSSxnQkFBZ0IsQ0FBQzFySixNQUFNaTFCLE1BQU14Z0IsTUFBTSxFQUFFbkQ7b0JBQ3ZELElBQUlxNkksYUFBYSxJQUFJLENBQUN2QyxrQkFBa0IsQ0FBQ25QLE9BQU8sQ0FBQ3VRO29CQUNqRG1CLFVBQVUsQ0FBQyxFQUFFLEdBQUdsM0ksUUFBUSxZQUFZO29CQUNwQ2szSSxVQUFVLENBQUMsRUFBRSxHQUFHbDNJLFFBQVEsZUFBZTtvQkFDdkNrM0ksVUFBVSxDQUFDLEVBQUUsR0FBR2wzSSxRQUFRLFdBQVc7b0JBQ25DazNJLFVBQVUsQ0FBQyxFQUFFLEdBQUdsM0ksUUFBUSxjQUFjO29CQUN0QyxJQUFJKzJJLGFBQWF4Rix3QkFBd0I7d0JBQ3ZDMkYsVUFBVSxDQUFDLEVBQUUsR0FBRzt3QkFDaEJBLFVBQVUsQ0FBQyxFQUFFLEdBQUc7b0JBQ2xCO2dCQUNGO2dCQUNBLElBQUlsQixZQUFZLElBQUksQ0FBQzdCLFdBQVcsQ0FBQzNPLE9BQU8sQ0FBQ3VRO2dCQUN6QzlULFlBQVlxVCxVQUFVVTtnQkFDdEIsSUFBSXJwSyxRQUFRNGUsS0FBS2cvQyxNQUFNLENBQUMvcEIsTUFBTTd6QyxLQUFLLEVBQUUxSSxLQUFLO2dCQUMxQyxJQUFJNHJFLFVBQVV0a0QsS0FBS2cvQyxNQUFNLENBQUMvcEIsTUFBTXF2QixPQUFPLEVBQUU1ckUsS0FBSztnQkFDOUMsSUFBSTZ5SyxZQUFZLElBQUksQ0FBQ3BDLFdBQVcsQ0FBQ2xQLE9BQU8sQ0FBQ3VRO2dCQUN6Q2hVLGFBQWFwMUosT0FBT2tqRSxTQUFTaW5HO2dCQUM3QixJQUFJSyxnQkFBZ0IsSUFBSSxDQUFDMUMsZUFBZSxDQUFDalAsT0FBTyxDQUFDdVEsV0FBVyxrREFBa0Q7Z0JBQzlHb0IsYUFBYSxDQUFDLEVBQUUsR0FBRztnQkFDbkJBLGFBQWEsQ0FBQyxFQUFFLEdBQUc7Z0JBQ25CLElBQUkzMkgsTUFBTTIwQixNQUFNLEVBQUU7b0JBQ2hCLElBQUluSCxjQUFjemlELEtBQUtnL0MsTUFBTSxDQUFDLGdCQUFnQnRtRSxLQUFLO29CQUNuRCxJQUFJK3BFLGNBQWMsR0FBRzt3QkFDbkIsSUFBSXdvRixjQUFjanJJLEtBQUtnL0MsTUFBTSxDQUFDLGdCQUFnQnRtRSxLQUFLO3dCQUNuRCxJQUFJeXNFLGdCQUFnQm5sRCxLQUFLZy9DLE1BQU0sQ0FBQyxrQkFBa0J0bUUsS0FBSzt3QkFDdkQsSUFBSW16SyxrQkFBa0IsSUFBSSxDQUFDeEMsaUJBQWlCLENBQUNwUCxPQUFPLENBQUN1UTt3QkFDckRoVSxhQUFhdkwsYUFBYTlsRixlQUFlMG1HO3dCQUV6QyxpRUFBaUU7d0JBQ2pFLElBQUlsaUcsWUFBWTNwRCxLQUFLZy9DLE1BQU0sQ0FBQyxtQkFBbUJ0bUUsS0FBSzt3QkFDcEQsSUFBSWl4RSxjQUFjLFVBQVU7NEJBQzFCaWlHLGFBQWEsQ0FBQyxFQUFFLEdBQUc7NEJBQ25CQSxhQUFhLENBQUMsRUFBRSxHQUFHLENBQUNucEc7d0JBQ3RCLE9BQU8sSUFBSWtILGNBQWMsV0FBVzs0QkFDbENpaUcsYUFBYSxDQUFDLEVBQUUsR0FBR25wRzs0QkFDbkJtcEcsYUFBYSxDQUFDLEVBQUUsR0FBRzt3QkFDckIsT0FBTzs0QkFDTCxXQUFXOzRCQUNYLElBQUloM0ksWUFBWTZ0QyxjQUFjOzRCQUM5Qm1wRyxhQUFhLENBQUMsRUFBRSxHQUFHaDNJOzRCQUNuQmczSSxhQUFhLENBQUMsRUFBRSxHQUFHLENBQUNoM0k7d0JBQ3RCO29CQUNGO2dCQUNGO2dCQUNBLElBQUlnMkksYUFBYSxJQUFJLENBQUNqQyxlQUFlLENBQUMvTixhQUFhLENBQUM0UDtnQkFDcEQsSUFBSSxDQUFDSyxrQkFBa0IsQ0FBQzdxSixNQUFNNHFKLFlBQVk1eUo7Z0JBQzFDLElBQUksQ0FBQzB4SixXQUFXO2dCQUNoQixJQUFJLENBQUNDLGFBQWE7Z0JBQ2xCLElBQUksSUFBSSxDQUFDQSxhQUFhLElBQUksSUFBSSxDQUFDeEQsWUFBWSxFQUFFO29CQUMzQyxJQUFJLENBQUM1b0csUUFBUTtnQkFDZjtZQUNGO1FBQ0Y7UUFBRztZQUNEdmxFLEtBQUs7WUFDTFUsT0FBTyxTQUFTK3lLLHFCQUFxQnpySixJQUFJLEVBQUU4ckosU0FBUztnQkFDbEQsSUFBSXBuRyxRQUFRMWtELEtBQUtnL0MsTUFBTSxDQUFDOHNHLFdBQVdwekssS0FBSztnQkFDeEMsT0FBUWdzRTtvQkFDTixLQUFLO3dCQUNILE9BQU9vaEc7b0JBQ1QsS0FBSzt3QkFDSCxPQUFPRztvQkFDVCxLQUFLO29CQUNMLEtBQUs7d0JBQ0gsT0FBT0Y7b0JBQ1QsS0FBSzt3QkFDSCxPQUFPQztvQkFDVDt3QkFDRSxPQUFPbnNLO2dCQUNYO1lBQ0Y7UUFDRjtRQUFHO1lBQ0Q3QixLQUFLO1lBQ0xVLE9BQU8sU0FBU2d6SyxpQkFBaUIxckosSUFBSSxFQUFFK3JKLFVBQVUsRUFBRXY1RyxLQUFLO2dCQUN0RCxJQUFJejhDLElBQUl5OEMsTUFBTXo4QyxDQUFDLEVBQ2I1VixJQUFJcXlELE1BQU1yeUQsQ0FBQztnQkFDYixpQ0FBaUM7Z0JBQ2pDLElBQUk2ZixLQUFLZy9DLE1BQU0sQ0FBQytzRyxZQUFZcnpLLEtBQUssS0FBSyxRQUFRO29CQUM1QyxPQUFPaThCLHdCQUF3QjVlLEdBQUc1VjtnQkFDcEMsT0FBTztvQkFDTCxJQUFJczBCLFNBQVN6VSxLQUFLZy9DLE1BQU0sQ0FBQytzRyxZQUFZOXNHLE9BQU87b0JBQzVDLElBQUlycUMsWUFBWTdlLElBQUk7b0JBQ3BCLElBQUk4ZSxhQUFhMTBCLElBQUk7b0JBQ3JCLE9BQU92RSxLQUFLK1UsR0FBRyxDQUFDOGpCLFFBQVFJLFlBQVlEO2dCQUN0QztZQUNGO1FBS0Y7UUFBRztZQUNENThCLEtBQUs7WUFDTFUsT0FBTyxTQUFTc3pLLGNBQWMvckosSUFBSSxFQUFFOHBKLFFBQVEsRUFBRXpySyxNQUFNO2dCQUNsRCxJQUFJLENBQUMyaEIsS0FBS214QyxPQUFPLElBQUk7b0JBQ25CO2dCQUNGO2dCQUNBLDBHQUEwRztnQkFDMUcsSUFBSTZxRCxLQUFLaDhGLEtBQUtoa0IsUUFBUSxDQUFDa2dCLFFBQVE7Z0JBQy9CLElBQUkvUSxHQUFHeUosR0FBR3VrQjtnQkFDVixJQUFJOTZCLFdBQVcsVUFBVTtvQkFDdkI4TSxJQUFJNndHLEdBQUdXLFdBQVc7b0JBQ2xCL25HLElBQUlvbkcsR0FBR1ksV0FBVztvQkFDbEJ6akYsUUFBUTZpRixHQUFHYSxhQUFhO2dCQUMxQixPQUFPO29CQUNMMXhHLElBQUk2d0csR0FBR2MsU0FBUztvQkFDaEJsb0csSUFBSW9uRyxHQUFHZSxTQUFTO29CQUNoQjVqRixRQUFRNmlGLEdBQUdnQixhQUFhO2dCQUMxQjtnQkFFQSwrQkFBK0I7Z0JBQy9CLElBQUl2aEgsTUFBTTBQLE1BQU1BLEtBQUssUUFBUTFQLE1BQU1tWixNQUFNQSxLQUFLLFFBQVFuWixNQUFNMDlCLFVBQVVBLFNBQVMsTUFBTTtvQkFDbkY7Z0JBQ0Y7Z0JBRUEsaUVBQWlFO2dCQUNqRSxJQUFJZ2tFLGFBQWFuOUUsS0FBSysrQyxNQUFNLENBQUMxZ0UsU0FBUyxnQkFBZ0I1RixLQUFLO2dCQUMzRCxJQUFJMGtHLGVBQWUsUUFBUTtvQkFDekI7Z0JBQ0Y7Z0JBQ0EsSUFBSWg4RixRQUFRNmUsS0FBSysrQyxNQUFNLENBQUMxZ0UsU0FBUyxnQkFBZ0I1RixLQUFLO2dCQUN0RCxJQUFJdXpLLGNBQWNoc0osS0FBSysrQyxNQUFNLENBQUMsV0FBV3RtRSxLQUFLO2dCQUM5QyxJQUFJbXBKLGNBQWM1aEksS0FBSysrQyxNQUFNLENBQUMsZ0JBQWdCdG1FLEtBQUs7Z0JBQ25ELElBQUk0ckUsVUFBVTJuRyxjQUFjcHFCO2dCQUM1QixJQUFJUyxZQUFZcmlJLEtBQUsrK0MsTUFBTSxDQUFDLFNBQVNDLE9BQU87Z0JBQzVDLElBQUlpdEcsVUFBVWpzSixLQUFLKytDLE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7Z0JBQzlDLElBQUlpaEIsT0FBTyxJQUFJLENBQUMvaUIsQ0FBQyxDQUFDNmlILGFBQWEsQ0FBQzZvQyxXQUFXNHBCO2dCQUMzQyxJQUFJMUIsV0FBVyxJQUFJLENBQUNiLGFBQWE7Z0JBQ2pDLElBQUkvMEYsWUFBWSxJQUFJLENBQUMrekYsZUFBZSxDQUFDL04sYUFBYSxDQUFDNFA7Z0JBQ25EcGhJLFNBQVN3ckM7Z0JBQ1Rxa0UsVUFBVXJrRSxXQUFXQSxXQUFXO29CQUFDeHBFO29CQUFHeUo7aUJBQUU7Z0JBQ3RDaWUsTUFBTThoRCxXQUFXQSxXQUFXO29CQUFDajdEO29CQUFNQTtpQkFBSztnQkFDeEMrcEQsT0FBT2tSLFdBQVdBLFdBQVd4N0M7Z0JBQzdCLElBQUksQ0FBQ3l2SSxjQUFjLENBQUM1TyxPQUFPLENBQUN1USxTQUFTLENBQUMsRUFBRSxHQUFHM0U7Z0JBQzNDLElBQUk0RSxZQUFZLElBQUksQ0FBQzdCLFdBQVcsQ0FBQzNPLE9BQU8sQ0FBQ3VRO2dCQUN6QzlULFlBQVlxVCxVQUFVVTtnQkFDdEIsSUFBSWMsWUFBWSxJQUFJLENBQUNwQyxXQUFXLENBQUNsUCxPQUFPLENBQUN1UTtnQkFDekNoVSxhQUFhcDFKLE9BQU9rakUsU0FBU2luRztnQkFDN0IsSUFBSSxDQUFDNUIsYUFBYTtnQkFDbEIsSUFBSSxJQUFJLENBQUNBLGFBQWEsSUFBSSxJQUFJLENBQUN4RCxZQUFZLEVBQUU7b0JBQzNDLElBQUksQ0FBQzVvRyxRQUFRO2dCQUNmO1lBQ0Y7UUFLRjtRQUFHO1lBQ0R2bEUsS0FBSztZQUNMVSxPQUFPLFNBQVN5ekssYUFBYWxzSixJQUFJLEVBQUU4cEosUUFBUTtnQkFDekMsSUFBSSxDQUFDOXBKLEtBQUtteEMsT0FBTyxJQUFJO29CQUNuQjtnQkFDRjtnQkFDQSxJQUFJdDRCLFNBQVMsSUFBSSxDQUFDc3pJLGNBQWMsQ0FBQ25zSjtnQkFDakMsSUFBSSxDQUFDNlksUUFBUTtvQkFDWDtnQkFDRjtnQkFFQSxhQUFhO2dCQUNiLElBQUltekksY0FBY2hzSixLQUFLKytDLE1BQU0sQ0FBQyxXQUFXdG1FLEtBQUs7Z0JBQzlDLElBQUltcEosY0FBYzVoSSxLQUFLKytDLE1BQU0sQ0FBQyxnQkFBZ0J0bUUsS0FBSztnQkFDbkQsSUFBSXM3QixRQUFRL1QsS0FBSysrQyxNQUFNLENBQUMsU0FBU0MsT0FBTztnQkFDeEMsSUFBSTc5RCxRQUFRNmUsS0FBSysrQyxNQUFNLENBQUMsY0FBY3RtRSxLQUFLO2dCQUMzQyxJQUFJNHJFLFVBQVUybkcsY0FBY3BxQjtnQkFDNUIsSUFBSS9vSCxPQUFPaGlDLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQzZ5SyxhQUFhLEdBQUcsSUFBSSxDQUFDeEQsWUFBWSxFQUFFO29CQUM5RCxJQUFJLENBQUM1b0csUUFBUTtnQkFDZjtnQkFDQSxJQUFJemtDLE9BQU9oaUMsTUFBTSxJQUFJLEdBQUc7b0JBQ3RCLGdCQUFnQjtvQkFDaEIsSUFBSTB6SyxXQUFXLElBQUksQ0FBQ2IsYUFBYTtvQkFDakMsSUFBSSxDQUFDZCxjQUFjLENBQUM1TyxPQUFPLENBQUN1USxTQUFTLENBQUMsRUFBRSxHQUFHN0U7b0JBQzNDLElBQUk4RSxZQUFZLElBQUksQ0FBQzdCLFdBQVcsQ0FBQzNPLE9BQU8sQ0FBQ3VRO29CQUN6QzlULFlBQVlxVCxVQUFVVTtvQkFDdEIsSUFBSWMsWUFBWSxJQUFJLENBQUNwQyxXQUFXLENBQUNsUCxPQUFPLENBQUN1UTtvQkFDekNoVSxhQUFhcDFKLE9BQU9rakUsU0FBU2luRztvQkFDN0IsSUFBSXJDLGtCQUFrQixJQUFJLENBQUNBLGVBQWUsQ0FBQ2pQLE9BQU8sQ0FBQ3VRO29CQUNuRHRCLGVBQWUsQ0FBQyxFQUFFLEdBQUdsMUk7b0JBQ3JCLElBQUlxNEksbUJBQW1CLElBQUksQ0FBQ3JELGtCQUFrQixDQUFDL08sT0FBTyxDQUFDdVE7b0JBQ3ZENkIsZ0JBQWdCLENBQUMsRUFBRSxHQUFHdnpJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsV0FBVztvQkFDNUN1ekksZ0JBQWdCLENBQUMsRUFBRSxHQUFHdnpJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsV0FBVztvQkFDNUN1ekksZ0JBQWdCLENBQUMsRUFBRSxHQUFHdnpJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsV0FBVztvQkFDNUN1ekksZ0JBQWdCLENBQUMsRUFBRSxHQUFHdnpJLE1BQU0sQ0FBQyxFQUFFLEVBQUUsV0FBVztvQkFFNUMsSUFBSSxDQUFDNndJLGFBQWE7b0JBQ2xCLElBQUksSUFBSSxDQUFDQSxhQUFhLElBQUksSUFBSSxDQUFDeEQsWUFBWSxFQUFFO3dCQUMzQyxJQUFJLENBQUM1b0csUUFBUTtvQkFDZjtnQkFDRixPQUFPO29CQUNMLGNBQWM7b0JBQ2QsSUFBSyxJQUFJbGtFLElBQUksR0FBR0EsSUFBSXkvQixPQUFPaGlDLE1BQU0sR0FBRyxHQUFHdUMsS0FBSyxFQUFHO3dCQUM3QyxJQUFJaXpLLFlBQVksSUFBSSxDQUFDM0MsYUFBYTt3QkFDbEMsSUFBSSxDQUFDZCxjQUFjLENBQUM1TyxPQUFPLENBQUNxUyxVQUFVLENBQUMsRUFBRSxHQUFHMUc7d0JBQzVDLElBQUkyRyxhQUFhLElBQUksQ0FBQzNELFdBQVcsQ0FBQzNPLE9BQU8sQ0FBQ3FTO3dCQUMxQzVWLFlBQVlxVCxVQUFVd0M7d0JBQ3RCLElBQUlDLGFBQWEsSUFBSSxDQUFDckQsV0FBVyxDQUFDbFAsT0FBTyxDQUFDcVM7d0JBQzFDOVYsYUFBYXAxSixPQUFPa2pFLFNBQVNrb0c7d0JBQzdCLElBQUlDLG1CQUFtQixJQUFJLENBQUN2RCxlQUFlLENBQUNqUCxPQUFPLENBQUNxUzt3QkFDcERHLGdCQUFnQixDQUFDLEVBQUUsR0FBR3o0STt3QkFDdEIsSUFBSTA0SSxNQUFNNXpJLE1BQU0sQ0FBQ3ovQixJQUFJLEVBQUUsRUFDckJzekssTUFBTTd6SSxNQUFNLENBQUN6L0IsSUFBSSxFQUFFO3dCQUNyQixJQUFJdXpLLE1BQU05ekksTUFBTSxDQUFDei9CLEVBQUUsRUFDakJ3ekssTUFBTS96SSxNQUFNLENBQUN6L0IsSUFBSSxFQUFFO3dCQUNyQixJQUFJeXpLLE1BQU1oMEksTUFBTSxDQUFDei9CLElBQUksRUFBRSxFQUNyQjB6SyxNQUFNajBJLE1BQU0sQ0FBQ3ovQixJQUFJLEVBQUU7d0JBQ3JCLElBQUkyekssTUFBTWwwSSxNQUFNLENBQUN6L0IsSUFBSSxFQUFFLEVBQ3JCNHpLLE1BQU1uMEksTUFBTSxDQUFDei9CLElBQUksRUFBRTt3QkFFckIsc0RBQXNEO3dCQUN0RCw4RkFBOEY7d0JBQzlGLElBQUlBLEtBQUssR0FBRzs0QkFDVnF6SyxNQUFNLElBQUlFLE1BQU1FLE1BQU07NEJBQ3RCSCxNQUFNLElBQUlFLE1BQU1FLE1BQU07d0JBQ3hCO3dCQUNBLElBQUkxekssS0FBS3kvQixPQUFPaGlDLE1BQU0sR0FBRyxHQUFHOzRCQUMxQmsySyxNQUFNLElBQUlGLE1BQU1GLE1BQU07NEJBQ3RCSyxNQUFNLElBQUlGLE1BQU1GLE1BQU07d0JBQ3hCO3dCQUNBLElBQUlLLGNBQWMsSUFBSSxDQUFDbEUsa0JBQWtCLENBQUMvTyxPQUFPLENBQUNxUzt3QkFDbERZLFdBQVcsQ0FBQyxFQUFFLEdBQUdSO3dCQUNqQlEsV0FBVyxDQUFDLEVBQUUsR0FBR1A7d0JBQ2pCTyxXQUFXLENBQUMsRUFBRSxHQUFHTjt3QkFDakJNLFdBQVcsQ0FBQyxFQUFFLEdBQUdMO3dCQUNqQixJQUFJTSxjQUFjLElBQUksQ0FBQ2xFLGtCQUFrQixDQUFDaFAsT0FBTyxDQUFDcVM7d0JBQ2xEYSxXQUFXLENBQUMsRUFBRSxHQUFHTDt3QkFDakJLLFdBQVcsQ0FBQyxFQUFFLEdBQUdKO3dCQUNqQkksV0FBVyxDQUFDLEVBQUUsR0FBR0g7d0JBQ2pCRyxXQUFXLENBQUMsRUFBRSxHQUFHRjt3QkFDakIsSUFBSSxDQUFDdEQsYUFBYTt3QkFDbEIsSUFBSSxJQUFJLENBQUNBLGFBQWEsSUFBSSxJQUFJLENBQUN4RCxZQUFZLEVBQUU7NEJBQzNDLElBQUksQ0FBQzVvRyxRQUFRO3dCQUNmO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUFHO1lBQ0R2bEUsS0FBSztZQUNMVSxPQUFPLFNBQVNzeEssYUFBYS9wSixJQUFJO2dCQUMvQixJQUFJZzhGLEtBQUtoOEYsS0FBS2hrQixRQUFRLENBQUNrZ0IsUUFBUTtnQkFDL0IsSUFBSTgvRixHQUFHaVcsT0FBTyxJQUFJalcsR0FBR1EsTUFBTSxJQUFJLFFBQVEvZ0gsTUFBTXVnSCxHQUFHUSxNQUFNLENBQUMsRUFBRSxHQUFHO29CQUMxRCxrRUFBa0U7b0JBQ2xFLE9BQU87Z0JBQ1Q7Z0JBQ0EsT0FBTztZQUNUO1FBQ0Y7UUFBRztZQUNEemtILEtBQUs7WUFDTFUsT0FBTyxTQUFTMHpLLGVBQWVuc0osSUFBSTtnQkFDakMsSUFBSWc4RixLQUFLaDhGLEtBQUtoa0IsUUFBUSxDQUFDa2dCLFFBQVE7Z0JBRS9CLHFEQUFxRDtnQkFDckQsSUFBSSxDQUFDLElBQUksQ0FBQzZ0SixZQUFZLENBQUMvcEosT0FBTztvQkFDNUIsa0VBQWtFO29CQUNsRTtnQkFDRjtnQkFDQSxJQUFJd3FELGdCQUFnQnd4QyxHQUFHUSxNQUFNO2dCQUM3QixJQUFJaHlDLGNBQWMzekUsTUFBTSxJQUFJLEdBQUc7b0JBQzdCLE9BQU8yekU7Z0JBQ1Q7Z0JBQ0EsSUFBSTJpRyxjQUFjLElBQUksQ0FBQ0MsZUFBZSxDQUFDcHRKO2dCQUN2QyxPQUFPLElBQUksQ0FBQ3F0SixzQkFBc0IsQ0FBQzdpRyxlQUFlMmlHO1lBQ3BEO1FBQ0Y7UUFBRztZQUNEcDFLLEtBQUs7WUFDTFUsT0FBTyxTQUFTMjBLLGdCQUFnQnB0SixJQUFJO2dCQUNsQyxvRkFBb0Y7Z0JBQ3BGLHNCQUFzQjtnQkFDdEIsK0RBQStEO2dCQUMvRCw4Q0FBOEM7Z0JBQzlDLHVFQUF1RTtnQkFDdkUsK0RBQStEO2dCQUMvRCxnQ0FBZ0M7Z0JBQ2hDLHlFQUF5RTtnQkFDekUsK0hBQStIO2dCQUMvSCxJQUFJbXRKLGNBQWM7Z0JBQ2xCLE9BQU94eEssS0FBSytVLEdBQUcsQ0FBQy9VLEtBQUs2VSxHQUFHLENBQUMyOEosYUFBYSxJQUFJLElBQUksQ0FBQ2pILFlBQVk7WUFDN0Q7UUFDRjtRQUFHO1lBQ0RudUssS0FBSztZQUNMVSxPQUFPLFNBQVM0MEssdUJBQXVCN2lHLGFBQWEsRUFBRStrRCxRQUFRO2dCQUM1RCxJQUFJL2tELGNBQWMzekUsTUFBTSxJQUFJLEdBQUc7b0JBQzdCLE9BQU8yekUsZUFBZSxnQkFBZ0I7Z0JBQ3hDO2dCQUNBLElBQUk4aUcsY0FBY3QySyxNQUFNLENBQUN1NEgsV0FBVyxLQUFLO2dCQUN6QyxJQUFLLElBQUluMkgsSUFBSSxHQUFHQSxLQUFLbTJILFVBQVVuMkgsSUFBSztvQkFDbEMsOEVBQThFO29CQUM5RSxJQUFJQSxLQUFLLEdBQUc7d0JBQ1ZrMEssV0FBVyxDQUFDLEVBQUUsR0FBRzlpRyxhQUFhLENBQUMsRUFBRTt3QkFDakM4aUcsV0FBVyxDQUFDLEVBQUUsR0FBRzlpRyxhQUFhLENBQUMsRUFBRTtvQkFDbkMsT0FBTyxJQUFJcHhFLEtBQUttMkgsVUFBVTt3QkFDeEIrOUMsV0FBVyxDQUFDbDBLLElBQUksRUFBRSxHQUFHb3hFLGFBQWEsQ0FBQ0EsY0FBYzN6RSxNQUFNLEdBQUcsRUFBRTt3QkFDNUR5MkssV0FBVyxDQUFDbDBLLElBQUksSUFBSSxFQUFFLEdBQUdveEUsYUFBYSxDQUFDQSxjQUFjM3pFLE1BQU0sR0FBRyxFQUFFO29CQUNsRSxPQUFPO3dCQUNMLElBQUlVLElBQUk2QixJQUFJbTJILFVBQVUsMkVBQTJFO3dCQUNqRyw4REFBOEQ7d0JBQzlELElBQUksQ0FBQ2crQyxjQUFjLENBQUMvaUcsZUFBZWp6RSxHQUFHKzFLLGFBQWFsMEssSUFBSTtvQkFDekQ7Z0JBQ0Y7Z0JBQ0EsT0FBT2swSztZQUNUO1FBQ0Y7UUFBRztZQUNEdjFLLEtBQUs7WUFDTFUsT0FBTyxTQUFTODBLLGVBQWUxMEksTUFBTSxFQUFFdGhDLENBQUMsRUFBRSsxSyxXQUFXLEVBQUVFLEdBQUc7Z0JBQ3hELElBQUkzMEksT0FBT2hpQyxNQUFNLElBQUksR0FBRztvQkFDdEJ5MkssV0FBVyxDQUFDRSxJQUFJLEdBQUczMEksTUFBTSxDQUFDLEVBQUU7b0JBQzVCeTBJLFdBQVcsQ0FBQ0UsTUFBTSxFQUFFLEdBQUczMEksTUFBTSxDQUFDLEVBQUU7Z0JBQ2xDLE9BQU87b0JBQ0wsSUFBSTQwSSxZQUFZejJLLE1BQU02aEMsT0FBT2hpQyxNQUFNLEdBQUc7b0JBQ3RDLElBQUssSUFBSXVDLElBQUksR0FBR0EsSUFBSXEwSyxVQUFVNTJLLE1BQU0sRUFBRXVDLEtBQUssRUFBRzt3QkFDNUMsSUFBSStSLElBQUksQ0FBQyxJQUFJNVQsQ0FBQUEsSUFBS3NoQyxNQUFNLENBQUN6L0IsRUFBRSxHQUFHN0IsSUFBSXNoQyxNQUFNLENBQUN6L0IsSUFBSSxFQUFFO3dCQUMvQyxJQUFJd2IsSUFBSSxDQUFDLElBQUlyZCxDQUFBQSxJQUFLc2hDLE1BQU0sQ0FBQ3ovQixJQUFJLEVBQUUsR0FBRzdCLElBQUlzaEMsTUFBTSxDQUFDei9CLElBQUksRUFBRTt3QkFDbkRxMEssU0FBUyxDQUFDcjBLLEVBQUUsR0FBRytSO3dCQUNmc2lLLFNBQVMsQ0FBQ3IwSyxJQUFJLEVBQUUsR0FBR3diO29CQUNyQjtvQkFDQSxPQUFPLElBQUksQ0FBQzI0SixjQUFjLENBQUNFLFdBQVdsMkssR0FBRysxSyxhQUFhRTtnQkFDeEQ7WUFDRjtRQUNGO1FBQUc7WUFDRHoxSyxLQUFLO1lBQ0xVLE9BQU8sU0FBUzZrRTtnQkFDZCxJQUFJeTNGLEtBQUssSUFBSSxDQUFDQSxFQUFFLEVBQ2QyUixNQUFNLElBQUksQ0FBQ0EsR0FBRyxFQUNkNkIsY0FBYyxJQUFJLENBQUNBLFdBQVcsRUFDOUJ6MkQsUUFBUSxJQUFJLENBQUM0M0QsYUFBYTtnQkFDNUIsSUFBSTUzRCxVQUFVLEdBQUc7Z0JBQ2pCLElBQUkrakQsVUFBVSxJQUFJLENBQUNrUixZQUFZLENBQUMxQixPQUFPLEdBQUcsSUFBSSxDQUFDb0IsY0FBYyxHQUFHLElBQUksQ0FBQzVRLE9BQU87Z0JBQzVFZCxHQUFHMlksVUFBVSxDQUFDN1g7Z0JBQ2RkLEdBQUcwVCxlQUFlLENBQUMvQjtnQkFFbkIsNEJBQTRCO2dCQUM1QixJQUFJM2xJLGFBQWE3b0MsMkJBQTJCLElBQUksQ0FBQ3kxSyxPQUFPLEdBQ3REM3NJO2dCQUNGLElBQUk7b0JBQ0YsSUFBS0QsV0FBV3hvQyxDQUFDLElBQUksQ0FBQyxDQUFDeW9DLFNBQVNELFdBQVdocUMsQ0FBQyxFQUFDLEVBQUd5QixJQUFJLEVBQUc7d0JBQ3JELElBQUlzK0osU0FBUzkxSCxPQUFPdm9DLEtBQUs7d0JBQ3pCcStKLE9BQU9xRCxhQUFhLENBQUNyb0Q7b0JBQ3ZCO2dCQUNGLEVBQUUsT0FBT254RSxLQUFLO29CQUNaSSxXQUFXanFDLENBQUMsQ0FBQzZwQztnQkFDZixTQUFVO29CQUNSSSxXQUFXcm9DLENBQUM7Z0JBQ2Q7Z0JBQ0EsSUFBSW1tSyxVQUFVLElBQUksQ0FBQ3lILFlBQVksQ0FBQzdCLFVBQVU7Z0JBQzFDLDhDQUE4QztnQkFDOUMsSUFBSyxJQUFJcnJLLElBQUksR0FBR0EsSUFBSXlsSyxRQUFRaG9LLE1BQU0sRUFBRXVDLElBQUs7b0JBQ3ZDeWxLLE9BQU8sQ0FBQ3psSyxFQUFFLENBQUNzbEssY0FBYyxDQUFDM0o7Z0JBQzVCO2dCQUNBLDhDQUE4QztnQkFDOUMsSUFBSyxJQUFJcjFJLE1BQU0sR0FBR0EsTUFBTW0vSSxRQUFRaG9LLE1BQU0sRUFBRTZvQixNQUFPO29CQUM3Q3ExSSxHQUFHNlksYUFBYSxDQUFDN1ksR0FBRzhZLFFBQVEsR0FBR251SjtvQkFDL0JxMUksR0FBR2lDLFdBQVcsQ0FBQ2pDLEdBQUdrQyxVQUFVLEVBQUU0SCxPQUFPLENBQUNuL0ksSUFBSSxDQUFDaTRILE9BQU87b0JBQ2xEb2QsR0FBRytZLFNBQVMsQ0FBQ2pZLFFBQVF3UyxTQUFTLENBQUMzb0osSUFBSSxFQUFFQTtnQkFDdkM7Z0JBRUEsbUJBQW1CO2dCQUNuQnExSSxHQUFHZ1osU0FBUyxDQUFDbFksUUFBUXVTLEtBQUssRUFBRWhTLGlCQUFpQixJQUFJLENBQUN6L0osQ0FBQztnQkFDbkRvK0osR0FBR2laLGdCQUFnQixDQUFDblksUUFBUW1TLGNBQWMsRUFBRSxPQUFPLElBQUksQ0FBQ3VCLGFBQWE7Z0JBQ3JFeFUsR0FBRytZLFNBQVMsQ0FBQ2pZLFFBQVFxUyxVQUFVLEVBQUUsSUFBSSxDQUFDNUIsWUFBWSxDQUFDdEYsWUFBWTtnQkFDL0QsNkRBQTZEO2dCQUM3RCxJQUFJaDJFLGVBQWV1ckUsYUFBYSxJQUFJLENBQUM0UCxPQUFPLEVBQUU7Z0JBQzlDcFIsR0FBR2taLFVBQVUsQ0FBQ3BZLFFBQVFzUyxRQUFRLEVBQUVuOUU7Z0JBRWhDLFFBQVE7Z0JBQ1IrcEUsR0FBR21aLG1CQUFtQixDQUFDblosR0FBR29aLFNBQVMsRUFBRSxHQUFHNUYsYUFBYXoyRDtnQkFDckRpakQsR0FBRzBULGVBQWUsQ0FBQztnQkFDbkIxVCxHQUFHaUMsV0FBVyxDQUFDakMsR0FBR2tDLFVBQVUsRUFBRSxPQUFPLHlEQUF5RDtnQkFFOUYsSUFBSSxJQUFJLENBQUMzc0UsS0FBSyxFQUFFO29CQUNkLElBQUksQ0FBQzg3RSxjQUFjLENBQUMvc0ssSUFBSSxDQUFDO3dCQUN2Qnk0RyxPQUFPQTt3QkFDUCxpQkFBaUI7d0JBQ2pCdXVELFlBQVl4QixRQUFRaG9LLE1BQU07b0JBQzVCO2dCQUNGO2dCQUVBLDJDQUEyQztnQkFDM0MsSUFBSSxDQUFDdW1FLFVBQVU7WUFDakI7UUFDRjtRQUFHO1lBQ0RybEUsS0FBSztZQUNMVSxPQUFPLFNBQVNxcks7Z0JBQ2QsSUFBSXFHLFlBQVksSUFBSSxDQUFDOUQsWUFBWSxDQUFDdkMsWUFBWTtnQkFDOUMsSUFBSXNLLGVBQWVqRSxVQUFVdnpHLE1BQU0sQ0FBQyxTQUFVazdDLEtBQUssRUFBRXBuRixJQUFJO29CQUN2RCxPQUFPb25GLFFBQVFwbkYsS0FBSzIxSSxVQUFVO2dCQUNoQyxHQUFHO2dCQUNILElBQUlnTyxZQUFZLElBQUksQ0FBQ2pJLGNBQWM7Z0JBQ25DLElBQUlrSSxpQkFBaUJELFVBQVV6M0csTUFBTSxDQUFDLFNBQVVrN0MsS0FBSyxFQUFFcG5GLElBQUk7b0JBQ3pELE9BQU9vbkYsUUFBUXBuRixLQUFLb25GLEtBQUs7Z0JBQzNCLEdBQUc7Z0JBQ0gsT0FBTztvQkFDTHE0RCxXQUFXQTtvQkFDWGlFLGNBQWNBO29CQUNkNUUsY0FBYyxJQUFJLENBQUNBLFlBQVk7b0JBQy9CQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztvQkFDN0I5L0UsWUFBWTBrRixVQUFVeDNLLE1BQU07b0JBQzVCdzNLLFdBQVdBO29CQUNYQyxnQkFBZ0JBO2dCQUNsQjtZQUNGO1FBQ0Y7S0FBRTtBQUNKO0FBRUEsSUFBSUMsUUFBUSxDQUFDO0FBRWI7O0NBRUMsR0FDREEsTUFBTUMsU0FBUyxHQUFHLFNBQVV6MkosSUFBSSxFQUFFMGhILEdBQUc7SUFDbkMsSUFBSTlpSSxJQUFJLElBQUk7SUFDWixJQUFJbytKLEtBQUtwK0osRUFBRTZqQixJQUFJLENBQUN3MEksUUFBUSxDQUFDcjRKLEVBQUU4M0ssS0FBSyxDQUFDO0lBRWpDLHFEQUFxRDtJQUNyRDEySixLQUFLb3VKLE9BQU8sR0FBR3VJLFdBQVcvM0s7SUFDMUJvaEIsS0FBSzR5RSxZQUFZLEdBQUdodkYsS0FBSytVLEdBQUcsQ0FBQ3FILEtBQUs0eUUsWUFBWSxFQUFFb3FFLEdBQUc0WixZQUFZLENBQUM1WixHQUFHNlosZ0JBQWdCO0lBQ25GNzJKLEtBQUs2eUUsWUFBWSxHQUFHanZGLEtBQUsrVSxHQUFHLENBQUNxSCxLQUFLNnlFLFlBQVksRUFBRTtJQUNoRDd5RSxLQUFLOHlFLGlCQUFpQixHQUFHbHZGLEtBQUsrVSxHQUFHLENBQUNxSCxLQUFLOHlFLGlCQUFpQixFQUFFO0lBQzFEOXlFLEtBQUsreUUsY0FBYyxHQUFHbnZGLEtBQUsrVSxHQUFHLENBQUNxSCxLQUFLK3lFLGNBQWMsRUFBRTtJQUNwRC95RSxLQUFLZ3pFLGdCQUFnQixHQUFHcHZGLEtBQUsrVSxHQUFHLENBQUNxSCxLQUFLZ3pFLGdCQUFnQixFQUFFZ3FFLEdBQUc0WixZQUFZLENBQUM1WixHQUFHOFosdUJBQXVCO0lBRWxHLDZCQUE2QjtJQUM3Qmw0SyxFQUFFOHpGLFVBQVUsR0FBRzF5RSxLQUFLMHlFLFVBQVU7SUFDOUI5ekYsRUFBRSt6RixxQkFBcUIsR0FBRzN5RSxLQUFLMnlFLHFCQUFxQjtJQUVwRCw4RkFBOEY7SUFDOUYsOEhBQThIO0lBQzlIL3pGLEVBQUVtNEssa0JBQWtCLEdBQUdqVSx5QkFBeUI5RjtJQUNoRHArSixFQUFFbTRLLGtCQUFrQixDQUFDQyxTQUFTLEdBQUc7SUFFakMsd0ZBQXdGO0lBQ3hGLDBFQUEwRTtJQUMxRXA0SyxFQUFFcTRLLE9BQU8sR0FBRyxJQUFJL0ksb0JBQW9CdHZLLEdBQUdvK0osSUFBSWg5STtJQUUzQyxnRUFBZ0U7SUFDaEUsSUFBSTBvSSxtQkFBbUIsU0FBU0EsaUJBQWlCdm5HLElBQUk7UUFDbkQsT0FBTyxTQUFVL2dDLEdBQUc7WUFDbEIsT0FBT3hoQixFQUFFK3BKLFlBQVksQ0FBQ3ZvSSxLQUFLK2dDO1FBQzdCO0lBQ0Y7SUFDQSxJQUFJKzFILGlCQUFpQixTQUFTQSxlQUFlLzFILElBQUk7UUFDL0MsT0FBTyxTQUFVL2dDLEdBQUc7WUFDbEIsSUFBSXlwRCxRQUFRenBELElBQUk0bUQsTUFBTSxDQUFDN2xCO1lBQ3ZCLE9BQU8wb0IsU0FBU0EsTUFBTW5wRSxLQUFLO1FBQzdCO0lBQ0Y7SUFDQSxJQUFJeTJLLGlCQUFpQixTQUFTQSxlQUFlN3dLLE1BQU07UUFDakQsT0FBTyxTQUFVMGhCLElBQUk7WUFDbkIsb0NBQW9DO1lBQ3BDLE9BQU9BLEtBQUtnL0MsTUFBTSxDQUFDLEdBQUduOUMsTUFBTSxDQUFDdmpCLFFBQVEsYUFBYTVGLEtBQUssR0FBRztRQUM1RDtJQUNGO0lBQ0EsSUFBSXV4SyxvQkFBb0IsU0FBU0Esa0JBQWtCN3hKLEdBQUc7UUFDcEQseUNBQXlDO1FBQ3pDLElBQUlqQixVQUFVaUIsSUFBSTRtRCxNQUFNLENBQUMsZUFBZThDLFFBQVEsS0FBSztRQUNyRCxPQUFPM3FELFVBQVVvdUosaUJBQWlCRSxNQUFNLEdBQUdGLGlCQUFpQkMsTUFBTTtJQUNwRTtJQUNBLElBQUk0SixzQkFBc0IsU0FBU0Esb0JBQW9CcHZKLElBQUk7UUFDekQsOERBQThEO1FBQzlELElBQUlxdkosaUJBQWlCcnZKLEtBQUtuRixRQUFRLElBQ2hDelAsSUFBSWlrSyxlQUFlamtLLENBQUMsRUFDcEJ5SixJQUFJdzZKLGVBQWV4NkosQ0FBQztRQUN0QixJQUFJa0IsSUFBSWlLLEtBQUtvbUQsVUFBVSxJQUFJLDhCQUE4QjtRQUN6RCxJQUFJam1FLElBQUk2ZixLQUFLcW1ELFdBQVc7UUFDeEIsT0FBTztZQUNMdHdELEdBQUdBO1lBQ0g1VixHQUFHQTtZQUNIekQsSUFBSTBPLElBQUkySyxJQUFJO1lBQ1puWixJQUFJaVksSUFBSTFVLElBQUk7UUFDZDtJQUNGO0lBRUEsMEZBQTBGO0lBQzFGLDhEQUE4RDtJQUM5RHZKLEVBQUVxNEssT0FBTyxDQUFDL04sa0JBQWtCLENBQUMsUUFBUTtRQUNuQ3BFLFNBQVM5a0osS0FBSzh5RSxpQkFBaUI7SUFDakM7SUFDQWwwRixFQUFFcTRLLE9BQU8sQ0FBQy9OLGtCQUFrQixDQUFDLFNBQVM7UUFDcENwRSxTQUFTOWtKLEtBQUs2eUUsWUFBWTtJQUM1QjtJQUVBLGtFQUFrRTtJQUVsRSxrRUFBa0U7SUFDbEUsc0VBQXNFO0lBQ3RFLCtEQUErRDtJQUMvRGowRixFQUFFcTRLLE9BQU8sQ0FBQ3BJLHlCQUF5QixDQUFDLGFBQWE7UUFDL0M3cUssWUFBWTtRQUNaMnJFLFFBQVEreEQsSUFBSTQxQyxXQUFXO1FBQ3ZCMTVCLGdCQUFnQmxjLElBQUk2MUMsYUFBYTtRQUNqQzU1QixhQUFhamMsSUFBSWljLFdBQVc7SUFDOUI7SUFDQS8rSSxFQUFFcTRLLE9BQU8sQ0FBQ2xJLHdCQUF3QixDQUFDLGFBQWE7UUFDOUNueEIsZ0JBQWdCdzVCO1FBQ2hCMzlHLFVBQVU2a0c7UUFDVndVLFlBQVk7WUFDVnBtRyxPQUFPO1lBQ1B0akUsT0FBTztZQUNQa2pFLFNBQVM7WUFDVDd2QyxRQUFRO1lBQ1JtMUMsUUFBUTtRQUNWO0lBQ0Y7SUFDQWh6RSxFQUFFcTRLLE9BQU8sQ0FBQ2xJLHdCQUF3QixDQUFDLGdCQUFnQjtRQUNqRG54QixnQkFBZ0J3NUI7UUFDaEJyNUIsV0FBV281QixlQUFlO1FBQzFCckUsWUFBWTtZQUNWcG1HLE9BQU87WUFDUHRqRSxPQUFPO1lBQ1BrakUsU0FBUztZQUNUeHlDLFNBQVM7WUFDVDJDLFFBQVE7UUFDVjtJQUNGO0lBQ0E3OUIsRUFBRXE0SyxPQUFPLENBQUNsSSx3QkFBd0IsQ0FBQyxpQkFBaUI7UUFDbERueEIsZ0JBQWdCdzVCO1FBQ2hCcjVCLFdBQVdvNUIsZUFBZTtRQUMxQnJFLFlBQVk7WUFDVnBtRyxPQUFPO1lBQ1B0akUsT0FBTztZQUNQa2pFLFNBQVM7WUFDVHh5QyxTQUFTO1lBQ1QyQyxRQUFRO1FBQ1Y7SUFDRjtJQUNBNzlCLEVBQUVxNEssT0FBTyxDQUFDcEkseUJBQXlCLENBQUMsU0FBUztRQUMzQywrQkFBK0I7UUFDL0I3cUssWUFBWTtRQUNaaXVLLG1CQUFtQkE7UUFDbkJ0aUcsUUFBUTZuRyxxQkFBcUI5MUMsSUFBSSsxQyxXQUFXLEVBQUU7UUFDOUM3NUIsZ0JBQWdCODVCLHVCQUF1QmgyQyxJQUFJaTJDLFdBQVcsRUFBRTtRQUN4RHBNLGFBQWE7UUFDYjV0QixhQUFhamMsSUFBSWdvQixTQUFTO1FBQzFCeEIsYUFBYVEsaUJBQWlCO1FBQzlCN0ssa0JBQWtCbmMsSUFBSWsyQyxxQkFBcUI7UUFDM0M5NUIsbUJBQW1CcGMsSUFBSW0yQyxzQkFBc0I7UUFDN0M5NUIsV0FBV201QixlQUFlO0lBQzVCO0lBQ0F0NEssRUFBRXE0SyxPQUFPLENBQUNwSSx5QkFBeUIsQ0FBQyxxQkFBcUI7UUFDdkQ3cUssWUFBWTtRQUNaaXVLLG1CQUFtQkE7UUFDbkJ0aUcsUUFBUTZuRyxxQkFBcUI5MUMsSUFBSW8yQyxpQkFBaUIsRUFBRTtRQUNwRGw2QixnQkFBZ0I4NUIsdUJBQXVCaDJDLElBQUlxMkMsaUJBQWlCLEVBQUU7UUFDOUR4TSxhQUFhO1FBQ2I1dEIsYUFBYWpjLElBQUlzMkMsZUFBZTtRQUNoQzl2QixhQUFhUSxpQkFBaUI7UUFDOUI3SyxrQkFBa0JuYyxJQUFJdTJDLDJCQUEyQjtRQUNqRG42QixtQkFBbUJwYyxJQUFJdzJDLDRCQUE0QjtRQUNuRG42QixXQUFXbTVCLGVBQWU7SUFDNUI7SUFDQXQ0SyxFQUFFcTRLLE9BQU8sQ0FBQ3BJLHlCQUF5QixDQUFDLHFCQUFxQjtRQUN2RDdxSyxZQUFZO1FBQ1ppdUssbUJBQW1CQTtRQUNuQnRpRyxRQUFRNm5HLHFCQUFxQjkxQyxJQUFJeTJDLGlCQUFpQixFQUFFO1FBQ3BEdjZCLGdCQUFnQjg1Qix1QkFBdUJoMkMsSUFBSTAyQyxpQkFBaUIsRUFBRTtRQUM5RDdNLGFBQWE7UUFDYjV0QixhQUFhamMsSUFBSTIyQyxlQUFlO1FBQ2hDbndCLGFBQWFRLGlCQUFpQjtRQUM5QjdLLGtCQUFrQm5jLElBQUk0MkMsMkJBQTJCO1FBQ2pEeDZCLG1CQUFtQnBjLElBQUk2MkMsNEJBQTRCO1FBQ25EeDZCLFdBQVdtNUIsZUFBZTtJQUM1QjtJQUVBLDBFQUEwRTtJQUMxRSxJQUFJc0IsWUFBWTUvSixTQUFTO1FBQ3ZCd0YsUUFBUWdCLEdBQUcsQ0FBQztRQUNaeGdCLEVBQUU2akIsSUFBSSxDQUFDcXBGLEVBQUUsR0FBRztJQUNkLEdBQUc7SUFFSCw0REFBNEQ7SUFDNURsdEcsRUFBRWtqSSxnQkFBZ0IsQ0FBQyxTQUFVdnhDLFFBQVEsRUFBRXBrRSxJQUFJO1FBQ3pDLElBQUlzc0osV0FBVztRQUNmLElBQUl0c0osUUFBUUEsS0FBS3J0QixNQUFNLEdBQUcsR0FBRztZQUMzQjI1SyxZQUFZNzVLLEVBQUVxNEssT0FBTyxDQUFDOTZCLFVBQVUsQ0FBQ2h3SDtRQUNuQztRQUNBLElBQUlzc0osVUFBVTtZQUNaRDtRQUNGO0lBQ0Y7SUFFQSwyREFBMkQ7SUFDM0RFLGdDQUFnQzk1SztBQUNsQztBQUNBLFNBQVMrM0ssV0FBVy8zSyxDQUFDO0lBQ25CLElBQUlpMUYsWUFBWWoxRixFQUFFeWpCLEVBQUUsQ0FBQ3d4RSxTQUFTO0lBQzlCLElBQUk4a0YsV0FBVzlrRixhQUFhQSxVQUFVMXdFLEtBQUssSUFBSTB3RSxVQUFVMXdFLEtBQUssQ0FBQ3ExSSxlQUFlLElBQUk7SUFDbEYsT0FBT2x2SixZQUFZcXZLO0FBQ3JCO0FBQ0EsU0FBU0MsY0FBY3g0SixHQUFHLEVBQUU5WixNQUFNO0lBQ2hDLElBQUkyOUcsS0FBSzdqRyxJQUFJbmMsUUFBUSxDQUFDa2dCLFFBQVE7SUFDOUIsT0FBT3pELG9CQUFvQnVqRyxJQUFJLHdCQUF3QjM5RyxXQUFXLEVBQUU7QUFDdEU7QUFFQTs7O0NBR0MsR0FDRCxJQUFJa3hLLHVCQUF1QixTQUFTQSxxQkFBcUI3bkcsTUFBTSxFQUFFcnBFLE1BQU07SUFDckUsT0FBTyxTQUFVOFosR0FBRztRQUNsQixJQUFJcGdCLE1BQU0ydkUsT0FBT3Z2RDtRQUNqQixJQUFJK2xCLFFBQVF5eUksY0FBY3g0SixLQUFLOVo7UUFDL0IsSUFBSTYvQixNQUFNcm5DLE1BQU0sR0FBRyxHQUFHO1lBQ3BCLE9BQU9xbkMsTUFBTXR6QixHQUFHLENBQUMsU0FBVTJ0QixJQUFJLEVBQUV4ckIsS0FBSztnQkFDcEMsT0FBTyxHQUFHNlUsTUFBTSxDQUFDN3BCLEtBQUssS0FBSzZwQixNQUFNLENBQUM3VTtZQUNwQztRQUNGO1FBQ0EsT0FBT2hWO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELElBQUkwM0sseUJBQXlCLFNBQVNBLHVCQUF1Qjk1QixjQUFjLEVBQUV0M0ksTUFBTTtJQUNqRixPQUFPLFNBQVU4WixHQUFHLEVBQUUyM0UsUUFBUTtRQUM1QixJQUFJeitELEtBQUtza0gsZUFBZXg5SDtRQUN4QixJQUFJLE9BQU8yM0UsYUFBYSxVQUFVO1lBQ2hDLElBQUk4Z0YsS0FBSzlnRixTQUFTdnRFLE9BQU8sQ0FBQztZQUMxQixJQUFJcXVKLEtBQUssR0FBRztnQkFDVixJQUFJQyxZQUFZcjZKLE9BQU9zNUUsU0FBU3h4RixTQUFTLENBQUNzeUssS0FBSztnQkFDL0MsSUFBSTF5SSxRQUFReXlJLGNBQWN4NEosS0FBSzlaO2dCQUMvQixnRUFBZ0U7Z0JBQ2hFLElBQUk2QixJQUFJbXhCLEdBQUdueEIsQ0FBQyxHQUFHZytCLE1BQU1ybkMsTUFBTTtnQkFDM0IsSUFBSWluSyxVQUFVNTlKLElBQUkyd0s7Z0JBQ2xCLElBQUlsMEssS0FBSzAwQixHQUFHMTBCLEVBQUUsR0FBR21oSztnQkFDakIsZ0RBQWdEO2dCQUNoRCxPQUFPO29CQUNMcmhLLElBQUk0MEIsR0FBRzUwQixFQUFFO29CQUNUcVosR0FBR3ViLEdBQUd2YixDQUFDO29CQUNQblosSUFBSUE7b0JBQ0p1RCxHQUFHQTtvQkFDSDQ5SixTQUFTQTtnQkFDWDtZQUNGO1FBQ0Y7UUFDQSxPQUFPenNJO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNvL0ksZ0NBQWdDOTVLLENBQUM7SUFDeEM7UUFDRSxrR0FBa0c7UUFDbEcsSUFBSW02SyxlQUFlbjZLLEVBQUV5NEksTUFBTTtRQUMzQno0SSxFQUFFeTRJLE1BQU0sR0FBRyxTQUFVemtJLE9BQU87WUFDMUJBLFVBQVVBLFdBQVcsQ0FBQztZQUN0QixJQUFJeVAsS0FBS3pqQixFQUFFeWpCLEVBQUU7WUFDYixJQUFJempCLEVBQUU2ekYsS0FBSyxFQUFFO2dCQUNYLCtGQUErRjtnQkFDL0YsdUJBQXVCO2dCQUN2QixJQUFJcHdFLEdBQUdpRCxJQUFJLEtBQUttM0gsV0FBVztvQkFDekJ1OEIsV0FBV3A2SztvQkFDWG02SyxhQUFhbDRLLElBQUksQ0FBQ2pDLEdBQUdnVTtnQkFDdkIsT0FBTztvQkFDTGluSixZQUFZajdKO29CQUNacTZLLFlBQVlyNkssR0FBR2dVLFNBQVNzNkosY0FBY0MsTUFBTTtnQkFDOUM7WUFDRjtRQUNGO0lBQ0Y7SUFDQTtRQUNFLGdGQUFnRjtRQUNoRixJQUFJK0wsV0FBV3Q2SyxFQUFFbTZJLGVBQWU7UUFDaENuNkksRUFBRW02SSxlQUFlLEdBQUcsU0FBVWxsRCxTQUFTO1lBQ3JDcWxGLFNBQVNyNEssSUFBSSxDQUFDakMsR0FBR2kxRjtZQUNqQmoxRixFQUFFbTRLLGtCQUFrQixDQUFDelQsNkJBQTZCLENBQUMxa0ssRUFBRW82SixXQUFXLEVBQUVwNkosRUFBRXE2SixZQUFZO1lBQ2hGcjZKLEVBQUVtNEssa0JBQWtCLENBQUNDLFNBQVMsR0FBRztRQUNuQztJQUNGO0lBQ0E7UUFDRSwyREFBMkQ7UUFDM0QsMEZBQTBGO1FBQzFGcDRLLEVBQUV1a0gsbUJBQW1CLEdBQUcsU0FBVS92RyxDQUFDLEVBQUV5SixDQUFDLEVBQUVvbUcsdUJBQXVCLEVBQUVDLE9BQU87WUFDdEUsbUVBQW1FO1lBQ25FLE9BQU9pMkQseUJBQXlCdjZLLEdBQUd3VSxHQUFHeUo7UUFDeEM7SUFDRjtJQUNBO1FBQ0UscUZBQXFGO1FBQ3JGLElBQUl1OEosWUFBWXg2SyxFQUFFaWtJLDJCQUEyQjtRQUM3Q2prSSxFQUFFaWtJLDJCQUEyQixHQUFHO1lBQzlCdTJDLFVBQVV2NEssSUFBSSxDQUFDakM7WUFDZkEsRUFBRW00SyxrQkFBa0IsQ0FBQ0MsU0FBUyxHQUFHO1FBQ25DO0lBQ0Y7SUFDQTtRQUNFLHFGQUFxRjtRQUNyRixJQUFJcUMsYUFBYXo2SyxFQUFFK2tELE1BQU07UUFDekIva0QsRUFBRStrRCxNQUFNLEdBQUcsU0FBVXl0QyxTQUFTLEVBQUVqbEUsSUFBSTtZQUNsQ2t0SixXQUFXeDRLLElBQUksQ0FBQ2pDLEdBQUd3eUYsV0FBV2psRTtZQUM5QixJQUFJaWxFLGNBQWMsY0FBY0EsY0FBYyxVQUFVO2dCQUN0RHh5RixFQUFFbTRLLGtCQUFrQixDQUFDQyxTQUFTLEdBQUc7WUFDbkMsT0FBTyxJQUFJNWxGLGNBQWMsY0FBYztnQkFDckMsb0RBQW9EO2dCQUNwRHh5RixFQUFFcTRLLE9BQU8sQ0FBQzk2QixVQUFVLENBQUNod0gsTUFBTTtvQkFDekJ4WSxNQUFNO2dCQUNSO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTcWxLLFdBQVdwNkssQ0FBQztJQUNuQixJQUFJbytKLEtBQUtwK0osRUFBRTZqQixJQUFJLENBQUN3MEksUUFBUSxDQUFDcjRKLEVBQUU4M0ssS0FBSyxDQUFDO0lBQ2pDMVosR0FBRzk3SSxLQUFLLENBQUM4N0ksR0FBR3NjLGdCQUFnQixHQUFHdGMsR0FBR3VjLGdCQUFnQjtBQUNwRDtBQUNBLFNBQVMxZixZQUFZajdKLENBQUM7SUFDcEIseUVBQXlFO0lBQ3pFLElBQUlzaUIsUUFBUSxTQUFTQSxNQUFNZzBELE9BQU87UUFDaENBLFFBQVFrNkUsSUFBSTtRQUNabDZFLFFBQVEwckUsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztRQUNwQzFyRSxRQUFRMnJFLFNBQVMsQ0FBQyxHQUFHLEdBQUdqaUosRUFBRW82SixXQUFXLEVBQUVwNkosRUFBRXE2SixZQUFZO1FBQ3JEL2pGLFFBQVEzeUQsT0FBTztJQUNqQjtJQUNBckIsTUFBTXRpQixFQUFFNmpCLElBQUksQ0FBQ3cwSSxRQUFRLENBQUNyNEosRUFBRWs3SixJQUFJLENBQUM7SUFDN0I1NEksTUFBTXRpQixFQUFFNmpCLElBQUksQ0FBQ3cwSSxRQUFRLENBQUNyNEosRUFBRW03SixJQUFJLENBQUM7QUFDL0I7QUFDQSxTQUFTeWYsb0JBQW9CNTZLLENBQUM7SUFDNUIsSUFBSW85QixRQUFRcDlCLEVBQUVvNkosV0FBVztJQUN6QixJQUFJLzhILFNBQVNyOUIsRUFBRXE2SixZQUFZO0lBQzNCLElBQUl3Z0Isd0JBQXdCcmIsb0JBQW9CeC9KLElBQzlDeW1CLE1BQU1vMEosc0JBQXNCcDBKLEdBQUcsRUFDL0JDLE9BQU9tMEosc0JBQXNCbjBKLElBQUk7SUFDbkMsSUFBSXMzRCxZQUFZbDdEO0lBQ2hCdS9ILFVBQVVya0UsV0FBV0EsV0FBVztRQUFDdjNELElBQUlqUyxDQUFDO1FBQUVpUyxJQUFJeEksQ0FBQztLQUFDO0lBQzlDaWUsTUFBTThoRCxXQUFXQSxXQUFXO1FBQUN0M0Q7UUFBTUE7S0FBSztJQUN4QyxJQUFJbzBKLGVBQWVoNEo7SUFDbkJpbkIsV0FBVyt3SSxjQUFjMTlJLE9BQU9DO0lBQ2hDLElBQUkwOUksVUFBVWo0SjtJQUNkOGhKLFNBQVNtVyxTQUFTRCxjQUFjOThGO0lBQ2hDLE9BQU8rOEY7QUFDVDtBQUNBLFNBQVN4ZSxvQkFBb0J2OEosQ0FBQyxFQUFFczJFLE9BQU87SUFDckMsSUFBSWw1QyxRQUFRcDlCLEVBQUVvNkosV0FBVztJQUN6QixJQUFJLzhILFNBQVNyOUIsRUFBRXE2SixZQUFZO0lBQzNCLElBQUkyZ0IseUJBQXlCeGIsb0JBQW9CeC9KLElBQy9DeW1CLE1BQU11MEosdUJBQXVCdjBKLEdBQUcsRUFDaENDLE9BQU9zMEosdUJBQXVCdDBKLElBQUk7SUFDcEM0dkQsUUFBUTByRSxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQ3BDMXJFLFFBQVEyckUsU0FBUyxDQUFDLEdBQUcsR0FBRzdrSCxPQUFPQztJQUMvQmk1QyxRQUFRK3JFLFNBQVMsQ0FBQzU3SCxJQUFJalMsQ0FBQyxFQUFFaVMsSUFBSXhJLENBQUM7SUFDOUJxNEQsUUFBUXA2QyxLQUFLLENBQUN4VixNQUFNQTtBQUN0QjtBQUNBLFNBQVMwMkksdUJBQXVCcDlKLENBQUMsRUFBRWdVLE9BQU87SUFDeENoVSxFQUFFbzlKLHNCQUFzQixDQUFDcHBKLFNBQVMsU0FBVXNpRSxPQUFPO1FBQ2pELE9BQU9pbUYsb0JBQW9CdjhKLEdBQUdzMkU7SUFDaEM7QUFDRjtBQUNBLFNBQVMya0csU0FBU2o3SyxDQUFDO0lBQ2pCLGVBQWU7SUFDZixJQUFJczJFLFVBQVV0MkUsRUFBRTZqQixJQUFJLENBQUN3MEksUUFBUSxDQUFDcjRKLEVBQUVrN0osSUFBSSxDQUFDO0lBQ3JDNWtGLFFBQVFrNkUsSUFBSTtJQUNaK0wsb0JBQW9CdjhKLEdBQUdzMkU7SUFDdkJBLFFBQVFnM0UsV0FBVyxHQUFHO0lBQ3RCaDNFLFFBQVEweEUsU0FBUztJQUNqQjF4RSxRQUFRNHhFLE1BQU0sQ0FBQyxDQUFDLEtBQUs7SUFDckI1eEUsUUFBUTYxQyxNQUFNLENBQUMsTUFBTTtJQUNyQjcxQyxRQUFRODJFLE1BQU07SUFDZDkyRSxRQUFRMHhFLFNBQVM7SUFDakIxeEUsUUFBUTR4RSxNQUFNLENBQUMsR0FBRyxDQUFDO0lBQ25CNXhFLFFBQVE2MUMsTUFBTSxDQUFDLEdBQUc7SUFDbEI3MUMsUUFBUTgyRSxNQUFNO0lBQ2Q5MkUsUUFBUTN5RCxPQUFPO0FBQ2pCO0FBQ0EsU0FBU3UzSixZQUFZbDdLLENBQUM7SUFDcEIsMkVBQTJFO0lBQzNFLElBQUlpaUgsT0FBTyxTQUFTQSxLQUFLbzJELE9BQU8sRUFBRTkwSyxJQUFJLEVBQUV1dEMsR0FBRztRQUN6QyxJQUFJMXJDLGFBQWFpekssUUFBUTNJLFlBQVksQ0FBQzFFLGtCQUFrQixDQUFDem5LO1FBQ3pELElBQUkreUUsVUFBVXQyRSxFQUFFNmpCLElBQUksQ0FBQ3cwSSxRQUFRLENBQUNyNEosRUFBRWs3SixJQUFJLENBQUM7UUFDckMsSUFBSWdOLFVBQVU5aUssV0FBVzhpSyxPQUFPO1FBQ2hDLElBQUssSUFBSS8rSSxLQUFLLEdBQUdBLEtBQUsrK0ksUUFBUWhvSyxNQUFNLEVBQUVpcEIsS0FBTTtZQUMxQyxJQUFJby9JLFFBQVFMLE9BQU8sQ0FBQy8rSSxHQUFHO1lBQ3ZCLElBQUkyM0csU0FBU3luQyxNQUFNem5DLE1BQU07WUFDekIsSUFBSUEsUUFBUTtnQkFDVixJQUFJM2hILElBQUkyaEgsT0FBTzFqRyxLQUFLO2dCQUNwQixJQUFJN3pCLElBQUl1M0gsT0FBT3pqRyxNQUFNO2dCQUNyQixJQUFJN29CLElBQUkySyxJQUFJZ0s7Z0JBQ1osSUFBSWxMLElBQUk2aUgsT0FBT3pqRyxNQUFNLEdBQUd5VDtnQkFDeEIsSUFBSTVVLFFBQVE7Z0JBQ1pvNkMsUUFBUWs2RSxJQUFJO2dCQUNabDZFLFFBQVFwNkMsS0FBSyxDQUFDQSxPQUFPQTtnQkFDckJvNkMsUUFBUXlyRSxTQUFTLENBQUNqaEIsUUFBUXRzSCxHQUFHeUo7Z0JBQzdCcTRELFFBQVFnM0UsV0FBVyxHQUFHO2dCQUN0QmgzRSxRQUFRcXRDLElBQUksQ0FBQ252RyxHQUFHeUosR0FBR2tCLEdBQUc1VjtnQkFDdEIrc0UsUUFBUTgyRSxNQUFNO2dCQUNkOTJFLFFBQVEzeUQsT0FBTztZQUNqQjtRQUNGO0lBQ0Y7SUFDQSxJQUFJbGhCLElBQUk7SUFDUncvRyxLQUFLamlILEVBQUVxNEssT0FBTyxFQUFFLFFBQVE1MUs7SUFDeEJ3L0csS0FBS2ppSCxFQUFFcTRLLE9BQU8sRUFBRSxTQUFTNTFLO0FBQzNCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBUzA0SyxrQkFBa0JuN0ssQ0FBQyxFQUFFaXJGLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDOUMsSUFBSTUyRSxHQUFHeUosR0FBR2tCLEdBQUc1VjtJQUNiLElBQUk2eEsseUJBQXlCNWIsb0JBQW9CeC9KLElBQy9DeW1CLE1BQU0yMEosdUJBQXVCMzBKLEdBQUcsRUFDaENDLE9BQU8wMEosdUJBQXVCMTBKLElBQUk7SUFDcEM7UUFDRSxJQUFJMjBKLHdCQUF3QjdpSix3QkFBd0J4NEIsR0FBR3ltQixLQUFLQyxNQUFNdWtFLEtBQUtDLE1BQ3JFb3dGLHlCQUF5Qno0SyxlQUFldzRLLHVCQUF1QixJQUMvREUsTUFBTUQsc0JBQXNCLENBQUMsRUFBRSxFQUMvQkUsTUFBTUYsc0JBQXNCLENBQUMsRUFBRTtRQUNqQyxJQUFJMTZLLElBQUksR0FBRyxpQkFBaUI7UUFDNUI0VCxJQUFJK21LLE1BQU0zNkssSUFBSTtRQUNkcWQsSUFBSXU5SixNQUFNNTZLLElBQUk7UUFDZHVlLElBQUl2ZTtRQUNKMkksSUFBSTNJO0lBQ047SUFDQSxJQUFJdWUsTUFBTSxLQUFLNVYsTUFBTSxHQUFHO1FBQ3RCLE9BQU8sRUFBRTtJQUNYO0lBQ0EsSUFBSTYwSixLQUFLcCtKLEVBQUU2akIsSUFBSSxDQUFDdzBJLFFBQVEsQ0FBQ3I0SixFQUFFODNLLEtBQUssQ0FBQztJQUNqQzFaLEdBQUdpRyxlQUFlLENBQUNqRyxHQUFHa0csV0FBVyxFQUFFdGtLLEVBQUVtNEssa0JBQWtCO0lBQ3ZELElBQUluNEssRUFBRW00SyxrQkFBa0IsQ0FBQ0MsU0FBUyxFQUFFO1FBQ2xDLG9EQUFvRDtRQUNwRGhhLEdBQUd0d0QsUUFBUSxDQUFDLEdBQUcsR0FBR3N3RCxHQUFHdDlCLE1BQU0sQ0FBQzFqRyxLQUFLLEVBQUVnaEksR0FBR3Q5QixNQUFNLENBQUN6akcsTUFBTTtRQUNuRGc5SSxZQUFZcjZLLEdBQUcsTUFBTXN1SyxjQUFjRyxPQUFPO1FBQzFDenVLLEVBQUVtNEssa0JBQWtCLENBQUNDLFNBQVMsR0FBRztJQUNuQztJQUNBLElBQUloNEssSUFBSStlLElBQUk1VixHQUFHLDJCQUEyQjtJQUMxQyxJQUFJc2EsT0FBTyxJQUFJNDNKLFdBQVdyN0ssSUFBSSxJQUFJLG9CQUFvQjtJQUN0RGcrSixHQUFHc2QsVUFBVSxDQUFDbG5LLEdBQUd5SixHQUFHa0IsR0FBRzVWLEdBQUc2MEosR0FBRzhDLElBQUksRUFBRTlDLEdBQUcrQyxhQUFhLEVBQUV0OUk7SUFDckR1NkksR0FBR2lHLGVBQWUsQ0FBQ2pHLEdBQUdrRyxXQUFXLEVBQUU7SUFDbkMsSUFBSXFYLFVBQVUsSUFBSXA0SjtJQUNsQixJQUFLLElBQUk5Z0IsSUFBSSxHQUFHQSxJQUFJckMsR0FBR3FDLElBQUs7UUFDMUIsSUFBSW01SyxRQUFRLzNKLEtBQUt2Z0IsS0FBSyxDQUFDYixJQUFJLEdBQUdBLElBQUksSUFBSTtRQUN0QyxJQUFJMlQsUUFBUTJwSixZQUFZNmIsU0FBUyxHQUFHLG1FQUFtRTtRQUN2RyxJQUFJeGxLLFNBQVMsR0FBRztZQUNkdWxLLFFBQVExNEosR0FBRyxDQUFDN007UUFDZDtJQUNGO0lBQ0EsT0FBT3VsSztBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTcEIseUJBQXlCdjZLLENBQUMsRUFBRXdVLENBQUMsRUFBRXlKLENBQUM7SUFDdkMsb0JBQW9CO0lBQ3BCLElBQUkwOUosVUFBVVIsa0JBQWtCbjdLLEdBQUd3VSxHQUFHeUo7SUFDdEMsSUFBSXNQLE9BQU92dEIsRUFBRXdrSCxvQkFBb0I7SUFDakMsSUFBSXA3RixNQUFNQztJQUNWLElBQUl1Z0IsWUFBWXJvQywyQkFBMkJvNkssVUFDekM5eEk7SUFDRixJQUFJO1FBQ0YsSUFBS0QsVUFBVWhvQyxDQUFDLElBQUksQ0FBQyxDQUFDaW9DLFFBQVFELFVBQVV4cEMsQ0FBQyxFQUFDLEVBQUd5QixJQUFJLEVBQUc7WUFDbEQsSUFBSXVVLFFBQVF5ekIsTUFBTS9uQyxLQUFLO1lBQ3ZCLElBQUkwZixNQUFNK0wsSUFBSSxDQUFDblgsTUFBTTtZQUNyQixJQUFJLENBQUNnVCxRQUFRNUgsSUFBSW9FLE1BQU0sSUFBSTtnQkFDekJ3RCxPQUFPNUg7WUFDVDtZQUNBLElBQUksQ0FBQzZILFFBQVE3SCxJQUFJbTZCLE1BQU0sSUFBSTtnQkFDekJ0eUIsT0FBTzdIO1lBQ1Q7WUFDQSxJQUFJNEgsUUFBUUMsTUFBTTtnQkFDaEI7WUFDRjtRQUNGO0lBQ0YsRUFBRSxPQUFPMmdCLEtBQUs7UUFDWkosVUFBVXpwQyxDQUFDLENBQUM2cEM7SUFDZCxTQUFVO1FBQ1JKLFVBQVU3bkMsQ0FBQztJQUNiO0lBQ0EsT0FBTztRQUFDcW5CO1FBQU1DO0tBQUssQ0FBQ2xHLE1BQU0sQ0FBQzA0SjtBQUM3QjtBQUVBOztDQUVDLEdBQ0QsU0FBU0MsUUFBUTk3SyxDQUFDLEVBQUVvVyxLQUFLLEVBQUVvTCxHQUFHO0lBQzVCLElBQUk2MkosVUFBVXI0SyxFQUFFcTRLLE9BQU87SUFDdkJqaUssU0FBUyxHQUFHLHlFQUF5RTtJQUNyRixJQUFJb0wsSUFBSW9FLE1BQU0sSUFBSTtRQUNoQnl5SixRQUFRenZCLFFBQVEsQ0FBQ3BuSSxLQUFLcEwsT0FBTztRQUM3QmlpSyxRQUFRenZCLFFBQVEsQ0FBQ3BuSSxLQUFLcEwsT0FBTztRQUM3QmlpSyxRQUFRbkYsV0FBVyxDQUFDMXhKLEtBQUtwTCxPQUFPO1FBQ2hDaWlLLFFBQVF6dkIsUUFBUSxDQUFDcG5JLEtBQUtwTCxPQUFPO0lBQy9CLE9BQU87UUFDTGlpSyxRQUFROUMsWUFBWSxDQUFDL3pKLEtBQUtwTDtRQUMxQmlpSyxRQUFRakQsYUFBYSxDQUFDNXpKLEtBQUtwTCxPQUFPO1FBQ2xDaWlLLFFBQVFqRCxhQUFhLENBQUM1ekosS0FBS3BMLE9BQU87UUFDbENpaUssUUFBUW5GLFdBQVcsQ0FBQzF4SixLQUFLcEwsT0FBTztRQUNoQ2lpSyxRQUFRbkYsV0FBVyxDQUFDMXhKLEtBQUtwTCxPQUFPO1FBQ2hDaWlLLFFBQVFuRixXQUFXLENBQUMxeEosS0FBS3BMLE9BQU87SUFDbEM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU2lrSyxZQUFZcjZLLENBQUMsRUFBRWdVLE9BQU8sRUFBRW84SixZQUFZO0lBQzNDLElBQUlqN0k7SUFDSixJQUFJbjFCLEVBQUU4ekYsVUFBVSxFQUFFO1FBQ2hCMytELFFBQVFwWixZQUFZbEcsR0FBRyxJQUFJLCtCQUErQjtJQUM1RDtJQUNBLElBQUl3aUssVUFBVXI0SyxFQUFFcTRLLE9BQU87SUFDdkIsSUFBSTBELFdBQVc7SUFDZixJQUFJM0wsYUFBYTVCLE1BQU0sRUFBRTtRQUN2QixJQUFJeHVLLEVBQUU2akIsSUFBSSxDQUFDeTNJLGlCQUFpQixDQUFDdDdKLEVBQUUrN0osVUFBVSxDQUFDLEVBQUU7WUFDMUNxQix1QkFBdUJwOUosR0FBR2dVO1FBQzVCO0lBQ0Y7SUFFQSw4Q0FBOEM7SUFDOUMsSUFBSWhVLEVBQUU2akIsSUFBSSxDQUFDeTNJLGlCQUFpQixDQUFDdDdKLEVBQUVrN0osSUFBSSxDQUFDLElBQUlrVixhQUFhMUIsT0FBTyxFQUFFO1FBQzVELElBQUl0USxLQUFLcCtKLEVBQUU2akIsSUFBSSxDQUFDdzBJLFFBQVEsQ0FBQ3I0SixFQUFFODNLLEtBQUssQ0FBQztRQUNqQyxJQUFJMUgsYUFBYTVCLE1BQU0sRUFBRTtZQUN2QnBRLEdBQUc0ZCxVQUFVLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxtQkFBbUI7WUFDOUM1ZCxHQUFHNmQsTUFBTSxDQUFDN2QsR0FBRzhkLEtBQUssR0FBRyxrQ0FBa0M7WUFDdkQ5ZCxHQUFHK2QsU0FBUyxDQUFDL2QsR0FBR2dlLEdBQUcsRUFBRWhlLEdBQUdpZSxtQkFBbUIsR0FBRyx1Q0FBdUM7UUFDdkYsT0FBTztZQUNMamUsR0FBR2tlLE9BQU8sQ0FBQ2xlLEdBQUc4ZCxLQUFLLEdBQUcsd0RBQXdEO1FBQ2hGO1FBQ0E5ZCxHQUFHOTdJLEtBQUssQ0FBQzg3SSxHQUFHc2MsZ0JBQWdCLEdBQUd0YyxHQUFHdWMsZ0JBQWdCO1FBQ2xEdmMsR0FBR3R3RCxRQUFRLENBQUMsR0FBRyxHQUFHc3dELEdBQUd0OUIsTUFBTSxDQUFDMWpHLEtBQUssRUFBRWdoSSxHQUFHdDlCLE1BQU0sQ0FBQ3pqRyxNQUFNO1FBQ25ELElBQUl1MUksZ0JBQWdCZ0ksb0JBQW9CNTZLO1FBQ3hDLElBQUl1dEIsT0FBT3Z0QixFQUFFd2tILG9CQUFvQjtRQUNqQ3UzRCxXQUFXeHVKLEtBQUtydEIsTUFBTTtRQUN0Qm00SyxRQUFRMUYsVUFBVSxDQUFDQyxlQUFleEM7UUFDbEMsSUFBSUEsYUFBYTVCLE1BQU0sRUFBRTtZQUN2QixJQUFLLElBQUkvckssSUFBSSxHQUFHQSxJQUFJOHFCLEtBQUt1MkcsT0FBTyxDQUFDNWpJLE1BQU0sRUFBRXVDLElBQUs7Z0JBQzVDcTVLLFFBQVE5N0ssR0FBR3lDLEdBQUc4cUIsS0FBS3UyRyxPQUFPLENBQUNyaEksRUFBRTtZQUMvQjtZQUNBLElBQUssSUFBSXNtQixNQUFNLEdBQUdBLE1BQU13RSxLQUFLczJHLElBQUksQ0FBQzNqSSxNQUFNLEVBQUU2b0IsTUFBTztnQkFDL0MreUosUUFBUTk3SyxHQUFHK29CLEtBQUt3RSxLQUFLczJHLElBQUksQ0FBQzk2RyxJQUFJO1lBQ2hDO1FBQ0YsT0FBTyxJQUFJcW5KLGFBQWExQixPQUFPLEVBQUU7WUFDL0IsSUFBSyxJQUFJcDNJLE1BQU0sR0FBR0EsTUFBTS9KLEtBQUtydEIsTUFBTSxFQUFFbzNCLE1BQU87Z0JBQzFDd2tKLFFBQVE5N0ssR0FBR3MzQixLQUFLL0osSUFBSSxDQUFDK0osSUFBSTtZQUMzQjtRQUNGO1FBQ0ErZ0osUUFBUXJGLFFBQVE7UUFDaEIsSUFBSTVDLGFBQWE1QixNQUFNLElBQUl4dUssRUFBRSt6RixxQkFBcUIsRUFBRTtZQUNsRGtuRixTQUFTajdLO1lBQ1RrN0ssWUFBWWw3SztRQUNkO1FBQ0FBLEVBQUU2akIsSUFBSSxDQUFDeTNJLGlCQUFpQixDQUFDdDdKLEVBQUVrN0osSUFBSSxDQUFDLEdBQUc7UUFDbkNsN0osRUFBRTZqQixJQUFJLENBQUN5M0ksaUJBQWlCLENBQUN0N0osRUFBRW03SixJQUFJLENBQUMsR0FBRztJQUNyQztJQUNBLElBQUluN0osRUFBRTh6RixVQUFVLEVBQUU7UUFDaEIsb0NBQW9DO1FBQ3BDLElBQUlsZ0UsTUFBTTdYLFlBQVlsRyxHQUFHO1FBQ3pCLElBQUkwbUssVUFBVTtRQUNkLElBQUkxaEssT0FBTzdWLEtBQUs0eEIsSUFBSSxDQUFDaEQsTUFBTXVCO1FBQzNCLElBQUlpNEksWUFBWWlMLFFBQVFsTCxZQUFZO1FBQ3BDLElBQUlxUCxTQUFTO1lBQUMsR0FBR3Z4SixNQUFNLENBQUM4d0osVUFBVTtZQUFjLEdBQUc5d0osTUFBTSxDQUFDbWlKLFVBQVV1SyxjQUFjLEVBQUU7WUFBZSxHQUFHMXNKLE1BQU0sQ0FBQ21pSixVQUFVcDZFLFVBQVUsRUFBRTtZQUFhLEdBQUcvbkUsTUFBTSxDQUFDbWlKLFVBQVVxSyxZQUFZLEVBQUU7WUFBYSxHQUFHeHNKLE1BQU0sQ0FBQ21pSixVQUFVeUYsWUFBWSxFQUFFO1lBQXNCLEdBQUc1bkosTUFBTSxDQUFDbWlKLFVBQVUwRixXQUFXLEVBQUU7U0FBa0IsQ0FBQ3BzSyxJQUFJLENBQUM7UUFDaFQsSUFBSTYxSyxTQUFTO1lBQ1gvOEosUUFBUWdCLEdBQUcsQ0FBQyxVQUFVeUssTUFBTSxDQUFDbWxKLGFBQWE3c0ssSUFBSSxFQUFFLGFBQWEwbkIsTUFBTSxDQUFDcFEsTUFBTSxRQUFRb1EsTUFBTSxDQUFDdXhKO1FBQzNGLE9BQU87WUFDTGg5SixRQUFRZ0IsR0FBRyxDQUFDLFVBQVV5SyxNQUFNLENBQUNtbEosYUFBYTdzSyxJQUFJLEVBQUUsbUJBQW1CMG5CLE1BQU0sQ0FBQ3BRLE1BQU07WUFDaEYyRSxRQUFRZ0IsR0FBRyxDQUFDO1lBQ1poQixRQUFRZ0IsR0FBRyxDQUFDLEtBQUt5SyxNQUFNLENBQUN1eEo7WUFDeEJoOUosUUFBUWdCLEdBQUcsQ0FBQztZQUNaLElBQUlnekosWUFBWXBHLFVBQVVvRyxTQUFTO1lBQ25DLElBQUlwcEksYUFBYTdvQywyQkFBMkJpeUssWUFDMUNucEk7WUFDRixJQUFJO2dCQUNGLElBQUtELFdBQVd4b0MsQ0FBQyxJQUFJLENBQUMsQ0FBQ3lvQyxTQUFTRCxXQUFXaHFDLENBQUMsRUFBQyxFQUFHeUIsSUFBSSxFQUFHO29CQUNyRCxJQUFJa3lCLE9BQU9zVyxPQUFPdm9DLEtBQUs7b0JBQ3ZCMGQsUUFBUWdCLEdBQUcsQ0FBQyxLQUFLeUssTUFBTSxDQUFDOEksS0FBS2hmLElBQUksRUFBRSxNQUFNa1csTUFBTSxDQUFDOEksS0FBSzAxSSxRQUFRLEVBQUUsV0FBV3grSSxNQUFNLENBQUM4SSxLQUFLMjFJLFVBQVUsRUFBRTtnQkFDcEc7WUFDRixFQUFFLE9BQU8xL0gsS0FBSztnQkFDWkksV0FBV2pxQyxDQUFDLENBQUM2cEM7WUFDZixTQUFVO2dCQUNSSSxXQUFXcm9DLENBQUM7WUFDZDtZQUNBeWQsUUFBUWdCLEdBQUcsQ0FBQztRQUNkO0lBQ0Y7SUFDQSxJQUFJeGdCLEVBQUU2akIsSUFBSSxDQUFDcXBGLEVBQUUsRUFBRTtRQUNiMXRGLFFBQVFnQixHQUFHLENBQUM7UUFDWnhnQixFQUFFNmpCLElBQUksQ0FBQ3FwRixFQUFFLEdBQUc7UUFDWm1yRSxRQUFRbnJFLEVBQUU7SUFDWjtBQUNGO0FBRUEsSUFBSXV2RSxRQUFRLENBQUM7QUFFYixxQkFBcUI7QUFDckJBLE1BQU10bEIsZUFBZSxHQUFHLFNBQVU3Z0YsT0FBTyxFQUFFOWhFLENBQUMsRUFBRXlKLENBQUMsRUFBRW1mLEtBQUssRUFBRUMsTUFBTSxFQUFFNkUsTUFBTTtJQUNwRSxJQUFJMkUsUUFBUXpKLFFBQVE7SUFDcEIsSUFBSTBKLFFBQVF6SixTQUFTO0lBQ3JCLElBQUlpNUMsUUFBUTB4RSxTQUFTLEVBQUU7UUFDckIxeEUsUUFBUTB4RSxTQUFTO0lBQ25CO0lBQ0ExeEUsUUFBUTR4RSxNQUFNLENBQUMxekksSUFBSXF5QixRQUFRM0UsTUFBTSxDQUFDLEVBQUUsRUFBRWprQixJQUFJNm9CLFFBQVE1RSxNQUFNLENBQUMsRUFBRTtJQUMzRCxJQUFLLElBQUl6L0IsSUFBSSxHQUFHQSxJQUFJeS9CLE9BQU9oaUMsTUFBTSxHQUFHLEdBQUd1QyxJQUFLO1FBQzFDNnpFLFFBQVE2MUMsTUFBTSxDQUFDMzNHLElBQUlxeUIsUUFBUTNFLE1BQU0sQ0FBQ3ovQixJQUFJLEVBQUUsRUFBRXdiLElBQUk2b0IsUUFBUTVFLE1BQU0sQ0FBQ3ovQixJQUFJLElBQUksRUFBRTtJQUN6RTtJQUNBNnpFLFFBQVE2eEUsU0FBUztBQUNuQjtBQUNBczBCLE1BQU0zbEIsb0JBQW9CLEdBQUcsU0FBVXhnRixPQUFPLEVBQUU5aEUsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFbWYsS0FBSyxFQUFFQyxNQUFNLEVBQUU2RSxNQUFNLEVBQUVZLE9BQU87SUFDbEZBLFFBQVExZixPQUFPLENBQUMsU0FBVTRmLE1BQU07UUFDOUIsT0FBT2dwRix3QkFBd0IxMUMsU0FBU3R6QztJQUMxQztJQUNBc3pDLFFBQVE2eEUsU0FBUztBQUNuQjtBQUVBLDBCQUEwQjtBQUMxQnMwQixNQUFNMWxCLHNCQUFzQixHQUFHLFNBQVV6Z0YsT0FBTyxFQUFFOWhFLENBQUMsRUFBRXlKLENBQUMsRUFBRW1mLEtBQUssRUFBRUMsTUFBTSxFQUFFUSxNQUFNO0lBQzNFLElBQUlHLFlBQVlaLFFBQVE7SUFDeEIsSUFBSWEsYUFBYVosU0FBUztJQUMxQixJQUFJUyxlQUFlRCxXQUFXLFNBQVNFLHdCQUF3QlgsT0FBT0MsVUFBVXI0QixLQUFLK1UsR0FBRyxDQUFDOGpCLFFBQVFJLFlBQVlEO0lBQzdHLElBQUlzNEMsUUFBUTB4RSxTQUFTLEVBQUU7UUFDckIxeEUsUUFBUTB4RSxTQUFTO0lBQ25CO0lBRUEsc0JBQXNCO0lBQ3RCMXhFLFFBQVE0eEUsTUFBTSxDQUFDMXpJLEdBQUd5SixJQUFJZ2dCO0lBQ3RCLG9DQUFvQztJQUNwQ3E0QyxRQUFRb21HLEtBQUssQ0FBQ2xvSyxJQUFJd3BCLFdBQVcvZixJQUFJZ2dCLFlBQVl6cEIsSUFBSXdwQixXQUFXL2YsR0FBRzZmO0lBQy9ELGdDQUFnQztJQUNoQ3c0QyxRQUFRb21HLEtBQUssQ0FBQ2xvSyxJQUFJd3BCLFdBQVcvZixJQUFJZ2dCLFlBQVl6cEIsR0FBR3lKLElBQUlnZ0IsWUFBWUg7SUFDaEUsK0JBQStCO0lBQy9CdzRDLFFBQVFvbUcsS0FBSyxDQUFDbG9LLElBQUl3cEIsV0FBVy9mLElBQUlnZ0IsWUFBWXpwQixJQUFJd3BCLFdBQVcvZixHQUFHNmY7SUFDL0Qsa0NBQWtDO0lBQ2xDdzRDLFFBQVFvbUcsS0FBSyxDQUFDbG9LLElBQUl3cEIsV0FBVy9mLElBQUlnZ0IsWUFBWXpwQixHQUFHeUosSUFBSWdnQixZQUFZSDtJQUNoRSxZQUFZO0lBQ1p3NEMsUUFBUTYxQyxNQUFNLENBQUMzM0csR0FBR3lKLElBQUlnZ0I7SUFDdEJxNEMsUUFBUTZ4RSxTQUFTO0FBQ25CO0FBQ0FzMEIsTUFBTXhsQiw0QkFBNEIsR0FBRyxTQUFVM2dGLE9BQU8sRUFBRTloRSxDQUFDLEVBQUV5SixDQUFDLEVBQUVtZixLQUFLLEVBQUVDLE1BQU0sRUFBRVEsTUFBTTtJQUNqRixJQUFJRyxZQUFZWixRQUFRO0lBQ3hCLElBQUlhLGFBQWFaLFNBQVM7SUFDMUIsSUFBSVMsZUFBZUQsV0FBVyxTQUFTRSx3QkFBd0JYLE9BQU9DLFVBQVVRO0lBQ2hGLElBQUl5NEMsUUFBUTB4RSxTQUFTLEVBQUU7UUFDckIxeEUsUUFBUTB4RSxTQUFTO0lBQ25CO0lBRUEsc0JBQXNCO0lBQ3RCMXhFLFFBQVE0eEUsTUFBTSxDQUFDMXpJLEdBQUd5SixJQUFJZ2dCO0lBQ3RCcTRDLFFBQVE2MUMsTUFBTSxDQUFDMzNHLElBQUl3cEIsV0FBVy9mLElBQUlnZ0I7SUFDbENxNEMsUUFBUTYxQyxNQUFNLENBQUMzM0csSUFBSXdwQixXQUFXL2Y7SUFDOUJxNEQsUUFBUW9tRyxLQUFLLENBQUNsb0ssSUFBSXdwQixXQUFXL2YsSUFBSWdnQixZQUFZenBCLEdBQUd5SixJQUFJZ2dCLFlBQVlIO0lBQ2hFdzRDLFFBQVFvbUcsS0FBSyxDQUFDbG9LLElBQUl3cEIsV0FBVy9mLElBQUlnZ0IsWUFBWXpwQixJQUFJd3BCLFdBQVcvZixHQUFHNmY7SUFDL0R3NEMsUUFBUTYxQyxNQUFNLENBQUMzM0csSUFBSXdwQixXQUFXL2YsSUFBSWdnQjtJQUNsQ3E0QyxRQUFRNjFDLE1BQU0sQ0FBQzMzRyxHQUFHeUosSUFBSWdnQjtJQUN0QnE0QyxRQUFRNnhFLFNBQVM7QUFDbkI7QUFDQXMwQixNQUFNemxCLG9CQUFvQixHQUFHLFNBQVUxZ0YsT0FBTyxFQUFFOWhFLENBQUMsRUFBRXlKLENBQUMsRUFBRW1mLEtBQUssRUFBRUMsTUFBTSxFQUFFNkUsTUFBTSxFQUFFWSxPQUFPO0lBQ2xGLElBQUk5RSxZQUFZWixRQUFRO0lBQ3hCLElBQUlhLGFBQWFaLFNBQVM7SUFDMUIsSUFBSWszRyxlQUFlenhHLFlBQVksU0FBU2dHLGdDQUFnQ2hHO0lBQ3hFLElBQUl3ekMsUUFBUTB4RSxTQUFTLEVBQUU7UUFDckIxeEUsUUFBUTB4RSxTQUFTO0lBQ25CO0lBQ0ExeEUsUUFBUTR4RSxNQUFNLENBQUMxekksSUFBSXdwQixZQUFZdTJHLGNBQWN0MkgsSUFBSWdnQjtJQUNqRHE0QyxRQUFRNjFDLE1BQU0sQ0FBQzMzRyxJQUFJd3BCLFlBQVl1MkcsY0FBY3QySCxJQUFJZ2dCO0lBQ2pEcTRDLFFBQVE2MUMsTUFBTSxDQUFDMzNHLElBQUl3cEIsV0FBVy9mLElBQUlnZ0IsYUFBYXMyRztJQUMvQ2orRCxRQUFRNjFDLE1BQU0sQ0FBQzMzRyxJQUFJd3BCLFdBQVcvZixJQUFJZ2dCLGFBQWFzMkc7SUFDL0NqK0QsUUFBUTYxQyxNQUFNLENBQUMzM0csSUFBSXdwQixZQUFZdTJHLGNBQWN0MkgsSUFBSWdnQjtJQUNqRHE0QyxRQUFRNjFDLE1BQU0sQ0FBQzMzRyxJQUFJd3BCLFlBQVl1MkcsY0FBY3QySCxJQUFJZ2dCO0lBQ2pEcTRDLFFBQVE2MUMsTUFBTSxDQUFDMzNHLElBQUl3cEIsV0FBVy9mLElBQUlnZ0IsYUFBYXMyRztJQUMvQ2orRCxRQUFRNjFDLE1BQU0sQ0FBQzMzRyxJQUFJd3BCLFdBQVcvZixJQUFJZ2dCLGFBQWFzMkc7SUFDL0NqK0QsUUFBUTZ4RSxTQUFTO0FBQ25CO0FBQ0FzMEIsTUFBTXZsQixjQUFjLEdBQUcsU0FBVTVnRixPQUFPLEVBQUU5aEUsQ0FBQyxFQUFFeUosQ0FBQyxFQUFFbWYsS0FBSyxFQUFFQyxNQUFNO0lBQzNELElBQUlXLFlBQVlaLFFBQVE7SUFDeEIsSUFBSWEsYUFBYVosU0FBUztJQUMxQixJQUFJcTNHLFNBQVNsZ0ksSUFBSXdwQjtJQUNqQixJQUFJMjJHLE9BQU9uZ0ksSUFBSXdwQjtJQUNmLElBQUk0MkcsU0FBUzMySCxJQUFJZ2dCO0lBQ2pCLElBQUk0MkcsT0FBTzUySCxJQUFJZ2dCO0lBQ2YsSUFBSTArSSx1QkFBdUIzekksd0JBQXdCNUwsT0FBT0M7SUFDMUQsSUFBSXc0RyxVQUFVOG1DLHFCQUFxQnp6SSxXQUFXO0lBQzlDLElBQUkwc0csVUFBVSttQyxxQkFBcUIxekksWUFBWTtJQUMvQyxJQUFJNnNHLGdCQUFnQjZtQyxxQkFBcUJ4ekksZUFBZSxHQUFHMHNHO0lBQzNELElBQUl2L0QsUUFBUTB4RSxTQUFTLEVBQUU7UUFDckIxeEUsUUFBUTB4RSxTQUFTO0lBQ25CO0lBQ0ExeEUsUUFBUTR4RSxNQUFNLENBQUN4VCxRQUFRRSxTQUFTZ0I7SUFDaEN0L0QsUUFBUTYxQyxNQUFNLENBQUN1b0IsUUFBUUcsT0FBT2U7SUFDOUJ0L0QsUUFBUXN4RSxnQkFBZ0IsQ0FBQ2xULFNBQVNvQixlQUFlakIsTUFBTUgsU0FBU21CLFNBQVNoQjtJQUN6RXYrRCxRQUFRNjFDLE1BQU0sQ0FBQ3dvQixPQUFPa0IsU0FBU2hCO0lBQy9CditELFFBQVFzeEUsZ0JBQWdCLENBQUNqVCxPQUFPbUIsZUFBZWpCLE1BQU1GLE1BQU1FLE9BQU9lO0lBQ2xFdC9ELFFBQVE2MUMsTUFBTSxDQUFDd29CLE1BQU1DLFNBQVNnQjtJQUM5QnQvRCxRQUFRc3hFLGdCQUFnQixDQUFDalQsT0FBT21CLGVBQWVsQixRQUFRRCxPQUFPa0IsU0FBU2pCO0lBQ3ZFdCtELFFBQVE2MUMsTUFBTSxDQUFDdW9CLFNBQVNtQixTQUFTakI7SUFDakN0K0QsUUFBUXN4RSxnQkFBZ0IsQ0FBQ2xULFNBQVNvQixlQUFlbEIsUUFBUUYsUUFBUUUsU0FBU2dCO0lBQzFFdC9ELFFBQVE2eEUsU0FBUztBQUNuQjtBQUNBLElBQUl5MEIsT0FBTzUzSyxLQUFLeVosR0FBRyxDQUFDO0FBQ3BCLElBQUlvK0osT0FBTzczSyxLQUFLd1osR0FBRyxDQUFDO0FBQ3BCLElBQUlDLE1BQU0sQ0FBQztBQUNYLElBQUlELE1BQU0sQ0FBQztBQUNYLElBQUlzK0osa0JBQWtCOTNLLEtBQUtzWixFQUFFLEdBQUc7QUFDaEMsSUFBSyxJQUFJN2IsSUFBSSxJQUFJdUMsS0FBS3NaLEVBQUUsRUFBRTdiLElBQUksSUFBSXVDLEtBQUtzWixFQUFFLEVBQUU3YixLQUFLcTZLLGdCQUFpQjtJQUMvRHIrSixHQUFHLENBQUNoYyxFQUFFLEdBQUd1QyxLQUFLeVosR0FBRyxDQUFDaGM7SUFDbEIrYixHQUFHLENBQUMvYixFQUFFLEdBQUd1QyxLQUFLd1osR0FBRyxDQUFDL2I7QUFDcEI7QUFDQWc2SyxNQUFNN2xCLGVBQWUsR0FBRyxTQUFVdGdGLE9BQU8sRUFBRXA0RCxPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTTtJQUN4RSxJQUFJaTVDLFFBQVEweEUsU0FBUyxFQUFFO1FBQ3JCMXhFLFFBQVEweEUsU0FBUztJQUNuQjtJQUNBLElBQUkxeEUsUUFBUXltRyxPQUFPLEVBQUU7UUFDbkJ6bUcsUUFBUXltRyxPQUFPLENBQUM3K0osU0FBU0MsU0FBU2lmLFFBQVEsR0FBR0MsU0FBUyxHQUFHLEdBQUcsR0FBRyxJQUFJcjRCLEtBQUtzWixFQUFFO0lBQzVFLE9BQU87UUFDTCxJQUFJMCtKLE1BQU1DO1FBQ1YsSUFBSUMsS0FBSzkvSSxRQUFRO1FBQ2pCLElBQUkrL0ksS0FBSzkvSSxTQUFTO1FBQ2xCLElBQUssSUFBSTU2QixJQUFJLElBQUl1QyxLQUFLc1osRUFBRSxFQUFFN2IsSUFBSSxJQUFJdUMsS0FBS3NaLEVBQUUsRUFBRTdiLEtBQUtxNkssZ0JBQWlCO1lBQy9ERSxPQUFPOStKLFVBQVVnL0osS0FBS3orSixHQUFHLENBQUNoYyxFQUFFLEdBQUdtNkssT0FBT00sS0FBSzErSixHQUFHLENBQUMvYixFQUFFLEdBQUdvNks7WUFDcERJLE9BQU85K0osVUFBVWcvSixLQUFLMytKLEdBQUcsQ0FBQy9iLEVBQUUsR0FBR202SyxPQUFPTyxLQUFLMStKLEdBQUcsQ0FBQ2hjLEVBQUUsR0FBR282SztZQUNwRCxJQUFJcDZLLE1BQU0sR0FBRztnQkFDWDZ6RSxRQUFRNHhFLE1BQU0sQ0FBQzgwQixNQUFNQztZQUN2QixPQUFPO2dCQUNMM21HLFFBQVE2MUMsTUFBTSxDQUFDNndELE1BQU1DO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUNBM21HLFFBQVE2eEUsU0FBUztBQUNuQjtBQUVBLDhDQUE4QyxHQUU5QyxJQUFJaTFCLFFBQVEsQ0FBQztBQUNiQSxNQUFNL2EsWUFBWSxHQUFHLFNBQVVsakosQ0FBQyxFQUFFNVYsQ0FBQztJQUNqQyxJQUFJNDJKLFNBQVN2OEosU0FBU3M5SCxhQUFhLENBQUMsV0FBVywrQkFBK0I7SUFDOUVpL0IsT0FBTy9pSSxLQUFLLEdBQUdqZTtJQUNmZ2hKLE9BQU85aUksTUFBTSxHQUFHOXpCO0lBQ2hCLE9BQU87UUFBQzQySjtRQUFRQSxPQUFPaC9CLFVBQVUsQ0FBQztLQUFNO0FBQzFDO0FBQ0FpOEMsTUFBTUMsaUJBQWlCLEdBQUcsU0FBVXJwSyxPQUFPO0lBQ3pDLElBQUl5UCxLQUFLLElBQUksQ0FBQ0EsRUFBRTtJQUNoQixJQUFJOEosT0FBTzlKLEdBQUd3MUQsZUFBZTtJQUM3QixJQUFJditDLEtBQUtuTixLQUFLMW5CLFdBQVc7SUFDekIsSUFBSXkzSyxVQUFVLElBQUksQ0FBQy81RCx5QkFBeUI7SUFDNUMsSUFBSW5tRixRQUFRcHBCLFFBQVF1cEssSUFBSSxHQUFHdjRLLEtBQUs0eEIsSUFBSSxDQUFDOEQsR0FBR3ZiLENBQUMsSUFBSW0rSixPQUFPLENBQUMsRUFBRTtJQUN2RCxJQUFJamdKLFNBQVNycEIsUUFBUXVwSyxJQUFJLEdBQUd2NEssS0FBSzR4QixJQUFJLENBQUM4RCxHQUFHbnhCLENBQUMsSUFBSSt6SyxPQUFPLENBQUMsRUFBRTtJQUN4RCxJQUFJRSxlQUFlNTRLLFNBQVNvUCxRQUFReXBLLFFBQVEsS0FBSzc0SyxTQUFTb1AsUUFBUTBwSyxTQUFTO0lBQzNFLElBQUlscEYsVUFBVSxJQUFJLENBQUMybUQsYUFBYTtJQUNoQyxJQUFJai9HLFFBQVE7SUFDWixJQUFJbG9CLFFBQVFrb0IsS0FBSyxLQUFLajVCLFdBQVc7UUFDL0JtNkIsU0FBU3BwQixRQUFRa29CLEtBQUs7UUFDdEJtQixVQUFVcnBCLFFBQVFrb0IsS0FBSztRQUN2QkEsUUFBUWxvQixRQUFRa29CLEtBQUs7SUFDdkIsT0FBTyxJQUFJc2hKLGNBQWM7UUFDdkIsSUFBSUcsWUFBWTF2SjtRQUNoQixJQUFJMnZKLFlBQVkzdko7UUFDaEIsSUFBSXJwQixTQUFTb1AsUUFBUXlwSyxRQUFRLEdBQUc7WUFDOUJFLFlBQVl6aEosUUFBUWxvQixRQUFReXBLLFFBQVEsR0FBR3JnSjtRQUN6QztRQUNBLElBQUl4NEIsU0FBU29QLFFBQVEwcEssU0FBUyxHQUFHO1lBQy9CRSxZQUFZMWhKLFFBQVFsb0IsUUFBUTBwSyxTQUFTLEdBQUdyZ0o7UUFDMUM7UUFDQW5CLFFBQVFsM0IsS0FBSytVLEdBQUcsQ0FBQzRqSyxXQUFXQztRQUM1QnhnSixTQUFTbEI7UUFDVG1CLFVBQVVuQjtJQUNaO0lBQ0EsSUFBSSxDQUFDc2hKLGNBQWM7UUFDakJwZ0osU0FBU28zRDtRQUNUbjNELFVBQVVtM0Q7UUFDVnQ0RCxTQUFTczREO0lBQ1g7SUFDQSxJQUFJcXBGLGFBQWFqNkssU0FBU3M5SCxhQUFhLENBQUMsV0FBVywrQkFBK0I7SUFFbEYyOEMsV0FBV3pnSixLQUFLLEdBQUdBO0lBQ25CeWdKLFdBQVd4Z0osTUFBTSxHQUFHQTtJQUNwQndnSixXQUFXdDVKLEtBQUssQ0FBQzZZLEtBQUssR0FBR0EsUUFBUTtJQUNqQ3lnSixXQUFXdDVKLEtBQUssQ0FBQzhZLE1BQU0sR0FBR0EsU0FBUztJQUNuQyxJQUFJeWdKLFVBQVVELFdBQVcxOEMsVUFBVSxDQUFDO0lBRXBDLCtEQUErRDtJQUMvRCxJQUFJL2pHLFFBQVEsS0FBS0MsU0FBUyxHQUFHO1FBQzNCeWdKLFFBQVE3N0IsU0FBUyxDQUFDLEdBQUcsR0FBRzdrSCxPQUFPQztRQUMvQnlnSixRQUFRandCLHdCQUF3QixHQUFHO1FBQ25DLElBQUlrd0IsY0FBYyxJQUFJLENBQUN2NUQsb0JBQW9CO1FBQzNDLElBQUl4d0csUUFBUXVwSyxJQUFJLEVBQUU7WUFDaEIsb0NBQW9DO1lBQ3BDTyxRQUFRejdCLFNBQVMsQ0FBQyxDQUFDM25ILEdBQUc1MEIsRUFBRSxHQUFHbzJCLE9BQU8sQ0FBQ3hCLEdBQUcxMEIsRUFBRSxHQUFHazJCO1lBQzNDNGhKLFFBQVE1aEosS0FBSyxDQUFDQSxPQUFPQTtZQUNyQixJQUFJLENBQUNzdUgsWUFBWSxDQUFDc3pCLFNBQVNDO1lBQzNCRCxRQUFRNWhKLEtBQUssQ0FBQyxJQUFJQSxPQUFPLElBQUlBO1lBQzdCNGhKLFFBQVF6N0IsU0FBUyxDQUFDM25ILEdBQUc1MEIsRUFBRSxHQUFHbzJCLE9BQU94QixHQUFHMTBCLEVBQUUsR0FBR2syQjtRQUMzQyxPQUFPO1lBQ0wsd0JBQXdCO1lBQ3hCLElBQUl6VixNQUFNaEQsR0FBR2dELEdBQUc7WUFDaEIsSUFBSXk2RixjQUFjO2dCQUNoQjFzRyxHQUFHaVMsSUFBSWpTLENBQUMsR0FBRzBuQjtnQkFDWGplLEdBQUd3SSxJQUFJeEksQ0FBQyxHQUFHaWU7WUFDYjtZQUNBQSxTQUFTelksR0FBR2lELElBQUk7WUFDaEJvM0osUUFBUXo3QixTQUFTLENBQUNuaEMsWUFBWTFzRyxDQUFDLEVBQUUwc0csWUFBWWpqRyxDQUFDO1lBQzlDNi9KLFFBQVE1aEosS0FBSyxDQUFDQSxPQUFPQTtZQUNyQixJQUFJLENBQUNzdUgsWUFBWSxDQUFDc3pCLFNBQVNDO1lBQzNCRCxRQUFRNWhKLEtBQUssQ0FBQyxJQUFJQSxPQUFPLElBQUlBO1lBQzdCNGhKLFFBQVF6N0IsU0FBUyxDQUFDLENBQUNuaEMsWUFBWTFzRyxDQUFDLEVBQUUsQ0FBQzBzRyxZQUFZampHLENBQUM7UUFDbEQ7UUFFQSx1RkFBdUY7UUFDdkYsSUFBSWpLLFFBQVFrK0UsRUFBRSxFQUFFO1lBQ2Q0ckYsUUFBUWp3Qix3QkFBd0IsR0FBRztZQUNuQ2l3QixRQUFRendCLFNBQVMsR0FBR3I1SSxRQUFRaytFLEVBQUU7WUFDOUI0ckYsUUFBUW42RCxJQUFJLENBQUMsR0FBRyxHQUFHdm1GLE9BQU9DO1lBQzFCeWdKLFFBQVF6NEUsSUFBSTtRQUNkO0lBQ0Y7SUFDQSxPQUFPdzRFO0FBQ1Q7QUFDQSxTQUFTRyxVQUFVQyxHQUFHLEVBQUVDLFFBQVE7SUFDOUIsSUFBSWpiLFFBQVFrYixLQUFLRjtJQUNqQixJQUFJRyxPQUFPLElBQUlDLFlBQVlwYixNQUFNL2lLLE1BQU07SUFDdkMsSUFBSW8rSyxZQUFZLElBQUk3QyxXQUFXMkM7SUFDL0IsSUFBSyxJQUFJMzdLLElBQUksR0FBR0EsSUFBSXdnSyxNQUFNL2lLLE1BQU0sRUFBRXVDLElBQUs7UUFDckM2N0ssU0FBUyxDQUFDNzdLLEVBQUUsR0FBR3dnSyxNQUFNcmxKLFVBQVUsQ0FBQ25iO0lBQ2xDO0lBQ0EsT0FBTyxJQUFJODdLLEtBQUs7UUFBQ0g7S0FBSyxFQUFFO1FBQ3RCcnBLLE1BQU1tcEs7SUFDUjtBQUNGO0FBQ0EsU0FBU00sWUFBWUMsTUFBTTtJQUN6QixJQUFJaDhLLElBQUlnOEssT0FBTzd5SixPQUFPLENBQUM7SUFDdkIsT0FBTzZ5SixPQUFPaHFHLE1BQU0sQ0FBQ2h5RSxJQUFJO0FBQzNCO0FBQ0EsU0FBU2k4SyxPQUFPMXFLLE9BQU8sRUFBRThzSCxNQUFNLEVBQUVvOUMsUUFBUTtJQUN2QyxJQUFJUyxZQUFZLFNBQVNBO1FBQ3ZCLE9BQU83OUMsT0FBTzg5QyxTQUFTLENBQUNWLFVBQVVscUssUUFBUTZxSyxPQUFPO0lBQ25EO0lBQ0EsT0FBUTdxSyxRQUFRMHFLLE1BQU07UUFDcEIsS0FBSztZQUNILE9BQU8sSUFBSXIrSCxVQUFVLFNBQVVSLE9BQU8sRUFBRVYsTUFBTTtnQkFDNUMsSUFBSTtvQkFDRjJoRixPQUFPZytDLE1BQU0sQ0FBQyxTQUFVQyxJQUFJO3dCQUMxQixJQUFJQSxRQUFRLE1BQU07NEJBQ2hCbC9ILFFBQVFrL0g7d0JBQ1YsT0FBTzs0QkFDTDUvSCxPQUFPLElBQUlqckMsTUFBTTt3QkFDbkI7b0JBQ0YsR0FBR2dxSyxVQUFVbHFLLFFBQVE2cUssT0FBTztnQkFDOUIsRUFBRSxPQUFPNzBJLEtBQUs7b0JBQ1ptVixPQUFPblY7Z0JBQ1Q7WUFDRjtRQUNGLEtBQUs7WUFDSCxPQUFPZzBJLFVBQVVRLFlBQVlHLGNBQWNUO1FBQzdDLEtBQUs7WUFDSCxPQUFPTSxZQUFZRztRQUNyQixLQUFLO1FBQ0w7WUFDRSxPQUFPQTtJQUNYO0FBQ0Y7QUFDQXZCLE1BQU1wckYsR0FBRyxHQUFHLFNBQVVoK0UsT0FBTztJQUMzQixPQUFPMHFLLE9BQU8xcUssU0FBUyxJQUFJLENBQUNxcEssaUJBQWlCLENBQUNycEssVUFBVTtBQUMxRDtBQUNBb3BLLE1BQU1uckYsR0FBRyxHQUFHLFNBQVVqK0UsT0FBTztJQUMzQixPQUFPMHFLLE9BQU8xcUssU0FBUyxJQUFJLENBQUNxcEssaUJBQWlCLENBQUNycEssVUFBVTtBQUMxRDtBQUVBLElBQUlnckssUUFBUSxDQUFDO0FBQ2JBLE1BQU1qckMsYUFBYSxHQUFHLFNBQVV4d0ksSUFBSSxFQUFFK3lFLE9BQU8sRUFBRXA0RCxPQUFPLEVBQUVDLE9BQU8sRUFBRWlmLEtBQUssRUFBRUMsTUFBTSxFQUFFNkUsTUFBTSxFQUFFWSxPQUFPO0lBQzdGLE9BQVF2L0I7UUFDTixLQUFLO1lBQ0gsT0FBTyxJQUFJLENBQUNxekosZUFBZSxDQUFDdGdGLFNBQVNwNEQsU0FBU0MsU0FBU2lmLE9BQU9DO1FBQ2hFLEtBQUs7WUFDSCxPQUFPLElBQUksQ0FBQzg1SCxlQUFlLENBQUM3Z0YsU0FBU3A0RCxTQUFTQyxTQUFTaWYsT0FBT0MsUUFBUTZFO1FBQ3hFLEtBQUs7WUFDSCxPQUFPLElBQUksQ0FBQzQwSCxvQkFBb0IsQ0FBQ3hnRixTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQyxRQUFRNkUsUUFBUVk7UUFDckYsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPLElBQUksQ0FBQ2kwSCxzQkFBc0IsQ0FBQ3pnRixTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQyxRQUFReUY7UUFDL0UsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPLElBQUksQ0FBQ2swSCxvQkFBb0IsQ0FBQzFnRixTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQyxRQUFRNkUsUUFBUVk7UUFDckYsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPLElBQUksQ0FBQ20wSCw0QkFBNEIsQ0FBQzNnRixTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQyxRQUFReUY7UUFDckYsS0FBSztZQUNILE9BQU8sSUFBSSxDQUFDbzBILGNBQWMsQ0FBQzVnRixTQUFTcDRELFNBQVNDLFNBQVNpZixPQUFPQztJQUNqRTtBQUNGO0FBRUEsSUFBSTRoSixLQUFLQztBQUNULElBQUlDLE1BQU1ELGVBQWU1OUssU0FBUztBQUNsQzY5SyxJQUFJNWtCLGFBQWEsR0FBRztBQUNwQixFQUFFO0FBQ0Y0a0IsSUFBSXBqQixVQUFVLEdBQUc7QUFDakJvakIsSUFBSWhrQixJQUFJLEdBQUc7QUFDWGdrQixJQUFJamtCLElBQUksR0FBRztBQUNYaWtCLElBQUlySCxLQUFLLEdBQUc7QUFDWnFILElBQUlDLFlBQVksR0FBRztJQUFDO0lBQU07SUFBTTtJQUFNO0NBQVM7QUFDL0NELElBQUkxa0IsWUFBWSxHQUFHO0FBQ25CLEVBQUU7QUFDRjBrQixJQUFJeGtCLGNBQWMsR0FBRztBQUNyQndrQixJQUFJamxCLHNCQUFzQixHQUFHO0FBQzdCaWxCLElBQUlobEIsc0JBQXNCLEdBQUc7QUFDN0IsU0FBUytrQixlQUFlbHJLLE9BQU87SUFDN0IsSUFBSWhVLElBQUksSUFBSTtJQUNaLElBQUkwZ0csa0JBQWtCMWdHLEVBQUV5akIsRUFBRSxDQUFDL2YsTUFBTTtJQUNqQyxJQUFJRSxZQUFXODhGLGdCQUFnQjk4RixRQUFRO0lBQ3ZDLElBQUlvUSxRQUFRNi9FLEtBQUssRUFBRTtRQUNqQnNyRixJQUFJNWtCLGFBQWEsR0FBR3Y2SixFQUFFdTZKLGFBQWEsR0FBRztRQUN0Qy82SSxRQUFRZ0IsR0FBRyxDQUFDO0lBQ2Q7SUFDQXhnQixFQUFFNmpCLElBQUksR0FBRztRQUNQMjJJLFVBQVUsSUFBSW42SixNQUFNOCtLLElBQUk1a0IsYUFBYTtRQUNyQ2xDLFVBQVUsSUFBSWg0SixNQUFNOCtLLElBQUk1a0IsYUFBYTtRQUNyQ2UsbUJBQW1CLElBQUlqN0osTUFBTTgrSyxJQUFJNWtCLGFBQWE7UUFDOUNOLGdCQUFnQixJQUFJNTVKLE1BQU04K0ssSUFBSTFrQixZQUFZO1FBQzFDaUMsZ0JBQWdCLElBQUlyOEosTUFBTTgrSyxJQUFJNWtCLGFBQWE7SUFDN0M7SUFDQSxJQUFJOGtCLGVBQWU7SUFDbkIsSUFBSUMsZ0JBQWdCO0lBQ3BCdC9LLEVBQUU2akIsSUFBSSxDQUFDeTJJLGVBQWUsR0FBRzEySixVQUFTczlILGFBQWEsQ0FBQyxRQUFRLCtCQUErQjtJQUN2RixJQUFJcStDLGlCQUFpQnYvSyxFQUFFNmpCLElBQUksQ0FBQ3kySSxlQUFlLENBQUMvMUksS0FBSztJQUNqRHZrQixFQUFFNmpCLElBQUksQ0FBQ3kySSxlQUFlLENBQUMvMUksS0FBSyxDQUFDODZKLGFBQWEsR0FBR0M7SUFDN0NDLGVBQWV0N0osUUFBUSxHQUFHO0lBQzFCczdKLGVBQWVsK0MsTUFBTSxHQUFHO0lBQ3hCaytDLGVBQWVsZ0QsUUFBUSxHQUFHO0lBQzFCLElBQUlwcUMsWUFBWWpoRixRQUFReVAsRUFBRSxDQUFDd3hFLFNBQVM7SUFDcENBLFVBQVV5NkQsV0FBVyxDQUFDMXZKLEVBQUU2akIsSUFBSSxDQUFDeTJJLGVBQWU7SUFDNUNybEUsVUFBVTF3RSxLQUFLLENBQUM4NkosYUFBYSxHQUFHQztJQUNoQyxJQUFJRSxXQUFXO1FBQ2IsdUJBQXVCO1FBQ3ZCLG9CQUFvQjtRQUNwQixlQUFlO1FBQ2YsK0JBQStCO1FBQy9CLGlCQUFpQjtJQUNuQjtJQUNBLElBQUlwNUssTUFBTTtRQUNSbzVLLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRztRQUMvQkEsUUFBUSxDQUFDLGVBQWUsR0FBRztJQUM3QjtJQUNBLElBQUssSUFBSS84SyxJQUFJLEdBQUdBLElBQUkwOEssSUFBSTVrQixhQUFhLEVBQUU5M0osSUFBSztRQUMxQyxJQUFJcStILFNBQVM5Z0ksRUFBRTZqQixJQUFJLENBQUMyMkksUUFBUSxDQUFDLzNKLEVBQUUsR0FBR21CLFVBQVNzOUgsYUFBYSxDQUFDLFdBQVcsK0JBQStCO1FBQ25HLElBQUluc0gsT0FBT29xSyxJQUFJQyxZQUFZLENBQUMzOEssRUFBRTtRQUM5QnpDLEVBQUU2akIsSUFBSSxDQUFDdzBJLFFBQVEsQ0FBQzUxSixFQUFFLEdBQUdxK0gsT0FBT0ssVUFBVSxDQUFDcHNIO1FBQ3ZDLElBQUksQ0FBQy9VLEVBQUU2akIsSUFBSSxDQUFDdzBJLFFBQVEsQ0FBQzUxSixFQUFFLEVBQUU7WUFDdkIyZCxNQUFNLHFDQUFxQ3JMO1FBQzdDO1FBQ0E5VCxPQUFPNEgsSUFBSSxDQUFDMjJLLFVBQVVwOEosT0FBTyxDQUFDLFNBQVVyYyxDQUFDO1lBQ3ZDKzVILE9BQU92OEcsS0FBSyxDQUFDeGQsRUFBRSxHQUFHeTRLLFFBQVEsQ0FBQ3o0SyxFQUFFO1FBQy9CO1FBQ0ErNUgsT0FBT3Y4RyxLQUFLLENBQUNOLFFBQVEsR0FBRztRQUN4QjY4RyxPQUFPMitDLFlBQVksQ0FBQyxXQUFXLFVBQVVoOUs7UUFDekNxK0gsT0FBT3Y4RyxLQUFLLENBQUM4OEcsTUFBTSxHQUFHbitILE9BQU9pOEssSUFBSTVrQixhQUFhLEdBQUc5M0o7UUFDakR6QyxFQUFFNmpCLElBQUksQ0FBQ3kySSxlQUFlLENBQUM1SyxXQUFXLENBQUM1dUI7UUFDbkM5Z0ksRUFBRTZqQixJQUFJLENBQUN5M0ksaUJBQWlCLENBQUM3NEosRUFBRSxHQUFHO0lBQ2hDO0lBQ0F6QyxFQUFFNmpCLElBQUksQ0FBQzY3SixTQUFTLEdBQUcxL0ssRUFBRTZqQixJQUFJLENBQUMyMkksUUFBUSxDQUFDLEVBQUU7SUFDckN4NkosRUFBRTZqQixJQUFJLENBQUMyMkksUUFBUSxDQUFDMmtCLElBQUlqa0IsSUFBSSxDQUFDLENBQUN1a0IsWUFBWSxDQUFDLFdBQVcsVUFBVU4sSUFBSWprQixJQUFJLEdBQUc7SUFDdkVsN0osRUFBRTZqQixJQUFJLENBQUMyMkksUUFBUSxDQUFDMmtCLElBQUlwakIsVUFBVSxDQUFDLENBQUMwakIsWUFBWSxDQUFDLFdBQVcsVUFBVU4sSUFBSXBqQixVQUFVLEdBQUc7SUFDbkYvN0osRUFBRTZqQixJQUFJLENBQUMyMkksUUFBUSxDQUFDMmtCLElBQUloa0IsSUFBSSxDQUFDLENBQUNza0IsWUFBWSxDQUFDLFdBQVcsVUFBVU4sSUFBSWhrQixJQUFJLEdBQUc7SUFDdkUsSUFBSW43SixFQUFFNmpCLElBQUksQ0FBQzIySSxRQUFRLENBQUMya0IsSUFBSXJILEtBQUssQ0FBQyxFQUFFO1FBQzlCOTNLLEVBQUU2akIsSUFBSSxDQUFDMjJJLFFBQVEsQ0FBQzJrQixJQUFJckgsS0FBSyxDQUFDLENBQUMySCxZQUFZLENBQUMsV0FBVyxVQUFVTixJQUFJckgsS0FBSyxHQUFHO0lBQzNFO0lBQ0EsSUFBSyxJQUFJcjFLLElBQUksR0FBR0EsSUFBSTA4SyxJQUFJMWtCLFlBQVksRUFBRWg0SixJQUFLO1FBQ3pDekMsRUFBRTZqQixJQUFJLENBQUNvMkksY0FBYyxDQUFDeDNKLEVBQUUsR0FBR21CLFVBQVNzOUgsYUFBYSxDQUFDLFdBQVcsK0JBQStCO1FBQzVGbGhJLEVBQUU2akIsSUFBSSxDQUFDNjRJLGNBQWMsQ0FBQ2o2SixFQUFFLEdBQUd6QyxFQUFFNmpCLElBQUksQ0FBQ28ySSxjQUFjLENBQUN4M0osRUFBRSxDQUFDMCtILFVBQVUsQ0FBQztRQUMvRG5oSSxFQUFFNmpCLElBQUksQ0FBQ28ySSxjQUFjLENBQUN4M0osRUFBRSxDQUFDOGhCLEtBQUssQ0FBQ04sUUFBUSxHQUFHO1FBQzFDamtCLEVBQUU2akIsSUFBSSxDQUFDbzJJLGNBQWMsQ0FBQ3gzSixFQUFFLENBQUNnOUssWUFBWSxDQUFDLFdBQVcsV0FBV2g5SztRQUM1RHpDLEVBQUU2akIsSUFBSSxDQUFDbzJJLGNBQWMsQ0FBQ3gzSixFQUFFLENBQUM4aEIsS0FBSyxDQUFDODhHLE1BQU0sR0FBR24rSCxPQUFPLENBQUNULElBQUk7UUFDcER6QyxFQUFFNmpCLElBQUksQ0FBQ28ySSxjQUFjLENBQUN4M0osRUFBRSxDQUFDOGhCLEtBQUssQ0FBQ29pRixVQUFVLEdBQUc7SUFDNUMsK0RBQStEO0lBQ2pFO0lBQ0EzbUcsRUFBRTIvSyxZQUFZLEdBQUc7SUFDakIsSUFBSUMsVUFBVW5sSjtJQUNkLElBQUlvbEosZUFBZSxTQUFTQSxhQUFhbmxKLEVBQUU7UUFDekMsT0FBTztZQUNMbG1CLEdBQUcsQ0FBQ2ttQixHQUFHNTBCLEVBQUUsR0FBRzQwQixHQUFHMzBCLEVBQUUsSUFBSTtZQUNyQmtZLEdBQUcsQ0FBQ3ljLEdBQUcxMEIsRUFBRSxHQUFHMDBCLEdBQUd6MEIsRUFBRSxJQUFJO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJNjVLLGtCQUFrQixTQUFTQSxnQkFBZ0JwbEosRUFBRTtRQUMvQyxPQUFPO1lBQ0xsbUIsR0FBRyxDQUFDa21CLEdBQUd2YixDQUFDLEdBQUc7WUFDWGxCLEdBQUcsQ0FBQ3ljLEdBQUdueEIsQ0FBQyxHQUFHO1FBQ2I7SUFDRjtJQUNBLElBQUl3MkssZ0NBQWdDLFNBQVNBLDhCQUE4QnYrSixHQUFHO1FBQzVFLElBQUl3QyxLQUFLeEMsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVE7UUFDeEIsSUFBSXVqQixPQUFPNUUsR0FBR2c4SixzQkFBc0IsS0FBS2g4SixHQUFHa3dJLG1CQUFtQjtRQUMvRCxPQUFPLENBQUN0ckk7SUFDVjtJQUNBLElBQUk4dkosY0FBYyxTQUFTQSxZQUFZbDNKLEdBQUc7UUFDeEMsT0FBT0EsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVEsQ0FBQzAyRixPQUFPO0lBQ2hDO0lBQ0EsSUFBSTg4RSxjQUFjLFNBQVNBLFlBQVlyM0osR0FBRztRQUN4QyxPQUFPQSxHQUFHLENBQUMsRUFBRSxDQUFDbmMsUUFBUSxDQUFDMDFGLGFBQWE7SUFDdEM7SUFDQSxJQUFJbStFLG9CQUFvQixTQUFTQSxrQkFBa0IxM0osR0FBRztRQUNwRCxPQUFPQSxHQUFHLENBQUMsRUFBRSxDQUFDbmMsUUFBUSxDQUFDODFGLG1CQUFtQjtJQUM1QztJQUNBLElBQUlvK0Usb0JBQW9CLFNBQVNBLGtCQUFrQi8zSixHQUFHO1FBQ3BELE9BQU9BLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRLENBQUNpMkYsbUJBQW1CO0lBQzVDO0lBQ0EsSUFBSXlqRCxjQUFjLFNBQVNBLFlBQVl6b0UsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWtaLEVBQUUsRUFBRWttSCxnQkFBZ0IsRUFBRWlRLGFBQWE7UUFDdEYsT0FBTzd3SixFQUFFKytJLFdBQVcsQ0FBQ3pvRSxTQUFTOTBELEtBQUtrWixJQUFJLE9BQU8sT0FBT20ySDtJQUN2RDtJQUNBLElBQUkvRixZQUFZLFNBQVNBLFVBQVV4MEUsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWtaLEVBQUUsRUFBRWttSCxnQkFBZ0IsRUFBRWlRLGFBQWE7UUFDbEYsT0FBTzd3SixFQUFFb3NKLGVBQWUsQ0FBQzkxRSxTQUFTOTBELEtBQUtrWixJQUFJa21ILGtCQUFrQixRQUFRaVE7SUFDdkU7SUFDQSxJQUFJdW9CLGtCQUFrQixTQUFTQSxnQkFBZ0I5aUcsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWtaLEVBQUUsRUFBRWttSCxnQkFBZ0IsRUFBRWlRLGFBQWE7UUFDOUYsT0FBTzd3SixFQUFFb3NKLGVBQWUsQ0FBQzkxRSxTQUFTOTBELEtBQUtrWixJQUFJa21ILGtCQUFrQixVQUFVaVE7SUFDekU7SUFDQSxJQUFJNG9CLGtCQUFrQixTQUFTQSxnQkFBZ0JuakcsT0FBTyxFQUFFOTBELEdBQUcsRUFBRWtaLEVBQUUsRUFBRWttSCxnQkFBZ0IsRUFBRWlRLGFBQWE7UUFDOUYsT0FBTzd3SixFQUFFb3NKLGVBQWUsQ0FBQzkxRSxTQUFTOTBELEtBQUtrWixJQUFJa21ILGtCQUFrQixVQUFVaVE7SUFDekU7SUFDQSxJQUFJOG5CLGdCQUFnQixTQUFTQSxjQUFjbjNKLEdBQUc7UUFDNUNBLElBQUkzYixXQUFXO1FBQ2YsT0FBTzJiLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRLENBQUM0Z0IsVUFBVTtJQUNuQztJQUNBLElBQUk4eUosY0FBYyxTQUFTQSxZQUFZdjNKLEdBQUc7UUFDeENBLElBQUkzYixXQUFXO1FBQ2YsT0FBTzJiLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRLENBQUM4Z0IsV0FBVyxDQUFDRSxJQUFJLElBQUl1NUo7SUFDN0M7SUFDQSxJQUFJekcsb0JBQW9CLFNBQVNBLGtCQUFrQjMzSixHQUFHO1FBQ3BEQSxJQUFJM2IsV0FBVztRQUNmLE9BQU8yYixHQUFHLENBQUMsRUFBRSxDQUFDbmMsUUFBUSxDQUFDOGdCLFdBQVcsQ0FBQ3JDLE1BQU0sSUFBSTg3SjtJQUMvQztJQUNBLElBQUlwRyxvQkFBb0IsU0FBU0Esa0JBQWtCaDRKLEdBQUc7UUFDcERBLElBQUkzYixXQUFXO1FBQ2YsT0FBTzJiLEdBQUcsQ0FBQyxFQUFFLENBQUNuYyxRQUFRLENBQUM4Z0IsV0FBVyxDQUFDcEMsTUFBTSxJQUFJNjdKO0lBQy9DO0lBQ0EsSUFBSUssd0JBQXdCLFNBQVNBLHNCQUFzQnorSixHQUFHLEVBQUVvL0gsZ0JBQWdCO1FBQzlFLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJcy9CLDBCQUEwQixTQUFTQSx3QkFBd0IxK0osR0FBRztRQUNoRSxPQUFPcStKLGFBQWFsSCxjQUFjbjNKO0lBQ3BDO0lBQ0EsSUFBSTIrSixnQkFBZ0IsU0FBU0EsY0FBY3o0SyxNQUFNLEVBQUVrMEIsRUFBRSxFQUFFcGEsR0FBRztRQUN4RCxJQUFJa2xHLE1BQU1oL0csU0FBU0EsU0FBUyxNQUFNO1FBQ2xDLE9BQU87WUFDTDhNLEdBQUdvbkIsR0FBR3BuQixDQUFDLEdBQUdnTixJQUFJNG1ELE1BQU0sQ0FBQ3MrQyxNQUFNLGlCQUFpQnIrQyxPQUFPO1lBQ25EcHFELEdBQUcyZCxHQUFHM2QsQ0FBQyxHQUFHdUQsSUFBSTRtRCxNQUFNLENBQUNzK0MsTUFBTSxpQkFBaUJyK0MsT0FBTztRQUNyRDtJQUNGO0lBQ0EsSUFBSSszRyxVQUFVLFNBQVNBLFFBQVE1K0osR0FBRyxFQUFFaE4sQ0FBQyxFQUFFeUosQ0FBQztRQUN0QyxJQUFJb25HLEtBQUs3akcsR0FBRyxDQUFDLEVBQUUsQ0FBQ25jLFFBQVEsQ0FBQ2tnQixRQUFRO1FBQ2pDLE9BQU87WUFDTC9RLEdBQUc2d0csRUFBRSxDQUFDN3dHLEVBQUU7WUFDUnlKLEdBQUdvbkcsRUFBRSxDQUFDcG5HLEVBQUU7UUFDVjtJQUNGO0lBQ0EsSUFBSSs2Six3QkFBd0IsU0FBU0Esc0JBQXNCeDNKLEdBQUc7UUFDNUQsT0FBTzIrSixjQUFjLElBQUlDLFFBQVE1K0osS0FBSyxVQUFVLFdBQVdBO0lBQzdEO0lBQ0EsSUFBSTYzSiw4QkFBOEIsU0FBU0EsNEJBQTRCNzNKLEdBQUc7UUFDeEUsT0FBTzIrSixjQUFjLFVBQVVDLFFBQVE1K0osS0FBSyxnQkFBZ0IsaUJBQWlCQTtJQUMvRTtJQUNBLElBQUlrNEosOEJBQThCLFNBQVNBLDRCQUE0Qmw0SixHQUFHO1FBQ3hFLE9BQU8yK0osY0FBYyxVQUFVQyxRQUFRNStKLEtBQUssZ0JBQWdCLGlCQUFpQkE7SUFDL0U7SUFDQSxJQUFJNitKLDJCQUEyQixTQUFTQSx5QkFBeUI3K0osR0FBRztRQUNsRSxPQUFPcytKLGdCQUFnQm5ILGNBQWNuM0o7SUFDdkM7SUFDQSxJQUFJODNKLCtCQUErQixTQUFTQSw2QkFBNkI5M0osR0FBRztRQUMxRSxPQUFPcytKLGdCQUFnQjNHLGtCQUFrQjMzSjtJQUMzQztJQUNBLElBQUltNEosK0JBQStCLFNBQVNBLDZCQUE2Qm40SixHQUFHO1FBQzFFLE9BQU9zK0osZ0JBQWdCdEcsa0JBQWtCaDRKO0lBQzNDO0lBQ0EsSUFBSXkzSix5QkFBeUIsU0FBU0EsdUJBQXVCejNKLEdBQUc7UUFDOUQsSUFBSWtaLEtBQUtxK0ksWUFBWXYzSjtRQUNyQixJQUFJL1gsSUFBSXEySyxnQkFBZ0IvRyxZQUFZdjNKO1FBQ3BDLElBQUlBLElBQUlvRSxNQUFNLElBQUk7WUFDaEIsT0FBUXBFLElBQUk0bUQsTUFBTSxDQUFDLGVBQWV0bUUsS0FBSztnQkFDckMsS0FBSztvQkFDSDJILEVBQUUrSyxDQUFDLEdBQUcsQ0FBQ2ttQixHQUFHdmIsQ0FBQyxHQUFJdWIsQ0FBQUEsR0FBRzB4QyxPQUFPLElBQUk7b0JBQzdCO2dCQUNGLEtBQUs7b0JBQ0gzaUUsRUFBRStLLENBQUMsR0FBRyxDQUFFa21CLENBQUFBLEdBQUcyeEMsUUFBUSxJQUFJO29CQUN2QjtZQUNKO1lBQ0EsT0FBUTdxRCxJQUFJNG1ELE1BQU0sQ0FBQyxlQUFldG1FLEtBQUs7Z0JBQ3JDLEtBQUs7b0JBQ0gySCxFQUFFd1UsQ0FBQyxHQUFHLENBQUN5YyxHQUFHbnhCLENBQUMsR0FBSW14QixDQUFBQSxHQUFHNHhDLE1BQU0sSUFBSTtvQkFDNUI7Z0JBQ0YsS0FBSztvQkFDSDdpRSxFQUFFd1UsQ0FBQyxHQUFHLENBQUV5YyxDQUFBQSxHQUFHNnhDLE1BQU0sSUFBSTtvQkFDckI7WUFDSjtRQUNGO1FBQ0EsT0FBTzlpRTtJQUNUO0lBQ0EsSUFBSTQvSSxjQUFjcnBKLEVBQUU2akIsSUFBSSxDQUFDd2xJLFdBQVcsR0FBRyxJQUFJL0osb0JBQW9CdC9JLEdBQUc7UUFDaEUrd0UsUUFBUTJuRztRQUNSMzhCLHNCQUFzQmdrQztRQUN0QmhoQyxhQUFhQTtRQUNiQyxnQkFBZ0IyNUI7UUFDaEIxNUIsa0JBQWtCaWhDO1FBQ2xCaGhDLG1CQUFtQm1oQztRQUNuQmpoQyxxQkFBcUI7UUFDckJDLHVCQUF1QjtJQUN6QjtJQUNBLElBQUlnTCxjQUFjcnFKLEVBQUU2akIsSUFBSSxDQUFDd21JLFdBQVcsR0FBRyxJQUFJL0ssb0JBQW9CdC9JLEdBQUc7UUFDaEUrd0UsUUFBUThuRztRQUNSOTVCLGFBQWErTDtRQUNiOUwsZ0JBQWdCKzVCO1FBQ2hCOTVCLGtCQUFrQis1QjtRQUNsQjk1QixtQkFBbUIrNUI7UUFDbkI5NUIsV0FBVzhnQztJQUNiO0lBQ0EsSUFBSTMxQixjQUFjdHFKLEVBQUU2akIsSUFBSSxDQUFDeW1JLFdBQVcsR0FBRyxJQUFJaEwsb0JBQW9CdC9JLEdBQUc7UUFDaEUrd0UsUUFBUW1vRztRQUNSbjZCLGFBQWFxNkI7UUFDYnA2QixnQkFBZ0JtNkI7UUFDaEJsNkIsa0JBQWtCbzZCO1FBQ2xCbjZCLG1CQUFtQm82QjtRQUNuQm42QixXQUFXOGdDO0lBQ2I7SUFDQSxJQUFJMTFCLGNBQWN2cUosRUFBRTZqQixJQUFJLENBQUMwbUksV0FBVyxHQUFHLElBQUlqTCxvQkFBb0J0L0ksR0FBRztRQUNoRSt3RSxRQUFRd29HO1FBQ1J4NkIsYUFBYTA2QjtRQUNiejZCLGdCQUFnQnc2QjtRQUNoQnY2QixrQkFBa0J5NkI7UUFDbEJ4NkIsbUJBQW1CeTZCO1FBQ25CeDZCLFdBQVc4Z0M7SUFDYjtJQUNBLElBQUlyMUIsY0FBYzVxSixFQUFFNmpCLElBQUksQ0FBQyttSSxXQUFXLEdBQUcsSUFBSTNHLG9CQUFvQmprSjtJQUMvREEsRUFBRWtqSSxnQkFBZ0IsQ0FBQyxTQUFTbzlDLHdCQUF3QjN1RixRQUFRLEVBQUVwa0UsSUFBSTtRQUNoRSxrR0FBa0c7UUFDbEc4N0gsWUFBWTdHLGtCQUFrQixDQUFDajFIO1FBQy9CODhILFlBQVk3SCxrQkFBa0IsQ0FBQ2oxSDtRQUMvQis4SCxZQUFZOUgsa0JBQWtCLENBQUNqMUg7UUFDL0JnOUgsWUFBWS9ILGtCQUFrQixDQUFDajFIO1FBRS9CLG9DQUFvQztRQUNwQ3E5SCxZQUFZcEksa0JBQWtCLENBQUNqMUg7UUFFL0IseUVBQXlFO1FBQ3pFLElBQUssSUFBSXBFLEtBQUssR0FBR0EsS0FBS29FLEtBQUtydEIsTUFBTSxFQUFFaXBCLEtBQU07WUFDdkMsSUFBSW5GLEtBQUt1SixJQUFJLENBQUNwRSxHQUFHLENBQUM5akIsUUFBUTtZQUMxQjJlLEdBQUdnOEosc0JBQXNCLEdBQUdoOEosR0FBR2t3SSxtQkFBbUI7UUFDcEQ7SUFDRjtJQUNBLElBQUlxc0IsaUJBQWlCLFNBQVNBLGVBQWVuZ0MsSUFBSTtRQUMvQyxJQUFLLElBQUkzOUksSUFBSSxHQUFHQSxJQUFJMjlJLEtBQUtsZ0osTUFBTSxFQUFFdUMsSUFBSztZQUNwQ21vSixZQUFZM0Qsd0JBQXdCLENBQUM3RyxJQUFJLENBQUMzOUksRUFBRSxDQUFDK2UsR0FBRztRQUNsRDtJQUNGO0lBQ0E2bkksWUFBWS9GLFNBQVMsQ0FBQ2k5QjtJQUN0QmwyQixZQUFZL0csU0FBUyxDQUFDaTlCO0lBQ3RCajJCLFlBQVloSCxTQUFTLENBQUNpOUI7SUFDdEJoMkIsWUFBWWpILFNBQVMsQ0FBQ2k5QjtJQUN0QixJQUFJdnNLLFFBQVE2L0UsS0FBSyxFQUFFO1FBQ2pCN3pGLEVBQUU2M0ssU0FBUyxDQUFDN2pLLFNBQVM7WUFDbkIwa0ssYUFBYUE7WUFDYkcsYUFBYUE7WUFDYkssbUJBQW1CQTtZQUNuQkssbUJBQW1CQTtZQUNuQng2QixhQUFhQTtZQUNiK0wsV0FBV0E7WUFDWHN1QixpQkFBaUJBO1lBQ2pCSyxpQkFBaUJBO1lBQ2pCZCxlQUFlQTtZQUNmSSxhQUFhQTtZQUNiSSxtQkFBbUJBO1lBQ25CSyxtQkFBbUJBO1lBQ25CMEcseUJBQXlCQTtZQUN6QkcsMEJBQTBCQTtZQUMxQnJILHVCQUF1QkE7WUFDdkJLLDZCQUE2QkE7WUFDN0JLLDZCQUE2QkE7WUFDN0JULHdCQUF3QkE7WUFDeEJLLDhCQUE4QkE7WUFDOUJLLDhCQUE4QkE7UUFDaEM7SUFDRjtBQUNGO0FBQ0F3RixJQUFJbjBDLFVBQVUsR0FBRyxTQUFVcG5ILEtBQUssRUFBRWt2RSxJQUFJO0lBQ3BDLElBQUk5eUYsSUFBSSxJQUFJO0lBQ1osT0FBUTRqQjtRQUNOLEtBQUs7WUFDSDVqQixFQUFFNmpCLElBQUksQ0FBQ3kzSSxpQkFBaUIsQ0FBQzZqQixJQUFJamtCLElBQUksQ0FBQyxHQUFHcG9FO1lBQ3JDO1FBQ0YsS0FBSztZQUNIOXlGLEVBQUU2akIsSUFBSSxDQUFDeTNJLGlCQUFpQixDQUFDNmpCLElBQUloa0IsSUFBSSxDQUFDLEdBQUdyb0U7WUFDckM7UUFDRixLQUFLO1lBQ0g5eUYsRUFBRTZqQixJQUFJLENBQUN5M0ksaUJBQWlCLENBQUM2akIsSUFBSXBqQixVQUFVLENBQUMsR0FBR2pwRTtZQUMzQztRQUNGLEtBQUs7WUFDSDl5RixFQUFFNmpCLElBQUksQ0FBQ3FwRixFQUFFLEdBQUc7WUFDWjtJQUNKO0FBQ0Y7QUFFQSw0Q0FBNEM7QUFDNUMsSUFBSXN6RSxhQUFhLE9BQU90ekIsV0FBVztBQUNuQ2l5QixJQUFJc0IsYUFBYSxHQUFHLFNBQVUxckgsRUFBRTtJQUM5QixJQUFJQSxPQUFPOXhELFdBQVc7UUFDcEIsT0FBTyxJQUFJLENBQUMwOEssWUFBWTtJQUMxQjtJQUNBLElBQUksQ0FBQ0EsWUFBWSxHQUFHNXFILEtBQUssT0FBTztBQUNsQztBQUNBb3FILElBQUl6eUIsUUFBUSxHQUFHO0lBQ2IsT0FBTzh6QixjQUFjLElBQUksQ0FBQ2IsWUFBWTtBQUN4QztBQUNBUixJQUFJNzRCLGVBQWUsR0FBRyxTQUFVaHdFLE9BQU8sRUFBRXdjLElBQUk7SUFDM0MsSUFBSXhjLFFBQVFvcUcscUJBQXFCLElBQUksTUFBTTtRQUN6Q3BxRyxRQUFRb3FHLHFCQUFxQixHQUFHNXRGO0lBQ2xDLE9BQU87UUFDTHhjLFFBQVFxcUcsMkJBQTJCLEdBQUc3dEY7UUFDdEN4YyxRQUFRc3FHLHdCQUF3QixHQUFHOXRGO1FBQ25DeGMsUUFBUXVxRyx1QkFBdUIsR0FBRy90RjtJQUNwQztBQUNGO0FBQ0Fxc0YsSUFBSXoxQixlQUFlLEdBQUcsU0FBVXB6RSxPQUFPO0lBQ3JDLElBQUlBLFFBQVFvcUcscUJBQXFCLElBQUksTUFBTTtRQUN6QyxPQUFPcHFHLFFBQVFvcUcscUJBQXFCO0lBQ3RDLE9BQU87UUFDTCxPQUFPcHFHLFFBQVFxcUcsMkJBQTJCLElBQUlycUcsUUFBUXNxRyx3QkFBd0IsSUFBSXRxRyxRQUFRdXFHLHVCQUF1QjtJQUNuSDtBQUNGO0FBQ0ExQixJQUFJbDhCLG1CQUFtQixHQUFHLFNBQVU3bEgsS0FBSyxFQUFFQyxNQUFNO0lBQy9DLElBQUl5akc7SUFDSixJQUFJLENBQUMsT0FBT2dnRCxvQkFBb0IsY0FBYyxjQUFjMzlLLFFBQVEyOUssZ0JBQWUsTUFBUSxhQUFlO1FBQ3hHaGdELFNBQVMsSUFBSWdnRCxnQkFBZ0IxakosT0FBT0M7SUFDdEMsT0FBTztRQUNMLElBQUlxakUsa0JBQWtCLElBQUksQ0FBQ2o5RSxFQUFFLENBQUMvZixNQUFNO1FBQ3BDLElBQUlFLFlBQVc4OEYsZ0JBQWdCOThGLFFBQVE7UUFDdkNrOUgsU0FBU2w5SCxVQUFTczlILGFBQWEsQ0FBQyxXQUFXLCtCQUErQjtRQUMxRUosT0FBTzFqRyxLQUFLLEdBQUdBO1FBQ2YwakcsT0FBT3pqRyxNQUFNLEdBQUdBO0lBQ2xCO0lBQ0EsT0FBT3lqRztBQUNUO0FBQ0E7SUFBQzJtQjtJQUFPYztJQUFPc0M7SUFBT3dEO0lBQU9xQztJQUFPaUQ7SUFBT3dFO0lBQU95ZjtJQUFPNkU7SUFBT1c7SUFBTzRCO0NBQU0sQ0FBQzU3SixPQUFPLENBQUMsU0FBVWk3QixLQUFLO0lBQ25HNTFDLE9BQU8wMkssS0FBSzlnSTtBQUNkO0FBRUEsSUFBSTJ2QixXQUFXO0lBQUM7UUFDZHpxRSxNQUFNO1FBQ05xd0MsTUFBTStzRTtJQUNSO0lBQUc7UUFDRHA5RyxNQUFNO1FBQ05xd0MsTUFBTWdsRztJQUNSO0lBQUc7UUFDRHIxSSxNQUFNO1FBQ05xd0MsTUFBTXFySTtJQUNSO0NBQUU7QUFFRixJQUFJOEIsVUFBVTtJQUFDO1FBQ2Joc0ssTUFBTTtRQUNOaXNLLFlBQVl2ckc7SUFDZDtJQUFHO1FBQ0QxZ0UsTUFBTTtRQUNOaXNLLFlBQVloekc7SUFDZDtDQUFFO0FBRUYsc0RBQXNEO0FBQ3RELElBQUlnekcsYUFBYSxDQUFDO0FBRWxCLHFEQUFxRDtBQUNyRCxJQUFJQyxVQUFVLENBQUM7QUFDZixTQUFTQyxhQUFhbnNLLElBQUksRUFBRXhSLElBQUksRUFBRTQ5SyxVQUFVO0lBQzFDLElBQUlDLE1BQU1EO0lBQ1YsSUFBSUUsY0FBYyxTQUFTQSxZQUFZMXRILEtBQUs7UUFDMUNsMEMsS0FBSyx1QkFBdUJsYyxPQUFPLFlBQVl3UixPQUFPLGNBQWM0K0MsUUFBUTtJQUM5RTtJQUNBLElBQUk1K0MsU0FBUyxRQUFRO1FBQ25CLElBQUlpNkYsS0FBSzF0RyxTQUFTLENBQUNpQyxLQUFLLEVBQUU7WUFDeEIsT0FBTzg5SyxZQUFZOTlLO1FBQ3JCLE9BQU87WUFDTHlyRyxLQUFLMXRHLFNBQVMsQ0FBQ2lDLEtBQUssR0FBRzQ5SztRQUN6QjtJQUNGLE9BQU8sSUFBSXBzSyxTQUFTLGNBQWM7UUFDaEMsSUFBSXl4RSxXQUFXbGxGLFNBQVMsQ0FBQ2lDLEtBQUssRUFBRTtZQUM5QixPQUFPODlLLFlBQVk5OUs7UUFDckIsT0FBTztZQUNMaWpGLFdBQVdsbEYsU0FBUyxDQUFDaUMsS0FBSyxHQUFHNDlLO1FBQy9CO0lBQ0YsT0FBTyxJQUFJcHNLLFNBQVMsVUFBVTtRQUM1QixvREFBb0Q7UUFFcEQsSUFBSXM5RSxTQUFTLFNBQVNBLE9BQU9yK0UsT0FBTztZQUNsQyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7WUFDZm10SyxXQUFXbC9LLElBQUksQ0FBQyxJQUFJLEVBQUUrUjtZQUV0QiwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDdFAsWUFBWSxJQUFJLENBQUNXLFFBQVEsR0FBRztnQkFDL0IsSUFBSSxDQUFDQSxRQUFRLEdBQUcsQ0FBQztZQUNuQjtZQUNBLElBQUksQ0FBQ0EsUUFBUSxDQUFDb2UsRUFBRSxHQUFHelAsUUFBUXlQLEVBQUU7WUFDN0IsSUFBSSxDQUFDcGUsUUFBUSxDQUFDaWYsU0FBUyxHQUFHLEVBQUU7WUFDNUIsSUFBSSxDQUFDdUMsYUFBYTtRQUNwQjtRQUNBLElBQUl5NkosY0FBY2p2RixPQUFPL3dGLFNBQVMsR0FBR0wsT0FBTzZoQixNQUFNLENBQUNxK0osV0FBVzcvSyxTQUFTO1FBQ3ZFLElBQUlpZ0wsZUFBZSxFQUFFO1FBQ3JCLElBQUssSUFBSTkrSyxJQUFJLEdBQUdBLElBQUk4K0ssYUFBYXJoTCxNQUFNLEVBQUV1QyxJQUFLO1lBQzVDLElBQUkrK0ssU0FBU0QsWUFBWSxDQUFDOStLLEVBQUU7WUFDNUI2K0ssV0FBVyxDQUFDRSxPQUFPLEdBQUdGLFdBQVcsQ0FBQ0UsT0FBTyxJQUFJO2dCQUMzQyxPQUFPLElBQUk7WUFDYjtRQUNGO1FBRUEsNkRBQTZEO1FBQzdELElBQUlGLFlBQVluc0osS0FBSyxJQUFJLENBQUNtc0osWUFBWTcrSCxHQUFHLEVBQUU7WUFDekM2K0gsWUFBWTcrSCxHQUFHLEdBQUc7Z0JBQ2hCLElBQUksQ0FBQ3R0QixLQUFLO2dCQUNWLE9BQU8sSUFBSTtZQUNiO1FBQ0YsT0FBTyxJQUFJLENBQUNtc0osWUFBWW5zSixLQUFLLElBQUltc0osWUFBWTcrSCxHQUFHLEVBQUU7WUFDaEQ2K0gsWUFBWW5zSixLQUFLLEdBQUc7Z0JBQ2xCLElBQUksQ0FBQ3N0QixHQUFHO2dCQUNSLE9BQU8sSUFBSTtZQUNiO1FBQ0Y7UUFDQSxJQUFJZy9ILFVBQVVOLFdBQVc3L0ssU0FBUyxDQUFDMGdELElBQUk7UUFDdkNzL0gsWUFBWXQvSCxJQUFJLEdBQUc7WUFDakIsSUFBSTVnQyxPQUFPLElBQUksQ0FBQ3BOLE9BQU87WUFDdkIsSUFBSW9OLFFBQVFBLEtBQUtnaUMsT0FBTyxFQUFFO2dCQUN4QixJQUFJeUIsT0FBTyxJQUFJLENBQUMwNEIsVUFBVTtnQkFDMUIsSUFBSTE0QixNQUFNO29CQUNSLElBQUssSUFBSTE3QixLQUFLLEdBQUdBLEtBQUswN0IsS0FBSzNrRCxNQUFNLEVBQUVpcEIsS0FBTTt3QkFDdkMwN0IsSUFBSSxDQUFDMTdCLEdBQUcsQ0FBQzY0QixJQUFJO29CQUNmO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJeS9ILFNBQVM7Z0JBQ1hBLFFBQVF4L0ssSUFBSSxDQUFDLElBQUk7WUFDbkIsT0FBTztnQkFDTCxJQUFJLENBQUNvMEQsSUFBSSxDQUFDO1lBQ1o7WUFDQSxPQUFPLElBQUk7UUFDYjtRQUNBLElBQUksQ0FBQ2lySCxZQUFZcHlFLE9BQU8sRUFBRTtZQUN4Qm95RSxZQUFZcHlFLE9BQU8sR0FBRztnQkFDcEIsT0FBTyxJQUFJO1lBQ2I7UUFDRjtRQUNBb3lFLFlBQVk3OUosRUFBRSxHQUFHO1lBQ2YsT0FBTyxJQUFJLENBQUNwZSxRQUFRLENBQUNvZSxFQUFFO1FBQ3pCO1FBQ0EsSUFBSWkrSixRQUFRLFNBQVNBLE1BQU1qc0csTUFBTTtZQUMvQixPQUFPQSxPQUFPcHdFLFFBQVEsQ0FBQ29lLEVBQUU7UUFDM0I7UUFDQSxJQUFJaytKLGNBQWM7WUFDaEJ2ckcsZ0JBQWdCLFNBQVNBLGVBQWVYLE1BQU0sRUFBRTJCLEdBQUc7Z0JBQ2pEQSxJQUFJM0IsTUFBTSxHQUFHQTtnQkFDYjJCLElBQUkzekQsRUFBRSxHQUFHaStKLE1BQU1qc0c7Z0JBQ2YyQixJQUFJcnpELE1BQU0sR0FBRzB4RDtZQUNmO1lBQ0FnQixRQUFRLFNBQVNBO2dCQUNmLE9BQU87WUFDVDtZQUNBOXdELFFBQVEsU0FBU0EsT0FBTzh2RCxNQUFNO2dCQUM1QixPQUFPaXNHLE1BQU1qc0c7WUFDZjtRQUNGO1FBQ0FodEUsT0FBTzY0SyxhQUFhO1lBQ2xCejZKLGVBQWUsU0FBU0E7Z0JBQ3RCLElBQUksQ0FBQ3hoQixRQUFRLENBQUNtekUsT0FBTyxHQUFHLElBQUk1QixRQUFRK3FHLGFBQWEsSUFBSTtnQkFDckQsT0FBTyxJQUFJO1lBQ2I7WUFDQW5wRyxTQUFTLFNBQVNBO2dCQUNoQixPQUFPLElBQUksQ0FBQ256RSxRQUFRLENBQUNtekUsT0FBTztZQUM5QjtZQUNBempCLElBQUksU0FBU0EsR0FBR3FpQixHQUFHLEVBQUV6M0IsRUFBRTtnQkFDckIsSUFBSSxDQUFDNjRCLE9BQU8sR0FBR3pqQixFQUFFLENBQUNxaUIsS0FBS3ozQjtnQkFDdkIsT0FBTyxJQUFJO1lBQ2I7WUFDQTYzQixLQUFLLFNBQVNBLElBQUlKLEdBQUcsRUFBRXozQixFQUFFO2dCQUN2QixJQUFJLENBQUM2NEIsT0FBTyxHQUFHaEIsR0FBRyxDQUFDSixLQUFLejNCO2dCQUN4QixPQUFPLElBQUk7WUFDYjtZQUNBdTRCLE1BQU0sU0FBU0EsS0FBS2QsR0FBRyxFQUFFejNCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQzY0QixPQUFPLEdBQUdoQixHQUFHLENBQUNKLEtBQUt6M0I7Z0JBQ3hCLE9BQU8sSUFBSTtZQUNiO1lBQ0F3VyxnQkFBZ0IsU0FBU0EsZUFBZWloQixHQUFHLEVBQUV6M0IsRUFBRTtnQkFDN0MsSUFBSSxDQUFDNjRCLE9BQU8sR0FBR3JpQixjQUFjLENBQUNpaEIsS0FBS3ozQjtnQkFDbkMsT0FBTyxJQUFJO1lBQ2I7WUFDQSszQixvQkFBb0IsU0FBU0E7Z0JBQzNCLElBQUksQ0FBQ2MsT0FBTyxHQUFHZCxrQkFBa0I7Z0JBQ2pDLE9BQU8sSUFBSTtZQUNiO1lBQ0FyaEIsTUFBTSxTQUFTQSxLQUFLK2dCLEdBQUcsRUFBRTF6RCxNQUFNO2dCQUM3QixJQUFJLENBQUM4MEQsT0FBTyxHQUFHbmlCLElBQUksQ0FBQytnQixLQUFLMXpEO2dCQUN6QixPQUFPLElBQUk7WUFDYjtRQUNGO1FBQ0FrekMsT0FBT2YsY0FBYyxDQUFDeXJIO1FBQ3RCRixNQUFNL3VGLFFBQVEsa0NBQWtDO0lBQ2xELE9BQU8sSUFBSXQ5RSxTQUFTLGNBQWN4UixTQUFTLFVBQVVBLFNBQVMsUUFBUTtRQUNwRSw4Q0FBOEM7UUFFOUMsSUFBSW8xSSxlQUFlaXBDLGFBQWEsWUFBWTtRQUM1QyxJQUFJQyxTQUFTbHBDLGFBQWFyM0ksU0FBUztRQUNuQyxJQUFJd2dMLHFCQUFxQlg7UUFDekIsSUFBSVksU0FBU1osV0FBVzcvSyxTQUFTO1FBQ2pDLElBQUkwZ0wsV0FBVyxTQUFTQTtZQUN0QnJwQyxhQUFhM3hJLEtBQUssQ0FBQyxJQUFJLEVBQUVSO1lBQ3pCczdLLG1CQUFtQjk2SyxLQUFLLENBQUMsSUFBSSxFQUFFUjtRQUNqQztRQUNBLElBQUlzdkQsUUFBUWtzSCxTQUFTMWdMLFNBQVM7UUFDOUIsSUFBSyxJQUFJMmdMLFNBQVNKLE9BQVE7WUFDeEIsSUFBSUssT0FBT0wsTUFBTSxDQUFDSSxNQUFNO1lBQ3hCLElBQUlFLFlBQVlKLE1BQU0sQ0FBQ0UsTUFBTSxJQUFJO1lBQ2pDLElBQUlFLFdBQVc7Z0JBQ2IsT0FBT2QsWUFBWVk7WUFDckI7WUFDQW5zSCxLQUFLLENBQUNtc0gsTUFBTSxHQUFHQyxNQUFNLHNCQUFzQjtRQUM3QztRQUNBLElBQUssSUFBSUUsVUFBVUwsT0FBUTtZQUN6QmpzSCxLQUFLLENBQUNzc0gsT0FBTyxHQUFHTCxNQUFNLENBQUNLLE9BQU8sRUFBRSw0QkFBNEI7UUFDOUQ7UUFDQVAsT0FBTy9vQyxlQUFlLENBQUMxMUgsT0FBTyxDQUFDLFNBQVU3ZixJQUFJO1lBQzNDdXlELEtBQUssQ0FBQ3Z5RCxLQUFLLEdBQUd1eUQsS0FBSyxDQUFDdnlELEtBQUssSUFBSTtnQkFDM0I2YyxNQUFNLDJDQUEyQzdjLE9BQU87WUFDMUQ7UUFDRjtRQUNBNjlLLE1BQU1ZO0lBQ1IsT0FBTyxJQUFJanRLLFNBQVMsZUFBZUEsU0FBUyxpQkFBaUJBLFNBQVMsYUFBYTtRQUNqRix5Q0FBeUM7UUFDekMsT0FBT3FMLE1BQU1yTCxPQUFPO0lBQ3RCO0lBQ0EsT0FBT2hCLE9BQU87UUFDWkUsS0FBSytzSztRQUNMbjRLLE1BQU07WUFBQ2tNO1lBQU14UjtTQUFLO1FBQ2xCekIsT0FBT3MvSztJQUNUO0FBQ0Y7QUFDQSxTQUFTUSxhQUFhN3NLLElBQUksRUFBRXhSLElBQUk7SUFDOUIsT0FBTzRRLE9BQU87UUFDWkYsS0FBSytzSztRQUNMbjRLLE1BQU07WUFBQ2tNO1lBQU14UjtTQUFLO0lBQ3BCO0FBQ0Y7QUFDQSxTQUFTOCtLLFVBQVV0dEssSUFBSSxFQUFFeFIsSUFBSSxFQUFFKytLLFVBQVUsRUFBRUMsVUFBVSxFQUFFcEIsVUFBVTtJQUMvRCxPQUFPcHRLLE9BQU87UUFDWkUsS0FBS2d0SztRQUNMcDRLLE1BQU07WUFBQ2tNO1lBQU14UjtZQUFNKytLO1lBQVlDO1NBQVc7UUFDMUN6Z0wsT0FBT3EvSztJQUNUO0FBQ0Y7QUFDQSxTQUFTcUIsVUFBVXp0SyxJQUFJLEVBQUV4UixJQUFJLEVBQUUrK0ssVUFBVSxFQUFFQyxVQUFVO0lBQ25ELE9BQU9wdUssT0FBTztRQUNaRixLQUFLZ3RLO1FBQ0xwNEssTUFBTTtZQUFDa007WUFBTXhSO1lBQU0rK0s7WUFBWUM7U0FBVztJQUM1QztBQUNGO0FBQ0EsSUFBSWp3RixZQUFZLFNBQVNBO0lBQ3ZCLG9DQUFvQztJQUNwQyxJQUFJOXJGLFVBQVV0RyxNQUFNLEtBQUssR0FBRztRQUMxQixPQUFPMGhMLGFBQWE1NkssS0FBSyxDQUFDLE1BQU1SO0lBQ2xDLE9BR0ssSUFBSUEsVUFBVXRHLE1BQU0sS0FBSyxHQUFHO1FBQy9CLE9BQU9naEwsYUFBYWw2SyxLQUFLLENBQUMsTUFBTVI7SUFDbEMsT0FHSyxJQUFJQSxVQUFVdEcsTUFBTSxLQUFLLEdBQUc7UUFDL0IsT0FBT3NpTCxVQUFVeDdLLEtBQUssQ0FBQyxNQUFNUjtJQUMvQixPQUdLLElBQUlBLFVBQVV0RyxNQUFNLEtBQUssR0FBRztRQUMvQixPQUFPbWlMLFVBQVVyN0ssS0FBSyxDQUFDLE1BQU1SO0lBQy9CLE9BQU87UUFDTDRaLE1BQU07SUFDUjtBQUNGO0FBRUEseURBQXlEO0FBQ3pENHVGLEtBQUsxdEcsU0FBUyxDQUFDZ3hGLFNBQVMsR0FBR0E7QUFFM0Isc0JBQXNCO0FBQ3RCeXVGLFFBQVEzOUosT0FBTyxDQUFDLFNBQVVRLEtBQUs7SUFDN0JBLE1BQU1vOUosVUFBVSxDQUFDNTlKLE9BQU8sQ0FBQyxTQUFVZytKLEdBQUc7UUFDcENGLGFBQWF0OUosTUFBTTdPLElBQUksRUFBRXFzSyxJQUFJNzlLLElBQUksRUFBRTY5SyxJQUFJeHRJLElBQUk7SUFDN0M7QUFDRjtBQUVBLHNFQUFzRTtBQUN0RSxvQkFBb0I7QUFDcEIsSUFBSTZ1SSxjQUFjLFNBQVNDO0lBQ3pCLElBQUksQ0FBRSxLQUFJLFlBQVlELFdBQVUsR0FBSTtRQUNsQyxPQUFPLElBQUlBO0lBQ2I7SUFDQSxJQUFJLENBQUN2aUwsTUFBTSxHQUFHO0FBQ2hCO0FBQ0EsSUFBSXlpTCxVQUFVRixZQUFZbmhMLFNBQVM7QUFDbkNxaEwsUUFBUXYrSyxjQUFjLEdBQUc7SUFDdkIsT0FBTztBQUNUO0FBRUEsNkNBQTZDO0FBQzdDdStLLFFBQVFsc0gsUUFBUSxHQUFHLFNBQVVBLFFBQVE7SUFDbkMsSUFBSWgwRCxJQUFJLElBQUksQ0FBQ3ZDLE1BQU07SUFDbkIsSUFBSSxDQUFDdUMsRUFBRSxHQUFHO1FBQ1JnMEQsVUFBVUE7UUFDVmpULFlBQVksRUFBRTtJQUNoQjtJQUNBLE9BQU8sSUFBSSxFQUFFLFdBQVc7QUFDMUI7QUFFQSw2Q0FBNkM7QUFDN0NtL0gsUUFBUTU3SixHQUFHLEdBQUcsU0FBVXhqQixJQUFJLEVBQUV6QixLQUFLO0lBQ2pDLElBQUlXLElBQUksSUFBSSxDQUFDdkMsTUFBTSxHQUFHO0lBQ3RCLElBQUlvRSxPQUFPZixPQUFPO1FBQ2hCLElBQUksQ0FBQ2QsRUFBRSxDQUFDK2dELFVBQVUsQ0FBQzlnRCxJQUFJLENBQUM7WUFDdEJhLE1BQU1BO1lBQ056QixPQUFPQTtRQUNUO0lBQ0YsT0FBTyxJQUFJNEMsWUFBWW5CLE9BQU87UUFDNUIsSUFBSTBRLE1BQU0xUTtRQUNWLElBQUlvMUYsWUFBWTEzRixPQUFPNEgsSUFBSSxDQUFDb0w7UUFDNUIsSUFBSyxJQUFJbkwsSUFBSSxHQUFHQSxJQUFJNnZGLFVBQVV6NEYsTUFBTSxFQUFFNEksSUFBSztZQUN6QyxJQUFJMUgsTUFBTXUzRixTQUFTLENBQUM3dkYsRUFBRTtZQUN0QixJQUFJaWpHLFNBQVM5M0YsR0FBRyxDQUFDN1MsSUFBSTtZQUNyQixJQUFJMnFHLFVBQVUsTUFBTTtnQkFDbEI7WUFDRjtZQUNBLElBQUl4cEQsT0FBT21wRCxPQUFPbG9ELFVBQVUsQ0FBQ3BpRCxJQUFJLElBQUlzcUcsT0FBT2xvRCxVQUFVLENBQUNqOEMsV0FBV25HLEtBQUs7WUFDdkUsSUFBSW1oRCxRQUFRLE1BQU07Z0JBQ2hCO1lBQ0Y7WUFDQSxJQUFJNnRDLFFBQVE3dEMsS0FBS2gvQyxJQUFJO1lBQ3JCLElBQUl1OEYsU0FBU2lNO1lBQ2IsSUFBSSxDQUFDdHBHLEVBQUUsQ0FBQytnRCxVQUFVLENBQUM5Z0QsSUFBSSxDQUFDO2dCQUN0QmEsTUFBTTZzRjtnQkFDTnR1RixPQUFPZytGO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsT0FBTyxJQUFJLEVBQUUsV0FBVztBQUMxQjtBQUNBNmlGLFFBQVFwK0osS0FBSyxHQUFHbytKLFFBQVE1N0osR0FBRztBQUUzQix5REFBeUQ7QUFDekQ0N0osUUFBUXAyRSxhQUFhLEdBQUcsU0FBVTlvRixFQUFFO0lBQ2xDLElBQUljLFFBQVEsSUFBSW1uRixPQUFPam9GO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDMG9GLGFBQWEsQ0FBQzVuRjtBQUM1QjtBQUVBLDBEQUEwRDtBQUMxRG8rSixRQUFReDJFLGFBQWEsR0FBRyxTQUFVNW5GLEtBQUs7SUFDckMsSUFBSyxJQUFJOWhCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUN2QyxNQUFNLEVBQUV1QyxJQUFLO1FBQ3BDLElBQUk2ekUsVUFBVSxJQUFJLENBQUM3ekUsRUFBRTtRQUNyQixJQUFJZzBELFdBQVc2ZixRQUFRN2YsUUFBUTtRQUMvQixJQUFJcFksUUFBUWk0QixRQUFROXlCLFVBQVU7UUFDOUJqL0IsTUFBTWt5QyxRQUFRLENBQUNBLFdBQVcsaUJBQWlCO1FBRTNDLElBQUssSUFBSTN0RCxJQUFJLEdBQUdBLElBQUl1MUMsTUFBTW4rQyxNQUFNLEVBQUU0SSxJQUFLO1lBQ3JDLElBQUl5NUMsT0FBT2xFLEtBQUssQ0FBQ3YxQyxFQUFFO1lBQ25CeWIsTUFBTXdDLEdBQUcsQ0FBQ3c3QixLQUFLaC9DLElBQUksRUFBRWcvQyxLQUFLemdELEtBQUssR0FBRyxpQkFBaUI7UUFDckQ7SUFDRjtJQUNBLE9BQU95aUI7QUFDVDtBQUVBLElBQUlxK0osVUFBVTtBQUVkLElBQUlDLFlBQVksU0FBU0EsVUFBVTd1SyxPQUFPO0lBQ3hDLHVDQUF1QztJQUN2QyxJQUFJQSxZQUFZL1EsV0FBVztRQUN6QitRLFVBQVUsQ0FBQztJQUNiO0lBRUEsa0JBQWtCO0lBQ2xCLElBQUl0UCxZQUFZc1AsVUFBVTtRQUN4QixPQUFPLElBQUlnN0YsS0FBS2g3RjtJQUNsQixPQUdLLElBQUkxUCxPQUFPMFAsVUFBVTtRQUN4QixPQUFPcytFLFVBQVV0ckYsS0FBSyxDQUFDc3JGLFdBQVc5ckY7SUFDcEM7QUFDRjtBQUVBLHNEQUFzRDtBQUN0RHE4SyxVQUFVNWlFLEdBQUcsR0FBRyxTQUFVbWhFLEdBQUc7SUFDM0IsSUFBSTM2SyxPQUFPcEcsTUFBTWlCLFNBQVMsQ0FBQ2dDLEtBQUssQ0FBQ3JCLElBQUksQ0FBQ3VFLFdBQVcsSUFBSSxzQkFBc0I7SUFFM0VDLEtBQUswaEIsT0FBTyxDQUFDMDZKLFlBQVksZ0NBQWdDO0lBRXpEekIsSUFBSXA2SyxLQUFLLENBQUMsTUFBTVA7SUFDaEIsT0FBTyxJQUFJO0FBQ2I7QUFDQW84SyxVQUFVdmlLLFFBQVEsR0FBRyxTQUFVd3lFLElBQUk7SUFDakMsT0FBT3h5RSxTQUFTd3lFO0FBQ2xCO0FBRUEsMkJBQTJCO0FBQzNCK3ZGLFVBQVVELE9BQU8sR0FBR0E7QUFFcEIsNkNBQTZDO0FBQzdDQyxVQUFVcjlLLFVBQVUsR0FBR3E5SyxVQUFVSCxVQUFVLEdBQUdEO0FBRWQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zeW5lcmdleC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5lc20ubWpzPzE1ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyNSwgVGhlIEN5dG9zY2FwZSBDb25zb3J0aXVtLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbiAqIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8gZGVhbCBpblxuICogdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuICogdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkb1xuICogc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8IGZhbHNlLCBvLmNvbmZpZ3VyYWJsZSA9IHRydWUsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gdHJ1ZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIociwgZSkge1xuICB2YXIgdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmICghdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHIpIHx8ICh0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpKSB8fCBlKSB7XG4gICAgICB0ICYmIChyID0gdCk7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbiA+PSByLmxlbmd0aCA/IHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogcltuKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICB0aHJvdyByO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cbiAgdmFyIG8sXG4gICAgYSA9IHRydWUsXG4gICAgdSA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHQgPSB0LmNhbGwocik7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgciA9IHQubmV4dCgpO1xuICAgICAgcmV0dXJuIGEgPSByLmRvbmUsIHI7XG4gICAgfSxcbiAgICBlOiBmdW5jdGlvbiAocikge1xuICAgICAgdSA9IHRydWUsIG8gPSByO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYSB8fCBudWxsID09IHQucmV0dXJuIHx8IHQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodSkgdGhyb3cgbztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkkMShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gdHJ1ZSxcbiAgICAgIG8gPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gdHJ1ZSwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodW5kZWZpbmVkICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgcik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFN0cmluZyApKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIF93aW5kb3cgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIG5hdmlnYXRvciA9IF93aW5kb3cgPyBfd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG5fd2luZG93ID8gX3dpbmRvdy5kb2N1bWVudCA6IG51bGw7XG52YXIgdHlwZW9mc3RyID0gX3R5cGVvZignJyk7XG52YXIgdHlwZW9mb2JqID0gX3R5cGVvZih7fSk7XG52YXIgdHlwZW9mZm4gPSBfdHlwZW9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoSFRNTEVsZW1lbnQpO1xudmFyIGluc3RhbmNlU3RyID0gZnVuY3Rpb24gaW5zdGFuY2VTdHIob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGZuJDYob2JqLmluc3RhbmNlU3RyaW5nKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT0gdHlwZW9mc3RyO1xufTtcbnZhciBmbiQ2ID0gZnVuY3Rpb24gZm4ob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZmZuO1xufTtcbnZhciBhcnJheSA9IGZ1bmN0aW9uIGFycmF5KG9iaikge1xuICByZXR1cm4gIWVsZW1lbnRPckNvbGxlY3Rpb24ob2JqKSAmJiAoQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5KTtcbn07XG52YXIgcGxhaW5PYmplY3QgPSBmdW5jdGlvbiBwbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqICYmICFhcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iajtcbn07XG52YXIgbnVtYmVyJDEgPSBmdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IF90eXBlb2YoMSkgJiYgIWlzTmFOKG9iaik7XG59O1xudmFyIGludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKG9iaikge1xuICByZXR1cm4gbnVtYmVyJDEob2JqKSAmJiBNYXRoLmZsb29yKG9iaikgPT09IG9iajtcbn07XG52YXIgaHRtbEVsZW1lbnQgPSBmdW5jdGlvbiBodG1sRWxlbWVudChvYmopIHtcbiAgaWYgKCd1bmRlZmluZWQnID09PSB0eXBlb2ZodG1sZWxlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbCAhPSBvYmogJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cbn07XG52YXIgZWxlbWVudE9yQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGVsZW1lbnRPckNvbGxlY3Rpb24ob2JqKSB7XG4gIHJldHVybiBlbGVtZW50KG9iaikgfHwgY29sbGVjdGlvbihvYmopO1xufTtcbnZhciBlbGVtZW50ID0gZnVuY3Rpb24gZWxlbWVudChvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xufTtcbnZhciBjb2xsZWN0aW9uID0gZnVuY3Rpb24gY29sbGVjdGlvbihvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbn07XG52YXIgY29yZSA9IGZ1bmN0aW9uIGNvcmUob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29yZSc7XG59O1xudmFyIHN0eWxlc2hlZXQgPSBmdW5jdGlvbiBzdHlsZXNoZWV0KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ3N0eWxlc2hlZXQnO1xufTtcbnZhciBldmVudCA9IGZ1bmN0aW9uIGV2ZW50KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2V2ZW50Jztcbn07XG52YXIgZW1wdHlTdHJpbmcgPSBmdW5jdGlvbiBlbXB0eVN0cmluZyhvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIC8vIG51bGwgaXMgZW1wdHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvYmogPT09ICcnIHx8IG9iai5tYXRjaCgvXlxccyskLykpIHtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgc3RyaW5nIGlzIGVtcHR5XG4gIH1cbiAgcmV0dXJuIGZhbHNlOyAvLyBvdGhlcndpc2UsIHdlIGRvbid0IGtub3cgd2hhdCB3ZSd2ZSBnb3Rcbn07XG52YXIgZG9tRWxlbWVudCA9IGZ1bmN0aW9uIGRvbUVsZW1lbnQob2JqKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSBub3QgaW4gYSBicm93c2VyIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG59O1xudmFyIGJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYm91bmRpbmdCb3gob2JqKSB7XG4gIHJldHVybiBwbGFpbk9iamVjdChvYmopICYmIG51bWJlciQxKG9iai54MSkgJiYgbnVtYmVyJDEob2JqLngyKSAmJiBudW1iZXIkMShvYmoueTEpICYmIG51bWJlciQxKG9iai55Mik7XG59O1xudmFyIHByb21pc2UgPSBmdW5jdGlvbiBwcm9taXNlKG9iaikge1xuICByZXR1cm4gb2JqZWN0KG9iaikgJiYgZm4kNihvYmoudGhlbik7XG59O1xudmFyIG1zID0gZnVuY3Rpb24gbXMoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbXNpZXx0cmlkZW50fGVkZ2UvaSk7XG59OyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cblxudmFyIG1lbW9pemUgPSBmdW5jdGlvbiBtZW1vaXplKGZuLCBrZXlGbikge1xuICBpZiAoIWtleUZuKSB7XG4gICAga2V5Rm4gPSBmdW5jdGlvbiBrZXlGbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgIH07XG4gIH1cbiAgdmFyIF9tZW1vaXplZEZuID0gZnVuY3Rpb24gbWVtb2l6ZWRGbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgayA9IGtleUZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHZhciBjYWNoZSA9IF9tZW1vaXplZEZuLmNhY2hlO1xuICAgIGlmICghKHJldCA9IGNhY2hlW2tdKSkge1xuICAgICAgcmV0ID0gY2FjaGVba10gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgX21lbW9pemVkRm4uY2FjaGUgPSB7fTtcbiAgcmV0dXJuIF9tZW1vaXplZEZuO1xufTtcblxudmFyIGNhbWVsMmRhc2ggPSBtZW1vaXplKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuICctJyArIHYudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBkYXNoMmNhbWVsID0gbWVtb2l6ZShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHZbMV0udG9VcHBlckNhc2UoKTtcbiAgfSk7XG59KTtcbnZhciBwcmVwZW5kQ2FtZWwgPSBtZW1vaXplKGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICByZXR1cm4gcHJlZml4ICsgc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufSwgZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gIHJldHVybiBwcmVmaXggKyAnJCcgKyBzdHI7XG59KTtcbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgaWYgKGVtcHR5U3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcbnZhciBlbmRzV2l0aCA9IGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgc3VmZml4KSB7XG4gIHJldHVybiBzdHJpbmcuc2xpY2UoLTEgKiBzdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4O1xufTtcblxudmFyIG51bWJlciA9ICcoPzpbLStdPyg/Oig/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbRWVdWystXT9cXFxcZCspPykpJztcbnZhciByZ2JhID0gJ3JnYlthXT9cXFxcKCgnICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJykpP1xcXFwpJztcbnZhciByZ2JhTm9CYWNrUmVmcyA9ICdyZ2JbYV0/XFxcXCgoPzonICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJykpP1xcXFwpJztcbnZhciBoc2xhID0gJ2hzbFthXT9cXFxcKCgnICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJykpP1xcXFwpJztcbnZhciBoc2xhTm9CYWNrUmVmcyA9ICdoc2xbYV0/XFxcXCgoPzonICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJykpP1xcXFwpJztcbnZhciBoZXgzID0gJ1xcXFwjWzAtOWEtZkEtRl17M30nO1xudmFyIGhleDYgPSAnXFxcXCNbMC05YS1mQS1GXXs2fSc7XG5cbnZhciBhc2NlbmRpbmcgPSBmdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBkZXNjZW5kaW5nID0gZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiAtMSAqIGFzY2VuZGluZyhhLCBiKTtcbn07XG5cbnZhciBleHRlbmQgPSBPYmplY3QuYXNzaWduICE9IG51bGwgPyBPYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KSA6IGZ1bmN0aW9uICh0Z3QpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvYmogPSBhcmdzW2ldO1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrID0ga2V5c1tqXTtcbiAgICAgIHRndFtrXSA9IG9ialtrXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRndDtcbn07XG5cbi8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbnZhciBoZXgydHVwbGUgPSBmdW5jdGlvbiBoZXgydHVwbGUoaGV4KSB7XG4gIGlmICghKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykgfHwgaGV4WzBdICE9PSAnIycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgdmFyIHIsIGcsIGI7XG4gIHZhciBiYXNlID0gMTY7XG4gIGlmIChzaG9ydEhleCkge1xuICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMV0sIGJhc2UpO1xuICAgIGcgPSBwYXJzZUludChoZXhbMl0gKyBoZXhbMl0sIGJhc2UpO1xuICAgIGIgPSBwYXJzZUludChoZXhbM10gKyBoZXhbM10sIGJhc2UpO1xuICB9IGVsc2Uge1xuICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMl0sIGJhc2UpO1xuICAgIGcgPSBwYXJzZUludChoZXhbM10gKyBoZXhbNF0sIGJhc2UpO1xuICAgIGIgPSBwYXJzZUludChoZXhbNV0gKyBoZXhbNl0sIGJhc2UpO1xuICB9XG4gIHJldHVybiBbciwgZywgYl07XG59O1xuXG4vLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcbnZhciBoc2wydHVwbGUgPSBmdW5jdGlvbiBoc2wydHVwbGUoaHNsKSB7XG4gIHZhciByZXQ7XG4gIHZhciBoLCBzLCBsLCBhLCByLCBnLCBiO1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIGhzbGEgKyAnJCcpLmV4ZWMoaHNsKTtcbiAgaWYgKG0pIHtcbiAgICAvLyBnZXQgaHVlXG4gICAgaCA9IHBhcnNlSW50KG1bMV0pO1xuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCA9ICgzNjAgLSAtMSAqIGggJSAzNjApICUgMzYwO1xuICAgIH0gZWxzZSBpZiAoaCA+IDM2MCkge1xuICAgICAgaCA9IGggJSAzNjA7XG4gICAgfVxuICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICBzID0gcGFyc2VGbG9hdChtWzJdKTtcbiAgICBpZiAocyA8IDAgfHwgcyA+IDEwMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgIHMgPSBzIC8gMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICBsID0gcGFyc2VGbG9hdChtWzNdKTtcbiAgICBpZiAobCA8IDAgfHwgbCA+IDEwMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgbCA9IGwgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIGEgPSBtWzRdO1xuICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuICAgICAgaWYgKGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gYWxwaGEgaXMgWzAsIDFdXG4gICAgfVxuXG4gICAgLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICByID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggKyAxIC8gMykpO1xuICAgICAgZyA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoKSk7XG4gICAgICBiID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxIC8gMykpO1xuICAgIH1cbiAgICByZXQgPSBbciwgZywgYiwgYV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxudmFyIHJnYjJ0dXBsZSA9IGZ1bmN0aW9uIHJnYjJ0dXBsZShyZ2IpIHtcbiAgdmFyIHJldDtcbiAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIHJnYmEgKyAnJCcpLmV4ZWMocmdiKTtcbiAgaWYgKG0pIHtcbiAgICByZXQgPSBbXTtcbiAgICB2YXIgaXNQY3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcbiAgICAgIGlmIChjaGFubmVsW2NoYW5uZWwubGVuZ3RoIC0gMV0gPT09ICclJykge1xuICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjaGFubmVsID0gcGFyc2VGbG9hdChjaGFubmVsKTtcbiAgICAgIGlmIChpc1BjdFtpXSkge1xuICAgICAgICBjaGFubmVsID0gY2hhbm5lbCAvIDEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGludmFsaWQgY2hhbm5lbCB2YWx1ZVxuXG4gICAgICByZXQucHVzaChNYXRoLmZsb29yKGNoYW5uZWwpKTtcbiAgICB9XG4gICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcbiAgICBpZiAoYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgdmFyIGFscGhhID0gbVs0XTtcbiAgICBpZiAoYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcbiAgICAgIGlmIChhbHBoYSA8IDAgfHwgYWxwaGEgPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaW52YWxpZCBhbHBoYSB2YWx1ZVxuXG4gICAgICByZXQucHVzaChhbHBoYSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xudmFyIGNvbG9ybmFtZTJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9ybmFtZTJ0dXBsZShjb2xvcikge1xuICByZXR1cm4gY29sb3JzW2NvbG9yLnRvTG93ZXJDYXNlKCldO1xufTtcbnZhciBjb2xvcjJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9yMnR1cGxlKGNvbG9yKSB7XG4gIHJldHVybiAoYXJyYXkoY29sb3IpID8gY29sb3IgOiBudWxsKSB8fCBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHx8IGhleDJ0dXBsZShjb2xvcikgfHwgcmdiMnR1cGxlKGNvbG9yKSB8fCBoc2wydHVwbGUoY29sb3IpO1xufTtcbnZhciBjb2xvcnMgPSB7XG4gIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sXG4gIC8vIE5CIGFscGhhID09PSAwXG5cbiAgLy8gcmVndWxhciBjb2xvdXJzXG4gIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICBmbG9yYWx3aGl0ZTogWzI1NSwgMjUwLCAyNDBdLFxuICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59O1xuXG4vLyBzZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG52YXIgc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwKG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocGxhaW5PYmplY3Qoa2V5KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgfVxuICAgIGlmIChpIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChvYmpba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIG9ialtrZXldID0ge307XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcbnZhciBnZXRNYXAgPSBmdW5jdGlvbiBnZXRNYXAob3B0aW9ucykge1xuICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICB9XG4gICAgb2JqID0gb2JqW2tleV07XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGlzT2JqZWN0XzE7XG52YXIgaGFzUmVxdWlyZWRJc09iamVjdDtcblxuZnVuY3Rpb24gcmVxdWlyZUlzT2JqZWN0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNPYmplY3QpIHJldHVybiBpc09iamVjdF8xO1xuXHRoYXNSZXF1aXJlZElzT2JqZWN0ID0gMTtcblx0ZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuXHR9XG5cblx0aXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXHRyZXR1cm4gaXNPYmplY3RfMTtcbn1cblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblxudmFyIF9mcmVlR2xvYmFsO1xudmFyIGhhc1JlcXVpcmVkX2ZyZWVHbG9iYWw7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfZnJlZUdsb2JhbCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9mcmVlR2xvYmFsKSByZXR1cm4gX2ZyZWVHbG9iYWw7XG5cdGhhc1JlcXVpcmVkX2ZyZWVHbG9iYWwgPSAxO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxuXHRfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWw7XG5cdHJldHVybiBfZnJlZUdsb2JhbDtcbn1cblxudmFyIF9yb290O1xudmFyIGhhc1JlcXVpcmVkX3Jvb3Q7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfcm9vdCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9yb290KSByZXR1cm4gX3Jvb3Q7XG5cdGhhc1JlcXVpcmVkX3Jvb3QgPSAxO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmVfZnJlZUdsb2JhbCgpO1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG5cdHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG5cdC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXHR2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXHRfcm9vdCA9IHJvb3Q7XG5cdHJldHVybiBfcm9vdDtcbn1cblxudmFyIG5vd18xO1xudmFyIGhhc1JlcXVpcmVkTm93O1xuXG5mdW5jdGlvbiByZXF1aXJlTm93ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkTm93KSByZXR1cm4gbm93XzE7XG5cdGhhc1JlcXVpcmVkTm93ID0gMTtcblx0dmFyIHJvb3QgPSByZXF1aXJlX3Jvb3QoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG5cdCAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAyLjQuMFxuXHQgKiBAY2F0ZWdvcnkgRGF0ZVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcblx0ICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuXHQgKiB9LCBfLm5vdygpKTtcblx0ICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cblx0ICovXG5cdHZhciBub3cgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuXHR9O1xuXG5cdG5vd18xID0gbm93O1xuXHRyZXR1cm4gbm93XzE7XG59XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xuXG52YXIgX3RyaW1tZWRFbmRJbmRleDtcbnZhciBoYXNSZXF1aXJlZF90cmltbWVkRW5kSW5kZXg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfdHJpbW1lZEVuZEluZGV4ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX3RyaW1tZWRFbmRJbmRleCkgcmV0dXJuIF90cmltbWVkRW5kSW5kZXg7XG5cdGhhc1JlcXVpcmVkX3RyaW1tZWRFbmRJbmRleCA9IDE7XG5cdHZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuXHQvKipcblx0ICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuXHQgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG5cdCAqL1xuXHRmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG5cdCAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuXHQgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRfdHJpbW1lZEVuZEluZGV4ID0gdHJpbW1lZEVuZEluZGV4O1xuXHRyZXR1cm4gX3RyaW1tZWRFbmRJbmRleDtcbn1cblxudmFyIF9iYXNlVHJpbTtcbnZhciBoYXNSZXF1aXJlZF9iYXNlVHJpbTtcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlVHJpbSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlVHJpbSkgcmV0dXJuIF9iYXNlVHJpbTtcblx0aGFzUmVxdWlyZWRfYmFzZVRyaW0gPSAxO1xuXHR2YXIgdHJpbW1lZEVuZEluZGV4ID0gcmVxdWlyZV90cmltbWVkRW5kSW5kZXgoKTtcblxuXHQvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG5cdHZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcblx0ICByZXR1cm4gc3RyaW5nXG5cdCAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuXHQgICAgOiBzdHJpbmc7XG5cdH1cblxuXHRfYmFzZVRyaW0gPSBiYXNlVHJpbTtcblx0cmV0dXJuIF9iYXNlVHJpbTtcbn1cblxudmFyIF9TeW1ib2w7XG52YXIgaGFzUmVxdWlyZWRfU3ltYm9sO1xuXG5mdW5jdGlvbiByZXF1aXJlX1N5bWJvbCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9TeW1ib2wpIHJldHVybiBfU3ltYm9sO1xuXHRoYXNSZXF1aXJlZF9TeW1ib2wgPSAxO1xuXHR2YXIgcm9vdCA9IHJlcXVpcmVfcm9vdCgpO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0X1N5bWJvbCA9IFN5bWJvbDtcblx0cmV0dXJuIF9TeW1ib2w7XG59XG5cbnZhciBfZ2V0UmF3VGFnO1xudmFyIGhhc1JlcXVpcmVkX2dldFJhd1RhZztcblxuZnVuY3Rpb24gcmVxdWlyZV9nZXRSYXdUYWcgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfZ2V0UmF3VGFnKSByZXR1cm4gX2dldFJhd1RhZztcblx0aGFzUmVxdWlyZWRfZ2V0UmF3VGFnID0gMTtcblx0dmFyIFN5bWJvbCA9IHJlcXVpcmVfU3ltYm9sKCk7XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG5cdCAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuXHQgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cblx0ICB0cnkge1xuXHQgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuXHQgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHQgIGlmICh1bm1hc2tlZCkge1xuXHQgICAgaWYgKGlzT3duKSB7XG5cdCAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRfZ2V0UmF3VGFnID0gZ2V0UmF3VGFnO1xuXHRyZXR1cm4gX2dldFJhd1RhZztcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgX29iamVjdFRvU3RyaW5nO1xudmFyIGhhc1JlcXVpcmVkX29iamVjdFRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXF1aXJlX29iamVjdFRvU3RyaW5nICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX29iamVjdFRvU3RyaW5nKSByZXR1cm4gX29iamVjdFRvU3RyaW5nO1xuXHRoYXNSZXF1aXJlZF9vYmplY3RUb1N0cmluZyA9IDE7XG5cdHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcblx0ICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG5cdCAqIG9mIHZhbHVlcy5cblx0ICovXG5cdHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG5cdCAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHR9XG5cblx0X29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG5cdHJldHVybiBfb2JqZWN0VG9TdHJpbmc7XG59XG5cbnZhciBfYmFzZUdldFRhZztcbnZhciBoYXNSZXF1aXJlZF9iYXNlR2V0VGFnO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VHZXRUYWcgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZUdldFRhZykgcmV0dXJuIF9iYXNlR2V0VGFnO1xuXHRoYXNSZXF1aXJlZF9iYXNlR2V0VGFnID0gMTtcblx0dmFyIFN5bWJvbCA9IHJlcXVpcmVfU3ltYm9sKCksXG5cdCAgICBnZXRSYXdUYWcgPSByZXF1aXJlX2dldFJhd1RhZygpLFxuXHQgICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlX29iamVjdFRvU3RyaW5nKCk7XG5cblx0LyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcblx0ICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuXHQgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG5cdCAgfVxuXHQgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcblx0ICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuXHQgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG5cdH1cblxuXHRfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cdHJldHVybiBfYmFzZUdldFRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGlzT2JqZWN0TGlrZV8xO1xudmFyIGhhc1JlcXVpcmVkSXNPYmplY3RMaWtlO1xuXG5mdW5jdGlvbiByZXF1aXJlSXNPYmplY3RMaWtlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNPYmplY3RMaWtlKSByZXR1cm4gaXNPYmplY3RMaWtlXzE7XG5cdGhhc1JlcXVpcmVkSXNPYmplY3RMaWtlID0gMTtcblx0ZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuXHR9XG5cblx0aXNPYmplY3RMaWtlXzEgPSBpc09iamVjdExpa2U7XG5cdHJldHVybiBpc09iamVjdExpa2VfMTtcbn1cblxudmFyIGlzU3ltYm9sXzE7XG52YXIgaGFzUmVxdWlyZWRJc1N5bWJvbDtcblxuZnVuY3Rpb24gcmVxdWlyZUlzU3ltYm9sICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSXNTeW1ib2wpIHJldHVybiBpc1N5bWJvbF8xO1xuXHRoYXNSZXF1aXJlZElzU3ltYm9sID0gMTtcblx0dmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlX2Jhc2VHZXRUYWcoKSxcblx0ICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmVJc09iamVjdExpa2UoKTtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc1N5bWJvbCgnYWJjJyk7XG5cdCAqIC8vID0+IGZhbHNlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcblx0ICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG5cdH1cblxuXHRpc1N5bWJvbF8xID0gaXNTeW1ib2w7XG5cdHJldHVybiBpc1N5bWJvbF8xO1xufVxuXG52YXIgdG9OdW1iZXJfMTtcbnZhciBoYXNSZXF1aXJlZFRvTnVtYmVyO1xuXG5mdW5jdGlvbiByZXF1aXJlVG9OdW1iZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRUb051bWJlcikgcmV0dXJuIHRvTnVtYmVyXzE7XG5cdGhhc1JlcXVpcmVkVG9OdW1iZXIgPSAxO1xuXHR2YXIgYmFzZVRyaW0gPSByZXF1aXJlX2Jhc2VUcmltKCksXG5cdCAgICBpc09iamVjdCA9IHJlcXVpcmVJc09iamVjdCgpLFxuXHQgICAgaXNTeW1ib2wgPSByZXF1aXJlSXNTeW1ib2woKTtcblxuXHQvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cblx0dmFyIE5BTiA9IDAgLyAwO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cblx0LyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cblx0dmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoMy4yKTtcblx0ICogLy8gPT4gMy4yXG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG5cdCAqIC8vID0+IDVlLTMyNFxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcblx0ICogLy8gPT4gSW5maW5pdHlcblx0ICpcblx0ICogXy50b051bWJlcignMy4yJyk7XG5cdCAqIC8vID0+IDMuMlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBOQU47XG5cdCAgfVxuXHQgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblx0ICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcblx0ICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuXHQgIH1cblx0ICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcblx0ICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuXHQgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuXHQgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG5cdCAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcblx0fVxuXG5cdHRvTnVtYmVyXzEgPSB0b051bWJlcjtcblx0cmV0dXJuIHRvTnVtYmVyXzE7XG59XG5cbnZhciBkZWJvdW5jZV8xO1xudmFyIGhhc1JlcXVpcmVkRGVib3VuY2U7XG5cbmZ1bmN0aW9uIHJlcXVpcmVEZWJvdW5jZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZERlYm91bmNlKSByZXR1cm4gZGVib3VuY2VfMTtcblx0aGFzUmVxdWlyZWREZWJvdW5jZSA9IDE7XG5cdHZhciBpc09iamVjdCA9IHJlcXVpcmVJc09iamVjdCgpLFxuXHQgICAgbm93ID0gcmVxdWlyZU5vdygpLFxuXHQgICAgdG9OdW1iZXIgPSByZXF1aXJlVG9OdW1iZXIoKTtcblxuXHQvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG5cdHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXHR2YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG5cdCAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG5cdCAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuXHQgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG5cdCAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuXHQgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcblx0ICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuXHQgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG5cdCAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG5cdCAqIGludm9jYXRpb24uXG5cdCAqXG5cdCAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcblx0ICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cblx0ICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuXHQgKlxuXHQgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcblx0ICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuXHQgKlxuXHQgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcblx0ICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG5cdCAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuXHQgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cblx0ICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcblx0ICpcblx0ICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG5cdCAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcblx0ICogICAnbGVhZGluZyc6IHRydWUsXG5cdCAqICAgJ3RyYWlsaW5nJzogZmFsc2Vcblx0ICogfSkpO1xuXHQgKlxuXHQgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuXHQgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcblx0ICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuXHQgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG5cdCAqXG5cdCAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG5cdCAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuXHQgKi9cblx0ZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuXHQgIHZhciBsYXN0QXJncyxcblx0ICAgICAgbGFzdFRoaXMsXG5cdCAgICAgIG1heFdhaXQsXG5cdCAgICAgIHJlc3VsdCxcblx0ICAgICAgdGltZXJJZCxcblx0ICAgICAgbGFzdENhbGxUaW1lLFxuXHQgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG5cdCAgICAgIGxlYWRpbmcgPSBmYWxzZSxcblx0ICAgICAgbWF4aW5nID0gZmFsc2UsXG5cdCAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuXHQgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG5cdCAgfVxuXHQgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuXHQgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuXHQgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuXHQgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG5cdCAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuXHQgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcblx0ICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG5cdCAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG5cdCAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuXHQgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuXHQgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuXHQgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cblx0ICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcblx0ICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG5cdCAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG5cdCAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cblx0ICAgIHJldHVybiBtYXhpbmdcblx0ICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuXHQgICAgICA6IHRpbWVXYWl0aW5nO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG5cdCAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuXHQgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cblx0ICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG5cdCAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuXHQgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuXHQgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcblx0ICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdygpO1xuXHQgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuXHQgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuXHQgICAgfVxuXHQgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG5cdCAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG5cdCAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG5cdCAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cblx0ICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuXHQgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcblx0ICAgIH1cblx0ICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcblx0ICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXHQgICAgfVxuXHQgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuXHQgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZmx1c2goKSB7XG5cdCAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG5cdCAgICB2YXIgdGltZSA9IG5vdygpLFxuXHQgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cblx0ICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuXHQgICAgbGFzdFRoaXMgPSB0aGlzO1xuXHQgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuXHQgICAgaWYgKGlzSW52b2tpbmcpIHtcblx0ICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtYXhpbmcpIHtcblx0ICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuXHQgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcblx0ICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHQgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG5cdCAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG5cdCAgcmV0dXJuIGRlYm91bmNlZDtcblx0fVxuXG5cdGRlYm91bmNlXzEgPSBkZWJvdW5jZTtcblx0cmV0dXJuIGRlYm91bmNlXzE7XG59XG5cbnZhciBkZWJvdW5jZUV4cG9ydHMgPSByZXF1aXJlRGVib3VuY2UoKTtcbnZhciBkZWJvdW5jZSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhkZWJvdW5jZUV4cG9ydHMpO1xuXG52YXIgcGVyZm9ybWFuY2UkMSA9IF93aW5kb3cgPyBfd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcbnZhciBwbm93ID0gcGVyZm9ybWFuY2UkMSAmJiBwZXJmb3JtYW5jZSQxLm5vdyA/IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBlcmZvcm1hbmNlJDEubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG52YXIgcmFmID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX3dpbmRvdykge1xuICAgIGlmIChfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX3dpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgX3dpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF93aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGlmIChmbikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKHBub3coKSk7XG4gICAgICB9LCAxMDAwIC8gNjApO1xuICAgIH1cbiAgfTtcbn0oKTtcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgcmV0dXJuIHJhZihmbik7XG59O1xudmFyIHBlcmZvcm1hbmNlTm93ID0gcG5vdztcblxudmFyIERFRkFVTFRfSEFTSF9TRUVEID0gOTI2MTtcbnZhciBLID0gNjU1OTk7IC8vIDM3IGFsc28gd29ya3MgcHJldHR5IHdlbGxcbnZhciBERUZBVUxUX0hBU0hfU0VFRF9BTFQgPSA1MzgxO1xudmFyIGhhc2hJdGVyYWJsZUludHMgPSBmdW5jdGlvbiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yKSB7XG4gIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRDtcbiAgLy8gc2RibS9zdHJpbmctaGFzaFxuICB2YXIgaGFzaCA9IHNlZWQ7XG4gIHZhciBlbnRyeTtcbiAgZm9yICg7Oykge1xuICAgIGVudHJ5ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaGFzaCA9IGhhc2ggKiBLICsgZW50cnkudmFsdWUgfCAwO1xuICB9XG4gIHJldHVybiBoYXNoO1xufTtcbnZhciBoYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludChudW0pIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEO1xuICAvLyBzZGJtL3N0cmluZy1oYXNoXG4gIHJldHVybiBzZWVkICogSyArIG51bSB8IDA7XG59O1xudmFyIGhhc2hJbnRBbHQgPSBmdW5jdGlvbiBoYXNoSW50QWx0KG51bSkge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICAvLyBkamIyL3N0cmluZy1oYXNoXG4gIHJldHVybiAoc2VlZCA8PCA1KSArIHNlZWQgKyBudW0gfCAwO1xufTtcbnZhciBjb21iaW5lSGFzaGVzID0gZnVuY3Rpb24gY29tYmluZUhhc2hlcyhoYXNoMSwgaGFzaDIpIHtcbiAgcmV0dXJuIGhhc2gxICogMHgyMDAwMDAgKyBoYXNoMjtcbn07XG52YXIgY29tYmluZUhhc2hlc0FycmF5ID0gZnVuY3Rpb24gY29tYmluZUhhc2hlc0FycmF5KGhhc2hlcykge1xuICByZXR1cm4gaGFzaGVzWzBdICogMHgyMDAwMDAgKyBoYXNoZXNbMV07XG59O1xudmFyIGhhc2hBcnJheXMgPSBmdW5jdGlvbiBoYXNoQXJyYXlzKGhhc2hlczEsIGhhc2hlczIpIHtcbiAgcmV0dXJuIFtoYXNoSW50KGhhc2hlczFbMF0sIGhhc2hlczJbMF0pLCBoYXNoSW50QWx0KGhhc2hlczFbMV0sIGhhc2hlczJbMV0pXTtcbn07XG52YXIgaGFzaEludHNBcnJheSA9IGZ1bmN0aW9uIGhhc2hJbnRzQXJyYXkoaW50cywgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gaW50cy5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBpbnRzW2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbn07XG52YXIgaGFzaFN0cmluZyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyLCBzZWVkKSB7XG4gIHZhciBlbnRyeSA9IHtcbiAgICB2YWx1ZTogMCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5ncyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzKCkge1xuICByZXR1cm4gaGFzaFN0cmluZ3NBcnJheShhcmd1bWVudHMpO1xufTtcbnZhciBoYXNoU3RyaW5nc0FycmF5ID0gZnVuY3Rpb24gaGFzaFN0cmluZ3NBcnJheShzdHJzKSB7XG4gIHZhciBoYXNoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RyID0gc3Ryc1tpXTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyLCBoYXNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xuXG5mdW5jdGlvbiByb3RhdGVQb2ludCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBhbmdsZURlZ3JlZXMpIHtcbiAgdmFyIGFuZ2xlUmFkaWFucyA9IGFuZ2xlRGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG4gIHZhciByb3RhdGVkWCA9IE1hdGguY29zKGFuZ2xlUmFkaWFucykgKiAoeCAtIGNlbnRlclgpIC0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKSAqICh5IC0gY2VudGVyWSkgKyBjZW50ZXJYO1xuICB2YXIgcm90YXRlZFkgPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpICogKHggLSBjZW50ZXJYKSArIE1hdGguY29zKGFuZ2xlUmFkaWFucykgKiAoeSAtIGNlbnRlclkpICsgY2VudGVyWTtcbiAgcmV0dXJuIHtcbiAgICB4OiByb3RhdGVkWCxcbiAgICB5OiByb3RhdGVkWVxuICB9O1xufVxudmFyIG1vdmVQb2ludEJ5Qm94QXNwZWN0ID0gZnVuY3Rpb24gbW92ZVBvaW50QnlCb3hBc3BlY3QoeCwgeSwgYm94WCwgYm94WSwgc2tld1gsIHNrZXdZKSB7XG4gIHJldHVybiB7XG4gICAgeDogKHggLSBib3hYKSAqIHNrZXdYICsgYm94WCxcbiAgICB5OiAoeSAtIGJveFkpICogc2tld1kgKyBib3hZXG4gIH07XG59O1xuZnVuY3Rpb24gcm90YXRlUG9zQW5kU2tld0J5Qm94KHBvcywgYm94LCBhbmdsZURlZ3JlZXMpIHtcbiAgaWYgKGFuZ2xlRGVncmVlcyA9PT0gMCkgcmV0dXJuIHBvcztcbiAgdmFyIGNlbnRlclggPSAoYm94LngxICsgYm94LngyKSAvIDI7XG4gIHZhciBjZW50ZXJZID0gKGJveC55MSArIGJveC55MikgLyAyO1xuICB2YXIgc2tld1ggPSBib3gudyAvIGJveC5oO1xuICB2YXIgc2tld1kgPSAxIC8gc2tld1g7XG4gIHZhciByb3RhdGVkID0gcm90YXRlUG9pbnQocG9zLngsIHBvcy55LCBjZW50ZXJYLCBjZW50ZXJZLCBhbmdsZURlZ3JlZXMpO1xuICB2YXIgc2tld2VkID0gbW92ZVBvaW50QnlCb3hBc3BlY3Qocm90YXRlZC54LCByb3RhdGVkLnksIGNlbnRlclgsIGNlbnRlclksIHNrZXdYLCBza2V3WSk7XG4gIHJldHVybiB7XG4gICAgeDogc2tld2VkLngsXG4gICAgeTogc2tld2VkLnlcbiAgfTtcbn1cblxudmFyIHdhcm5pbmdzRW5hYmxlZCA9IHRydWU7XG52YXIgd2FyblN1cHBvcnRlZCA9IGNvbnNvbGUud2FybiAhPSBudWxsO1xudmFyIHRyYWNlU3VwcG9ydGVkID0gY29uc29sZS50cmFjZSAhPSBudWxsO1xudmFyIE1BWF9JTlQkMSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgdHJ1ZWlmeSA9IGZ1bmN0aW9uIHRydWVpZnkoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBmYWxzaWZ5ID0gZnVuY3Rpb24gZmFsc2lmeSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciB6ZXJvaWZ5ID0gZnVuY3Rpb24gemVyb2lmeSgpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBlcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn07XG52YXIgd2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncyhlbmFibGVkKSB7XG4gIGlmIChlbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICB3YXJuaW5nc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdhcm5pbmdzRW5hYmxlZDtcbiAgfVxufTtcbnZhciB3YXJuID0gZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKCF3YXJuaW5ncygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3YXJuU3VwcG9ydGVkKSB7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cobXNnKTtcbiAgICBpZiAodHJhY2VTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgb2JqKTtcbn07XG5cbi8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG52YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKGFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBjbG9uZShvYmopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG52YXIgY29weUFycmF5ID0gZnVuY3Rpb24gY29weUFycmF5KGFycikge1xuICByZXR1cm4gYXJyLnNsaWNlKCk7XG59O1xudmFyIHV1aWQgPSBmdW5jdGlvbiB1dWlkKGEsIGIgLyogcGxhY2Vob2xkZXJzICovKSB7XG4gIGZvciAoXG4gIC8vIGxvb3AgOilcbiAgYiA9IGEgPSAnJztcbiAgLy8gYiAtIHJlc3VsdCAsIGEgLSBudW1lcmljIGxldGlhYmxlXG4gIGErKyA8IDM2O1xuICAvL1xuICBiICs9IGEgKiA1MSAmIDUyIC8vIGlmIFwiYVwiIGlzIG5vdCA5IG9yIDE0IG9yIDE5IG9yIDI0XG4gID9cbiAgLy8gIHJldHVybiBhIHJhbmRvbSBudW1iZXIgb3IgNFxuICAoYSBeIDE1IC8vIGlmIFwiYVwiIGlzIG5vdCAxNVxuICA/XG4gIC8vIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gMTVcbiAgOCBeIE1hdGgucmFuZG9tKCkgKiAoYSBeIDIwID8gMTYgOiA0KSAvLyB1bmxlc3MgXCJhXCIgaXMgMjAsIGluIHdoaWNoIGNhc2UgYSByYW5kb20gbnVtYmVyIGZyb20gOCB0byAxMVxuICA6IDQgLy8gIG90aGVyd2lzZSA0XG4gICkudG9TdHJpbmcoMTYpIDogJy0nIC8vICBpbiBvdGhlciBjYXNlcyAoaWYgXCJhXCIgaXMgOSwxNCwxOSwyNCkgaW5zZXJ0IFwiLVwiXG4gICk7XG4gIHJldHVybiBiO1xufTtcbnZhciBfc3RhdGljRW1wdHlPYmplY3QgPSB7fTtcbnZhciBzdGF0aWNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uIHN0YXRpY0VtcHR5T2JqZWN0KCkge1xuICByZXR1cm4gX3N0YXRpY0VtcHR5T2JqZWN0O1xufTtcbnZhciBkZWZhdWx0cyRnID0gZnVuY3Rpb24gZGVmYXVsdHMoX2RlZmF1bHRzKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX2RlZmF1bHRzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgdmFyIGZpbGxlZE9wdHMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIG9wdFZhbCA9IG9wdHMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9wdHNba2V5XTtcbiAgICAgIGZpbGxlZE9wdHNba2V5XSA9IG9wdFZhbCA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRzW2tleV0gOiBvcHRWYWw7XG4gICAgfVxuICAgIHJldHVybiBmaWxsZWRPcHRzO1xuICB9O1xufTtcbnZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyLCBlbGUsIG9uZUNvcHkpIHtcbiAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChhcnJbaV0gPT09IGVsZSkge1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG52YXIgY2xlYXJBcnJheSA9IGZ1bmN0aW9uIGNsZWFyQXJyYXkoYXJyKSB7XG4gIGFyci5zcGxpY2UoMCwgYXJyLmxlbmd0aCk7XG59O1xudmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGFyciwgb3RoZXJBcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlckFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IG90aGVyQXJyW2ldO1xuICAgIGFyci5wdXNoKGVsKTtcbiAgfVxufTtcbnZhciBnZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIHByb3BOYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCkge1xuICAgIHByb3BOYW1lID0gcHJlcGVuZENhbWVsKHByZWZpeCwgcHJvcE5hbWUpOyAvLyBlLmcuIChsYWJlbFdpZHRoLCBzb3VyY2UpID0+IHNvdXJjZUxhYmVsV2lkdGhcbiAgfVxuICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbn07XG52YXIgc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG4gIG9ialtwcm9wTmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qIGdsb2JhbCBNYXAgKi9cbnZhciBPYmplY3RNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmplY3RNYXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdE1hcCk7XG4gICAgdGhpcy5fb2JqID0ge307XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhPYmplY3RNYXAsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICAgIHRoaXMuX29ialtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgdGhpcy5fb2JqW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLl9vYmogPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIE1hcCQxID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXAgOiBPYmplY3RNYXA7XG5cbi8qIGdsb2JhbCBTZXQgKi9cblxudmFyIHVuZGVmID0gXCJ1bmRlZmluZWRcIiA7XG52YXIgT2JqZWN0U2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqZWN0U2V0KGFycmF5T3JPYmplY3RTZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0U2V0KTtcbiAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgaWYgKGFycmF5T3JPYmplY3RTZXQgIT0gbnVsbCkge1xuICAgICAgdmFyIGFycjtcbiAgICAgIGlmIChhcnJheU9yT2JqZWN0U2V0Lmluc3RhbmNlU3RyaW5nICE9IG51bGwgJiYgYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZygpID09PSB0aGlzLmluc3RhbmNlU3RyaW5nKCkpIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldC50b0FycmF5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSBhcnJheU9yT2JqZWN0U2V0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQoYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhPYmplY3RTZXQsIFt7XG4gICAga2V5OiBcImluc3RhbmNlU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG4gICAgICBpZiAob1t2YWxdICE9PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDE7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuICAgICAgaWYgKG9bdmFsXSA9PT0gMSkge1xuICAgICAgICBvW3ZhbF0gPSAwO1xuICAgICAgICB0aGlzLnNpemUtLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialt2YWxdID09PSAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX29iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhcyhrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xudmFyIFNldCQxID0gKHR5cGVvZiBTZXQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihTZXQpKSAhPT0gdW5kZWYgPyBTZXQgOiBPYmplY3RTZXQ7XG5cbi8vIHJlcHJlc2VudHMgYSBub2RlIG9yIGFuIGVkZ2VcbnZhciBFbGVtZW50ID0gZnVuY3Rpb24gRWxlbWVudChjeSwgcGFyYW1zKSB7XG4gIHZhciByZXN0b3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCAhY29yZShjeSkpIHtcbiAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdyb3VwID0gcGFyYW1zLmdyb3VwO1xuXG4gIC8vIHRyeSB0byBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSBncm91cCBpZiB1bnNwZWNpZmllZFxuICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgIGlmIChwYXJhbXMuZGF0YSAmJiBwYXJhbXMuZGF0YS5zb3VyY2UgIT0gbnVsbCAmJiBwYXJhbXMuZGF0YS50YXJnZXQgIT0gbnVsbCkge1xuICAgICAgZ3JvdXAgPSAnZWRnZXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9ICdub2Rlcyc7XG4gICAgfVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgaWYgKGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnKSB7XG4gICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cbiAgdGhpcy5sZW5ndGggPSAxO1xuICB0aGlzWzBdID0gdGhpcztcblxuICAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIHNpbmdsZTogdHJ1ZSxcbiAgICAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgZGF0YTogcGFyYW1zLmRhdGEgfHwge30sXG4gICAgLy8gZGF0YSBvYmplY3RcbiAgICBwb3NpdGlvbjogcGFyYW1zLnBvc2l0aW9uIHx8IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyAoeCwgeSkgcG9zaXRpb24gcGFpclxuICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2Ygbm9kZXMgY2FsY3VsYXRlZCBieSB0aGUgcmVuZGVyZXIgd2hlbiBzZXQgdG8gc3BlY2lhbCAnYXV0bycgdmFsdWVcbiAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgYXV0b1BhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBjb21wb3VuZEJvdW5kc0NsZWFuOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBjb21wb3VuZCBkaW1lbnNpb25zIG5lZWQgdG8gYmUgcmVjYWxjdWxhdGVkIHRoZSBuZXh0IHRpbWUgZGltZW5zaW9ucyBhcmUgcmVhZFxuICAgIGxpc3RlbmVyczogW10sXG4gICAgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIC8vIHN0cmluZzsgJ25vZGVzJyBvciAnZWRnZXMnXG4gICAgc3R5bGU6IHt9LFxuICAgIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgIHJzdHlsZToge30sXG4gICAgLy8gcHJvcGVydGllcyBmb3Igc3R5bGUgc2VudCBmcm9tIHRoZSByZW5kZXJlciB0byB0aGUgY29yZVxuICAgIHN0eWxlQ3h0czogW10sXG4gICAgLy8gYXBwbGllZCBzdHlsZSBjb250ZXh0cyBmcm9tIHRoZSBzdHlsZXJcbiAgICBzdHlsZUtleXM6IHt9LFxuICAgIC8vIHBlci1ncm91cCBrZXlzIG9mIHN0eWxlIHByb3BlcnR5IHZhbHVlc1xuICAgIHJlbW92ZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgIHNlbGVjdGVkOiBwYXJhbXMuc2VsZWN0ZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgc2VsZWN0YWJsZTogcGFyYW1zLnNlbGVjdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgIGdyYWJiZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwYXJhbXMuZ3JhYmJhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgY2FuIGJlIGdyYWJiZWRcbiAgICBwYW5uYWJsZTogcGFyYW1zLnBhbm5hYmxlID09PSB1bmRlZmluZWQgPyBncm91cCA9PT0gJ2VkZ2VzJyA/IHRydWUgOiBmYWxzZSA6IHBhcmFtcy5wYW5uYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyBwYXNzdGhyb3VnaCBwYW5uaW5nIGVuYWJsZWRcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgIGNsYXNzZXM6IG5ldyBTZXQkMSgpLFxuICAgIC8vIG1hcCAoIGNsYXNzTmFtZSA9PiB0cnVlIClcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIHJzY3JhdGNoOiB7fSxcbiAgICAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgIHNjcmF0Y2g6IHBhcmFtcy5zY3JhdGNoIHx8IHt9LFxuICAgIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgIGVkZ2VzOiBbXSxcbiAgICAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICBjaGlsZHJlbjogW10sXG4gICAgLy8gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBwYXJlbnQ6IHBhcmFtcy5wYXJlbnQgJiYgcGFyYW1zLnBhcmVudC5pc05vZGUoKSA/IHBhcmFtcy5wYXJlbnQgOiBudWxsLFxuICAgIC8vIHBhcmVudCByZWZcbiAgICB0cmF2ZXJzYWxDYWNoZToge30sXG4gICAgLy8gY2FjaGUgb2Ygb3V0cHV0IG9mIHRyYXZlcnNhbCBmdW5jdGlvbnNcbiAgICBiYWNrZ3JvdW5kaW5nOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGJhY2tncm91bmQgaW1hZ2VzIGFyZSBsb2FkaW5nXG4gICAgYmJDYWNoZTogbnVsbCxcbiAgICAvLyBjYWNoZSBvZiB0aGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICBiYkNhY2hlU2hpZnQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyBzaGlmdCBhcHBsaWVkIHRvIGNhY2hlZCBiYiB0byBiZSBhcHBsaWVkIG9uIG5leHQgZ2V0XG4gICAgYm9keUJvdW5kczogbnVsbCxcbiAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCB3L28gb3ZlcmxheVxuICAgIG92ZXJsYXlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgaW5jbHVkaW5nIG92ZXJsYXlcbiAgICBsYWJlbEJvdW5kczoge1xuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGxhYmVsc1xuICAgICAgYWxsOiBudWxsLFxuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgbWFpbjogbnVsbFxuICAgIH0sXG4gICAgYXJyb3dCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlZGdlIGFycm93c1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgJ21pZC1zb3VyY2UnOiBudWxsLFxuICAgICAgJ21pZC10YXJnZXQnOiBudWxsXG4gICAgfVxuICB9O1xuICBpZiAoX3AucG9zaXRpb24ueCA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueCA9IDA7XG4gIH1cbiAgaWYgKF9wLnBvc2l0aW9uLnkgPT0gbnVsbCkge1xuICAgIF9wLnBvc2l0aW9uLnkgPSAwO1xuICB9XG5cbiAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbikge1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIF9wLnBvc2l0aW9uID0ge1xuICAgICAgeDogKHJwb3MueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5OiAocnBvcy55IC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gIH1cbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgaWYgKGFycmF5KHBhcmFtcy5jbGFzc2VzKSkge1xuICAgIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3NlcztcbiAgfSBlbHNlIGlmIChzdHJpbmcocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgIGlmICghY2xzIHx8IGNscyA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfcC5jbGFzc2VzLmFkZChjbHMpO1xuICB9XG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICBpZiAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICB2YXIgYnlwYXNzID0gcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3M7XG4gIGlmIChieXBhc3MpIHtcbiAgICB3YXJuKCdTZXR0aW5nIGEgYHN0eWxlYCBieXBhc3MgYXQgZWxlbWVudCBjcmVhdGlvbiBzaG91bGQgYmUgZG9uZSBvbmx5IHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuICBUcnkgdG8gdXNlIHRoZSBzdHlsZXNoZWV0IGluc3RlYWQuJyk7XG4gICAgdGhpcy5zdHlsZShieXBhc3MpO1xuICB9XG59O1xuXG52YXIgZGVmaW5lU2VhcmNoID0gZnVuY3Rpb24gZGVmaW5lU2VhcmNoKHBhcmFtcykge1xuICBwYXJhbXMgPSB7XG4gICAgYmZzOiBwYXJhbXMuYmZzIHx8ICFwYXJhbXMuZGZzLFxuICAgIGRmczogcGFyYW1zLmRmcyB8fCAhcGFyYW1zLmJmc1xuICB9O1xuXG4gIC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaEZuKHJvb3RzLCBmbiwgZGlyZWN0ZWQpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAocGxhaW5PYmplY3Qocm9vdHMpICYmICFlbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSkge1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9XG4gICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFmbiQ2KGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgZm4gPSBmbiQ2KGZuKSA/IGZuIDogZnVuY3Rpb24gKCkge307XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgdiA9IHJvb3RzID0gc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgdmFyIFYgPSB7fTtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGZvdW5kO1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAvLyBlbnF1ZXVlIHZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2aSA9IHZbaV07XG4gICAgICB2YXIgdmlJZCA9IHZpLmlkKCk7XG4gICAgICBpZiAodmkuaXNOb2RlKCkpIHtcbiAgICAgICAgUS51bnNoaWZ0KHZpKTtcbiAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICBWW3ZpSWRdID0gdHJ1ZTtcbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHZpKTtcbiAgICAgICAgfVxuICAgICAgICBpZDJkZXB0aFt2aUlkXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgdiA9IHBhcmFtcy5iZnMgPyBRLnNoaWZ0KCkgOiBRLnBvcCgpO1xuICAgICAgICB2YXIgdklkID0gdi5pZCgpO1xuICAgICAgICBpZiAocGFyYW1zLmRmcykge1xuICAgICAgICAgIGlmIChWW3ZJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBWW3ZJZF0gPSB0cnVlO1xuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbdklkXTtcbiAgICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbdklkXTtcbiAgICAgICAgdmFyIHNyYyA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS5zb3VyY2UoKSA6IG51bGw7XG4gICAgICAgIHZhciB0Z3QgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2UudGFyZ2V0KCkgOiBudWxsO1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogdi5zYW1lKHNyYykgPyB0Z3RbMF0gOiBzcmNbMF07XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIHJldCA9IGZuKHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3VuZCA9IHY7XG4gICAgICAgICAgcmV0dXJuIDE7IC8vIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gMTsgLy8gYnJlYWtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gKCFkaXJlY3RlZCB8fCBlLnNvdXJjZSgpLnNhbWUodikpICYmIGVkZ2VzLmhhcyhlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHZ3RWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tfaTJdO1xuICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuICFuLnNhbWUodikgJiYgbm9kZXMuaGFzKG4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciB3SWQgPSB3LmlkKCk7XG4gICAgICAgICAgaWYgKHcubGVuZ3RoICE9PSAwICYmICFWW3dJZF0pIHtcbiAgICAgICAgICAgIHcgPSB3WzBdO1xuICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5iZnMpIHtcbiAgICAgICAgICAgICAgVlt3SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3RlZEJ5W3dJZF0gPSBlO1xuICAgICAgICAgICAgaWQyZGVwdGhbd0lkXSA9IGlkMmRlcHRoW3ZJZF0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9yZXQ7XG4gICAgd2hpbGUgKFEubGVuZ3RoICE9PSAwKSB7XG4gICAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICAgIGlmIChfcmV0ID09PSAxKSBicmVhaztcbiAgICB9XG4gICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tfaV07XG4gICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5W25vZGUuaWQoKV07XG4gICAgICBpZiAoZWRnZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oY29ubmVjdGVkRWxlcyksXG4gICAgICBmb3VuZDogY3kuY29sbGVjdGlvbihmb3VuZClcbiAgICB9O1xuICB9O1xufTtcblxuLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG52YXIgZWxlc2ZuJHYgPSB7XG4gIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICBiZnM6IHRydWVcbiAgfSksXG4gIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgZGZzOiB0cnVlXG4gIH0pXG59O1xuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcbmVsZXNmbiR2LmJmcyA9IGVsZXNmbiR2LmJyZWFkdGhGaXJzdFNlYXJjaDtcbmVsZXNmbiR2LmRmcyA9IGVsZXNmbiR2LmRlcHRoRmlyc3RTZWFyY2g7XG5cbnZhciBoZWFwJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgaGVhcCQxID0gaGVhcCQyLmV4cG9ydHM7XG5cbnZhciBoYXNSZXF1aXJlZEhlYXAkMTtcblxuZnVuY3Rpb24gcmVxdWlyZUhlYXAkMSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhlYXAkMSkgcmV0dXJuIGhlYXAkMi5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEhlYXAkMSA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0Ly8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuXHRcdChmdW5jdGlvbigpIHtcblx0XHQgIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuXHRcdCAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG5cdFx0ICAvKlxuXHRcdCAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcblx0XHQgICAqL1xuXG5cdFx0ICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdCAgICBpZiAoeCA8IHkpIHtcblx0XHQgICAgICByZXR1cm4gLTE7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKHggPiB5KSB7XG5cdFx0ICAgICAgcmV0dXJuIDE7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIDA7XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuXHRcdCAgXG5cdFx0ICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG5cdFx0ICBcblx0XHQgIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2Vcblx0XHQgIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG5cdFx0ICAgKi9cblxuXHRcdCAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcblx0XHQgICAgdmFyIG1pZDtcblx0XHQgICAgaWYgKGxvID09IG51bGwpIHtcblx0XHQgICAgICBsbyA9IDA7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAobG8gPCAwKSB7XG5cdFx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChoaSA9PSBudWxsKSB7XG5cdFx0ICAgICAgaGkgPSBhLmxlbmd0aDtcblx0XHQgICAgfVxuXHRcdCAgICB3aGlsZSAobG8gPCBoaSkge1xuXHRcdCAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuXHRcdCAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcblx0XHQgICAgICAgIGhpID0gbWlkO1xuXHRcdCAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICBsbyA9IG1pZCArIDE7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG5cdFx0ICAgKi9cblxuXHRcdCAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgYXJyYXkucHVzaChpdGVtKTtcblx0XHQgICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cblx0XHQgICAqL1xuXG5cdFx0ICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuXHRcdCAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG5cdFx0ICAgIGlmIChhcnJheS5sZW5ndGgpIHtcblx0XHQgICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG5cdFx0ICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuXHRcdCAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIHJldHVybml0ZW07XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG5cdFx0ICBcblx0XHQgIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuXHRcdCAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG5cdFx0ICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG5cdFx0ICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuXHRcdCAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuXHRcdCAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuXHRcdCAgICovXG5cblx0XHQgIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuXHRcdCAgICB2YXIgcmV0dXJuaXRlbTtcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG5cdFx0ICAgIGFycmF5WzBdID0gaXRlbTtcblx0XHQgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcblx0XHQgICAgcmV0dXJuIHJldHVybml0ZW07XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG5cdFx0ICAgKi9cblxuXHRcdCAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG5cdFx0ICAgIHZhciBfcmVmO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcblx0XHQgICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcblx0XHQgICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBpdGVtO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cblx0XHQgICAqL1xuXG5cdFx0ICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuXHRcdCAgICB2YXIgaSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIF9yZXN1bHRzMSA9IFtdO1xuXHRcdCAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG5cdFx0ICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcblx0XHQgICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuXHRcdCAgICBfcmVzdWx0cyA9IFtdO1xuXHRcdCAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG5cdFx0ICAgICAgaSA9IF9yZWYxW19pXTtcblx0XHQgICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBfcmVzdWx0cztcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG5cdFx0ICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cblx0XHQgICAqL1xuXG5cdFx0ICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuXHRcdCAgICB2YXIgcG9zO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG5cdFx0ICAgIGlmIChwb3MgPT09IC0xKSB7XG5cdFx0ICAgICAgcmV0dXJuO1xuXHRcdCAgICB9XG5cdFx0ICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuXHRcdCAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cblx0XHQgICAqL1xuXG5cdFx0ICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcblx0XHQgICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG5cdFx0ICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuXHRcdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgIH1cblx0XHQgICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG5cdFx0ICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcblx0XHQgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG5cdFx0ICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuXHRcdCAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cblx0XHQgICAqL1xuXG5cdFx0ICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG5cdFx0ICAgIHZhciBlbGVtLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcblx0XHQgICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG5cdFx0ICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG5cdFx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHRcdCAgICAgIH1cblx0XHQgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuXHRcdCAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcblx0XHQgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcblx0XHQgICAgICAgIGVsZW0gPSBfcmVmW19pXTtcblx0XHQgICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcblx0XHQgICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcblx0XHQgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuXHRcdCAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH1cblx0XHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHRcdCAgICB9XG5cdFx0ICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG5cdFx0ICAgIF9yZXN1bHRzID0gW107XG5cdFx0ICAgIGZvciAoX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuXHRcdCAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIF9yZXN1bHRzO1xuXHRcdCAgfTtcblxuXHRcdCAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuXHRcdCAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG5cdFx0ICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuXHRcdCAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuXHRcdCAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG5cdFx0ICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuXHRcdCAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcblx0XHQgICAgICAgIHBvcyA9IHBhcmVudHBvcztcblx0XHQgICAgICAgIGNvbnRpbnVlO1xuXHRcdCAgICAgIH1cblx0XHQgICAgICBicmVhaztcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG5cdFx0ICB9O1xuXG5cdFx0ICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG5cdFx0ICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuXHRcdCAgICBzdGFydHBvcyA9IHBvcztcblx0XHQgICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG5cdFx0ICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG5cdFx0ICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuXHRcdCAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuXHRcdCAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuXHRcdCAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcblx0XHQgICAgICB9XG5cdFx0ICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcblx0XHQgICAgICBwb3MgPSBjaGlsZHBvcztcblx0XHQgICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuXHRcdCAgICB9XG5cdFx0ICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuXHRcdCAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuXHRcdCAgfTtcblxuXHRcdCAgSGVhcCA9IChmdW5jdGlvbigpIHtcblx0XHQgICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cblx0XHQgICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG5cdFx0ICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG5cdFx0ICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG5cdFx0ICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cblx0XHQgICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuXHRcdCAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cblx0XHQgICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cblx0XHQgICAgZnVuY3Rpb24gSGVhcChjbXApIHtcblx0XHQgICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcblx0XHQgICAgICB0aGlzLm5vZGVzID0gW107XG5cdFx0ICAgIH1cblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuXHRcdCAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcblx0XHQgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuXHRcdCAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcblx0XHQgICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcblx0XHQgICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICB2YXIgaGVhcDtcblx0XHQgICAgICBoZWFwID0gbmV3IEhlYXAoKTtcblx0XHQgICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcblx0XHQgICAgICByZXR1cm4gaGVhcDtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cblx0XHQgICAgcmV0dXJuIEhlYXA7XG5cblx0XHQgIH0pKCk7XG5cblx0XHQgIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdFx0ICAgIHtcblx0XHQgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdFx0ICAgIH1cblx0XHQgIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdCAgICByZXR1cm4gSGVhcDtcblx0XHQgIH0pO1xuXG5cdFx0fSkuY2FsbChoZWFwJDEpOyBcblx0fSAoaGVhcCQyKSk7XG5cdHJldHVybiBoZWFwJDIuZXhwb3J0cztcbn1cblxudmFyIGhlYXA7XG52YXIgaGFzUmVxdWlyZWRIZWFwO1xuXG5mdW5jdGlvbiByZXF1aXJlSGVhcCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEhlYXApIHJldHVybiBoZWFwO1xuXHRoYXNSZXF1aXJlZEhlYXAgPSAxO1xuXHRoZWFwID0gcmVxdWlyZUhlYXAkMSgpO1xuXHRyZXR1cm4gaGVhcDtcbn1cblxudmFyIGhlYXBFeHBvcnRzID0gcmVxdWlyZUhlYXAoKTtcbnZhciBIZWFwID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGhlYXBFeHBvcnRzKTtcblxudmFyIGRpamtzdHJhRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiR1ID0ge1xuICBkaWprc3RyYTogZnVuY3Rpb24gZGlqa3N0cmEob3B0aW9ucykge1xuICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgd2VpZ2h0OiBhcmdzWzFdLFxuICAgICAgICBkaXJlY3RlZDogYXJnc1syXVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9kaWprc3RyYURlZmF1bHRzID0gZGlqa3N0cmFEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHJvb3QgPSBfZGlqa3N0cmFEZWZhdWx0cy5yb290LFxuICAgICAgd2VpZ2h0ID0gX2RpamtzdHJhRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQgPSBfZGlqa3N0cmFEZWZhdWx0cy5kaXJlY3RlZDtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBzb3VyY2UgPSBzdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgdmFyIGRpc3QgPSB7fTtcbiAgICB2YXIgcHJldiA9IHt9O1xuICAgIHZhciBrbm93bkRpc3QgPSB7fTtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChub2RlKSB7XG4gICAgICByZXR1cm4gZGlzdFtub2RlLmlkKCldO1xuICAgIH07XG4gICAgdmFyIHNldERpc3QgPSBmdW5jdGlvbiBzZXREaXN0KG5vZGUsIGQpIHtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IGQ7XG4gICAgICBRLnVwZGF0ZUl0ZW0obm9kZSk7XG4gICAgfTtcbiAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbiBkaXN0QmV0d2Vlbih1LCB2KSB7XG4gICAgICB2YXIgdXZzID0gKGRpcmVjdGVkID8gdS5lZGdlc1RvKHYpIDogdS5lZGdlc1dpdGgodikpLmludGVyc2VjdChlZGdlcyk7XG4gICAgICB2YXIgc21hbGxlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgdmFyIHNtYWxsZXN0RWRnZTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1dnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gdXZzW19pXTtcbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgICAgaWYgKF93ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UpIHtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gX3dlaWdodDtcbiAgICAgICAgICBzbWFsbGVzdEVkZ2UgPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgIGRpc3Q6IHNtYWxsZXN0RGlzdGFuY2VcbiAgICAgIH07XG4gICAgfTtcbiAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcbiAgICAgIGlmIChzbWFsbGV0c0Rpc3QgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW19pMl07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcbiAgICAgICAgaWYgKGFsdCA8IGdldERpc3QodikpIHtcbiAgICAgICAgICBzZXREaXN0KHYsIGFsdCk7XG4gICAgICAgICAgcHJldlt2aWRdID0ge1xuICAgICAgICAgICAgbm9kZTogdSxcbiAgICAgICAgICAgIGVkZ2U6IHZEaXN0LmVkZ2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuICAgIH0gLy8gd2hpbGVcblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgfSxcbiAgICAgIHBhdGhUbzogZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBTLnVuc2hpZnQodGFyZ2V0KTtcbiAgICAgICAgICB3aGlsZSAocHJldlt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHByZXZbdWlkXTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLmVkZ2UpO1xuICAgICAgICAgICAgUy51bnNoaWZ0KHAubm9kZSk7XG4gICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgICAgdWlkID0gdS5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihTKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJHQgPSB7XG4gIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAga3J1c2thbDogZnVuY3Rpb24ga3J1c2thbCh3ZWlnaHRGbikge1xuICAgIHdlaWdodEZuID0gd2VpZ2h0Rm4gfHwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGZvcmVzdCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIEEgPSBub2RlczsgLy8gYXNzdW1lcyBieUdyb3VwKCkgY3JlYXRlcyBuZXcgY29sbGVjdGlvbnMgdGhhdCBjYW4gYmUgc2FmZWx5IG11dGF0ZWRcblxuICAgIHZhciBmaW5kU2V0SW5kZXggPSBmdW5jdGlvbiBmaW5kU2V0SW5kZXgoZWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFtpXTtcbiAgICAgICAgaWYgKGVsZXMuaGFzKGVsZSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGFydCB3aXRoIG9uZSBmb3Jlc3QgcGVyIG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZvcmVzdFtpXSA9IHRoaXMuc3Bhd24obm9kZXNbaV0pO1xuICAgIH1cbiAgICB2YXIgUyA9IGVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB3ZWlnaHRGbihhKSAtIHdlaWdodEZuKGIpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBTLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGVkZ2UgPSBTW19pXTtcbiAgICAgIHZhciB1ID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB2ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICAgIHZhciBzZXRVSW5kZXggPSBmaW5kU2V0SW5kZXgodSk7XG4gICAgICB2YXIgc2V0VkluZGV4ID0gZmluZFNldEluZGV4KHYpO1xuICAgICAgdmFyIHNldFUgPSBmb3Jlc3Rbc2V0VUluZGV4XTtcbiAgICAgIHZhciBzZXRWID0gZm9yZXN0W3NldFZJbmRleF07XG4gICAgICBpZiAoc2V0VUluZGV4ICE9PSBzZXRWSW5kZXgpIHtcbiAgICAgICAgQS5tZXJnZShlZGdlKTtcblxuICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgc2V0VS5tZXJnZShzZXRWKTtcbiAgICAgICAgZm9yZXN0LnNwbGljZShzZXRWSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQTtcbiAgfVxufTtcblxudmFyIGFTdGFyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogbnVsbCxcbiAgZ29hbDogbnVsbCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBoZXVyaXN0aWM6IGZ1bmN0aW9uIGhldXJpc3RpYyhlZGdlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJHMgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBhU3RhcjogZnVuY3Rpb24gYVN0YXIob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgX2FTdGFyRGVmYXVsdHMgPSBhU3RhckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgcm9vdCA9IF9hU3RhckRlZmF1bHRzLnJvb3QsXG4gICAgICBnb2FsID0gX2FTdGFyRGVmYXVsdHMuZ29hbCxcbiAgICAgIGhldXJpc3RpYyA9IF9hU3RhckRlZmF1bHRzLmhldXJpc3RpYyxcbiAgICAgIGRpcmVjdGVkID0gX2FTdGFyRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICB3ZWlnaHQgPSBfYVN0YXJEZWZhdWx0cy53ZWlnaHQ7XG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG4gICAgZ29hbCA9IGN5LmNvbGxlY3Rpb24oZ29hbClbMF07XG4gICAgdmFyIHNpZCA9IHJvb3QuaWQoKTtcbiAgICB2YXIgdGlkID0gZ29hbC5pZCgpO1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG4gICAgdmFyIGNsb3NlZFNldElkcyA9IHt9O1xuICAgIHZhciBvcGVuU2V0ID0gbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmU2NvcmVbYS5pZCgpXSAtIGZTY29yZVtiLmlkKCldO1xuICAgIH0pO1xuICAgIHZhciBvcGVuU2V0SWRzID0gbmV3IFNldCQxKCk7XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuICAgIHZhciBhZGRUb09wZW5TZXQgPSBmdW5jdGlvbiBhZGRUb09wZW5TZXQoZWxlLCBpZCkge1xuICAgICAgb3BlblNldC5wdXNoKGVsZSk7XG4gICAgICBvcGVuU2V0SWRzLmFkZChpZCk7XG4gICAgfTtcbiAgICB2YXIgY01pbiwgY01pbklkO1xuICAgIHZhciBwb3BGcm9tT3BlblNldCA9IGZ1bmN0aW9uIHBvcEZyb21PcGVuU2V0KCkge1xuICAgICAgY01pbiA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICBvcGVuU2V0SWRzW1wiZGVsZXRlXCJdKGNNaW5JZCk7XG4gICAgfTtcbiAgICB2YXIgaXNJbk9wZW5TZXQgPSBmdW5jdGlvbiBpc0luT3BlblNldChpZCkge1xuICAgICAgcmV0dXJuIG9wZW5TZXRJZHMuaGFzKGlkKTtcbiAgICB9O1xuICAgIGFkZFRvT3BlblNldChyb290LCBzaWQpO1xuICAgIGdTY29yZVtzaWRdID0gMDtcbiAgICBmU2NvcmVbc2lkXSA9IGhldXJpc3RpYyhyb290KTtcblxuICAgIC8vIENvdW50ZXJcbiAgICB2YXIgc3RlcHMgPSAwO1xuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgd2hpbGUgKG9wZW5TZXQuc2l6ZSgpID4gMCkge1xuICAgICAgcG9wRnJvbU9wZW5TZXQoKTtcbiAgICAgIHN0ZXBzKys7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgICBpZiAoY01pbklkID09PSB0aWQpIHtcbiAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgdmFyIHBhdGhOb2RlID0gZ29hbDtcbiAgICAgICAgdmFyIHBhdGhOb2RlSWQgPSB0aWQ7XG4gICAgICAgIHZhciBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoTm9kZSk7XG4gICAgICAgICAgaWYgKHBhdGhFZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoRWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhOb2RlID0gY2FtZUZyb21bcGF0aE5vZGVJZF07XG4gICAgICAgICAgaWYgKHBhdGhOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoTm9kZUlkID0gcGF0aE5vZGUuaWQoKTtcbiAgICAgICAgICBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICAgIGRpc3RhbmNlOiBnU2NvcmVbY01pbklkXSxcbiAgICAgICAgICBwYXRoOiB0aGlzLnNwYXduKHBhdGgpLFxuICAgICAgICAgIHN0ZXBzOiBzdGVwc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcbiAgICAgIGNsb3NlZFNldElkc1tjTWluSWRdID0gdHJ1ZTtcblxuICAgICAgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcblxuICAgICAgICAvLyBlZGdlIG11c3QgYmUgaW4gc2V0IG9mIGNhbGxpbmcgZWxlc1xuICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZChlLmlkKCkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjTWluIG11c3QgYmUgdGhlIHNvdXJjZSBvZiBlZGdlIGlmIGRpcmVjdGVkXG4gICAgICAgIGlmIChkaXJlY3RlZCAmJiBlLmRhdGEoJ3NvdXJjZScpICE9PSBjTWluSWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd1NyYyA9IGUuc291cmNlKCk7XG4gICAgICAgIHZhciB3VGd0ID0gZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIHcgPSB3U3JjLmlkKCkgIT09IGNNaW5JZCA/IHdTcmMgOiB3VGd0O1xuICAgICAgICB2YXIgd2lkID0gdy5pZCgpO1xuXG4gICAgICAgIC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG4gICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKHdpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKGNsb3NlZFNldElkc1t3aWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluSWRdICsgd2VpZ2h0KGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgLy8gT1JcbiAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuXG4gICAgICAgIC8vIHcgbm90IGluIG9wZW5TZXRcbiAgICAgICAgaWYgKCFpc0luT3BlblNldCh3aWQpKSB7XG4gICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgYWRkVG9PcGVuU2V0KHcsIHdpZCk7XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgICAgY2FtZUZyb21FZGdlW3dpZF0gPSBlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG4gICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbd2lkXSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuXG4gICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBzdGVwczogc3RlcHNcbiAgICB9O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJHIgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBmbG95ZFdhcnNoYWxsOiBmdW5jdGlvbiBmbG95ZFdhcnNoYWxsKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIF9mbG95ZFdhcnNoYWxsRGVmYXVsdCA9IGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHdlaWdodCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC5kaXJlY3RlZDtcbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICB2YXIgTiA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgTnNxID0gTiAqIE47XG4gICAgdmFyIGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgIH07XG4gICAgdmFyIGF0SW5kZXggPSBmdW5jdGlvbiBhdEluZGV4KGkpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgZGlzdCA9IG5ldyBBcnJheShOc3EpO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgTnNxOyBuKyspIHtcbiAgICAgIHZhciBqID0gbiAlIE47XG4gICAgICB2YXIgaSA9IChuIC0gaikgLyBOO1xuICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgZGlzdFtuXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXN0W25dID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgdmFyIG5leHQgPSBuZXcgQXJyYXkoTnNxKTtcbiAgICB2YXIgZWRnZU5leHQgPSBuZXcgQXJyYXkoTnNxKTtcblxuICAgIC8vIFByb2Nlc3MgZWRnZXNcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGV4Y2x1ZGUgbG9vcHNcblxuICAgICAgdmFyIHMgPSBpbmRleE9mKHNyYyk7XG4gICAgICB2YXIgdCA9IGluZGV4T2YodGd0KTtcbiAgICAgIHZhciBzdCA9IHMgKiBOICsgdDsgLy8gc291cmNlIHRvIHRhcmdldCBpbmRleFxuICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgaWYgKGRpc3Rbc3RdID4gX3dlaWdodCkge1xuICAgICAgICBkaXN0W3N0XSA9IF93ZWlnaHQ7XG4gICAgICAgIG5leHRbc3RdID0gdDtcbiAgICAgICAgZWRnZU5leHRbc3RdID0gZWRnZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VcbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIHRzID0gdCAqIE4gKyBzOyAvLyB0YXJnZXQgdG8gc291cmNlIGluZGV4XG5cbiAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiBkaXN0W3RzXSA+IF93ZWlnaHQpIHtcbiAgICAgICAgICBkaXN0W3RzXSA9IF93ZWlnaHQ7XG4gICAgICAgICAgbmV4dFt0c10gPSBzO1xuICAgICAgICAgIGVkZ2VOZXh0W3RzXSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IE47IGsrKykge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgX2kyKyspIHtcbiAgICAgICAgdmFyIGlrID0gX2kyICogTiArIGs7XG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBOOyBfaisrKSB7XG4gICAgICAgICAgdmFyIGlqID0gX2kyICogTiArIF9qO1xuICAgICAgICAgIHZhciBraiA9IGsgKiBOICsgX2o7XG4gICAgICAgICAgaWYgKGRpc3RbaWtdICsgZGlzdFtral0gPCBkaXN0W2lqXSkge1xuICAgICAgICAgICAgZGlzdFtpal0gPSBkaXN0W2lrXSArIGRpc3Rba2pdO1xuICAgICAgICAgICAgbmV4dFtpal0gPSBuZXh0W2lrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdldEFyZ0VsZSA9IGZ1bmN0aW9uIGdldEFyZ0VsZShlbGUpIHtcbiAgICAgIHJldHVybiAoc3RyaW5nKGVsZSkgPyBjeS5maWx0ZXIoZWxlKSA6IGVsZSlbMF07XG4gICAgfTtcbiAgICB2YXIgaW5kZXhPZkFyZ0VsZSA9IGZ1bmN0aW9uIGluZGV4T2ZBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZihnZXRBcmdFbGUoZWxlKSk7XG4gICAgfTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uIGRpc3RhbmNlKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBpID0gaW5kZXhPZkFyZ0VsZShmcm9tKTtcbiAgICAgICAgdmFyIGogPSBpbmRleE9mQXJnRWxlKHRvKTtcbiAgICAgICAgcmV0dXJuIGRpc3RbaSAqIE4gKyBqXTtcbiAgICAgIH0sXG4gICAgICBwYXRoOiBmdW5jdGlvbiBwYXRoKGZyb20sIHRvKSB7XG4gICAgICAgIHZhciBpID0gaW5kZXhPZkFyZ0VsZShmcm9tKTtcbiAgICAgICAgdmFyIGogPSBpbmRleE9mQXJnRWxlKHRvKTtcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gYXRJbmRleChpKTtcbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICByZXR1cm4gZnJvbU5vZGUuY29sbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0W2kgKiBOICsgal0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIHZhciBwcmV2ID0gaTtcbiAgICAgICAgdmFyIGVkZ2U7XG4gICAgICAgIHBhdGgubWVyZ2UoZnJvbU5vZGUpO1xuICAgICAgICB3aGlsZSAoaSAhPT0gaikge1xuICAgICAgICAgIHByZXYgPSBpO1xuICAgICAgICAgIGkgPSBuZXh0W2kgKiBOICsgal07XG4gICAgICAgICAgZWRnZSA9IGVkZ2VOZXh0W3ByZXYgKiBOICsgaV07XG4gICAgICAgICAgcGF0aC5tZXJnZShlZGdlKTtcbiAgICAgICAgICBwYXRoLm1lcmdlKGF0SW5kZXgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG59OyAvLyBlbGVzZm5cblxudmFyIGJlbGxtYW5Gb3JkRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIHJvb3Q6IG51bGxcbn0pO1xudmFyIGVsZXNmbiRxID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYmVsbG1hbkZvcmQ6IGZ1bmN0aW9uIGJlbGxtYW5Gb3JkKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYmVsbG1hbkZvcmREZWZhdWx0cyA9IGJlbGxtYW5Gb3JkRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICB3ZWlnaHQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgcm9vdCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLnJvb3Q7XG4gICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcyxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcztcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZm9NYXAgPSBuZXcgTWFwJDEoKTtcbiAgICB2YXIgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IGZhbHNlO1xuICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlcyA9IFtdO1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdOyAvLyBpbiBjYXNlIHNlbGVjdG9yIHBhc3NlZFxuXG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIGdldEluZm8gPSBmdW5jdGlvbiBnZXRJbmZvKG5vZGUpIHtcbiAgICAgIHZhciBvYmogPSBpbmZvTWFwLmdldChub2RlLmlkKCkpO1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICAgIGluZm9NYXAuc2V0KG5vZGUuaWQoKSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB2YXIgZ2V0Tm9kZUZyb21UbyA9IGZ1bmN0aW9uIGdldE5vZGVGcm9tVG8odG8pIHtcbiAgICAgIHJldHVybiAoc3RyaW5nKHRvKSA/IGN5LiQodG8pIDogdG8pWzBdO1xuICAgIH07XG4gICAgdmFyIGRpc3RhbmNlVG8gPSBmdW5jdGlvbiBkaXN0YW5jZVRvKHRvKSB7XG4gICAgICByZXR1cm4gZ2V0SW5mbyhnZXROb2RlRnJvbVRvKHRvKSkuZGlzdDtcbiAgICB9O1xuICAgIHZhciBwYXRoVG8gPSBmdW5jdGlvbiBwYXRoVG8odG8pIHtcbiAgICAgIHZhciB0aGlzU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJvb3Q7XG4gICAgICB2YXIgZW5kID0gZ2V0Tm9kZUZyb21Ubyh0byk7XG4gICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgdmFyIG5vZGUgPSBlbmQ7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc3Bhd24oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKG5vZGUpLFxuICAgICAgICAgIGVkZ2UgPSBfZ2V0SW5mby5lZGdlLFxuICAgICAgICAgIHByZWQgPSBfZ2V0SW5mby5wcmVkO1xuICAgICAgICBwYXRoLnVuc2hpZnQobm9kZVswXSk7XG4gICAgICAgIGlmIChub2RlLnNhbWUodGhpc1N0YXJ0KSAmJiBwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRnZSAhPSBudWxsKSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KGVkZ2UpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBwcmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZXMuc3Bhd24ocGF0aCk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemF0aW9ucyB7IGRpc3QsIHByZWQsIGVkZ2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBpbmZvID0gZ2V0SW5mbyhub2RlKTtcbiAgICAgIGlmIChub2RlLnNhbWUocm9vdCkpIHtcbiAgICAgICAgaW5mby5kaXN0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8uZGlzdCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaW5mby5wcmVkID0gbnVsbDtcbiAgICAgIGluZm8uZWRnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gRWRnZXMgcmVsYXhhdGlvblxuICAgIHZhciByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcbiAgICB2YXIgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChub2RlMSwgbm9kZTIsIGVkZ2UsIGluZm8xLCBpbmZvMiwgd2VpZ2h0KSB7XG4gICAgICB2YXIgZGlzdCA9IGluZm8xLmRpc3QgKyB3ZWlnaHQ7XG4gICAgICBpZiAoZGlzdCA8IGluZm8yLmRpc3QgJiYgIWVkZ2Uuc2FtZShpbmZvMS5lZGdlKSkge1xuICAgICAgICBpbmZvMi5kaXN0ID0gZGlzdDtcbiAgICAgICAgaW5mbzIucHJlZCA9IG5vZGUxO1xuICAgICAgICBpbmZvMi5lZGdlID0gZWRnZTtcbiAgICAgICAgcmVwbGFjZWRFZGdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG51bUVkZ2VzOyBlKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgICB2YXIgc3JjSW5mbyA9IGdldEluZm8oc3JjKTtcbiAgICAgICAgdmFyIHRndEluZm8gPSBnZXRJbmZvKHRndCk7XG4gICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHNyYywgdGd0LCBlZGdlLCBzcmNJbmZvLCB0Z3RJbmZvLCBfd2VpZ2h0KTtcblxuICAgICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQodGd0LCBzcmMsIGVkZ2UsIHRndEluZm8sIHNyY0luZm8sIF93ZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlcGxhY2VkRWRnZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcGxhY2VkRWRnZSkge1xuICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIHdlaWdodCBjeWNsZXNcbiAgICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzID0gW107XG4gICAgICBmb3IgKHZhciBfZSA9IDA7IF9lIDwgbnVtRWRnZXM7IF9lKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2VdO1xuICAgICAgICB2YXIgX3NyYyA9IF9lZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgX3RndCA9IF9lZGdlLnRhcmdldCgpO1xuICAgICAgICB2YXIgX3dlaWdodDIgPSB3ZWlnaHRGbihfZWRnZSk7XG4gICAgICAgIHZhciBzcmNEaXN0ID0gZ2V0SW5mbyhfc3JjKS5kaXN0O1xuICAgICAgICB2YXIgdGd0RGlzdCA9IGdldEluZm8oX3RndCkuZGlzdDtcbiAgICAgICAgaWYgKHNyY0Rpc3QgKyBfd2VpZ2h0MiA8IHRndERpc3QgfHwgIWRpcmVjdGVkICYmIHRndERpc3QgKyBfd2VpZ2h0MiA8IHNyY0Rpc3QpIHtcbiAgICAgICAgICBpZiAoIWhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUpIHtcbiAgICAgICAgICAgIHdhcm4oJ0dyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlIGZvciBCZWxsbWFuLUZvcmQnKTtcbiAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5maW5kTmVnYXRpdmVXZWlnaHRDeWNsZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgbmVnYXRpdmVOb2RlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNyY0Rpc3QgKyBfd2VpZ2h0MiA8IHRndERpc3QpIHtcbiAgICAgICAgICAgICAgbmVnYXRpdmVOb2Rlcy5wdXNoKF9zcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiB0Z3REaXN0ICsgX3dlaWdodDIgPCBzcmNEaXN0KSB7XG4gICAgICAgICAgICAgIG5lZ2F0aXZlTm9kZXMucHVzaChfdGd0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1OZWdhdGl2ZU5vZGVzID0gbmVnYXRpdmVOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG51bU5lZ2F0aXZlTm9kZXM7IG4rKykge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBuZWdhdGl2ZU5vZGVzW25dO1xuICAgICAgICAgICAgICB2YXIgY3ljbGUgPSBbc3RhcnRdO1xuICAgICAgICAgICAgICBjeWNsZS5wdXNoKGdldEluZm8oc3RhcnQpLmVkZ2UpO1xuICAgICAgICAgICAgICB2YXIgX25vZGUgPSBnZXRJbmZvKHN0YXJ0KS5wcmVkO1xuICAgICAgICAgICAgICB3aGlsZSAoY3ljbGUuaW5kZXhPZihfbm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY3ljbGUucHVzaChfbm9kZSk7XG4gICAgICAgICAgICAgICAgY3ljbGUucHVzaChnZXRJbmZvKF9ub2RlKS5lZGdlKTtcbiAgICAgICAgICAgICAgICBfbm9kZSA9IGdldEluZm8oX25vZGUpLnByZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3ljbGUgPSBjeWNsZS5zbGljZShjeWNsZS5pbmRleE9mKF9ub2RlKSk7XG4gICAgICAgICAgICAgIHZhciBzbWFsbGVzdElkID0gY3ljbGVbMF0uaWQoKTtcbiAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMjsgYyA8IGN5Y2xlLmxlbmd0aDsgYyArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlW2NdLmlkKCkgPCBzbWFsbGVzdElkKSB7XG4gICAgICAgICAgICAgICAgICBzbWFsbGVzdElkID0gY3ljbGVbY10uaWQoKTtcbiAgICAgICAgICAgICAgICAgIHNtYWxsZXN0SW5kZXggPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjeWNsZSA9IGN5Y2xlLnNsaWNlKHNtYWxsZXN0SW5kZXgpLmNvbmNhdChjeWNsZS5zbGljZSgwLCBzbWFsbGVzdEluZGV4KSk7XG4gICAgICAgICAgICAgIGN5Y2xlLnB1c2goY3ljbGVbMF0pO1xuICAgICAgICAgICAgICB2YXIgY3ljbGVJZCA9IGN5Y2xlLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuaWQoKTtcbiAgICAgICAgICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgIGlmIChuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzLmluZGV4T2YoY3ljbGVJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXMucHVzaChlbGVzLnNwYXduKGN5Y2xlKSk7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcy5wdXNoKGN5Y2xlSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGlzdGFuY2VUbzogZGlzdGFuY2VUbyxcbiAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSxcbiAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzOiBuZWdhdGl2ZVdlaWdodEN5Y2xlc1xuICAgIH07XG4gIH0gLy8gYmVsbG1hbkZvcmRcbn07IC8vIGVsZXNmblxuXG52YXIgc3FydDIgPSBNYXRoLnNxcnQoMik7XG5cbi8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4vLyBVcGRhdGVzIHRoZSByZW1haW5pbmcgZWRnZSBsaXN0c1xuLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICBpZiAocmVtYWluaW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3IoXCJLYXJnZXItU3RlaW4gbXVzdCBiZSBydW4gb24gYSBjb25uZWN0ZWQgKHN1YilncmFwaFwiKTtcbiAgfVxuICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICB2YXIgc291cmNlSW4gPSBlZGdlSW5mb1sxXTtcbiAgdmFyIHRhcmdldEluID0gZWRnZUluZm9bMl07XG4gIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFt0YXJnZXRJbl07XG4gIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzOyAvLyByZS11c2UgYXJyYXlcblxuICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuICBmb3IgKHZhciBpID0gbmV3RWRnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzW2ldO1xuICAgIHZhciBzcmMgPSBlZGdlWzFdO1xuICAgIHZhciB0Z3QgPSBlZGdlWzJdO1xuICAgIGlmIChub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24yIHx8IG5vZGVNYXBbc3JjXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW3RndF0gPT09IHBhcnRpdGlvbjEpIHtcbiAgICAgIG5ld0VkZ2VzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGwgZWRnZXMgcG9pbnRpbmcgdG8gcGFydGl0aW9uMiBzaG91bGQgbm93IHBvaW50IHRvIHBhcnRpdGlvbjFcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5ld0VkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfZWRnZSA9IG5ld0VkZ2VzW19pXTtcbiAgICBpZiAoX2VkZ2VbMV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgIC8vIENoZWNrIHNvdXJjZVxuICAgICAgbmV3RWRnZXNbX2ldID0gX2VkZ2Uuc2xpY2UoKTsgLy8gY29weVxuICAgICAgbmV3RWRnZXNbX2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICB9IGVsc2UgaWYgKF9lZGdlWzJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAvLyBDaGVjayB0YXJnZXRcbiAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcbiAgICAgIG5ld0VkZ2VzW19pXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZU1hcC5sZW5ndGg7IF9pMisrKSB7XG4gICAgaWYgKG5vZGVNYXBbX2kyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgbm9kZU1hcFtfaTJdID0gcGFydGl0aW9uMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0VkZ2VzO1xufTtcblxuLy8gQ29udHJhY3RzIGEgZ3JhcGggdW50aWwgd2UgcmVhY2ggYSBjZXJ0YWluIG51bWJlciBvZiBtZXRhIG5vZGVzXG52YXIgY29udHJhY3RVbnRpbCA9IGZ1bmN0aW9uIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzLCBzaXplLCBzaXplTGltaXQpIHtcbiAgd2hpbGUgKHNpemUgPiBzaXplTGltaXQpIHtcbiAgICAvLyBDaG9vc2UgYW4gZWRnZSByYW5kb21seVxuICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByZW1haW5pbmdFZGdlcy5sZW5ndGgpO1xuXG4gICAgLy8gQ29sbGFwc2UgZ3JhcGggYmFzZWQgb24gZWRnZVxuICAgIHJlbWFpbmluZ0VkZ2VzID0gY29sbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgIHNpemUtLTtcbiAgfVxuICByZXR1cm4gcmVtYWluaW5nRWRnZXM7XG59O1xudmFyIGVsZXNmbiRwID0ge1xuICAvLyBDb21wdXRlcyB0aGUgbWluaW11bSBjdXQgb2YgYW4gdW5kaXJlY3RlZCBncmFwaFxuICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uIGthcmdlclN0ZWluKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoTWF0aC5wb3coTWF0aC5sb2cobnVtTm9kZXMpIC8gTWF0aC5MTjIsIDIpKTtcbiAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gc3FydDIpO1xuICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgIGVycm9yKCdBdCBsZWFzdCAyIG5vZGVzIGFyZSByZXF1aXJlZCBmb3IgS2FyZ2VyLVN0ZWluIGFsZ29yaXRobScpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgLy8gRm9ybWF0IGZvciBlYWNoIGVkZ2UgKGVkZ2UgaW5kZXgsIHNvdXJjZSBub2RlIGluZGV4LCB0YXJnZXQgbm9kZSBpbmRleClcbiAgICB2YXIgZWRnZUluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBub2Rlcy5pbmRleE9mKGUuc291cmNlKCkpLCBub2Rlcy5pbmRleE9mKGUudGFyZ2V0KCkpXSk7XG4gICAgfVxuXG4gICAgLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkN1dEVkZ2VJbmRleGVzID0gW107XG4gICAgdmFyIG1pbkN1dE5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuXG4gICAgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgdmFyIG1ldGFOb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgbWV0YU5vZGVNYXAyID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgY29weU5vZGVzTWFwID0gZnVuY3Rpb24gY29weU5vZGVzTWFwKGZyb20sIHRvKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgdG9bX2kzXSA9IGZyb21bX2kzXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAvLyBSZXNldCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgICAgbWV0YU5vZGVNYXBbX2k0XSA9IF9pNDtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG4gICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLnNsaWNlKCksIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG4gICAgICB2YXIgZWRnZXNTdGF0ZTIgPSBlZGdlc1N0YXRlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcbiAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWV0YU5vZGVNYXAyKTtcblxuICAgICAgLy8gUnVuIDIgaXRlcmF0aW9ucyBzdGFydGluZyBpbiB0aGUgc3RvcCBzdGF0ZVxuICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlMiwgc3RvcFNpemUsIDIpO1xuXG4gICAgICAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMTtcbiAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzMi5sZW5ndGggPD0gcmVzMS5sZW5ndGggJiYgcmVzMi5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMyLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMyO1xuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAyLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcblxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICB2YXIgY3V0ID0gdGhpcy5zcGF3bihtaW5DdXRFZGdlSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlZGdlc1tlWzBdXTtcbiAgICB9KSk7XG4gICAgdmFyIHBhcnRpdGlvbjEgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIHBhcnRpdGlvbjIgPSB0aGlzLnNwYXduKCk7XG5cbiAgICAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcbiAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXROb2RlTWFwWzBdO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG1pbkN1dE5vZGVNYXAubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0Tm9kZU1hcFtfaTVdO1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTVdO1xuICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICBwYXJ0aXRpb24xLm1lcmdlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5tZXJnZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3QgY29tcG9uZW50cyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggZGlzam9pbnQgc3Vic2V0IG9mIG5vZGVzXG4gICAgdmFyIGNvbnN0cnVjdENvbXBvbmVudCA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBvbmVudChzdWJzZXQpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5zcGF3bigpO1xuICAgICAgc3Vic2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgICBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBlZGdlIGlzIHdpdGhpbiBjYWxsaW5nIGNvbGxlY3Rpb24gYW5kIGVkZ2UgaXMgbm90IGluIGN1dFxuICAgICAgICAgIGlmIChfdGhpcy5jb250YWlucyhlZGdlKSAmJiAhY3V0LmNvbnRhaW5zKGVkZ2UpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRzID0gW2NvbnN0cnVjdENvbXBvbmVudChwYXJ0aXRpb24xKSwgY29uc3RydWN0Q29tcG9uZW50KHBhcnRpdGlvbjIpXTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBjdXQsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgLy8gbi5iLiBwYXJ0aXRpb25zIGFyZSBpbmNsdWRlZCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIG9sZCBhcGkgc3BlY1xuICAgICAgLy8gKGNvdWxkIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbilcbiAgICAgIHBhcnRpdGlvbjE6IHBhcnRpdGlvbjEsXG4gICAgICBwYXJ0aXRpb24yOiBwYXJ0aXRpb24yXG4gICAgfTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIF9NYXRoJGh5cG90O1xudmFyIGNvcHlQb3NpdGlvbiA9IGZ1bmN0aW9uIGNvcHlQb3NpdGlvbihwKSB7XG4gIHJldHVybiB7XG4gICAgeDogcC54LFxuICAgIHk6IHAueVxuICB9O1xufTtcbnZhciBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxID0gZnVuY3Rpb24gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcC54ICogem9vbSArIHBhbi54LFxuICAgIHk6IHAueSAqIHpvb20gKyBwYW4ueVxuICB9O1xufTtcbnZhciByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICByZXR1cm4ge1xuICAgIHg6IChwLnggLSBwYW4ueCkgLyB6b29tLFxuICAgIHk6IChwLnkgLSBwYW4ueSkgLyB6b29tXG4gIH07XG59O1xudmFyIGFycmF5MnBvaW50ID0gZnVuY3Rpb24gYXJyYXkycG9pbnQoYXJyKSB7XG4gIHJldHVybiB7XG4gICAgeDogYXJyWzBdLFxuICAgIHk6IGFyclsxXVxuICB9O1xufTtcbnZhciBtaW4gPSBmdW5jdGlvbiBtaW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKHZhbCwgbWluKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbjtcbn07XG52YXIgbWF4ID0gZnVuY3Rpb24gbWF4KGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciBtYXggPSAtSW5maW5pdHk7XG4gIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgodmFsLCBtYXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4O1xufTtcbnZhciBtZWFuID0gZnVuY3Rpb24gbWVhbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgdG90YWwgPSAwO1xuICB2YXIgbiA9IDA7XG4gIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgdG90YWwgKz0gdmFsO1xuICAgICAgbisrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG90YWwgLyBuO1xufTtcbnZhciBtZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIGNvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciBzb3J0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgaW5jbHVkZUhvbGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICBpZiAoY29weSkge1xuICAgIGFyciA9IGFyci5zbGljZShiZWdpbiwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5kIDwgYXJyLmxlbmd0aCkge1xuICAgICAgYXJyLnNwbGljZShlbmQsIGFyci5sZW5ndGggLSBlbmQpO1xuICAgIH1cbiAgICBpZiAoYmVnaW4gPiAwKSB7XG4gICAgICBhcnIuc3BsaWNlKDAsIGJlZ2luKTtcbiAgICB9XG4gIH1cblxuICAvLyBhbGwgbm9uIGZpbml0ZSAoZS5nLiBJbmZpbml0eSwgTmFOKSBlbGVtZW50cyBtdXN0IGJlIC1JbmZpbml0eSBzbyB0aGV5IGdvIHRvIHRoZSBzdGFydFxuICB2YXIgb2ZmID0gMDsgLy8gb2Zmc2V0IGZyb20gbm9uLWZpbml0ZSB2YWx1ZXNcbiAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB2ID0gYXJyW2ldO1xuICAgIGlmIChpbmNsdWRlSG9sZXMpIHtcbiAgICAgIGlmICghaXNGaW5pdGUodikpIHtcbiAgICAgICAgYXJyW2ldID0gLUluZmluaXR5O1xuICAgICAgICBvZmYrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCByZW1vdmUgaXQgaWYgd2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBob2xlc1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNvcnQpIHtcbiAgICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pOyAvLyByZXF1aXJlcyBjb3B5ID0gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG9yaWdcbiAgfVxuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IobGVuIC8gMik7XG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgcmV0dXJuIGFyclttaWQgKyAxICsgb2ZmXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGFyclttaWQgLSAxICsgb2ZmXSArIGFyclttaWQgKyBvZmZdKSAvIDI7XG4gIH1cbn07XG52YXIgZGVnMnJhZCA9IGZ1bmN0aW9uIGRlZzJyYWQoZGVnKSB7XG4gIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xufTtcbnZhciBnZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoZGlzcFksIGRpc3BYKSAtIE1hdGguUEkgLyAyO1xufTtcbnZhciBsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBNYXRoLmxvZyhuKSAvIE1hdGgubG9nKDIpO1xufTtcbnZhciBzaWdudW0gPSBmdW5jdGlvbiBzaWdudW0oeCkge1xuICBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBkaXN0ID0gZnVuY3Rpb24gZGlzdChwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcWRpc3QocDEsIHAyKSk7XG59O1xudmFyIHNxZGlzdCA9IGZ1bmN0aW9uIHNxZGlzdChwMSwgcDIpIHtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xudmFyIGluUGxhY2VTdW1Ob3JtYWxpemUgPSBmdW5jdGlvbiBpblBsYWNlU3VtTm9ybWFsaXplKHYpIHtcbiAgdmFyIGxlbmd0aCA9IHYubGVuZ3RoO1xuXG4gIC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuICB2YXIgdG90YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG90YWwgKz0gdltpXTtcbiAgfVxuXG4gIC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgIHZbX2ldID0gdltfaV0gLyB0b3RhbDtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8vIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlI1F1YWRyYXRpY19jdXJ2ZXNcbnZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiBxYmV6aWVyQXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiBwMCArIDIgKiAoMSAtIHQpICogdCAqIHAxICsgdCAqIHQgKiBwMjtcbn07XG52YXIgcWJlemllclB0QXQgPSBmdW5jdGlvbiBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiB7XG4gICAgeDogcWJlemllckF0KHAwLngsIHAxLngsIHAyLngsIHQpLFxuICAgIHk6IHFiZXppZXJBdChwMC55LCBwMS55LCBwMi55LCB0KVxuICB9O1xufTtcbnZhciBsaW5lQXQgPSBmdW5jdGlvbiBsaW5lQXQocDAsIHAxLCB0LCBkKSB7XG4gIHZhciB2ZWMgPSB7XG4gICAgeDogcDEueCAtIHAwLngsXG4gICAgeTogcDEueSAtIHAwLnlcbiAgfTtcbiAgdmFyIHZlY0Rpc3QgPSBkaXN0KHAwLCBwMSk7XG4gIHZhciBub3JtVmVjID0ge1xuICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgfTtcbiAgdCA9IHQgPT0gbnVsbCA/IDAgOiB0O1xuICBkID0gZCAhPSBudWxsID8gZCA6IHQgKiB2ZWNEaXN0O1xuICByZXR1cm4ge1xuICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gIH07XG59O1xudmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQobWluLCB2YWwsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xufTtcblxuLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbnZhciBtYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBtYWtlQm91bmRpbmdCb3goYmIpIHtcbiAgaWYgKGJiID09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgIHkyOiAtSW5maW5pdHksXG4gICAgICB3OiAwLFxuICAgICAgaDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYmIueDEgIT0gbnVsbCAmJiBiYi55MSAhPSBudWxsKSB7XG4gICAgaWYgKGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICB5MTogYmIueTEsXG4gICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgeTI6IGJiLnkyLFxuICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgeTI6IGJiLnkxICsgYmIuaCxcbiAgICAgICAgdzogYmIudyxcbiAgICAgICAgaDogYmIuaFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG52YXIgY29weUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY29weUJvdW5kaW5nQm94KGJiKSB7XG4gIHJldHVybiB7XG4gICAgeDE6IGJiLngxLFxuICAgIHgyOiBiYi54MixcbiAgICB3OiBiYi53LFxuICAgIHkxOiBiYi55MSxcbiAgICB5MjogYmIueTIsXG4gICAgaDogYmIuaFxuICB9O1xufTtcbnZhciBjbGVhckJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY2xlYXJCb3VuZGluZ0JveChiYikge1xuICBiYi54MSA9IEluZmluaXR5O1xuICBiYi55MSA9IEluZmluaXR5O1xuICBiYi54MiA9IC1JbmZpbml0eTtcbiAgYmIueTIgPSAtSW5maW5pdHk7XG4gIGJiLncgPSAwO1xuICBiYi5oID0gMDtcbn07XG52YXIgdXBkYXRlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveChiYjEsIGJiMikge1xuICAvLyB1cGRhdGUgYmIxIHdpdGggYmIyIGJvdW5kc1xuXG4gIGJiMS54MSA9IE1hdGgubWluKGJiMS54MSwgYmIyLngxKTtcbiAgYmIxLngyID0gTWF0aC5tYXgoYmIxLngyLCBiYjIueDIpO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgYmIxLnkxID0gTWF0aC5taW4oYmIxLnkxLCBiYjIueTEpO1xuICBiYjEueTIgPSBNYXRoLm1heChiYjEueTIsIGJiMi55Mik7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHgsIHkpIHtcbiAgYmIueDEgPSBNYXRoLm1pbihiYi54MSwgeCk7XG4gIGJiLngyID0gTWF0aC5tYXgoYmIueDIsIHgpO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIueTEgPSBNYXRoLm1pbihiYi55MSwgeSk7XG4gIGJiLnkyID0gTWF0aC5tYXgoYmIueTIsIHkpO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveChiYikge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgYmIueDEgLT0gcGFkZGluZztcbiAgYmIueDIgKz0gcGFkZGluZztcbiAgYmIueTEgLT0gcGFkZGluZztcbiAgYmIueTIgKz0gcGFkZGluZztcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICByZXR1cm4gYmI7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMF07XG4gIHZhciB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQ7XG4gIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgIHRvcCA9IHJpZ2h0ID0gYm90dG9tID0gbGVmdCA9IHBhZGRpbmdbMF07XG4gIH0gZWxzZSBpZiAocGFkZGluZy5sZW5ndGggPT09IDIpIHtcbiAgICB0b3AgPSBib3R0b20gPSBwYWRkaW5nWzBdO1xuICAgIGxlZnQgPSByaWdodCA9IHBhZGRpbmdbMV07XG4gIH0gZWxzZSBpZiAocGFkZGluZy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgX3BhZGRpbmcgPSBfc2xpY2VkVG9BcnJheShwYWRkaW5nLCA0KTtcbiAgICB0b3AgPSBfcGFkZGluZ1swXTtcbiAgICByaWdodCA9IF9wYWRkaW5nWzFdO1xuICAgIGJvdHRvbSA9IF9wYWRkaW5nWzJdO1xuICAgIGxlZnQgPSBfcGFkZGluZ1szXTtcbiAgfVxuICBiYi54MSAtPSBsZWZ0O1xuICBiYi54MiArPSByaWdodDtcbiAgYmIueTEgLT0gdG9wO1xuICBiYi55MiArPSBib3R0b207XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgcmV0dXJuIGJiO1xufTtcblxuLy8gYXNzaWduIHRoZSB2YWx1ZXMgb2YgYmIyIGludG8gYmIxXG52YXIgYXNzaWduQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBhc3NpZ25Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICBiYjEueDEgPSBiYjIueDE7XG4gIGJiMS55MSA9IGJiMi55MTtcbiAgYmIxLngyID0gYmIyLngyO1xuICBiYjEueTIgPSBiYjIueTI7XG4gIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbn07XG52YXIgYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIxLCBiYjIpIHtcbiAgLy8gY2FzZTogb25lIGJiIHRvIHJpZ2h0IG9mIG90aGVyXG4gIGlmIChiYjEueDEgPiBiYjIueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJiMi54MSA+IGJiMS54Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG4gIGlmIChiYjEueDIgPCBiYjIueDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJiMi54MiA8IGJiMS54MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuICBpZiAoYmIxLnkyIDwgYmIyLnkxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueTIgPCBiYjEueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjYXNlOiBvbmUgYmIgYmVsb3cgb3RoZXJcbiAgaWYgKGJiMS55MSA+IGJiMi55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLnkxID4gYmIxLnkyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkge1xuICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55Mjtcbn07XG52YXIgcG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gcG9pbnRJbkJvdW5kaW5nQm94KGJiLCBwdCkge1xuICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYiwgcHQueCwgcHQueSk7XG59O1xudmFyIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MSwgYmIyLnkxKSAmJiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngyLCBiYjIueTIpO1xufTtcbnZhciBoeXBvdCA9IChfTWF0aCRoeXBvdCA9IE1hdGguaHlwb3QpICE9PSBudWxsICYmIF9NYXRoJGh5cG90ICE9PSB1bmRlZmluZWQgPyBfTWF0aCRoeXBvdCA6IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG59O1xuZnVuY3Rpb24gaW5mbGF0ZVBvbHlnb24ocG9seWdvbiwgZCkge1xuICBpZiAocG9seWdvbi5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGF0IGxlYXN0IDMgdmVydGljZXMnKTtcbiAgfVxuICAvLyBIZWxwZXJzXG4gIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoYSwgYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBhLnggKyBiLngsXG4gICAgICB5OiBhLnkgKyBiLnlcbiAgICB9O1xuICB9O1xuICB2YXIgc3ViID0gZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYS54IC0gYi54LFxuICAgICAgeTogYS55IC0gYi55XG4gICAgfTtcbiAgfTtcbiAgdmFyIHNjYWxlID0gZnVuY3Rpb24gc2NhbGUodiwgcykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB2LnggKiBzLFxuICAgICAgeTogdi55ICogc1xuICAgIH07XG4gIH07XG4gIHZhciBjcm9zcyA9IGZ1bmN0aW9uIGNyb3NzKHUsIHYpIHtcbiAgICByZXR1cm4gdS54ICogdi55IC0gdS55ICogdi54O1xuICB9O1xuICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHYpIHtcbiAgICB2YXIgbGVuID0gaHlwb3Qodi54LCB2LnkpO1xuICAgIHJldHVybiBsZW4gPT09IDAgPyB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0gOiB7XG4gICAgICB4OiB2LnggLyBsZW4sXG4gICAgICB5OiB2LnkgLyBsZW5cbiAgICB9O1xuICB9O1xuICAvLyBTaWduZWQgYXJlYSAocG9zaXRpdmUgPSBDQ1cpXG4gIHZhciBzaWduZWRBcmVhID0gZnVuY3Rpb24gc2lnbmVkQXJlYShwdHMpIHtcbiAgICB2YXIgQSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHRzW2ldLFxuICAgICAgICBxID0gcHRzWyhpICsgMSkgJSBwdHMubGVuZ3RoXTtcbiAgICAgIEEgKz0gcC54ICogcS55IC0gcS54ICogcC55O1xuICAgIH1cbiAgICByZXR1cm4gQSAvIDI7XG4gIH07XG4gIC8vIExpbmXigJNsaW5lIGludGVyc2VjdGlvbiAoaW5maW5pdGUgbGluZXMpXG4gIHZhciBpbnRlcnNlY3RMaW5lcyA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVzKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgdmFyIHIgPSBzdWIocDIsIHAxKTtcbiAgICB2YXIgcyA9IHN1YihwNCwgcDMpO1xuICAgIHZhciBkZW5vbSA9IGNyb3NzKHIsIHMpO1xuICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCAxZS05KSB7XG4gICAgICAvLyBQYXJhbGxlbCBvciBuZWFybHkgc28g4oCUIGZhbGxiYWNrIHRvIG1pZHBvaW50XG4gICAgICByZXR1cm4gYWRkKHAxLCBzY2FsZShyLCAwLjUpKTtcbiAgICB9XG4gICAgdmFyIHQgPSBjcm9zcyhzdWIocDMsIHAxKSwgcykgLyBkZW5vbTtcbiAgICByZXR1cm4gYWRkKHAxLCBzY2FsZShyLCB0KSk7XG4gIH07XG5cbiAgLy8gTWFrZSBhIHNoYWxsb3cgY29weSBhbmQgZW5mb3JjZSBDQ1dcbiAgdmFyIHB0cyA9IHBvbHlnb24ubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCxcbiAgICAgIHk6IHAueVxuICAgIH07XG4gIH0pO1xuICBpZiAoc2lnbmVkQXJlYShwdHMpIDwgMCkgcHRzLnJldmVyc2UoKTtcbiAgdmFyIG4gPSBwdHMubGVuZ3RoO1xuICAvLyBDb21wdXRlIG91dHdhcmQgbm9ybWFscyBmb3IgZWFjaCBlZGdlXG4gIHZhciBub3JtYWxzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBwdHNbaV0sXG4gICAgICBxID0gcHRzWyhpICsgMSkgJSBuXTtcbiAgICB2YXIgZWRnZSA9IHN1YihxLCBwKTtcbiAgICAvLyBGb3IgQ0NXIHBvbHlnb24sIGlud2FyZCBub3JtYWwgPSAoLWVkZ2UueSwgZWRnZS54KVxuICAgIC8vIHNvIG91dHdhcmQgbm9ybWFsID0gKGVkZ2UueSwgLWVkZ2UueClcbiAgICB2YXIgb3V0ID0gbm9ybWFsaXplKHtcbiAgICAgIHg6IGVkZ2UueSxcbiAgICAgIHk6IC1lZGdlLnhcbiAgICB9KTtcbiAgICBub3JtYWxzLnB1c2gob3V0KTtcbiAgfVxuXG4gIC8vIEJ1aWxkIG9mZnNldCBlZGdlc1xuICB2YXIgb2Zmc2V0RWRnZXMgPSBub3JtYWxzLm1hcChmdW5jdGlvbiAobnJtLCBpKSB7XG4gICAgdmFyIHAxID0gYWRkKHB0c1tpXSwgc2NhbGUobnJtLCBkKSk7XG4gICAgdmFyIHAyID0gYWRkKHB0c1soaSArIDEpICUgbl0sIHNjYWxlKG5ybSwgZCkpO1xuICAgIHJldHVybiB7XG4gICAgICBwMTogcDEsXG4gICAgICBwMjogcDJcbiAgICB9O1xuICB9KTtcblxuICAvLyBJbnRlcnNlY3QgY29uc2VjdXRpdmUgb2Zmc2V0IGVkZ2VzXG4gIHZhciBpbmZsYXRlZCA9IFtdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuOyBfaTIrKykge1xuICAgIHZhciBwcmV2RWRnZSA9IG9mZnNldEVkZ2VzWyhfaTIgLSAxICsgbikgJSBuXTtcbiAgICB2YXIgY3VyckVkZ2UgPSBvZmZzZXRFZGdlc1tfaTJdO1xuICAgIHZhciBpcCA9IGludGVyc2VjdExpbmVzKHByZXZFZGdlLnAxLCBwcmV2RWRnZS5wMiwgY3VyckVkZ2UucDEsIGN1cnJFZGdlLnAyKTtcbiAgICBpbmZsYXRlZC5wdXNoKGlwKTtcbiAgfVxuICByZXR1cm4gaW5mbGF0ZWQ7XG59XG5mdW5jdGlvbiBtaXRlckJveChwdHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHN0cm9rZVdpZHRoKSB7XG4gIHZhciB0cHRzID0gdHJhbnNmb3JtUG9pbnRzKHB0cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gIHZhciBvZmZzZXRQb2ludHMgPSBpbmZsYXRlUG9seWdvbih0cHRzLCBzdHJva2VXaWR0aCk7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICBvZmZzZXRQb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocHQpIHtcbiAgICByZXR1cm4gZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCBwdC54LCBwdC55KTtcbiAgfSk7XG4gIHJldHVybiBiYjtcbn1cbnZhciByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6ICdhdXRvJztcbiAgdmFyIGNvcm5lclJhZGl1cyA9IHJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiByYWRpdXM7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oY29ybmVyUmFkaXVzLCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICB2YXIgZG9XaWR0aCA9IGNvcm5lclJhZGl1cyAhPT0gaGFsZldpZHRoLFxuICAgIGRvSGVpZ2h0ID0gY29ybmVyUmFkaXVzICE9PSBoYWxmSGVpZ2h0O1xuXG4gIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuXG4gIC8vIFRvcCBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gIGlmIChkb1dpZHRoKSB7XG4gICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAgaWYgKGRvSGVpZ2h0KSB7XG4gICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHJpZ2h0U3RhcnRYLCByaWdodFN0YXJ0WSwgcmlnaHRFbmRYLCByaWdodEVuZFksIGZhbHNlKTtcbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuICBpZiAoZG9XaWR0aCkge1xuICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WSA9IG5vZGVZICsgaGFsZkhlaWdodCArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAgaWYgKGRvSGVpZ2h0KSB7XG4gICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0RW5kWCA9IGxlZnRTdGFydFg7XG4gICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBsZWZ0U3RhcnRYLCBsZWZ0U3RhcnRZLCBsZWZ0RW5kWCwgbGVmdEVuZFksIGZhbHNlKTtcbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG4gIHZhciBhcmNJbnRlcnNlY3Rpb25zO1xuXG4gIC8vIFRvcCBMZWZ0XG4gIHtcbiAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgLy8gVG9wIFJpZ2h0XG4gIHtcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIFJpZ2h0XG4gIHtcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVJpZ2h0Q2VudGVyWCwgYm90dG9tUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21SaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIExlZnRcbiAge1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG59O1xudmFyIGluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24gaW5MaW5lVmljaW5pdHkoeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2UpIHtcbiAgdmFyIHQgPSB0b2xlcmFuY2U7XG4gIHZhciB4MSA9IE1hdGgubWluKGx4MSwgbHgyKTtcbiAgdmFyIHgyID0gTWF0aC5tYXgobHgxLCBseDIpO1xuICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gIHZhciB5MiA9IE1hdGgubWF4KGx5MSwgbHkyKTtcbiAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0ICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xufTtcbnZhciBpbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24gaW5CZXppZXJWaWNpbml0eSh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgdmFyIGJiID0ge1xuICAgIHgxOiBNYXRoLm1pbih4MSwgeDMsIHgyKSAtIHRvbGVyYW5jZSxcbiAgICB4MjogTWF0aC5tYXgoeDEsIHgzLCB4MikgKyB0b2xlcmFuY2UsXG4gICAgeTE6IE1hdGgubWluKHkxLCB5MywgeTIpIC0gdG9sZXJhbmNlLFxuICAgIHkyOiBNYXRoLm1heCh5MSwgeTMsIHkyKSArIHRvbGVyYW5jZVxuICB9O1xuXG4gIC8vIGlmIG91dHNpZGUgdGhlIHJvdWdoIGJvdW5kaW5nIGJveCBmb3IgdGhlIGJlemllciwgdGhlbiBpdCBjYW4ndCBiZSBhIGhpdFxuICBpZiAoeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBzb2x2ZVF1YWRyYXRpYyA9IGZ1bmN0aW9uIHNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHZhbCkge1xuICBjIC09IHZhbDtcbiAgdmFyIHIgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKHIgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBzcXJ0UiA9IE1hdGguc3FydChyKTtcbiAgdmFyIGRlbm9tID0gMiAqIGE7XG4gIHZhciByb290MSA9ICgtYiArIHNxcnRSKSAvIGRlbm9tO1xuICB2YXIgcm9vdDIgPSAoLWIgLSBzcXJ0UikgLyBkZW5vbTtcbiAgcmV0dXJuIFtyb290MSwgcm9vdDJdO1xufTtcbnZhciBzb2x2ZUN1YmljID0gZnVuY3Rpb24gc29sdmVDdWJpYyhhLCBiLCBjLCBkLCByZXN1bHQpIHtcbiAgLy8gU29sdmVzIGEgY3ViaWMgZnVuY3Rpb24sIHJldHVybnMgcm9vdCBpbiBmb3JtIFtyMSwgaTEsIHIyLCBpMiwgcjMsIGkzXSwgd2hlcmVcbiAgLy8gciBpcyB0aGUgcmVhbCBjb21wb25lbnQsIGkgaXMgdGhlIGltYWdpbmFyeSBjb21wb25lbnRcblxuICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcblxuICB2YXIgZXBzaWxvbiA9IDAuMDAwMDE7XG5cbiAgLy8gYXZvaWQgZGl2aXNpb24gYnkgemVybyB3aGlsZSBrZWVwaW5nIHRoZSBvdmVyYWxsIGV4cHJlc3Npb24gY2xvc2UgaW4gdmFsdWVcbiAgaWYgKGEgPT09IDApIHtcbiAgICBhID0gZXBzaWxvbjtcbiAgfVxuICBiIC89IGE7XG4gIGMgLz0gYTtcbiAgZCAvPSBhO1xuICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuICBxID0gKDMuMCAqIGMgLSBiICogYikgLyA5LjA7XG4gIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICByIC89IDU0LjA7XG4gIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICByZXN1bHRbMV0gPSAwO1xuICB0ZXJtMSA9IGIgLyAzLjA7XG4gIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgcyA9IHIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICBzID0gcyA8IDAgPyAtTWF0aC5wb3coLXMsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhzLCAxLjAgLyAzLjApO1xuICAgIHQgPSByIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgdCA9IHQgPCAwID8gLU1hdGgucG93KC10LCAxLjAgLyAzLjApIDogTWF0aC5wb3codCwgMS4wIC8gMy4wKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyBzICsgdDtcbiAgICB0ZXJtMSArPSAocyArIHQpIC8gMi4wO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICB0ZXJtMSA9IE1hdGguc3FydCgzLjApICogKC10ICsgcykgLyAyO1xuICAgIHJlc3VsdFszXSA9IHRlcm0xO1xuICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcbiAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgIHIxMyA9IHIgPCAwID8gLU1hdGgucG93KC1yLCAxLjAgLyAzLjApIDogTWF0aC5wb3cociwgMS4wIC8gMy4wKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLShyMTMgKyB0ZXJtMSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHEgPSAtcTtcbiAgZHVtMSA9IHEgKiBxICogcTtcbiAgZHVtMSA9IE1hdGguYWNvcyhyIC8gTWF0aC5zcXJ0KGR1bTEpKTtcbiAgcjEzID0gMi4wICogTWF0aC5zcXJ0KHEpO1xuICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyhkdW0xIC8gMy4wKTtcbiAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyAyLjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gIHJlc3VsdFs0XSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKChkdW0xICsgNC4wICogTWF0aC5QSSkgLyAzLjApO1xuICByZXR1cm47XG59O1xudmFyIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24gc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAvLyBGaW5kIG1pbmltdW0gZGlzdGFuY2UgYnkgdXNpbmcgdGhlIG1pbmltdW0gb2YgdGhlIGRpc3RhbmNlXG4gIC8vIGZ1bmN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50IGFuZCB0aGUgY3VydmVcblxuICAvLyBUaGlzIGdpdmVzIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHJlc3VsdGluZyBjdWJpYyBlcXVhdGlvblxuICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG5cbiAgdmFyIGEgPSAxLjAgKiB4MSAqIHgxIC0gNCAqIHgxICogeDIgKyAyICogeDEgKiB4MyArIDQgKiB4MiAqIHgyIC0gNCAqIHgyICogeDMgKyB4MyAqIHgzICsgeTEgKiB5MSAtIDQgKiB5MSAqIHkyICsgMiAqIHkxICogeTMgKyA0ICogeTIgKiB5MiAtIDQgKiB5MiAqIHkzICsgeTMgKiB5MztcbiAgdmFyIGIgPSAxLjAgKiA5ICogeDEgKiB4MiAtIDMgKiB4MSAqIHgxIC0gMyAqIHgxICogeDMgLSA2ICogeDIgKiB4MiArIDMgKiB4MiAqIHgzICsgOSAqIHkxICogeTIgLSAzICogeTEgKiB5MSAtIDMgKiB5MSAqIHkzIC0gNiAqIHkyICogeTIgKyAzICogeTIgKiB5MztcbiAgdmFyIGMgPSAxLjAgKiAzICogeDEgKiB4MSAtIDYgKiB4MSAqIHgyICsgeDEgKiB4MyAtIHgxICogeCArIDIgKiB4MiAqIHgyICsgMiAqIHgyICogeCAtIHgzICogeCArIDMgKiB5MSAqIHkxIC0gNiAqIHkxICogeTIgKyB5MSAqIHkzIC0geTEgKiB5ICsgMiAqIHkyICogeTIgKyAyICogeTIgKiB5IC0geTMgKiB5O1xuICB2YXIgZCA9IDEuMCAqIHgxICogeDIgLSB4MSAqIHgxICsgeDEgKiB4IC0geDIgKiB4ICsgeTEgKiB5MiAtIHkxICogeTEgKyB5MSAqIHkgLSB5MiAqIHk7XG5cbiAgLy8gZGVidWcoXCJjb2VmZmljaWVudHM6IFwiICsgYSAvIGEgKyBcIiwgXCIgKyBiIC8gYSArIFwiLCBcIiArIGMgLyBhICsgXCIsIFwiICsgZCAvIGEpO1xuXG4gIHZhciByb290cyA9IFtdO1xuXG4gIC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cbiAgc29sdmVDdWJpYyhhLCBiLCBjLCBkLCByb290cyk7XG4gIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuICB2YXIgcGFyYW1zID0gW107XG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCA2OyBpbmRleCArPSAyKSB7XG4gICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZCAmJiByb290c1tpbmRleF0gPj0gMCAmJiByb290c1tpbmRleF0gPD0gMS4wKSB7XG4gICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgIH1cbiAgfVxuICBwYXJhbXMucHVzaCgxLjApO1xuICBwYXJhbXMucHVzaCgwLjApO1xuICB2YXIgbWluRGlzdGFuY2VTcXVhcmVkID0gLTE7XG4gIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDEgKyAyLjAgKiAoMSAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB4MiArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuICAgIGN1clkgPSBNYXRoLnBvdygxIC0gcGFyYW1zW2ldLCAyLjApICogeTEgKyAyICogKDEuMCAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB5MiArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHkzO1xuICAgIGRpc3RTcXVhcmVkID0gTWF0aC5wb3coY3VyWCAtIHgsIDIpICsgTWF0aC5wb3coY3VyWSAtIHksIDIpO1xuICAgIC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuICAgIGlmIChtaW5EaXN0YW5jZVNxdWFyZWQgPj0gMCkge1xuICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkRpc3RhbmNlU3F1YXJlZDtcbn07XG52YXIgc3FkaXN0VG9GaW5pdGVMaW5lID0gZnVuY3Rpb24gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcbiAgdmFyIGxpbmVTcSA9IGxpbmVbMF0gKiBsaW5lWzBdICsgbGluZVsxXSAqIGxpbmVbMV07XG4gIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgdmFyIGFkalNxID0gZG90UHJvZHVjdCAqIGRvdFByb2R1Y3QgLyBsaW5lU3E7XG4gIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuICBpZiAoYWRqU3EgPiBsaW5lU3EpIHtcbiAgICByZXR1cm4gKHggLSB4MikgKiAoeCAtIHgyKSArICh5IC0geTIpICogKHkgLSB5Mik7XG4gIH1cbiAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpIHtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICB2YXIgeTM7XG5cbiAgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuICB2YXIgdXAgPSAwO1xuICAvLyBsZXQgZG93biA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgIGlmIChpICsgMSA8IHBvaW50cy5sZW5ndGggLyAyKSB7XG4gICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDIgKyAxXTtcbiAgICB9XG4gICAgaWYgKHgxID09IHggJiYgeDIgPT0geCkgOyBlbHNlIGlmICh4MSA+PSB4ICYmIHggPj0geDIgfHwgeDEgPD0geCAmJiB4IDw9IHgyKSB7XG4gICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmKCB5MyA8IHkgKXtcbiAgICAgIC8vIGRvd24rKztcbiAgICAgIC8vIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGlmICh1cCAlIDIgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgcG9pbnRJbnNpZGVQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuXG4gIC8vIEdpdmVzIG5lZ2F0aXZlIGFuZ2xlXG4gIHZhciBhbmdsZTtcbiAgaWYgKGRpcmVjdGlvblswXSAhPSBudWxsKSB7XG4gICAgYW5nbGUgPSBNYXRoLmF0YW4oZGlyZWN0aW9uWzFdIC8gZGlyZWN0aW9uWzBdKTtcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbmdsZSA9IGRpcmVjdGlvbjtcbiAgfVxuICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cbiAgLy8gICAgY29uc29sZS5sb2coXCJiYXNlOiBcIiArIGJhc2VQb2ludHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvcyAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgfVxuICB2YXIgcG9pbnRzO1xuICBpZiAocGFkZGluZyA+IDApIHtcbiAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuICAgIHBvaW50cyA9IGpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICB9XG4gIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKTtcbn07XG52YXIgcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJzKSB7XG4gIHZhciBjdXRQb2x5Z29uUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoICogMik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29ybmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAwXSA9IGNvcm5lci5zdGFydFg7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDFdID0gY29ybmVyLnN0YXJ0WTtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMl0gPSBjb3JuZXIuc3RvcFg7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDNdID0gY29ybmVyLnN0b3BZO1xuICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhjb3JuZXIuY3ggLSB4LCAyKSArIE1hdGgucG93KGNvcm5lci5jeSAtIHksIDIpO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gTWF0aC5wb3coY29ybmVyLnJhZGl1cywgMikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFBvbHlnb25Qb2ludHMpO1xufTtcbnZhciBqb2luTGluZXMgPSBmdW5jdGlvbiBqb2luTGluZXMobGluZVNldCkge1xuICB2YXIgdmVydGljZXMgPSBuZXcgQXJyYXkobGluZVNldC5sZW5ndGggLyAyKTtcbiAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTZXQubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0W2kgKiA0ICsgMl07XG4gICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuICAgIGlmIChpIDwgbGluZVNldC5sZW5ndGggLyA0IC0gMSkge1xuICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WyhpICsgMSkgKiA0XTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsoaSArIDEpICogNCArIDFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsoaSArIDEpICogNCArIDJdO1xuICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFsoaSArIDEpICogNCArIDNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbMF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFszXTtcbiAgICB9XG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFksIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksIHRydWUpO1xuICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICB2ZXJ0aWNlc1tpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICB9XG4gIHJldHVybiB2ZXJ0aWNlcztcbn07XG52YXIgZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uIGV4cGFuZFBvbHlnb24ocG9pbnRzLCBwYWQpIHtcbiAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1sxXTtcbiAgICB9XG5cbiAgICAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cblxuICAgIC8vIEFzc3VtZSBDQ1cgcG9seWdvbiB3aW5kaW5nXG5cbiAgICB2YXIgb2Zmc2V0WCA9IG5leHRQb2ludFkgLSBjdXJyZW50UG9pbnRZO1xuICAgIHZhciBvZmZzZXRZID0gLShuZXh0UG9pbnRYIC0gY3VycmVudFBvaW50WCk7XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WCA9IG9mZnNldFggLyBvZmZzZXRMZW5ndGg7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDRdID0gY3VycmVudFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDNdID0gbmV4dFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICB9XG4gIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG59O1xudmFyIGludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcbiAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKTtcbiAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG4gIGlmIChuZXdMZW5ndGggPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuICByZXR1cm4gWyhjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5XTtcbn07XG52YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gIHggLT0gY2VudGVyWDtcbiAgeSAtPSBjZW50ZXJZO1xuICB4IC89IHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gIHkgLz0gaGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gIHJldHVybiB4ICogeCArIHkgKiB5IDw9IDE7XG59O1xuXG4vLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxudmFyIGludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZCA9IFt4MiAtIHgxLCB5MiAtIHkxXTsgLy8gRGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBmID0gW3gxIC0gY2VudGVyWCwgeTEgLSBjZW50ZXJZXTtcbiAgdmFyIGEgPSBkWzBdICogZFswXSArIGRbMV0gKiBkWzFdO1xuICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gIHZhciBjID0gZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSAtIHJhZGl1cyAqIHJhZGl1cztcbiAgdmFyIGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdE1pbiA9IE1hdGgubWluKHQxLCB0Mik7XG4gIHZhciB0TWF4ID0gTWF0aC5tYXgodDEsIHQyKTtcbiAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcbiAgaWYgKHRNaW4gPj0gMCAmJiB0TWluIDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1pbik7XG4gIH1cbiAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1heCk7XG4gIH1cbiAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBuZWFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzBdICsgeDE7XG4gIHZhciBuZWFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzFdICsgeTE7XG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdKSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICB9XG59O1xudmFyIG1pZE9mVGhyZWUgPSBmdW5jdGlvbiBtaWRPZlRocmVlKGEsIGIsIGMpIHtcbiAgaWYgKGIgPD0gYSAmJiBhIDw9IGMgfHwgYyA8PSBhICYmIGEgPD0gYikge1xuICAgIHJldHVybiBhO1xuICB9IGVsc2UgaWYgKGEgPD0gYiAmJiBiIDw9IGMgfHwgYyA8PSBiICYmIGIgPD0gYSkge1xuICAgIHJldHVybiBiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjO1xuICB9XG59O1xuXG4vLyAoeDEseTEpPT4oeDIseTIpIGludGVyc2VjdCB3aXRoICh4Myx5Myk9Pih4NCx5NClcbnZhciBmaW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICB2YXIgZHgxMyA9IHgxIC0geDM7XG4gIHZhciBkeDIxID0geDIgLSB4MTtcbiAgdmFyIGR4NDMgPSB4NCAtIHgzO1xuICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gIHZhciBkeTIxID0geTIgLSB5MTtcbiAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuICB2YXIgdWFfdCA9IGR4NDMgKiBkeTEzIC0gZHk0MyAqIGR4MTM7XG4gIHZhciB1Yl90ID0gZHgyMSAqIGR5MTMgLSBkeTIxICogZHgxMztcbiAgdmFyIHVfYiA9IGR5NDMgKiBkeDIxIC0gZHg0MyAqIGR5MjE7XG4gIGlmICh1X2IgIT09IDApIHtcbiAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG4gICAgdmFyIGZscHRUaHJlc2hvbGQgPSAwLjAwMTtcbiAgICB2YXIgX21pbiA9IDAgLSBmbHB0VGhyZXNob2xkO1xuICAgIHZhciBfbWF4ID0gMSArIGZscHRUaHJlc2hvbGQ7XG4gICAgaWYgKF9taW4gPD0gdWEgJiYgdWEgPD0gX21heCAmJiBfbWluIDw9IHViICYmIHViIDw9IF9tYXgpIHtcbiAgICAgIHJldHVybiBbeDEgKyB1YSAqIGR4MjEsIHkxICsgdWEgKiBkeTIxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpbmZpbml0ZUxpbmVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbeDEgKyB1YSAqIGR4MjEsIHkxICsgdWEgKiBkeTIxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCkge1xuICAgICAgLy8gUGFyYWxsZWwsIGNvaW5jaWRlbnQgbGluZXMuIENoZWNrIGlmIG92ZXJsYXBcblxuICAgICAgLy8gQ2hlY2sgZW5kcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmIChtaWRPZlRocmVlKHgxLCB4MiwgeDQpID09PSB4NCkge1xuICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHgzKSA9PT0geDMpIHtcbiAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG4gICAgICBpZiAobWlkT2ZUaHJlZSh4MywgeDQsIHgyKSA9PT0geDIpIHtcbiAgICAgICAgcmV0dXJuIFt4MiwgeTJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn07XG52YXIgdHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHggPSBjZW50ZXJYO1xuICB2YXIgeSA9IGNlbnRlclk7XG4gIHJldC5wdXNoKHtcbiAgICB4OiB4ICsgaGFsZlcgKiBwb2ludHNbMF0sXG4gICAgeTogeSArIGhhbGZIICogcG9pbnRzWzFdXG4gIH0pO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICByZXQucHVzaCh7XG4gICAgICB4OiB4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLFxuICAgICAgeTogeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApXG4vLyBpbnRlcnNlY3QgYSBub2RlIHBvbHlnb24gKHB0cyB0cmFuc2Zvcm1lZClcbi8vXG4vLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZIClcbi8vIGludGVyc2VjdCB0aGUgcG9pbnRzIChubyB0cmFuc2Zvcm0pXG52YXIgcG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBkb1RyYW5zZm9ybSA9IHRydWU7XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgZG9UcmFuc2Zvcm0gPSBmYWxzZTtcbiAgfVxuICB2YXIgcG9pbnRzO1xuICBpZiAoZG9UcmFuc2Zvcm0pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBiYXNlUG9pbnRzO1xuICB9XG4gIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcG9pbnRzLmxlbmd0aCAvIDI7IF9pMysrKSB7XG4gICAgY3VycmVudFggPSBwb2ludHNbX2kzICogMl07XG4gICAgY3VycmVudFkgPSBwb2ludHNbX2kzICogMiArIDFdO1xuICAgIGlmIChfaTMgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWyhfaTMgKyAxKSAqIDJdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbKF9pMyArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgIH1cbiAgICBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSk7XG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nLCBjb3JuZXJzKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG4gIHZhciBsaW5lcyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCAqIDIpO1xuICBjb3JuZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvcm5lciwgaSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAyXSA9IGNvcm5lci5zdGFydFg7XG4gICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9IGNvcm5lci5zdGFydFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzW2kgKiA0IC0gMl0gPSBjb3JuZXIuc3RhcnRYO1xuICAgICAgbGluZXNbaSAqIDQgLSAxXSA9IGNvcm5lci5zdGFydFk7XG4gICAgfVxuICAgIGxpbmVzW2kgKiA0XSA9IGNvcm5lci5zdG9wWDtcbiAgICBsaW5lc1tpICogNCArIDFdID0gY29ybmVyLnN0b3BZO1xuICAgIGludGVyc2VjdGlvbiA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyLmN4LCBjb3JuZXIuY3ksIGNvcm5lci5yYWRpdXMpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgbGluZXNbaSAqIDRdLCBsaW5lc1tpICogNCArIDFdLCBsaW5lc1tpICogNCArIDJdLCBsaW5lc1tpICogNCArIDNdLCBmYWxzZSk7XG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9XG4gIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDIpIHtcbiAgICB2YXIgbG93ZXN0SW50ZXJzZWN0aW9uID0gW2ludGVyc2VjdGlvbnNbMF0sIGludGVyc2VjdGlvbnNbMV1dO1xuICAgIHZhciBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMF0gLSB4LCAyKSArIE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblsxXSAtIHksIDIpO1xuICAgIGZvciAodmFyIF9pNCA9IDE7IF9pNCA8IGludGVyc2VjdGlvbnMubGVuZ3RoIC8gMjsgX2k0KyspIHtcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDJdIC0geCwgMikgKyBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXSAtIHksIDIpO1xuICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8PSBsb3dlc3RTcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgbG93ZXN0SW50ZXJzZWN0aW9uWzBdID0gaW50ZXJzZWN0aW9uc1tfaTQgKiAyXTtcbiAgICAgICAgbG93ZXN0SW50ZXJzZWN0aW9uWzFdID0gaW50ZXJzZWN0aW9uc1tfaTQgKiAyICsgMV07XG4gICAgICAgIGxvd2VzdFNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvd2VzdEludGVyc2VjdGlvbjtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn07XG52YXIgc2hvcnRlbkludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuICB2YXIgZGlzcCA9IFtpbnRlcnNlY3Rpb25bMF0gLSBvZmZzZXRbMF0sIGludGVyc2VjdGlvblsxXSAtIG9mZnNldFsxXV07XG4gIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuICBpZiAobGVuUmF0aW8gPCAwKSB7XG4gICAgbGVuUmF0aW8gPSAwLjAwMDAxO1xuICB9XG4gIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xufTtcbnZhciBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICB2YXIgcG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKTtcbiAgcG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cyk7XG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uIGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpIHtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGggLyAyO1xuICB2YXIgbWluWCA9IEluZmluaXR5LFxuICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICBtYXhYID0gLUluZmluaXR5LFxuICAgIG1heFkgPSAtSW5maW5pdHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gIH1cblxuICAvLyBzdHJldGNoIGZhY3RvcnNcbiAgdmFyIHN4ID0gMiAvIChtYXhYIC0gbWluWCk7XG4gIHZhciBzeSA9IDIgLyAobWF4WSAtIG1pblkpO1xuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzaWRlczsgX2k1KyspIHtcbiAgICB4ID0gcG9pbnRzWzIgKiBfaTVdID0gcG9pbnRzWzIgKiBfaTVdICogc3g7XG4gICAgeSA9IHBvaW50c1syICogX2k1ICsgMV0gPSBwb2ludHNbMiAqIF9pNSArIDFdICogc3k7XG4gICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICB9XG4gIGlmIChtaW5ZIDwgLTEpIHtcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBzaWRlczsgX2k2KyspIHtcbiAgICAgIHkgPSBwb2ludHNbMiAqIF9pNiArIDFdID0gcG9pbnRzWzIgKiBfaTYgKyAxXSArICgtMSAtIG1pblkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufTtcbnZhciBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKSB7XG4gIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICB2YXIgc3RhcnRBbmdsZSA9IHNpZGVzICUgMiA9PT0gMCA/IE1hdGguUEkgLyAyLjAgKyBpbmNyZW1lbnQgLyAyLjAgOiBNYXRoLlBJIC8gMi4wO1xuICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcbiAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShzaWRlcyAqIDIpO1xuICB2YXIgY3VycmVudEFuZ2xlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICBjdXJyZW50QW5nbGUgPSBpICogaW5jcmVtZW50ICsgc3RhcnRBbmdsZTtcbiAgICBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsgLy8geFxuICAgIHBvaW50c1syICogaSArIDFdID0gTWF0aC5zaW4oLWN1cnJlbnRBbmdsZSk7IC8vIHlcbiAgfVxuICByZXR1cm4gcG9pbnRzO1xufTtcblxuLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1cywgdW5sZXNzIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBkZWZhdWx0XG52YXIgZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xufTtcblxuLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1c1xudmFyIGdldFJvdW5kUG9seWdvblJhZGl1cyA9IGZ1bmN0aW9uIGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDEwLCBoZWlnaHQgLyAxMCwgOCk7XG59O1xudmFyIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCA9IGZ1bmN0aW9uIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIHtcbiAgcmV0dXJuIDg7XG59O1xudmFyIGJlemllclB0c1RvUXVhZENvZWZmID0gZnVuY3Rpb24gYmV6aWVyUHRzVG9RdWFkQ29lZmYocDAsIHAxLCBwMikge1xuICByZXR1cm4gW3AwIC0gMiAqIHAxICsgcDIsIDIgKiAocDEgLSBwMCksIHAwXTtcbn07XG5cbi8vIGdldCBjdXJ2ZSB3aWR0aCwgaGVpZ2h0LCBhbmQgY29udHJvbCBwb2ludCBwb3NpdGlvbiBvZmZzZXRzIGFzIGEgcGVyY2VudGFnZSBvZiBub2RlIGhlaWdodCAvIHdpZHRoXG52YXIgZ2V0QmFycmVsQ3VydmVDb25zdGFudHMgPSBmdW5jdGlvbiBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgaGVpZ2h0T2Zmc2V0OiBNYXRoLm1pbigxNSwgMC4wNSAqIGhlaWdodCksXG4gICAgd2lkdGhPZmZzZXQ6IE1hdGgubWluKDEwMCwgMC4yNSAqIHdpZHRoKSxcbiAgICBjdHJsUHRPZmZzZXRQY3Q6IDAuMDVcbiAgfTtcbn07XG5cbi8vIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtIChTQVQpIHRvIGRldGVybWluZSBpZiB0d28gcG9seWdvbnMgaW50ZXJzZWN0LiBcbi8vIFRoZSBmdW5jdGlvbiB0YWtlcyB0d28gcG9seWdvbnMgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgXG4vLyB3aGV0aGVyIHRoZSB0d28gcG9seWdvbnMgaW50ZXJzZWN0LlxuZnVuY3Rpb24gc2F0UG9seWdvbkludGVyc2VjdGlvbihwb2x5MSwgcG9seTIpIHtcbiAgZnVuY3Rpb24gZ2V0QXhlcyhwb2x5Z29uKSB7XG4gICAgdmFyIGF4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwMSA9IHBvbHlnb25baV07XG4gICAgICB2YXIgcDIgPSBwb2x5Z29uWyhpICsgMSkgJSBwb2x5Z29uLmxlbmd0aF07XG4gICAgICB2YXIgZWRnZSA9IHtcbiAgICAgICAgeDogcDIueCAtIHAxLngsXG4gICAgICAgIHk6IHAyLnkgLSBwMS55XG4gICAgICB9O1xuICAgICAgdmFyIG5vcm1hbCA9IHtcbiAgICAgICAgeDogLWVkZ2UueSxcbiAgICAgICAgeTogZWRnZS54XG4gICAgICB9O1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChub3JtYWwueCAqIG5vcm1hbC54ICsgbm9ybWFsLnkgKiBub3JtYWwueSk7XG4gICAgICBheGVzLnB1c2goe1xuICAgICAgICB4OiBub3JtYWwueCAvIGxlbmd0aCxcbiAgICAgICAgeTogbm9ybWFsLnkgLyBsZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXhlcztcbiAgfVxuICBmdW5jdGlvbiBwcm9qZWN0KHBvbHlnb24sIGF4aXMpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocG9seWdvbiksXG4gICAgICBfc3RlcDtcbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gcG9pbnQueCAqIGF4aXMueCArIHBvaW50LnkgKiBheGlzLnk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcHJvamVjdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gb3ZlcmxhcHMocHJvajEsIHByb2oyKSB7XG4gICAgcmV0dXJuICEocHJvajEubWF4IDwgcHJvajIubWluIHx8IHByb2oyLm1heCA8IHByb2oxLm1pbik7XG4gIH1cbiAgdmFyIGF4ZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGdldEF4ZXMocG9seTEpKSwgX3RvQ29uc3VtYWJsZUFycmF5KGdldEF4ZXMocG9seTIpKSk7XG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXhlcyksXG4gICAgX3N0ZXAyO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYXhpcyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIHZhciBwcm9qMSA9IHByb2plY3QocG9seTEsIGF4aXMpO1xuICAgICAgdmFyIHByb2oyID0gcHJvamVjdChwb2x5MiwgYXhpcyk7XG4gICAgICBpZiAoIW92ZXJsYXBzKHByb2oxLCBwcm9qMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBvdmVybGFwLCBzbyB0aGUgcG9seWdvbnMgZG8gbm90IGludGVyc2VjdFxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7IC8vIHBvbHlnb25zIGludGVyc2VjdFxufVxuXG52YXIgcGFnZVJhbmtEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBkYW1waW5nRmFjdG9yOiAwLjgsXG4gIHByZWNpc2lvbjogMC4wMDAwMDEsXG4gIGl0ZXJhdGlvbnM6IDIwMCxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9XG59KTtcbnZhciBlbGVzZm4kbyA9IHtcbiAgcGFnZVJhbms6IGZ1bmN0aW9uIHBhZ2VSYW5rKG9wdGlvbnMpIHtcbiAgICB2YXIgX3BhZ2VSYW5rRGVmYXVsdHMgPSBwYWdlUmFua0RlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgZGFtcGluZ0ZhY3RvciA9IF9wYWdlUmFua0RlZmF1bHRzLmRhbXBpbmdGYWN0b3IsXG4gICAgICBwcmVjaXNpb24gPSBfcGFnZVJhbmtEZWZhdWx0cy5wcmVjaXNpb24sXG4gICAgICBpdGVyYXRpb25zID0gX3BhZ2VSYW5rRGVmYXVsdHMuaXRlcmF0aW9ucyxcbiAgICAgIHdlaWdodCA9IF9wYWdlUmFua0RlZmF1bHRzLndlaWdodDtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1Ob2Rlc1NxZCA9IG51bU5vZGVzICogbnVtTm9kZXM7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgIC8vIEZpcnN0IGxldHMgaGF2ZSBhIHplcm9lZCBtYXRyaXggb2YgdGhlIHJpZ2h0IHNpemVcbiAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgIHZhciBtYXRyaXggPSBuZXcgQXJyYXkobnVtTm9kZXNTcWQpO1xuICAgIHZhciBjb2x1bW5TdW0gPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgIC8vIENyZWF0ZSBudWxsIG1hdHJpeFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIHZhciBuID0gaSAqIG51bU5vZGVzICsgajtcbiAgICAgICAgbWF0cml4W25dID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbHVtblN1bVtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUVkZ2VzOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgIHZhciBzcmNJZCA9IGVkZ2UuZGF0YSgnc291cmNlJyk7XG4gICAgICB2YXIgdGd0SWQgPSBlZGdlLmRhdGEoJ3RhcmdldCcpO1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGxvb3BzIGluIHRoZSBtYXRyaXhcbiAgICAgIGlmIChzcmNJZCA9PT0gdGd0SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IG5vZGVzLmluZGV4T2ZJZChzcmNJZCk7XG4gICAgICB2YXIgdCA9IG5vZGVzLmluZGV4T2ZJZCh0Z3RJZCk7XG4gICAgICB2YXIgdyA9IHdlaWdodChlZGdlKTtcbiAgICAgIHZhciBfbiA9IHQgKiBudW1Ob2RlcyArIHM7XG5cbiAgICAgIC8vIFVwZGF0ZSBtYXRyaXhcbiAgICAgIG1hdHJpeFtfbl0gKz0gdztcblxuICAgICAgLy8gVXBkYXRlIGNvbHVtbiBzdW1cbiAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgIH1cblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG5cbiAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtTm9kZXM7IF9qKyspIHtcbiAgICAgIGlmIChjb2x1bW5TdW1bX2pdID09PSAwKSB7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bU5vZGVzOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbjIgPSBfaTIgKiBudW1Ob2RlcyArIF9qO1xuICAgICAgICAgIG1hdHJpeFtfbjJdID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbjMgPSBfaTMgKiBudW1Ob2RlcyArIF9qO1xuICAgICAgICAgIG1hdHJpeFtfbjNdID0gbWF0cml4W19uM10gLyBjb2x1bW5TdW1bX2pdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuICAgIHZhciBlaWdlbnZlY3RvciA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIHRlbXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBwcmV2aW91cztcblxuICAgIC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICBlaWdlbnZlY3RvcltfaTRdID0gMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBpdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAgIC8vIFRlbXAgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBudW1Ob2RlczsgX2k1KyspIHtcbiAgICAgICAgdGVtcFtfaTVdID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBudW1Ob2RlczsgX2k2KyspIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbnVtTm9kZXM7IF9qMisrKSB7XG4gICAgICAgICAgdmFyIF9uNCA9IF9pNiAqIG51bU5vZGVzICsgX2oyO1xuICAgICAgICAgIHRlbXBbX2k2XSArPSBtYXRyaXhbX240XSAqIGVpZ2VudmVjdG9yW19qMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluUGxhY2VTdW1Ob3JtYWxpemUodGVtcCk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuICAgICAgdGVtcCA9IHByZXZpb3VzO1xuICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG4gICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBudW1Ob2RlczsgX2k3KyspIHtcbiAgICAgICAgdmFyIGRlbHRhID0gcHJldmlvdXNbX2k3XSAtIGVpZ2VudmVjdG9yW19pN107XG4gICAgICAgIGRpZmYgKz0gZGVsdGEgKiBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgaWYgKGRpZmYgPCBwcmVjaXNpb24pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciByZXMgPSB7XG4gICAgICByYW5rOiBmdW5jdGlvbiByYW5rKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IGN5LmNvbGxlY3Rpb24obm9kZSlbMF07XG4gICAgICAgIHJldHVybiBlaWdlbnZlY3Rvcltub2Rlcy5pbmRleE9mKG5vZGUpXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH0gLy8gcGFnZVJhbmtcbn07IC8vIGVsZXNmblxuXG52YXIgZGVmYXVsdHMkZiA9IGRlZmF1bHRzJGcoe1xuICByb290OiBudWxsLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgYWxwaGE6IDBcbn0pO1xudmFyIGVsZXNmbiRuID0ge1xuICBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyRmKG9wdGlvbnMpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGlmICghb3B0aW9ucy5kaXJlY3RlZCkge1xuICAgICAgdmFyIGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhEZWdyZWUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuICAgICAgICBpZiAobWF4RGVncmVlIDwgY3VyckRlZ3JlZS5kZWdyZWUpIHtcbiAgICAgICAgICBtYXhEZWdyZWUgPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgICBkZWdyZWVzW25vZGUuaWQoKV0gPSBjdXJyRGVncmVlLmRlZ3JlZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heERlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICAgIHZhciBpZCA9IF9ub2RlLmlkKCk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG4gICAgICAgIG9wdGlvbnMucm9vdCA9IF9ub2RlO1xuICAgICAgICB2YXIgX2N1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG4gICAgICAgIGlmIChtYXhJbmRlZ3JlZSA8IF9jdXJyRGVncmVlLmluZGVncmVlKSBtYXhJbmRlZ3JlZSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICBpZiAobWF4T3V0ZGVncmVlIDwgX2N1cnJEZWdyZWUub3V0ZGVncmVlKSBtYXhPdXRkZWdyZWUgPSBfY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICAgIGluZGVncmVlc1tpZF0gPSBfY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1tpZF0gPSBfY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogZnVuY3Rpb24gaW5kZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhJbmRlZ3JlZSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZGVncmVlc1tub2RlLmlkKCldIC8gbWF4SW5kZWdyZWU7XG4gICAgICAgIH0sXG4gICAgICAgIG91dGRlZ3JlZTogZnVuY3Rpb24gb3V0ZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4T3V0ZGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMkZihvcHRpb25zKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICB3ZWlnaHQgPSBfb3B0aW9ucy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9vcHRpb25zLmRpcmVjdGVkLFxuICAgICAgYWxwaGEgPSBfb3B0aW9ucy5hbHBoYTtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcbiAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihjYWxsaW5nRWxlcyk7XG4gICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcyArPSB3ZWlnaHQoY29ubkVkZ2VzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGluY29taW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRhcmdldCgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2Uuc291cmNlKCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNvbWluZy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHNfaW4gKz0gd2VpZ2h0KGluY29taW5nW19pMl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIHN1bSBvdXRnb2luZyBlZGdlIHdlaWdodHNcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG91dGdvaW5nLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0KG91dGdvaW5nW19pM10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IE1hdGgucG93KGtfaW4sIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX2luLCBhbHBoYSksXG4gICAgICAgIG91dGRlZ3JlZTogTWF0aC5wb3coa19vdXQsIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX291dCwgYWxwaGEpXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBkZWdyZWVDZW50cmFsaXR5XG59OyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5lbGVzZm4kbi5kYyA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHk7XG5lbGVzZm4kbi5kY24gPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG52YXIgZGVmYXVsdHMkZSA9IGRlZmF1bHRzJGcoe1xuICBoYXJtb25pYzogdHJ1ZSxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJG0gPSB7XG4gIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJGUob3B0aW9ucyksXG4gICAgICBoYXJtb25pYyA9IF9kZWZhdWx0cy5oYXJtb25pYyxcbiAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZDtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGNsb3NlbmVzc2VzID0ge307XG4gICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBmdyA9IHRoaXMuZmxveWRXYXJzaGFsbCh7XG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pO1xuXG4gICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgdmFyIG5vZGVfaSA9IG5vZGVzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2Uobm9kZV9pLCBub2Rlc1tqXSk7XG4gICAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhcm1vbmljKSB7XG4gICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cbiAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKSB7XG4gICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgICBjbG9zZW5lc3Nlc1tub2RlX2kuaWQoKV0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiBjbG9zZW5lc3Mobm9kZSkge1xuICAgICAgICBpZiAobWF4Q2xvc2VuZXNzID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSlbMF0uaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBjbG9zZW5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzMiA9IGRlZmF1bHRzJGUob3B0aW9ucyksXG4gICAgICByb290ID0gX2RlZmF1bHRzMi5yb290LFxuICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzMi53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0czIuZGlyZWN0ZWQsXG4gICAgICBoYXJtb25pYyA9IF9kZWZhdWx0czIuaGFybW9uaWM7XG4gICAgcm9vdCA9IHRoaXMuZmlsdGVyKHJvb3QpWzBdO1xuXG4gICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSh7XG4gICAgICByb290OiByb290LFxuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTtcbiAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgICBpZiAoIW4uc2FtZShyb290KSkge1xuICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8obik7XG4gICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgfSAvLyBjbG9zZW5lc3NDZW50cmFsaXR5XG59OyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5lbGVzZm4kbS5jYyA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHk7XG5lbGVzZm4kbS5jY24gPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG52YXIgZGVmYXVsdHMkZCA9IGRlZmF1bHRzJGcoe1xuICB3ZWlnaHQ6IG51bGwsXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJGwgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiB0aGUgcGFwZXIgXCJPbiBWYXJpYW50cyBvZiBTaG9ydGVzdC1QYXRoIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgYW5kIHRoZWlyIEdlbmVyaWMgQ29tcHV0YXRpb25cIiBieSBVbHJpayBCcmFuZGVzXG4gIGJldHdlZW5uZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gYmV0d2Vlbm5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkZChvcHRpb25zKSxcbiAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodDtcbiAgICB2YXIgd2VpZ2h0ZWQgPSB3ZWlnaHQgIT0gbnVsbDtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAvLyBzdGFydGluZ1xuICAgIHZhciBWID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBBID0ge307XG4gICAgdmFyIF9DID0ge307XG4gICAgdmFyIG1heCA9IDA7XG4gICAgdmFyIEMgPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICBfQ1trZXldID0gdmFsO1xuICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfQ1trZXldO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2ID0gVltpXTtcbiAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgQVt2aWRdID0gdi5vdXRnb2VycygpLm5vZGVzKCk7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBW3ZpZF0gPSB2Lm9wZW5OZWlnaGJvcmhvb2QoKS5ub2RlcygpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH1cbiAgICAgIEMuc2V0KHZpZCwgMCk7XG4gICAgfVxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIHNpZCA9IFZbc10uaWQoKTtcbiAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBkW2FdIC0gZFtiXTtcbiAgICAgIH0pOyAvLyBxdWV1ZVxuXG4gICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFYubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfdmlkID0gVltfaV0uaWQoKTtcbiAgICAgICAgUFtfdmlkXSA9IFtdO1xuICAgICAgICBnW192aWRdID0gMDtcbiAgICAgICAgZFtfdmlkXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgZ1tzaWRdID0gMTsgLy8gc2lnbWFcbiAgICAgIGRbc2lkXSA9IDA7IC8vIGRpc3RhbmNlIHRvIHNcblxuICAgICAgUS5wdXNoKHNpZCk7XG4gICAgICB3aGlsZSAoIVEuZW1wdHkoKSkge1xuICAgICAgICB2YXIgX3YgPSBRLnBvcCgpO1xuICAgICAgICBTLnB1c2goX3YpO1xuICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEFbX3ZdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IEFbX3ZdW2pdO1xuICAgICAgICAgICAgdmFyIHZFbGUgPSBjeS5nZXRFbGVtZW50QnlJZChfdik7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh2RWxlLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyh2RWxlKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0KGVkZ2UpO1xuICAgICAgICAgICAgdyA9IHcuaWQoKTtcbiAgICAgICAgICAgIGlmIChkW3ddID4gZFtfdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGRbd10gPSBkW192XSArIGVkZ2VXZWlnaHQ7XG4gICAgICAgICAgICAgIGlmIChRLm5vZGVzLmluZGV4T2YodykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0odyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ1t3XSA9IDA7XG4gICAgICAgICAgICAgIFBbd10gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkW3ddID09IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBnW3ddID0gZ1t3XSArIGdbX3ZdO1xuICAgICAgICAgICAgICBQW3ddLnB1c2goX3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgQVtfdl0ubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICB2YXIgX3cgPSBBW192XVtfal0uaWQoKTtcbiAgICAgICAgICAgIGlmIChkW193XSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBRLnB1c2goX3cpO1xuICAgICAgICAgICAgICBkW193XSA9IGRbX3ZdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkW193XSA9PSBkW192XSArIDEpIHtcbiAgICAgICAgICAgICAgZ1tfd10gPSBnW193XSArIGdbX3ZdO1xuICAgICAgICAgICAgICBQW193XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlID0ge307XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBWLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgZVtWW19pMl0uaWQoKV0gPSAwO1xuICAgICAgfVxuICAgICAgd2hpbGUgKFMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3cyID0gUy5wb3AoKTtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgUFtfdzJdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3YyID0gUFtfdzJdW19qMl07XG4gICAgICAgICAgZVtfdjJdID0gZVtfdjJdICsgZ1tfdjJdIC8gZ1tfdzJdICogKDEgKyBlW193Ml0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdzIgIT0gVltzXS5pZCgpKSB7XG4gICAgICAgICAgQy5zZXQoX3cyLCBDLmdldChfdzIpICsgZVtfdzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBWLmxlbmd0aDsgcysrKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgYmV0d2Vlbm5lc3M6IGZ1bmN0aW9uIGJldHdlZW5uZXNzKG5vZGUpIHtcbiAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICByZXR1cm4gQy5nZXQoaWQpO1xuICAgICAgfSxcbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gYmV0d2Vlbm5lc3NOb3JtYWxpemVkKG5vZGUpIHtcbiAgICAgICAgaWYgKG1heCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICByZXR1cm4gQy5nZXQoaWQpIC8gbWF4O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhbGlhc1xuICAgIHJldC5iZXR3ZWVubmVzc05vcm1hbGlzZWQgPSByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpemVkO1xuICAgIHJldHVybiByZXQ7XG4gIH0gLy8gYmV0d2Vlbm5lc3NDZW50cmFsaXR5XG59OyAvLyBlbGVzZm5cblxuLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5lbGVzZm4kbC5iYyA9IGVsZXNmbiRsLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3l0b3NjYXBlL2N5dG9zY2FwZS5qcy1tYXJrb3YtY2x1c3RlclxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZGVmYXVsdHMkYyA9IGRlZmF1bHRzJGcoe1xuICBleHBhbmRGYWN0b3I6IDIsXG4gIC8vIGFmZmVjdHMgdGltZSBvZiBjb21wdXRhdGlvbiBhbmQgY2x1c3RlciBncmFudWxhcml0eSB0byBzb21lIGV4dGVudDogTSAqIE1cbiAgaW5mbGF0ZUZhY3RvcjogMixcbiAgLy8gYWZmZWN0cyBjbHVzdGVyIGdyYW51bGFyaXR5ICh0aGUgZ3JlYXRlciB0aGUgdmFsdWUsIHRoZSBtb3JlIGNsdXN0ZXJzKTogTShpLGopIC8gRShqKVxuICBtdWx0RmFjdG9yOiAxLFxuICAvLyBvcHRpb25hbCBzZWxmIGxvb3BzIGZvciBlYWNoIG5vZGUuIFVzZSBhIG5ldXRyYWwgdmFsdWUgdG8gaW1wcm92ZSBjbHVzdGVyIGNvbXB1dGF0aW9ucy5cbiAgbWF4SXRlcmF0aW9uczogMjAsXG4gIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgb2YgdGhlIE1DTCBhbGdvcml0aG0gaW4gYSBzaW5nbGUgcnVuXG4gIGF0dHJpYnV0ZXM6IFtcbiAgLy8gYXR0cmlidXRlcy9mZWF0dXJlcyB1c2VkIHRvIGdyb3VwIG5vZGVzLCBpZS4gc2ltaWxhcml0eSB2YWx1ZXMgYmV0d2VlbiBub2Rlc1xuICBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9XVxufSk7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBzZXRPcHRpb25zJDMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlZmF1bHRzJGMob3B0aW9ucyk7XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgZ2V0U2ltaWxhcml0eSQxID0gZnVuY3Rpb24gZ2V0U2ltaWxhcml0eShlZGdlLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciB0b3RhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHRvdGFsICs9IGF0dHJpYnV0ZXNbaV0oZWRnZSk7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufTtcbnZhciBhZGRMb29wcyA9IGZ1bmN0aW9uIGFkZExvb3BzKE0sIG4sIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIE1baSAqIG4gKyBpXSA9IHZhbDtcbiAgfVxufTtcbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoTSwgbikge1xuICB2YXIgc3VtO1xuICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBuOyBjb2wrKykge1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbjsgcm93KyspIHtcbiAgICAgIHN1bSArPSBNW3JvdyAqIG4gKyBjb2xdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfcm93ID0gMDsgX3JvdyA8IG47IF9yb3crKykge1xuICAgICAgTVtfcm93ICogbiArIGNvbF0gPSBNW19yb3cgKiBuICsgY29sXSAvIHN1bTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFRPRE86IGJsb2NrZWQgbWF0cml4IG11bHRpcGxpY2F0aW9uP1xudmFyIG1tdWx0ID0gZnVuY3Rpb24gbW11bHQoQSwgQiwgbikge1xuICB2YXIgQyA9IG5ldyBBcnJheShuICogbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIENbaSAqIG4gKyBqXSA9IDA7XG4gICAgfVxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICBDW2kgKiBuICsgX2pdICs9IEFbaSAqIG4gKyBrXSAqIEJbayAqIG4gKyBfal07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBDO1xufTtcbnZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQoTSwgbiwgZXhwYW5kRmFjdG9yIC8qKiBwb3dlciAqKi8pIHtcbiAgdmFyIF9NID0gTS5zbGljZSgwKTtcbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBleHBhbmRGYWN0b3I7IHArKykge1xuICAgIE0gPSBtbXVsdChNLCBfTSwgbik7XG4gIH1cbiAgcmV0dXJuIE07XG59O1xudmFyIGluZmxhdGUgPSBmdW5jdGlvbiBpbmZsYXRlKE0sIG4sIGluZmxhdGVGYWN0b3IgLyoqIHIgKiovKSB7XG4gIHZhciBfTSA9IG5ldyBBcnJheShuICogbik7XG5cbiAgLy8gTShpLGopIF4gaW5mbGF0ZVBvd2VyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbiAqIG47IGkrKykge1xuICAgIF9NW2ldID0gTWF0aC5wb3coTVtpXSwgaW5mbGF0ZUZhY3Rvcik7XG4gIH1cbiAgbm9ybWFsaXplKF9NLCBuKTtcbiAgcmV0dXJuIF9NO1xufTtcbnZhciBoYXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXNDb252ZXJnZWQoTSwgX00sIG4yLCByb3VuZEZhY3Rvcikge1xuICAvLyBDaGVjayB0aGF0IGJvdGggbWF0cmljZXMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyAoaSxqKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG4yOyBpKyspIHtcbiAgICB2YXIgdjEgPSBNYXRoLnJvdW5kKE1baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7IC8vIHRydW5jYXRlIHRvICdyb3VuZEZhY3RvcicgZGVjaW1hbCBwbGFjZXNcbiAgICB2YXIgdjIgPSBNYXRoLnJvdW5kKF9NW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpO1xuICAgIGlmICh2MSAhPT0gdjIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGFzc2lnbiQyID0gZnVuY3Rpb24gYXNzaWduKE0sIG4sIG5vZGVzLCBjeSkge1xuICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgY2x1c3RlciA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAvLyBSb3ctd2lzZSBhdHRyYWN0b3JzIGFuZCBlbGVtZW50cyB0aGF0IHRoZXkgYXR0cmFjdCBiZWxvbmcgaW4gc2FtZSBjbHVzdGVyXG4gICAgICBpZiAoTWF0aC5yb3VuZChNW2kgKiBuICsgal0gKiAxMDAwKSAvIDEwMDAgPiAwKSB7XG4gICAgICAgIGNsdXN0ZXIucHVzaChub2Rlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbHVzdGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY2x1c3RlcnMucHVzaChjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBpc0R1cGxpY2F0ZSA9IGZ1bmN0aW9uIGlzRHVwbGljYXRlKGMxLCBjMikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGMxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFjMltpXSB8fCBjMVtpXS5pZCgpICE9PSBjMltpXS5pZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciByZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGkgIT0gaiAmJiBpc0R1cGxpY2F0ZShjbHVzdGVyc1tpXSwgY2x1c3RlcnNbal0pKSB7XG4gICAgICAgIGNsdXN0ZXJzLnNwbGljZShqLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBtYXJrb3ZDbHVzdGVyaW5nID0gZnVuY3Rpb24gbWFya292Q2x1c3RlcmluZyhvcHRpb25zKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOlxuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMyhvcHRpb25zKTtcblxuICAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG4gIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgc3RvY2hhc3RpYyBtYXRyaXggTSBmcm9tIGlucHV0IGdyYXBoIEcgKHNob3VsZCBiZSBzeW1tZXRyaWMvdW5kaXJlY3RlZClcbiAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgbjIgPSBuICogbjtcbiAgdmFyIE0gPSBuZXcgQXJyYXkobjIpLFxuICAgIF9NO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjI7IF9pKyspIHtcbiAgICBNW19pXSA9IDA7XG4gIH1cbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbZV07XG4gICAgdmFyIF9pMiA9IGlkMnBvc2l0aW9uW2VkZ2Uuc291cmNlKCkuaWQoKV07XG4gICAgdmFyIGogPSBpZDJwb3NpdGlvbltlZGdlLnRhcmdldCgpLmlkKCldO1xuICAgIHZhciBzaW0gPSBnZXRTaW1pbGFyaXR5JDEoZWRnZSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICBNW19pMiAqIG4gKyBqXSArPSBzaW07IC8vIEcgc2hvdWxkIGJlIHN5bW1ldHJpYyBhbmQgdW5kaXJlY3RlZFxuICAgIE1baiAqIG4gKyBfaTJdICs9IHNpbTtcbiAgfVxuXG4gIC8vIEJlZ2luIE1hcmtvdiBjbHVzdGVyIGFsZ29yaXRobVxuXG4gIC8vIFN0ZXAgMTogQWRkIHNlbGYgbG9vcHMgdG8gZWFjaCBub2RlLCBpZS4gYWRkIG11bHRGYWN0b3IgdG8gbWF0cml4IGRpYWdvbmFsXG4gIGFkZExvb3BzKE0sIG4sIG9wdHMubXVsdEZhY3Rvcik7XG5cbiAgLy8gU3RlcCAyOiBNID0gbm9ybWFsaXplKCBNICk7XG4gIG5vcm1hbGl6ZShNLCBuKTtcbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG5cbiAgICAvLyBTdGVwIDM6XG4gICAgX00gPSBleHBhbmQoTSwgbiwgb3B0cy5leHBhbmRGYWN0b3IpO1xuXG4gICAgLy8gU3RlcCA0OlxuICAgIE0gPSBpbmZsYXRlKF9NLCBuLCBvcHRzLmluZmxhdGVGYWN0b3IpO1xuXG4gICAgLy8gU3RlcCA1OiBjaGVjayB0byBzZWUgaWYgfnN0ZWFkeSBzdGF0ZSBoYXMgYmVlbiByZWFjaGVkXG4gICAgaWYgKCFoYXNDb252ZXJnZWQoTSwgX00sIG4yLCA0KSkge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgfVxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIC8vIEJ1aWxkIGNsdXN0ZXJzIGZyb20gbWF0cml4XG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbiQyKE0sIG4sIG5vZGVzLCBjeSk7XG5cbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBjbHVzdGVycyBkdWUgdG8gc3ltbWV0cnkgb2YgZ3JhcGggYW5kIE0gbWF0cml4XG4gIGNsdXN0ZXJzID0gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycyk7XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgbWFya292Q2x1c3RlcmluZyQxID0ge1xuICBtYXJrb3ZDbHVzdGVyaW5nOiBtYXJrb3ZDbHVzdGVyaW5nLFxuICBtY2w6IG1hcmtvdkNsdXN0ZXJpbmdcbn07XG5cbi8vIENvbW1vbiBkaXN0YW5jZSBtZXRyaWNzIGZvciBjbHVzdGVyaW5nIGFsZ29yaXRobXNcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hpZXJhcmNoaWNhbF9jbHVzdGVyaW5nI01ldHJpY1xuXG52YXIgaWRlbnRpdHkkMSA9IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59O1xudmFyIGFic0RpZmYgPSBmdW5jdGlvbiBhYnNEaWZmKHAsIHEpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHEgLSBwKTtcbn07XG52YXIgYWRkQWJzRGlmZiA9IGZ1bmN0aW9uIGFkZEFic0RpZmYodG90YWwsIHAsIHEpIHtcbiAgcmV0dXJuIHRvdGFsICsgYWJzRGlmZihwLCBxKTtcbn07XG52YXIgYWRkU3F1YXJlZERpZmYgPSBmdW5jdGlvbiBhZGRTcXVhcmVkRGlmZih0b3RhbCwgcCwgcSkge1xuICByZXR1cm4gdG90YWwgKyBNYXRoLnBvdyhxIC0gcCwgMik7XG59O1xudmFyIHNxcnQgPSBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh4KTtcbn07XG52YXIgbWF4QWJzRGlmZiA9IGZ1bmN0aW9uIG1heEFic0RpZmYoY3VycmVudE1heCwgcCwgcSkge1xuICByZXR1cm4gTWF0aC5tYXgoY3VycmVudE1heCwgYWJzRGlmZihwLCBxKSk7XG59O1xudmFyIGdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCBpbml0LCB2aXNpdCkge1xuICB2YXIgcG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogaWRlbnRpdHkkMTtcbiAgdmFyIHJldCA9IGluaXQ7XG4gIHZhciBwLCBxO1xuICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBsZW5ndGg7IGRpbSsrKSB7XG4gICAgcCA9IGdldFAoZGltKTtcbiAgICBxID0gZ2V0UShkaW0pO1xuICAgIHJldCA9IHZpc2l0KHJldCwgcCwgcSk7XG4gIH1cbiAgcmV0dXJuIHBvc3QocmV0KTtcbn07XG52YXIgZGlzdGFuY2VzID0ge1xuICBldWNsaWRlYW46IGZ1bmN0aW9uIGV1Y2xpZGVhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmLCBzcXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIHNpbmdsZSBhdHRyIGNhc2UsIG1vcmUgZWZmaWNpZW50IHRvIGF2b2lkIHNxcnRcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZEFic0RpZmYpO1xuICAgIH1cbiAgfSxcbiAgc3F1YXJlZEV1Y2xpZGVhbjogZnVuY3Rpb24gc3F1YXJlZEV1Y2xpZGVhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZik7XG4gIH0sXG4gIG1hbmhhdHRhbjogZnVuY3Rpb24gbWFuaGF0dGFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZEFic0RpZmYpO1xuICB9LFxuICBtYXg6IGZ1bmN0aW9uIG1heChsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAtSW5maW5pdHksIG1heEFic0RpZmYpO1xuICB9XG59O1xuXG4vLyBpbiBjYXNlIHRoZSB1c2VyIGFjY2lkZW50YWxseSBkb2Vzbid0IHVzZSBjYW1lbCBjYXNlXG5kaXN0YW5jZXNbJ3NxdWFyZWQtZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbmRpc3RhbmNlc1snc3F1YXJlZGV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG5mdW5jdGlvbiBjbHVzdGVyaW5nRGlzdGFuY2UgKG1ldGhvZCwgbGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpIHtcbiAgdmFyIGltcGw7XG4gIGlmIChmbiQ2KG1ldGhvZCkpIHtcbiAgICBpbXBsID0gbWV0aG9kO1xuICB9IGVsc2Uge1xuICAgIGltcGwgPSBkaXN0YW5jZXNbbWV0aG9kXSB8fCBkaXN0YW5jZXMuZXVjbGlkZWFuO1xuICB9XG4gIGlmIChsZW5ndGggPT09IDAgJiYgZm4kNihtZXRob2QpKSB7XG4gICAgcmV0dXJuIGltcGwobm9kZVAsIG5vZGVRKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW1wbChsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzJGIgPSBkZWZhdWx0cyRnKHtcbiAgazogMixcbiAgbTogMixcbiAgc2Vuc2l0aXZpdHlUaHJlc2hvbGQ6IDAuMDAwMSxcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICBtYXhJdGVyYXRpb25zOiAxMCxcbiAgYXR0cmlidXRlczogW10sXG4gIHRlc3RNb2RlOiBmYWxzZSxcbiAgdGVzdENlbnRyb2lkczogbnVsbFxufSk7XG52YXIgc2V0T3B0aW9ucyQyID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBkZWZhdWx0cyRiKG9wdGlvbnMpO1xufTtcblxudmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KHR5cGUsIG5vZGUsIGNlbnRyb2lkLCBhdHRyaWJ1dGVzLCBtb2RlKSB7XG4gIHZhciBub05vZGVQID0gbW9kZSAhPT0gJ2tNZWRvaWRzJztcbiAgdmFyIGdldFAgPSBub05vZGVQID8gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gY2VudHJvaWRbaV07XG4gIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKGNlbnRyb2lkKTtcbiAgfTtcbiAgdmFyIGdldFEgPSBmdW5jdGlvbiBnZXRRKGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShub2RlKTtcbiAgfTtcbiAgdmFyIG5vZGVQID0gY2VudHJvaWQ7XG4gIHZhciBub2RlUSA9IG5vZGU7XG4gIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG59O1xudmFyIHJhbmRvbUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHJhbmRvbUNlbnRyb2lkcyhub2RlcywgaywgYXR0cmlidXRlcykge1xuICB2YXIgbmRpbSA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICB2YXIgbWluID0gbmV3IEFycmF5KG5kaW0pO1xuICB2YXIgbWF4ID0gbmV3IEFycmF5KG5kaW0pO1xuICB2YXIgY2VudHJvaWRzID0gbmV3IEFycmF5KGspO1xuICB2YXIgY2VudHJvaWQgPSBudWxsO1xuXG4gIC8vIEZpbmQgbWluLCBtYXggdmFsdWVzIGZvciBlYWNoIGF0dHJpYnV0ZSBkaW1lbnNpb25cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZGltOyBpKyspIHtcbiAgICBtaW5baV0gPSBub2Rlcy5taW4oYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gICAgbWF4W2ldID0gbm9kZXMubWF4KGF0dHJpYnV0ZXNbaV0pLnZhbHVlO1xuICB9XG5cbiAgLy8gQnVpbGQgayBjZW50cm9pZHMsIGVhY2ggcmVwcmVzZW50ZWQgYXMgYW4gbi1kaW0gZmVhdHVyZSB2ZWN0b3JcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBrOyBjKyspIHtcbiAgICBjZW50cm9pZCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZGltOyBfaSsrKSB7XG4gICAgICBjZW50cm9pZFtfaV0gPSBNYXRoLnJhbmRvbSgpICogKG1heFtfaV0gLSBtaW5bX2ldKSArIG1pbltfaV07IC8vIHJhbmRvbSBpbml0aWFsIHZhbHVlXG4gICAgfVxuICAgIGNlbnRyb2lkc1tjXSA9IGNlbnRyb2lkO1xuICB9XG4gIHJldHVybiBjZW50cm9pZHM7XG59O1xudmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBkaXN0YW5jZSwgYXR0cmlidXRlcywgdHlwZSkge1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3QgPSBnZXREaXN0KGRpc3RhbmNlLCBub2RlLCBjZW50cm9pZHNbaV0sIGF0dHJpYnV0ZXMsIHR5cGUpO1xuICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICBtaW4gPSBkaXN0O1xuICAgICAgaW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xudmFyIGJ1aWxkQ2x1c3RlciA9IGZ1bmN0aW9uIGJ1aWxkQ2x1c3RlcihjZW50cm9pZCwgbm9kZXMsIGFzc2lnbm1lbnQpIHtcbiAgdmFyIGNsdXN0ZXIgPSBbXTtcbiAgdmFyIG5vZGUgPSBudWxsO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgbm9kZSA9IG5vZGVzW25dO1xuICAgIGlmIChhc3NpZ25tZW50W25vZGUuaWQoKV0gPT09IGNlbnRyb2lkKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiTm9kZSBcIiArIG5vZGUuaWQoKSArIFwiIGlzIGFzc29jaWF0ZWQgd2l0aCBtZWRvaWQgIzogXCIgKyBtKTtcbiAgICAgIGNsdXN0ZXIucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXI7XG59O1xudmFyIGhhdmVWYWx1ZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlVmFsdWVzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHYyIC0gdjEpIDw9IHNlbnNpdGl2aXR5VGhyZXNob2xkO1xufTtcbnZhciBoYXZlTWF0cmljZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlTWF0cmljZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB2MVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh2MVtpXVtqXSAtIHYyW2ldW2pdKTtcbiAgICAgIGlmIChkaWZmID4gc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgc2VlbkJlZm9yZSA9IGZ1bmN0aW9uIHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChub2RlID09PSBtZWRvaWRzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIHJhbmRvbU1lZG9pZHMgPSBmdW5jdGlvbiByYW5kb21NZWRvaWRzKG5vZGVzLCBrKSB7XG4gIHZhciBtZWRvaWRzID0gbmV3IEFycmF5KGspO1xuXG4gIC8vIEZvciBzbWFsbCBkYXRhIHNldHMsIHRoZSBwcm9iYWJpbGl0eSBvZiBtZWRvaWQgY29uZmxpY3QgaXMgZ3JlYXRlcixcbiAgLy8gc28gd2UgbmVlZCB0byBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBzZWVuIG9yIGNob3NlIHRoaXMgbm9kZSBiZWZvcmUuXG4gIGlmIChub2Rlcy5sZW5ndGggPCA1MCkge1xuICAgIC8vIFJhbmRvbWx5IHNlbGVjdCBrIG1lZG9pZHMgZnJvbSB0aGUgbiBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNob3NlbiB0aGlzIG5vZGUgdG8gYmUgYSBtZWRvaWQsIGRvbid0IGNob29zZSBpdCBhZ2FpbiAoZm9yIHNtYWxsIGRhdGEgc2V0cykuXG4gICAgICAvLyBJbnN0ZWFkIGNob29zZSBhIGRpZmZlcmVudCByYW5kb20gbm9kZS5cbiAgICAgIHdoaWxlIChzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIGkpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICAgIH1cbiAgICAgIG1lZG9pZHNbaV0gPSBub2RlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZWxhdGl2ZWx5IGxhcmdlIGRhdGEgc2V0LCBzbyBwcmV0dHkgc2FmZSB0byBub3QgY2hlY2sgYW5kIGp1c3Qgc2VsZWN0IHJhbmRvbSBub2Rlc1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGs7IF9pMisrKSB7XG4gICAgICBtZWRvaWRzW19pMl0gPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lZG9pZHM7XG59O1xudmFyIGZpbmRDb3N0ID0gZnVuY3Rpb24gZmluZENvc3QocG90ZW50aWFsTmV3TWVkb2lkLCBjbHVzdGVyLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBjb3N0ID0gMDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVyLmxlbmd0aDsgbisrKSB7XG4gICAgY29zdCArPSBnZXREaXN0KCdtYW5oYXR0YW4nLCBjbHVzdGVyW25dLCBwb3RlbnRpYWxOZXdNZWRvaWQsIGF0dHJpYnV0ZXMsICdrTWVkb2lkcycpO1xuICB9XG4gIHJldHVybiBjb3N0O1xufTtcbnZhciBrTWVhbnMgPSBmdW5jdGlvbiBrTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG5vZGUgPSBudWxsO1xuXG4gIC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTogIyBvZiBjbHVzdGVycywgZGlzdGFuY2UgbWV0cmljLCBldGMuXG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpO1xuXG4gIC8vIEJlZ2luIGstbWVhbnMgYWxnb3JpdGhtXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICB2YXIgY2VudHJvaWRzO1xuXG4gIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBjZW50cm9pZCBwb3NpdGlvbnNcbiAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCBhIHNlZWRlZCByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgIG9wdHMudGVzdENlbnRyb2lkcztcbiAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgY2VudHJvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gIH1cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAvLyBTdGVwIDI6IEFzc2lnbiBub2RlcyB0byB0aGUgbmVhcmVzdCBjZW50cm9pZFxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBvcHRzLmRpc3RhbmNlLCBvcHRzLmF0dHJpYnV0ZXMsICdrTWVhbnMnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDM6IEZvciBlYWNoIG9mIHRoZSBrIGNsdXN0ZXJzLCB1cGRhdGUgaXRzIGNlbnRyb2lkXG4gICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3B0cy5rOyBjKyspIHtcbiAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBjbHVzdGVyXG4gICAgICB2YXIgY2x1c3RlciA9IGJ1aWxkQ2x1c3RlcihjLCBub2RlcywgYXNzaWdubWVudCk7XG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjZW50cm9pZHMgYnkgY2FsY3VsYXRpbmcgYXZnIG9mIGFsbCBub2RlcyB3aXRoaW4gdGhlIGNsdXN0ZXIuXG4gICAgICB2YXIgbmRpbSA9IG9wdHMuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICB2YXIgY2VudHJvaWQgPSBjZW50cm9pZHNbY107IC8vIFsgZGltXzEsIGRpbV8yLCBkaW1fMywgLi4uICwgZGltX24gXVxuICAgICAgdmFyIG5ld0NlbnRyb2lkID0gbmV3IEFycmF5KG5kaW0pO1xuICAgICAgdmFyIHN1bSA9IG5ldyBBcnJheShuZGltKTtcbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbmRpbTsgZCsrKSB7XG4gICAgICAgIHN1bVtkXSA9IDAuMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IGNsdXN0ZXJbaV07XG4gICAgICAgICAgc3VtW2RdICs9IG9wdHMuYXR0cmlidXRlc1tkXShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdDZW50cm9pZFtkXSA9IHN1bVtkXSAvIGNsdXN0ZXIubGVuZ3RoO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhbGdvcml0aG0gaGFzIGNvbnZlcmdlZCwgaS5lLiB3aGVuIGNlbnRyb2lkcyBubyBsb25nZXIgY2hhbmdlXG4gICAgICAgIGlmICghaGF2ZVZhbHVlc0NvbnZlcmdlZChuZXdDZW50cm9pZFtkXSwgY2VudHJvaWRbZF0sIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNlbnRyb2lkc1tjXSA9IG5ld0NlbnRyb2lkO1xuICAgICAgY2x1c3RlcnNbY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpO1xuICAgIH1cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBrTWVkb2lkcyA9IGZ1bmN0aW9uIGtNZWRvaWRzKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBub2RlID0gbnVsbDtcbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7XG5cbiAgLy8gQmVnaW4gay1tZWRvaWRzIGFsZ29yaXRobVxuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgdmFyIG1lZG9pZHM7XG4gIHZhciBhc3NpZ25tZW50ID0ge307XG4gIHZhciBjdXJDb3N0O1xuICB2YXIgbWluQ29zdHMgPSBuZXcgQXJyYXkob3B0cy5rKTsgLy8gbWluaW11bSBjb3N0IGNvbmZpZ3VyYXRpb24gZm9yIGVhY2ggY2x1c3RlclxuXG4gIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBrIG1lZG9pZHNcbiAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIDsgZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgbWVkb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICB9XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgbWVkb2lkXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dO1xuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhpcyBub2RlIGJlbG9uZ3MgdG86IG5vZGUgaWQgPT4gY2x1c3RlciAjXG4gICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBtZWRvaWRzLCBvcHRzLmRpc3RhbmNlLCBvcHRzLmF0dHJpYnV0ZXMsICdrTWVkb2lkcycpO1xuICAgIH1cbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG4gICAgLy8gU3RlcCAzOiBGb3IgZWFjaCBtZWRvaWQgbSwgYW5kIGZvciBlYWNoIG5vZGUgYXNzb2NpYXRlZCB3aXRoIG1lZGlvZCBtLFxuICAgIC8vIHNlbGVjdCB0aGUgbm9kZSB3aXRoIHRoZSBsb3dlc3QgY29uZmlndXJhdGlvbiBjb3N0IGFzIG5ldyBtZWRvaWQuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBtZWRvaWRzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgbWVkb2lkXG4gICAgICB2YXIgY2x1c3RlciA9IGJ1aWxkQ2x1c3RlcihtLCBub2RlcywgYXNzaWdubWVudCk7XG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtaW5Db3N0c1ttXSA9IGZpbmRDb3N0KG1lZG9pZHNbbV0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7IC8vIG9yaWdpbmFsIGNvc3RcblxuICAgICAgLy8gU2VsZWN0IGRpZmZlcmVudCBtZWRvaWQgaWYgaXRzIGNvbmZpZ3VyYXRpb24gaGFzIHRoZSBsb3dlc3QgY29zdFxuICAgICAgZm9yICh2YXIgX24gPSAwOyBfbiA8IGNsdXN0ZXIubGVuZ3RoOyBfbisrKSB7XG4gICAgICAgIGN1ckNvc3QgPSBmaW5kQ29zdChjbHVzdGVyW19uXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGN1ckNvc3QgPCBtaW5Db3N0c1ttXSkge1xuICAgICAgICAgIG1pbkNvc3RzW21dID0gY3VyQ29zdDtcbiAgICAgICAgICBtZWRvaWRzW21dID0gY2x1c3Rlcltfbl07XG4gICAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNsdXN0ZXJzW21dID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICB9XG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgdXBkYXRlQ2VudHJvaWRzID0gZnVuY3Rpb24gdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cykge1xuICB2YXIgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgICB3ZWlnaHRbbl1bY10gPSBNYXRoLnBvdyhVW25dW2NdLCBvcHRzLm0pO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgY2VudHJvaWRzLmxlbmd0aDsgX2MrKykge1xuICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IG9wdHMuYXR0cmlidXRlcy5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBudW1lcmF0b3IgPSAwO1xuICAgICAgZGVub21pbmF0b3IgPSAwO1xuICAgICAgZm9yICh2YXIgX24yID0gMDsgX24yIDwgbm9kZXMubGVuZ3RoOyBfbjIrKykge1xuICAgICAgICBudW1lcmF0b3IgKz0gd2VpZ2h0W19uMl1bX2NdICogb3B0cy5hdHRyaWJ1dGVzW2RpbV0obm9kZXNbX24yXSk7XG4gICAgICAgIGRlbm9taW5hdG9yICs9IHdlaWdodFtfbjJdW19jXTtcbiAgICAgIH1cbiAgICAgIGNlbnRyb2lkc1tfY11bZGltXSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgIH1cbiAgfVxufTtcbnZhciB1cGRhdGVNZW1iZXJzaGlwID0gZnVuY3Rpb24gdXBkYXRlTWVtYmVyc2hpcChVLCBfVSwgY2VudHJvaWRzLCBub2Rlcywgb3B0cykge1xuICAvLyBTYXZlIHByZXZpb3VzIHN0ZXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBVLmxlbmd0aDsgaSsrKSB7XG4gICAgX1VbaV0gPSBVW2ldLnNsaWNlKCk7XG4gIH1cbiAgdmFyIHN1bSwgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcbiAgdmFyIHBvdyA9IDIgLyAob3B0cy5tIC0gMSk7XG4gIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY2VudHJvaWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIGFnYWluc3QgYWxsIG90aGVyIGNlbnRyb2lkc1xuICAgICAgICBudW1lcmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNbY10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICBkZW5vbWluYXRvciA9IGdldERpc3Qob3B0cy5kaXN0YW5jZSwgbm9kZXNbbl0sIGNlbnRyb2lkc1trXSwgb3B0cy5hdHRyaWJ1dGVzLCAnY21lYW5zJyk7XG4gICAgICAgIHN1bSArPSBNYXRoLnBvdyhudW1lcmF0b3IgLyBkZW5vbWluYXRvciwgcG93KTtcbiAgICAgIH1cbiAgICAgIFVbbl1bY10gPSAxIC8gc3VtO1xuICAgIH1cbiAgfVxufTtcbnZhciBhc3NpZ24kMSA9IGZ1bmN0aW9uIGFzc2lnbihub2RlcywgVSwgb3B0cywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIGZvciAodmFyIGMgPSAwOyBjIDwgY2x1c3RlcnMubGVuZ3RoOyBjKyspIHtcbiAgICBjbHVzdGVyc1tjXSA9IFtdO1xuICB9XG4gIHZhciBtYXg7XG4gIHZhciBpbmRleDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBVLmxlbmd0aDsgbisrKSB7XG4gICAgLy8gZm9yIGVhY2ggbm9kZSAoVSBpcyBOIHggQyBtYXRyaXgpXG4gICAgbWF4ID0gLUluZmluaXR5O1xuICAgIGluZGV4ID0gLTE7XG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhlIG5vZGUgaXMgbW9zdCBsaWtlbHkgdG8gYmVsb25nIGluXG4gICAgZm9yICh2YXIgX2MyID0gMDsgX2MyIDwgVVswXS5sZW5ndGg7IF9jMisrKSB7XG4gICAgICBpZiAoVVtuXVtfYzJdID4gbWF4KSB7XG4gICAgICAgIG1heCA9IFVbbl1bX2MyXTtcbiAgICAgICAgaW5kZXggPSBfYzI7XG4gICAgICB9XG4gICAgfVxuICAgIGNsdXN0ZXJzW2luZGV4XS5wdXNoKG5vZGVzW25dKTtcbiAgfVxuXG4gIC8vIFR1cm4gZXZlcnkgYXJyYXkgaW50byBhIGNvbGxlY3Rpb24gb2Ygbm9kZXNcbiAgZm9yICh2YXIgX2MzID0gMDsgX2MzIDwgY2x1c3RlcnMubGVuZ3RoOyBfYzMrKykge1xuICAgIGNsdXN0ZXJzW19jM10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW19jM10pO1xuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgZnV6enlDTWVhbnMgPSBmdW5jdGlvbiBmdXp6eUNNZWFucyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTtcblxuICAvLyBCZWdpbiBmdXp6eSBjLW1lYW5zIGFsZ29yaXRobVxuICB2YXIgY2x1c3RlcnM7XG4gIHZhciBjZW50cm9pZHM7XG4gIHZhciBVO1xuICB2YXIgX1U7XG4gIHZhciB3ZWlnaHQ7XG5cbiAgLy8gU3RlcCAxOiBJbml0aWFsaXplIGxldGlhYmxlcy5cbiAgX1UgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIE4geCBDIG1hdHJpeFxuICAgIF9VW2ldID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIH1cbiAgVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgVVtfaTNdID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIH1cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcHRzLms7IGorKykge1xuICAgICAgVVtfaTRdW2pdID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIHRvdGFsICs9IFVbX2k0XVtqXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG9wdHMuazsgX2orKykge1xuICAgICAgVVtfaTRdW19qXSA9IFVbX2k0XVtfal0gLyB0b3RhbDtcbiAgICB9XG4gIH1cbiAgY2VudHJvaWRzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG9wdHMuazsgX2k1KyspIHtcbiAgICBjZW50cm9pZHNbX2k1XSA9IG5ldyBBcnJheShvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgfVxuICB3ZWlnaHQgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbm9kZXMubGVuZ3RoOyBfaTYrKykge1xuICAgIC8vIE4geCBDIG1hdHJpeFxuICAgIHdlaWdodFtfaTZdID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIH1cbiAgLy8gZW5kIGluaXQgRkNNXG5cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG5cbiAgICAvLyBTdGVwIDI6IENhbGN1bGF0ZSB0aGUgY2VudHJvaWRzIGZvciBlYWNoIHN0ZXAuXG4gICAgdXBkYXRlQ2VudHJvaWRzKGNlbnRyb2lkcywgbm9kZXMsIFUsIHdlaWdodCwgb3B0cyk7XG5cbiAgICAvLyBTdGVwIDM6IFVwZGF0ZSB0aGUgcGFydGl0aW9uIG1hdHJpeCBVLlxuICAgIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpO1xuXG4gICAgLy8gU3RlcCA0OiBDaGVjayBmb3IgY29udmVyZ2VuY2UuXG4gICAgaWYgKCFoYXZlTWF0cmljZXNDb252ZXJnZWQoVSwgX1UsIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzIHdpdGggaGlnaGVzdCBwcm9iYWJpbGl0eS5cbiAgY2x1c3RlcnMgPSBhc3NpZ24kMShub2RlcywgVSwgb3B0cywgY3kpO1xuICByZXR1cm4ge1xuICAgIGNsdXN0ZXJzOiBjbHVzdGVycyxcbiAgICBkZWdyZWVPZk1lbWJlcnNoaXA6IFVcbiAgfTtcbn07XG52YXIga0NsdXN0ZXJpbmcgPSB7XG4gIGtNZWFuczoga01lYW5zLFxuICBrTWVkb2lkczoga01lZG9pZHMsXG4gIGZ1enp5Q01lYW5zOiBmdXp6eUNNZWFucyxcbiAgZmNtOiBmdXp6eUNNZWFuc1xufTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3l0b3NjYXBlL2N5dG9zY2FwZS5qcy1oaWVyYXJjaGljYWxcblxudmFyIGRlZmF1bHRzJGEgPSBkZWZhdWx0cyRnKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBub2Rlc1xuICBsaW5rYWdlOiAnbWluJyxcbiAgLy8gbGlua2FnZSBjcml0ZXJpb24gOiBob3cgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNsdXN0ZXJzIG9mIG5vZGVzXG4gIG1vZGU6ICd0aHJlc2hvbGQnLFxuICAvLyBtb2RlOid0aHJlc2hvbGQnID0+IGNsdXN0ZXJzIG11c3QgYmUgdGhyZXNob2xkIGRpc3RhbmNlIGFwYXJ0XG4gIHRocmVzaG9sZDogSW5maW5pdHksXG4gIC8vIHRoZSBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgLy8gbW9kZTonZGVuZHJvZ3JhbScgPT4gdGhlIG5vZGVzIGFyZSBvcmdhbmlzZWQgYXMgbGVhdmVzIGluIGEgdHJlZSAoc2libGluZ3MgYXJlIGNsb3NlKSwgbWVyZ2luZyBtYWtlcyBjbHVzdGVyc1xuICBhZGREZW5kcm9ncmFtOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBhZGQgdGhlIGRlbmRyb2dyYW0gdG8gdGhlIGdyYXBoIGZvciB2aXpcbiAgZGVuZHJvZ3JhbURlcHRoOiAwLFxuICAvLyBkZXB0aCBhdCB3aGljaCBkZW5kcm9ncmFtIGJyYW5jaGVzIGFyZSBtZXJnZWQgaW50byB0aGUgcmV0dXJuZWQgY2x1c3RlcnNcbiAgYXR0cmlidXRlczogW10gLy8gYXJyYXkgb2YgYXR0ciBmdW5jdGlvbnNcbn0pO1xudmFyIGxpbmthZ2VBbGlhc2VzID0ge1xuICAnc2luZ2xlJzogJ21pbicsXG4gICdjb21wbGV0ZSc6ICdtYXgnXG59O1xudmFyIHNldE9wdGlvbnMkMSA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgb3B0cyA9IGRlZmF1bHRzJGEob3B0aW9ucyk7XG4gIHZhciBwcmVmZXJyZWRBbGlhcyA9IGxpbmthZ2VBbGlhc2VzW29wdHMubGlua2FnZV07XG4gIGlmIChwcmVmZXJyZWRBbGlhcyAhPSBudWxsKSB7XG4gICAgb3B0cy5saW5rYWdlID0gcHJlZmVycmVkQWxpYXM7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59O1xudmFyIG1lcmdlQ2xvc2VzdCA9IGZ1bmN0aW9uIG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKSB7XG4gIC8vIEZpbmQgdHdvIGNsb3Nlc3QgY2x1c3RlcnMgZnJvbSBjYWNoZWQgbWluc1xuICB2YXIgbWluS2V5ID0gMDtcbiAgdmFyIG1pbiA9IEluZmluaXR5O1xuICB2YXIgZGlzdDtcbiAgdmFyIGF0dHJzID0gb3B0cy5hdHRyaWJ1dGVzO1xuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gY2x1c3RlcnNbaV0ua2V5O1xuICAgIHZhciBfZGlzdCA9IGRpc3RzW2tleV1bbWluc1trZXldXTtcbiAgICBpZiAoX2Rpc3QgPCBtaW4pIHtcbiAgICAgIG1pbktleSA9IGtleTtcbiAgICAgIG1pbiA9IF9kaXN0O1xuICAgIH1cbiAgfVxuICBpZiAob3B0cy5tb2RlID09PSAndGhyZXNob2xkJyAmJiBtaW4gPj0gb3B0cy50aHJlc2hvbGQgfHwgb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgJiYgY2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjMSA9IGluZGV4W21pbktleV07XG4gIHZhciBjMiA9IGluZGV4W21pbnNbbWluS2V5XV07XG4gIHZhciBtZXJnZWQ7XG5cbiAgLy8gTWVyZ2UgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcbiAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgbWVyZ2VkID0ge1xuICAgICAgbGVmdDogYzEsXG4gICAgICByaWdodDogYzIsXG4gICAgICBrZXk6IGMxLmtleVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbWVyZ2VkID0ge1xuICAgICAgdmFsdWU6IGMxLnZhbHVlLmNvbmNhdChjMi52YWx1ZSksXG4gICAgICBrZXk6IGMxLmtleVxuICAgIH07XG4gIH1cbiAgY2x1c3RlcnNbYzEuaW5kZXhdID0gbWVyZ2VkO1xuICBjbHVzdGVycy5zcGxpY2UoYzIuaW5kZXgsIDEpO1xuICBpbmRleFtjMS5rZXldID0gbWVyZ2VkO1xuXG4gIC8vIFVwZGF0ZSBkaXN0YW5jZXMgd2l0aCBuZXcgbWVyZ2VkIGNsdXN0ZXJcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNsdXN0ZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBjdXIgPSBjbHVzdGVyc1tfaV07XG4gICAgaWYgKGMxLmtleSA9PT0gY3VyLmtleSkge1xuICAgICAgZGlzdCA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWluJykge1xuICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG4gICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA+IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtYXgnKSB7XG4gICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcbiAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldIDwgZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21lYW4nKSB7XG4gICAgICBkaXN0ID0gKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gKiBjMS5zaXplICsgZGlzdHNbYzIua2V5XVtjdXIua2V5XSAqIGMyLnNpemUpIC8gKGMxLnNpemUgKyBjMi5zaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWUsIGMxLnZhbHVlKTtlbHNlIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZVswXSwgYzEudmFsdWVbMF0pO1xuICAgIH1cbiAgICBkaXN0c1tjMS5rZXldW2N1ci5rZXldID0gZGlzdHNbY3VyLmtleV1bYzEua2V5XSA9IGRpc3Q7IC8vIGRpc3RhbmNlIG1hdHJpeCBpcyBzeW1tZXRyaWNcbiAgfVxuXG4gIC8vIFVwZGF0ZSBjYWNoZWQgbWluc1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjbHVzdGVycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGtleTEgPSBjbHVzdGVyc1tfaTJdLmtleTtcbiAgICBpZiAobWluc1trZXkxXSA9PT0gYzEua2V5IHx8IG1pbnNba2V5MV0gPT09IGMyLmtleSkge1xuICAgICAgdmFyIF9taW4gPSBrZXkxO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIga2V5MiA9IGNsdXN0ZXJzW2pdLmtleTtcbiAgICAgICAgaWYgKGRpc3RzW2tleTFdW2tleTJdIDwgZGlzdHNba2V5MV1bX21pbl0pIHtcbiAgICAgICAgICBfbWluID0ga2V5MjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWluc1trZXkxXSA9IF9taW47XG4gICAgfVxuICAgIGNsdXN0ZXJzW19pMl0uaW5kZXggPSBfaTI7XG4gIH1cblxuICAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICBjMS5rZXkgPSBjMi5rZXkgPSBjMS5pbmRleCA9IGMyLmluZGV4ID0gbnVsbDtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIF9nZXRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKHJvb3QsIGFyciwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm47XG4gIGlmIChyb290LnZhbHVlKSB7XG4gICAgYXJyLnB1c2gocm9vdC52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJvb3QubGVmdCkgX2dldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgYXJyKTtcbiAgICBpZiAocm9vdC5yaWdodCkgX2dldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIGFycik7XG4gIH1cbn07XG52YXIgX2J1aWxkRGVuZHJvZ3JhbSA9IGZ1bmN0aW9uIGJ1aWxkRGVuZHJvZ3JhbShyb290LCBjeSkge1xuICBpZiAoIXJvb3QpIHJldHVybiAnJztcbiAgaWYgKHJvb3QubGVmdCAmJiByb290LnJpZ2h0KSB7XG4gICAgdmFyIGxlZnRTdHIgPSBfYnVpbGREZW5kcm9ncmFtKHJvb3QubGVmdCwgY3kpO1xuICAgIHZhciByaWdodFN0ciA9IF9idWlsZERlbmRyb2dyYW0ocm9vdC5yaWdodCwgY3kpO1xuICAgIHZhciBub2RlID0gY3kuYWRkKHtcbiAgICAgIGdyb3VwOiAnbm9kZXMnLFxuICAgICAgZGF0YToge1xuICAgICAgICBpZDogbGVmdFN0ciArICcsJyArIHJpZ2h0U3RyXG4gICAgICB9XG4gICAgfSk7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiAnZWRnZXMnLFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IGxlZnRTdHIsXG4gICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiAnZWRnZXMnLFxuICAgICAgZGF0YToge1xuICAgICAgICBzb3VyY2U6IHJpZ2h0U3RyLFxuICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlLmlkKCk7XG4gIH0gZWxzZSBpZiAocm9vdC52YWx1ZSkge1xuICAgIHJldHVybiByb290LnZhbHVlLmlkKCk7XG4gIH1cbn07XG52YXIgX2J1aWxkQ2x1c3RlcnNGcm9tVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LCBrLCBjeSkge1xuICBpZiAoIXJvb3QpIHJldHVybiBbXTtcbiAgdmFyIGxlZnQgPSBbXSxcbiAgICByaWdodCA9IFtdLFxuICAgIGxlYXZlcyA9IFtdO1xuICBpZiAoayA9PT0gMCkge1xuICAgIC8vIGRvbid0IGN1dCB0cmVlLCBzaW1wbHkgcmV0dXJuIGFsbCBub2RlcyBhcyAxIHNpbmdsZSBjbHVzdGVyXG4gICAgaWYgKHJvb3QubGVmdCkgX2dldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgaWYgKHJvb3QucmlnaHQpIF9nZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgbGVhdmVzID0gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWF2ZXMpXTtcbiAgfSBlbHNlIGlmIChrID09PSAxKSB7XG4gICAgLy8gY3V0IGF0IHJvb3RcblxuICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICAvLyBsZWFmIG5vZGVcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LmxlZnQpIF9nZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIF9nZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24obGVmdCksIGN5LmNvbGxlY3Rpb24ocmlnaHQpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LmxlZnQpIGxlZnQgPSBfYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QubGVmdCwgayAtIDEsIGN5KTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSByaWdodCA9IF9idWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5yaWdodCwgayAtIDEsIGN5KTtcbiAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyA9IGZ1bmN0aW9uIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06IGxpbmthZ2UgdHlwZSwgZGlzdGFuY2UgbWV0cmljLCBldGMuXG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpO1xuICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG4gIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgfSwgbjEsIG4yKTtcbiAgfTtcblxuICAvLyBCZWdpbiBoaWVyYXJjaGljYWwgYWxnb3JpdGhtXG4gIHZhciBjbHVzdGVycyA9IFtdO1xuICB2YXIgZGlzdHMgPSBbXTsgLy8gZGlzdGFuY2VzIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG4gIHZhciBtaW5zID0gW107IC8vIGNsb3Nlc3QgY2x1c3RlciBmb3IgZWFjaCBjbHVzdGVyXG4gIHZhciBpbmRleCA9IFtdOyAvLyBoYXNoIG9mIGFsbCBjbHVzdGVycyBieSBrZXlcblxuICAvLyBJbiBhZ2dsb21lcmF0aXZlIChib3R0b20tdXApIGNsdXN0ZXJpbmcsIGVhY2ggbm9kZSBzdGFydHMgYXMgaXRzIG93biBjbHVzdGVyXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgY2x1c3RlciA9IHtcbiAgICAgIHZhbHVlOiBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyA/IG5vZGVzW25dIDogW25vZGVzW25dXSxcbiAgICAgIGtleTogbixcbiAgICAgIGluZGV4OiBuXG4gICAgfTtcbiAgICBjbHVzdGVyc1tuXSA9IGNsdXN0ZXI7XG4gICAgaW5kZXhbbl0gPSBjbHVzdGVyO1xuICAgIGRpc3RzW25dID0gW107XG4gICAgbWluc1tuXSA9IDA7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgIHZhciBkaXN0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgICAgIC8vIG1vZGVzIHN0b3JlIGNsdXN0ZXIgdmFsdWVzIGRpZmZlcmVudGx5XG4gICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlLCBjbHVzdGVyc1tqXS52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZVswXSwgY2x1c3RlcnNbal0udmFsdWVbMF0pO1xuICAgICAgfVxuICAgICAgZGlzdHNbaV1bal0gPSBkaXN0O1xuICAgICAgZGlzdHNbal1baV0gPSBkaXN0O1xuICAgICAgaWYgKGRpc3QgPCBkaXN0c1tpXVttaW5zW2ldXSkge1xuICAgICAgICBtaW5zW2ldID0gajsgLy8gQ2FjaGUgbWluczogY2xvc2VzdCBjbHVzdGVyIHRvIGNsdXN0ZXIgaSBpcyBjbHVzdGVyIGpcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBjbG9zZXN0IHBhaXIgb2YgY2x1c3RlcnMgYW5kIG1lcmdlIHRoZW0gaW50byBhIHNpbmdsZSBjbHVzdGVyLlxuICAvLyBVcGRhdGUgZGlzdGFuY2VzIGJldHdlZW4gbmV3IGNsdXN0ZXIgYW5kIGVhY2ggb2YgdGhlIG9sZCBjbHVzdGVycywgYW5kIGxvb3AgdW50aWwgdGhyZXNob2xkIHJlYWNoZWQuXG4gIHZhciBtZXJnZWQgPSBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cyk7XG4gIHdoaWxlIChtZXJnZWQpIHtcbiAgICBtZXJnZWQgPSBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cyk7XG4gIH1cbiAgdmFyIHJldENsdXN0ZXJzO1xuXG4gIC8vIERlbmRyb2dyYW0gbW9kZSBidWlsZHMgdGhlIGhpZXJhcmNoeSBhbmQgYWRkcyBpbnRlcm1lZGlhcnkgbm9kZXMgKyBlZGdlc1xuICAvLyBpbiBhZGRpdGlvbiB0byByZXR1cm5pbmcgdGhlIGNsdXN0ZXJzLlxuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICByZXRDbHVzdGVycyA9IF9idWlsZENsdXN0ZXJzRnJvbVRyZWUoY2x1c3RlcnNbMF0sIG9wdHMuZGVuZHJvZ3JhbURlcHRoLCBjeSk7XG4gICAgaWYgKG9wdHMuYWRkRGVuZHJvZ3JhbSkgX2J1aWxkRGVuZHJvZ3JhbShjbHVzdGVyc1swXSwgY3kpO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlZ3VsYXIgbW9kZSBzaW1wbHkgcmV0dXJucyB0aGUgY2x1c3RlcnNcblxuICAgIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGNsdXN0ZXJzLmxlbmd0aCk7XG4gICAgY2x1c3RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2x1c3RlciwgaSkge1xuICAgICAgLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgICAgIGNsdXN0ZXIua2V5ID0gY2x1c3Rlci5pbmRleCA9IG51bGw7XG4gICAgICByZXRDbHVzdGVyc1tpXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlci52YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJldENsdXN0ZXJzO1xufTtcbnZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEgPSB7XG4gIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmc6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcsXG4gIGhjYTogaGllcmFyY2hpY2FsQ2x1c3RlcmluZ1xufTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3l0b3NjYXBlL2N5dG9zY2FwZS5qcy1hZmZpbml0eS1wcm9wYWdhdGlvblxuXG52YXIgZGVmYXVsdHMkOSA9IGRlZmF1bHRzJGcoe1xuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIC8vIGRpc3RhbmNlIG1ldHJpYyB0byBjb21wYXJlIGF0dHJpYnV0ZXMgYmV0d2VlbiB0d28gbm9kZXNcbiAgcHJlZmVyZW5jZTogJ21lZGlhbicsXG4gIC8vIHN1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuICBkYW1waW5nOiAwLjgsXG4gIC8vIGRhbXBpbmcgZmFjdG9yIGJldHdlZW4gWzAuNSwgMSlcbiAgbWF4SXRlcmF0aW9uczogMTAwMCxcbiAgLy8gbWF4IG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJ1blxuICBtaW5JdGVyYXRpb25zOiAxMDAsXG4gIC8vIG1pbiBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW4gaW4gb3JkZXIgZm9yIGNsdXN0ZXJpbmcgdG8gc3RvcFxuICBhdHRyaWJ1dGVzOiBbLy8gZnVuY3Rpb25zIHRvIHF1YW50aWZ5IHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gYW55IHR3byBwb2ludHNcbiAgICAvLyBlLmcuIG5vZGUgPT4gbm9kZS5kYXRhKCd3ZWlnaHQnKVxuICBdXG59KTtcbnZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBkbXAgPSBvcHRpb25zLmRhbXBpbmc7XG4gIHZhciBwcmVmID0gb3B0aW9ucy5wcmVmZXJlbmNlO1xuICBpZiAoISgwLjUgPD0gZG1wICYmIGRtcCA8IDEpKSB7XG4gICAgZXJyb3IoXCJEYW1waW5nIG11c3QgcmFuZ2Ugb24gWzAuNSwgMSkuICBHb3Q6IFwiLmNvbmNhdChkbXApKTtcbiAgfVxuICB2YXIgdmFsaWRQcmVmcyA9IFsnbWVkaWFuJywgJ21lYW4nLCAnbWluJywgJ21heCddO1xuICBpZiAoISh2YWxpZFByZWZzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gcHJlZjtcbiAgfSkgfHwgbnVtYmVyJDEocHJlZikpKSB7XG4gICAgZXJyb3IoXCJQcmVmZXJlbmNlIG11c3QgYmUgb25lIG9mIFtcIi5jb25jYXQodmFsaWRQcmVmcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBcIidcIi5jb25jYXQocCwgXCInXCIpO1xuICAgIH0pLmpvaW4oJywgJyksIFwiXSBvciBhIG51bWJlci4gIEdvdDogXCIpLmNvbmNhdChwcmVmKSk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRzJDkob3B0aW9ucyk7XG59O1xuXG52YXIgZ2V0U2ltaWxhcml0eSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkodHlwZSwgbjEsIG4yLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihuLCBpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obik7XG4gIH07XG5cbiAgLy8gbmIgbmVnYXRpdmUgYmVjYXVzZSBzaW1pbGFyaXR5IHNob3VsZCBoYXZlIGFuIGludmVyc2UgcmVsYXRpb25zaGlwIHRvIGRpc3RhbmNlXG4gIHJldHVybiAtY2x1c3RlcmluZ0Rpc3RhbmNlKHR5cGUsIGF0dHJpYnV0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyKG4xLCBpKTtcbiAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gYXR0cihuMiwgaSk7XG4gIH0sIG4xLCBuMik7XG59O1xudmFyIGdldFByZWZlcmVuY2UgPSBmdW5jdGlvbiBnZXRQcmVmZXJlbmNlKFMsIHByZWZlcmVuY2UpIHtcbiAgLy8gbGFyZ2VyIHByZWZlcmVuY2UgPSBncmVhdGVyICMgb2YgY2x1c3RlcnNcbiAgdmFyIHAgPSBudWxsO1xuICBpZiAocHJlZmVyZW5jZSA9PT0gJ21lZGlhbicpIHtcbiAgICBwID0gbWVkaWFuKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtZWFuJykge1xuICAgIHAgPSBtZWFuKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtaW4nKSB7XG4gICAgcCA9IG1pbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWF4Jykge1xuICAgIHAgPSBtYXgoUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3VzdG9tIHByZWZlcmVuY2UgbnVtYmVyLCBhcyBzZXQgYnkgdXNlclxuICAgIHAgPSBwcmVmZXJlbmNlO1xuICB9XG4gIHJldHVybiBwO1xufTtcbnZhciBmaW5kRXhlbXBsYXJzID0gZnVuY3Rpb24gZmluZEV4ZW1wbGFycyhuLCBSLCBBKSB7XG4gIHZhciBpbmRpY2VzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKFJbaSAqIG4gKyBpXSArIEFbaSAqIG4gKyBpXSA+IDApIHtcbiAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGljZXM7XG59O1xudmFyIGFzc2lnbkNsdXN0ZXJzID0gZnVuY3Rpb24gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKSB7XG4gIHZhciBjbHVzdGVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICAgIHZhciBlID0gZXhlbXBsYXJzW2VpXTtcbiAgICAgIGlmIChTW2kgKiBuICsgZV0gPiBtYXgpIHtcbiAgICAgICAgaW5kZXggPSBlO1xuICAgICAgICBtYXggPSBTW2kgKiBuICsgZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBfZWkgPSAwOyBfZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBfZWkrKykge1xuICAgIGNsdXN0ZXJzW2V4ZW1wbGFyc1tfZWldXSA9IGV4ZW1wbGFyc1tfZWldO1xuICB9XG4gIHJldHVybiBjbHVzdGVycztcbn07XG52YXIgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKG4sIFMsIGV4ZW1wbGFycykge1xuICB2YXIgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgIHZhciBpaSA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2x1c3RlcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGlmIChjbHVzdGVyc1tjXSA9PT0gZXhlbXBsYXJzW2VpXSkge1xuICAgICAgICBpaS5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWF4SSA9IC0xO1xuICAgIHZhciBtYXhTdW0gPSAtSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bSArPSBTW2lpW2pdICogbiArIGlpW2ldXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdW0gPiBtYXhTdW0pIHtcbiAgICAgICAgbWF4SSA9IGk7XG4gICAgICAgIG1heFN1bSA9IHN1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXhlbXBsYXJzW2VpXSA9IGlpW21heEldO1xuICB9XG4gIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBhZmZpbml0eVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gYWZmaW5pdHlQcm9wYWdhdGlvbihvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gTWFwIGVhY2ggbm9kZSB0byBpdHMgcG9zaXRpb24gaW4gbm9kZSBhcnJheVxuICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfVxuXG4gIC8vIEJlZ2luIGFmZmluaXR5IHByb3BhZ2F0aW9uIGFsZ29yaXRobVxuXG4gIHZhciBuOyAvLyBudW1iZXIgb2YgZGF0YSBwb2ludHNcbiAgdmFyIG4yOyAvLyBzaXplIG9mIG1hdHJpY2VzXG4gIHZhciBTOyAvLyBzaW1pbGFyaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG4gIHZhciBwOyAvLyBwcmVmZXJlbmNlL3N1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuICB2YXIgUjsgLy8gcmVzcG9uc2liaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcbiAgdmFyIEE7IC8vIGF2YWlsYWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIG4gPSBub2Rlcy5sZW5ndGg7XG4gIG4yID0gbiAqIG47XG5cbiAgLy8gSW5pdGlhbGl6ZSBhbmQgYnVpbGQgUyBzaW1pbGFyaXR5IG1hdHJpeFxuICBTID0gbmV3IEFycmF5KG4yKTtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgU1tfaV0gPSAtSW5maW5pdHk7IC8vIGZvciBjYXNlcyB3aGVyZSB0d28gZGF0YSBwb2ludHMgc2hvdWxkbid0IGJlIGxpbmtlZCB0b2dldGhlclxuICB9XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG47IF9pMisrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIGlmIChfaTIgIT09IGopIHtcbiAgICAgICAgU1tfaTIgKiBuICsgal0gPSBnZXRTaW1pbGFyaXR5KG9wdHMuZGlzdGFuY2UsIG5vZGVzW19pMl0sIG5vZGVzW2pdLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBsYWNlIHByZWZlcmVuY2VzIG9uIHRoZSBkaWFnb25hbCBvZiBTXG4gIHAgPSBnZXRQcmVmZXJlbmNlKFMsIG9wdHMucHJlZmVyZW5jZSk7XG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG47IF9pMysrKSB7XG4gICAgU1tfaTMgKiBuICsgX2kzXSA9IHA7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG4gIFIgPSBuZXcgQXJyYXkobjIpO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBuMjsgX2k0KyspIHtcbiAgICBSW19pNF0gPSAwLjA7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuICBBID0gbmV3IEFycmF5KG4yKTtcbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbjI7IF9pNSsrKSB7XG4gICAgQVtfaTVdID0gMC4wO1xuICB9XG4gIHZhciBvbGQgPSBuZXcgQXJyYXkobik7XG4gIHZhciBScCA9IG5ldyBBcnJheShuKTtcbiAgdmFyIHNlID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBuOyBfaTYrKykge1xuICAgIG9sZFtfaTZdID0gMC4wO1xuICAgIFJwW19pNl0gPSAwLjA7XG4gICAgc2VbX2k2XSA9IDA7XG4gIH1cbiAgdmFyIGUgPSBuZXcgQXJyYXkobiAqIG9wdHMubWluSXRlcmF0aW9ucyk7XG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGUubGVuZ3RoOyBfaTcrKykge1xuICAgIGVbX2k3XSA9IDA7XG4gIH1cbiAgdmFyIGl0ZXI7XG4gIGZvciAoaXRlciA9IDA7IGl0ZXIgPCBvcHRzLm1heEl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgIC8vIG1haW4gYWxnb3JpdGhtaWMgbG9vcFxuXG4gICAgLy8gVXBkYXRlIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbjsgX2k4KyspIHtcbiAgICAgIHZhciBtYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1heDIgPSAtSW5maW5pdHksXG4gICAgICAgIG1heEkgPSAtMSxcbiAgICAgICAgQVMgPSAwLjA7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICBvbGRbX2pdID0gUltfaTggKiBuICsgX2pdO1xuICAgICAgICBBUyA9IEFbX2k4ICogbiArIF9qXSArIFNbX2k4ICogbiArIF9qXTtcbiAgICAgICAgaWYgKEFTID49IG1heCkge1xuICAgICAgICAgIG1heDIgPSBtYXg7XG4gICAgICAgICAgbWF4ID0gQVM7XG4gICAgICAgICAgbWF4SSA9IF9qO1xuICAgICAgICB9IGVsc2UgaWYgKEFTID4gbWF4Mikge1xuICAgICAgICAgIG1heDIgPSBBUztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbjsgX2oyKyspIHtcbiAgICAgICAgUltfaTggKiBuICsgX2oyXSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChTW19pOCAqIG4gKyBfajJdIC0gbWF4KSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajJdO1xuICAgICAgfVxuICAgICAgUltfaTggKiBuICsgbWF4SV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgbWF4SV0gLSBtYXgyKSArIG9wdHMuZGFtcGluZyAqIG9sZFttYXhJXTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG4gICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbjsgX2k5KyspIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgbjsgX2ozKyspIHtcbiAgICAgICAgb2xkW19qM10gPSBBW19qMyAqIG4gKyBfaTldO1xuICAgICAgICBScFtfajNdID0gTWF0aC5tYXgoMCwgUltfajMgKiBuICsgX2k5XSk7XG4gICAgICAgIHN1bSArPSBScFtfajNdO1xuICAgICAgfVxuICAgICAgc3VtIC09IFJwW19pOV07XG4gICAgICBScFtfaTldID0gUltfaTkgKiBuICsgX2k5XTtcbiAgICAgIHN1bSArPSBScFtfaTldO1xuICAgICAgZm9yICh2YXIgX2o0ID0gMDsgX2o0IDwgbjsgX2o0KyspIHtcbiAgICAgICAgQVtfajQgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIE1hdGgubWluKDAsIHN1bSAtIFJwW19qNF0pICsgb3B0cy5kYW1waW5nICogb2xkW19qNF07XG4gICAgICB9XG4gICAgICBBW19pOSAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKHN1bSAtIFJwW19pOV0pICsgb3B0cy5kYW1waW5nICogb2xkW19pOV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGNvbnZlcmdlbmNlXG4gICAgdmFyIEsgPSAwO1xuICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbjsgX2kxMCsrKSB7XG4gICAgICB2YXIgRSA9IEFbX2kxMCAqIG4gKyBfaTEwXSArIFJbX2kxMCAqIG4gKyBfaTEwXSA+IDAgPyAxIDogMDtcbiAgICAgIGVbaXRlciAlIG9wdHMubWluSXRlcmF0aW9ucyAqIG4gKyBfaTEwXSA9IEU7XG4gICAgICBLICs9IEU7XG4gICAgfVxuICAgIGlmIChLID4gMCAmJiAoaXRlciA+PSBvcHRzLm1pbkl0ZXJhdGlvbnMgLSAxIHx8IGl0ZXIgPT0gb3B0cy5tYXhJdGVyYXRpb25zIC0gMSkpIHtcbiAgICAgIHZhciBfc3VtID0gMDtcbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbjsgX2kxMSsrKSB7XG4gICAgICAgIHNlW19pMTFdID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2o1ID0gMDsgX2o1IDwgb3B0cy5taW5JdGVyYXRpb25zOyBfajUrKykge1xuICAgICAgICAgIHNlW19pMTFdICs9IGVbX2o1ICogbiArIF9pMTFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZVtfaTExXSA9PT0gMCB8fCBzZVtfaTExXSA9PT0gb3B0cy5taW5JdGVyYXRpb25zKSB7XG4gICAgICAgICAgX3N1bSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3N1bSA9PT0gbikge1xuICAgICAgICAvLyB0aGVuIHdlIGhhdmUgY29udmVyZ2VuY2VcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWRlbnRpZnkgZXhlbXBsYXJzIChjbHVzdGVyIGNlbnRlcnMpXG4gIHZhciBleGVtcGxhcnNJbmRpY2VzID0gZmluZEV4ZW1wbGFycyhuLCBSLCBBKTtcblxuICAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnNcbiAgdmFyIGNsdXN0ZXJJbmRpY2VzID0gYXNzaWduKG4sIFMsIGV4ZW1wbGFyc0luZGljZXMpO1xuICB2YXIgY2x1c3RlcnMgPSB7fTtcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tjXV0gPSBbXTtcbiAgfVxuICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IG5vZGVzLmxlbmd0aDsgX2kxMisrKSB7XG4gICAgdmFyIHBvcyA9IGlkMnBvc2l0aW9uW25vZGVzW19pMTJdLmlkKCldO1xuICAgIHZhciBjbHVzdGVySW5kZXggPSBjbHVzdGVySW5kaWNlc1twb3NdO1xuICAgIGlmIChjbHVzdGVySW5kZXggIT0gbnVsbCkge1xuICAgICAgLy8gdGhlIG5vZGUgbWF5IGhhdmUgbm90IGJlZW4gYXNzaWduZWQgYSBjbHVzdGVyIGlmIG5vIHZhbGlkIGF0dHJpYnV0ZXMgd2VyZSBzcGVjaWZpZWRcbiAgICAgIGNsdXN0ZXJzW2NsdXN0ZXJJbmRleF0ucHVzaChub2Rlc1tfaTEyXSk7XG4gICAgfVxuICB9XG4gIHZhciByZXRDbHVzdGVycyA9IG5ldyBBcnJheShleGVtcGxhcnNJbmRpY2VzLmxlbmd0aCk7XG4gIGZvciAodmFyIF9jID0gMDsgX2MgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgX2MrKykge1xuICAgIHJldENsdXN0ZXJzW19jXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tfY11dKTtcbiAgfVxuICByZXR1cm4gcmV0Q2x1c3RlcnM7XG59O1xudmFyIGFmZmluaXR5UHJvcGFnYXRpb24kMSA9IHtcbiAgYWZmaW5pdHlQcm9wYWdhdGlvbjogYWZmaW5pdHlQcm9wYWdhdGlvbixcbiAgYXA6IGFmZmluaXR5UHJvcGFnYXRpb25cbn07XG5cbnZhciBoaWVyaG9semVyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgcm9vdDogdW5kZWZpbmVkLFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRrID0ge1xuICBoaWVyaG9semVyOiBmdW5jdGlvbiBoaWVyaG9semVyKG9wdGlvbnMpIHtcbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgIGRpcmVjdGVkOiBhcmdzWzFdXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgX2hpZXJob2x6ZXJEZWZhdWx0cyA9IGhpZXJob2x6ZXJEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHJvb3QgPSBfaGllcmhvbHplckRlZmF1bHRzLnJvb3QsXG4gICAgICBkaXJlY3RlZCA9IF9oaWVyaG9semVyRGVmYXVsdHMuZGlyZWN0ZWQ7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBkZmxhZyA9IGZhbHNlO1xuICAgIHZhciBvZGRJbjtcbiAgICB2YXIgb2RkT3V0O1xuICAgIHZhciBzdGFydFZlcnRleDtcbiAgICBpZiAocm9vdCkgc3RhcnRWZXJ0ZXggPSBzdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXS5pZCgpIDogcm9vdFswXS5pZCgpO1xuICAgIHZhciBub2RlcyA9IHt9O1xuICAgIHZhciBlZGdlcyA9IHt9O1xuICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICB2YXIgaW5kID0gZWxlLmluZGVncmVlKHRydWUpO1xuICAgICAgICAgIHZhciBvdXRkID0gZWxlLm91dGRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICB2YXIgZDEgPSBpbmQgLSBvdXRkO1xuICAgICAgICAgIHZhciBkMiA9IG91dGQgLSBpbmQ7XG4gICAgICAgICAgaWYgKGQxID09IDEpIHtcbiAgICAgICAgICAgIGlmIChvZGRJbikgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkSW4gPSBpZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGQyID09IDEpIHtcbiAgICAgICAgICAgIGlmIChvZGRPdXQpIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZE91dCA9IGlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPiAxIHx8IGQxID4gMSkge1xuICAgICAgICAgICAgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICBlbGUub3V0Z29lcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0VkZ2UoKSkgbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlc1tpZF0gPSBbdW5kZWZpbmVkLCBlbGUudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIHZhciBkID0gZWxlLmRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICBpZiAoZCAlIDIpIHtcbiAgICAgICAgICAgIGlmICghb2RkSW4pIG9kZEluID0gaWQ7ZWxzZSBpZiAoIW9kZE91dCkgb2RkT3V0ID0gaWQ7ZWxzZSBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVzW2lkXSA9IFtdO1xuICAgICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1tpZF0ucHVzaChlLmlkKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VzW2lkXSA9IFtlbGUuc291cmNlKCkuaWQoKSwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIHRyYWlsOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChkZmxhZykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChvZGRPdXQgJiYgb2RkSW4pIHtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydFZlcnRleCAmJiBvZGRPdXQgIT0gc3RhcnRWZXJ0ZXggJiYgb2RkSW4gIT0gc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGFydFZlcnRleCkge1xuICAgICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc3RhcnRWZXJ0ZXgpIHN0YXJ0VmVydGV4ID0gZWxlc1swXS5pZCgpO1xuICAgIH1cbiAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIHdhbGsodikge1xuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdjtcbiAgICAgIHZhciBzdWJ0b3VyID0gW3ZdO1xuICAgICAgdmFyIGFkaiwgYWRqVGFpbCwgYWRqSGVhZDtcbiAgICAgIHdoaWxlIChub2Rlc1tjdXJyZW50Tm9kZV0ubGVuZ3RoKSB7XG4gICAgICAgIGFkaiA9IG5vZGVzW2N1cnJlbnROb2RlXS5zaGlmdCgpO1xuICAgICAgICBhZGpUYWlsID0gZWRnZXNbYWRqXVswXTtcbiAgICAgICAgYWRqSGVhZCA9IGVkZ2VzW2Fkal1bMV07XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSAhPSBhZGpIZWFkKSB7XG4gICAgICAgICAgbm9kZXNbYWRqSGVhZF0gPSBub2Rlc1thZGpIZWFkXS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IGFkakhlYWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRpcmVjdGVkICYmIGN1cnJlbnROb2RlICE9IGFkalRhaWwpIHtcbiAgICAgICAgICBub2Rlc1thZGpUYWlsXSA9IG5vZGVzW2FkalRhaWxdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqVGFpbDtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0b3VyLnVuc2hpZnQoYWRqKTtcbiAgICAgICAgc3VidG91ci51bnNoaWZ0KGN1cnJlbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJ0b3VyO1xuICAgIH07XG4gICAgdmFyIHRyYWlsID0gW107XG4gICAgdmFyIHN1YnRvdXIgPSBbXTtcbiAgICBzdWJ0b3VyID0gd2FsayhzdGFydFZlcnRleCk7XG4gICAgd2hpbGUgKHN1YnRvdXIubGVuZ3RoICE9IDEpIHtcbiAgICAgIGlmIChub2Rlc1tzdWJ0b3VyWzBdXS5sZW5ndGggPT0gMCkge1xuICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnRvdXIgPSB3YWxrKHN1YnRvdXIuc2hpZnQoKSkuY29uY2F0KHN1YnRvdXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7IC8vIGZpbmFsIG5vZGVcblxuICAgIGZvciAodmFyIGQgaW4gbm9kZXMpIHtcbiAgICAgIGlmIChub2Rlc1tkXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LmZvdW5kID0gdHJ1ZTtcbiAgICByZXN1bHQudHJhaWwgPSB0aGlzLnNwYXduKHRyYWlsLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCA9IGZ1bmN0aW9uIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQoKSB7XG4gIHZhciBlbGVzID0gdGhpcztcbiAgdmFyIG5vZGVzID0ge307XG4gIHZhciBpZCA9IDA7XG4gIHZhciBlZGdlQ291bnQgPSAwO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHZpc2l0ZWRFZGdlcyA9IHt9O1xuICB2YXIgYnVpbGRDb21wb25lbnQgPSBmdW5jdGlvbiBidWlsZENvbXBvbmVudCh4LCB5KSB7XG4gICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIHZhciBjdXRzZXQgPSBbXTtcbiAgICB2YXIgY29tcG9uZW50ID0gZWxlcy5zcGF3bigpO1xuICAgIHdoaWxlIChzdGFja1tpXS54ICE9IHggfHwgc3RhY2tbaV0ueSAhPSB5KSB7XG4gICAgICBjdXRzZXQucHVzaChzdGFjay5wb3AoKS5lZGdlKTtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgY3V0c2V0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IGVkZ2UuY29ubmVjdGVkTm9kZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICBjb25uZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcbiAgICAgICAgaWYgKCFub2Rlc1tub2RlSWRdLmN1dFZlcnRleCkge1xuICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShjb25uZWN0ZWRFZGdlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGNvbm5lY3RlZEVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgfTtcbiAgdmFyIF9iaWNvbm5lY3RlZFNlYXJjaCA9IGZ1bmN0aW9uIGJpY29ubmVjdGVkU2VhcmNoKHJvb3QsIGN1cnJlbnROb2RlLCBwYXJlbnQpIHtcbiAgICBpZiAocm9vdCA9PT0gcGFyZW50KSBlZGdlQ291bnQgKz0gMTtcbiAgICBub2Rlc1tjdXJyZW50Tm9kZV0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBsb3c6IGlkKyssXG4gICAgICBjdXRWZXJ0ZXg6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZWRnZXMgPSBlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICBpZiAoZWRnZXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2goZWxlcy5zcGF3bihlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc291cmNlSWQsIHRhcmdldElkLCBvdGhlck5vZGVJZCwgZWRnZUlkO1xuICAgICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBzb3VyY2VJZCA9IGVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgICAgdGFyZ2V0SWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICAgIG90aGVyTm9kZUlkID0gc291cmNlSWQgPT09IGN1cnJlbnROb2RlID8gdGFyZ2V0SWQgOiBzb3VyY2VJZDtcbiAgICAgICAgaWYgKG90aGVyTm9kZUlkICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICBlZGdlSWQgPSBlZGdlLmlkKCk7XG4gICAgICAgICAgaWYgKCF2aXNpdGVkRWRnZXNbZWRnZUlkXSkge1xuICAgICAgICAgICAgdmlzaXRlZEVkZ2VzW2VkZ2VJZF0gPSB0cnVlO1xuICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgIHg6IGN1cnJlbnROb2RlLFxuICAgICAgICAgICAgICB5OiBvdGhlck5vZGVJZCxcbiAgICAgICAgICAgICAgZWRnZTogZWRnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKG90aGVyTm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgICAgX2JpY29ubmVjdGVkU2VhcmNoKHJvb3QsIG90aGVyTm9kZUlkLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0ubG93ID0gTWF0aC5taW4obm9kZXNbY3VycmVudE5vZGVdLmxvdywgbm9kZXNbb3RoZXJOb2RlSWRdLmxvdyk7XG4gICAgICAgICAgICBpZiAobm9kZXNbY3VycmVudE5vZGVdLmlkIDw9IG5vZGVzW290aGVyTm9kZUlkXS5sb3cpIHtcbiAgICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmN1dFZlcnRleCA9IHRydWU7XG4gICAgICAgICAgICAgIGJ1aWxkQ29tcG9uZW50KGN1cnJlbnROb2RlLCBvdGhlck5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tjdXJyZW50Tm9kZV0ubG93LCBub2Rlc1tvdGhlck5vZGVJZF0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBub2RlSWQgPSBlbGUuaWQoKTtcbiAgICAgIGlmICghKG5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgZWRnZUNvdW50ID0gMDtcbiAgICAgICAgX2JpY29ubmVjdGVkU2VhcmNoKG5vZGVJZCwgbm9kZUlkKTtcbiAgICAgICAgbm9kZXNbbm9kZUlkXS5jdXRWZXJ0ZXggPSBlZGdlQ291bnQgPiAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBjdXRWZXJ0aWNlcyA9IE9iamVjdC5rZXlzKG5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIG5vZGVzW2lkXS5jdXRWZXJ0ZXg7XG4gIH0pLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gZWxlcy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGN1dDogZWxlcy5zcGF3bihjdXRWZXJ0aWNlcyksXG4gICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICB9O1xufTtcbnZhciBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEgPSB7XG4gIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQ6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gIGh0YmM6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gIGh0YjogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZENvbXBvbmVudHM6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWRcbn07XG5cbnZhciB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCA9IGZ1bmN0aW9uIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkKCkge1xuICB2YXIgZWxlcyA9IHRoaXM7XG4gIHZhciBub2RlcyA9IHt9O1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGN1dCA9IGVsZXMuc3Bhd24oZWxlcyk7XG4gIHZhciBfc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2ggPSBmdW5jdGlvbiBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaChzb3VyY2VOb2RlSWQpIHtcbiAgICBzdGFjay5wdXNoKHNvdXJjZU5vZGVJZCk7XG4gICAgbm9kZXNbc291cmNlTm9kZUlkXSA9IHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGxvdzogaW5kZXgrKyxcbiAgICAgIGV4cGxvcmVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gZWxlcy5nZXRFbGVtZW50QnlJZChzb3VyY2VOb2RlSWQpLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgIGNvbm5lY3RlZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG4gICAgICBpZiAodGFyZ2V0Tm9kZUlkICE9PSBzb3VyY2VOb2RlSWQpIHtcbiAgICAgICAgaWYgKCEodGFyZ2V0Tm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgIF9zdHJvbmdseUNvbm5lY3RlZFNlYXJjaCh0YXJnZXROb2RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZXNbdGFyZ2V0Tm9kZUlkXS5leHBsb3JlZCkge1xuICAgICAgICAgIG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93ID0gTWF0aC5taW4obm9kZXNbc291cmNlTm9kZUlkXS5sb3csIG5vZGVzW3RhcmdldE5vZGVJZF0ubG93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChub2Rlc1tzb3VyY2VOb2RlSWRdLmluZGV4ID09PSBub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdykge1xuICAgICAgdmFyIGNvbXBvbmVudE5vZGVzID0gZWxlcy5zcGF3bigpO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgbm9kZUlkID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbXBvbmVudE5vZGVzLm1lcmdlKGVsZXMuZ2V0RWxlbWVudEJ5SWQobm9kZUlkKSk7XG4gICAgICAgIG5vZGVzW25vZGVJZF0ubG93ID0gbm9kZXNbc291cmNlTm9kZUlkXS5pbmRleDtcbiAgICAgICAgbm9kZXNbbm9kZUlkXS5leHBsb3JlZCA9IHRydWU7XG4gICAgICAgIGlmIChub2RlSWQgPT09IHNvdXJjZU5vZGVJZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29tcG9uZW50RWRnZXMgPSBjb21wb25lbnROb2Rlcy5lZGdlc1dpdGgoY29tcG9uZW50Tm9kZXMpO1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudE5vZGVzLm1lcmdlKGNvbXBvbmVudEVkZ2VzKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgY3V0ID0gY3V0LmRpZmZlcmVuY2UoY29tcG9uZW50KTtcbiAgICB9XG4gIH07XG4gIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGVJZCA9IGVsZS5pZCgpO1xuICAgICAgaWYgKCEobm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICBfc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2gobm9kZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGN1dDogY3V0LFxuICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgfTtcbn07XG52YXIgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQkMSA9IHtcbiAgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQ6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkLFxuICB0c2M6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkLFxuICB0c2NjOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZFxufTtcblxudmFyIGVsZXNmbiRqID0ge307XG5bZWxlc2ZuJHYsIGVsZXNmbiR1LCBlbGVzZm4kdCwgZWxlc2ZuJHMsIGVsZXNmbiRyLCBlbGVzZm4kcSwgZWxlc2ZuJHAsIGVsZXNmbiRvLCBlbGVzZm4kbiwgZWxlc2ZuJG0sIGVsZXNmbiRsLCBtYXJrb3ZDbHVzdGVyaW5nJDEsIGtDbHVzdGVyaW5nLCBoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEsIGFmZmluaXR5UHJvcGFnYXRpb24kMSwgZWxlc2ZuJGssIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSwgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGVsZXNmbiRqLCBwcm9wcyk7XG59KTtcblxuLyohXG5FbWJlZGRhYmxlIE1pbmltdW0gU3RyaWN0bHktQ29tcGxpYW50IFByb21pc2VzL0ErIDEuMS4xIFRoZW5hYmxlXG5Db3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBSYWxmIFMuIEVuZ2Vsc2NoYWxsIChodHRwOi8vZW5nZWxzY2hhbGwuY29tKVxuTGljZW5zZWQgdW5kZXIgVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuKi9cblxuLyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xudmFyIFNUQVRFX1BFTkRJTkcgPSAwOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cbnZhciBTVEFURV9GVUxGSUxMRUQgPSAxOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cbnZhciBTVEFURV9SRUpFQ1RFRCA9IDI7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjNdICAqL1xuXG4vKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG52YXIgX2FwaSA9IGZ1bmN0aW9uIGFwaShleGVjdXRvcikge1xuICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX2FwaSkpIHJldHVybiBuZXcgX2FwaShleGVjdXRvcik7XG5cbiAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuICB0aGlzLmlkID0gJ1RoZW5hYmxlLzEuMC43JztcbiAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7IC8qICBpbml0aWFsIHN0YXRlICAqL1xuICB0aGlzLmZ1bGZpbGxWYWx1ZSA9IHVuZGVmaW5lZDsgLyogIGluaXRpYWwgdmFsdWUgICovIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cbiAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7IC8qICBpbml0aWFsIHJlYXNvbiAqLyAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG4gIHRoaXMub25GdWxmaWxsZWQgPSBbXTsgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gIHRoaXMub25SZWplY3RlZCA9IFtdOyAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG4gIHRoaXMucHJveHkgPSB7XG4gICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgfTtcblxuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cbiAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykgZXhlY3V0b3IuY2FsbCh0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCh0aGlzKSwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG59O1xuXG4vKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cbl9hcGkucHJvdG90eXBlID0ge1xuICAvKiAgcHJvbWlzZSByZXNvbHZpbmcgbWV0aG9kcyAgKi9cbiAgZnVsZmlsbDogZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlKTtcbiAgfSxcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgJ3JlamVjdFJlYXNvbicsIHZhbHVlKTtcbiAgfSxcbiAgLyogIFwiVGhlIHRoZW4gTWV0aG9kXCIgW1Byb21pc2VzL0ErIDEuMSwgMS4yLCAyLjJdICAqL1xuICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzO1xuICAgIHZhciBuZXh0ID0gbmV3IF9hcGkoKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuN10gICovXG4gICAgY3Vyci5vbkZ1bGZpbGxlZC5wdXNoKHJlc29sdmVyKG9uRnVsZmlsbGVkLCBuZXh0LCAnZnVsZmlsbCcpKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG4gICAgY3Vyci5vblJlamVjdGVkLnB1c2gocmVzb2x2ZXIob25SZWplY3RlZCwgbmV4dCwgJ3JlamVjdCcpKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuMy8yLjIuNl0gICovXG4gICAgZXhlY3V0ZShjdXJyKTtcbiAgICByZXR1cm4gbmV4dC5wcm94eTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNywgMy4zXSAgKi9cbiAgfVxufTtcblxuLyogIGRlbGl2ZXIgYW4gYWN0aW9uICAqL1xudmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiBkZWxpdmVyKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTsgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4xLCAyLjEuMy4xXSAgKi9cbiAgICBjdXJyW25hbWVdID0gdmFsdWU7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMiwgMi4xLjMuMl0gICovXG4gICAgZXhlY3V0ZShjdXJyKTtcbiAgfVxuICByZXR1cm4gY3Vycjtcbn07XG5cbi8qICBleGVjdXRlIGFsbCBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZShjdXJyKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uRnVsZmlsbGVkJywgY3Vyci5mdWxmaWxsVmFsdWUpO2Vsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvblJlamVjdGVkJywgY3Vyci5yZWplY3RSZWFzb24pO1xufTtcblxuLyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG52YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgbmFtZSwgdmFsdWUpIHtcbiAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuICAvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG4gIC8qICBzaG9ydC1jaXJjdWl0IHByb2Nlc3NpbmcgICovXG4gIGlmIChjdXJyW25hbWVdLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG4gIHZhciBoYW5kbGVycyA9IGN1cnJbbmFtZV07XG4gIGN1cnJbbmFtZV0gPSBbXTsgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIGhhbmRsZXJzW2ldKHZhbHVlKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG4gIH07XG5cbiAgLyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgc2V0SW1tZWRpYXRlKGZ1bmMpO2Vsc2Ugc2V0VGltZW91dChmdW5jLCAwKTtcbn07XG5cbi8qICBnZW5lcmF0ZSBhIHJlc29sdmVyIGZ1bmN0aW9uICAqL1xudmFyIHJlc29sdmVyID0gZnVuY3Rpb24gcmVzb2x2ZXIoY2IsIG5leHQsIG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7IC8qICBbUHJvbWlzZXMvQSsgMi4yLjcuMywgMi4yLjcuNF0gICovZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gY2IodmFsdWUpO1xuICAgICAgfSAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjEsIDIuMi4zLjEsIDIuMi41LCAzLjJdICAqLyBjYXRjaCAoZSkge1xuICAgICAgICBuZXh0LnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3Jlc29sdmUobmV4dCwgcmVzdWx0KTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4xXSAgKi9cbiAgICB9XG4gIH07XG59O1xuXG4vKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cbnZhciBfcmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgeCkge1xuICAvKiAgc2FuaXR5IGNoZWNrIGFyZ3VtZW50cyAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMV0gICovXG4gIGlmIChwcm9taXNlID09PSB4IHx8IHByb21pc2UucHJveHkgPT09IHgpIHtcbiAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qICBzdXJnaWNhbGx5IGNoZWNrIGZvciBhIFwidGhlblwiIG1ldGhvZFxuICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG4gIHZhciB0aGVuO1xuICBpZiAoX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB0aGVuID0geC50aGVuO1xuICAgIH0gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqLyBjYXRjaCAoZSkge1xuICAgICAgcHJvbWlzZS5yZWplY3QoZSk7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMl0gICovXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLyogIGhhbmRsZSBvd24gVGhlbmFibGVzICAgIFtQcm9taXNlcy9BKyAyLjMuMl1cbiAgICBhbmQgc2ltaWxhciBcInRoZW5hYmxlc1wiIFtQcm9taXNlcy9BKyAyLjMuM10gICovXG4gIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAvKiAgY2FsbCByZXRyaWV2ZWQgXCJ0aGVuXCIgbWV0aG9kICovIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuM10gICovXG4gICAgICB0aGVuLmNhbGwoeCwgLyogIHJlc29sdmVQcm9taXNlICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICBmdW5jdGlvbiAoeSkge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIGlmICh5ID09PSB4KSAvKiAgW1Byb21pc2VzL0ErIDMuNl0gICovXG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2lyY3VsYXIgdGhlbmFibGUgY2hhaW4nKSk7ZWxzZSBfcmVzb2x2ZShwcm9taXNlLCB5KTtcbiAgICAgIH0sIC8qICByZWplY3RQcm9taXNlICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFyZXNvbHZlZCkgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cbiAgcHJvbWlzZS5mdWxmaWxsKHgpOyAvKiAgW1Byb21pc2VzL0ErIDIuMy40LCAyLjMuMy40XSAgKi9cbn07XG5cbi8vIHNvIHdlIGFsd2F5cyBoYXZlIFByb21pc2UuYWxsKClcbl9hcGkuYWxsID0gZnVuY3Rpb24gKHBzKSB7XG4gIHJldHVybiBuZXcgX2FwaShmdW5jdGlvbiAocmVzb2x2ZUFsbCwgcmVqZWN0QWxsKSB7XG4gICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkocHMubGVuZ3RoKTtcbiAgICB2YXIgZG9uZUNvdW50ID0gMDtcbiAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uIGZ1bGZpbGwoaSwgdmFsKSB7XG4gICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgZG9uZUNvdW50Kys7XG4gICAgICBpZiAoZG9uZUNvdW50ID09PSBwcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZUFsbCh2YWxzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgcCA9IHBzW2ldO1xuICAgICAgICB2YXIgaXNQcm9taXNlID0gcCAhPSBudWxsICYmIHAudGhlbiAhPSBudWxsO1xuICAgICAgICBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3RBbGwoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgfSk7XG59O1xuX2FwaS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IF9hcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc29sdmUodmFsKTtcbiAgfSk7XG59O1xuX2FwaS5yZWplY3QgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBuZXcgX2FwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbCk7XG4gIH0pO1xufTtcbnZhciBQcm9taXNlJDEgPSB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgPyBQcm9taXNlIDogX2FwaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gQW5pbWF0aW9uKHRhcmdldCwgb3B0cywgb3B0czIpIHtcbiAgdmFyIGlzQ29yZSA9IGNvcmUodGFyZ2V0KTtcbiAgdmFyIGlzRWxlID0gIWlzQ29yZTtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IGV4dGVuZCh7XG4gICAgZHVyYXRpb246IDEwMDBcbiAgfSwgb3B0cywgb3B0czIpO1xuICBfcC50YXJnZXQgPSB0YXJnZXQ7XG4gIF9wLnN0eWxlID0gX3Auc3R5bGUgfHwgX3AuY3NzO1xuICBfcC5zdGFydGVkID0gZmFsc2U7XG4gIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgX3AuaG9va2VkID0gZmFsc2U7XG4gIF9wLmFwcGx5aW5nID0gZmFsc2U7XG4gIF9wLnByb2dyZXNzID0gMDtcbiAgX3AuY29tcGxldGVzID0gW107XG4gIF9wLmZyYW1lcyA9IFtdO1xuICBpZiAoX3AuY29tcGxldGUgJiYgZm4kNihfcC5jb21wbGV0ZSkpIHtcbiAgICBfcC5jb21wbGV0ZXMucHVzaChfcC5jb21wbGV0ZSk7XG4gIH1cbiAgaWYgKGlzRWxlKSB7XG4gICAgdmFyIHBvcyA9IHRhcmdldC5wb3NpdGlvbigpO1xuICAgIF9wLnN0YXJ0UG9zaXRpb24gPSBfcC5zdGFydFBvc2l0aW9uIHx8IHtcbiAgICAgIHg6IHBvcy54LFxuICAgICAgeTogcG9zLnlcbiAgICB9O1xuICAgIF9wLnN0YXJ0U3R5bGUgPSBfcC5zdGFydFN0eWxlIHx8IHRhcmdldC5jeSgpLnN0eWxlKCkuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSh0YXJnZXQsIF9wLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNDb3JlKSB7XG4gICAgdmFyIHBhbiA9IHRhcmdldC5wYW4oKTtcbiAgICBfcC5zdGFydFBhbiA9IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9O1xuICAgIF9wLnN0YXJ0Wm9vbSA9IHRhcmdldC56b29tKCk7XG4gIH1cblxuICAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcbnZhciBhbmlmbiA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5leHRlbmQoYW5pZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnYW5pbWF0aW9uJztcbiAgfSxcbiAgaG9vazogZnVuY3Rpb24gaG9vaygpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmICghX3AuaG9va2VkKSB7XG4gICAgICAvLyBhZGQgdG8gdGFyZ2V0J3MgYW5pbWF0aW9uIHF1ZXVlXG4gICAgICB2YXIgcTtcbiAgICAgIHZhciB0QW5pID0gX3AudGFyZ2V0Ll9wcml2YXRlLmFuaW1hdGlvbjtcbiAgICAgIGlmIChfcC5xdWV1ZSkge1xuICAgICAgICBxID0gdEFuaS5xdWV1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHEgPSB0QW5pLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBxLnB1c2godGhpcyk7XG5cbiAgICAgIC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oX3AudGFyZ2V0KSkge1xuICAgICAgICBfcC50YXJnZXQuY3koKS5hZGRUb0FuaW1hdGlvblBvb2woX3AudGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAvLyBhdXRvcmV3aW5kXG4gICAgaWYgKF9wLnByb2dyZXNzID09PSAxKSB7XG4gICAgICBfcC5wcm9ncmVzcyA9IDA7XG4gICAgfVxuICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvb2soKTtcblxuICAgIC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIHN0YXJ0IHRoZSBhbmltYXRpb24uLi5cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwbGF5aW5nOiBmdW5jdGlvbiBwbGF5aW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBsYXlpbmc7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLmFwcGx5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcbiAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhcHBseWluZzogZnVuY3Rpb24gYXBwbHlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXBwbHlpbmc7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIF9wLnN0b3BwZWQgPSB0cnVlOyAvLyB0byBiZSByZW1vdmVkIGZyb20gYW5pbWF0aW9uIHF1ZXVlc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJld2luZDogZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDApO1xuICB9LFxuICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24gZmFzdGZvcndhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMSk7XG4gIH0sXG4gIHRpbWU6IGZ1bmN0aW9uIHRpbWUodCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzICogX3AuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKHQgLyBfcC5kdXJhdGlvbik7XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MocCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuICAgIGlmIChwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgICAgX3AucHJvZ3Jlc3MgPSBwO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb21wbGV0ZWQ6IGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wcm9ncmVzcyA9PT0gMTtcbiAgfSxcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgICBfcC5wcm9ncmVzcyA9IDEgLSBfcC5wcm9ncmVzcztcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgdmFyIHN3YXAgPSBmdW5jdGlvbiBzd2FwKGEsIGIpIHtcbiAgICAgIHZhciBfcGEgPSBfcFthXTtcbiAgICAgIGlmIChfcGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcFthXSA9IF9wW2JdO1xuICAgICAgX3BbYl0gPSBfcGE7XG4gICAgfTtcbiAgICBzd2FwKCd6b29tJywgJ3N0YXJ0Wm9vbScpO1xuICAgIHN3YXAoJ3BhbicsICdzdGFydFBhbicpO1xuICAgIHN3YXAoJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nKTtcblxuICAgIC8vIHN3YXAgc3R5bGVzXG4gICAgaWYgKF9wLnN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9wLnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgc3RhcnRTdHlsZVByb3AgPSBfcC5zdGFydFN0eWxlW25hbWVdO1xuICAgICAgICBfcC5zdGFydFN0eWxlW25hbWVdID0gcHJvcDtcbiAgICAgICAgX3Auc3R5bGVbaV0gPSBzdGFydFN0eWxlUHJvcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh0eXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgYXJyO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgICBhcnIgPSBfcC5mcmFtZXM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIGFyciA9IF9wLmNvbXBsZXRlcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXJyLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5hbmlmbi5jb21wbGV0ZSA9IGFuaWZuLmNvbXBsZXRlZDtcbmFuaWZuLnJ1biA9IGFuaWZuLnBsYXk7XG5hbmlmbi5ydW5uaW5nID0gYW5pZm4ucGxheWluZztcblxudmFyIGRlZmluZSQzID0ge1xuICBhbmltYXRlZDogZnVuY3Rpb24gYW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVkSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZWxlID0gYWxsWzBdO1xuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZWRcblxuICBjbGVhclF1ZXVlOiBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclF1ZXVlSW1wbCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sXG4gIC8vIGNsZWFyUXVldWVcblxuICBkZWxheTogZnVuY3Rpb24gZGVsYXkoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5SW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgLy8gZGVsYXlcblxuICBkZWxheUFuaW1hdGlvbjogZnVuY3Rpb24gZGVsYXlBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbih7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvLyBkZWxheVxuXG4gIGFuaW1hdGlvbjogZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRpb25JbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICB2YXIgaXNDb3JlID0gIXNlbGZJc0FycmF5TGlrZTtcbiAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICBwcm9wZXJ0aWVzID0gZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMpO1xuICAgICAgdmFyIHByb3BlcnRpZXNFbXB0eSA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlmIChwcm9wZXJ0aWVzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICB9XG4gICAgICBpZiAocHJvcGVydGllcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHByb3BlcnRpZXMuZHVyYXRpb24pIHtcbiAgICAgICAgY2FzZSAnc2xvdyc6XG4gICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmFzdCc6XG4gICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcbiAgICAgICAgcHJvcGVydGllcy5jc3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVzICYmIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBycG9zID0gcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocnBvcywgem9vbSwgcGFuKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIHBhbkJ5IGlmIHNldFxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLnBhbkJ5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG4gICAgICB2YXIgY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXIgfHwgcHJvcGVydGllcy5jZW50cmU7XG4gICAgICBpZiAoaXNDb3JlICYmIGNlbnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSk7XG4gICAgICAgIGlmIChjZW50ZXJQYW4gIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiAmIHpvb20gdy8gZml0IGlmIHNldFxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG4gICAgICAgIGlmIChmaXRWcCAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBmaXRWcC5wYW47XG4gICAgICAgICAgcHJvcGVydGllcy56b29tID0gZml0VnAuem9vbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSB6b29tICgmIHBvdGVudGlhbGx5IHBhbikgdy8gem9vbSBvYmogaWYgc2V0XG4gICAgICBpZiAoaXNDb3JlICYmIHBsYWluT2JqZWN0KHByb3BlcnRpZXMuem9vbSkpIHtcbiAgICAgICAgdmFyIHZwID0gY3kuZ2V0Wm9vbWVkVmlld3BvcnQocHJvcGVydGllcy56b29tKTtcbiAgICAgICAgaWYgKHZwICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodnAuem9vbWVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSB2cC56b29tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHZwLnBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy56b29tID0gbnVsbDsgLy8gYW4gaW5hdmFsaWQgem9vbSAoZS5nLiBubyBkZWx0YSkgZ2V0cyBhdXRvbWF0aWNhbGx5IGRlc3Ryb3llZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihhbGxbMF0sIHByb3BlcnRpZXMpO1xuICAgIH07XG4gIH0sXG4gIC8vIGFuaW1hdGVcblxuICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFudWFsbHkgaG9vayBhbmQgcnVuIHRoZSBhbmltYXRpb25cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIHZhciBxdWV1ZSA9IGVsZS5hbmltYXRlZCgpICYmIChwcm9wZXJ0aWVzLnF1ZXVlID09PSB1bmRlZmluZWQgfHwgcHJvcGVydGllcy5xdWV1ZSk7XG4gICAgICAgIHZhciBhbmkgPSBlbGUuYW5pbWF0aW9uKHByb3BlcnRpZXMsIHF1ZXVlID8ge1xuICAgICAgICAgIHF1ZXVlOiB0cnVlXG4gICAgICAgIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBhbmkucGxheSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BJbXBsKGNsZWFyUXVldWUsIGp1bXBUb0VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgYW5pcyA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgYW5pID0gYW5pc1tqXTtcbiAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gICAgICAgICAgaWYgKGp1bXBUb0VuZCkge1xuICAgICAgICAgICAgLy8gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBsb29wLCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAvLyB3aWxsIGdvIHN0cmFpZ2h0IHRvIHRoZSBlbmQgYW5kIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIGFuaV9wLmR1cmF0aW9uID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciB0aGUgcXVldWUgb2YgZnV0dXJlIGFuaW1hdGlvbnNcbiAgICAgICAgaWYgKGNsZWFyUXVldWUpIHtcbiAgICAgICAgICBfcC5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWp1bXBUb0VuZCkge1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0gLy8gc3RvcFxufTsgLy8gZGVmaW5lXG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNBcnJheV8xO1xudmFyIGhhc1JlcXVpcmVkSXNBcnJheTtcblxuZnVuY3Rpb24gcmVxdWlyZUlzQXJyYXkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJc0FycmF5KSByZXR1cm4gaXNBcnJheV8xO1xuXHRoYXNSZXF1aXJlZElzQXJyYXkgPSAxO1xuXHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cblx0aXNBcnJheV8xID0gaXNBcnJheTtcblx0cmV0dXJuIGlzQXJyYXlfMTtcbn1cblxudmFyIF9pc0tleTtcbnZhciBoYXNSZXF1aXJlZF9pc0tleTtcblxuZnVuY3Rpb24gcmVxdWlyZV9pc0tleSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9pc0tleSkgcmV0dXJuIF9pc0tleTtcblx0aGFzUmVxdWlyZWRfaXNLZXkgPSAxO1xuXHR2YXIgaXNBcnJheSA9IHJlcXVpcmVJc0FycmF5KCksXG5cdCAgICBpc1N5bWJvbCA9IHJlcXVpcmVJc1N5bWJvbCgpO1xuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblx0dmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG5cdCAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuXHQgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG5cdCAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuXHQgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcblx0fVxuXG5cdF9pc0tleSA9IGlzS2V5O1xuXHRyZXR1cm4gX2lzS2V5O1xufVxuXG52YXIgaXNGdW5jdGlvbl8xO1xudmFyIGhhc1JlcXVpcmVkSXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gcmVxdWlyZUlzRnVuY3Rpb24gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJc0Z1bmN0aW9uKSByZXR1cm4gaXNGdW5jdGlvbl8xO1xuXHRoYXNSZXF1aXJlZElzRnVuY3Rpb24gPSAxO1xuXHR2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmVfYmFzZUdldFRhZygpLFxuXHQgICAgaXNPYmplY3QgPSByZXF1aXJlSXNPYmplY3QoKTtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcblx0ICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuXHQgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcblx0ICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLmlzRnVuY3Rpb24oXyk7XG5cdCAqIC8vID0+IHRydWVcblx0ICpcblx0ICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcblx0ICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3Jcblx0ICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cblx0ICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG5cdCAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcblx0fVxuXG5cdGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb247XG5cdHJldHVybiBpc0Z1bmN0aW9uXzE7XG59XG5cbnZhciBfY29yZUpzRGF0YTtcbnZhciBoYXNSZXF1aXJlZF9jb3JlSnNEYXRhO1xuXG5mdW5jdGlvbiByZXF1aXJlX2NvcmVKc0RhdGEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfY29yZUpzRGF0YSkgcmV0dXJuIF9jb3JlSnNEYXRhO1xuXHRoYXNSZXF1aXJlZF9jb3JlSnNEYXRhID0gMTtcblx0dmFyIHJvb3QgPSByZXF1aXJlX3Jvb3QoKTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG5cdHZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cblx0X2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhO1xuXHRyZXR1cm4gX2NvcmVKc0RhdGE7XG59XG5cbnZhciBfaXNNYXNrZWQ7XG52YXIgaGFzUmVxdWlyZWRfaXNNYXNrZWQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaXNNYXNrZWQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaXNNYXNrZWQpIHJldHVybiBfaXNNYXNrZWQ7XG5cdGhhc1JlcXVpcmVkX2lzTWFza2VkID0gMTtcblx0dmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlX2NvcmVKc0RhdGEoKTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuXHR2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuXHQgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcblx0fSgpKTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuXHQgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG5cdH1cblxuXHRfaXNNYXNrZWQgPSBpc01hc2tlZDtcblx0cmV0dXJuIF9pc01hc2tlZDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXG52YXIgX3RvU291cmNlO1xudmFyIGhhc1JlcXVpcmVkX3RvU291cmNlO1xuXG5mdW5jdGlvbiByZXF1aXJlX3RvU291cmNlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX3RvU291cmNlKSByZXR1cm4gX3RvU291cmNlO1xuXHRoYXNSZXF1aXJlZF90b1NvdXJjZSA9IDE7XG5cdHZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuXHR2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcblx0ICBpZiAoZnVuYyAhPSBudWxsKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgdHJ5IHtcblx0ICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdCAgcmV0dXJuICcnO1xuXHR9XG5cblx0X3RvU291cmNlID0gdG9Tb3VyY2U7XG5cdHJldHVybiBfdG9Tb3VyY2U7XG59XG5cbnZhciBfYmFzZUlzTmF0aXZlO1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VJc05hdGl2ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlSXNOYXRpdmUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZUlzTmF0aXZlKSByZXR1cm4gX2Jhc2VJc05hdGl2ZTtcblx0aGFzUmVxdWlyZWRfYmFzZUlzTmF0aXZlID0gMTtcblx0dmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlSXNGdW5jdGlvbigpLFxuXHQgICAgaXNNYXNrZWQgPSByZXF1aXJlX2lzTWFza2VkKCksXG5cdCAgICBpc09iamVjdCA9IHJlcXVpcmVJc09iamVjdCgpLFxuXHQgICAgdG9Tb3VyY2UgPSByZXF1aXJlX3RvU291cmNlKCk7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcblx0ICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG5cdCAqL1xuXHR2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cblx0dmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblx0dmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cblx0dmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcblx0ICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuXHQgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuXHQpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcblx0ICogIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuXHQgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3Rvcjtcblx0ICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG5cdH1cblxuXHRfYmFzZUlzTmF0aXZlID0gYmFzZUlzTmF0aXZlO1xuXHRyZXR1cm4gX2Jhc2VJc05hdGl2ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuXG52YXIgX2dldFZhbHVlO1xudmFyIGhhc1JlcXVpcmVkX2dldFZhbHVlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2dldFZhbHVlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2dldFZhbHVlKSByZXR1cm4gX2dldFZhbHVlO1xuXHRoYXNSZXF1aXJlZF9nZXRWYWx1ZSA9IDE7XG5cdGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG5cdCAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG5cdH1cblxuXHRfZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblx0cmV0dXJuIF9nZXRWYWx1ZTtcbn1cblxudmFyIF9nZXROYXRpdmU7XG52YXIgaGFzUmVxdWlyZWRfZ2V0TmF0aXZlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2dldE5hdGl2ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9nZXROYXRpdmUpIHJldHVybiBfZ2V0TmF0aXZlO1xuXHRoYXNSZXF1aXJlZF9nZXROYXRpdmUgPSAxO1xuXHR2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZV9iYXNlSXNOYXRpdmUoKSxcblx0ICAgIGdldFZhbHVlID0gcmVxdWlyZV9nZXRWYWx1ZSgpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcblx0ICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG5cdCAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdF9nZXROYXRpdmUgPSBnZXROYXRpdmU7XG5cdHJldHVybiBfZ2V0TmF0aXZlO1xufVxuXG52YXIgX25hdGl2ZUNyZWF0ZTtcbnZhciBoYXNSZXF1aXJlZF9uYXRpdmVDcmVhdGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbmF0aXZlQ3JlYXRlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX25hdGl2ZUNyZWF0ZSkgcmV0dXJuIF9uYXRpdmVDcmVhdGU7XG5cdGhhc1JlcXVpcmVkX25hdGl2ZUNyZWF0ZSA9IDE7XG5cdHZhciBnZXROYXRpdmUgPSByZXF1aXJlX2dldE5hdGl2ZSgpO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cblx0dmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuXHRfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlO1xuXHRyZXR1cm4gX25hdGl2ZUNyZWF0ZTtcbn1cblxudmFyIF9oYXNoQ2xlYXI7XG52YXIgaGFzUmVxdWlyZWRfaGFzaENsZWFyO1xuXG5mdW5jdGlvbiByZXF1aXJlX2hhc2hDbGVhciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9oYXNoQ2xlYXIpIHJldHVybiBfaGFzaENsZWFyO1xuXHRoYXNSZXF1aXJlZF9oYXNoQ2xlYXIgPSAxO1xuXHR2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZV9uYXRpdmVDcmVhdGUoKTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgY2xlYXJcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcblx0ICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG5cdCAgdGhpcy5zaXplID0gMDtcblx0fVxuXG5cdF9oYXNoQ2xlYXIgPSBoYXNoQ2xlYXI7XG5cdHJldHVybiBfaGFzaENsZWFyO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG52YXIgX2hhc2hEZWxldGU7XG52YXIgaGFzUmVxdWlyZWRfaGFzaERlbGV0ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9oYXNoRGVsZXRlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2hhc2hEZWxldGUpIHJldHVybiBfaGFzaERlbGV0ZTtcblx0aGFzUmVxdWlyZWRfaGFzaERlbGV0ZSA9IDE7XG5cdGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG5cdCAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcblx0ICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblx0cmV0dXJuIF9oYXNoRGVsZXRlO1xufVxuXG52YXIgX2hhc2hHZXQ7XG52YXIgaGFzUmVxdWlyZWRfaGFzaEdldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9oYXNoR2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2hhc2hHZXQpIHJldHVybiBfaGFzaEdldDtcblx0aGFzUmVxdWlyZWRfaGFzaEdldCA9IDE7XG5cdHZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlX25hdGl2ZUNyZWF0ZSgpO1xuXG5cdC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblx0dmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBnZXRcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIGlmIChuYXRpdmVDcmVhdGUpIHtcblx0ICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG5cdCAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcblx0ICB9XG5cdCAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcblx0fVxuXG5cdF9oYXNoR2V0ID0gaGFzaEdldDtcblx0cmV0dXJuIF9oYXNoR2V0O1xufVxuXG52YXIgX2hhc2hIYXM7XG52YXIgaGFzUmVxdWlyZWRfaGFzaEhhcztcblxuZnVuY3Rpb24gcmVxdWlyZV9oYXNoSGFzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2hhc2hIYXMpIHJldHVybiBfaGFzaEhhcztcblx0aGFzUmVxdWlyZWRfaGFzaEhhcyA9IDE7XG5cdHZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlX25hdGl2ZUNyZWF0ZSgpO1xuXG5cdC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgaGFzXG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcblx0fVxuXG5cdF9oYXNoSGFzID0gaGFzaEhhcztcblx0cmV0dXJuIF9oYXNoSGFzO1xufVxuXG52YXIgX2hhc2hTZXQ7XG52YXIgaGFzUmVxdWlyZWRfaGFzaFNldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9oYXNoU2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2hhc2hTZXQpIHJldHVybiBfaGFzaFNldDtcblx0aGFzUmVxdWlyZWRfaGFzaFNldCA9IDE7XG5cdHZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlX25hdGl2ZUNyZWF0ZSgpO1xuXG5cdC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblx0dmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIHNldFxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG5cdCAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfaGFzaFNldCA9IGhhc2hTZXQ7XG5cdHJldHVybiBfaGFzaFNldDtcbn1cblxudmFyIF9IYXNoO1xudmFyIGhhc1JlcXVpcmVkX0hhc2g7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfSGFzaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9IYXNoKSByZXR1cm4gX0hhc2g7XG5cdGhhc1JlcXVpcmVkX0hhc2ggPSAxO1xuXHR2YXIgaGFzaENsZWFyID0gcmVxdWlyZV9oYXNoQ2xlYXIoKSxcblx0ICAgIGhhc2hEZWxldGUgPSByZXF1aXJlX2hhc2hEZWxldGUoKSxcblx0ICAgIGhhc2hHZXQgPSByZXF1aXJlX2hhc2hHZXQoKSxcblx0ICAgIGhhc2hIYXMgPSByZXF1aXJlX2hhc2hIYXMoKSxcblx0ICAgIGhhc2hTZXQgPSByZXF1aXJlX2hhc2hTZXQoKTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG5cdCAgdGhpcy5jbGVhcigpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcblx0ICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgfVxuXHR9XG5cblx0Ly8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuXHRIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcblx0SGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcblx0SGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcblx0SGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcblx0SGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuXHRfSGFzaCA9IEhhc2g7XG5cdHJldHVybiBfSGFzaDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5cbnZhciBfbGlzdENhY2hlQ2xlYXI7XG52YXIgaGFzUmVxdWlyZWRfbGlzdENhY2hlQ2xlYXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbGlzdENhY2hlQ2xlYXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbGlzdENhY2hlQ2xlYXIpIHJldHVybiBfbGlzdENhY2hlQ2xlYXI7XG5cdGhhc1JlcXVpcmVkX2xpc3RDYWNoZUNsZWFyID0gMTtcblx0ZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG5cdCAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuXHQgIHRoaXMuc2l6ZSA9IDA7XG5cdH1cblxuXHRfbGlzdENhY2hlQ2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblx0cmV0dXJuIF9saXN0Q2FjaGVDbGVhcjtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5cbnZhciBlcV8xO1xudmFyIGhhc1JlcXVpcmVkRXE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVFcSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEVxKSByZXR1cm4gZXFfMTtcblx0aGFzUmVxdWlyZWRFcSA9IDE7XG5cdGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuXHR9XG5cblx0ZXFfMSA9IGVxO1xuXHRyZXR1cm4gZXFfMTtcbn1cblxudmFyIF9hc3NvY0luZGV4T2Y7XG52YXIgaGFzUmVxdWlyZWRfYXNzb2NJbmRleE9mO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Fzc29jSW5kZXhPZiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9hc3NvY0luZGV4T2YpIHJldHVybiBfYXNzb2NJbmRleE9mO1xuXHRoYXNSZXF1aXJlZF9hc3NvY0luZGV4T2YgPSAxO1xuXHR2YXIgZXEgPSByZXF1aXJlRXEoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcblx0ICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHQgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcblx0ICAgICAgcmV0dXJuIGxlbmd0aDtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIC0xO1xuXHR9XG5cblx0X2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblx0cmV0dXJuIF9hc3NvY0luZGV4T2Y7XG59XG5cbnZhciBfbGlzdENhY2hlRGVsZXRlO1xudmFyIGhhc1JlcXVpcmVkX2xpc3RDYWNoZURlbGV0ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9saXN0Q2FjaGVEZWxldGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbGlzdENhY2hlRGVsZXRlKSByZXR1cm4gX2xpc3RDYWNoZURlbGV0ZTtcblx0aGFzUmVxdWlyZWRfbGlzdENhY2hlRGVsZXRlID0gMTtcblx0dmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmVfYXNzb2NJbmRleE9mKCk7XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZGVsZXRlXG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICBpZiAoaW5kZXggPCAwKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG5cdCAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuXHQgICAgZGF0YS5wb3AoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuXHQgIH1cblx0ICAtLXRoaXMuc2l6ZTtcblx0ICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cdHJldHVybiBfbGlzdENhY2hlRGVsZXRlO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldDtcbnZhciBoYXNSZXF1aXJlZF9saXN0Q2FjaGVHZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbGlzdENhY2hlR2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2xpc3RDYWNoZUdldCkgcmV0dXJuIF9saXN0Q2FjaGVHZXQ7XG5cdGhhc1JlcXVpcmVkX2xpc3RDYWNoZUdldCA9IDE7XG5cdHZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlX2Fzc29jSW5kZXhPZigpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZ2V0XG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG5cdH1cblxuXHRfbGlzdENhY2hlR2V0ID0gbGlzdENhY2hlR2V0O1xuXHRyZXR1cm4gX2xpc3RDYWNoZUdldDtcbn1cblxudmFyIF9saXN0Q2FjaGVIYXM7XG52YXIgaGFzUmVxdWlyZWRfbGlzdENhY2hlSGFzO1xuXG5mdW5jdGlvbiByZXF1aXJlX2xpc3RDYWNoZUhhcyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9saXN0Q2FjaGVIYXMpIHJldHVybiBfbGlzdENhY2hlSGFzO1xuXHRoYXNSZXF1aXJlZF9saXN0Q2FjaGVIYXMgPSAxO1xuXHR2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZV9hc3NvY0luZGV4T2YoKTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuXHQgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuXHR9XG5cblx0X2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblx0cmV0dXJuIF9saXN0Q2FjaGVIYXM7XG59XG5cbnZhciBfbGlzdENhY2hlU2V0O1xudmFyIGhhc1JlcXVpcmVkX2xpc3RDYWNoZVNldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9saXN0Q2FjaGVTZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbGlzdENhY2hlU2V0KSByZXR1cm4gX2xpc3RDYWNoZVNldDtcblx0aGFzUmVxdWlyZWRfbGlzdENhY2hlU2V0ID0gMTtcblx0dmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmVfYXNzb2NJbmRleE9mKCk7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgKyt0aGlzLnNpemU7XG5cdCAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfbGlzdENhY2hlU2V0ID0gbGlzdENhY2hlU2V0O1xuXHRyZXR1cm4gX2xpc3RDYWNoZVNldDtcbn1cblxudmFyIF9MaXN0Q2FjaGU7XG52YXIgaGFzUmVxdWlyZWRfTGlzdENhY2hlO1xuXG5mdW5jdGlvbiByZXF1aXJlX0xpc3RDYWNoZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9MaXN0Q2FjaGUpIHJldHVybiBfTGlzdENhY2hlO1xuXHRoYXNSZXF1aXJlZF9MaXN0Q2FjaGUgPSAxO1xuXHR2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlX2xpc3RDYWNoZUNsZWFyKCksXG5cdCAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlX2xpc3RDYWNoZURlbGV0ZSgpLFxuXHQgICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZV9saXN0Q2FjaGVHZXQoKSxcblx0ICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmVfbGlzdENhY2hlSGFzKCksXG5cdCAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlX2xpc3RDYWNoZVNldCgpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cblx0ICB0aGlzLmNsZWFyKCk7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuXHQgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcblx0ICB9XG5cdH1cblxuXHQvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cblx0TGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcblx0TGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5cdExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuXHRfTGlzdENhY2hlID0gTGlzdENhY2hlO1xuXHRyZXR1cm4gX0xpc3RDYWNoZTtcbn1cblxudmFyIF9NYXA7XG52YXIgaGFzUmVxdWlyZWRfTWFwO1xuXG5mdW5jdGlvbiByZXF1aXJlX01hcCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9NYXApIHJldHVybiBfTWFwO1xuXHRoYXNSZXF1aXJlZF9NYXAgPSAxO1xuXHR2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZV9nZXROYXRpdmUoKSxcblx0ICAgIHJvb3QgPSByZXF1aXJlX3Jvb3QoKTtcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdHZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5cdF9NYXAgPSBNYXA7XG5cdHJldHVybiBfTWFwO1xufVxuXG52YXIgX21hcENhY2hlQ2xlYXI7XG52YXIgaGFzUmVxdWlyZWRfbWFwQ2FjaGVDbGVhcjtcblxuZnVuY3Rpb24gcmVxdWlyZV9tYXBDYWNoZUNsZWFyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21hcENhY2hlQ2xlYXIpIHJldHVybiBfbWFwQ2FjaGVDbGVhcjtcblx0aGFzUmVxdWlyZWRfbWFwQ2FjaGVDbGVhciA9IDE7XG5cdHZhciBIYXNoID0gcmVxdWlyZV9IYXNoKCksXG5cdCAgICBMaXN0Q2FjaGUgPSByZXF1aXJlX0xpc3RDYWNoZSgpLFxuXHQgICAgTWFwID0gcmVxdWlyZV9NYXAoKTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBjbGVhclxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG5cdCAgdGhpcy5zaXplID0gMDtcblx0ICB0aGlzLl9fZGF0YV9fID0ge1xuXHQgICAgJ2hhc2gnOiBuZXcgSGFzaCxcblx0ICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuXHQgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG5cdCAgfTtcblx0fVxuXG5cdF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcblx0cmV0dXJuIF9tYXBDYWNoZUNsZWFyO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuXG52YXIgX2lzS2V5YWJsZTtcbnZhciBoYXNSZXF1aXJlZF9pc0tleWFibGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaXNLZXlhYmxlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2lzS2V5YWJsZSkgcmV0dXJuIF9pc0tleWFibGU7XG5cdGhhc1JlcXVpcmVkX2lzS2V5YWJsZSA9IDE7XG5cdGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG5cdCAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG5cdCAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG5cdH1cblxuXHRfaXNLZXlhYmxlID0gaXNLZXlhYmxlO1xuXHRyZXR1cm4gX2lzS2V5YWJsZTtcbn1cblxudmFyIF9nZXRNYXBEYXRhO1xudmFyIGhhc1JlcXVpcmVkX2dldE1hcERhdGE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfZ2V0TWFwRGF0YSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9nZXRNYXBEYXRhKSByZXR1cm4gX2dldE1hcERhdGE7XG5cdGhhc1JlcXVpcmVkX2dldE1hcERhdGEgPSAxO1xuXHR2YXIgaXNLZXlhYmxlID0gcmVxdWlyZV9pc0tleWFibGUoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuXHQgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuXHQgIHJldHVybiBpc0tleWFibGUoa2V5KVxuXHQgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cblx0ICAgIDogZGF0YS5tYXA7XG5cdH1cblxuXHRfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cdHJldHVybiBfZ2V0TWFwRGF0YTtcbn1cblxudmFyIF9tYXBDYWNoZURlbGV0ZTtcbnZhciBoYXNSZXF1aXJlZF9tYXBDYWNoZURlbGV0ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9tYXBDYWNoZURlbGV0ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9tYXBDYWNoZURlbGV0ZSkgcmV0dXJuIF9tYXBDYWNoZURlbGV0ZTtcblx0aGFzUmVxdWlyZWRfbWFwQ2FjaGVEZWxldGUgPSAxO1xuXHR2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmVfZ2V0TWFwRGF0YSgpO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBkZWxldGVcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcblx0ICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuXHQgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0X21hcENhY2hlRGVsZXRlID0gbWFwQ2FjaGVEZWxldGU7XG5cdHJldHVybiBfbWFwQ2FjaGVEZWxldGU7XG59XG5cbnZhciBfbWFwQ2FjaGVHZXQ7XG52YXIgaGFzUmVxdWlyZWRfbWFwQ2FjaGVHZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbWFwQ2FjaGVHZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbWFwQ2FjaGVHZXQpIHJldHVybiBfbWFwQ2FjaGVHZXQ7XG5cdGhhc1JlcXVpcmVkX21hcENhY2hlR2V0ID0gMTtcblx0dmFyIGdldE1hcERhdGEgPSByZXF1aXJlX2dldE1hcERhdGEoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgZ2V0XG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG5cdCAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcblx0fVxuXG5cdF9tYXBDYWNoZUdldCA9IG1hcENhY2hlR2V0O1xuXHRyZXR1cm4gX21hcENhY2hlR2V0O1xufVxuXG52YXIgX21hcENhY2hlSGFzO1xudmFyIGhhc1JlcXVpcmVkX21hcENhY2hlSGFzO1xuXG5mdW5jdGlvbiByZXF1aXJlX21hcENhY2hlSGFzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21hcENhY2hlSGFzKSByZXR1cm4gX21hcENhY2hlSGFzO1xuXHRoYXNSZXF1aXJlZF9tYXBDYWNoZUhhcyA9IDE7XG5cdHZhciBnZXRNYXBEYXRhID0gcmVxdWlyZV9nZXRNYXBEYXRhKCk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcblx0ICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuXHR9XG5cblx0X21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cdHJldHVybiBfbWFwQ2FjaGVIYXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQ7XG52YXIgaGFzUmVxdWlyZWRfbWFwQ2FjaGVTZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbWFwQ2FjaGVTZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbWFwQ2FjaGVTZXQpIHJldHVybiBfbWFwQ2FjaGVTZXQ7XG5cdGhhc1JlcXVpcmVkX21hcENhY2hlU2V0ID0gMTtcblx0dmFyIGdldE1hcERhdGEgPSByZXF1aXJlX2dldE1hcERhdGEoKTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIHNldFxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuXHQgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuXHQgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG5cdCAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblx0cmV0dXJuIF9tYXBDYWNoZVNldDtcbn1cblxudmFyIF9NYXBDYWNoZTtcbnZhciBoYXNSZXF1aXJlZF9NYXBDYWNoZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9NYXBDYWNoZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9NYXBDYWNoZSkgcmV0dXJuIF9NYXBDYWNoZTtcblx0aGFzUmVxdWlyZWRfTWFwQ2FjaGUgPSAxO1xuXHR2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmVfbWFwQ2FjaGVDbGVhcigpLFxuXHQgICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlX21hcENhY2hlRGVsZXRlKCksXG5cdCAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmVfbWFwQ2FjaGVHZXQoKSxcblx0ICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZV9tYXBDYWNoZUhhcygpLFxuXHQgICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlX21hcENhY2hlU2V0KCk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgKi9cblx0ZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cblx0ICB0aGlzLmNsZWFyKCk7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuXHQgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcblx0ICB9XG5cdH1cblxuXHQvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuXHRNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuXHRNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5cdE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcblx0TWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuXHRNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cblx0X01hcENhY2hlID0gTWFwQ2FjaGU7XG5cdHJldHVybiBfTWFwQ2FjaGU7XG59XG5cbnZhciBtZW1vaXplXzE7XG52YXIgaGFzUmVxdWlyZWRNZW1vaXplO1xuXG5mdW5jdGlvbiByZXF1aXJlTWVtb2l6ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZE1lbW9pemUpIHJldHVybiBtZW1vaXplXzE7XG5cdGhhc1JlcXVpcmVkTWVtb2l6ZSA9IDE7XG5cdHZhciBNYXBDYWNoZSA9IHJlcXVpcmVfTWFwQ2FjaGUoKTtcblxuXHQvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG5cdHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG5cdCAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcblx0ICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdCAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG5cdCAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG5cdCAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuXHQgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuXHQgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuXHQgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMC4xLjBcblx0ICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcblx0ICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuXHQgKlxuXHQgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcblx0ICogdmFsdWVzKG9iamVjdCk7XG5cdCAqIC8vID0+IFsxLCAyXVxuXHQgKlxuXHQgKiB2YWx1ZXMob3RoZXIpO1xuXHQgKiAvLyA9PiBbMywgNF1cblx0ICpcblx0ICogb2JqZWN0LmEgPSAyO1xuXHQgKiB2YWx1ZXMob2JqZWN0KTtcblx0ICogLy8gPT4gWzEsIDJdXG5cdCAqXG5cdCAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuXHQgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG5cdCAqIHZhbHVlcyhvYmplY3QpO1xuXHQgKiAvLyA9PiBbJ2EnLCAnYiddXG5cdCAqXG5cdCAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG5cdCAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG5cdCAqL1xuXHRmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG5cdCAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG5cdCAgfVxuXHQgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdCAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG5cdCAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuXHQgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG5cdCAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcblx0ICByZXR1cm4gbWVtb2l6ZWQ7XG5cdH1cblxuXHQvLyBFeHBvc2UgYE1hcENhY2hlYC5cblx0bWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5cdG1lbW9pemVfMSA9IG1lbW9pemU7XG5cdHJldHVybiBtZW1vaXplXzE7XG59XG5cbnZhciBfbWVtb2l6ZUNhcHBlZDtcbnZhciBoYXNSZXF1aXJlZF9tZW1vaXplQ2FwcGVkO1xuXG5mdW5jdGlvbiByZXF1aXJlX21lbW9pemVDYXBwZWQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbWVtb2l6ZUNhcHBlZCkgcmV0dXJuIF9tZW1vaXplQ2FwcGVkO1xuXHRoYXNSZXF1aXJlZF9tZW1vaXplQ2FwcGVkID0gMTtcblx0dmFyIG1lbW9pemUgPSByZXF1aXJlTWVtb2l6ZSgpO1xuXG5cdC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cblx0dmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cblx0LyoqXG5cdCAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3Ncblx0ICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuXHQgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuXHQgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcblx0ICAgICAgY2FjaGUuY2xlYXIoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBrZXk7XG5cdCAgfSk7XG5cblx0ICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdF9tZW1vaXplQ2FwcGVkID0gbWVtb2l6ZUNhcHBlZDtcblx0cmV0dXJuIF9tZW1vaXplQ2FwcGVkO1xufVxuXG52YXIgX3N0cmluZ1RvUGF0aDtcbnZhciBoYXNSZXF1aXJlZF9zdHJpbmdUb1BhdGg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfc3RyaW5nVG9QYXRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX3N0cmluZ1RvUGF0aCkgcmV0dXJuIF9zdHJpbmdUb1BhdGg7XG5cdGhhc1JlcXVpcmVkX3N0cmluZ1RvUGF0aCA9IDE7XG5cdHZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZV9tZW1vaXplQ2FwcGVkKCk7XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuXHR2YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuXHQvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblx0dmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG5cdCAqL1xuXHR2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG5cdCAgICByZXN1bHQucHVzaCgnJyk7XG5cdCAgfVxuXHQgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0ICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcblx0ICB9KTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9KTtcblxuXHRfc3RyaW5nVG9QYXRoID0gc3RyaW5nVG9QYXRoO1xuXHRyZXR1cm4gX3N0cmluZ1RvUGF0aDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cblxudmFyIF9hcnJheU1hcDtcbnZhciBoYXNSZXF1aXJlZF9hcnJheU1hcDtcblxuZnVuY3Rpb24gcmVxdWlyZV9hcnJheU1hcCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9hcnJheU1hcCkgcmV0dXJuIF9hcnJheU1hcDtcblx0aGFzUmVxdWlyZWRfYXJyYXlNYXAgPSAxO1xuXHRmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG5cdCAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdF9hcnJheU1hcCA9IGFycmF5TWFwO1xuXHRyZXR1cm4gX2FycmF5TWFwO1xufVxuXG52YXIgX2Jhc2VUb1N0cmluZztcbnZhciBoYXNSZXF1aXJlZF9iYXNlVG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZVRvU3RyaW5nICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VUb1N0cmluZykgcmV0dXJuIF9iYXNlVG9TdHJpbmc7XG5cdGhhc1JlcXVpcmVkX2Jhc2VUb1N0cmluZyA9IDE7XG5cdHZhciBTeW1ib2wgPSByZXF1aXJlX1N5bWJvbCgpLFxuXHQgICAgYXJyYXlNYXAgPSByZXF1aXJlX2FycmF5TWFwKCksXG5cdCAgICBpc0FycmF5ID0gcmVxdWlyZUlzQXJyYXkoKSxcblx0ICAgIGlzU3ltYm9sID0gcmVxdWlyZUlzU3ltYm9sKCk7XG5cblx0LyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG5cdHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG5cdCAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuXHQgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG5cdCAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cblx0ICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHQgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHQgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cblx0ICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuXHQgIH1cblx0ICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuXHQgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSW5maW5pdHkpID8gJy0wJyA6IHJlc3VsdDtcblx0fVxuXG5cdF9iYXNlVG9TdHJpbmcgPSBiYXNlVG9TdHJpbmc7XG5cdHJldHVybiBfYmFzZVRvU3RyaW5nO1xufVxuXG52YXIgdG9TdHJpbmdfMTtcbnZhciBoYXNSZXF1aXJlZFRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXF1aXJlVG9TdHJpbmcgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRUb1N0cmluZykgcmV0dXJuIHRvU3RyaW5nXzE7XG5cdGhhc1JlcXVpcmVkVG9TdHJpbmcgPSAxO1xuXHR2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZV9iYXNlVG9TdHJpbmcoKTtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcblx0ICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8udG9TdHJpbmcobnVsbCk7XG5cdCAqIC8vID0+ICcnXG5cdCAqXG5cdCAqIF8udG9TdHJpbmcoLTApO1xuXHQgKiAvLyA9PiAnLTAnXG5cdCAqXG5cdCAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcblx0ICogLy8gPT4gJzEsMiwzJ1xuXHQgKi9cblx0ZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcblx0ICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcblx0fVxuXG5cdHRvU3RyaW5nXzEgPSB0b1N0cmluZztcblx0cmV0dXJuIHRvU3RyaW5nXzE7XG59XG5cbnZhciBfY2FzdFBhdGg7XG52YXIgaGFzUmVxdWlyZWRfY2FzdFBhdGg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfY2FzdFBhdGggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfY2FzdFBhdGgpIHJldHVybiBfY2FzdFBhdGg7XG5cdGhhc1JlcXVpcmVkX2Nhc3RQYXRoID0gMTtcblx0dmFyIGlzQXJyYXkgPSByZXF1aXJlSXNBcnJheSgpLFxuXHQgICAgaXNLZXkgPSByZXF1aXJlX2lzS2V5KCksXG5cdCAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlX3N0cmluZ1RvUGF0aCgpLFxuXHQgICAgdG9TdHJpbmcgPSByZXF1aXJlVG9TdHJpbmcoKTtcblxuXHQvKipcblx0ICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cblx0ICovXG5cdGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcblx0ICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuXHR9XG5cblx0X2Nhc3RQYXRoID0gY2FzdFBhdGg7XG5cdHJldHVybiBfY2FzdFBhdGg7XG59XG5cbnZhciBfdG9LZXk7XG52YXIgaGFzUmVxdWlyZWRfdG9LZXk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfdG9LZXkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfdG9LZXkpIHJldHVybiBfdG9LZXk7XG5cdGhhc1JlcXVpcmVkX3RvS2V5ID0gMTtcblx0dmFyIGlzU3ltYm9sID0gcmVxdWlyZUlzU3ltYm9sKCk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cblx0ICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcblx0ICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUluZmluaXR5KSA/ICctMCcgOiByZXN1bHQ7XG5cdH1cblxuXHRfdG9LZXkgPSB0b0tleTtcblx0cmV0dXJuIF90b0tleTtcbn1cblxudmFyIF9iYXNlR2V0O1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VHZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZUdldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlR2V0KSByZXR1cm4gX2Jhc2VHZXQ7XG5cdGhhc1JlcXVpcmVkX2Jhc2VHZXQgPSAxO1xuXHR2YXIgY2FzdFBhdGggPSByZXF1aXJlX2Nhc3RQYXRoKCksXG5cdCAgICB0b0tleSA9IHJlcXVpcmVfdG9LZXkoKTtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG5cdCAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cblx0ICB2YXIgaW5kZXggPSAwLFxuXHQgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuXHQgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcblx0ICB9XG5cdCAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuXHR9XG5cblx0X2Jhc2VHZXQgPSBiYXNlR2V0O1xuXHRyZXR1cm4gX2Jhc2VHZXQ7XG59XG5cbnZhciBnZXRfMTtcbnZhciBoYXNSZXF1aXJlZEdldDtcblxuZnVuY3Rpb24gcmVxdWlyZUdldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEdldCkgcmV0dXJuIGdldF8xO1xuXHRoYXNSZXF1aXJlZEdldCA9IDE7XG5cdHZhciBiYXNlR2V0ID0gcmVxdWlyZV9iYXNlR2V0KCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG5cdCAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAzLjcuMFxuXHQgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuXHQgKlxuXHQgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuXHQgKiAvLyA9PiAzXG5cdCAqXG5cdCAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuXHQgKiAvLyA9PiAzXG5cdCAqXG5cdCAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcblx0ICogLy8gPT4gJ2RlZmF1bHQnXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcblx0ICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cdCAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuXHR9XG5cblx0Z2V0XzEgPSBnZXQ7XG5cdHJldHVybiBnZXRfMTtcbn1cblxudmFyIGdldEV4cG9ydHMgPSByZXF1aXJlR2V0KCk7XG52YXIgZ2V0ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldEV4cG9ydHMpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5O1xudmFyIGhhc1JlcXVpcmVkX2RlZmluZVByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXF1aXJlX2RlZmluZVByb3BlcnR5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2RlZmluZVByb3BlcnR5KSByZXR1cm4gX2RlZmluZVByb3BlcnR5O1xuXHRoYXNSZXF1aXJlZF9kZWZpbmVQcm9wZXJ0eSA9IDE7XG5cdHZhciBnZXROYXRpdmUgPSByZXF1aXJlX2dldE5hdGl2ZSgpO1xuXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0ICB0cnkge1xuXHQgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcblx0ICAgIGZ1bmMoe30sICcnLCB7fSk7XG5cdCAgICByZXR1cm4gZnVuYztcblx0ICB9IGNhdGNoIChlKSB7fVxuXHR9KCkpO1xuXG5cdF9kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5O1xuXHRyZXR1cm4gX2RlZmluZVByb3BlcnR5O1xufVxuXG52YXIgX2Jhc2VBc3NpZ25WYWx1ZTtcbnZhciBoYXNSZXF1aXJlZF9iYXNlQXNzaWduVmFsdWU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZUFzc2lnblZhbHVlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VBc3NpZ25WYWx1ZSkgcmV0dXJuIF9iYXNlQXNzaWduVmFsdWU7XG5cdGhhc1JlcXVpcmVkX2Jhc2VBc3NpZ25WYWx1ZSA9IDE7XG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKTtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcblx0ICogdmFsdWUgY2hlY2tzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuXHQgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcblx0ICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG5cdCAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuXHQgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG5cdCAgICAgICd2YWx1ZSc6IHZhbHVlLFxuXHQgICAgICAnd3JpdGFibGUnOiB0cnVlXG5cdCAgICB9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICB9XG5cdH1cblxuXHRfYmFzZUFzc2lnblZhbHVlID0gYmFzZUFzc2lnblZhbHVlO1xuXHRyZXR1cm4gX2Jhc2VBc3NpZ25WYWx1ZTtcbn1cblxudmFyIF9hc3NpZ25WYWx1ZTtcbnZhciBoYXNSZXF1aXJlZF9hc3NpZ25WYWx1ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9hc3NpZ25WYWx1ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9hc3NpZ25WYWx1ZSkgcmV0dXJuIF9hc3NpZ25WYWx1ZTtcblx0aGFzUmVxdWlyZWRfYXNzaWduVmFsdWUgPSAxO1xuXHR2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZV9iYXNlQXNzaWduVmFsdWUoKSxcblx0ICAgIGVxID0gcmVxdWlyZUVxKCk7XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuXHQgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuXHQgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcblx0ICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuXHQgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuXHQgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG5cdCAgfVxuXHR9XG5cblx0X2Fzc2lnblZhbHVlID0gYXNzaWduVmFsdWU7XG5cdHJldHVybiBfYXNzaWduVmFsdWU7XG59XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXG52YXIgX2lzSW5kZXg7XG52YXIgaGFzUmVxdWlyZWRfaXNJbmRleDtcblxuZnVuY3Rpb24gcmVxdWlyZV9pc0luZGV4ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2lzSW5kZXgpIHJldHVybiBfaXNJbmRleDtcblx0aGFzUmVxdWlyZWRfaXNJbmRleCA9IDE7XG5cdHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG5cdHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG5cdCAgcmV0dXJuICEhbGVuZ3RoICYmXG5cdCAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuXHQgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG5cdCAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuXHR9XG5cblx0X2lzSW5kZXggPSBpc0luZGV4O1xuXHRyZXR1cm4gX2lzSW5kZXg7XG59XG5cbnZhciBfYmFzZVNldDtcbnZhciBoYXNSZXF1aXJlZF9iYXNlU2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VTZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZVNldCkgcmV0dXJuIF9iYXNlU2V0O1xuXHRoYXNSZXF1aXJlZF9iYXNlU2V0ID0gMTtcblx0dmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZV9hc3NpZ25WYWx1ZSgpLFxuXHQgICAgY2FzdFBhdGggPSByZXF1aXJlX2Nhc3RQYXRoKCksXG5cdCAgICBpc0luZGV4ID0gcmVxdWlyZV9pc0luZGV4KCksXG5cdCAgICBpc09iamVjdCA9IHJlcXVpcmVJc09iamVjdCgpLFxuXHQgICAgdG9LZXkgPSByZXF1aXJlX3RvS2V5KCk7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cblx0ICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuXHQgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuXHQgICAgcmV0dXJuIG9iamVjdDtcblx0ICB9XG5cdCAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG5cdCAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG5cdCAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuXHQgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuXHQgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cblx0ICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG5cdCAgICAgIHJldHVybiBvYmplY3Q7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcblx0ICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG5cdCAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcblx0ICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuXHQgICAgICAgICAgPyBvYmpWYWx1ZVxuXHQgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG5cdCAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcblx0ICB9XG5cdCAgcmV0dXJuIG9iamVjdDtcblx0fVxuXG5cdF9iYXNlU2V0ID0gYmFzZVNldDtcblx0cmV0dXJuIF9iYXNlU2V0O1xufVxuXG52YXIgc2V0XzE7XG52YXIgaGFzUmVxdWlyZWRTZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVTZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRTZXQpIHJldHVybiBzZXRfMTtcblx0aGFzUmVxdWlyZWRTZXQgPSAxO1xuXHR2YXIgYmFzZVNldCA9IHJlcXVpcmVfYmFzZVNldCgpO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcblx0ICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG5cdCAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG5cdCAqIGBwYXRoYCBjcmVhdGlvbi5cblx0ICpcblx0ICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDMuNy4wXG5cdCAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cblx0ICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuXHQgKlxuXHQgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuXHQgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuXHQgKiAvLyA9PiA0XG5cdCAqXG5cdCAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuXHQgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuXHQgKiAvLyA9PiA1XG5cdCAqL1xuXHRmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHQgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG5cdH1cblxuXHRzZXRfMSA9IHNldDtcblx0cmV0dXJuIHNldF8xO1xufVxuXG52YXIgc2V0RXhwb3J0cyA9IHJlcXVpcmVTZXQoKTtcbnZhciBzZXQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc2V0RXhwb3J0cyk7XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuXG52YXIgX2NvcHlBcnJheTtcbnZhciBoYXNSZXF1aXJlZF9jb3B5QXJyYXk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfY29weUFycmF5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2NvcHlBcnJheSkgcmV0dXJuIF9jb3B5QXJyYXk7XG5cdGhhc1JlcXVpcmVkX2NvcHlBcnJheSA9IDE7XG5cdGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cblx0ICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcblx0ICB9XG5cdCAgcmV0dXJuIGFycmF5O1xuXHR9XG5cblx0X2NvcHlBcnJheSA9IGNvcHlBcnJheTtcblx0cmV0dXJuIF9jb3B5QXJyYXk7XG59XG5cbnZhciB0b1BhdGhfMTtcbnZhciBoYXNSZXF1aXJlZFRvUGF0aDtcblxuZnVuY3Rpb24gcmVxdWlyZVRvUGF0aCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFRvUGF0aCkgcmV0dXJuIHRvUGF0aF8xO1xuXHRoYXNSZXF1aXJlZFRvUGF0aCA9IDE7XG5cdHZhciBhcnJheU1hcCA9IHJlcXVpcmVfYXJyYXlNYXAoKSxcblx0ICAgIGNvcHlBcnJheSA9IHJlcXVpcmVfY29weUFycmF5KCksXG5cdCAgICBpc0FycmF5ID0gcmVxdWlyZUlzQXJyYXkoKSxcblx0ICAgIGlzU3ltYm9sID0gcmVxdWlyZUlzU3ltYm9sKCksXG5cdCAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlX3N0cmluZ1RvUGF0aCgpLFxuXHQgICAgdG9LZXkgPSByZXF1aXJlX3RvS2V5KCksXG5cdCAgICB0b1N0cmluZyA9IHJlcXVpcmVUb1N0cmluZygpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IFV0aWxcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b1BhdGgoJ2EuYi5jJyk7XG5cdCAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuXHQgKlxuXHQgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcblx0ICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cblx0ICovXG5cdGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuXHQgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG5cdCAgfVxuXHQgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcblx0fVxuXG5cdHRvUGF0aF8xID0gdG9QYXRoO1xuXHRyZXR1cm4gdG9QYXRoXzE7XG59XG5cbnZhciB0b1BhdGhFeHBvcnRzID0gcmVxdWlyZVRvUGF0aCgpO1xudmFyIHRvUGF0aCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh0b1BhdGhFeHBvcnRzKTtcblxudmFyIGRlZmluZSQyID0ge1xuICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgaW1tdXRhYmxlS2V5czoge30sXG4gICAgICAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZSxcbiAgICAgIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KHNlbGYpIHt9LFxuICAgICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoc2VsZiwgb2JqKSB7fSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChzZWxmKSB7fSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24gY2FuU2V0KHNlbGYpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkYXRhSW1wbChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjtcblxuICAgICAgLy8gLmRhdGEoJ2ZvbycsIC4uLilcbiAgICAgIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgICAgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuICAgICAgICB2YXIgaXNQYXRoTGlrZSA9IG5hbWUuaW5kZXhPZignLicpICE9PSAtMTsgLy8gdGhlcmUgbWlnaHQgYmUgYSBub3JtYWwgZmllbGQgd2l0aCBhIGRvdCBcbiAgICAgICAgdmFyIHBhdGggPSBpc1BhdGhMaWtlICYmIHRvUGF0aChuYW1lKTtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJylcbiAgICAgICAgaWYgKHAuYWxsb3dHZXR0aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXRcblxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBwYXRoIGFuZCBhIGZpZWxkIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAocGF0aCAmJiBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXQgPSBnZXQoc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdLCBwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgIC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBfZGVmaW5lUHJvcGVydHkkMSh7fSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgY2hhbmdlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgICAgICBpZiAocC5jYW5TZXQoZWxlKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoICYmIHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBzZXQoZWxlLl9wcml2YXRlW3AuZmllbGRdLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgICBwLm9uU2V0KHNlbGYpO1xuICAgICAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAuZGF0YSh7ICdmb28nOiAnYmFyJyB9KVxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiBwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgICAvLyBleHRlbmRcbiAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgIHZhciBrLCB2O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIG9iaik7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGsgPSBrZXlzW19pXTtcbiAgICAgICAgICB2ID0gb2JqW2tdO1xuICAgICAgICAgIHZhciBfdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tdO1xuICAgICAgICAgIGlmIChfdmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfZWxlID0gYWxsW2pdO1xuICAgICAgICAgICAgICBpZiAocC5jYW5TZXQoX2VsZSkpIHtcbiAgICAgICAgICAgICAgICBfZWxlLl9wcml2YXRlW3AuZmllbGRdW2tdID0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgIGlmIChwLnVwZGF0ZVN0eWxlKSB7XG4gICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICBwLm9uU2V0KHNlbGYpO1xuICAgICAgICBpZiAocC5zZXR0aW5nVHJpZ2dlcnNFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLnNldHRpbmdFdmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0JpbmRpbmcgJiYgZm4kNihuYW1lKSkge1xuICAgICAgICAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgIHNlbGYub24ocC5iaW5kaW5nRXZlbnQsIGZuKTtcblxuICAgICAgICAvLyAuZGF0YSgpXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dHZXR0aW5nICYmIG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBnZXQgd2hvbGUgb2JqZWN0XG4gICAgICAgIHZhciBfcmV0O1xuICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTtcbiAgICAgICAgICBfcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgIH07IC8vIGZ1bmN0aW9uXG4gIH0sXG4gIC8vIGRhdGFcblxuICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRGF0YUltcGwobmFtZXMpIHtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcbiAgICAgIGlmIChzdHJpbmcobmFtZXMpKSB7XG4gICAgICAgIC8vIHRoZW4gZ2V0IHRoZSBsaXN0IG9mIGtleXMsIGFuZCBkZWxldGUgdGhlbVxuICAgICAgICB2YXIga2V5cyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChlbXB0eVN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trZXldOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG4gICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrKSB7XG4gICAgICAgICAgICAgIGFsbFtpX2FdLl9wcml2YXRlW3AuZmllbGRdW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC5yZW1vdmVEYXRhKClcbiAgICAgIH0gZWxzZSBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuXG4gICAgICAgIGZvciAodmFyIF9pX2EgPSAwLCBfbF9hID0gYWxsLmxlbmd0aDsgX2lfYSA8IF9sX2E7IF9pX2ErKykge1xuICAgICAgICAgIHZhciBfcHJpdmF0ZUZpZWxkcyA9IGFsbFtfaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyhfcHJpdmF0ZUZpZWxkcyk7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2tleXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIF9rZXkgPSBfa2V5c1tfaTJdO1xuICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzW19rZXldO1xuICAgICAgICAgICAgaWYgKHZhbGlkS2V5VG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgX3ByaXZhdGVGaWVsZHNbX2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSAvLyByZW1vdmVEYXRhXG59OyAvLyBkZWZpbmVcblxudmFyIGRlZmluZSQxID0ge1xuICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24gZXZlbnRBbGlhc2VzT24ocHJvdG8pIHtcbiAgICB2YXIgcCA9IHByb3RvO1xuICAgIHAuYWRkTGlzdGVuZXIgPSBwLmxpc3RlbiA9IHAuYmluZCA9IHAub247XG4gICAgcC51bmxpc3RlbiA9IHAudW5iaW5kID0gcC5vZmYgPSBwLnJlbW92ZUxpc3RlbmVyO1xuICAgIHAudHJpZ2dlciA9IHAuZW1pdDtcblxuICAgIC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcbiAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24gKGV2ZW50cywgc2VsZWN0b3IpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZSkge1xuICAgICAgICAgIHNlbGYub2ZmLmFwcGx5KHNlbGYsIG9mZkFyZ3MpO1xuICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkFyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgdmFyIG9mZkFyZ3MgPSBvbkFyZ3MuY29uY2F0KFtdKTtcbiAgICAgICAgc2VsZi5vbi5hcHBseShzZWxmLCBvbkFyZ3MpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufTsgLy8gZGVmaW5lXG5cbi8vIHVzZSB0aGlzIG1vZHVsZSB0byBjaGVycnkgcGljayBmdW5jdGlvbnMgaW50byB5b3VyIHByb3RvdHlwZVxuLy8gKHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIHRoZSBjb3JlIGFuZCBjb2xsZWN0aW9ucywgZm9yIGV4YW1wbGUpXG5cbnZhciBkZWZpbmUgPSB7fTtcbltkZWZpbmUkMywgZGVmaW5lJDIsIGRlZmluZSQxXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIGV4dGVuZChkZWZpbmUsIG0pO1xufSk7XG5cbnZhciBlbGVzZm4kaSA9IHtcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKClcbn07XG5cbnZhciBlbGVzZm4kaCA9IHtcbiAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcyhfY2xhc3Nlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoX2NsYXNzZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgc2VsZlswXS5fcHJpdmF0ZS5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgICByZXR1cm4gcmV0LnB1c2goY2xzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2UgaWYgKCFhcnJheShfY2xhc3NlcykpIHtcbiAgICAgIC8vIGV4dHJhY3QgY2xhc3NlcyBmcm9tIHN0cmluZ1xuICAgICAgX2NsYXNzZXMgPSAoX2NsYXNzZXMgfHwgJycpLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIH1cbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzU2V0ID0gbmV3IFNldCQxKF9jbGFzc2VzKTtcblxuICAgIC8vIGNoZWNrIGFuZCB1cGRhdGUgZWFjaCBlbGVcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2pdO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGVsZUNsYXNzZXMgPSBfcC5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgZWxlIGhhcyBhbGwgb2YgdGhlIHBhc3NlZCBjbGFzc2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbHMgPSBfY2xhc3Nlc1tpXTtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcbiAgICAgICAgaWYgKCFlbGVIYXNDbGFzcykge1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIGVsZSBoYXMgY2xhc3NlcyBvdXRzaWRlIG9mIHRob3NlIHBhc3NlZFxuICAgICAgaWYgKCFjaGFuZ2VkRWxlKSB7XG4gICAgICAgIGNoYW5nZWRFbGUgPSBlbGVDbGFzc2VzLnNpemUgIT09IF9jbGFzc2VzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFuZ2VkRWxlKSB7XG4gICAgICAgIF9wLmNsYXNzZXMgPSBjbGFzc2VzU2V0O1xuICAgICAgICBjaGFuZ2VkLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NlcywgdHJ1ZSk7XG4gIH0sXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXMuaGFzKGNsYXNzTmFtZSk7XG4gIH0sXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhjbGFzc2VzLCB0b2dnbGUpIHtcbiAgICBpZiAoIWFycmF5KGNsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRvZ2dsZVVuZGVmZCA9IHRvZ2dsZSA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcbiAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcbiAgICAgICAgdmFyIGNoYW5nZWROb3cgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgIWhhc0NsYXNzKSB7XG4gICAgICAgICAgZWxlQ2xhc3Nlcy5hZGQoY2xzKTtcbiAgICAgICAgICBjaGFuZ2VkTm93ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghdG9nZ2xlIHx8IHRvZ2dsZVVuZGVmZCAmJiBoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXNbXCJkZWxldGVcIl0oY2xzKTtcbiAgICAgICAgICBjaGFuZ2VkTm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoYW5nZWRFbGUgJiYgY2hhbmdlZE5vdykge1xuICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBqIGNsYXNzZXNcbiAgICB9IC8vIGZvciBpIGVsZXNcblxuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCBmYWxzZSk7XG4gIH0sXG4gIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uIGZsYXNoQ2xhc3MoY2xhc3NlcywgZHVyYXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgIGR1cmF0aW9uID0gMjUwO1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBzZWxmOyAvLyBub3RoaW5nIHRvIGRvIHJlYWxseVxuICAgIH1cbiAgICBzZWxmLmFkZENsYXNzKGNsYXNzZXMpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICB9LCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn07XG5lbGVzZm4kaC5jbGFzc05hbWUgPSBlbGVzZm4kaC5jbGFzc05hbWVzID0gZWxlc2ZuJGguY2xhc3NlcztcblxuLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxudmFyIHRva2VucyA9IHtcbiAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLFxuICAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiBsZXQgbmFtZXMsIGV0Y1xuICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLFxuICAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLFxuICAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pKlwiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSonXCIsXG4gIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gIG51bWJlcjogbnVtYmVyLFxuICAvLyBudW1iZXIgbGl0ZXJhbCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0tIGUuZy4gMC4xMjM0LCAxMjM0LCAxMmUxMjNcbiAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLFxuICAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJyxcbiAgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgZGVzY2VuZGFudDogJ1xcXFxzKycsXG4gIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gIHN1YmplY3Q6ICdcXFxcJCcsXG4gIGdyb3VwOiAnbm9kZXxlZGdlfFxcXFwqJyxcbiAgZGlyZWN0ZWRFZGdlOiAnXFxcXHMrLT5cXFxccysnLFxuICB1bmRpcmVjdGVkRWRnZTogJ1xcXFxzKzwtPlxcXFxzKydcbn07XG50b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LS5dfCg/OlxcXFxcXFxcJyArIHRva2Vucy5tZXRhQ2hhciArICcpKSsnOyAvLyBhIHZhcmlhYmxlIG5hbWUgY2FuIGhhdmUgbGV0dGVycywgbnVtYmVycywgZGFzaGVzLCBhbmQgcGVyaW9kc1xudG9rZW5zLmNsYXNzTmFtZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSBjbGFzcyBuYW1lIGhhcyB0aGUgc2FtZSBydWxlcyBhcyBhIHZhcmlhYmxlIGV4Y2VwdCBpdCBjYW4ndCBoYXZlIGEgJy4nIGluIHRoZSBuYW1lXG50b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG50b2tlbnMuaWQgPSB0b2tlbnMudmFyaWFibGU7IC8vIGFuIGVsZW1lbnQgaWQgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHMsIG9wLCBpO1xuXG4gIC8vIGFkZCBAIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgfVxuXG4gIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICBpZiAob3AuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuICAgIGlmIChvcCA9PT0gJz0nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogTWFrZSBhIG5ldyBxdWVyeSBvYmplY3RcbiAqXG4gKiBAcHJvcCB0eXBlIHtUeXBlfSBUaGUgdHlwZSBlbnVtIChpbnQpIG9mIHRoZSBxdWVyeVxuICogQHByb3AgY2hlY2tzIExpc3Qgb2YgY2hlY2tzIHRvIG1ha2UgYWdhaW5zdCBhbiBlbGUgdG8gdGVzdCBmb3IgYSBtYXRjaFxuICovXG52YXIgbmV3UXVlcnkgPSBmdW5jdGlvbiBuZXdRdWVyeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja3M6IFtdXG4gIH07XG59O1xuXG4vKipcbiAqIEEgY2hlY2sgdHlwZSBlbnVtLWxpa2Ugb2JqZWN0LiAgVXNlcyBpbnRlZ2VyIHZhbHVlcyBmb3IgZmFzdCBtYXRjaCgpIGxvb2t1cC5cbiAqIFRoZSBvcmRlcmluZyBkb2VzIG5vdCBtYXR0ZXIgYXMgbG9uZyBhcyB0aGUgaW50cyBhcmUgdW5pcXVlLlxuICovXG52YXIgVHlwZSA9IHtcbiAgLyoqIEUuZy4gbm9kZSAqL1xuICBHUk9VUDogMCxcbiAgLyoqIEEgY29sbGVjdGlvbiBvZiBlbGVtZW50cyAqL1xuICBDT0xMRUNUSU9OOiAxLFxuICAvKiogQSBmaWx0ZXIoZWxlKSBmdW5jdGlvbiAqL1xuICBGSUxURVI6IDIsXG4gIC8qKiBFLmcuIFtmb28gPiAxXSAqL1xuICBEQVRBX0NPTVBBUkU6IDMsXG4gIC8qKiBFLmcuIFtmb29dICovXG4gIERBVEFfRVhJU1Q6IDQsXG4gIC8qKiBFLmcuIFs/Zm9vXSAqL1xuICBEQVRBX0JPT0w6IDUsXG4gIC8qKiBFLmcuIFtbZGVncmVlID4gMl1dICovXG4gIE1FVEFfQ09NUEFSRTogNixcbiAgLyoqIEUuZy4gOnNlbGVjdGVkICovXG4gIFNUQVRFOiA3LFxuICAvKiogRS5nLiAjZm9vICovXG4gIElEOiA4LFxuICAvKiogRS5nLiAuZm9vICovXG4gIENMQVNTOiA5LFxuICAvKiogRS5nLiAjZm9vIDwtPiAjYmFyICovXG4gIFVORElSRUNURURfRURHRTogMTAsXG4gIC8qKiBFLmcuICNmb28gLT4gI2JhciAqL1xuICBESVJFQ1RFRF9FREdFOiAxMSxcbiAgLyoqIEUuZy4gJCNmb28gLT4gI2JhciAqL1xuICBOT0RFX1NPVVJDRTogMTIsXG4gIC8qKiBFLmcuICNmb28gLT4gJCNiYXIgKi9cbiAgTk9ERV9UQVJHRVQ6IDEzLFxuICAvKiogRS5nLiAkI2ZvbyA8LT4gI2JhciAqL1xuICBOT0RFX05FSUdIQk9SOiAxNCxcbiAgLyoqIEUuZy4gI2ZvbyA+ICNiYXIgKi9cbiAgQ0hJTEQ6IDE1LFxuICAvKiogRS5nLiAjZm9vICNiYXIgKi9cbiAgREVTQ0VOREFOVDogMTYsXG4gIC8qKiBFLmcuICQjZm9vID4gI2JhciAqL1xuICBQQVJFTlQ6IDE3LFxuICAvKiogRS5nLiAkI2ZvbyAjYmFyICovXG4gIEFOQ0VTVE9SOiAxOCxcbiAgLyoqIEUuZy4gI2ZvbyA+ICRiYXIgPiAjYmF6ICovXG4gIENPTVBPVU5EX1NQTElUOiAxOSxcbiAgLyoqIEFsd2F5cyBtYXRjaGVzLCB1c2VmdWwgcGxhY2Vob2xkZXIgZm9yIHN1YmplY3QgaW4gYENPTVBPVU5EX1NQTElUYCAqL1xuICBUUlVFOiAyMFxufTtcblxudmFyIHN0YXRlU2VsZWN0b3JzID0gW3tcbiAgc2VsZWN0b3I6ICc6c2VsZWN0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5zZWxlY3RlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuc2VsZWN0YWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0YWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmxvY2tlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5sb2NrZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmxvY2tlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dmlzaWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS52aXNpYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aGlkZGVuJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dHJhbnNwYXJlbnQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudHJhbnNwYXJlbnQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpncmFiYmVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmdyYWJiZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpmcmVlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6cmVtb3ZlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW1vdmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5zaWRlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5yZW1vdmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmdyYWJiYWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuZ3JhYmJhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphbmltYXRlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuYW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFuaW1hdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6cGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y2hpbGRsZXNzJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGRsZXNzKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y2hpbGQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm9ycGhhbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbm9ycGhhbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Y29tcG91bmQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpO1xuICAgIH1cbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb29wJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnNpbXBsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1NpbXBsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmFjdGl2ZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5hY3RpdmUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzppbmFjdGl2ZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YmFja2dyb3VuZGluZycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bm9uYmFja2dyb3VuZGluZycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59XS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIC8vIG4uYi4gc2VsZWN0b3JzIHRoYXQgYXJlIHN0YXJ0aW5nIHN1YnN0cmluZ3Mgb2Ygb3RoZXJzIG11c3QgaGF2ZSB0aGUgbG9uZ2VyIG9uZXMgZmlyc3RcbiAgcmV0dXJuIGRlc2NlbmRpbmcoYS5zZWxlY3RvciwgYi5zZWxlY3Rvcik7XG59KTtcbnZhciBsb29rdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxUb0ZuID0ge307XG4gIHZhciBzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgcyA9IHN0YXRlU2VsZWN0b3JzW2ldO1xuICAgIHNlbFRvRm5bcy5zZWxlY3Rvcl0gPSBzLm1hdGNoZXM7XG4gIH1cbiAgcmV0dXJuIHNlbFRvRm47XG59KCk7XG52YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzZWwsIGVsZSkge1xuICByZXR1cm4gbG9va3VwW3NlbF0oZWxlKTtcbn07XG52YXIgc3RhdGVTZWxlY3RvclJlZ2V4ID0gJygnICsgc3RhdGVTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnNlbGVjdG9yO1xufSkuam9pbignfCcpICsgJyknO1xuXG4vLyB3aGVuIGEgdG9rZW4gbGlrZSBhIHZhcmlhYmxlIGhhcyBlc2NhcGVkIG1ldGEgY2hhcmFjdGVycywgd2UgbmVlZCB0byBjbGVhbiB0aGUgYmFja3NsYXNoZXMgb3V0XG4vLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcbnZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uIGNsZWFuTWV0YUNoYXJzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnKSwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICAgIHJldHVybiAkMTtcbiAgfSk7XG59O1xudmFyIHJlcGxhY2VMYXN0UXVlcnkgPSBmdW5jdGlvbiByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBleGFtaW5pbmdRdWVyeSwgcmVwbGFjZW1lbnRRdWVyeSkge1xuICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9IHJlcGxhY2VtZW50UXVlcnk7XG59O1xuXG4vLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4vLyAtIGEgcXVlcnkgY29udGFpbnMgYWxsIGFkamFjZW50IChpLmUuIG5vIHNlcGFyYXRvciBpbiBiZXR3ZWVuKSBleHByZXNzaW9ucztcbi8vIC0gdGhlIGN1cnJlbnQgcXVlcnkgaXMgc3RvcmVkIGluIHNlbGVjdG9yW2ldXG4vLyAtIHlvdSBuZWVkIHRvIGNoZWNrIHRoZSBxdWVyeSBvYmplY3RzIGluIG1hdGNoKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxudmFyIGV4cHJzID0gW3tcbiAgbmFtZTogJ2dyb3VwJyxcbiAgLy8ganVzdCB1c2VkIGZvciBpZGVudGlmeWluZyB3aGVuIGRlYnVnZ2luZ1xuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICcoJyArIHRva2Vucy5ncm91cCArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZikge1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDEpLFxuICAgICAgZ3JvdXAgPSBfcmVmMlswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkdST1VQLFxuICAgICAgdmFsdWU6IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N0YXRlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYzKSB7XG4gICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgc3RhdGUgPSBfcmVmNFswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLlNUQVRFLFxuICAgICAgdmFsdWU6IHN0YXRlXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2lkJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXCMoJyArIHRva2Vucy5pZCArICcpJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjUpIHtcbiAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMSksXG4gICAgICBpZCA9IF9yZWY2WzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuSUQsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoaWQpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2NsYXNzTmFtZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwuKCcgKyB0b2tlbnMuY2xhc3NOYW1lICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmNykge1xuICAgIHZhciBfcmVmOCA9IF9zbGljZWRUb0FycmF5KF9yZWY3LCAxKSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWY4WzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuQ0xBU1MsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICB2YXJpYWJsZSA9IF9yZWYxMFswXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfRVhJU1QsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFDb21wYXJlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTEpIHtcbiAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAzKSxcbiAgICAgIHZhcmlhYmxlID0gX3JlZjEyWzBdLFxuICAgICAgY29tcGFyYXRvck9wID0gX3JlZjEyWzFdLFxuICAgICAgdmFsdWUgPSBfcmVmMTJbMl07XG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG4gICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH1cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFCb29sJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy5ib29sT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxMykge1xuICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDIpLFxuICAgICAgYm9vbE9wID0gX3JlZjE0WzBdLFxuICAgICAgdmFyaWFibGUgPSBfcmVmMTRbMV07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0JPT0wsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdtZXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJyArIHRva2Vucy5tZXRhICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLm51bWJlciArICcpXFxcXHMqXFxcXF1cXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxNSkge1xuICAgIHZhciBfcmVmMTYgPSBfc2xpY2VkVG9BcnJheShfcmVmMTUsIDMpLFxuICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxNlsxXSxcbiAgICAgIG51bWJlciA9IF9yZWYxNlsyXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLk1FVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ25leHRRdWVyeScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcbiAgICB2YXIgZWRnZUNvdW50ID0gc2VsZWN0b3IuZWRnZUNvdW50O1xuICAgIHZhciBjb21wb3VuZENvdW50ID0gc2VsZWN0b3IuY29tcG91bmRDb3VudDtcbiAgICB2YXIgbGFzdFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudFN1YmplY3QgIT0gbnVsbCkge1xuICAgICAgbGFzdFEuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgIH1cbiAgICBsYXN0US5lZGdlQ291bnQgPSBlZGdlQ291bnQ7XG4gICAgbGFzdFEuY29tcG91bmRDb3VudCA9IGNvbXBvdW5kQ291bnQ7XG4gICAgc2VsZWN0b3IuZWRnZUNvdW50ID0gMDtcbiAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50ID0gMDtcblxuICAgIC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcbiAgICB2YXIgbmV4dFF1ZXJ5ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoKytdID0gbmV3UXVlcnkoKTtcbiAgICByZXR1cm4gbmV4dFF1ZXJ5OyAvLyB0aGlzIGlzIHRoZSBuZXcgcXVlcnkgdG8gYmUgZmlsbGVkIGJ5IHRoZSBmb2xsb3dpbmcgZXhwcnNcbiAgfVxufSwge1xuICBuYW1lOiAnZGlyZWN0ZWRFZGdlJyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLmRpcmVjdGVkRWRnZSxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2VcbiAgICAgIHZhciBlZGdlUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHNvdXJjZSA9IHF1ZXJ5O1xuICAgICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICBlZGdlUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRJUkVDVEVEX0VER0UsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBlZGdlIHJhdGhlciB0aGFuIHRoZSBzb3VyY2VcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc291cmNlL3RhcmdldFxuICAgICAgdmFyIHNyY1RndFEgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9zb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciBfdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHNyY1RndFEuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLk5PREVfU09VUkNFLFxuICAgICAgICBzb3VyY2U6IF9zb3VyY2UsXG4gICAgICAgIHRhcmdldDogX3RhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBuZWlnaGJvdXJob29kIHJhdGhlciB0aGFuIHRoZSBub2RlXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgc3JjVGd0USk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcbiAgICAgIHJldHVybiBfdGFyZ2V0OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHdpdGggdGhlIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5VTkRJUkVDVEVEX0VER0UsXG4gICAgICAgIG5vZGVzOiBbc291cmNlLCB0YXJnZXRdXG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGVkZ2VRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcblxuICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZWlnaGJvdXJob29kXG4gICAgICB2YXIgbmhvb2RRID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBub2RlID0gcXVlcnk7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZXdRdWVyeSgpO1xuICAgICAgbmhvb2RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX05FSUdIQk9SLFxuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBuZWlnaGJvcjogbmVpZ2hib3JcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIG5ob29kUSk7XG4gICAgICByZXR1cm4gbmVpZ2hib3I7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSBuZWlnaGJvciB3aXRoIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnY2hpbGQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gZGVmYXVsdDogY2hpbGQgcXVlcnlcbiAgICAgIHZhciBwYXJlbnRDaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBjaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRDaGlsZFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DSElMRCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgcGFyZW50Q2hpbGRRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PT0gcXVlcnkpIHtcbiAgICAgIC8vIGNvbXBvdW5kIHNwbGl0IHF1ZXJ5XG4gICAgICB2YXIgY29tcG91bmQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGxlZnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByaWdodCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc3ViamVjdCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX2NoaWxkID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfcGFyZW50ID0gbmV3UXVlcnkoKTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSByb290IGNvbXBvdW5kIHFcbiAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICB9KTtcblxuICAgICAgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG4gICAgICBzdWJqZWN0LmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGFrZSB0aGUgY2hlY2tzIGZyb20gdGhlIGxlZnRcbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuXG4gICAgICAvLyBzZXQgdXAgdGhlIHJpZ2h0IHFcbiAgICAgIF9wYXJlbnQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH0pOyAvLyBwYXJlbnQgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG4gICAgICByaWdodC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuUEFSRU5ULFxuICAgICAgICAvLyB0eXBlIGlzIHN3YXBwZWQgb24gcmlnaHQgc2lkZSBxdWVyaWVzXG4gICAgICAgIHBhcmVudDogX3BhcmVudCxcbiAgICAgICAgY2hpbGQ6IF9jaGlsZCAvLyBlbXB0eSBmb3Igbm93XG4gICAgICB9KTtcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGxlZnQsIGNvbXBvdW5kKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSByZWYgc2luY2Ugd2UgbW92ZWQgdGhpbmdzIGFyb3VuZCBmb3IgYHF1ZXJ5YFxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9jaGlsZDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBjaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9wYXJlbnQyID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfY2hpbGQyID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBwY1FDaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlBBUkVOVCxcbiAgICAgICAgcGFyZW50OiBfcGFyZW50MixcbiAgICAgICAgY2hpbGQ6IF9jaGlsZDJcbiAgICAgIH1dO1xuXG4gICAgICAvLyB0aGUgcGFyZW50LWNoaWxkIHF1ZXJ5IHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgcXVlcnkgcHJldmlvdXNseSBiZWluZyBwb3B1bGF0ZWRcbiAgICAgIF9wYXJlbnQyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IHBjUUNoZWNrczsgLy8gcGMgcXVlcnkgdGFrZXMgb3ZlclxuXG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2NoaWxkMjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdkZXNjZW5kYW50JyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gZGVmYXVsdDogZGVzY2VuZGFudCBxdWVyeVxuICAgICAgdmFyIGFuY0NoUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGRlc2NlbmRhbnQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGFuY2VzdG9yID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICBhbmNDaFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5ERVNDRU5EQU5ULFxuICAgICAgICBhbmNlc3RvcjogYW5jZXN0b3IsXG4gICAgICAgIGRlc2NlbmRhbnQ6IGRlc2NlbmRhbnRcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgJz4nIGl0c2VsZlxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGFuY0NoUXVlcnkpO1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuXG4gICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX2FuY2VzdG9yID0gbmV3UXVlcnkoKTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSByb290IGNvbXBvdW5kIHFcbiAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICB9KTtcblxuICAgICAgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG4gICAgICBzdWJqZWN0LmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGFrZSB0aGUgY2hlY2tzIGZyb20gdGhlIGxlZnRcbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuXG4gICAgICAvLyBzZXQgdXAgdGhlIHJpZ2h0IHFcbiAgICAgIF9hbmNlc3Rvci5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfSk7IC8vIGFuY2VzdG9yIGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuICAgICAgcmlnaHQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICAvLyB0eXBlIGlzIHN3YXBwZWQgb24gcmlnaHQgc2lkZSBxdWVyaWVzXG4gICAgICAgIGFuY2VzdG9yOiBfYW5jZXN0b3IsXG4gICAgICAgIGRlc2NlbmRhbnQ6IF9kZXNjZW5kYW50IC8vIGVtcHR5IGZvciBub3dcbiAgICAgIH0pO1xuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2Rlc2NlbmRhbnQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSByaWdodCBzaWRlJ3MgZGVzY2VuZGFudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbmNlc3RvciBxdWVyeVxuICAgICAgLy8gaW5mbyBmb3IgcGFyZW50IHF1ZXJ5XG4gICAgICB2YXIgX2FuY2VzdG9yMiA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX2Rlc2NlbmRhbnQyID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBhZFFDaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yMixcbiAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQyXG4gICAgICB9XTtcblxuICAgICAgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG4gICAgICBfYW5jZXN0b3IyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IGFkUUNoZWNrczsgLy8gcGMgcXVlcnkgdGFrZXMgb3ZlclxuXG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2Rlc2NlbmRhbnQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N1YmplY3QnLFxuICBtb2RpZmllcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zdWJqZWN0LFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgIT09IHF1ZXJ5KSB7XG4gICAgICB3YXJuKCdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yLnRvU3RyaW5nKCkgKyAnYCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHF1ZXJ5O1xuICAgIHZhciB0b3BRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRvcENoayA9IHRvcFEuY2hlY2tzWzBdO1xuICAgIHZhciB0b3BUeXBlID0gdG9wQ2hrID09IG51bGwgPyBudWxsIDogdG9wQ2hrLnR5cGU7XG4gICAgaWYgKHRvcFR5cGUgPT09IFR5cGUuRElSRUNURURfRURHRSkge1xuICAgICAgLy8gZGlyZWN0ZWQgZWRnZSB3aXRoIHN1YmplY3Qgb24gdGhlIHRhcmdldFxuXG4gICAgICAvLyBjaGFuZ2UgdG8gdGFyZ2V0IG5vZGUgY2hlY2tcbiAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX1RBUkdFVDtcbiAgICB9IGVsc2UgaWYgKHRvcFR5cGUgPT09IFR5cGUuVU5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSBzZWNvbmQgbm9kZVxuXG4gICAgICAvLyBjaGFuZ2UgdG8gbmVpZ2hib3IgY2hlY2tcbiAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX05FSUdIQk9SO1xuICAgICAgdG9wQ2hrLm5vZGUgPSB0b3BDaGsubm9kZXNbMV07IC8vIHNlY29uZCBub2RlIGlzIHN1YmplY3RcbiAgICAgIHRvcENoay5uZWlnaGJvciA9IHRvcENoay5ub2Rlc1swXTtcblxuICAgICAgLy8gY2xlYW4gdXAgdW51c2VkIGZpZWxkcyBmb3IgbmV3IHR5cGVcbiAgICAgIHRvcENoay5ub2RlcyA9IG51bGw7XG4gICAgfVxuICB9XG59XTtcbmV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGUucmVnZXhPYmogPSBuZXcgUmVnRXhwKCdeJyArIGUucmVnZXgpO1xufSk7XG5cbi8qKlxuICogT2YgYWxsIHRoZSBleHByZXNzaW9ucywgZmluZCB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIHJlbWFpbmluZyB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbWFpbmluZyBUaGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAqIEByZXR1cm5zIFRoZSBtYXRjaGVkIGV4cHJlc3Npb24gYW5kIHRoZSBuZXdseSByZW1haW5pbmcgdGV4dCBgeyBleHByLCBtYXRjaCwgbmFtZSwgcmVtYWluaW5nIH1gXG4gKi9cbnZhciBjb25zdW1lRXhwciA9IGZ1bmN0aW9uIGNvbnN1bWVFeHByKHJlbWFpbmluZykge1xuICB2YXIgZXhwcjtcbiAgdmFyIG1hdGNoO1xuICB2YXIgbmFtZTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgdmFyIG4gPSBlLm5hbWU7XG4gICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goZS5yZWdleE9iaik7XG4gICAgaWYgKG0gIT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBtO1xuICAgICAgZXhwciA9IGU7XG4gICAgICBuYW1lID0gbjtcbiAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG4gICAgICBicmVhazsgLy8gd2UndmUgY29uc3VtZWQgb25lIGV4cHIsIHNvIHdlIGNhbiByZXR1cm4gbm93XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcjogZXhwcixcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1haW5pbmc6IHJlbWFpbmluZ1xuICB9O1xufTtcblxuLyoqXG4gKiBDb25zdW1lIGFsbCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSB0ZXh0IHRvIGNvbnN1bWVcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IHdpdGggdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkXG4gKi9cbnZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZykge1xuICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBjb25zdW1lZCA9IG1hdGNoWzBdO1xuICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gcmVtYWluaW5nO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIGFuZCBzdG9yZSB0aGUgcGFyc2VkIHJlcHJlc2VudGF0aW9uIGluIHRoZSBTZWxlY3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNlbGVjdG9yIHdhcyBzdWNjZXNzZnVsbHkgcGFyc2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICovXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzZWxlY3Rvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSBzZWxmLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICB2YXIgY3VycmVudFF1ZXJ5ID0gc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gIHNlbGYubGVuZ3RoID0gMTtcbiAgcmVtYWluaW5nID0gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcblxuICBmb3IgKDs7KSB7XG4gICAgdmFyIGV4cHJJbmZvID0gY29uc3VtZUV4cHIocmVtYWluaW5nKTtcbiAgICBpZiAoZXhwckluZm8uZXhwciA9PSBudWxsKSB7XG4gICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgaXMgaW52YWxpZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IGV4cHJJbmZvLm1hdGNoLnNsaWNlKDEpO1xuXG4gICAgICAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgaW4gY3VycmVudFF1ZXJ5XG4gICAgICB2YXIgcmV0ID0gZXhwckluZm8uZXhwci5wb3B1bGF0ZShzZWxmLCBjdXJyZW50UXVlcnksIGFyZ3MpO1xuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRRdWVyeSA9IHJldDsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHF1ZXJ5IHRvIGJlIGZpbGxlZCBpZiB0aGUgZXhwciBzcGVjaWZpZXNcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtYWluaW5nID0gZXhwckluZm8ucmVtYWluaW5nO1xuXG4gICAgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG4gICAgaWYgKHJlbWFpbmluZy5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgbGFzdFEgPSBzZWxmW3NlbGYubGVuZ3RoIC0gMV07XG4gIGlmIChzZWxmLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwpIHtcbiAgICBsYXN0US5zdWJqZWN0ID0gc2VsZi5jdXJyZW50U3ViamVjdDtcbiAgfVxuICBsYXN0US5lZGdlQ291bnQgPSBzZWxmLmVkZ2VDb3VudDtcbiAgbGFzdFEuY29tcG91bmRDb3VudCA9IHNlbGYuY29tcG91bmRDb3VudDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHEgPSBzZWxmW2ldO1xuXG4gICAgLy8gaW4gZnV0dXJlLCB0aGlzIGNvdWxkIHBvdGVudGlhbGx5IGJlIGFsbG93ZWQgaWYgdGhlcmUgd2VyZSBvcGVyYXRvciBwcmVjZWRlbmNlIGFuZCBkZXRlY3Rpb24gb2YgaW52YWxpZCBjb21iaW5hdGlvbnNcbiAgICBpZiAocS5jb21wb3VuZENvdW50ID4gMCAmJiBxLmVkZ2VDb3VudCA+IDApIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgYm90aCBhIGNvbXBvdW5kIHNlbGVjdG9yIGFuZCBhbiBlZGdlIHNlbGVjdG9yJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChxLmVkZ2VDb3VudCA+IDEpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgbXVsdGlwbGUgZWRnZSBzZWxlY3RvcnMnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHEuZWRnZUNvdW50ID09PSAxKSB7XG4gICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGRlcHJlY2F0ZWQuICBFZGdlIHNlbGVjdG9ycyBkbyBub3QgdGFrZSBlZmZlY3Qgb24gY2hhbmdlcyB0byBzb3VyY2UgYW5kIHRhcmdldCBub2RlcyBhZnRlciBhbiBlZGdlIGlzIGFkZGVkLCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIFVzZSBhIGNsYXNzIG9yIGRhdGEgc2VsZWN0b3Igb24gZWRnZXMgaW5zdGVhZCwgdXBkYXRpbmcgdGhlIGNsYXNzIG9yIGRhdGEgb2YgYW4gZWRnZSB3aGVuIHlvdXIgYXBwIGRldGVjdHMgYSBjaGFuZ2UgaW4gc291cmNlIG9yIHRhcmdldCBub2Rlcy4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7IC8vIHN1Y2Nlc3Ncbn07XG5cbi8qKlxuICogR2V0IHRoZSBzZWxlY3RvciByZXByZXNlbnRlZCBhcyBhIHN0cmluZy4gIFRoaXMgdmFsdWUgdXNlcyBkZWZhdWx0IGZvcm1hdHRpbmcsXG4gKiBzbyB0aGluZ3MgbGlrZSBzcGFjaW5nIG1heSBkaWZmZXIgZnJvbSB0aGUgaW5wdXQgdGV4dCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHNlbGVjdG9yIHN0cmluZ1xuICovXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMudG9TdHJpbmdDYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmdDYWNoZTtcbiAgfVxuICB2YXIgY2xlYW4gPSBmdW5jdGlvbiBjbGVhbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH07XG4gIHZhciBjbGVhblZhbCA9IGZ1bmN0aW9uIGNsZWFuVmFsKHZhbCkge1xuICAgIGlmIChzdHJpbmcodmFsKSkge1xuICAgICAgcmV0dXJuICdcIicgKyB2YWwgKyAnXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2xlYW4odmFsKTtcbiAgICB9XG4gIH07XG4gIHZhciBzcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKHZhbCkge1xuICAgIHJldHVybiAnICcgKyB2YWwgKyAnICc7XG4gIH07XG4gIHZhciBjaGVja1RvU3RyaW5nID0gZnVuY3Rpb24gY2hlY2tUb1N0cmluZyhjaGVjaywgc3ViamVjdCkge1xuICAgIHZhciB0eXBlID0gY2hlY2sudHlwZSxcbiAgICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFR5cGUuR1JPVVA6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBjbGVhbih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwLnN1YnN0cmluZygwLCBncm91cC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkRBVEFfQ09NUEFSRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcjtcbiAgICAgICAgICByZXR1cm4gJ1snICsgZmllbGQgKyBzcGFjZShjbGVhbihvcGVyYXRvcikpICsgY2xlYW5WYWwodmFsdWUpICsgJ10nO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuREFUQV9CT09MOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgX2ZpZWxkID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgcmV0dXJuICdbJyArIGNsZWFuKF9vcGVyYXRvcikgKyBfZmllbGQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0VYSVNUOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9maWVsZDIgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgX2ZpZWxkMiArICddJztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLk1FVEFfQ09NUEFSRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3BlcmF0b3IyID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICBfZmllbGQzID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgcmV0dXJuICdbWycgKyBfZmllbGQzICsgc3BhY2UoY2xlYW4oX29wZXJhdG9yMikpICsgY2xlYW5WYWwodmFsdWUpICsgJ11dJztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLlNUQVRFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuSUQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJyMnICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5DTEFTUzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnLicgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLlBBUkVOVDpcbiAgICAgIGNhc2UgVHlwZS5DSElMRDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBxdWVyeVRvU3RyaW5nKGNoZWNrLnBhcmVudCwgc3ViamVjdCkgKyBzcGFjZSgnPicpICsgcXVlcnlUb1N0cmluZyhjaGVjay5jaGlsZCwgc3ViamVjdCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5BTkNFU1RPUjpcbiAgICAgIGNhc2UgVHlwZS5ERVNDRU5EQU5UOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2suYW5jZXN0b3IsIHN1YmplY3QpICsgJyAnICsgcXVlcnlUb1N0cmluZyhjaGVjay5kZXNjZW5kYW50LCBzdWJqZWN0KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkNPTVBPVU5EX1NQTElUOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxocyA9IHF1ZXJ5VG9TdHJpbmcoY2hlY2subGVmdCwgc3ViamVjdCk7XG4gICAgICAgICAgdmFyIHN1YiA9IHF1ZXJ5VG9TdHJpbmcoY2hlY2suc3ViamVjdCwgc3ViamVjdCk7XG4gICAgICAgICAgdmFyIHJocyA9IHF1ZXJ5VG9TdHJpbmcoY2hlY2sucmlnaHQsIHN1YmplY3QpO1xuICAgICAgICAgIHJldHVybiBsaHMgKyAobGhzLmxlbmd0aCA+IDAgPyAnICcgOiAnJykgKyBzdWIgKyByaHM7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5UUlVFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uIHF1ZXJ5VG9TdHJpbmcocXVlcnksIHN1YmplY3QpIHtcbiAgICByZXR1cm4gcXVlcnkuY2hlY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBjaGssIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAoc3ViamVjdCA9PT0gcXVlcnkgJiYgaSA9PT0gMCA/ICckJyA6ICcnKSArIGNoZWNrVG9TdHJpbmcoY2hrLCBzdWJqZWN0KTtcbiAgICB9LCAnJyk7XG4gIH07XG4gIHZhciBzdHIgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcbiAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyhxdWVyeSwgcXVlcnkuc3ViamVjdCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICBzdHIgKz0gJywgJztcbiAgICB9XG4gIH1cbiAgdGhpcy50b1N0cmluZ0NhY2hlID0gc3RyO1xuICByZXR1cm4gc3RyO1xufTtcbnZhciBwYXJzZSQxID0ge1xuICBwYXJzZTogcGFyc2UsXG4gIHRvU3RyaW5nOiB0b1N0cmluZ1xufTtcblxudmFyIHZhbENtcCA9IGZ1bmN0aW9uIHZhbENtcChmaWVsZFZhbCwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gIHZhciBtYXRjaGVzO1xuICB2YXIgaXNGaWVsZFN0ciA9IHN0cmluZyhmaWVsZFZhbCk7XG4gIHZhciBpc0ZpZWxkTnVtID0gbnVtYmVyJDEoZmllbGRWYWwpO1xuICB2YXIgaXNWYWxTdHIgPSBzdHJpbmcodmFsdWUpO1xuICB2YXIgZmllbGRTdHIsIHZhbFN0cjtcbiAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICB2YXIgaXNJbmVxQ21wID0gZmFsc2U7XG4gIGlmIChvcGVyYXRvci5pbmRleE9mKCchJykgPj0gMCkge1xuICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnIScsICcnKTtcbiAgICBub3RFeHByID0gdHJ1ZTtcbiAgfVxuICBpZiAob3BlcmF0b3IuaW5kZXhPZignQCcpID49IDApIHtcbiAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJ0AnLCAnJyk7XG4gICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNGaWVsZFN0ciB8fCBpc1ZhbFN0ciB8fCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBmaWVsZFN0ciA9ICFpc0ZpZWxkU3RyICYmICFpc0ZpZWxkTnVtID8gJycgOiAnJyArIGZpZWxkVmFsO1xuICAgIHZhbFN0ciA9ICcnICsgdmFsdWU7XG4gIH1cblxuICAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gIC8vIGV2ZW4gaWYgd2UncmUgY29tcGFyaW5nIG51bWJlcnNcbiAgaWYgKGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGZpZWxkVmFsID0gZmllbGRTdHIgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbHVlID0gdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJyo9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPj0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyQ9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0ciwgZmllbGRTdHIubGVuZ3RoIC0gdmFsU3RyLmxlbmd0aCkgPj0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ149JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPT09IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA9PT0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc+JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz49JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzw9JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPD0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBhcHBseSB0aGUgbm90IG9wLCBidXQgbnVsbCB2YWxzIGZvciBpbmVxdWFsaXRpZXMgc2hvdWxkIGFsd2F5cyBzdGF5IG5vbi1tYXRjaGluZ1xuICBpZiAobm90RXhwciAmJiAoZmllbGRWYWwgIT0gbnVsbCB8fCAhaXNJbmVxQ21wKSkge1xuICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn07XG52YXIgYm9vbENtcCA9IGZ1bmN0aW9uIGJvb2xDbXAoZmllbGRWYWwsIG9wZXJhdG9yKSB7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICc/JzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA/IHRydWUgOiBmYWxzZTtcbiAgICBjYXNlICchJzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA/IGZhbHNlIDogdHJ1ZTtcbiAgICBjYXNlICdeJzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA9PT0gdW5kZWZpbmVkO1xuICB9XG59O1xudmFyIGV4aXN0Q21wID0gZnVuY3Rpb24gZXhpc3RDbXAoZmllbGRWYWwpIHtcbiAgcmV0dXJuIGZpZWxkVmFsICE9PSB1bmRlZmluZWQ7XG59O1xudmFyIGRhdGEkMSA9IGZ1bmN0aW9uIGRhdGEoZWxlLCBmaWVsZCkge1xuICByZXR1cm4gZWxlLmRhdGEoZmllbGQpO1xufTtcbnZhciBtZXRhID0gZnVuY3Rpb24gbWV0YShlbGUsIGZpZWxkKSB7XG4gIHJldHVybiBlbGVbZmllbGRdKCk7XG59O1xuXG4vKiogQSBsb29rdXAgb2YgYG1hdGNoKGNoZWNrLCBlbGUpYCBmdW5jdGlvbnMgYnkgYFR5cGVgIGludCAqL1xudmFyIG1hdGNoID0gW107XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGZvciB0aGUgZWxlbWVudFxuICogQHBhcmFtIHF1ZXJ5IFRoZSBgeyB0eXBlLCB2YWx1ZSwgLi4uIH1gIHF1ZXJ5IG9iamVjdFxuICogQHBhcmFtIGVsZSBUaGUgZWxlbWVudCB0byBjb21wYXJlIGFnYWluc3RcbiovXG52YXIgbWF0Y2hlcyQxID0gZnVuY3Rpb24gbWF0Y2hlcyhxdWVyeSwgZWxlKSB7XG4gIHJldHVybiBxdWVyeS5jaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoaykge1xuICAgIHJldHVybiBtYXRjaFtjaGsudHlwZV0oY2hrLCBlbGUpO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkdST1VQXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBncm91cCA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZ3JvdXAgPT09ICcqJyB8fCBncm91cCA9PT0gZWxlLmdyb3VwKCk7XG59O1xubWF0Y2hbVHlwZS5TVEFURV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgc3RhdGVTZWxlY3RvciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc3RhdGVTZWxlY3RvciwgZWxlKTtcbn07XG5tYXRjaFtUeXBlLklEXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBpZCA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZWxlLmlkKCkgPT09IGlkO1xufTtcbm1hdGNoW1R5cGUuQ0xBU1NdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGNscyA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZWxlLmhhc0NsYXNzKGNscyk7XG59O1xubWF0Y2hbVHlwZS5NRVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcixcbiAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gdmFsQ21wKG1ldGEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG59O1xubWF0Y2hbVHlwZS5EQVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcixcbiAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gdmFsQ21wKGRhdGEkMShlbGUsIGZpZWxkKSwgb3BlcmF0b3IsIHZhbHVlKTtcbn07XG5tYXRjaFtUeXBlLkRBVEFfQk9PTF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICByZXR1cm4gYm9vbENtcChkYXRhJDEoZWxlLCBmaWVsZCksIG9wZXJhdG9yKTtcbn07XG5tYXRjaFtUeXBlLkRBVEFfRVhJU1RdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQ7XG4gICAgY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBleGlzdENtcChkYXRhJDEoZWxlLCBmaWVsZCkpO1xufTtcbm1hdGNoW1R5cGUuVU5ESVJFQ1RFRF9FREdFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBxQSA9IGNoZWNrLm5vZGVzWzBdO1xuICB2YXIgcUIgPSBjaGVjay5ub2Rlc1sxXTtcbiAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKTtcbiAgdmFyIHRndCA9IGVsZS50YXJnZXQoKTtcbiAgcmV0dXJuIG1hdGNoZXMkMShxQSwgc3JjKSAmJiBtYXRjaGVzJDEocUIsIHRndCkgfHwgbWF0Y2hlcyQxKHFCLCBzcmMpICYmIG1hdGNoZXMkMShxQSwgdGd0KTtcbn07XG5tYXRjaFtUeXBlLk5PREVfTkVJR0hCT1JdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5ub2RlLCBlbGUpICYmIGVsZS5uZWlnaGJvcmhvb2QoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLm5laWdoYm9yLCBuKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5ESVJFQ1RFRF9FREdFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUuc291cmNlKCkpICYmIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIGVsZS50YXJnZXQoKSk7XG59O1xubWF0Y2hbVHlwZS5OT0RFX1NPVVJDRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgZWxlKSAmJiBlbGUub3V0Z29lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgbik7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuTk9ERV9UQVJHRVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIGVsZSkgJiYgZWxlLmluY29tZXJzKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIG4pO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkNISUxEXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suY2hpbGQsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnBhcmVudCwgZWxlLnBhcmVudCgpKTtcbn07XG5tYXRjaFtUeXBlLlBBUkVOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnBhcmVudCwgZWxlKSAmJiBlbGUuY2hpbGRyZW4oKS5zb21lKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5jaGlsZCwgYyk7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuREVTQ0VOREFOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmRlc2NlbmRhbnQsIGVsZSkgJiYgZWxlLmFuY2VzdG9ycygpLnNvbWUoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmFuY2VzdG9yLCBhKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5BTkNFU1RPUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmFuY2VzdG9yLCBlbGUpICYmIGVsZS5kZXNjZW5kYW50cygpLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmRlc2NlbmRhbnQsIGQpO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkNPTVBPVU5EX1NQTElUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc3ViamVjdCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2subGVmdCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2sucmlnaHQsIGVsZSk7XG59O1xubWF0Y2hbVHlwZS5UUlVFXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xubWF0Y2hbVHlwZS5DT0xMRUNUSU9OXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBjb2xsZWN0aW9uLmhhcyhlbGUpO1xufTtcbm1hdGNoW1R5cGUuRklMVEVSXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWx0ZXIgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGZpbHRlcihlbGUpO1xufTtcblxuLy8gZmlsdGVyIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb25cbnZhciBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZm9yIDEgaWQgI2ZvbyBxdWVyaWVzLCBqdXN0IGdldCB0aGUgZWxlbWVudFxuICBpZiAoc2VsZi5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3MubGVuZ3RoID09PSAxICYmIHNlbGZbMF0uY2hlY2tzWzBdLnR5cGUgPT09IFR5cGUuSUQpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5nZXRFbGVtZW50QnlJZChzZWxmWzBdLmNoZWNrc1swXS52YWx1ZSkuY29sbGVjdGlvbigpO1xuICB9XG4gIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbihlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuICAgICAgaWYgKG1hdGNoZXMkMShxdWVyeSwgZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgaWYgKHNlbGYudGV4dCgpID09IG51bGwpIHtcbiAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKHNlbGVjdG9yRnVuY3Rpb24pO1xufTsgLy8gZmlsdGVyXG5cbi8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cbnZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuICAgIGlmIChtYXRjaGVzJDEocXVlcnksIGVsZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59OyAvLyBtYXRjaGVzXG5cbnZhciBtYXRjaGluZyA9IHtcbiAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgZmlsdGVyOiBmaWx0ZXJcbn07XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHRoaXMuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gIHRoaXMuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICB0aGlzLmNvbXBvdW5kQ291bnQgPSAwO1xuICB0aGlzLmVkZ2VDb3VudCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgaWYgKHNlbGVjdG9yID09IG51bGwgfHwgc3RyaW5nKHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5tYXRjaCgvXlxccyokLykpIDsgZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihzZWxlY3RvcikpIHtcbiAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgIGNoZWNrczogW3tcbiAgICAgICAgdHlwZTogVHlwZS5DT0xMRUNUSU9OLFxuICAgICAgICB2YWx1ZTogc2VsZWN0b3IuY29sbGVjdGlvbigpXG4gICAgICB9XVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGZuJDYoc2VsZWN0b3IpKSB7XG4gICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICBjaGVja3M6IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuRklMVEVSLFxuICAgICAgICB2YWx1ZTogc2VsZWN0b3JcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHNlbGVjdG9yKSkge1xuICAgIGlmICghdGhpcy5wYXJzZShzZWxlY3RvcikpIHtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVycm9yKCdBIHNlbGVjdG9yIG11c3QgYmUgY3JlYXRlZCBmcm9tIGEgc3RyaW5nOyBmb3VuZCAnKTtcbiAgfVxufTtcbnZhciBzZWxmbiA9IFNlbGVjdG9yLnByb3RvdHlwZTtcbltwYXJzZSQxLCBtYXRjaGluZ10uZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gZXh0ZW5kKHNlbGZuLCBwKTtcbn0pO1xuc2VsZm4udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaW5wdXRUZXh0O1xufTtcbnNlbGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5zZWxmbi5lcSA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiB0aGlzW2ldO1xufTtcbnNlbGZuLnNhbWVUZXh0ID0gZnVuY3Rpb24gKG90aGVyU2VsKSB7XG4gIHJldHVybiAhdGhpcy5pbnZhbGlkICYmICFvdGhlclNlbC5pbnZhbGlkICYmIHRoaXMudGV4dCgpID09PSBvdGhlclNlbC50ZXh0KCk7XG59O1xuc2VsZm4uYWRkUXVlcnkgPSBmdW5jdGlvbiAocSkge1xuICB0aGlzW3RoaXMubGVuZ3RoKytdID0gcTtcbn07XG5zZWxmbi5zZWxlY3RvciA9IHNlbGZuLnRvU3RyaW5nO1xuXG52YXIgZWxlc2ZuJGcgPSB7XG4gIGFsbEFyZTogZnVuY3Rpb24gYWxsQXJlKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbE9iai5tYXRjaGVzKGVsZSk7XG4gICAgfSk7XG4gIH0sXG4gIGlzOiBmdW5jdGlvbiBpcyhzZWxlY3Rvcikge1xuICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbE9iai5tYXRjaGVzKGVsZSk7XG4gICAgfSk7XG4gIH0sXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoZm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG4gICAgICBpZiAoIXJldCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBzYW1lOiBmdW5jdGlvbiBzYW1lKGNvbGxlY3Rpb24pIHtcbiAgICAvLyBjaGVhcCBjb2xsZWN0aW9uIHJlZiBjaGVja1xuICAgIGlmICh0aGlzID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIGNvbGxlY3Rpb25MZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgIC8vIGNoZWFwIGxlbmd0aCBjaGVja1xuICAgIGlmICh0aGlzTGVuZ3RoICE9PSBjb2xsZWN0aW9uTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlYXAgZWxlbWVudCByZWYgY2hlY2tcbiAgICBpZiAodGhpc0xlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPT09IGNvbGxlY3Rpb25bMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbnlTYW1lOiBmdW5jdGlvbiBhbnlTYW1lKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiBhbGxBcmVOZWlnaGJvcnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgbmhvb2QgPSB0aGlzLm5laWdoYm9yaG9vZCgpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBuaG9vZC5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxmLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9XG59O1xuZWxlc2ZuJGcuYWxsQXJlTmVpZ2hib3VycyA9IGVsZXNmbiRnLmFsbEFyZU5laWdoYm9ycztcbmVsZXNmbiRnLmhhcyA9IGVsZXNmbiRnLmNvbnRhaW5zO1xuZWxlc2ZuJGcuZXF1YWwgPSBlbGVzZm4kZy5lcXVhbHMgPSBlbGVzZm4kZy5zYW1lO1xuXG52YXIgY2FjaGUgPSBmdW5jdGlvbiBjYWNoZShmbiwgbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2FsQ2FjaGUoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIHZhciBzZWxlY3Rvck9yRWxlcyA9IGFyZzE7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBrZXk7XG4gICAgaWYgKHNlbGVjdG9yT3JFbGVzID09IG51bGwpIHtcbiAgICAgIGtleSA9ICcnO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihzZWxlY3Rvck9yRWxlcykgJiYgc2VsZWN0b3JPckVsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBrZXkgPSBzZWxlY3Rvck9yRWxlcy5pZCgpO1xuICAgIH1cbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDEgJiYga2V5KSB7XG4gICAgICB2YXIgX3AgPSBlbGVzWzBdLl9wcml2YXRlO1xuICAgICAgdmFyIHRjaCA9IF9wLnRyYXZlcnNhbENhY2hlID0gX3AudHJhdmVyc2FsQ2FjaGUgfHwge307XG4gICAgICB2YXIgY2ggPSB0Y2hbbmFtZV0gPSB0Y2hbbmFtZV0gfHwgW107XG4gICAgICB2YXIgaGFzaCA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICAgIHZhciBjYWNoZUhpdCA9IGNoW2hhc2hdO1xuICAgICAgaWYgKGNhY2hlSGl0KSB7XG4gICAgICAgIHJldHVybiBjYWNoZUhpdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaFtoYXNoXSA9IGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBlbGVzZm4kZiA9IHtcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgZWxlIGNhbGxcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzWzBdLl9wcml2YXRlLnBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBfcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcbiAgICAgIGlmIChfcGFyZW50KSB7XG4gICAgICAgIHBhcmVudHMucHVzaChfcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgIHdoaWxlIChlbGVzLm5vbmVtcHR5KCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgcGFyZW50cy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY29tbW9uQW5jZXN0b3JzOiBmdW5jdGlvbiBjb21tb25BbmNlc3RvcnMoc2VsZWN0b3IpIHtcbiAgICB2YXIgYW5jZXN0b3JzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgcGFyZW50cyA9IGVsZS5wYXJlbnRzKCk7XG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMgfHwgcGFyZW50cztcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5pbnRlcnNlY3QocGFyZW50cyk7IC8vIGN1cnJlbnQgbGlzdCBtdXN0IGJlIGNvbW1vbiB3aXRoIGN1cnJlbnQgZWxlIHBhcmVudHMgc2V0XG4gICAgfVxuICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3JwaGFuczogZnVuY3Rpb24gb3JwaGFucyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzT3JwaGFuKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgbm9ub3JwaGFuczogZnVuY3Rpb24gbm9ub3JwaGFucyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjaGlsZHJlbjogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBlbGVDaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlQ2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChlbGVDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKGNoaWxkcmVuLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY2hpbGRyZW4nKSxcbiAgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uIGlzUGFyZW50KCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG4gIGlzQ2hpbGRsZXNzOiBmdW5jdGlvbiBpc0NoaWxkbGVzcygpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9LFxuICBpc0NoaWxkOiBmdW5jdGlvbiBpc0NoaWxkKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCAhPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgaXNPcnBoYW46IGZ1bmN0aW9uIGlzT3JwaGFuKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCA9PSBudWxsO1xuICAgIH1cbiAgfSxcbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgZnVuY3Rpb24gYWRkKGVsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICBpZiAoZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSkge1xuICAgICAgICAgIGFkZChlbGUuY2hpbGRyZW4oKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYWRkKHRoaXMuY2hpbGRyZW4oKSk7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH1cbn07XG5mdW5jdGlvbiBmb3JFYWNoQ29tcG91bmQoZWxlcywgZm4sIGluY2x1ZGVTZWxmLCByZWN1cnNpdmVTdGVwKSB7XG4gIHZhciBxID0gW107XG4gIHZhciBkaWQgPSBuZXcgU2V0JDEoKTtcbiAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgIHEucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgZWxlKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHEubGVuZ3RoID4gMCkge1xuICAgIHZhciBfZWxlID0gcS5zaGlmdCgpO1xuICAgIGZuKF9lbGUpO1xuICAgIGRpZC5hZGQoX2VsZS5pZCgpKTtcbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgX2VsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVzO1xufVxuZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKCFkaWQuaGFzKGNoaWxkLmlkKCkpKSB7XG4gICAgICAgIHEucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHZlcnkgZWZmaWNpZW50IHZlcnNpb24gb2YgZWxlcy5hZGQoIGVsZXMuZGVzY2VuZGFudHMoKSApLmZvckVhY2goKVxuLy8gZm9yIGludGVybmFsIHVzZVxuZWxlc2ZuJGYuZm9yRWFjaERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkQ2hpbGRyZW4pO1xufTtcbmZ1bmN0aW9uIGFkZFBhcmVudChxLCBkaWQsIGVsZSkge1xuICBpZiAoZWxlLmlzQ2hpbGQoKSkge1xuICAgIHZhciBwYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuICAgIGlmICghZGlkLmhhcyhwYXJlbnQuaWQoKSkpIHtcbiAgICAgIHEucHVzaChwYXJlbnQpO1xuICAgIH1cbiAgfVxufVxuZWxlc2ZuJGYuZm9yRWFjaFVwID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudCk7XG59O1xuZnVuY3Rpb24gYWRkUGFyZW50QW5kQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgYWRkUGFyZW50KHEsIGRpZCwgZWxlKTtcbiAgYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpO1xufVxuZWxlc2ZuJGYuZm9yRWFjaFVwQW5kRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnRBbmRDaGlsZHJlbik7XG59O1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4kZi5hbmNlc3RvcnMgPSBlbGVzZm4kZi5wYXJlbnRzO1xuXG52YXIgZm4kNSwgZWxlc2ZuJGU7XG5mbiQ1ID0gZWxlc2ZuJGUgPSB7XG4gIGRhdGE6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgZXZlbnQ6ICdkYXRhJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICBzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcnNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuICByZW1vdmVSc2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgIHRyaWdnZXJFdmVudDogZmFsc2VcbiAgfSksXG4gIGlkOiBmdW5jdGlvbiBpZCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhbGlhc2VzXG5mbiQ1LmF0dHIgPSBmbiQ1LmRhdGE7XG5mbiQ1LnJlbW92ZUF0dHIgPSBmbiQ1LnJlbW92ZURhdGE7XG52YXIgZGF0YSA9IGVsZXNmbiRlO1xuXG52YXIgZWxlc2ZuJGQgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLmlzTm9kZSgpICYmICFzZWxmLnJlbW92ZWQoKSkge1xuICAgICAgdmFyIGRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHNlbGZbMF07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuICAgICAgICBpZiAoIWluY2x1ZGVMb29wcyAmJiBlZGdlLmlzTG9vcCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVncmVlICs9IGNhbGxiYWNrKG5vZGUsIGVkZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cbmV4dGVuZChlbGVzZm4kZCwge1xuICBkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2Uuc291cmNlKCkuc2FtZShlZGdlLnRhcmdldCgpKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSksXG4gIGluZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgIGlmIChlZGdlLnRhcmdldCgpLnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pLFxuICBvdXRkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2Uuc291cmNlKCkuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSlcbn0pO1xuZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oZGVncmVlRm4sIGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oaW5jbHVkZUxvb3BzKTtcbiAgICAgIGlmIChkZWdyZWUgIT09IHVuZGVmaW5lZCAmJiAocmV0ID09PSB1bmRlZmluZWQgfHwgY2FsbGJhY2soZGVncmVlLCByZXQpKSkge1xuICAgICAgICByZXQgPSBkZWdyZWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5leHRlbmQoZWxlc2ZuJGQsIHtcbiAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcbiAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcbmV4dGVuZChlbGVzZm4kZCwge1xuICB0b3RhbERlZ3JlZTogZnVuY3Rpb24gdG90YWxEZWdyZWUoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWwgKz0gbm9kZXNbaV0uZGVncmVlKGluY2x1ZGVMb29wcyk7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSk7XG5cbnZhciBmbiQ0LCBlbGVzZm4kYztcbnZhciBiZWZvcmVQb3NpdGlvblNldCA9IGZ1bmN0aW9uIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1Bvcywgc2lsZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIGlmICghZWxlLmxvY2tlZCgpKSB7XG4gICAgICB2YXIgb2xkUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIGRlbHRhID0ge1xuICAgICAgICB4OiBuZXdQb3MueCAhPSBudWxsID8gbmV3UG9zLnggLSBvbGRQb3MueCA6IDAsXG4gICAgICAgIHk6IG5ld1Bvcy55ICE9IG51bGwgPyBuZXdQb3MueSAtIG9sZFBvcy55IDogMFxuICAgICAgfTtcbiAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSAmJiAhKGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkpIHtcbiAgICAgICAgZWxlLmNoaWxkcmVuKCkuc2hpZnQoZGVsdGEsIHNpbGVudCk7XG4gICAgICB9XG4gICAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIHBvc2l0aW9uRGVmID0ge1xuICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgdHJpZ2dlckZuTmFtZTogJ2VtaXRBbmROb3RpZnknLFxuICBhbGxvd0dldHRpbmc6IHRydWUsXG4gIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgYmVmb3JlR2V0OiBmdW5jdGlvbiBiZWZvcmVHZXQoZWxlKSB7XG4gICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gIH0sXG4gIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KGVsZXMsIG5ld1Bvcykge1xuICAgIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1BvcywgZmFsc2UpO1xuICB9LFxuICBvblNldDogZnVuY3Rpb24gb25TZXQoZWxlcykge1xuICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gIH0sXG4gIGNhblNldDogZnVuY3Rpb24gY2FuU2V0KGVsZSkge1xuICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICB9XG59O1xuZm4kNCA9IGVsZXNmbiRjID0ge1xuICBwb3NpdGlvbjogZGVmaW5lLmRhdGEocG9zaXRpb25EZWYpLFxuICAvLyBwb3NpdGlvbiBidXQgbm8gbm90aWZpY2F0aW9uIHRvIHJlbmRlcmVyXG4gIHNpbGVudFBvc2l0aW9uOiBkZWZpbmUuZGF0YShleHRlbmQoe30sIHBvc2l0aW9uRGVmLCB7XG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHRydWUpO1xuICAgIH0sXG4gICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgfVxuICB9KSksXG4gIHBvc2l0aW9uczogZnVuY3Rpb24gcG9zaXRpb25zKHBvcywgc2lsZW50KSB7XG4gICAgaWYgKHBsYWluT2JqZWN0KHBvcykpIHtcbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgdGhpcy5zaWxlbnRQb3NpdGlvbihwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihwb3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm4kNihwb3MpKSB7XG4gICAgICB2YXIgX2ZuID0gcG9zO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgX3BvcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKF9wb3MgPSBfZm4oZWxlLCBpKSkge1xuICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoZGltLCB2YWwsIHNpbGVudCkge1xuICAgIHZhciBkZWx0YTtcbiAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgZGVsdGEgPSB7XG4gICAgICAgIHg6IG51bWJlciQxKGRpbS54KSA/IGRpbS54IDogMCxcbiAgICAgICAgeTogbnVtYmVyJDEoZGltLnkpID8gZGltLnkgOiAwXG4gICAgICB9O1xuICAgICAgc2lsZW50ID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgZGVsdGEgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBkZWx0YVtkaW1dID0gdmFsO1xuICAgIH1cbiAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIC8vIGV4Y2x1ZGUgYW55IG5vZGUgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGNhbGxpbmcgY29sbGVjdGlvblxuICAgICAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGVsZS5pc0NoaWxkKCkgJiYgZWxlLmFuY2VzdG9ycygpLmFueVNhbWUodGhpcykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuZXdQb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggKyBkZWx0YS54LFxuICAgICAgICAgIHk6IHBvcy55ICsgZGVsdGEueVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzaWxlbnRTaGlmdDogZnVuY3Rpb24gc2lsZW50U2hpZnQoZGltLCB2YWwpIHtcbiAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHZhbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24gcmVuZGVyZWRQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHJwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZSA9IHRoaXNbaV07XG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihkaW0sICh2YWwgLSBwYW5bZGltXSkgLyB6b29tKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBfZWxlLnBvc2l0aW9uKHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHJwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxKHBvcywgem9vbSwgcGFuKTtcbiAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcnBvc1tkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gZ2V0L3NldCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiByZWxhdGl2ZVBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBwcG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICBpZiAoZWxlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9lbGUyID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IF9lbGUyLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuICAgICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBfZWxlMi5wb3NpdGlvbihkaW0sIHZhbCArIG9yaWdpbltkaW1dKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICBfZWxlMi5wb3NpdGlvbih7XG4gICAgICAgICAgICAgIHg6IHBwb3MueCArIG9yaWdpbi54LFxuICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgdmFyIF9oYXNQYXJlbnQgPSBfcGFyZW50ICYmIF9wYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgdmFyIF9yZWxhdGl2ZVRvUGFyZW50ID0gX2hhc1BhcmVudDtcbiAgICAgICAgaWYgKF9oYXNQYXJlbnQpIHtcbiAgICAgICAgICBfcGFyZW50ID0gX3BhcmVudFswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX29yaWdpbiA9IF9yZWxhdGl2ZVRvUGFyZW50ID8gX3BhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBwcG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54IC0gX29yaWdpbi54LFxuICAgICAgICAgIHk6IHBvcy55IC0gX29yaWdpbi55XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHBwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbmZuJDQubW9kZWxQb3NpdGlvbiA9IGZuJDQucG9pbnQgPSBmbiQ0LnBvc2l0aW9uO1xuZm4kNC5tb2RlbFBvc2l0aW9ucyA9IGZuJDQucG9pbnRzID0gZm4kNC5wb3NpdGlvbnM7XG5mbiQ0LnJlbmRlcmVkUG9pbnQgPSBmbiQ0LnJlbmRlcmVkUG9zaXRpb247XG5mbiQ0LnJlbGF0aXZlUG9pbnQgPSBmbiQ0LnJlbGF0aXZlUG9zaXRpb247XG52YXIgcG9zaXRpb24gPSBlbGVzZm4kYztcblxudmFyIGZuJDMsIGVsZXNmbiRiO1xuZm4kMyA9IGVsZXNmbiRiID0ge307XG5lbGVzZm4kYi5yZW5kZXJlZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveChvcHRpb25zKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gIHZhciB5MSA9IGJiLnkxICogem9vbSArIHBhbi55O1xuICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcbiAgcmV0dXJuIHtcbiAgICB4MTogeDEsXG4gICAgeDI6IHgyLFxuICAgIHkxOiB5MSxcbiAgICB5MjogeTIsXG4gICAgdzogeDIgLSB4MSxcbiAgICBoOiB5MiAtIHkxXG4gIH07XG59O1xuZWxlc2ZuJGIuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2lsZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLmZvckVhY2hVcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gZmFsc2U7XG4gICAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5lbGVzZm4kYi51cGRhdGVDb21wb3VuZEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gIC8vIG5vdCBwb3NzaWJsZSB0byBkbyBvbiBub24tY29tcG91bmQgZ3JhcGhzIG9yIHdpdGggdGhlIHN0eWxlIGRpc2FibGVkXG4gIGlmICghY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2F2ZSBjeWNsZXMgd2hlbiBiYXRjaGluZyAtLSBidXQgYm91bmRzIHdpbGwgYmUgc3RhbGUgKG9yIG5vdCBleGlzdCB5ZXQpXG4gIGlmICghZm9yY2UgJiYgY3kuYmF0Y2hpbmcoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudC5pc1BhcmVudCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfcCA9IHBhcmVudC5fcHJpdmF0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAgICB2YXIgaW5jbHVkZUxhYmVscyA9IHBhcmVudC5wc3R5bGUoJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJykudmFsdWUgPT09ICdpbmNsdWRlJztcbiAgICB2YXIgbWluID0ge1xuICAgICAgd2lkdGg6IHtcbiAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICBsZWZ0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1sZWZ0JyksXG4gICAgICAgIHJpZ2h0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1yaWdodCcpXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodCcpLnBmVmFsdWUsXG4gICAgICAgIHRvcDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLXRvcCcpLFxuICAgICAgICBib3R0b206IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nKVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goe1xuICAgICAgaW5jbHVkZUxhYmVsczogaW5jbHVkZUxhYmVscyxcbiAgICAgIGluY2x1ZGVPdmVybGF5czogZmFsc2UsXG4gICAgICAvLyB1cGRhdGluZyB0aGUgY29tcG91bmQgYm91bmRzIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgcmVndWxhclxuICAgICAgLy8gY2FjaGUgY3ljbGUgKGkuZS4gYmVmb3JlIGZpcmVkIGV2ZW50cylcbiAgICAgIHVzZUNhY2hlOiBmYWxzZVxuICAgIH0pO1xuICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcblxuICAgIC8vIGlmIGNoaWxkcmVuIHRha2UgdXAgemVybyBhcmVhIHRoZW4ga2VlcCBwb3NpdGlvbiBhbmQgZmFsbCBiYWNrIG9uIHN0eWxlc2hlZXQgdy9oXG4gICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgYmIgPSB7XG4gICAgICAgIHc6IHBhcmVudC5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgaDogcGFyZW50LnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZVxuICAgICAgfTtcbiAgICAgIGJiLngxID0gcG9zLnggLSBiYi53IC8gMjtcbiAgICAgIGJiLngyID0gcG9zLnggKyBiYi53IC8gMjtcbiAgICAgIGJiLnkxID0gcG9zLnkgLSBiYi5oIC8gMjtcbiAgICAgIGJiLnkyID0gcG9zLnkgKyBiYi5oIC8gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZUJpYXNWYWx1ZXMocHJvcERpZmYsIHByb3BCaWFzLCBwcm9wQmlhc0NvbXBsZW1lbnQpIHtcbiAgICAgIHZhciBiaWFzRGlmZiA9IDA7XG4gICAgICB2YXIgYmlhc0NvbXBsZW1lbnREaWZmID0gMDtcbiAgICAgIHZhciBiaWFzVG90YWwgPSBwcm9wQmlhcyArIHByb3BCaWFzQ29tcGxlbWVudDtcbiAgICAgIGlmIChwcm9wRGlmZiA+IDAgJiYgYmlhc1RvdGFsID4gMCkge1xuICAgICAgICBiaWFzRGlmZiA9IHByb3BCaWFzIC8gYmlhc1RvdGFsICogcHJvcERpZmY7XG4gICAgICAgIGJpYXNDb21wbGVtZW50RGlmZiA9IHByb3BCaWFzQ29tcGxlbWVudCAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmlhc0RpZmY6IGJpYXNEaWZmLFxuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmY6IGJpYXNDb21wbGVtZW50RGlmZlxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcHV0ZVBhZGRpbmdWYWx1ZXMod2lkdGgsIGhlaWdodCwgcGFkZGluZ09iamVjdCwgcmVsYXRpdmVUbykge1xuICAgICAgLy8gQXNzdW1pbmcgcGVyY2VudGFnZSBpcyBudW1iZXIgZnJvbSAwIHRvIDFcbiAgICAgIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAnJScpIHtcbiAgICAgICAgc3dpdGNoIChyZWxhdGl2ZVRvKSB7XG4gICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcbiAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuICAgICAgICAgIGNhc2UgJ2F2ZXJhZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogKHdpZHRoICsgaGVpZ2h0KSAvIDIgOiAwO1xuICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcbiAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgcmV0dXJuIHBhZGRpbmdPYmplY3QucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGVmdFZhbCA9IG1pbi53aWR0aC5sZWZ0LnZhbHVlO1xuICAgIGlmIChtaW4ud2lkdGgubGVmdC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCkge1xuICAgICAgbGVmdFZhbCA9IGxlZnRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgIH1cbiAgICB2YXIgcmlnaHRWYWwgPSBtaW4ud2lkdGgucmlnaHQudmFsdWU7XG4gICAgaWYgKG1pbi53aWR0aC5yaWdodC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCkge1xuICAgICAgcmlnaHRWYWwgPSByaWdodFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgfVxuICAgIHZhciB0b3BWYWwgPSBtaW4uaGVpZ2h0LnRvcC52YWx1ZTtcbiAgICBpZiAobWluLmhlaWdodC50b3AudW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICB0b3BWYWwgPSB0b3BWYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG4gICAgdmFyIGJvdHRvbVZhbCA9IG1pbi5oZWlnaHQuYm90dG9tLnZhbHVlO1xuICAgIGlmIChtaW4uaGVpZ2h0LmJvdHRvbS51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgIGJvdHRvbVZhbCA9IGJvdHRvbVZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgIH1cbiAgICB2YXIgd2lkdGhCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4ud2lkdGgudmFsIC0gYmIudywgbGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgIHZhciBkaWZmTGVmdCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgIHZhciBkaWZmUmlnaHQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgdmFyIGhlaWdodEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi5oZWlnaHQudmFsIC0gYmIuaCwgdG9wVmFsLCBib3R0b21WYWwpO1xuICAgIHZhciBkaWZmVG9wID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgIHZhciBkaWZmQm90dG9tID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICBfcC5hdXRvUGFkZGluZyA9IGNvbXB1dGVQYWRkaW5nVmFsdWVzKGJiLncsIGJiLmgsIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmcnKSwgcGFyZW50LnBzdHlsZSgncGFkZGluZy1yZWxhdGl2ZS10bycpLnZhbHVlKTtcbiAgICBfcC5hdXRvV2lkdGggPSBNYXRoLm1heChiYi53LCBtaW4ud2lkdGgudmFsKTtcbiAgICBwb3MueCA9ICgtZGlmZkxlZnQgKyBiYi54MSArIGJiLngyICsgZGlmZlJpZ2h0KSAvIDI7XG4gICAgX3AuYXV0b0hlaWdodCA9IE1hdGgubWF4KGJiLmgsIG1pbi5oZWlnaHQudmFsKTtcbiAgICBwb3MueSA9ICgtZGlmZlRvcCArIGJiLnkxICsgYmIueTIgKyBkaWZmQm90dG9tKSAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIGlmICghX3AuY29tcG91bmRCb3VuZHNDbGVhbiB8fCBmb3JjZSkge1xuICAgICAgdXBkYXRlKGVsZSk7XG4gICAgICBpZiAoIWN5LmJhdGNoaW5nKCkpIHtcbiAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBub25pbmYgPSBmdW5jdGlvbiBub25pbmYoeCkge1xuICBpZiAoeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xudmFyIHVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kcyhiLCB4MSwgeTEsIHgyLCB5Mikge1xuICAvLyBkb24ndCB1cGRhdGUgd2l0aCB6ZXJvIGFyZWEgYm94ZXNcbiAgaWYgKHgyIC0geDEgPT09IDAgfHwgeTIgLSB5MSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRvbid0IHVwZGF0ZSB3aXRoIG51bGwgZGltXG4gIGlmICh4MSA9PSBudWxsIHx8IHkxID09IG51bGwgfHwgeDIgPT0gbnVsbCB8fCB5MiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGIueDEgPSB4MSA8IGIueDEgPyB4MSA6IGIueDE7XG4gIGIueDIgPSB4MiA+IGIueDIgPyB4MiA6IGIueDI7XG4gIGIueTEgPSB5MSA8IGIueTEgPyB5MSA6IGIueTE7XG4gIGIueTIgPSB5MiA+IGIueTIgPyB5MiA6IGIueTI7XG4gIGIudyA9IGIueDIgLSBiLngxO1xuICBiLmggPSBiLnkyIC0gYi55MTtcbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbUJveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYiwgYjIpIHtcbiAgaWYgKGIyID09IG51bGwpIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICByZXR1cm4gdXBkYXRlQm91bmRzKGIsIGIyLngxLCBiMi55MSwgYjIueDIsIGIyLnkyKTtcbn07XG52YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KSB7XG4gIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCk7XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgcHJlZml4KSB7XG4gIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIGhhbGZBclcgPSByc3R5bGUuYXJyb3dXaWR0aCAvIDI7XG4gIHZhciBhcnJvd1R5cGUgPSBlbGUucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHg7XG4gIHZhciB5O1xuICBpZiAoYXJyb3dUeXBlICE9PSAnbm9uZScpIHtcbiAgICBpZiAocHJlZml4ID09PSAnc291cmNlJykge1xuICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAndGFyZ2V0Jykge1xuICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIHN0b3JlIHRoZSBpbmRpdmlkdWFsIGFycm93IGJvdW5kc1xuICAgIHZhciBiYnMgPSBfcC5hcnJvd0JvdW5kcyA9IF9wLmFycm93Qm91bmRzIHx8IHt9O1xuICAgIHZhciBiYiA9IGJic1twcmVmaXhdID0gYmJzW3ByZWZpeF0gfHwge307XG4gICAgYmIueDEgPSB4IC0gaGFsZkFyVztcbiAgICBiYi55MSA9IHkgLSBoYWxmQXJXO1xuICAgIGJiLngyID0geCArIGhhbGZBclc7XG4gICAgYmIueTIgPSB5ICsgaGFsZkFyVztcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYiwgMSk7XG4gICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYmIueDEsIGJiLnkxLCBiYi54MiwgYmIueTIpO1xuICB9XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgcHJlZml4KSB7XG4gIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwcmVmaXhEYXNoO1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhEYXNoID0gJyc7XG4gIH1cbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgaWYgKGxhYmVsKSB7XG4gICAgdmFyIGhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJyk7XG4gICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJyk7XG4gICAgdmFyIGxhYmVsV2lkdGggPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbEhlaWdodCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFggPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsWSA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICB2YXIgbWFyZ2luWCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gICAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBoYWxmQm9yZGVyV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgdmFyIHBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpbk9mRXJyb3IgPSAyOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG5cbiAgICB2YXIgbGggPSBsYWJlbEhlaWdodDtcbiAgICB2YXIgbHcgPSBsYWJlbFdpZHRoO1xuICAgIHZhciBsd18yID0gbHcgLyAyO1xuICAgIHZhciBsaF8yID0gbGggLyAyO1xuICAgIHZhciBseDEsIGx4MiwgbHkxLCBseTI7XG4gICAgaWYgKGlzRWRnZSkge1xuICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgbHgyID0gbGFiZWxYO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWDtcbiAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFk7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hpZnQgYnkgbWFyZ2luIGFuZCBleHBhbmQgYnkgb3V0bGluZSBhbmQgYm9yZGVyXG4gICAgdmFyIGxlZnRQYWQgPSBtYXJnaW5YIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZyAtIG1hcmdpbk9mRXJyb3I7XG4gICAgdmFyIHJpZ2h0UGFkID0gbWFyZ2luWCArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmcgKyBtYXJnaW5PZkVycm9yO1xuICAgIHZhciB0b3BQYWQgPSBtYXJnaW5ZIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZyAtIG1hcmdpbk9mRXJyb3I7XG4gICAgdmFyIGJvdFBhZCA9IG1hcmdpblkgKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nICsgbWFyZ2luT2ZFcnJvcjtcbiAgICBseDEgKz0gbGVmdFBhZDtcbiAgICBseDIgKz0gcmlnaHRQYWQ7XG4gICAgbHkxICs9IHRvcFBhZDtcbiAgICBseTIgKz0gYm90UGFkO1xuXG4gICAgLy8gYWx3YXlzIHN0b3JlIHRoZSB1bnJvdGF0ZWQgbGFiZWwgYm91bmRzIHNlcGFyYXRlbHlcbiAgICB2YXIgYmJQcmVmaXggPSBwcmVmaXggfHwgJ21haW4nO1xuICAgIHZhciBiYnMgPSBfcC5sYWJlbEJvdW5kcztcbiAgICB2YXIgYmIgPSBiYnNbYmJQcmVmaXhdID0gYmJzW2JiUHJlZml4XSB8fCB7fTtcbiAgICBiYi54MSA9IGx4MTtcbiAgICBiYi55MSA9IGx5MTtcbiAgICBiYi54MiA9IGx4MjtcbiAgICBiYi55MiA9IGx5MjtcbiAgICBiYi53ID0gbHgyIC0gbHgxO1xuICAgIGJiLmggPSBseTIgLSBseTE7XG4gICAgYmIubGVmdFBhZCA9IGxlZnRQYWQ7XG4gICAgYmIucmlnaHRQYWQgPSByaWdodFBhZDtcbiAgICBiYi50b3BQYWQgPSB0b3BQYWQ7XG4gICAgYmIuYm90UGFkID0gYm90UGFkO1xuICAgIHZhciBpc0F1dG9yb3RhdGUgPSBpc0VkZ2UgJiYgcm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcbiAgICB2YXIgaXNQZlZhbHVlID0gcm90YXRpb24ucGZWYWx1ZSAhPSBudWxsICYmIHJvdGF0aW9uLnBmVmFsdWUgIT09IDA7XG4gICAgaWYgKGlzQXV0b3JvdGF0ZSB8fCBpc1BmVmFsdWUpIHtcbiAgICAgIHZhciB0aGV0YSA9IGlzQXV0b3JvdGF0ZSA/IHByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxBbmdsZScsIHByZWZpeCkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIC8vIHJvdGF0aW9uIHBvaW50IChkZWZhdWx0IHZhbHVlIGZvciBjZW50ZXItY2VudGVyKVxuICAgICAgdmFyIHhvID0gKGx4MSArIGx4MikgLyAyO1xuICAgICAgdmFyIHlvID0gKGx5MSArIGx5MikgLyAyO1xuICAgICAgaWYgKCFpc0VkZ2UpIHtcbiAgICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHhvID0gbHgyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeG8gPSBseDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB5byA9IGx5MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICB5byA9IGx5MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSB4bztcbiAgICAgICAgeSA9IHkgLSB5bztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIHhvLFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgeW9cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuICAgICAgbHgxID0gTWF0aC5taW4ocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICBseDIgPSBNYXRoLm1heChweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgIGx5MSA9IE1hdGgubWluKHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgICAgbHkyID0gTWF0aC5tYXgocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgfVxuICAgIHZhciBiYlByZWZpeFJvdCA9IGJiUHJlZml4ICsgJ1JvdCc7XG4gICAgdmFyIGJiUm90ID0gYmJzW2JiUHJlZml4Um90XSA9IGJic1tiYlByZWZpeFJvdF0gfHwge307XG4gICAgYmJSb3QueDEgPSBseDE7XG4gICAgYmJSb3QueTEgPSBseTE7XG4gICAgYmJSb3QueDIgPSBseDI7XG4gICAgYmJSb3QueTIgPSBseTI7XG4gICAgYmJSb3QudyA9IGx4MiAtIGx4MTtcbiAgICBiYlJvdC5oID0gbHkyIC0gbHkxO1xuICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gICAgdXBkYXRlQm91bmRzKF9wLmxhYmVsQm91bmRzLmFsbCwgbHgxLCBseTEsIGx4MiwgbHkyKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tT3V0bGluZSA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21PdXRsaW5lKGJvdW5kcywgZWxlKSB7XG4gIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ291dGxpbmUtb3BhY2l0eScpLnZhbHVlO1xuICB2YXIgb3V0bGluZVdpZHRoID0gZWxlLnBzdHlsZSgnb3V0bGluZS13aWR0aCcpLnZhbHVlO1xuICB2YXIgb3V0bGluZU9mZnNldCA9IGVsZS5wc3R5bGUoJ291dGxpbmUtb2Zmc2V0JykudmFsdWU7XG4gIHZhciBleHBhbnNpb24gPSBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0O1xuICB1cGRhdGVCb3VuZHNGcm9tTWl0ZXIoYm91bmRzLCBlbGUsIG91dGxpbmVPcGFjaXR5LCBleHBhbnNpb24sICdvdXRzaWRlJywgZXhwYW5zaW9uIC8gMik7XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21NaXRlciA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21NaXRlcihib3VuZHMsIGVsZSwgb3BhY2l0eSwgZXhwYW5zaW9uU2l6ZSwgZXhwYW5zaW9uUG9zaXRpb24sIHVzZUZhbGxiYWNrVmFsdWUpIHtcbiAgaWYgKG9wYWNpdHkgPT09IDAgfHwgZXhwYW5zaW9uU2l6ZSA8PSAwIHx8IGV4cGFuc2lvblBvc2l0aW9uID09PSAnaW5zaWRlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgdmFyIHNoYXBlID0gZWxlLnBzdHlsZSgnc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHJzaGFwZSA9IGN5LnJlbmRlcmVyKCkubm9kZVNoYXBlc1tzaGFwZV07XG4gIHZhciBfZWxlJHBvc2l0aW9uID0gZWxlLnBvc2l0aW9uKCksXG4gICAgeCA9IF9lbGUkcG9zaXRpb24ueCxcbiAgICB5ID0gX2VsZSRwb3NpdGlvbi55O1xuICB2YXIgdyA9IGVsZS53aWR0aCgpO1xuICB2YXIgaCA9IGVsZS5oZWlnaHQoKTtcbiAgaWYgKHJzaGFwZS5oYXNNaXRlckJvdW5kcykge1xuICAgIGlmIChleHBhbnNpb25Qb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIGV4cGFuc2lvblNpemUgLz0gMjtcbiAgICB9XG4gICAgdmFyIG1iYiA9IHJzaGFwZS5taXRlckJvdW5kcyh4LCB5LCB3LCBoLCBleHBhbnNpb25TaXplKTtcbiAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJvdW5kcywgbWJiKTtcbiAgfSBlbHNlIGlmICh1c2VGYWxsYmFja1ZhbHVlICE9IG51bGwgJiYgdXNlRmFsbGJhY2tWYWx1ZSA+IDApIHtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJvdW5kcywgW3VzZUZhbGxiYWNrVmFsdWUsIHVzZUZhbGxiYWNrVmFsdWUsIHVzZUZhbGxiYWNrVmFsdWUsIHVzZUZhbGxiYWNrVmFsdWVdKTtcbiAgfVxufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tTWl0ZXJCb3JkZXIgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tTWl0ZXJCb3JkZXIoYm91bmRzLCBlbGUpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGJvcmRlck9wYWNpdHkgPSBlbGUucHN0eWxlKCdib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICB2YXIgYm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgYm9yZGVyUG9zaXRpb24gPSBlbGUucHN0eWxlKCdib3JkZXItcG9zaXRpb24nKS52YWx1ZTtcbiAgdXBkYXRlQm91bmRzRnJvbU1pdGVyKGJvdW5kcywgZWxlLCBib3JkZXJPcGFjaXR5LCBib3JkZXJXaWR0aCwgYm9yZGVyUG9zaXRpb24pO1xufTtcblxuLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG52YXIgYm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0aW9ucykge1xuICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgdmFyIGhlYWRsZXNzID0gY3kuaGVhZGxlc3MoKTtcbiAgdmFyIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBleDEsIGV4MiwgZXkxLCBleTI7IC8vIGV4dHJlbWEgb2YgYm9keSAvIGxpbmVzXG4gIHZhciB4LCB5OyAvLyBub2RlIHBvc1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgbWFudWFsRXhwYW5zaW9uID0gaXNOb2RlICYmIHN0eWxlRW5hYmxlZCA/IGVsZS5wc3R5bGUoJ2JvdW5kcy1leHBhbnNpb24nKS5wZlZhbHVlIDogWzBdO1xuXG4gIC8vIG11c3QgdXNlIGBkaXNwbGF5YCBwcm9wIG9ubHksIGFzIHJlYWRpbmcgYGNvbXBvdW5kLndpZHRoKClgIGNhdXNlcyByZWN1cnNpb25cbiAgLy8gKG90aGVyIGZhY3RvcnMgbGlrZSB3aWR0aCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb24gYW55d2F5KVxuICB2YXIgaXNEaXNwbGF5ZWQgPSBmdW5jdGlvbiBpc0Rpc3BsYXllZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlICE9PSAnbm9uZSc7XG4gIH07XG4gIHZhciBkaXNwbGF5ZWQgPSAhc3R5bGVFbmFibGVkIHx8IGlzRGlzcGxheWVkKGVsZSlcblxuICAvLyBtdXN0IHRha2UgaW50byBhY2NvdW50IGNvbm5lY3RlZCBub2RlcyBiL2Mgb2YgaW1wbGljaXQgZWRnZSBoaWRpbmcgb24gZGlzcGxheTpub25lIG5vZGVcbiAgJiYgKCFpc0VkZ2UgfHwgaXNEaXNwbGF5ZWQoZWxlLnNvdXJjZSgpKSAmJiBpc0Rpc3BsYXllZChlbGUudGFyZ2V0KCkpKTtcbiAgaWYgKGRpc3BsYXllZCkge1xuICAgIC8vIGRpc3BsYXllZCBzdWZmaWNlcywgc2luY2Ugd2Ugd2lsbCBmaW5kIHplcm8gYXJlYSBlbGVzIGFueXdheVxuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IDA7XG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gMDtcbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICBvdmVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuICAgICAgaWYgKG92ZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIG92ZXJsYXlQYWRkaW5nID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1wYWRkaW5nJykudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1bmRlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciB1bmRlcmxheVBhZGRpbmcgPSAwO1xuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlVW5kZXJsYXlzKSB7XG4gICAgICB1bmRlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCd1bmRlcmxheS1vcGFjaXR5JykudmFsdWU7XG4gICAgICBpZiAodW5kZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHVuZGVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ3VuZGVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhZGRpbmcgPSBNYXRoLm1heChvdmVybGF5UGFkZGluZywgdW5kZXJsYXlQYWRkaW5nKTtcbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIHdIYWxmID0gMDtcbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICB3ID0gZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgd0hhbGYgPSB3IC8gMjtcbiAgICB9XG4gICAgaWYgKGlzTm9kZSAmJiBvcHRpb25zLmluY2x1ZGVOb2Rlcykge1xuICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgeCA9IHBvcy54O1xuICAgICAgeSA9IHBvcy55O1xuICAgICAgdmFyIF93ID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBoYWxmVyA9IF93IC8gMjtcbiAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgaGFsZkggPSBoIC8gMjtcblxuICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICBleDEgPSB4IC0gaGFsZlc7XG4gICAgICBleDIgPSB4ICsgaGFsZlc7XG4gICAgICBleTEgPSB5IC0gaGFsZkg7XG4gICAgICBleTIgPSB5ICsgaGFsZkg7XG4gICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tT3V0bGluZShib3VuZHMsIGVsZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU91dGxpbmVzICYmICFoZWFkbGVzcykge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tT3V0bGluZShib3VuZHMsIGVsZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21NaXRlckJvcmRlcihib3VuZHMsIGVsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZTtcblxuICAgICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBleDEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgZXgyID0gTWF0aC5tYXgocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV5MSA9IE1hdGgubWluKHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpO1xuICAgICAgICBleTIgPSBNYXRoLm1heChyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcblxuICAgICAgICAvLyBwcmVjaXNlIGVkZ2VzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICAgIHZhciBocHRzID0gcnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgICAgIGlmIChocHRzICYmIGhwdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBleDEgPSBocHRzWzBdLng7XG4gICAgICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgICAgICBleDIgPSBocHRzWzFdLng7XG4gICAgICAgICAgICBleTIgPSBocHRzWzFdLnk7XG4gICAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXkxID4gZXkyKSB7XG4gICAgICAgICAgICAgIHZhciBfdGVtcCA9IGV5MTtcbiAgICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgICBleTIgPSBfdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHdIYWxmLCBleTEgLSB3SGFsZiwgZXgyICsgd0hhbGYsIGV5MiArIHdIYWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VydmVTdHlsZSA9PT0gJ2JlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGVuZHNXaXRoKGN1cnZlU3R5bGUsICdzZWdtZW50cycpIHx8IGVuZHNXaXRoKGN1cnZlU3R5bGUsICd0YXhpJykpIHtcbiAgICAgICAgICB2YXIgcHRzO1xuICAgICAgICAgIHN3aXRjaCAoY3VydmVTdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgICAgICAgIGNhc2UgJ3VuYnVuZGxlZC1iZXppZXInOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUuYmV6aWVyUHRzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3RheGknOlxuICAgICAgICAgICAgY2FzZSAncm91bmQtc2VnbWVudHMnOlxuICAgICAgICAgICAgY2FzZSAncm91bmQtdGF4aSc6XG4gICAgICAgICAgICAgIHB0cyA9IHJzdHlsZS5saW5lUHRzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHB0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgcHQgPSBwdHNbal07XG4gICAgICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gcHQueCArIHdIYWxmO1xuICAgICAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcbiAgICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYmV6aWVyLWxpa2Ugb3Igc2VnbWVudC1saWtlIGVkZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG5cbiAgICAgICAgLy8gZmFsbGJhY2sgb24gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIHZhciBuMSA9IGVsZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIG4xcG9zID0gbjEucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG4yID0gZWxlLnRhcmdldCgpO1xuICAgICAgICB2YXIgbjJwb3MgPSBuMi5wb3NpdGlvbigpO1xuICAgICAgICBleDEgPSBuMXBvcy54O1xuICAgICAgICBleDIgPSBuMnBvcy54O1xuICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICBleTIgPSBuMnBvcy55O1xuICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMiA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gX3RlbXAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICB2YXIgX3RlbXAzID0gZXkxO1xuICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICBleTIgPSBfdGVtcDM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgIH0gLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcbiAgICB9IC8vIGVkZ2VzXG5cbiAgICAvLyBoYW5kbGUgZWRnZSBhcnJvdyBzaXplXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcyAmJiBpc0VkZ2UpIHtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC1zb3VyY2UnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC10YXJnZXQnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuXG4gICAgLy8gZ2hvc3RcbiAgICAvLy8vLy8vL1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgdmFyIGdob3N0ID0gZWxlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG4gICAgICBpZiAoZ2hvc3QpIHtcbiAgICAgICAgdmFyIGd4ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICB2YXIgZ3kgPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJvdW5kcy54MSArIGd4LCBib3VuZHMueTEgKyBneSwgYm91bmRzLngyICsgZ3gsIGJvdW5kcy55MiArIGd5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHdheXMgc3RvcmUgdGhlIGJvZHkgYm91bmRzIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGFiZWxzXG4gICAgdmFyIGJiQm9keSA9IF9wLmJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiQm9keSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiQm9keSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYkJvZHksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG5cbiAgICAvLyBvdmVybGF5XG4gICAgLy8vLy8vLy8vL1xuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgZXgxID0gYm91bmRzLngxO1xuICAgICAgZXgyID0gYm91bmRzLngyO1xuICAgICAgZXkxID0gYm91bmRzLnkxO1xuICAgICAgZXkyID0gYm91bmRzLnkyO1xuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gcGFkZGluZywgZXkxIC0gcGFkZGluZywgZXgyICsgcGFkZGluZywgZXkyICsgcGFkZGluZyk7XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuICAgIHZhciBiYk92ZXJsYXkgPSBfcC5vdmVybGF5Qm91bmRzID0gX3Aub3ZlcmxheUJvdW5kcyB8fCB7fTtcbiAgICBhc3NpZ25Cb3VuZGluZ0JveChiYk92ZXJsYXksIGJvdW5kcyk7XG4gICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYk92ZXJsYXksIG1hbnVhbEV4cGFuc2lvbik7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmJPdmVybGF5LCAxKTsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuXG4gICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIGJiTGFiZWxzID0gX3AubGFiZWxCb3VuZHMgPSBfcC5sYWJlbEJvdW5kcyB8fCB7fTtcbiAgICBpZiAoYmJMYWJlbHMuYWxsICE9IG51bGwpIHtcbiAgICAgIGNsZWFyQm91bmRpbmdCb3goYmJMYWJlbHMuYWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmJMYWJlbHMuYWxsID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgfVxuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlTWFpbkxhYmVscykge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgJ3RhcmdldCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBzdHlsZSBlbmFibGVkIGZvciBsYWJlbHNcbiAgfSAvLyBpZiBkaXNwbGF5ZWRcblxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcbiAgaWYgKGJvdW5kcy53ID4gMCAmJiBib3VuZHMuaCA+IDAgJiYgZGlzcGxheWVkKSB7XG4gICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhib3VuZHMsIG1hbnVhbEV4cGFuc2lvbik7XG5cbiAgICAvLyBleHBhbmQgYm91bmRzIGJ5IDEgYmVjYXVzZSBhbnRpYWxpYXNpbmcgY2FuIGluY3JlYXNlIHRoZSB2aXN1YWwvZWZmZWN0aXZlIHNpemUgYnkgMSBvbiBhbGwgc2lkZXNcbiAgICBleHBhbmRCb3VuZGluZ0JveChib3VuZHMsIDEpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59O1xudmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShvcHRzKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHRmID0gZnVuY3Rpb24gdGYodmFsKSB7XG4gICAgcmV0dXJuICh2YWwgPyAxIDogMCkgPDwgaSsrO1xuICB9O1xuICB2YXIga2V5ID0gMDtcbiAga2V5ICs9IHRmKG9wdHMuaW5jdWRlTm9kZXMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlRWRnZXMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlU291cmNlTGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVPdmVybGF5cyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVPdXRsaW5lcyk7XG4gIHJldHVybiBrZXk7XG59O1xudmFyIGdldEJvdW5kaW5nQm94UG9zS2V5ID0gZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKSB7XG4gIHZhciByID0gZnVuY3Rpb24gcih4KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XG4gIH07XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgcDEgPSBlbGUuc291cmNlKCkucG9zaXRpb24oKTtcbiAgICB2YXIgcDIgPSBlbGUudGFyZ2V0KCkucG9zaXRpb24oKTtcbiAgICByZXR1cm4gaGFzaEludHNBcnJheShbcihwMS54KSwgcihwMS55KSwgcihwMi54KSwgcihwMi55KV0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBwID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgcmV0dXJuIGhhc2hJbnRzQXJyYXkoW3IocC54KSwgcihwLnkpXSk7XG4gIH1cbn07XG52YXIgY2FjaGVkQm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gY2FjaGVkQm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0cykge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBiYjtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIGtleSA9IG9wdHMgPT0gbnVsbCA/IGRlZkJiT3B0c0tleSA6IGdldEtleShvcHRzKTtcbiAgdmFyIHVzaW5nRGVmT3B0cyA9IGtleSA9PT0gZGVmQmJPcHRzS2V5O1xuICBpZiAoX3AuYmJDYWNoZSA9PSBudWxsKSB7XG4gICAgYmIgPSBib3VuZGluZ0JveEltcGwoZWxlLCBkZWZCYk9wdHMpO1xuICAgIF9wLmJiQ2FjaGUgPSBiYjtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgfSBlbHNlIHtcbiAgICBiYiA9IF9wLmJiQ2FjaGU7XG4gIH1cblxuICAvLyBub3QgdXNpbmcgZGVmIG9wdHMgPT4gbmVlZCB0byBidWlsZCB1cCBiYiBmcm9tIGNvbWJpbmF0aW9uIG9mIHN1YiBiYnNcbiAgaWYgKCF1c2luZ0RlZk9wdHMpIHtcbiAgICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgaWYgKG9wdHMuaW5jbHVkZU5vZGVzICYmIGlzTm9kZSB8fCBvcHRzLmluY2x1ZGVFZGdlcyAmJiAhaXNOb2RlKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3Aub3ZlcmxheUJvdW5kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5ib2R5Qm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMgJiYgKCFpc0VkZ2UgfHwgb3B0cy5pbmNsdWRlU291cmNlTGFiZWxzICYmIG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuYWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMubWFpblJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnNvdXJjZVJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH1cbiAgcmV0dXJuIGJiO1xufTtcbnZhciBkZWZCYk9wdHMgPSB7XG4gIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlTWFpbkxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVNvdXJjZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZVRhcmdldExhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU92ZXJsYXlzOiB0cnVlLFxuICBpbmNsdWRlVW5kZXJsYXlzOiB0cnVlLFxuICBpbmNsdWRlT3V0bGluZXM6IHRydWUsXG4gIHVzZUNhY2hlOiB0cnVlXG59O1xudmFyIGRlZkJiT3B0c0tleSA9IGdldEtleShkZWZCYk9wdHMpO1xudmFyIGZpbGxlZEJiT3B0cyA9IGRlZmF1bHRzJGcoZGVmQmJPcHRzKTtcbmVsZXNmbiRiLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kcztcbiAgdmFyIHVzZUNhY2hlID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlO1xuICB2YXIgaXNEaXJ0eSA9IG1lbW9pemUoZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICByZXR1cm4gX3AuYmJDYWNoZSA9PSBudWxsIHx8IF9wLnN0eWxlRGlydHkgfHwgX3AuYmJDYWNoZVBvc0tleSAhPT0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgfSwgZnVuY3Rpb24gKGVsZSkge1xuICAgIHJldHVybiBlbGUuaWQoKTtcbiAgfSk7XG5cbiAgLy8gdGhlIG1haW4gdXNlY2FzZSBpcyBlbGUuYm91bmRpbmdCb3goKSBmb3IgYSBzaW5nbGUgZWxlbWVudCB3aXRoIG5vL2RlZiBvcHRpb25zXG4gIC8vIHNwZWNpZmllZCBzLnQuIHRoZSBjYWNoZSBpcyB1c2VkLCBzbyBjaGVjayBmb3IgdGhpcyBjYXNlIHRvIG1ha2UgaXQgZmFzdGVyIGJ5XG4gIC8vIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cbiAgaWYgKHVzZUNhY2hlICYmIHRoaXMubGVuZ3RoID09PSAxICYmICFpc0RpcnR5KHRoaXNbMF0pKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IGRlZkJiT3B0cztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICB9XG4gICAgYm91bmRzID0gY2FjaGVkQm91bmRpbmdCb3hJbXBsKHRoaXNbMF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZkJiT3B0cztcbiAgICB2YXIgb3B0cyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgIC8vIGNhY2hlIHRoZSBpc0RpcnR5IHN0YXRlIGZvciBhbGwgZWxlcywgZWRnZXMgZmlyc3Qgc2luY2UgdGhleSBkZXBlbmQgb24gbm9kZSBzdGF0ZVxuICAgIHRoaXMuZWRnZXMoKS5mb3JFYWNoKGlzRGlydHkpO1xuICAgIHRoaXMubm9kZXMoKS5mb3JFYWNoKGlzRGlydHkpO1xuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcyghdXNlQ2FjaGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICBpZiAoaXNEaXJ0eShlbGUpKSB7XG4gICAgICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYm91bmRzLCBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSk7XG4gICAgfVxuICB9XG4gIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuICByZXR1cm4gYm91bmRzO1xufTtcbmVsZXNmbiRiLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wID0gdGhpc1tpXS5fcHJpdmF0ZTtcbiAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICBfcC5iYkNhY2hlUG9zS2V5ID0gbnVsbDtcbiAgICBfcC5ib2R5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5vdmVybGF5Qm91bmRzID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5hbGwgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5tYWluID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpblJvdCA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtc291cmNlJ10gPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzWydtaWQtdGFyZ2V0J10gPSBudWxsO1xuICB9XG4gIHRoaXMuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcHJpdmF0ZSBoZWxwZXIgdG8gZ2V0IGJvdW5kaW5nIGJveCBmb3IgY3VzdG9tIG5vZGUgcG9zaXRpb25zXG4vLyAtIGdvb2QgZm9yIHBlcmYgaW4gY2VydGFpbiBjYXNlcyBidXQgY3VycmVudGx5IHJlcXVpcmVzIGRpcnR5aW5nIHRoZSByZW5kZXJlZCBzdHlsZVxuLy8gLSB3b3VsZCBiZSBiZXR0ZXIgdG8gbm90IG1vZGlmeSB0aGUgbm9kZXMgYnV0IHRoZSBub2RlcyBhcmUgcmVhZCBkaXJlY3RseSBldmVyeXdoZXJlIGluIHRoZSByZW5kZXJlci4uLlxuLy8gLSB0cnkgdG8gdXNlIGZvciBvbmx5IHRoaW5ncyBsaWtlIGRpc2NyZXRlIGxheW91dHMgd2hlcmUgdGhlIG5vZGUgcG9zaXRpb24gd291bGQgY2hhbmdlIGFueXdheVxuZWxlc2ZuJGIuYm91bmRpbmdCb3hBdCA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBwYXJlbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHBhcmVudHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmlzUGFyZW50KCk7XG4gICAgfSk7XG4gICAgbm9kZXMgPSBub2Rlcy5ub3QocGFyZW50cyk7XG4gIH1cbiAgaWYgKHBsYWluT2JqZWN0KGZuKSkge1xuICAgIHZhciBvYmogPSBmbjtcbiAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG4gIHZhciBzdG9yZU9sZFBvcyA9IGZ1bmN0aW9uIHN0b3JlT2xkUG9zKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zID0gZm4obm9kZSwgaSk7XG4gIH07XG4gIHZhciBnZXRPbGRQb3MgPSBmdW5jdGlvbiBnZXRPbGRQb3Mobm9kZSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3M7XG4gIH07XG4gIGN5LnN0YXJ0QmF0Y2goKTtcbiAgbm9kZXMuZm9yRWFjaChzdG9yZU9sZFBvcykuc2lsZW50UG9zaXRpb25zKGZuKTtcbiAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICBwYXJlbnRzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIHBhcmVudHMuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgcGFyZW50cy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICB9XG4gIHZhciBiYiA9IGNvcHlCb3VuZGluZ0JveCh0aGlzLmJvdW5kaW5nQm94KHtcbiAgICB1c2VDYWNoZTogZmFsc2VcbiAgfSkpO1xuICBub2Rlcy5zaWxlbnRQb3NpdGlvbnMoZ2V0T2xkUG9zKTtcbiAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICBwYXJlbnRzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIHBhcmVudHMuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgcGFyZW50cy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICB9XG4gIGN5LmVuZEJhdGNoKCk7XG4gIHJldHVybiBiYjtcbn07XG5mbiQzLmJvdW5kaW5nYm94ID0gZm4kMy5iYiA9IGZuJDMuYm91bmRpbmdCb3g7XG5mbiQzLnJlbmRlcmVkQm91bmRpbmdib3ggPSBmbiQzLnJlbmRlcmVkQm91bmRpbmdCb3g7XG52YXIgYm91bmRzID0gZWxlc2ZuJGI7XG5cbnZhciBmbiQyLCBlbGVzZm4kYTtcbmZuJDIgPSBlbGVzZm4kYSA9IHt9O1xudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uIGRlZmluZURpbUZucyhvcHRzKSB7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IGNhcGl0YWxpemUob3B0cy5uYW1lKTtcbiAgb3B0cy5hdXRvTmFtZSA9ICdhdXRvJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5sYWJlbE5hbWUgPSAnbGFiZWwnICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLm91dGVyTmFtZSA9ICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm91dGVyTmFtZSk7XG4gIGZuJDJbb3B0cy5uYW1lXSA9IGZ1bmN0aW9uIGRpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICByZXR1cm4gX3Bbb3B0cy5hdXRvTmFtZV0gfHwgMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZCA9IGVsZS5wc3R5bGUob3B0cy5uYW1lKTtcbiAgICAgICAgc3dpdGNoIChkLnN0clZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSgpO1xuICAgICAgICAgICAgcmV0dXJuIF9wLnJzdHlsZVtvcHRzLmxhYmVsTmFtZV0gfHwgMDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGQucGZWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmbiQyWydvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGRpbSA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICAgIHZhciBib3JkZXJQb3MgPSBlbGUucHN0eWxlKCdib3JkZXItcG9zaXRpb24nKS52YWx1ZTtcbiAgICAgICAgdmFyIGJvcmRlcjtcbiAgICAgICAgaWYgKGJvcmRlclBvcyA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBib3JkZXIgPSBlbGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlOyAvLyBuLmIuIDEvMiBlYWNoIHNpZGVcbiAgICAgICAgfSBlbHNlIGlmIChib3JkZXJQb3MgPT09ICdvdXRzaWRlJykge1xuICAgICAgICAgIGJvcmRlciA9IDIgKiBlbGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICdpbnNpZGUnXG4gICAgICAgICAgYm9yZGVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFkZGluZyA9IDIgKiBlbGUucGFkZGluZygpO1xuICAgICAgICByZXR1cm4gZGltICsgYm9yZGVyICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZm4kMlsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgZCA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICByZXR1cm4gZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgfVxuICB9O1xuICBmbiQyWydyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZE91dGVyRGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgb2QgPSBlbGVbb3B0cy5vdXRlck5hbWVdKCk7XG4gICAgICByZXR1cm4gb2QgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcbn07XG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnd2lkdGgnXG59KTtcbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICdoZWlnaHQnXG59KTtcbmVsZXNmbiRhLnBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIGlmIChfcC5hdXRvUGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AuYXV0b1BhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICB9XG59O1xuZWxlc2ZuJGEucGFkZGVkSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZS5oZWlnaHQoKSArIDIgKiBlbGUucGFkZGluZygpO1xufTtcbmVsZXNmbiRhLnBhZGRlZFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZS53aWR0aCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xudmFyIHdpZHRoSGVpZ2h0ID0gZWxlc2ZuJGE7XG5cbnZhciBpZkVkZ2UgPSBmdW5jdGlvbiBpZkVkZ2UoZWxlLCBnZXRWYWx1ZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpICYmIGVsZS50YWtlc1VwU3BhY2UoKSkge1xuICAgIHJldHVybiBnZXRWYWx1ZShlbGUpO1xuICB9XG59O1xudmFyIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKGVsZSwgZ2V0UG9pbnQpIHtcbiAgaWYgKGVsZS5pc0VkZ2UoKSAmJiBlbGUudGFrZXNVcFNwYWNlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24kMShnZXRQb2ludChlbGUpLCBjeS56b29tKCksIGN5LnBhbigpKTtcbiAgfVxufTtcbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKGVsZSwgZ2V0UG9pbnRzKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkgJiYgZWxlLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHJldHVybiBnZXRQb2ludHMoZWxlKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxKHAsIHpvb20sIHBhbik7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgY29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRDb250cm9sUG9pbnRzKGVsZSk7XG59O1xudmFyIHNlZ21lbnRQb2ludHMgPSBmdW5jdGlvbiBzZWdtZW50UG9pbnRzKGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U2VnbWVudFBvaW50cyhlbGUpO1xufTtcbnZhciBzb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIHNvdXJjZUVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U291cmNlRW5kcG9pbnQoZWxlKTtcbn07XG52YXIgdGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiB0YXJnZXRFbmRwb2ludChlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFRhcmdldEVuZHBvaW50KGVsZSk7XG59O1xudmFyIG1pZHBvaW50ID0gZnVuY3Rpb24gbWlkcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRFZGdlTWlkcG9pbnQoZWxlKTtcbn07XG52YXIgcHRzID0ge1xuICBjb250cm9sUG9pbnRzOiB7XG4gICAgZ2V0OiBjb250cm9sUG9pbnRzLFxuICAgIG11bHQ6IHRydWVcbiAgfSxcbiAgc2VnbWVudFBvaW50czoge1xuICAgIGdldDogc2VnbWVudFBvaW50cyxcbiAgICBtdWx0OiB0cnVlXG4gIH0sXG4gIHNvdXJjZUVuZHBvaW50OiB7XG4gICAgZ2V0OiBzb3VyY2VFbmRwb2ludFxuICB9LFxuICB0YXJnZXRFbmRwb2ludDoge1xuICAgIGdldDogdGFyZ2V0RW5kcG9pbnRcbiAgfSxcbiAgbWlkcG9pbnQ6IHtcbiAgICBnZXQ6IG1pZHBvaW50XG4gIH1cbn07XG52YXIgcmVuZGVyZWROYW1lID0gZnVuY3Rpb24gcmVuZGVyZWROYW1lKG5hbWUpIHtcbiAgcmV0dXJuICdyZW5kZXJlZCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTtcbn07XG52YXIgZWRnZVBvaW50cyA9IE9iamVjdC5rZXlzKHB0cykucmVkdWNlKGZ1bmN0aW9uIChvYmosIG5hbWUpIHtcbiAgdmFyIHNwZWMgPSBwdHNbbmFtZV07XG4gIHZhciByTmFtZSA9IHJlbmRlcmVkTmFtZShuYW1lKTtcbiAgb2JqW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZkVkZ2UodGhpcywgc3BlYy5nZXQpO1xuICB9O1xuICBpZiAoc3BlYy5tdWx0KSB7XG4gICAgb2JqW3JOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyh0aGlzLCBzcGVjLmdldCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24odGhpcywgc3BlYy5nZXQpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxudmFyIGRpbWVuc2lvbnMgPSBleHRlbmQoe30sIHBvc2l0aW9uLCBib3VuZHMsIHdpZHRoSGVpZ2h0LCBlZGdlUG9pbnRzKTtcblxuLyohXG5FdmVudCBvYmplY3QgYmFzZWQgb24galF1ZXJ5IGV2ZW50cywgTUlUIGxpY2Vuc2VcblxuaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2UvXG5odHRwczovL3RsZHJsZWdhbC5jb20vbGljZW5zZS9taXQtbGljZW5zZVxuaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG4qL1xuXG52YXIgRXZlbnQgPSBmdW5jdGlvbiBFdmVudChzcmMsIHByb3BzKSB7XG4gIHRoaXMucmVjeWNsZShzcmMsIHByb3BzKTtcbn07XG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuRXZlbnQucHJvdG90eXBlID0ge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdldmVudCc7XG4gIH0sXG4gIHJlY3ljbGU6IGZ1bmN0aW9uIHJlY3ljbGUoc3JjLCBwcm9wcykge1xuICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5GYWxzZTtcbiAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAvLyBCcm93c2VyIEV2ZW50IG9iamVjdFxuICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG4gICAgfSBlbHNlIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMudHlwZSkge1xuICAgICAgLy8gUGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGV2ZW50IGRldGFpbHNcbiAgICAgIHByb3BzID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVudCBzdHJpbmdcbiAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICB9XG5cbiAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgIGlmIChwcm9wcyAhPSBudWxsKSB7XG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBtYW51YWxseSBjb3B5IGZpZWxkcyB3ZSB1c2VcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHByb3BzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICB0aGlzLnR5cGUgPSBwcm9wcy50eXBlICE9IG51bGwgPyBwcm9wcy50eXBlIDogdGhpcy50eXBlO1xuICAgICAgdGhpcy5jeSA9IHByb3BzLmN5O1xuICAgICAgdGhpcy50YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gcHJvcHMucG9zaXRpb247XG4gICAgICB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgICB0aGlzLmxheW91dCA9IHByb3BzLmxheW91dDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3kgIT0gbnVsbCAmJiB0aGlzLnBvc2l0aW9uICE9IG51bGwgJiYgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmVkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwYXNzZWQgcG9zaXRpb25cbiAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgdmFyIHpvb20gPSB0aGlzLmN5Lnpvb20oKTtcbiAgICAgIHZhciBwYW4gPSB0aGlzLmN5LnBhbigpO1xuICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0ge1xuICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgcHJldmVudERlZmF1bHQgZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfSxcbiAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcbiAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2Vcbn07XG5cbnZhciBldmVudFJlZ2V4ID0gL14oW14uXSspKFxcLig/OlteLl0rKSk/JC87IC8vIHJlZ2V4IGZvciBtYXRjaGluZyBldmVudCBzdHJpbmdzIChlLmcuIFwiY2xpY2submFtZXNwYWNlXCIpXG52YXIgdW5pdmVyc2FsTmFtZXNwYWNlID0gJy4qJzsgLy8gbWF0Y2hlcyBhcyBpZiBubyBuYW1lc3BhY2Ugc3BlY2lmaWVkIGFuZCBwcmV2ZW50cyB1c2VycyBmcm9tIHVuYmluZGluZyBhY2NpZGVudGFsbHlcblxudmFyIGRlZmF1bHRzJDggPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUocTEsIHEyKSB7XG4gICAgcmV0dXJuIHExID09PSBxMjtcbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoLypjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmoqL1xuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKC8qY29udGV4dCwgZXZ0Ki9cbiAgKSB7fSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY29udGV4dCAvKiwgbGlzdGVuZXIsIGV2ZW50T2JqKi8pIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSxcbiAgYmVmb3JlRW1pdDogZnVuY3Rpb24gYmVmb3JlRW1pdCgvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAgKSB7fSxcbiAgYWZ0ZXJFbWl0OiBmdW5jdGlvbiBhZnRlckVtaXQoLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gICkge30sXG4gIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKC8qY29udGV4dCovXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoLypjb250ZXh0Ki9cbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGNvbnRleHQ6IG51bGxcbn07XG52YXIgZGVmYXVsdHNLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMkOCk7XG52YXIgZW1wdHlPcHRzID0ge307XG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZW1wdHlPcHRzO1xuICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAvLyBtaWNyby1vcHRpbWlzYXRpb24gdnMgT2JqZWN0LmFzc2lnbigpIC0tIHJlZHVjZXMgRWxlbWVudCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gZGVmYXVsdHNLZXlzW2ldO1xuICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XSB8fCBkZWZhdWx0cyQ4W2tleV07XG4gIH1cbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG4gIHRoaXMubGlzdGVuZXJzID0gW107XG4gIHRoaXMuZW1pdHRpbmcgPSAwO1xufVxudmFyIHAgPSBFbWl0dGVyLnByb3RvdHlwZTtcbnZhciBmb3JFYWNoRXZlbnQgPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnQoc2VsZiwgaGFuZGxlciwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGlmIChmbiQ2KHF1YWxpZmllcikpIHtcbiAgICBjYWxsYmFjayA9IHF1YWxpZmllcjtcbiAgICBxdWFsaWZpZXIgPSBudWxsO1xuICB9XG4gIGlmIChjb25mT3ZlcnJpZGVzKSB7XG4gICAgaWYgKGNvbmYgPT0gbnVsbCkge1xuICAgICAgY29uZiA9IGNvbmZPdmVycmlkZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmYgPSBleHRlbmQoe30sIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICAgIH1cbiAgfVxuICB2YXIgZXZlbnRMaXN0ID0gYXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG4gICAgaWYgKGVtcHR5U3RyaW5nKGV2dCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgIHZhciByZXQgPSBoYW5kbGVyKHNlbGYsIGV2dCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKTtcbiAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBhbGxvdyBleGl0aW5nIGVhcmx5XG4gICAgfVxuICB9XG59O1xudmFyIG1ha2VFdmVudE9iaiA9IGZ1bmN0aW9uIG1ha2VFdmVudE9iaihzZWxmLCBvYmopIHtcbiAgc2VsZi5hZGRFdmVudEZpZWxkcyhzZWxmLmNvbnRleHQsIG9iaik7XG4gIHJldHVybiBuZXcgRXZlbnQob2JqLnR5cGUsIG9iaik7XG59O1xudmFyIGZvckVhY2hFdmVudE9iaiA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudE9iaihzZWxmLCBoYW5kbGVyLCBldmVudHMpIHtcbiAgaWYgKGV2ZW50KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIGV2ZW50cyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGV2ZW50cykpIHtcbiAgICBoYW5kbGVyKHNlbGYsIG1ha2VFdmVudE9iaihzZWxmLCBldmVudHMpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgZXZlbnRPYmogPSBtYWtlRXZlbnRPYmooc2VsZiwge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgdGFyZ2V0OiBzZWxmLmNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcihzZWxmLCBldmVudE9iaik7XG4gICAgfVxuICB9XG59O1xucC5vbiA9IHAuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGZvckVhY2hFdmVudCh0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICAgIGlmIChmbiQ2KGNhbGxiYWNrKSkge1xuICAgICAgc2VsZi5saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgLy8gZnVsbCBldmVudCBzdHJpbmdcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgIHF1YWxpZmllcjogcXVhbGlmaWVyLFxuICAgICAgICAvLyBhIHJlc3RyaWN0aW9uIG9uIHdoZXRoZXIgdG8gbWF0Y2ggdGhpcyBlbWl0dGVyXG4gICAgICAgIGNvbmY6IGNvbmYgLy8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gIHJldHVybiB0aGlzO1xufTtcbnAub25lID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICByZXR1cm4gdGhpcy5vbihldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIHtcbiAgICBvbmU6IHRydWVcbiAgfSk7XG59O1xucC5yZW1vdmVMaXN0ZW5lciA9IHAub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBpZiAodGhpcy5lbWl0dGluZyAhPT0gMCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gY29weUFycmF5KHRoaXMubGlzdGVuZXJzKTtcbiAgfVxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgZm9yRWFjaEV2ZW50KF90aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjayAvKiwgY29uZiovKSB7XG4gICAgICBpZiAoKGxpc3RlbmVyLnR5cGUgPT09IHR5cGUgfHwgZXZlbnRzID09PSAnKicpICYmICghbmFtZXNwYWNlICYmIGxpc3RlbmVyLm5hbWVzcGFjZSAhPT0gJy4qJyB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSkgJiYgKCFxdWFsaWZpZXIgfHwgc2VsZi5xdWFsaWZpZXJDb21wYXJlKGxpc3RlbmVyLnF1YWxpZmllciwgcXVhbGlmaWVyKSkgJiYgKCFjYWxsYmFjayB8fCBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2spKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuICB9O1xuICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgX2xvb3AoaSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xucC5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKCcqJyk7XG59O1xucC5lbWl0ID0gcC50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50cywgZXh0cmFQYXJhbXMsIG1hbnVhbENhbGxiYWNrKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcbiAgdmFyIG51bUxpc3RlbmVyc0JlZm9yZUVtaXQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICB0aGlzLmVtaXR0aW5nKys7XG4gIGlmICghYXJyYXkoZXh0cmFQYXJhbXMpKSB7XG4gICAgZXh0cmFQYXJhbXMgPSBbZXh0cmFQYXJhbXNdO1xuICB9XG4gIGZvckVhY2hFdmVudE9iaih0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnRPYmopIHtcbiAgICBpZiAobWFudWFsQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXJzID0gW3tcbiAgICAgICAgZXZlbnQ6IGV2ZW50T2JqLmV2ZW50LFxuICAgICAgICB0eXBlOiBldmVudE9iai50eXBlLFxuICAgICAgICBuYW1lc3BhY2U6IGV2ZW50T2JqLm5hbWVzcGFjZSxcbiAgICAgICAgY2FsbGJhY2s6IG1hbnVhbENhbGxiYWNrXG4gICAgICB9XTtcbiAgICAgIG51bUxpc3RlbmVyc0JlZm9yZUVtaXQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgaWYgKGxpc3RlbmVyLnR5cGUgPT09IGV2ZW50T2JqLnR5cGUgJiYgKCFsaXN0ZW5lci5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBldmVudE9iai5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSB1bml2ZXJzYWxOYW1lc3BhY2UpICYmIHNlbGYuZXZlbnRNYXRjaGVzKHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKSkge1xuICAgICAgICB2YXIgYXJncyA9IFtldmVudE9ial07XG4gICAgICAgIGlmIChleHRyYVBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgICAgcHVzaChhcmdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5iZWZvcmVFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmUpIHtcbiAgICAgICAgICBzZWxmLmxpc3RlbmVycyA9IHNlbGYubGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0ID0gc2VsZi5jYWxsYmFja0NvbnRleHQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICB2YXIgcmV0ID0gbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHNlbGYuYWZ0ZXJFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBldmVudE9iai5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldmVudE9iai5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdDsgaSsrKSB7XG4gICAgICBfbG9vcDIoKTtcbiAgICB9IC8vIGZvciBsaXN0ZW5lclxuXG4gICAgaWYgKHNlbGYuYnViYmxlKHNlbGYuY29udGV4dCkgJiYgIWV2ZW50T2JqLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgIHNlbGYucGFyZW50KHNlbGYuY29udGV4dCkuZW1pdChldmVudE9iaiwgZXh0cmFQYXJhbXMpO1xuICAgIH1cbiAgfSwgZXZlbnRzKTtcbiAgdGhpcy5lbWl0dGluZy0tO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBlbWl0dGVyT3B0aW9ucyQxID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICB9XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGVsZSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gbGlzdGVuZXIucXVhbGlmaWVyO1xuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhlbGUsIGV2dCkge1xuICAgIGV2dC5jeSA9IGVsZS5jeSgpO1xuICAgIGV2dC50YXJnZXQgPSBlbGU7XG4gIH0sXG4gIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGVsZSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogZWxlO1xuICB9LFxuICBiZWZvcmVFbWl0OiBmdW5jdGlvbiBiZWZvcmVFbWl0KGNvbnRleHQsIGxpc3RlbmVyIC8qLCBldmVudE9iaiovKSB7XG4gICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmNlKSB7XG4gICAgICBsaXN0ZW5lci5jb25mLm9uY2VDb2xsZWN0aW9uLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5xdWFsaWZpZXIsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG4gIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKSA/IGVsZS5wYXJlbnQoKSA6IGVsZS5jeSgpO1xuICB9XG59O1xudmFyIGFyZ1NlbGVjdG9yJDEgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn07XG52YXIgZWxlc2ZuJDkgPSB7XG4gIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdGlvbnMkMSwgZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgfSxcbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjaywge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBvbmNlQ29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdEFuZE5vdGlmeTogZnVuY3Rpb24gZW1pdEFuZE5vdGlmeShldmVudCwgZXh0cmFQYXJhbXMpIHtcbiAgICAvLyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGVtcHR5IGNvbGxlY3Rpb25zIGRvbid0IG5lZWQgdG8gbm90aWZ5IGFueXRoaW5nXG5cbiAgICAvLyBub3RpZnkgcmVuZGVyZXJcbiAgICB0aGlzLmN5KCkubm90aWZ5KGV2ZW50LCB0aGlzKTtcbiAgICB0aGlzLmVtaXQoZXZlbnQsIGV4dHJhUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbmRlZmluZS5ldmVudEFsaWFzZXNPbihlbGVzZm4kOSk7XG5cbnZhciBlbGVzZm4kOCA9IHtcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgLy8gaW50ZXJuYWwgaGVscGVyIHRvIGdldCBub2RlcyBhbmQgZWRnZXMgYXMgc2VwYXJhdGUgY29sbGVjdGlvbnMgd2l0aCBzaW5nbGUgaXRlcmF0aW9uIG92ZXIgZWxlbWVudHNcbiAgYnlHcm91cDogZnVuY3Rpb24gYnlHcm91cCgpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5zcGF3bigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2VzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgIGVkZ2VzOiBlZGdlc1xuICAgIH07XG4gIH0sXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKF9maWx0ZXIsIHRoaXNBcmcpIHtcbiAgICBpZiAoX2ZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0aGlzIGZpcnN0IGIvYyBpdCdzIHRoZSBtb3N0IGNvbW1vbi9wZXJmb3JtYW50IGNhc2VcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKF9maWx0ZXIpIHx8IGVsZW1lbnRPckNvbGxlY3Rpb24oX2ZpbHRlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IoX2ZpbHRlcikuZmlsdGVyKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoZm4kNihfZmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlckVsZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBpbmNsdWRlID0gdGhpc0FyZyA/IF9maWx0ZXIuYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogX2ZpbHRlcihlbGUsIGksIGVsZXMpO1xuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIGZpbHRlckVsZXMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsdGVyRWxlcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgfSxcbiAgbm90OiBmdW5jdGlvbiBub3QodG9SZW1vdmUpIHtcbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmVtb3ZlID0gdG9SZW1vdmUuaGFzKGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXJlbW92ZSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gIH0sXG4gIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24gYWJzb2x1dGVDb21wbGVtZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICByZXR1cm4gY3kubXV0YWJsZUVsZW1lbnRzKCkubm90KHRoaXMpO1xuICB9LFxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIGludGVyc2VjdChvdGhlcikge1xuICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgIHZhciBjb2wxU21hbGxlciA9IHRoaXMubGVuZ3RoIDwgb3RoZXIubGVuZ3RoO1xuICAgIHZhciBjb2xTID0gY29sMVNtYWxsZXIgPyBjb2wxIDogY29sMjtcbiAgICB2YXIgY29sTCA9IGNvbDFTbWFsbGVyID8gY29sMiA6IGNvbDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xTLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gY29sU1tpXTtcbiAgICAgIGlmIChjb2xMLmhhcyhlbGUpKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICB4b3I6IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgfVxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGNvbCwgb3RoZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICAgICAgICBpZiAoIWluT3RoZXIpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZChjb2wxLCBjb2wyKTtcbiAgICBhZGQoY29sMiwgY29sMSk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICB9XG4gICAgdmFyIGxlZnQgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBib3RoID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlciwgcmV0RWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG4gICAgICAgIGlmIChpbk90aGVyKSB7XG4gICAgICAgICAgYm90aC5tZXJnZShlbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEVsZXMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhZGQoY29sMSwgY29sMiwgbGVmdCk7XG4gICAgYWRkKGNvbDIsIGNvbDEsIHJpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgIGJvdGg6IGJvdGhcbiAgICB9O1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKCF0b0FkZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3blNlbGYoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgYWRkID0gIXRoaXMuaGFzKGVsZSk7XG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHRvQWRkKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRvQWRkICYmIHN0cmluZyh0b0FkZCkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICB2YXIgbWFwID0gX3AubWFwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b0FkZEVsZSA9IHRvQWRkW2ldO1xuICAgICAgdmFyIGlkID0gdG9BZGRFbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBhZGQgPSAhbWFwLmhhcyhpZCk7XG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdG9BZGRFbGU7XG4gICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICBlbGU6IHRvQWRkRWxlLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVubWVyZ2VBdDogZnVuY3Rpb24gdW5tZXJnZUF0KGkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBtYXAgPSBfcC5tYXA7XG5cbiAgICAvLyByZW1vdmUgZWxlXG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICBtYXBbXCJkZWxldGVcIl0oaWQpO1xuICAgIHZhciB1bm1lcmdlZExhc3RFbGUgPSBpID09PSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiAhdW5tZXJnZWRMYXN0RWxlKSB7XG4gICAgICB2YXIgbGFzdEVsZUkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbGFzdEVsZSA9IHRoaXNbbGFzdEVsZUldO1xuICAgICAgdmFyIGxhc3RFbGVJZCA9IGxhc3RFbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHRoaXNbbGFzdEVsZUldID0gdW5kZWZpbmVkO1xuICAgICAgdGhpc1tpXSA9IGxhc3RFbGU7XG4gICAgICBtYXAuc2V0KGxhc3RFbGVJZCwge1xuICAgICAgICBlbGU6IGxhc3RFbGUsXG4gICAgICAgIGluZGV4OiBpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuICAgIHRoaXMubGVuZ3RoLS07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIHJlbW92ZSBzaW5nbGUgZWxlIGluIHBsYWNlIGluIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlT25lOiBmdW5jdGlvbiB1bm1lcmdlT25lKGVsZSkge1xuICAgIGVsZSA9IGVsZVswXTtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIHZhciBtYXAgPSBfcC5tYXA7XG4gICAgdmFyIGVudHJ5ID0gbWFwLmdldChpZCk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgfVxuICAgIHZhciBpID0gZW50cnkuaW5kZXg7XG4gICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlOiBmdW5jdGlvbiB1bm1lcmdlKHRvUmVtb3ZlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRvUmVtb3ZlICYmIHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgdG9SZW1vdmUgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVubWVyZ2VPbmUodG9SZW1vdmVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgdW5tZXJnZUJ5OiBmdW5jdGlvbiB1bm1lcmdlQnkodG9SbUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgaWYgKHRvUm1GbihlbGUpKSB7XG4gICAgICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IG1hcEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IG1hcEZuKGVsZSwgaSwgZWxlcyk7XG4gICAgICBhcnIucHVzaChyZXQpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9LFxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHZhbCA9IGluaXRpYWxWYWx1ZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9LFxuICBtYXg6IGZ1bmN0aW9uIG1heCh2YWxGbiwgdGhpc0FyZykge1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heEVsZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWF4LFxuICAgICAgZWxlOiBtYXhFbGVcbiAgICB9O1xuICB9LFxuICBtaW46IGZ1bmN0aW9uIG1pbih2YWxGbiwgdGhpc0FyZykge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiB2YWxGbihlbGUsIGksIGVsZXMpO1xuICAgICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtaW4sXG4gICAgICBlbGU6IG1pbkVsZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbnZhciBmbiQxID0gZWxlc2ZuJDg7XG5mbiQxWyd1J10gPSBmbiQxWyd8J10gPSBmbiQxWycrJ10gPSBmbiQxLnVuaW9uID0gZm4kMS5vciA9IGZuJDEuYWRkO1xuZm4kMVsnXFxcXCddID0gZm4kMVsnISddID0gZm4kMVsnLSddID0gZm4kMS5kaWZmZXJlbmNlID0gZm4kMS5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbiQxLnN1YnRyYWN0ID0gZm4kMS5ub3Q7XG5mbiQxWyduJ10gPSBmbiQxWycmJ10gPSBmbiQxWycuJ10gPSBmbiQxLmFuZCA9IGZuJDEuaW50ZXJzZWN0aW9uID0gZm4kMS5pbnRlcnNlY3Q7XG5mbiQxWydeJ10gPSBmbiQxWycoKyknXSA9IGZuJDFbJygtKSddID0gZm4kMS5zeW1tZXRyaWNEaWZmZXJlbmNlID0gZm4kMS5zeW1kaWZmID0gZm4kMS54b3I7XG5mbiQxLmZuRmlsdGVyID0gZm4kMS5maWx0ZXJGbiA9IGZuJDEuc3RkRmlsdGVyID0gZm4kMS5maWx0ZXI7XG5mbiQxLmNvbXBsZW1lbnQgPSBmbiQxLmFic2NvbXAgPSBmbiQxLmFic29sdXRlQ29tcGxlbWVudDtcblxudmFyIGVsZXNmbiQ3ID0ge1xuICBpc05vZGU6IGZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnbm9kZXMnO1xuICB9LFxuICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnZWRnZXMnO1xuICB9LFxuICBpc0xvb3A6IGZ1bmN0aW9uIGlzTG9vcCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpWzBdID09PSB0aGlzLnRhcmdldCgpWzBdO1xuICB9LFxuICBpc1NpbXBsZTogZnVuY3Rpb24gaXNTaW1wbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSAhPT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAqXG4gKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAqL1xudmFyIHpJbmRleFNvcnQgPSBmdW5jdGlvbiB6SW5kZXhTb3J0KGEsIGIpIHtcbiAgdmFyIGN5ID0gYS5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgZnVuY3Rpb24gZ2V0RGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpO1xuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIE1BWF9JTlQkMTtcbiAgICB9XG4gICAgLy8gJ29ycGhhbidcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgZGVwdGhEaWZmID0gZ2V0RGVwdGgoYSkgLSBnZXREZXB0aChiKTtcbiAgaWYgKGRlcHRoRGlmZiAhPT0gMCkge1xuICAgIHJldHVybiBkZXB0aERpZmY7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RWxlRGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1pbmRleC1jb21wYXJlJyk7XG4gICAgaWYgKHN0eWxlLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgPyAxIDogMDtcbiAgICB9XG4gICAgLy8gJ21hbnVhbCdcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgZWxlRGlmZiA9IGdldEVsZURlcHRoKGEpIC0gZ2V0RWxlRGVwdGgoYik7XG4gIGlmIChlbGVEaWZmICE9PSAwKSB7XG4gICAgcmV0dXJuIGVsZURpZmY7XG4gIH1cbiAgdmFyIHpEaWZmID0gYS5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZSAtIGIucHN0eWxlKCd6LWluZGV4JykudmFsdWU7XG4gIGlmICh6RGlmZiAhPT0gMCkge1xuICAgIHJldHVybiB6RGlmZjtcbiAgfVxuICAvLyBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuICByZXR1cm4gYS5wb29sSW5kZXgoKSAtIGIucG9vbEluZGV4KCk7XG59O1xuXG52YXIgZWxlc2ZuJDYgPSB7XG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICBpZiAoZm4kNihmbikpIHtcbiAgICAgIHZhciBOID0gdGhpcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBmbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCB0aGlzXSkgOiBmbihlbGUsIGksIHRoaXMpO1xuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA+PSAwICYmIGkgPCBlbmQgJiYgaSA8IHRoaXNTaXplOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKGFycmF5KTtcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH0sXG4gIGVxOiBmdW5jdGlvbiBlcShpKSB7XG4gICAgcmV0dXJuIHRoaXNbaV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbMF0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICB9LFxuICBub25lbXB0eTogZnVuY3Rpb24gbm9uZW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoc29ydEZuKSB7XG4gICAgaWYgKCFmbiQ2KHNvcnRGbikpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydChzb3J0Rm4pO1xuICAgIHJldHVybiB0aGlzLnNwYXduKHNvcnRlZCk7XG4gIH0sXG4gIHNvcnRCeVpJbmRleDogZnVuY3Rpb24gc29ydEJ5WkluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNvcnQoekluZGV4U29ydCk7XG4gIH0sXG4gIHpEZXB0aDogZnVuY3Rpb24gekRlcHRoKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmICghZWxlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGxldCBjeSA9IGVsZS5jeSgpO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcbiAgICBpZiAoZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgIHZhciBkZXB0aCA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuICAgICAgaWYgKCFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gTUFYX0lOVCQxIC0gMTsgLy8gY2hpbGRsZXNzIG5vZGVzIGFsd2F5cyBvbiB0b3BcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRGVwdGggPSBzcmMuekRlcHRoKCk7XG4gICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoc3JjRGVwdGgsIHRndERlcHRoLCAwKTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnRcbiAgICB9XG4gIH1cbn07XG5lbGVzZm4kNi5lYWNoID0gZWxlc2ZuJDYuZm9yRWFjaDtcbnZhciBkZWZpbmVTeW1ib2xJdGVyYXRvciA9IGZ1bmN0aW9uIGRlZmluZVN5bWJvbEl0ZXJhdG9yKCkge1xuICB2YXIgdHlwZW9mVW5kZWYgPSBcInVuZGVmaW5lZFwiIDtcbiAgdmFyIGlzSXRlcmF0b3JTdXBwb3J0ZWQgPSAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFN5bWJvbCkpICE9IHR5cGVvZlVuZGVmICYmIF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSAhPSB0eXBlb2ZVbmRlZjtcbiAgaWYgKGlzSXRlcmF0b3JTdXBwb3J0ZWQpIHtcbiAgICBlbGVzZm4kNltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5JDEoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZSA9IF90aGlzW2krK107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgfSwgU3ltYm9sLml0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufTtcbmRlZmluZVN5bWJvbEl0ZXJhdG9yKCk7XG5cbnZhciBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zID0gZGVmYXVsdHMkZyh7XG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQ1ID0ge1xuICAvLyBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIG5vZGUgZGltZW5zaW9ucyB7IHgsIHkgfSBiYXNlZCBvbiBvcHRpb25zIGdpdmVuXG4gIGxheW91dERpbWVuc2lvbnM6IGZ1bmN0aW9uIGxheW91dERpbWVuc2lvbnMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciBkaW1zO1xuICAgIGlmICghdGhpcy50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICB2YXIgYmJEaW0gPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiBiYkRpbS53LFxuICAgICAgICBoOiBiYkRpbS5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiB0aGlzLm91dGVyV2lkdGgoKSxcbiAgICAgICAgaDogdGhpcy5vdXRlckhlaWdodCgpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHNhbml0aXNlIHRoZSBkaW1lbnNpb25zIGZvciBleHRlcm5hbCBsYXlvdXRzIChhdm9pZCBkaXZpc2lvbiBieSB6ZXJvKVxuICAgIGlmIChkaW1zLncgPT09IDAgfHwgZGltcy5oID09PSAwKSB7XG4gICAgICBkaW1zLncgPSBkaW1zLmggPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfSxcbiAgLy8gdXNpbmcgc3RhbmRhcmQgbGF5b3V0IG9wdGlvbnMsIGFwcGx5IHBvc2l0aW9uIGZ1bmN0aW9uICh3LyBvciB3L28gYW5pbWF0aW9uKVxuICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uIGxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGZuKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gICAgfSk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBsYXlvdXRFbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBub2RlcyAmIGVkZ2VzXG4gICAgdmFyIGdldE1lbW9pemVLZXkgPSBmdW5jdGlvbiBnZXRNZW1vaXplS2V5KG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmlkKCk7XG4gICAgfTtcbiAgICB2YXIgZm5NZW0gPSBtZW1vaXplKGZuLCBnZXRNZW1vaXplS2V5KTsgLy8gbWVtb2l6ZWQgdmVyc2lvbiBvZiBwb3NpdGlvbiBmdW5jdGlvblxuXG4gICAgbGF5b3V0LmVtaXQoe1xuICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgIGxheW91dDogbGF5b3V0XG4gICAgfSk7XG4gICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcbiAgICB2YXIgY2FsY3VsYXRlU3BhY2luZyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgbm9kZXNCYiwgcG9zKSB7XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiBub2Rlc0JiLngxICsgbm9kZXNCYi53IC8gMixcbiAgICAgICAgeTogbm9kZXNCYi55MSArIG5vZGVzQmIuaCAvIDJcbiAgICAgIH07XG4gICAgICB2YXIgc3BhY2luZ1ZlY3RvciA9IHtcbiAgICAgICAgLy8gc2NhbGUgZnJvbSBjZW50ZXIgb2YgYm91bmRpbmcgYm94IChub3QgbmVjZXNzYXJpbHkgMCwwKVxuICAgICAgICB4OiAocG9zLnggLSBjZW50ZXIueCkgKiBzcGFjaW5nLFxuICAgICAgICB5OiAocG9zLnkgLSBjZW50ZXIueSkgKiBzcGFjaW5nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyBzcGFjaW5nVmVjdG9yLngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgc3BhY2luZ1ZlY3Rvci55XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIHVzZVNwYWNpbmdGYWN0b3IgPSBvcHRpb25zLnNwYWNpbmdGYWN0b3IgJiYgb3B0aW9ucy5zcGFjaW5nRmFjdG9yICE9PSAxO1xuICAgIHZhciBzcGFjaW5nQmIgPSBmdW5jdGlvbiBzcGFjaW5nQmIoKSB7XG4gICAgICBpZiAoIXVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IGZuTWVtKG5vZGUsIGkpO1xuICAgICAgICBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHBvcy54LCBwb3MueSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmI7XG4gICAgfTtcbiAgICB2YXIgYmIgPSBzcGFjaW5nQmIoKTtcbiAgICB2YXIgZ2V0RmluYWxQb3MgPSBtZW1vaXplKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICB2YXIgbmV3UG9zID0gZm5NZW0obm9kZSwgaSk7XG4gICAgICBpZiAodXNlU3BhY2luZ0ZhY3Rvcikge1xuICAgICAgICB2YXIgc3BhY2luZyA9IE1hdGguYWJzKG9wdGlvbnMuc3BhY2luZ0ZhY3Rvcik7XG4gICAgICAgIG5ld1BvcyA9IGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgYmIsIG5ld1Bvcyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgICAgICBuZXdQb3MgPSBvcHRpb25zLnRyYW5zZm9ybShub2RlLCBuZXdQb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9LCBnZXRNZW1vaXplS2V5KTtcbiAgICBpZiAob3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBuZXdQb3MgPSBnZXRGaW5hbFBvcyhub2RlLCBpKTtcbiAgICAgICAgdmFyIGFuaW1hdGVOb2RlID0gb3B0aW9ucy5hbmltYXRlRmlsdGVyID09IG51bGwgfHwgb3B0aW9ucy5hbmltYXRlRmlsdGVyKG5vZGUsIGkpO1xuICAgICAgICBpZiAoYW5pbWF0ZU5vZGUpIHtcbiAgICAgICAgICB2YXIgYW5pID0gbm9kZS5hbmltYXRpb24oe1xuICAgICAgICAgICAgcG9zaXRpb246IG5ld1BvcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goYW5pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICB2YXIgZml0QW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICBmaXQ6IHtcbiAgICAgICAgICAgIGJvdW5kaW5nQm94OiBsYXlvdXRFbGVzLmJvdW5kaW5nQm94QXQoZ2V0RmluYWxQb3MpLFxuICAgICAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGZpdEFuaSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHpvb21QYW5BbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgIHpvb206IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICBwYW46IG9wdGlvbnMucGFuLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goem9vbVBhbkFuaSk7XG4gICAgICB9XG4gICAgICBsYXlvdXQuYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhbmkpIHtcbiAgICAgICAgcmV0dXJuIGFuaS5wbGF5KCk7XG4gICAgICB9KTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICAgIFByb21pc2UkMS5hbGwobGF5b3V0LmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmkpIHtcbiAgICAgICAgcmV0dXJuIGFuaS5wcm9taXNlKCk7XG4gICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzLnBvc2l0aW9ucyhnZXRGaW5hbFBvcyk7XG4gICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgY3kuZml0KG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT0gbnVsbCkge1xuICAgICAgICBjeS56b29tKG9wdGlvbnMuem9vbSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5wYW4pIHtcbiAgICAgICAgY3kucGFuKG9wdGlvbnMucGFuKTtcbiAgICAgIH1cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm1ha2VMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSkpO1xuICB9XG59O1xuXG4vLyBhbGlhc2VzOlxuZWxlc2ZuJDUuY3JlYXRlTGF5b3V0ID0gZWxlc2ZuJDUubWFrZUxheW91dCA9IGVsZXNmbiQ1LmxheW91dDtcblxuZnVuY3Rpb24gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgY2FjaGUgPSBfcC5zdHlsZUNhY2hlID0gX3Auc3R5bGVDYWNoZSB8fCBbXTtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBjYWNoZVtrZXldKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBjYWNoZVtrZXldID0gZm4oZWxlKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG59XG5mdW5jdGlvbiBjYWNoZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRTdHlsZUZ1bmN0aW9uKGVsZSkge1xuICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSk7XG4gIH07XG59XG5mdW5jdGlvbiBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gIHZhciBzZWxmRm4gPSBmdW5jdGlvbiBzZWxmRm4oZWxlKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwoZWxlKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBzZWxmRm4sIGVsZSk7XG4gICAgfVxuICB9O1xufVxudmFyIGVsZXNmbiQ0ID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgICBpZiAocmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkKSB7XG4gICAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodGhpcywgdXNlQ2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlydHlTdHlsZUNhY2hlOiBmdW5jdGlvbiBkaXJ0eVN0eWxlQ2FjaGUoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBkaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9O1xuICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHZhciBlbGVzO1xuICAgICAgZWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgICBlbGVzLm1lcmdlKGVsZXMuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICBlbGVzLmZvckVhY2goZGlydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBkaXJ0eShlbGUpO1xuICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGRpcnR5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICB1cGRhdGVTdHlsZTogZnVuY3Rpb24gdXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG4gICAgICBiRWxlcy5tZXJnZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgfVxuICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcztcbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgLy8gdGhlbiBhZGQgZXZlcnl0aGluZyB1cCBhbmQgZG93biBmb3IgY29tcG91bmQgc2VsZWN0b3IgY2hlY2tzXG4gICAgICB1cGRhdGVkRWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgfVxuXG4gICAgLy8gbGV0IGNoYW5nZWRFbGVzID0gc3R5bGUuYXBwbHkoIHVwZGF0ZWRFbGVzICk7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gdXBkYXRlZEVsZXM7XG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICBjaGFuZ2VkRWxlcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXQoJ3N0eWxlJyk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICB9XG4gICAgdXBkYXRlZEVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlRGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICAvLyBwcml2YXRlOiBjbGVhcnMgZGlydHkgZmxhZyBhbmQgcmVjYWxjdWxhdGVzIHN0eWxlXG4gIGNsZWFuU3R5bGU6IGZ1bmN0aW9uIGNsZWFuU3R5bGUoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGlmIChlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSkge1xuICAgICAgICAvLyBuLmIuIHRoaXMgZmxhZyBzaG91bGQgYmUgc2V0IGJlZm9yZSBhcHBseSgpIHRvIGF2b2lkIHBvdGVudGlhbCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgZWxlLl9wcml2YXRlLnN0eWxlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY3kuc3R5bGUoKS5hcHBseShlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBwYXJzZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gIHBhcnNlZFN0eWxlOiBmdW5jdGlvbiBwYXJzZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBpbmNsdWRlTm9uRGVmYXVsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGUpIHtcbiAgICAgIC8vIHRoaXMuY2xlYW5TdHlsZSgpO1xuXG4gICAgICAvLyBJbmxpbmUgdGhlIGltcG9ydGFudCBwYXJ0IG9mIGNsZWFuU3R5bGUoKSwgZm9yIHJhdyBwZXJmb3JtYW5jZVxuICAgICAgaWYgKGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5KSB7XG4gICAgICAgIC8vIG4uYi4gdGhpcyBmbGFnIHNob3VsZCBiZSBzZXQgYmVmb3JlIGFwcGx5KCkgdG8gYXZvaWQgcG90ZW50aWFsIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICBlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBjeS5zdHlsZSgpLmFwcGx5KGVsZSk7XG4gICAgICB9XG4gICAgICB2YXIgb3ZlcnJpZGRlblN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlW3Byb3BlcnR5XTtcbiAgICAgIGlmIChvdmVycmlkZGVuU3R5bGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGRlblN0eWxlO1xuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlTm9uRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBudW1lcmljU3R5bGU6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmICghZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpO1xuICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZVVuaXRzOiBmdW5jdGlvbiBudW1lcmljU3R5bGVVbml0cyhwcm9wZXJ0eSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmICghZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUocHJvcGVydHkpLnVuaXRzO1xuICAgIH1cbiAgfSxcbiAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgY3NzIHByb3BlcnR5IGFzIGEgcmVuZGVyZWQgdmFsdWUgKGkuZS4gb24tc2NyZWVuIHZhbHVlKVxuICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICByZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZW5kZXJlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKGVsZSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfSxcbiAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgIC8vIHRoZW4gZXh0ZW5kIHRoZSBieXBhc3NcbiAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICBzdHlsZS5hcHBseUJ5cGFzcyh0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgIH0gZWxzZSBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGVuIGdldCB0aGUgcHJvcGVydHkgZnJvbSB0aGUgc3R5bGVcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9lbGUgPSB0aGlzWzBdO1xuICAgICAgaWYgKF9lbGUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKF9lbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHJlbW92ZVN0eWxlOiBmdW5jdGlvbiByZW1vdmVTdHlsZShuYW1lcykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW19pXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoX2VsZTIsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ2VsZW1lbnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGVmZmVjdGl2ZU9wYWNpdHk6IGZ1bmN0aW9uIGVmZmVjdGl2ZU9wYWNpdHkoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG4gICAgICBpZiAocGFyZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcmVudC5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgIH1cbiAgfSxcbiAgdHJhbnNwYXJlbnQ6IGZ1bmN0aW9uIHRyYW5zcGFyZW50KCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gZWxlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICByZXR1cm4gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiYWNrZ3JvdW5kaW5nOiBmdW5jdGlvbiBiYWNrZ3JvdW5kaW5nKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPaykge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwYXJlbnRzID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpIDogbnVsbDtcbiAgaWYgKHBhcmVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgaWYgKCFwYXJlbnRPayhwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbihzcGVjcykge1xuICB2YXIgb2sgPSBzcGVjcy5vaztcbiAgdmFyIGVkZ2VPa1ZpYU5vZGUgPSBzcGVjcy5lZGdlT2tWaWFOb2RlIHx8IHNwZWNzLm9rO1xuICB2YXIgcGFyZW50T2sgPSBzcGVjcy5wYXJlbnRPayB8fCBzcGVjcy5vaztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIGlmICghb2soZWxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgcmV0dXJuIGVkZ2VPa1ZpYU5vZGUoc3JjKSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChzcmMsIGVkZ2VPa1ZpYU5vZGUpKSAmJiAoc3JjID09PSB0Z3QgfHwgZWRnZU9rVmlhTm9kZSh0Z3QpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHRndCwgZWRnZU9rVmlhTm9kZSkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG52YXIgZWxlVGFrZXNVcFNwYWNlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVUYWtlc1VwU3BhY2UnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdlbGVtZW50JyAmJiBlbGUud2lkdGgoKSAhPT0gMCAmJiAoZWxlLmlzTm9kZSgpID8gZWxlLmhlaWdodCgpICE9PSAwIDogdHJ1ZSk7XG59KTtcbmVsZXNmbiQ0LnRha2VzVXBTcGFjZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndGFrZXNVcFNwYWNlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG52YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG52YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ3BhcmVudEludGVyYWN0aXZlJywgZnVuY3Rpb24gKHBhcmVudCkge1xuICByZXR1cm4gcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKHBhcmVudCk7XG59KTtcbmVsZXNmbiQ0LmludGVyYWN0aXZlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpbnRlcmFjdGl2ZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZUludGVyYWN0aXZlLFxuICBwYXJlbnRPazogcGFyZW50SW50ZXJhY3RpdmUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xuZWxlc2ZuJDQubm9uaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuaW50ZXJhY3RpdmUoKTtcbiAgfVxufTtcbnZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBlZGdlVmlzaWJsZVZpYU5vZGUgPSBlbGVUYWtlc1VwU3BhY2U7XG5lbGVzZm4kNC52aXNpYmxlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd2aXNpYmxlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVmlzaWJsZSxcbiAgZWRnZU9rVmlhTm9kZTogZWRnZVZpc2libGVWaWFOb2RlXG59KSk7XG5lbGVzZm4kNC5oaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59O1xuZWxlc2ZuJDQuaXNCdW5kbGVkQmV6aWVyID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpc0J1bmRsZWRCZXppZXInLCBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhdGhpcy5yZW1vdmVkKCkgJiYgdGhpcy5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWUgPT09ICdiZXppZXInICYmIHRoaXMudGFrZXNVcFNwYWNlKCk7XG59KTtcbmVsZXNmbiQ0LmJ5cGFzcyA9IGVsZXNmbiQ0LmNzcyA9IGVsZXNmbiQ0LnN0eWxlO1xuZWxlc2ZuJDQucmVuZGVyZWRDc3MgPSBlbGVzZm4kNC5yZW5kZXJlZFN0eWxlO1xuZWxlc2ZuJDQucmVtb3ZlQnlwYXNzID0gZWxlc2ZuJDQucmVtb3ZlQ3NzID0gZWxlc2ZuJDQucmVtb3ZlU3R5bGU7XG5lbGVzZm4kNC5wc3R5bGUgPSBlbGVzZm4kNC5wYXJzZWRTdHlsZTtcblxudmFyIGVsZXNmbiQzID0ge307XG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTtcblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIGRhdGEsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGZuJDYoYXJnc1swXSkpIHtcbiAgICAgIHZhciBfaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgX2hhbmRsZXIpO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgIC8vIGUuZy4gKHByaXZhdGUpIGN5Lm5vZGVzKCkuc2VsZWN0KFsndGFwc2VsZWN0J10pXG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPT09IDEgJiYgYXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIHZhciBhZGRsRXZlbnRzID0gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gIT0gcGFyYW1zLnZhbHVlO1xuICAgICAgICBpZiAocGFyYW1zLm92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgIHZhciBvdmVycmlkZUFibGUgPSBwYXJhbXMub3ZlcnJpZGVBYmxlKGVsZSk7XG4gICAgICAgICAgaWYgKG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYmxlID0gb3ZlcnJpZGVBYmxlO1xuICAgICAgICAgICAgaWYgKCFvdmVycmlkZUFibGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IC8vIHRvIHNhdmUgY3ljbGVzIGFzc3VtZSBub3QgYWJsZSBmb3IgYWxsIG9uIG92ZXJyaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhYmxlKSB7XG4gICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VkQ29sbCA9IHRoaXMuc3Bhd24oY2hhbmdlZEVsZXMpO1xuICAgICAgY2hhbmdlZENvbGwudXBkYXRlU3R5bGUoKTsgLy8gY2hhbmdlIG9mIHN0YXRlID0+IHBvc3NpYmxlIGNoYW5nZSBvZiBzdHlsZVxuICAgICAgY2hhbmdlZENvbGwuZW1pdChwYXJhbXMuZXZlbnQpO1xuICAgICAgaWYgKGFkZGxFdmVudHMpIHtcbiAgICAgICAgY2hhbmdlZENvbGwuZW1pdChhZGRsRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQocGFyYW1zKSB7XG4gIGVsZXNmbiQzW3BhcmFtcy5maWVsZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUZpZWxkKSB7XG4gICAgICAgIHZhciB2YWwgPSBwYXJhbXMub3ZlcnJpZGVGaWVsZChlbGUpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF07XG4gICAgfVxuICB9O1xuICBlbGVzZm4kM1twYXJhbXMub25dID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub24sXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBlbGVzZm4kM1twYXJhbXMub2ZmXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICBldmVudDogcGFyYW1zLm9mZixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IGZhbHNlXG4gIH0pO1xufVxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdsb2NrZWQnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdsb2NrJyxcbiAgb2ZmOiAndW5sb2NrJ1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2dyYWJiYWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bmdyYWJpZnkoKSB8fCBlbGUucGFubmFibGUoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2dyYWJpZnknLFxuICBvZmY6ICd1bmdyYWJpZnknXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICBhYmxlRmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVBYmxlOiBmdW5jdGlvbiBvdmVycmlkZUFibGUoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0JyxcbiAgb2ZmOiAndW5zZWxlY3QnXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0aWZ5JyxcbiAgb2ZmOiAndW5zZWxlY3RpZnknXG59KTtcbmVsZXNmbiQzLmRlc2VsZWN0ID0gZWxlc2ZuJDMudW5zZWxlY3Q7XG5lbGVzZm4kMy5ncmFiYmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgfVxufTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnYWN0aXZlJyxcbiAgb246ICdhY3RpdmF0ZScsXG4gIG9mZjogJ3VuYWN0aXZhdGUnXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAncGFubmFibGUnLFxuICBvbjogJ3BhbmlmeScsXG4gIG9mZjogJ3VucGFuaWZ5J1xufSk7XG5lbGVzZm4kMy5pbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmIChlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5fcHJpdmF0ZS5hY3RpdmU7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kMiA9IHt9O1xuXG4vLyBEQUcgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZpbmVEYWdFeHRyZW1pdHkgPSBmdW5jdGlvbiBkZWZpbmVEYWdFeHRyZW1pdHkocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBkYWdFeHRyZW1pdHlJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZGlzcXVhbGlmaWVkID0gZmFsc2U7XG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICBpZiAocGFyYW1zLm5vSW5jb21pbmdFZGdlcyAmJiB0Z3QgPT09IGVsZSAmJiBzcmMgIT09IGVsZSB8fCBwYXJhbXMubm9PdXRnb2luZ0VkZ2VzICYmIHNyYyA9PT0gZWxlICYmIHRndCAhPT0gZWxlKSB7XG4gICAgICAgICAgZGlzcXVhbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkaXNxdWFsaWZpZWQpIHtcbiAgICAgICAgcmV0LnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0LCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcbnZhciBkZWZpbmVEYWdPbmVIb3AgPSBmdW5jdGlvbiBkZWZpbmVEYWdPbmVIb3AocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5vdXRnb2luZyAmJiBzcmMgPT09IGVsZSkge1xuICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgb0VsZXMucHVzaCh0Z3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5pbmNvbWluZyAmJiB0Z3QgPT09IGVsZSkge1xuICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgb0VsZXMucHVzaChzcmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKG9FbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcbnZhciBkZWZpbmVEYWdBbGxIb3BzID0gZnVuY3Rpb24gZGVmaW5lRGFnQWxsSG9wcyhwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgc0VsZXMgPSBbXTtcbiAgICB2YXIgc0VsZXNJZHMgPSB7fTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmFtcy5vdXRnb2luZyA/IGVsZXMub3V0Z29lcnMoKSA6IGVsZXMuaW5jb21lcnMoKTtcbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZG9uZSBpZiBub25lIGxlZnRcblxuICAgICAgdmFyIG5ld05leHQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbiA9IG5leHRbaV07XG4gICAgICAgIHZhciBuaWQgPSBuLmlkKCk7XG4gICAgICAgIGlmICghc0VsZXNJZHNbbmlkXSkge1xuICAgICAgICAgIHNFbGVzSWRzW25pZF0gPSB0cnVlO1xuICAgICAgICAgIHNFbGVzLnB1c2gobik7XG4gICAgICAgICAgbmV3TmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbmV3TmV4dCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cbiAgICAgIGVsZXMgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzRWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5lbGVzZm4kMi5jbGVhclRyYXZlcnNhbENhY2hlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzW2ldLl9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcbiAgfVxufTtcbmV4dGVuZChlbGVzZm4kMiwge1xuICAvLyBnZXQgdGhlIHJvb3Qgbm9kZXMgaW4gdGhlIERBR1xuICByb290czogZGVmaW5lRGFnRXh0cmVtaXR5KHtcbiAgICBub0luY29taW5nRWRnZXM6IHRydWVcbiAgfSksXG4gIC8vIGdldCB0aGUgbGVhZiBub2RlcyBpbiB0aGUgREFHXG4gIGxlYXZlczogZGVmaW5lRGFnRXh0cmVtaXR5KHtcbiAgICBub091dGdvaW5nRWRnZXM6IHRydWVcbiAgfSksXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBjaGlsZHJlbiBpbiBncmFwaCB0aGVvcnlcbiAgLy8gdGhlc2Ugbm9kZXMgPWVkZ2VzPT4gb3V0Z29pbmcgbm9kZXNcbiAgb3V0Z29lcnM6IGNhY2hlKGRlZmluZURhZ09uZUhvcCh7XG4gICAgb3V0Z29pbmc6IHRydWVcbiAgfSksICdvdXRnb2VycycpLFxuICAvLyBha2EgREFHIGRlc2NlbmRhbnRzXG4gIHN1Y2Nlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoe1xuICAgIG91dGdvaW5nOiB0cnVlXG4gIH0pLFxuICAvLyBub3JtYWxseSBjYWxsZWQgcGFyZW50cyBpbiBncmFwaCB0aGVvcnlcbiAgLy8gdGhlc2Ugbm9kZXMgPD1lZGdlcz0gaW5jb21pbmcgbm9kZXNcbiAgaW5jb21lcnM6IGNhY2hlKGRlZmluZURhZ09uZUhvcCh7XG4gICAgaW5jb21pbmc6IHRydWVcbiAgfSksICdpbmNvbWVycycpLFxuICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICBwcmVkZWNlc3NvcnM6IGRlZmluZURhZ0FsbEhvcHMoe1xuICAgIH0pXG59KTtcblxuLy8gTmVpZ2hib3VyaG9vZCBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4dGVuZChlbGVzZm4kMiwge1xuICBuZWlnaGJvcmhvb2Q6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSBub2RlID09PSBzcmMgPyB0Z3QgOiBzcmM7XG5cbiAgICAgICAgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcbiAgICAgICAgaWYgKG90aGVyTm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChvdGhlck5vZGVbMF0pOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcbiAgICAgICAgZWxlbWVudHMucHVzaChlZGdlWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICduZWlnaGJvcmhvb2QnKSxcbiAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbiBjbG9zZWROZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24gb3Blbk5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZChzZWxlY3Rvcik7XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4kMi5uZWlnaGJvdXJob29kID0gZWxlc2ZuJDIubmVpZ2hib3Job29kO1xuZWxlc2ZuJDIuY2xvc2VkTmVpZ2hib3VyaG9vZCA9IGVsZXNmbiQyLmNsb3NlZE5laWdoYm9yaG9vZDtcbmVsZXNmbiQyLm9wZW5OZWlnaGJvdXJob29kID0gZWxlc2ZuJDIub3Blbk5laWdoYm9yaG9vZDtcblxuLy8gRWRnZSBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4dGVuZChlbGVzZm4kMiwge1xuICBzb3VyY2U6IGNhY2hlKGZ1bmN0aW9uIHNvdXJjZUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgc3JjO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlcihzZWxlY3RvcikgOiBzcmM7XG4gIH0sICdzb3VyY2UnKSxcbiAgdGFyZ2V0OiBjYWNoZShmdW5jdGlvbiB0YXJnZXRJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHRndDtcbiAgICBpZiAoZWxlKSB7XG4gICAgICB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0IHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoc2VsZWN0b3IpIDogdGd0O1xuICB9LCAndGFyZ2V0JyksXG4gIHNvdXJjZXM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAnc291cmNlJ1xuICB9KSxcbiAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgIGF0dHI6ICd0YXJnZXQnXG4gIH0pXG59KTtcbmZ1bmN0aW9uIGRlZmluZVNvdXJjZUZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmF0dHJdO1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICBzb3VyY2VzLnB1c2goc3JjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc291cmNlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn1cbmV4dGVuZChlbGVzZm4kMiwge1xuICBlZGdlc1dpdGg6IGNhY2hlKGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCksICdlZGdlc1dpdGgnKSxcbiAgZWRnZXNUbzogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oe1xuICAgIHRoaXNJc1NyYzogdHJ1ZVxuICB9KSwgJ2VkZ2VzVG8nKVxufSk7XG5mdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGVkZ2VzV2l0aEltcGwob3RoZXJOb2Rlcykge1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHAgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcbiAgICBpZiAoc3RyaW5nKG90aGVyTm9kZXMpKSB7XG4gICAgICBvdGhlck5vZGVzID0gY3kuJChvdGhlck5vZGVzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaCA9IDA7IGggPCBvdGhlck5vZGVzLmxlbmd0aDsgaCsrKSB7XG4gICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgZWRnZURhdGEgPSBlZGdlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuICAgICAgICBpZiAoIWVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLnRoaXNJc1NyYyB8fCBwLnRoaXNJc1RndCkge1xuICAgICAgICAgIGlmIChwLnRoaXNJc1NyYyAmJiAhdGhpc1RvT3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocC50aGlzSXNUZ3QgJiYgIW90aGVyVG9UaGlzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpO1xuICB9O1xufVxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIGNvbm5lY3RlZEVkZ2VzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gZWxlc1tpXTtcbiAgICAgIGlmICghbm9kZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHJldEVsZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZEVkZ2VzJyksXG4gIGNvbm5lY3RlZE5vZGVzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcbiAgICAgIGlmICghZWRnZS5pc0VkZ2UoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldEVsZXMucHVzaChlZGdlLnNvdXJjZSgpWzBdKTtcbiAgICAgIHJldEVsZXMucHVzaChlZGdlLnRhcmdldCgpWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG4gIHBhcmFsbGVsRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLCAncGFyYWxsZWxFZGdlcycpLFxuICBjb2RpcmVjdGVkRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbih7XG4gICAgY29kaXJlY3RlZDogdHJ1ZVxuICB9KSwgJ2NvZGlyZWN0ZWRFZGdlcycpXG59KTtcbmZ1bmN0aW9uIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGNvZGlyZWN0ZWQ6IGZhbHNlXG4gIH07XG4gIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gIHJldHVybiBmdW5jdGlvbiBwYXJhbGxlbEVkZ2VzSW1wbChzZWxlY3Rvcikge1xuICAgIC8vIG1pY3JvLW9wdGltaXNlZCBmb3IgcmVuZGVyZXJcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgdmFyIHAgPSBwYXJhbXM7XG5cbiAgICAvLyBsb29rIGF0IGFsbCB0aGUgZWRnZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZTEgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBlZGdlMV9wID0gZWRnZTEuX3ByaXZhdGU7XG4gICAgICB2YXIgc3JjMSA9IGVkZ2UxX3Auc291cmNlO1xuICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciB0Z3RpZDEgPSBlZGdlMV9wLmRhdGEudGFyZ2V0O1xuICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlMiA9IHNyY0VkZ2VzMVtqXTtcbiAgICAgICAgdmFyIGVkZ2UyZGF0YSA9IGVkZ2UyLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICB2YXIgc3JjaWQyID0gZWRnZTJkYXRhLnNvdXJjZTtcbiAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgdmFyIG9wcGRpcmVjdGVkID0gc3JjaWQxID09PSB0Z3RpZDIgJiYgdGd0aWQxID09PSBzcmNpZDI7XG4gICAgICAgIGlmIChwLmNvZGlyZWN0ZWQgJiYgY29kaXJlY3RlZCB8fCAhcC5jb2RpcmVjdGVkICYmIChjb2RpcmVjdGVkIHx8IG9wcGRpcmVjdGVkKSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufVxuXG4vLyBNaXNjIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIGNvbXBvbmVudHM6IGZ1bmN0aW9uIGNvbXBvbmVudHMocm9vdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgdmFyIHVudmlzaXRlZCA9IHJvb3QgPT0gbnVsbCA/IHNlbGYubm9kZXMoKSA6IHJvb3Qubm9kZXMoKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIGlmIChyb290ICE9IG51bGwgJiYgdW52aXNpdGVkLmVtcHR5KCkpIHtcbiAgICAgIC8vIHJvb3QgbWF5IGNvbnRhaW4gb25seSBlZGdlc1xuICAgICAgdW52aXNpdGVkID0gcm9vdC5zb3VyY2VzKCk7IC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIG5vZGUgdG8gdXNlICh1bmRpcmVjdGVkKSwgc28ganVzdCB1c2UgdGhlIHNvdXJjZSBzaWRlc1xuICAgIH1cbiAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHZpc2l0SW5Db21wb25lbnQobm9kZSwgY29tcG9uZW50KSB7XG4gICAgICB2aXNpdGVkLm1lcmdlKG5vZGUpO1xuICAgICAgdW52aXNpdGVkLnVubWVyZ2Uobm9kZSk7XG4gICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgfTtcbiAgICBpZiAodW52aXNpdGVkLmVtcHR5KCkpIHtcbiAgICAgIHJldHVybiBzZWxmLnNwYXduKCk7XG4gICAgfVxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgLy8gZWFjaCBpdGVyYXRpb24geWllbGRzIGEgY29tcG9uZW50XG4gICAgICB2YXIgY21wdCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcbiAgICAgIHZhciByb290ID0gdW52aXNpdGVkWzBdO1xuICAgICAgdmlzaXRJbkNvbXBvbmVudChyb290LCBjbXB0KTtcbiAgICAgIHNlbGYuYmZzKHtcbiAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgICAgICByb290czogcm9vdCxcbiAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KHYpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRJbkNvbXBvbmVudCh2LCBjbXB0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgICAgaWYgKHNlbGYuaGFzKGUpICYmIGNtcHQuaGFzKGUuc291cmNlKCkpICYmIGNtcHQuaGFzKGUudGFyZ2V0KCkpKSB7XG4gICAgICAgICAgICAvLyBoYXMoKSBpcyBjaGVhcFxuICAgICAgICAgICAgY21wdC5tZXJnZShlKTsgLy8gZm9yRWFjaCgpIG9ubHkgY29uc2lkZXJzIG5vZGVzIC0tIHNldHMgTiBhdCBjYWxsIHRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBkbyB7XG4gICAgICBfbG9vcCgpO1xuICAgIH0gd2hpbGUgKHVudmlzaXRlZC5sZW5ndGggPiAwKTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbiAgfSxcbiAgY29tcG9uZW50OiBmdW5jdGlvbiBjb21wb25lbnQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS5jeSgpLm11dGFibGVFbGVtZW50cygpLmNvbXBvbmVudHMoZWxlKVswXTtcbiAgfVxufSk7XG5lbGVzZm4kMi5jb21wb25lbnRzT2YgPSBlbGVzZm4kMi5jb21wb25lbnRzO1xuXG4vLyByZXByZXNlbnRzIGEgc2V0IG9mIG5vZGVzLCBlZGdlcywgb3IgYm90aCB0b2dldGhlclxudmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cykge1xuICB2YXIgdW5pcXVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIHJlbW92ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICBpZiAoY3kgPT09IHVuZGVmaW5lZCkge1xuICAgIGVycm9yKCdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXAgPSBuZXcgTWFwJDEoKTtcbiAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgZWxlbWVudHMgPSBbXTtcbiAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGggPiAwICYmIHBsYWluT2JqZWN0KGVsZW1lbnRzWzBdKSAmJiAhZWxlbWVudChlbGVtZW50c1swXSkpIHtcbiAgICBjcmVhdGVkRWxlbWVudHMgPSB0cnVlO1xuXG4gICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0gbmV3IFNldCQxKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBqc29uID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoanNvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAganNvbi5kYXRhID0ge307XG4gICAgICB9XG4gICAgICB2YXIgX2RhdGEgPSBqc29uLmRhdGE7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRzIGhhdmUgdmFsaWQgaWRzXG4gICAgICBpZiAoX2RhdGEuaWQgPT0gbnVsbCkge1xuICAgICAgICBfZGF0YS5pZCA9IHV1aWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY3kuaGFzRWxlbWVudFdpdGhJZChfZGF0YS5pZCkgfHwgZWxlc0lkcy5oYXMoX2RhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuICAgICAgdmFyIGVsZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7XG4gICAgICBlbGVzLnB1c2goZWxlKTtcbiAgICAgIGVsZXNJZHMuYWRkKF9kYXRhLmlkKTtcbiAgICB9XG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IGVsZW1lbnRzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgIHZhciBlbGVtZW50JDEgPSBlbGVtZW50c1tfaV1bMF07IC8vIFswXSBpbiBjYXNlIGVsZW1lbnRzIGlzIGFuIGFycmF5IG9mIGNvbGxlY3Rpb25zLCByYXRoZXIgdGhhbiBhcnJheSBvZiBlbGVtZW50c1xuICAgIGlmIChlbGVtZW50JDEgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpZCA9IGVsZW1lbnQkMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIGlmICghdW5pcXVlIHx8ICFtYXAuaGFzKGlkKSkge1xuICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgaW5kZXg6IHRoaXMubGVuZ3RoLFxuICAgICAgICAgIGVsZTogZWxlbWVudCQxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpc1t0aGlzLmxlbmd0aF0gPSBlbGVtZW50JDE7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGVsZXM6IHRoaXMsXG4gICAgY3k6IGN5LFxuICAgIGdldCBtYXAoKSB7XG4gICAgICBpZiAodGhpcy5sYXp5TWFwID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sYXp5TWFwO1xuICAgIH0sXG4gICAgc2V0IG1hcChtKSB7XG4gICAgICB0aGlzLmxhenlNYXAgPSBtO1xuICAgIH0sXG4gICAgcmVidWlsZE1hcDogZnVuY3Rpb24gcmVidWlsZE1hcCgpIHtcbiAgICAgIHZhciBtID0gdGhpcy5sYXp5TWFwID0gbmV3IE1hcCQxKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXMuZWxlcztcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX2VsZSA9IGVsZXNbX2kyXTtcbiAgICAgICAgbS5zZXQoX2VsZS5pZCgpLCB7XG4gICAgICAgICAgaW5kZXg6IF9pMixcbiAgICAgICAgICBlbGU6IF9lbGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAodW5pcXVlKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5tYXAgPSBtYXA7XG4gIH1cblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmIChjcmVhdGVkRWxlbWVudHMgJiYgIXJlbW92ZWQpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuJDEgPSBFbGVtZW50LnByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xuZWxlc2ZuJDEuaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnY29sbGVjdGlvbic7XG59O1xuZWxlc2ZuJDEuc3Bhd24gPSBmdW5jdGlvbiAoZWxlcywgdW5pcXVlKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXMsIHVuaXF1ZSk7XG59O1xuZWxlc2ZuJDEuc3Bhd25TZWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zcGF3bih0aGlzKTtcbn07XG5lbGVzZm4kMS5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuZWxlc2ZuJDEucmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmN5LnJlbmRlcmVyKCk7XG59O1xuZWxlc2ZuJDEuZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbMF07XG59O1xuZWxlc2ZuJDEuY29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbGxlY3Rpb24odGhpcykpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSk7XG4gIH1cbn07XG5lbGVzZm4kMS51bmlxdWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB0cnVlKTtcbn07XG5lbGVzZm4kMS5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuaGFzKGlkKTtcbn07XG5lbGVzZm4kMS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKTtcbiAgcmV0dXJuIGVudHJ5ID8gZW50cnkuZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5lbGVzZm4kMS4kaWQgPSBlbGVzZm4kMS5nZXRFbGVtZW50QnlJZDtcbmVsZXNmbiQxLnBvb2xJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgdmFyIGlkID0gdGhpc1swXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gZWxlcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5lbGVzZm4kMS5pbmRleE9mID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgaWQgPSBlbGVbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuZWxlc2ZuJDEuaW5kZXhPZklkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5lbGVzZm4kMS5qc29uID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgaWYgKGVsZSA9PSBudWxsICYmIG9iaikge1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cbiAgaWYgKGVsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSAvLyBjYW4ndCBnZXQgZnJvbSBubyBlbGVzXG5cbiAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG4gIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgLy8gc2V0XG5cbiAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICBlbGUuZGF0YShvYmouZGF0YSk7XG4gICAgICB2YXIgX2RhdGEyID0gcC5kYXRhO1xuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICAvLyBzb3VyY2UgYW5kIHRhcmdldCBhcmUgaW1tdXRhYmxlIHZpYSBkYXRhKClcbiAgICAgICAgdmFyIG1vdmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNwZWMgPSB7fTtcbiAgICAgICAgdmFyIHNyYyA9IG9iai5kYXRhLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IG9iai5kYXRhLnRhcmdldDtcbiAgICAgICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYyAhPSBfZGF0YTIuc291cmNlKSB7XG4gICAgICAgICAgc3BlYy5zb3VyY2UgPSAnJyArIHNyYzsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGd0ICE9IG51bGwgJiYgdGd0ICE9IF9kYXRhMi50YXJnZXQpIHtcbiAgICAgICAgICBzcGVjLnRhcmdldCA9ICcnICsgdGd0OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgZWxlID0gZWxlLm1vdmUoc3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgbmV3UGFyZW50VmFsU3BlY2QgPSAncGFyZW50JyBpbiBvYmouZGF0YTtcbiAgICAgICAgdmFyIHBhcmVudCA9IG9iai5kYXRhLnBhcmVudDtcbiAgICAgICAgaWYgKG5ld1BhcmVudFZhbFNwZWNkICYmIChwYXJlbnQgIT0gbnVsbCB8fCBfZGF0YTIucGFyZW50ICE9IG51bGwpICYmIHBhcmVudCAhPSBfZGF0YTIucGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjYW4ndCBzZXQgdW5kZWZpbmVkIGltcGVyYXRpdmVseSwgc28gdXNlIG51bGxcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50ID0gJycgKyBwYXJlbnQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZSA9IGVsZS5tb3ZlKHtcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iai5wb3NpdGlvbikge1xuICAgICAgZWxlLnBvc2l0aW9uKG9iai5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG4gICAgdmFyIGNoZWNrU3dpdGNoID0gZnVuY3Rpb24gY2hlY2tTd2l0Y2goaywgdHJ1ZUZuTmFtZSwgZmFsc2VGbk5hbWUpIHtcbiAgICAgIHZhciBvYmpfayA9IG9ialtrXTtcbiAgICAgIGlmIChvYmpfayAhPSBudWxsICYmIG9ial9rICE9PSBwW2tdKSB7XG4gICAgICAgIGlmIChvYmpfaykge1xuICAgICAgICAgIGVsZVt0cnVlRm5OYW1lXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVtmYWxzZUZuTmFtZV0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tTd2l0Y2goJ3JlbW92ZWQnLCAncmVtb3ZlJywgJ3Jlc3RvcmUnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGFibGUnLCAnc2VsZWN0aWZ5JywgJ3Vuc2VsZWN0aWZ5Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ2xvY2tlZCcsICdsb2NrJywgJ3VubG9jaycpO1xuICAgIGNoZWNrU3dpdGNoKCdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknKTtcbiAgICBjaGVja1N3aXRjaCgncGFubmFibGUnLCAncGFuaWZ5JywgJ3VucGFuaWZ5Jyk7XG4gICAgaWYgKG9iai5jbGFzc2VzICE9IG51bGwpIHtcbiAgICAgIGVsZS5jbGFzc2VzKG9iai5jbGFzc2VzKTtcbiAgICB9XG4gICAgY3kuZW5kQmF0Y2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGdldFxuXG4gICAgdmFyIGpzb24gPSB7XG4gICAgICBkYXRhOiBjb3B5KHAuZGF0YSksXG4gICAgICBwb3NpdGlvbjogY29weShwLnBvc2l0aW9uKSxcbiAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgcmVtb3ZlZDogcC5yZW1vdmVkLFxuICAgICAgc2VsZWN0ZWQ6IHAuc2VsZWN0ZWQsXG4gICAgICBzZWxlY3RhYmxlOiBwLnNlbGVjdGFibGUsXG4gICAgICBsb2NrZWQ6IHAubG9ja2VkLFxuICAgICAgZ3JhYmJhYmxlOiBwLmdyYWJiYWJsZSxcbiAgICAgIHBhbm5hYmxlOiBwLnBhbm5hYmxlLFxuICAgICAgY2xhc3NlczogbnVsbFxuICAgIH07XG4gICAganNvbi5jbGFzc2VzID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHAuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIHJldHVybiBqc29uLmNsYXNzZXMgKz0gaSsrID09PSAwID8gY2xzIDogJyAnICsgY2xzO1xuICAgIH0pO1xuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuZWxlc2ZuJDEuanNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBqc29ucyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAganNvbnMucHVzaChqc29uKTtcbiAgfVxuICByZXR1cm4ganNvbnM7XG59O1xuZWxlc2ZuJDEuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIGVsZXNBcnIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaChjbG9uZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVzQXJyKTtcbn07XG5lbGVzZm4kMS5jb3B5ID0gZWxlc2ZuJDEuY2xvbmU7XG5lbGVzZm4kMS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBhZGRUb1Bvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuXG4gIC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzO1xuICBmb3IgKHZhciBfaTMgPSAwLCBsID0gc2VsZi5sZW5ndGg7IF9pMyA8IGw7IF9pMysrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbX2kzXTtcbiAgICBpZiAoYWRkVG9Qb29sICYmICFlbGUucmVtb3ZlZCgpKSB7XG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVsZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9XG4gIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KGVkZ2VzKTtcbiAgdmFyIGk7XG4gIHZhciByZW1vdmVGcm9tRWxlbWVudHMgPSBmdW5jdGlvbiByZW1vdmVGcm9tRWxlbWVudHMoKSB7XG4gICAgZWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgIGktLTtcbiAgfTtcblxuICAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG4gIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZWxlMiA9IGVsZW1lbnRzW2ldO1xuICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUyLl9wcml2YXRlO1xuICAgIHZhciBfZGF0YTMgPSBfcHJpdmF0ZS5kYXRhO1xuXG4gICAgLy8gdGhlIHRyYXZlcnNhbCBjYWNoZSBzaG91bGQgc3RhcnQgZnJlc2ggd2hlbiBlbGUgaXMgYWRkZWRcbiAgICBfZWxlMi5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG5cbiAgICAvLyBzZXQgaWQgYW5kIHZhbGlkYXRlXG4gICAgaWYgKCFhZGRUb1Bvb2wgJiYgIV9wcml2YXRlLnJlbW92ZWQpIDsgZWxzZSBpZiAoX2RhdGEzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF9kYXRhMy5pZCA9IHV1aWQoKTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciQxKF9kYXRhMy5pZCkpIHtcbiAgICAgIF9kYXRhMy5pZCA9ICcnICsgX2RhdGEzLmlkOyAvLyBub3cgaXQncyBhIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAoZW1wdHlTdHJpbmcoX2RhdGEzLmlkKSB8fCAhc3RyaW5nKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlbGVtZW50IHdpdGggaW52YWxpZCBzdHJpbmcgSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTtcblxuICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpZCA9IF9kYXRhMy5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgaWYgKF9lbGUyLmlzTm9kZSgpKSB7XG4gICAgICAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgcG9zID0gX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgbm9kZXMgaGF2ZSBhIGRlZmluZWQgcG9zaXRpb25cblxuICAgICAgaWYgKHBvcy54ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2VsZTIuaXNFZGdlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcblxuICAgICAgdmFyIGVkZ2UgPSBfZWxlMjtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgICAgdmFyIHZhbCA9IF9kYXRhM1tmaWVsZF07XG4gICAgICAgIGlmIChudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgdmFsID0gX2RhdGEzW2ZpZWxkXSA9ICcnICsgX2RhdGEzW2ZpZWxkXTsgLy8gbm93IHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCB1bnNwZWNpZmllZCAnICsgZmllbGQpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghY3kuaGFzRWxlbWVudFdpdGhJZCh2YWwpKSB7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVkZ2UgaWYgb25lIG9mIGl0cyBub2RlcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYmFkU291cmNlT3JUYXJnZXQpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG4gICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoX2RhdGEzLnNvdXJjZSk7XG4gICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoX2RhdGEzLnRhcmdldCk7XG5cbiAgICAgIC8vIG9ubHkgb25lIGVkZ2UgaW4gbm9kZSBpZiBsb29wXG4gICAgICBpZiAoc3JjLnNhbWUodGd0KSkge1xuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cbiAgICAgIGVkZ2UuX3ByaXZhdGUuc291cmNlID0gc3JjO1xuICAgICAgZWRnZS5fcHJpdmF0ZS50YXJnZXQgPSB0Z3Q7XG4gICAgfSAvLyBpZiBpcyBlZGdlXG5cbiAgICAvLyBjcmVhdGUgbW9jayBpZHMgLyBpbmRleGVzIG1hcHMgZm9yIGVsZW1lbnQgc28gaXQgY2FuIGJlIHVzZWQgbGlrZSBjb2xsZWN0aW9uc1xuICAgIF9wcml2YXRlLm1hcCA9IG5ldyBNYXAkMSgpO1xuICAgIF9wcml2YXRlLm1hcC5zZXQoaWQsIHtcbiAgICAgIGVsZTogX2VsZTIsXG4gICAgICBpbmRleDogMFxuICAgIH0pO1xuICAgIF9wcml2YXRlLnJlbW92ZWQgPSBmYWxzZTtcbiAgICBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICBjeS5hZGRUb1Bvb2woX2VsZTIpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG5cbiAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAvLyBlYWNoIG5vZGVcbiAgICB2YXIgbm9kZSA9IG5vZGVzW19pNF07XG4gICAgdmFyIF9kYXRhNCA9IG5vZGUuX3ByaXZhdGUuZGF0YTtcbiAgICBpZiAobnVtYmVyJDEoX2RhdGE0LnBhcmVudCkpIHtcbiAgICAgIC8vIHRoZW4gYXV0b21ha2Ugc3RyaW5nXG4gICAgICBfZGF0YTQucGFyZW50ID0gJycgKyBfZGF0YTQucGFyZW50O1xuICAgIH1cbiAgICB2YXIgcGFyZW50SWQgPSBfZGF0YTQucGFyZW50O1xuICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuICAgIGlmIChzcGVjaWZpZWRQYXJlbnQgfHwgbm9kZS5fcHJpdmF0ZS5wYXJlbnQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLl9wcml2YXRlLnBhcmVudCA/IGN5LmNvbGxlY3Rpb24oKS5tZXJnZShub2RlLl9wcml2YXRlLnBhcmVudCkgOiBjeS5nZXRFbGVtZW50QnlJZChwYXJlbnRJZCk7XG4gICAgICBpZiAocGFyZW50LmVtcHR5KCkpIHtcbiAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50WzBdLnJlbW92ZWQoKSkge1xuICAgICAgICB3YXJuKCdOb2RlIGFkZGVkIHdpdGggbWlzc2luZyBwYXJlbnQsIHJlZmVyZW5jZSB0byBwYXJlbnQgcmVtb3ZlZCcpO1xuICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgICAgd2hpbGUgKCFhbmNlc3Rvci5lbXB0eSgpKSB7XG4gICAgICAgICAgaWYgKG5vZGUuc2FtZShhbmNlc3RvcikpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgc2VsZiBhcyBwYXJlbnQgYW5kIHJlbW92ZSBmcm9tIGRhdGFcbiAgICAgICAgICAgIHNlbGZBc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmQXNQYXJlbnQpIHtcbiAgICAgICAgICAvLyBjb25uZWN0IHdpdGggY2hpbGRyZW5cbiAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTtcblxuICAgICAgICAgIC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuICAgICAgICAgIGN5X3AuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZWxzZVxuICAgIH0gLy8gaWYgc3BlY2lmaWVkIHBhcmVudFxuICB9IC8vIGZvciBlYWNoIG5vZGVcblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciByZXN0b3JlZCA9IGVsZW1lbnRzLmxlbmd0aCA9PT0gc2VsZi5sZW5ndGggPyBzZWxmIDogbmV3IENvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCByZXN0b3JlZC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgX2VsZTMgPSByZXN0b3JlZFtfaTVdO1xuICAgICAgaWYgKF9lbGUzLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgICBfZWxlMy5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG4gICAgICBfZWxlMy5zb3VyY2UoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgICBfZWxlMy50YXJnZXQoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuICAgIHZhciB0b1VwZGF0ZVN0eWxlO1xuICAgIGlmIChjeV9wLmhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSBjeS5jb2xsZWN0aW9uKCkubWVyZ2UocmVzdG9yZWQpLm1lcmdlKHJlc3RvcmVkLmNvbm5lY3RlZE5vZGVzKCkpLm1lcmdlKHJlc3RvcmVkLnBhcmVudCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkO1xuICAgIH1cbiAgICB0b1VwZGF0ZVN0eWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpLnVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKTtcbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIHJlc3RvcmVkLmVtaXRBbmROb3RpZnkoJ2FkZCcpO1xuICAgIH0gZWxzZSBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICByZXN0b3JlZC5lbWl0KCdhZGQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7IC8vIGNoYWluYWJpbGl0eVxufTtcbmVsZXNmbiQxLnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmIGVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcbmVsZXNmbiQxLmluc2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcbmVsZXNmbiQxLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICB2YXIgcmVtb3ZlRnJvbVBvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVsZXNUb1JlbW92ZSA9IFtdO1xuICB2YXIgZWxlc1RvUmVtb3ZlSWRzID0ge307XG4gIHZhciBjeSA9IHNlbGYuX3ByaXZhdGUuY3k7XG5cbiAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKSB7XG4gICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoZWRnZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG4gIGZ1bmN0aW9uIGFkZENoaWxkcmVuKG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLl9wcml2YXRlLmNoaWxkcmVuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkZChlbGUpIHtcbiAgICB2YXIgYWxyZWFkeUFkZGVkID0gZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXTtcbiAgICBpZiAocmVtb3ZlRnJvbVBvb2wgJiYgZWxlLnJlbW92ZWQoKSB8fCBhbHJlYWR5QWRkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGVsZXNUb1JlbW92ZS5wdXNoKGVsZSk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoZWxlKTtcbiAgICAgIGFkZENoaWxkcmVuKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZS51bnNoaWZ0KGVsZSk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSB0aGUgbGlzdCBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgLy8gKG1heSBiZSByZW1vdmluZyBtb3JlIHRoYW4gc3BlY2lmaWVkIGR1ZSB0byBjb25uZWN0ZWQgZWRnZXMgZXRjKVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICBhZGQoZWxlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2UpIHtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIHJlbW92ZUZyb21BcnJheShjb25uZWN0ZWRFZGdlcywgZWRnZSk7XG5cbiAgICAvLyByZW1vdmluZyBhbiBlZGdlcyBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciBpdHMgbm9kZXNcbiAgICBub2RlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKSB7XG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgcGxsRWRnZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cbiAgdmFyIGFsdGVyZWRQYXJlbnRzID0gW107XG4gIGFsdGVyZWRQYXJlbnRzLmlkcyA9IHt9O1xuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSkge1xuICAgIGVsZSA9IGVsZVswXTtcbiAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuICAgIHZhciBwaWQgPSBwYXJlbnQuaWQoKTtcbiAgICByZW1vdmVGcm9tQXJyYXkoY2hpbGRyZW4sIGVsZSk7IC8vIHJlbW92ZSBwYXJlbnQgPT4gY2hpbGQgcmVmXG5cbiAgICBlbGUuX3ByaXZhdGUucGFyZW50ID0gbnVsbDsgLy8gcmVtb3ZlIGNoaWxkID0+IHBhcmVudCByZWZcblxuICAgIGlmICghYWx0ZXJlZFBhcmVudHMuaWRzW3BpZF0pIHtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLmlkc1twaWRdID0gdHJ1ZTtcbiAgICAgIGFsdGVyZWRQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cbiAgc2VsZi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgY3kucmVtb3ZlRnJvbVBvb2woZWxlc1RvUmVtb3ZlKTsgLy8gcmVtb3ZlIGZyb20gY29yZSBwb29sXG4gIH1cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgX2VsZTQgPSBlbGVzVG9SZW1vdmVbX2k2XTtcbiAgICBpZiAoX2VsZTQuaXNFZGdlKCkpIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICB2YXIgc3JjID0gX2VsZTQuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gX2VsZTQudGFyZ2V0KClbMF07XG4gICAgICByZW1vdmVFZGdlUmVmKHNyYywgX2VsZTQpO1xuICAgICAgcmVtb3ZlRWRnZVJlZih0Z3QsIF9lbGU0KTtcbiAgICAgIHZhciBwbGxFZGdlcyA9IF9lbGU0LnBhcmFsbGVsRWRnZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGxsRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHBsbEVkZ2UgPSBwbGxFZGdlc1tqXTtcbiAgICAgICAgcmVtb3ZlUGFyYWxsZWxSZWYocGxsRWRnZSk7XG4gICAgICAgIGlmIChwbGxFZGdlLmlzQnVuZGxlZEJlemllcigpKSB7XG4gICAgICAgICAgcGxsRWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IF9lbGU0LnBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBfZWxlNCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICBfZWxlNC5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgX2k3KyspIHtcbiAgICB2YXIgX2VsZTUgPSBlbGVzU3RpbGxJbnNpZGVbX2k3XTtcbiAgICBpZiAoX2VsZTUuaXNQYXJlbnQoKSkge1xuICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgZWxlc1RvUmVtb3ZlKTtcbiAgaWYgKHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwKSB7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG5cbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIHJlbW92ZWRFbGVtZW50cy5lbWl0QW5kTm90aWZ5KCdyZW1vdmUnKTtcbiAgICB9IGVsc2UgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdCgncmVtb3ZlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIHBhcmVudHMgd2hvIHdlcmUgbW9kaWZpZWQgYnkgdGhlIHJlbW92YWwgbmVlZCB0aGVpciBzdHlsZSB1cGRhdGVkXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k4KyspIHtcbiAgICB2YXIgX2VsZTYgPSBhbHRlcmVkUGFyZW50c1tfaThdO1xuICAgIGlmICghcmVtb3ZlRnJvbVBvb2wgfHwgIV9lbGU2LnJlbW92ZWQoKSkge1xuICAgICAgX2VsZTYudXBkYXRlU3R5bGUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW92ZWRFbGVtZW50cztcbn07XG5lbGVzZm4kMS5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgLy8ganVzdCBjbGVhbiB1cCByZWZzLCBjYWNoZXMsIGV0Yy4gaW4gdGhlIHNhbWUgd2F5IGFzIHdoZW4gcmVtb3ZpbmcgYW5kIHRoZW4gcmVzdG9yaW5nXG4gIC8vIChvdXIgY2FsbHMgdG8gcmVtb3ZlL3Jlc3RvcmUgZG8gbm90IHJlbW92ZSBmcm9tIHRoZSBncmFwaCBvciBtYWtlIGV2ZW50cylcbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gZmFsc2U7XG4gIHZhciBtb2RpZnlQb29sID0gZmFsc2U7XG4gIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGlkKSB7XG4gICAgcmV0dXJuIGlkID09IG51bGwgPyBpZCA6ICcnICsgaWQ7XG4gIH07IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgaWYgKHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3JjSWQgPSB0b1N0cmluZyhzdHJ1Y3Quc291cmNlKTtcbiAgICB2YXIgdGd0SWQgPSB0b1N0cmluZyhzdHJ1Y3QudGFyZ2V0KTtcbiAgICB2YXIgc3JjRXhpc3RzID0gc3JjSWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHNyY0lkKTtcbiAgICB2YXIgdGd0RXhpc3RzID0gdGd0SWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHRndElkKTtcbiAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuICAgICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmVvdXQnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNSA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmNFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRndEV4aXN0cykge1xuICAgICAgICAgICAgICBfZGF0YTUudGFyZ2V0ID0gdGd0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZXMucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcbiAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgIHZhciBwYXJlbnRJZCA9IHRvU3RyaW5nKHN0cnVjdC5wYXJlbnQpO1xuICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5oYXNFbGVtZW50V2l0aElkKHBhcmVudElkKTtcbiAgICBpZiAocGFyZW50RXhpc3RzKSB7XG4gICAgICB2YXIgcGlkVG9Bc3NpZ24gPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG4gICAgICAgIHVwZGF0ZWQuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICB2YXIgX2RhdGE2ID0gZWxlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgX2RhdGE2LnBhcmVudCA9IHBpZFRvQXNzaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgfSk7XG4gICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuW2VsZXNmbiRqLCBlbGVzZm4kaSwgZWxlc2ZuJGgsIGVsZXNmbiRnLCBlbGVzZm4kZiwgZGF0YSwgZWxlc2ZuJGQsIGRpbWVuc2lvbnMsIGVsZXNmbiQ5LCBlbGVzZm4kOCwgZWxlc2ZuJDcsIGVsZXNmbiQ2LCBlbGVzZm4kNSwgZWxlc2ZuJDQsIGVsZXNmbiQzLCBlbGVzZm4kMl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGVsZXNmbiQxLCBwcm9wcyk7XG59KTtcblxudmFyIGNvcmVmbiQ5ID0ge1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvcHRzKSB7XG4gICAgdmFyIGVsZW1lbnRzO1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAvLyBhZGQgdGhlIGVsZW1lbnRzXG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykpIHtcbiAgICAgIHZhciBlbGVzID0gb3B0cztcbiAgICAgIGlmIChlbGVzLl9wcml2YXRlLmN5ID09PSBjeSkge1xuICAgICAgICAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICBlbGVtZW50cyA9IGVsZXMucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICB2YXIganNvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAganNvbnMucHVzaChlbGUuanNvbigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiAoYXJyYXkob3B0cykpIHtcbiAgICAgIHZhciBfanNvbnMgPSBvcHRzO1xuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zKTtcbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgZWxzZSBpZiAocGxhaW5PYmplY3Qob3B0cykgJiYgKGFycmF5KG9wdHMubm9kZXMpIHx8IGFycmF5KG9wdHMuZWRnZXMpKSkge1xuICAgICAgdmFyIGVsZXNCeUdyb3VwID0gb3B0cztcbiAgICAgIHZhciBfanNvbnMyID0gW107XG4gICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbCA9IGdycy5sZW5ndGg7IF9pIDwgaWw7IF9pKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JzW19pXTtcbiAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwW2dyb3VwXTtcbiAgICAgICAgaWYgKGFycmF5KGVsZXNBcnJheSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBleHRlbmQoe1xuICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgIH0sIGVsZXNBcnJheVtqXSk7XG4gICAgICAgICAgICBfanNvbnMyLnB1c2goanNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBfanNvbnMyKTtcbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgZWxzZSB7XG4gICAgICB2YXIgX2pzb24gPSBvcHRzO1xuICAgICAgZWxlbWVudHMgPSBuZXcgRWxlbWVudChjeSwgX2pzb24pLmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikpIDsgZWxzZSBpZiAoc3RyaW5nKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuJChzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5cbi8qISBCZXppZXIgY3VydmUgZnVuY3Rpb24gZ2VuZXJhdG9yLiBDb3B5cmlnaHQgR2FldGFuIFJlbmF1ZGVhdS4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQsXG4gICAgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxLFxuICAgIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMSxcbiAgICBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwLFxuICAgIGtTcGxpbmVUYWJsZVNpemUgPSAxMSxcbiAgICBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCksXG4gICAgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgLyogTXVzdCBjb250YWluIGZvdXIgYXJndW1lbnRzLiAqL1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qIEFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMuICovXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oYXJndW1lbnRzW2ldKSB8fCAhaXNGaW5pdGUoYXJndW1lbnRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cbiAgbVgxID0gTWF0aC5taW4obVgxLCAxKTtcbiAgbVgyID0gTWF0aC5taW4obVgyLCAxKTtcbiAgbVgxID0gTWF0aC5tYXgobVgxLCAwKTtcbiAgbVgyID0gTWF0aC5tYXgobVgyLCAwKTtcbiAgdmFyIG1TYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcbiAgfVxuICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgfVxuICBmdW5jdGlvbiBDKGFBMSkge1xuICAgIHJldHVybiAzLjAgKiBhQTE7XG4gIH1cbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGFHdWVzc1QpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTkVXVE9OX0lURVJBVElPTlM7ICsrX2kpIHtcbiAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICB9XG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cbiAgZnVuY3Rpb24gY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrU3BsaW5lVGFibGVTaXplOyArK19pMikge1xuICAgICAgbVNhbXBsZVZhbHVlc1tfaTJdID0gY2FsY0JlemllcihfaTIgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIpIHtcbiAgICB2YXIgY3VycmVudFgsXG4gICAgICBjdXJyZW50VCxcbiAgICAgIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjAsXG4gICAgICBjdXJyZW50U2FtcGxlID0gMSxcbiAgICAgIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pLFxuICAgICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemUsXG4gICAgICBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplKTtcbiAgICB9XG4gIH1cbiAgdmFyIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAgIF9wcmVjb21wdXRlZCA9IHRydWU7XG4gICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgfVxuICB9XG4gIHZhciBmID0gZnVuY3Rpb24gZihhWCkge1xuICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG4gICAgICBwcmVjb21wdXRlKCk7XG4gICAgfVxuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgcmV0dXJuIGFYO1xuICAgIH1cbiAgICBpZiAoYVggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoYVggPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcbiAgfTtcbiAgZi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbe1xuICAgICAgeDogbVgxLFxuICAgICAgeTogbVkxXG4gICAgfSwge1xuICAgICAgeDogbVgyLFxuICAgICAgeTogbVkyXG4gICAgfV07XG4gIH07XG4gIHZhciBzdHIgPSBcImdlbmVyYXRlQmV6aWVyKFwiICsgW21YMSwgbVkxLCBtWDIsIG1ZMl0gKyBcIilcIjtcbiAgZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICByZXR1cm4gZjtcbn1cblxuLyohIFJ1bmdlLUt1dHRhIHNwcmluZyBwaHlzaWNzIGZ1bmN0aW9uIGdlbmVyYXRvci4gQWRhcHRlZCBmcm9tIEZyYW1lci5qcywgY29weXJpZ2h0IEtvZW4gQm9rLiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xudmFyIGdlbmVyYXRlU3ByaW5nUks0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiAtc3RhdGUudGVuc2lvbiAqIHN0YXRlLnggLSBzdGF0ZS5mcmljdGlvbiAqIHN0YXRlLnY7XG4gIH1cbiAgZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgIHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuICAgICAgdGVuc2lvbjogaW5pdGlhbFN0YXRlLnRlbnNpb24sXG4gICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShzdGF0ZSwgZHQpIHtcbiAgICB2YXIgYSA9IHtcbiAgICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICAgIH0sXG4gICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICBjID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYiksXG4gICAgICBkID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCwgYyksXG4gICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICBkdmR0ID0gMS4wIC8gNi4wICogKGEuZHYgKyAyLjAgKiAoYi5kdiArIGMuZHYpICsgZC5kdik7XG4gICAgc3RhdGUueCA9IHN0YXRlLnggKyBkeGR0ICogZHQ7XG4gICAgc3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBzcHJpbmdSSzRGYWN0b3J5KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgIHZhciBpbml0U3RhdGUgPSB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB2OiAwLFxuICAgICAgICB0ZW5zaW9uOiBudWxsLFxuICAgICAgICBmcmljdGlvbjogbnVsbFxuICAgICAgfSxcbiAgICAgIHBhdGggPSBbMF0sXG4gICAgICB0aW1lX2xhcHNlZCA9IDAsXG4gICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICBEVCA9IDE2IC8gMTAwMCxcbiAgICAgIGhhdmVfZHVyYXRpb24sXG4gICAgICBkdCxcbiAgICAgIGxhc3Rfc3RhdGU7XG4gICAgdGVuc2lvbiA9IHBhcnNlRmxvYXQodGVuc2lvbikgfHwgNTAwO1xuICAgIGZyaWN0aW9uID0gcGFyc2VGbG9hdChmcmljdGlvbikgfHwgMjA7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBudWxsO1xuICAgIGluaXRTdGF0ZS50ZW5zaW9uID0gdGVuc2lvbjtcbiAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICBoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG5cbiAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuICAgIGlmIChoYXZlX2R1cmF0aW9uKSB7XG4gICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgdGltZV9sYXBzZWQgPSBzcHJpbmdSSzRGYWN0b3J5KHRlbnNpb24sIGZyaWN0aW9uKTtcbiAgICAgIC8qIENvbXB1dGUgdGhlIGFkanVzdGVkIHRpbWUgZGVsdGEuICovXG4gICAgICBkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHQgPSBEVDtcbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgLyogTmV4dC9zdGVwIGZ1bmN0aW9uIC4qL1xuICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAvKiBTdG9yZSB0aGUgcG9zaXRpb24uICovXG4gICAgICBwYXRoLnB1c2goMSArIGxhc3Rfc3RhdGUueCk7XG4gICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgIC8qIElmIHRoZSBjaGFuZ2UgdGhyZXNob2xkIGlzIHJlYWNoZWQsIGJyZWFrLiAqL1xuICAgICAgaWYgKCEoTWF0aC5hYnMobGFzdF9zdGF0ZS54KSA+IHRvbGVyYW5jZSAmJiBNYXRoLmFicyhsYXN0X3N0YXRlLnYpID4gdG9sZXJhbmNlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJZiBkdXJhdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHRoZSBhY3R1YWwgdGltZSByZXF1aXJlZCBmb3IgY29tcGxldGluZyB0aGlzIGFuaW1hdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBjbG9zdXJlIHRoYXQgaG9sZHMgdGhlXG4gICAgICAgY29tcHV0ZWQgcGF0aCBhbmQgcmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gYSBnaXZlbiBwZXJjZW50Q29tcGxldGUuICovXG4gICAgcmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbiAocGVyY2VudENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gcGF0aFtwZXJjZW50Q29tcGxldGUgKiAocGF0aC5sZW5ndGggLSAxKSB8IDBdO1xuICAgIH07XG4gIH07XG59KCk7XG5cbnZhciBjdWJpY0JlemllciA9IGZ1bmN0aW9uIGN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKSB7XG4gIHZhciBiZXppZXIgPSBnZW5lcmF0ZUN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGJlemllcihwZXJjZW50KTtcbiAgfTtcbn07XG52YXIgZWFzaW5ncyA9IHtcbiAgJ2xpbmVhcic6IGZ1bmN0aW9uIGxpbmVhcihzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gIH0sXG4gIC8vIGRlZmF1bHQgZWFzaW5nc1xuICAnZWFzZSc6IGN1YmljQmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMSksXG4gICdlYXNlLWluJzogY3ViaWNCZXppZXIoMC40MiwgMCwgMSwgMSksXG4gICdlYXNlLW91dCc6IGN1YmljQmV6aWVyKDAsIDAsIDAuNTgsIDEpLFxuICAnZWFzZS1pbi1vdXQnOiBjdWJpY0JlemllcigwLjQyLCAwLCAwLjU4LCAxKSxcbiAgLy8gc2luZVxuICAnZWFzZS1pbi1zaW5lJzogY3ViaWNCZXppZXIoMC40NywgMCwgMC43NDUsIDAuNzE1KSxcbiAgJ2Vhc2Utb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjM5LCAwLjU3NSwgMC41NjUsIDEpLFxuICAnZWFzZS1pbi1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1KSxcbiAgLy8gcXVhZFxuICAnZWFzZS1pbi1xdWFkJzogY3ViaWNCZXppZXIoMC41NSwgMC4wODUsIDAuNjgsIDAuNTMpLFxuICAnZWFzZS1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpLFxuICAnZWFzZS1pbi1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUpLFxuICAvLyBjdWJpY1xuICAnZWFzZS1pbi1jdWJpYyc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSksXG4gICdlYXNlLW91dC1jdWJpYyc6IGN1YmljQmV6aWVyKDAuMjE1LCAwLjYxLCAwLjM1NSwgMSksXG4gICdlYXNlLWluLW91dC1jdWJpYyc6IGN1YmljQmV6aWVyKDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEpLFxuICAvLyBxdWFydFxuICAnZWFzZS1pbi1xdWFydCc6IGN1YmljQmV6aWVyKDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiksXG4gICdlYXNlLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuMTY1LCAwLjg0LCAwLjQ0LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC43NywgMCwgMC4xNzUsIDEpLFxuICAvLyBxdWludFxuICAnZWFzZS1pbi1xdWludCc6IGN1YmljQmV6aWVyKDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiksXG4gICdlYXNlLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpLFxuICAnZWFzZS1pbi1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjg2LCAwLCAwLjA3LCAxKSxcbiAgLy8gZXhwb1xuICAnZWFzZS1pbi1leHBvJzogY3ViaWNCZXppZXIoMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1KSxcbiAgJ2Vhc2Utb3V0LWV4cG8nOiBjdWJpY0JlemllcigwLjE5LCAxLCAwLjIyLCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWV4cG8nOiBjdWJpY0JlemllcigxLCAwLCAwLCAxKSxcbiAgLy8gY2lyY1xuICAnZWFzZS1pbi1jaXJjJzogY3ViaWNCZXppZXIoMC42LCAwLjA0LCAwLjk4LCAwLjMzNSksXG4gICdlYXNlLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC4wNzUsIDAuODIsIDAuMTY1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYpLFxuICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cblxuICAnc3ByaW5nJzogZnVuY3Rpb24gc3ByaW5nKHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gY2FuJ3QgZ2V0IGEgc3ByaW5nIHcvIGR1cmF0aW9uIDBcbiAgICAgIHJldHVybiBlYXNpbmdzLmxpbmVhcjsgLy8gZHVyYXRpb24gMCA9PiBqdW1wIHRvIGVuZCBzbyBpbXBsIGRvZXNuJ3QgbWF0dGVyXG4gICAgfVxuICAgIHZhciBzcHJpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNCh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgcGVyY2VudCkge1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHNwcmluZyhwZXJjZW50KTtcbiAgICB9O1xuICB9LFxuICAnY3ViaWMtYmV6aWVyJzogY3ViaWNCZXppZXJcbn07XG5cbmZ1bmN0aW9uIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pIHtcbiAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgcmV0dXJuIGVuZDtcbiAgfVxuICB2YXIgdmFsID0gZWFzaW5nRm4oc3RhcnQsIGVuZCwgcGVyY2VudCk7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh0eXBlLnJvdW5kVmFsdWUgfHwgdHlwZS5jb2xvcikge1xuICAgIHZhbCA9IE1hdGgucm91bmQodmFsKTtcbiAgfVxuICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IE1hdGgubWF4KHZhbCwgdHlwZS5taW4pO1xuICB9XG4gIGlmICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gTWF0aC5taW4odmFsLCB0eXBlLm1heCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKHByb3AsIHNwZWMpIHtcbiAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHByb3AudmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCAmJiAoc3BlYyA9PSBudWxsIHx8IHNwZWMudHlwZS51bml0cyAhPT0gJyUnKSkge1xuICAgICAgcmV0dXJuIHByb3AucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3AudmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59XG5mdW5jdGlvbiBlYXNlKHN0YXJ0UHJvcCwgZW5kUHJvcCwgcGVyY2VudCwgZWFzaW5nRm4sIHByb3BTcGVjKSB7XG4gIHZhciB0eXBlID0gcHJvcFNwZWMgIT0gbnVsbCA/IHByb3BTcGVjLnR5cGUgOiBudWxsO1xuICBpZiAocGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG4gIHZhciBzdGFydCA9IGdldFZhbHVlKHN0YXJ0UHJvcCwgcHJvcFNwZWMpO1xuICB2YXIgZW5kID0gZ2V0VmFsdWUoZW5kUHJvcCwgcHJvcFNwZWMpO1xuICBpZiAobnVtYmVyJDEoc3RhcnQpICYmIG51bWJlciQxKGVuZCkpIHtcbiAgICByZXR1cm4gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gIH0gZWxzZSBpZiAoYXJyYXkoc3RhcnQpICYmIGFycmF5KGVuZCkpIHtcbiAgICB2YXIgZWFzZWRBcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNpID0gc3RhcnRbaV07XG4gICAgICB2YXIgZWkgPSBlbmRbaV07XG4gICAgICBpZiAoc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB2YWwgPSBnZXRFYXNlZFZhbHVlKHR5cGUsIHNpLCBlaSwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICAgICAgICBlYXNlZEFyci5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYXNlZEFyci5wdXNoKGVpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVhc2VkQXJyO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0ZXAkMShzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gIHZhciBwRWFzaW5nID0gYW5pX3AuZWFzaW5nO1xuICB2YXIgc3RhcnRUaW1lID0gYW5pX3Auc3RhcnRUaW1lO1xuICB2YXIgY3kgPSBpc0NvcmUgPyBzZWxmIDogc2VsZi5jeSgpO1xuICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICBpZiAoIWFuaV9wLmVhc2luZ0ltcGwpIHtcbiAgICBpZiAocEVhc2luZyA9PSBudWxsKSB7XG4gICAgICAvLyB1c2UgZGVmYXVsdFxuICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGRlZmluZSB3LyBuYW1lXG4gICAgICB2YXIgZWFzaW5nVmFscztcbiAgICAgIGlmIChzdHJpbmcocEVhc2luZykpIHtcbiAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCBwRWFzaW5nKTtcbiAgICAgICAgZWFzaW5nVmFscyA9IGVhc2luZ1Byb3AudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIGFzc3VtZSBwcmVwYXJzZWQgYXJyYXlcbiAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmFtZSwgYXJncztcbiAgICAgIGlmIChzdHJpbmcoZWFzaW5nVmFscykpIHtcbiAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHM7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzWzFdO1xuICAgICAgICBhcmdzID0gZWFzaW5nVmFscy5zbGljZSgyKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gK247XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBjcmVhdGUgd2l0aCBhcmdzXG4gICAgICAgIGlmIChuYW1lID09PSAnc3ByaW5nJykge1xuICAgICAgICAgIGFyZ3MucHVzaChhbmlfcC5kdXJhdGlvbik7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgIH1cbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdGF0aWMgaW1wbCBieSBuYW1lXG4gICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZWFzaW5nID0gYW5pX3AuZWFzaW5nSW1wbDtcbiAgdmFyIHBlcmNlbnQ7XG4gIGlmIChhbmlfcC5kdXJhdGlvbiA9PT0gMCkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9IGVsc2Uge1xuICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICB9XG4gIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgIHBlcmNlbnQgPSBhbmlfcC5wcm9ncmVzcztcbiAgfVxuICBpZiAocGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG4gIGlmIChhbmlfcC5kZWxheSA9PSBudWxsKSB7XG4gICAgLy8gdGhlbiB1cGRhdGVcblxuICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGVuZFBvcyA9IGFuaV9wLnBvc2l0aW9uO1xuICAgIGlmIChlbmRQb3MgJiYgaXNFbGVzICYmICFzZWxmLmxvY2tlZCgpKSB7XG4gICAgICB2YXIgbmV3UG9zID0ge307XG4gICAgICBpZiAodmFsaWQoc3RhcnRQb3MueCwgZW5kUG9zLngpKSB7XG4gICAgICAgIG5ld1Bvcy54ID0gZWFzZShzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy55LCBlbmRQb3MueSkpIHtcbiAgICAgICAgbmV3UG9zLnkgPSBlYXNlKHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuICAgICAgc2VsZi5wb3NpdGlvbihuZXdQb3MpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbjtcbiAgICB2YXIgZW5kUGFuID0gYW5pX3AucGFuO1xuICAgIHZhciBwYW4gPSBfcC5wYW47XG4gICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcbiAgICBpZiAoYW5pbWF0aW5nUGFuKSB7XG4gICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueCwgZW5kUGFuLngpKSB7XG4gICAgICAgIHBhbi54ID0gZWFzZShzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZChzdGFydFBhbi55LCBlbmRQYW4ueSkpIHtcbiAgICAgICAgcGFuLnkgPSBlYXNlKHN0YXJ0UGFuLnksIGVuZFBhbi55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdwYW4nKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbTtcbiAgICB2YXIgZW5kWm9vbSA9IGFuaV9wLnpvb207XG4gICAgdmFyIGFuaW1hdGluZ1pvb20gPSBlbmRab29tICE9IG51bGwgJiYgaXNDb3JlO1xuICAgIGlmIChhbmltYXRpbmdab29tKSB7XG4gICAgICBpZiAodmFsaWQoc3RhcnRab29tLCBlbmRab29tKSkge1xuICAgICAgICBfcC56b29tID0gYm91bmQoX3AubWluWm9vbSwgZWFzZShzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQsIGVhc2luZyksIF9wLm1heFpvb20pO1xuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCd6b29tJyk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSkge1xuICAgICAgc2VsZi5lbWl0KCd2aWV3cG9ydCcpO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSBhbmlfcC5zdHlsZTtcbiAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoID4gMCAmJiBpc0VsZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgZW5kID0gcHJvcDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gYW5pX3Auc3RhcnRTdHlsZVtfbmFtZV07XG4gICAgICAgIHZhciBwcm9wU3BlYyA9IHN0eWxlLnByb3BlcnRpZXNbc3RhcnQubmFtZV07XG4gICAgICAgIHZhciBlYXNlZFZhbCA9IGVhc2Uoc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nLCBwcm9wU3BlYyk7XG4gICAgICAgIHN0eWxlLm92ZXJyaWRlQnlwYXNzKHNlbGYsIF9uYW1lLCBlYXNlZFZhbCk7XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBzZWxmLmVtaXQoJ3N0eWxlJyk7XG4gICAgfSAvLyBpZlxuICB9XG4gIGFuaV9wLnByb2dyZXNzID0gcGVyY2VudDtcbiAgcmV0dXJuIHBlcmNlbnQ7XG59XG5mdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChudW1iZXIkMShzdGFydCkgJiYgbnVtYmVyJDEoZW5kKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gIGFuaV9wLnN0YXJ0ZWQgPSB0cnVlO1xuICBhbmlfcC5zdGFydFRpbWUgPSBub3cgLSBhbmlfcC5wcm9ncmVzcyAqIGFuaV9wLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBzdGVwQWxsKG5vdywgY3kpIHtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5hbmlFbGVzO1xuICB2YXIgZG9uZUVsZXMgPSBbXTtcbiAgZnVuY3Rpb24gc3RlcE9uZShlbGUsIGlzQ29yZSkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3VycmVudCA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgIHZhciBxdWV1ZSA9IF9wLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICB2YXIgcmFuQW5pcyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG4gICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYWxsYmFja3MgPSBmdW5jdGlvbiBjYWxsYmFja3MoX2NhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IF9jYWxsYmFja3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGNiID0gX2NhbGxiYWNrc1tqXTtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICAgIF9jYWxsYmFja3Muc3BsaWNlKDAsIF9jYWxsYmFja3MubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgLy8gc3RlcCBhbmQgcmVtb3ZlIGlmIGRvbmVcbiAgICBmb3IgKHZhciBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbaV07XG4gICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gICAgICBpZiAoYW5pX3Auc3RvcHBlZCkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFuaV9wLnBsYXlpbmcgJiYgIWFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhbiBhcHBseSgpIHdoaWxlIHBsYXlpbmcgc2hvdWxkbid0IGRvIGFueXRoaW5nXG4gICAgICBpZiAoYW5pX3AucGxheWluZyAmJiBhbmlfcC5hcHBseWluZykge1xuICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFhbmlfcC5zdGFydGVkKSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKGVsZSwgYW5pLCBub3cpO1xuICAgICAgfVxuICAgICAgc3RlcCQxKGVsZSwgYW5pLCBub3csIGlzQ29yZSk7XG4gICAgICBpZiAoYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcyhhbmlfcC5mcmFtZXMpO1xuICAgICAgaWYgKGFuaV9wLnN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBhbmlfcC5zdGVwKG5vdyk7XG4gICAgICB9XG4gICAgICBpZiAoYW5pLmNvbXBsZXRlZCgpKSB7XG4gICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrcyhhbmlfcC5jb21wbGV0ZXMpO1xuICAgICAgfVxuICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNDb3JlICYmIGN1cnJlbnQubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZG9uZUVsZXMucHVzaChlbGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuQW5pcztcbiAgfSAvLyBzdGVwRWxlbWVudFxuXG4gIC8vIGhhbmRsZSBhbGwgZWxlc1xuICB2YXIgcmFuRWxlQW5pID0gZmFsc2U7XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IHN0ZXBPbmUoZWxlKTtcbiAgICByYW5FbGVBbmkgPSByYW5FbGVBbmkgfHwgaGFuZGxlZFRoaXNFbGU7XG4gIH0gLy8gZWFjaCBlbGVtZW50XG5cbiAgdmFyIHJhbkNvcmVBbmkgPSBzdGVwT25lKGN5LCB0cnVlKTtcblxuICAvLyBub3RpZnkgcmVuZGVyZXJcbiAgaWYgKHJhbkVsZUFuaSB8fCByYW5Db3JlQW5pKSB7XG4gICAgaWYgKGVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY3kubm90aWZ5KCdkcmF3JywgZWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuICBlbGVzLnVubWVyZ2UoZG9uZUVsZXMpO1xuICBjeS5lbWl0KCdzdGVwJyk7XG59IC8vIHN0ZXBBbGxcblxudmFyIGNvcmVmbiQ4ID0ge1xuICAvLyBwdWxsIGluIGFuaW1hdGlvbiBmdW5jdGlvbnNcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKCksXG4gIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24gYWRkVG9BbmltYXRpb25Qb29sKGVsZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgY3kuX3ByaXZhdGUuYW5pRWxlcy5tZXJnZShlbGVzKTtcbiAgfSxcbiAgc3RvcEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0b3BBbmltYXRpb25Mb29wKCkge1xuICAgIHRoaXMuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSBmYWxzZTtcbiAgfSxcbiAgc3RhcnRBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdGFydEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IHRydWU7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICAvLyBOQiB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBleGVjIGluIGhlYWRsZXNzIGVudmlyb25tZW50cyBpZiBzdHlsZSBlbmFibGVkXG4gICAgLy8gYW5kIGV4cGxpY2l0IGN5LmRlc3Ryb3koKSBpcyBuZWNlc3NhcnkgdG8gc3RvcCB0aGUgbG9vcFxuXG4gICAgZnVuY3Rpb24gaGVhZGxlc3NTdGVwKCkge1xuICAgICAgaWYgKCFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0aW9uU3RlcChub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgICAgaGVhZGxlc3NTdGVwKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgICBpZiAocmVuZGVyZXIgJiYgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKSB7XG4gICAgICAvLyBsZXQgdGhlIHJlbmRlcmVyIHNjaGVkdWxlIGFuaW1hdGlvbnNcbiAgICAgIHJlbmRlcmVyLmJlZm9yZVJlbmRlcihmdW5jdGlvbiByZW5kZXJlckFuaW1hdGlvblN0ZXAod2lsbERyYXcsIG5vdykge1xuICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgfSwgcmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5hbmltYXRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbWFuYWdlIHRoZSBhbmltYXRpb24gbG9vcCBvdXJzZWx2ZXNcbiAgICAgIGhlYWRsZXNzU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgfVxuICB9XG59O1xuXG52YXIgZW1pdHRlck9wdGlvbnMgPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgIH1cbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcbiAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGN5ICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhjeSwgZXZ0KSB7XG4gICAgZXZ0LmN5ID0gY3k7XG4gICAgZXZ0LnRhcmdldCA9IGN5O1xuICB9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLnF1YWxpZmllciAhPSBudWxsID8gZXZlbnRPYmoudGFyZ2V0IDogY3k7XG4gIH1cbn07XG52YXIgYXJnU2VsZWN0b3IgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn07XG52YXIgZWxlc2ZuID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKCFfcC5lbWl0dGVyKSB7XG4gICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBlbGVzKSB7XG4gICAgdGhpcy5lbWl0KGV2ZW50KTtcbiAgICB0aGlzLm5vdGlmeShldmVudCwgZWxlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuKTtcblxudmFyIGNvcmVmbiQ3ID0ge1xuICBwbmc6IGZ1bmN0aW9uIHBuZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcmVuZGVyZXIucG5nKG9wdGlvbnMpO1xuICB9LFxuICBqcGc6IGZ1bmN0aW9uIGpwZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyhvcHRpb25zKTtcbiAgfVxufTtcbmNvcmVmbiQ3LmpwZWcgPSBjb3JlZm4kNy5qcGc7XG5cbnZhciBjb3JlZm4kNiA9IHtcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0xheW91dCBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBgbmFtZWAgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcbiAgICBpZiAoTGF5b3V0ID09IG51bGwpIHtcbiAgICAgIGVycm9yKCdObyBzdWNoIGxheW91dCBgJyArIG5hbWUgKyAnYCBmb3VuZC4gIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCBpdCBhbmQgYGN5dG9zY2FwZS51c2UoKWAgaXQ/Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbGVzO1xuICAgIGlmIChzdHJpbmcob3B0aW9ucy5lbGVzKSkge1xuICAgICAgZWxlcyA9IGN5LiQob3B0aW9ucy5lbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cbiAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGVsZXM6IGVsZXNcbiAgICB9KSk7XG4gICAgcmV0dXJuIGxheW91dDtcbiAgfVxufTtcbmNvcmVmbiQ2LmNyZWF0ZUxheW91dCA9IGNvcmVmbiQ2Lm1ha2VMYXlvdXQgPSBjb3JlZm4kNi5sYXlvdXQ7XG5cbnZhciBjb3JlZm4kNSA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmICh0aGlzLmJhdGNoaW5nKCkpIHtcbiAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IF9wLmJhdGNoTm90aWZpY2F0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBlbGVzID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXSB8fCB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIGlmIChldmVudEVsZXMgIT0gbnVsbCkge1xuICAgICAgICBlbGVzLm1lcmdlKGV2ZW50RWxlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm47IC8vIG5vdGlmaWNhdGlvbnMgYXJlIGRpc2FibGVkIGR1cmluZyBiYXRjaGluZ1xuICAgIH1cbiAgICBpZiAoIV9wLm5vdGlmaWNhdGlvbnNFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG5cbiAgICAvLyBleGl0IGlmIGRlc3Ryb3koKSBjYWxsZWQgb24gY29yZSBvciByZW5kZXJlciBpbiBiZXR3ZWVuIGZyYW1lcyAjMTQ5OSAjMTUyOFxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCgpIHx8ICFyZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpO1xuICB9LFxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiBub3RpZmljYXRpb25zKGJvb2wpIHtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHAubm90aWZpY2F0aW9uc0VuYWJsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAubm90aWZpY2F0aW9uc0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiBub05vdGlmaWNhdGlvbnMoY2FsbGJhY2spIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICB9LFxuICBiYXRjaGluZzogZnVuY3Rpb24gYmF0Y2hpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYmF0Y2hDb3VudCA+IDA7XG4gIH0sXG4gIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmRCYXRjaDogZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9wLmJhdGNoQ291bnQtLTtcbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy51cGRhdGVTdHlsZSgpO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuXG4gICAgICAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuICAgICAgT2JqZWN0LmtleXMoX3AuYmF0Y2hOb3RpZmljYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgdmFyIGVsZXMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXTtcbiAgICAgICAgaWYgKGVsZXMuZW1wdHkoKSkge1xuICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGVsZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGJhdGNoOiBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgYmF0Y2hEYXRhOiBmdW5jdGlvbiBiYXRjaERhdGEobWFwKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXBbaWRdO1xuICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICBlbGUuZGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxudmFyIHJlbmRlcmVyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgaGlkZUVkZ2VzT25WaWV3cG9ydDogZmFsc2UsXG4gIHRleHR1cmVPblZpZXdwb3J0OiBmYWxzZSxcbiAgbW90aW9uQmx1cjogZmFsc2UsXG4gIG1vdGlvbkJsdXJPcGFjaXR5OiAwLjA1LFxuICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IDQsXG4gIHRvdWNoVGFwVGhyZXNob2xkOiA4LFxuICB3aGVlbFNlbnNpdGl2aXR5OiAxLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHNob3dGcHM6IGZhbHNlLFxuICAvLyB3ZWJnbCBvcHRpb25zXG4gIHdlYmdsOiBmYWxzZSxcbiAgd2ViZ2xEZWJ1ZzogZmFsc2UsXG4gIHdlYmdsRGVidWdTaG93QXRsYXNlczogZmFsc2UsXG4gIC8vIGRlZmF1bHRzIGdvb2QgZm9yIG1vYmlsZVxuICB3ZWJnbFRleFNpemU6IDIwNDgsXG4gIHdlYmdsVGV4Um93czogMzYsXG4gIHdlYmdsVGV4Um93c05vZGVzOiAxOCxcbiAgd2ViZ2xCYXRjaFNpemU6IDIwNDgsXG4gIHdlYmdsVGV4UGVyQmF0Y2g6IDE0LFxuICB3ZWJnbEJnQ29sb3I6IFsyNTUsIDI1NSwgMjU1XVxufSk7XG52YXIgY29yZWZuJDQgPSB7XG4gIHJlbmRlclRvOiBmdW5jdGlvbiByZW5kZXJUbyhjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8pIHtcbiAgICB2YXIgciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgci5yZW5kZXJUbyhjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW5kZXJlcjogZnVuY3Rpb24gcmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gIH0sXG4gIGZvcmNlUmVuZGVyOiBmdW5jdGlvbiBmb3JjZVJlbmRlcigpIHtcbiAgICB0aGlzLm5vdGlmeSgnZHJhdycpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICB0aGlzLmludmFsaWRhdGVTaXplKCk7XG4gICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdyZXNpemUnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiBpbml0UmVuZGVyZXIob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIFJlbmRlcmVyUHJvdG8gPSBjeS5leHRlbnNpb24oJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lKTtcbiAgICBpZiAoUmVuZGVyZXJQcm90byA9PSBudWxsKSB7XG4gICAgICBlcnJvcihcIkNhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgXCIuY29uY2F0KG9wdGlvbnMubmFtZSwgXCJgIGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0P1wiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybihcIllvdSBoYXZlIHNldCBhIGN1c3RvbSB3aGVlbCBzZW5zaXRpdml0eS4gIFRoaXMgd2lsbCBtYWtlIHlvdXIgYXBwIHpvb20gdW5uYXR1cmFsbHkgd2hlbiB1c2luZyBtYWluc3RyZWFtIG1pY2UuICBZb3Ugc2hvdWxkIGNoYW5nZSB0aGlzIHZhbHVlIGZyb20gdGhlIGRlZmF1bHQgb25seSBpZiB5b3UgY2FuIGd1YXJhbnRlZSB0aGF0IGFsbCB5b3VyIHVzZXJzIHdpbGwgdXNlIHRoZSBzYW1lIGhhcmR3YXJlIGFuZCBPUyBjb25maWd1cmF0aW9uIGFzIHlvdXIgY3VycmVudCBtYWNoaW5lLlwiKTtcbiAgICB9XG4gICAgdmFyIHJPcHRzID0gcmVuZGVyZXJEZWZhdWx0cyhvcHRpb25zKTtcbiAgICByT3B0cy5jeSA9IGN5O1xuICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyUHJvdG8ock9wdHMpO1xuICAgIHRoaXMubm90aWZ5KCdpbml0Jyk7XG4gIH0sXG4gIGRlc3Ryb3lSZW5kZXJlcjogZnVuY3Rpb24gZGVzdHJveVJlbmRlcmVyKCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kubm90aWZ5KCdkZXN0cm95Jyk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICB2YXIgZG9tRWxlID0gY3kuY29udGFpbmVyKCk7XG4gICAgaWYgKGRvbUVsZSkge1xuICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG4gICAgICB3aGlsZSAoZG9tRWxlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkb21FbGUucmVtb3ZlQ2hpbGQoZG9tRWxlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG51bGw7IC8vIHRvIGJlIGV4dHJhIHNhZmUsIHJlbW92ZSB0aGUgcmVmXG4gICAgY3kubXV0YWJsZUVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBfcC5yc2NyYXRjaCA9IHt9O1xuICAgICAgX3AucnN0eWxlID0ge307XG4gICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgfSk7XG4gIH0sXG4gIG9uUmVuZGVyOiBmdW5jdGlvbiBvblJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gIH0sXG4gIG9mZlJlbmRlcjogZnVuY3Rpb24gb2ZmUmVuZGVyKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub2ZmKCdyZW5kZXInLCBmbik7XG4gIH1cbn07XG5jb3JlZm4kNC5pbnZhbGlkYXRlRGltZW5zaW9ucyA9IGNvcmVmbiQ0LnJlc2l6ZTtcblxudmFyIGNvcmVmbiQzID0ge1xuICAvLyBnZXQgYSBjb2xsZWN0aW9uXG4gIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gIC8vIC0gZ3VhcmFudGVlIGEgcmV0dXJuZWQgY29sbGVjdGlvbiB3aGVuIGVsZW1lbnRzIG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uIGNvbGxlY3Rpb24oZWxlcywgb3B0cykge1xuICAgIGlmIChzdHJpbmcoZWxlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLiQoZWxlcyk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZXMpKSB7XG4gICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChhcnJheShlbGVzKSkge1xuICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBlbGVzLCBvcHRzLnVuaXF1ZSwgb3B0cy5yZW1vdmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMpO1xuICB9LFxuICBub2RlczogZnVuY3Rpb24gbm9kZXMoc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGdlcztcbiAgfSxcbiAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAkOiBmdW5jdGlvbiAkKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZXMuc3Bhd25TZWxmKCk7XG4gICAgfVxuICB9LFxuICBtdXRhYmxlRWxlbWVudHM6IGZ1bmN0aW9uIG11dGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuY29yZWZuJDMuZWxlbWVudHMgPSBjb3JlZm4kMy5maWx0ZXIgPSBjb3JlZm4kMy4kO1xuXG52YXIgc3R5Zm4kOCA9IHt9O1xuXG4vLyBrZXlzIGZvciBzdHlsZSBibG9ja3MsIGUuZy4gdHRmZnR0XG52YXIgVFJVRSA9ICd0JztcbnZhciBGQUxTRSA9ICdmJztcblxuLy8gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbilcbi8vIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvblxuLy8gLSBpdHMgYnlwYXNzXG4vLyAtIHdoYXQgc2VsZWN0b3JzIG1hdGNoIGl0XG5zdHlmbiQ4LmFwcGx5ID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICB2YXIgY3kgPSBfcC5jeTtcbiAgdmFyIHVwZGF0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuICBmb3IgKHZhciBpZSA9IDA7IGllIDwgZWxlcy5sZW5ndGg7IGllKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpZV07XG4gICAgdmFyIGN4dE1ldGEgPSBzZWxmLmdldENvbnRleHRNZXRhKGVsZSk7XG4gICAgaWYgKGN4dE1ldGEuZW1wdHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZShjeHRNZXRhKTtcbiAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZShjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKTtcbiAgICBpZiAoZWxlLl9wcml2YXRlLmFwcGxpZWRJbml0U3R5bGUpIHtcbiAgICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBhcHAuZGlmZlByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlLl9wcml2YXRlLmFwcGxpZWRJbml0U3R5bGUgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgaGludHNEaWZmID0gc2VsZi51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgaWYgKGhpbnRzRGlmZikge1xuICAgICAgdXBkYXRlZEVsZXMucHVzaChlbGUpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlbWVudHNcblxuICByZXR1cm4gdXBkYXRlZEVsZXM7XG59O1xuc3R5Zm4kOC5nZXRQcm9wZXJ0aWVzRGlmZiA9IGZ1bmN0aW9uIChvbGRDeHRLZXksIG5ld0N4dEtleSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWNoZSA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgfHwge307XG4gIHZhciBkdWFsQ3h0S2V5ID0gb2xkQ3h0S2V5ICsgJy0nICsgbmV3Q3h0S2V5O1xuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZHVhbEN4dEtleV07XG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG4gIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgdmFyIGFkZGVkUHJvcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5W2ldID09PSBUUlVFO1xuICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgdmFyIGN4dEhhc0RpZmZlZCA9IG9sZEhhc0N4dCAhPT0gbmV3SGFzQ3h0O1xuICAgIHZhciBjeHRIYXNNYXBwZWRQcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGN4dEhhc0RpZmZlZCB8fCBuZXdIYXNDeHQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgIHZhciBwcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjeHRIYXNEaWZmZWQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgfSBlbHNlIGlmIChjeHRIYXNEaWZmZWQpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gbmVlZCB0byBjaGVjayB0aGVtIGFsbFxuICAgICAgfSBlbHNlIGlmIChjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgIC8vIGlzIGNhY2hlZClcbiAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGsgPSBpICsgMTsgayA8IHNlbGYubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgIHZhciBoYXNMYXRlckN4dCA9IG5ld0N4dEtleVtrXSA9PT0gVFJVRTtcbiAgICAgICAgICBpZiAoIWhhc0xhdGVyQ3h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIGNhbid0IG92ZXJyaWRlIHVubGVzcyB0aGUgY29udGV4dCBpcyBhY3RpdmVcblxuICAgICAgICAgIGxhdGVyQ3h0T3ZlcnJpZGVzID0gbGF0ZXJDeHQucHJvcGVydGllc1twcm9wLm5hbWVdICE9IG51bGw7XG4gICAgICAgICAgaWYgKGxhdGVyQ3h0T3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IC8vIGV4aXQgZWFybHkgYXMgbG9uZyBhcyBvbmUgbGF0ZXIgY29udGV4dCBvdmVycmlkZXNcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBwcm9wc1xuICAgIH0gLy8gaWZcbiAgfSAvLyBmb3IgY29udGV4dHNcblxuICBjYWNoZVtkdWFsQ3h0S2V5XSA9IGRpZmZQcm9wcztcbiAgcmV0dXJuIGRpZmZQcm9wcztcbn07XG5zdHlmbiQ4LmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRLZXkgPSAnJztcbiAgdmFyIGRpZmZQcm9wcztcbiAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7XG5cbiAgLy8gZ2V0IHRoZSBjeHQga2V5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKGVsZSk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgIGlmIChjb250ZXh0U2VsZWN0b3JNYXRjaGVzKSB7XG4gICAgICBjeHRLZXkgKz0gVFJVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0S2V5ICs9IEZBTFNFO1xuICAgIH1cbiAgfSAvLyBmb3IgY29udGV4dFxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYocHJldktleSwgY3h0S2V5KTtcbiAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wcyxcbiAgICBlbXB0eTogZGlmZlByb3BzLmxlbmd0aCA9PT0gMFxuICB9O1xufTtcblxuLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuc3R5Zm4kOC5nZXRDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSkge1xuICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyB8fCB7fTtcblxuICAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuICBpZiAoY3h0U3R5bGVzW2N4dEtleV0pIHtcbiAgICByZXR1cm4gY3h0U3R5bGVzW2N4dEtleV07XG4gIH1cbiAgdmFyIHN0eWxlID0ge1xuICAgIF9wcml2YXRlOiB7XG4gICAgICBrZXk6IGN4dEtleVxuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gVFJVRTtcbiAgICBpZiAoIWhhc0N4dCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICB9XG4gIH1cbiAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcbnN0eWZuJDguYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gIHZhciByZXREaWZmUHJvcHMgPSB7fTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzW2ldO1xuICAgIHZhciBjeHRQcm9wID0gY3h0U3R5bGVbZGlmZlByb3BOYW1lXTtcbiAgICB2YXIgZWxlUHJvcCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcbiAgICBpZiAoIWN4dFByb3ApIHtcbiAgICAgIC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgIGlmICghZWxlUHJvcCkge1xuICAgICAgICBjb250aW51ZTsgLy8gbm8gZXhpc3RpbmcgcHJvcCBtZWFucyBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgfSBlbHNlIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICBkZWxldGVCeXBhc3NlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgXCJkZWxldGVcIjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmIChlbGVQcm9wID09PSBjeHRQcm9wKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIGN5Y2xlcyB3aGVuIGEgbWFwcGVkIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmIChjeHRQcm9wLm1hcHBlZCA9PT0gdHlwZXMuZm4gLy8gY29udGV4dCBwcm9wIGlzIGZ1bmN0aW9uIG1hcHBlclxuICAgICYmIGVsZVByb3AgIT0gbnVsbCAvLyBzb21lIHByb3BzIGNhbiBiZSBudWxsIGV2ZW4gYnkgZGVmYXVsdCAoZS5nLiBhIHByb3AgdGhhdCBvdmVycmlkZXMgYW5vdGhlciBvbmUpXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nICE9IG51bGwgLy8gZWxlIHByb3AgaXMgYSBjb25jcmV0ZSB2YWx1ZSBmcm9tIGZyb20gYSBtYXBwZXJcbiAgICAmJiBlbGVQcm9wLm1hcHBpbmcudmFsdWUgPT09IGN4dFByb3AudmFsdWUgLy8gdGhlIGN1cnJlbnQgcHJvcCBvbiB0aGUgZWxlIGlzIGEgZmxhdCBwcm9wIHZhbHVlIGZvciB0aGUgZnVuY3Rpb24gbWFwcGVyXG4gICAgKSB7XG4gICAgICAvLyBOQiBkb24ndCB3cml0ZSB0byBjeHRQcm9wLCBhcyBpdCdzIHNoYXJlZCBhbW9uZyBlbGVzIChzdG9yZWQgaW4gc3R5bGVzaGVldClcbiAgICAgIHZhciBtYXBwaW5nID0gZWxlUHJvcC5tYXBwaW5nOyAvLyBjYW4gd3JpdGUgdG8gbWFwcGluZywgYXMgaXQncyBhIHBlci1lbGUgY29weVxuICAgICAgdmFyIGZuVmFsdWUgPSBtYXBwaW5nLmZuVmFsdWUgPSBjeHRQcm9wLnZhbHVlKGVsZSk7IC8vIHRlbXBvcmFyaWx5IGNhY2hlIHRoZSB2YWx1ZSBpbiBjYXNlIG9mIGEgbWlzc1xuXG4gICAgICBpZiAoZm5WYWx1ZSA9PT0gbWFwcGluZy5wcmV2Rm5WYWx1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzW2RpZmZQcm9wTmFtZV0gPSB7XG4gICAgICBwcmV2OiBlbGVQcm9wXG4gICAgfTtcbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjeHRQcm9wKTtcbiAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuICAgIGlmIChyZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzKSB7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkaWZmUHJvcHM6IHJldERpZmZQcm9wc1xuICB9O1xufTtcbnN0eWZuJDgudXBkYXRlU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wTmFtZXMgPSBzZWxmLnByb3BlcnR5R3JvdXBOYW1lcztcbiAgdmFyIHByb3BHcktleXMgPSBzZWxmLnByb3BlcnR5R3JvdXBLZXlzO1xuICB2YXIgcHJvcEhhc2ggPSBmdW5jdGlvbiBwcm9wSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSkge1xuICAgIHJldHVybiBzZWxmLmdldFByb3BlcnRpZXNIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KTtcbiAgfTtcbiAgdmFyIG9sZFN0eWxlS2V5ID0gX3Auc3R5bGVLZXk7XG4gIGlmIChlbGUucmVtb3ZlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJztcblxuICAvLyBnZXQgdGhlIHN0eWxlIGtleSBoYXNoZXMgcGVyIHByb3AgZ3JvdXBcbiAgLy8gYnV0IGxhemlseSAtLSBvbmx5IHVzZSBub24tZGVmYXVsdCBwcm9wIHZhbHVlcyB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBoYXNoZXNcbiAgLy9cblxuICB2YXIgb3ZlcnJpZGRlblN0eWxlcyA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMob3ZlcnJpZGRlblN0eWxlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEdyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncktleSA9IHByb3BHcktleXNbaV07XG4gICAgX3Auc3R5bGVLZXlzW2dyS2V5XSA9IFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXTtcbiAgfVxuICB2YXIgdXBkYXRlR3JLZXkxID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkxKHZhbCwgZ3JLZXkpIHtcbiAgICByZXR1cm4gX3Auc3R5bGVLZXlzW2dyS2V5XVswXSA9IGhhc2hJbnQodmFsLCBfcC5zdHlsZUtleXNbZ3JLZXldWzBdKTtcbiAgfTtcbiAgdmFyIHVwZGF0ZUdyS2V5MiA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5Mih2YWwsIGdyS2V5KSB7XG4gICAgcmV0dXJuIF9wLnN0eWxlS2V5c1tncktleV1bMV0gPSBoYXNoSW50QWx0KHZhbCwgX3Auc3R5bGVLZXlzW2dyS2V5XVsxXSk7XG4gIH07XG4gIHZhciB1cGRhdGVHcktleSA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5KHZhbCwgZ3JLZXkpIHtcbiAgICB1cGRhdGVHcktleTEodmFsLCBncktleSk7XG4gICAgdXBkYXRlR3JLZXkyKHZhbCwgZ3JLZXkpO1xuICB9O1xuICB2YXIgdXBkYXRlR3JLZXlXU3RyID0gZnVuY3Rpb24gdXBkYXRlR3JLZXlXU3RyKHN0clZhbCwgZ3JLZXkpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0clZhbC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGNoID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICB1cGRhdGVHcktleTEoY2gsIGdyS2V5KTtcbiAgICAgIHVwZGF0ZUdyS2V5MihjaCwgZ3JLZXkpO1xuICAgIH1cbiAgfTtcblxuICAvLyAtIGhhc2hpbmcgd29ya3Mgb24gMzIgYml0IGludHMgYi9jIHdlIHVzZSBiaXR3aXNlIG9wc1xuICAvLyAtIHNtYWxsIG51bWJlcnMgZ2V0IGN1dCBvZmYgKGUuZy4gMC4xMjMgaXMgc2VlbiBhcyAwIGJ5IHRoZSBoYXNoaW5nIGZ1bmN0aW9uKVxuICAvLyAtIHJhaXNlIHVwIHNtYWxsIG51bWJlcnMgc28gbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgYXJlIHNlZW4gYnkgaGFzaGluZ1xuICAvLyAtIG1ha2Ugc21hbGwgbnVtYmVycyBsYXJnZXIgdGhhbiBhIG5vcm1hbCB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zXG4gIC8vIC0gd29ya3MgaW4gcHJhY3RpY2UgYW5kIGl0J3MgcmVsYXRpdmVseSBjaGVhcFxuICB2YXIgTiA9IDIwMDAwMDAwMDA7XG4gIHZhciBjbGVhbk51bSA9IGZ1bmN0aW9uIGNsZWFuTnVtKHZhbCkge1xuICAgIHJldHVybiAtMTI4IDwgdmFsICYmIHZhbCA8IDEyOCAmJiBNYXRoLmZsb29yKHZhbCkgIT09IHZhbCA/IE4gLSAodmFsICogMTAyNCB8IDApIDogdmFsO1xuICB9O1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcE5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWVzW19pXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IG92ZXJyaWRkZW5TdHlsZXNbbmFtZV07XG4gICAgaWYgKHBhcnNlZFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwcm9wSW5mbyA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHByb3BJbmZvLnR5cGU7XG4gICAgdmFyIF9ncktleSA9IHByb3BJbmZvLmdyb3VwS2V5O1xuICAgIHZhciBub3JtYWxpemVkTnVtYmVyVmFsID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wSW5mby5oYXNoT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHByb3BJbmZvLmhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkUHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbWlnaHQgbm90IGJlIGEgbnVtYmVyIGlmIGl0IGFsbG93cyBlbnVtc1xuICAgIHZhciBudW1iZXJWYWwgPSBwcm9wSW5mby5lbnVtcyA9PSBudWxsID8gcGFyc2VkUHJvcC52YWx1ZSA6IG51bGw7XG4gICAgdmFyIGhhdmVOb3JtTnVtID0gbm9ybWFsaXplZE51bWJlclZhbCAhPSBudWxsO1xuICAgIHZhciBoYXZlVW5pdGVkTnVtID0gbnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVOdW0gPSBoYXZlTm9ybU51bSB8fCBoYXZlVW5pdGVkTnVtO1xuICAgIHZhciB1bml0cyA9IHBhcnNlZFByb3AudW5pdHM7XG5cbiAgICAvLyBudW1iZXJzIGFyZSBjaGVhcGVyIHRvIGhhc2ggdGhhbiBzdHJpbmdzXG4gICAgLy8gMSBoYXNoIG9wIHZzIG4gaGFzaCBvcHMgKGZvciBsZW5ndGggbiBzdHJpbmcpXG4gICAgaWYgKHR5cGUubnVtYmVyICYmIGhhdmVOdW0gJiYgIXR5cGUubXVsdGlwbGUpIHtcbiAgICAgIHZhciB2ID0gaGF2ZU5vcm1OdW0gPyBub3JtYWxpemVkTnVtYmVyVmFsIDogbnVtYmVyVmFsO1xuICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odiksIF9ncktleSk7XG4gICAgICBpZiAoIWhhdmVOb3JtTnVtICYmIHVuaXRzICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlR3JLZXlXU3RyKHVuaXRzLCBfZ3JLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVHcktleVdTdHIocGFyc2VkUHJvcC5zdHJWYWx1ZSwgX2dyS2V5KTtcbiAgICB9XG4gIH1cblxuICAvLyBvdmVyYWxsIHN0eWxlIGtleVxuICAvL1xuXG4gIHZhciBoYXNoID0gW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wR3JLZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2dyS2V5MiA9IHByb3BHcktleXNbX2kyXTtcbiAgICB2YXIgZ3JIYXNoID0gX3Auc3R5bGVLZXlzW19ncktleTJdO1xuICAgIGhhc2hbMF0gPSBoYXNoSW50KGdySGFzaFswXSwgaGFzaFswXSk7XG4gICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoZ3JIYXNoWzFdLCBoYXNoWzFdKTtcbiAgfVxuICBfcC5zdHlsZUtleSA9IGNvbWJpbmVIYXNoZXMoaGFzaFswXSwgaGFzaFsxXSk7XG5cbiAgLy8gbGFiZWwgZGltc1xuICAvL1xuXG4gIHZhciBzayA9IF9wLnN0eWxlS2V5cztcbiAgX3AubGFiZWxEaW1zS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gIHZhciBsYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsnbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgX3AubGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkobGFiZWxLZXlzKTtcbiAgX3AubGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBsYWJlbEtleXMpKTtcbiAgaWYgKCFpc05vZGUpIHtcbiAgICB2YXIgc291cmNlTGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3NvdXJjZS1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNvdXJjZUxhYmVsS2V5cyk7XG4gICAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBzb3VyY2VMYWJlbEtleXMpKTtcbiAgICB2YXIgdGFyZ2V0TGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ3RhcmdldC1sYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIF9wLnRhcmdldExhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHRhcmdldExhYmVsS2V5cyk7XG4gICAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCB0YXJnZXRMYWJlbEtleXMpKTtcbiAgfVxuXG4gIC8vIG5vZGVcbiAgLy9cblxuICBpZiAoaXNOb2RlKSB7XG4gICAgdmFyIF9wJHN0eWxlS2V5cyA9IF9wLnN0eWxlS2V5cyxcbiAgICAgIG5vZGVCb2R5ID0gX3Akc3R5bGVLZXlzLm5vZGVCb2R5LFxuICAgICAgbm9kZUJvcmRlciA9IF9wJHN0eWxlS2V5cy5ub2RlQm9yZGVyLFxuICAgICAgbm9kZU91dGxpbmUgPSBfcCRzdHlsZUtleXMubm9kZU91dGxpbmUsXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBfcCRzdHlsZUtleXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgY29tcG91bmQgPSBfcCRzdHlsZUtleXMuY29tcG91bmQsXG4gICAgICBwaWUgPSBfcCRzdHlsZUtleXMucGllLFxuICAgICAgc3RyaXBlID0gX3Akc3R5bGVLZXlzLnN0cmlwZTtcbiAgICB2YXIgbm9kZUtleXMgPSBbbm9kZUJvZHksIG5vZGVCb3JkZXIsIG5vZGVPdXRsaW5lLCBiYWNrZ3JvdW5kSW1hZ2UsIGNvbXBvdW5kLCBwaWUsIHN0cmlwZV0uZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gayAhPSBudWxsO1xuICAgIH0pLnJlZHVjZShoYXNoQXJyYXlzLCBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF0pO1xuICAgIF9wLm5vZGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkobm9kZUtleXMpO1xuICAgIF9wLmhhc1BpZSA9IHBpZSAhPSBudWxsICYmIHBpZVswXSAhPT0gREVGQVVMVF9IQVNIX1NFRUQgJiYgcGllWzFdICE9PSBERUZBVUxUX0hBU0hfU0VFRF9BTFQ7XG4gICAgX3AuaGFzU3RyaXBlID0gc3RyaXBlICE9IG51bGwgJiYgc3RyaXBlWzBdICE9PSBERUZBVUxUX0hBU0hfU0VFRCAmJiBzdHJpcGVbMV0gIT09IERFRkFVTFRfSEFTSF9TRUVEX0FMVDtcbiAgfVxuICByZXR1cm4gb2xkU3R5bGVLZXkgIT09IF9wLnN0eWxlS2V5O1xufTtcbnN0eWZuJDguY2xlYXJTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIF9wLnN0eWxlQ3h0S2V5ID0gJyc7XG4gIF9wLnN0eWxlS2V5cyA9IHt9O1xuICBfcC5zdHlsZUtleSA9IG51bGw7XG4gIF9wLmxhYmVsS2V5ID0gbnVsbDtcbiAgX3AubGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsS2V5ID0gbnVsbDtcbiAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsS2V5ID0gbnVsbDtcbiAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IG51bGw7XG4gIF9wLm5vZGVLZXkgPSBudWxsO1xuICBfcC5oYXNQaWUgPSBudWxsO1xuICBfcC5oYXNTdHJpcGUgPSBudWxsO1xufTtcblxuLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4vLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbi8vXG4vLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbi8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4vLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4vLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5zdHlmbiQ4LmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlLCBwYXJzZWRQcm9wKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBmbGF0UHJvcDtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgdmFyIHR5cGUgPSBzZWxmLnByb3BlcnRpZXNbcHJvcC5uYW1lXS50eXBlO1xuICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gIHZhciBvcmlnUHJvcCA9IHN0eWxlW3Byb3AubmFtZV07XG4gIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBmbGF0UHJvcE1hcHBpbmcgPSAnbWFwcGluZyc7XG4gIHZhciBnZXRWYWwgPSBmdW5jdGlvbiBnZXRWYWwocCkge1xuICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAocC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBwLnBmVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwLnZhbHVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIGNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiBjaGVja1RyaWdnZXJzKCkge1xuICAgIHZhciBmcm9tVmFsID0gZ2V0VmFsKG9yaWdQcm9wKTtcbiAgICB2YXIgdG9WYWwgPSBnZXRWYWwocHJvcCk7XG4gICAgc2VsZi5jaGVja1RyaWdnZXJzKGVsZSwgcHJvcC5uYW1lLCBmcm9tVmFsLCB0b1ZhbCk7XG4gIH07XG5cbiAgLy8gZWRnZSBzYW5pdHkgY2hlY2tzIHRvIHByZXZlbnQgdGhlIGNsaWVudCBmcm9tIG1ha2luZyBzZXJpb3VzIG1pc3Rha2VzXG4gIGlmIChwYXJzZWRQcm9wLm5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgZWxlLmlzRWRnZSgpICYmIChcbiAgLy8gbG9vcHMgbXVzdCBiZSBidW5kbGVkIGJlemllcnNcbiAgcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2JlemllcicgJiYgZWxlLmlzTG9vcCgpIHx8XG4gIC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICBwYXJzZWRQcm9wLnZhbHVlID09PSAnaGF5c3RhY2snICYmIChlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSkpKSB7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKHBhcnNlZFByb3AubmFtZSwgJ2JlemllcicsIHByb3BJc0J5cGFzcyk7XG4gIH1cbiAgaWYgKHByb3BbXCJkZWxldGVcIl0pIHtcbiAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGFuZCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgb24gZmFsc2V5IHZhbHVlXG4gICAgc3R5bGVbcHJvcC5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHByb3AuZGVsZXRlQnlwYXNzZWQpIHtcbiAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IHRoYXQgdGhlXG4gICAgaWYgKCFvcmlnUHJvcCkge1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGNhbid0IGRlbGV0ZSBpZiBubyBwcm9wXG4gICAgfSBlbHNlIGlmIChvcmlnUHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIGRlbGV0ZSBieXBhc3NlZFxuICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSB1bmRlZmluZWQ7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc2VkXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzcykge1xuICAgIC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBvcmlnUHJvcC5ieXBhc3NlZDtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG4gIHZhciBwcmludE1hcHBpbmdFcnIgPSBmdW5jdGlvbiBwcmludE1hcHBpbmdFcnIoKSB7XG4gICAgd2FybignRG8gbm90IGFzc2lnbiBtYXBwaW5ncyB0byBlbGVtZW50cyB3aXRob3V0IGNvcnJlc3BvbmRpbmcgZGF0YSAoaS5lLiBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGhhcyBubyBtYXBwaW5nIGZvciBwcm9wZXJ0eSBgJyArIHByb3AubmFtZSArICdgIHdpdGggZGF0YSBmaWVsZCBgJyArIHByb3AuZmllbGQgKyAnYCk7IHRyeSBhIGBbJyArIHByb3AuZmllbGQgKyAnXWAgc2VsZWN0b3IgdG8gbGltaXQgc2NvcGUgdG8gZWxlbWVudHMgd2l0aCBgJyArIHByb3AuZmllbGQgKyAnYCBkZWZpbmVkJyk7XG4gIH07XG5cbiAgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuICBzd2l0Y2ggKHByb3AubWFwcGVkKSB7XG4gICAgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gICAgY2FzZSB0eXBlcy5tYXBEYXRhOlxuICAgICAge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBmaWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJjZW50O1xuICAgICAgICBpZiAoIW51bWJlciQxKGZpZWxkVmFsKSkge1xuICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGNvbnRpbnVvdXMgbWFwcGVycyB3aXRob3V0IHNwZWNpZnlpbmcgbnVtZXJpYyBkYXRhIChpLmUuIGAnICsgcHJvcC5maWVsZCArICc6ICcgKyBmaWVsZFZhbCArICdgIGZvciBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbm9uLW51bWVyaWMpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmaWVsZFdpZHRoID0gcHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW47XG4gICAgICAgICAgaWYgKGZpZWxkV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNhZmV0eSBjaGVjayAtLSBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IGFzIG5vIHByb3BzIG9mIHplcm8gcmFuZ2Ugc2hvdWxkIGJlIHBhc3NlZCBoZXJlXG4gICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gZmllbGRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG4gICAgICAgICAgdmFyIGNsciA9IFtNYXRoLnJvdW5kKHIxICsgKHIyIC0gcjEpICogcGVyY2VudCksIE1hdGgucm91bmQoZzEgKyAoZzIgLSBnMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGExICsgKGEyIC0gYTEpICogcGVyY2VudCldO1xuICAgICAgICAgIGZsYXRQcm9wID0ge1xuICAgICAgICAgICAgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcyxcbiAgICAgICAgICAgIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLm51bWJlcikge1xuICAgICAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IHRoZSBwcm9wZXJ0eSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAvLyBkaXJlY3QgbWFwcGluZ1xuICAgIGNhc2UgdHlwZXMuZGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgX2ZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIF9maWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF9maWVsZHMubGVuZ3RoICYmIF9maWVsZFZhbDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX2ZpZWxkID0gX2ZpZWxkc1tfaTNdO1xuICAgICAgICAgIF9maWVsZFZhbCA9IF9maWVsZFZhbFtfZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZmllbGRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIF9maWVsZFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIHR5cGVzLmZuOlxuICAgICAge1xuICAgICAgICB2YXIgZm4gPSBwcm9wLnZhbHVlO1xuICAgICAgICB2YXIgZm5SZXRWYWwgPSBwcm9wLmZuVmFsdWUgIT0gbnVsbCA/IHByb3AuZm5WYWx1ZSA6IGZuKGVsZSk7IC8vIGNoZWNrIGZvciBjYWNoZWQgdmFsdWUgYmVmb3JlIGNhbGxpbmcgZnVuY3Rpb25cblxuICAgICAgICBwcm9wLnByZXZGblZhbHVlID0gZm5SZXRWYWw7XG4gICAgICAgIGlmIChmblJldFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gbnVsbCAoaS5lLiBgJyArIHByb3AubmFtZSArICdgIGZvciBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGlzIG51bGwpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIGludmFsaWQgdmFsdWVzIGZvciB0aGUgcHJvcGVydHkgdHlwZSAoaS5lLiBgJyArIHByb3AubmFtZSArICdgIGZvciBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGlzIGludmFsaWQpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBjb3B5KHByb3ApOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGJyZWFrO1xuICAgIC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gIH1cblxuICAvLyBpZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHksIHRoZW4gbGluayB0aGUgcmVzdWx0YW50IHByb3BlcnR5IHRvIHRoZSBvcmlnaW5hbCBvbmVcbiAgaWYgKHByb3BJc0J5cGFzcykge1xuICAgIGlmIChvcmlnUHJvcElzQnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHRoaXMgYnlwYXNzIG92ZXJyaWRlcyB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3AuYnlwYXNzZWQ7IC8vIHN0ZWFsIGJ5cGFzc2VkIHByb3AgZnJvbSBvbGQgYnlwYXNzXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4gbGluayB0aGUgb3JpZyBwcm9wIHRvIHRoZSBuZXcgYnlwYXNzXG4gICAgICBwcm9wLmJ5cGFzc2VkID0gb3JpZ1Byb3A7XG4gICAgfVxuICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbmQgc2V0XG4gIH0gZWxzZSB7XG4gICAgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgIH1cbiAgfVxuICBjaGVja1RyaWdnZXJzKCk7XG4gIHJldHVybiB0cnVlO1xufTtcbnN0eWZuJDguY2xlYW5FbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzLCBrZWVwQnlwYXNzZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdGhpcy5jbGVhclN0eWxlSGludHMoZWxlKTtcbiAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIGlmICgha2VlcEJ5cGFzc2VzKSB7XG4gICAgICBlbGUuX3ByaXZhdGUuc3R5bGUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BOYW1lc1tqXTtcbiAgICAgICAgdmFyIGVsZVByb3AgPSBzdHlsZVtwcm9wTmFtZV07XG4gICAgICAgIGlmIChlbGVQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgICAgIGVsZVByb3AuYnlwYXNzZWQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuc3R5Zm4kOC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gIGVsZXMudXBkYXRlU3R5bGUoKTtcbn07XG5cbi8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG5zdHlmbiQ4LnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKGVsZSwgZGlmZlByb3BzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcHJvcHMgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXByb3BlcnR5JykudmFsdWU7XG4gIHZhciBkdXJhdGlvbiA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKS5wZlZhbHVlO1xuICB2YXIgZGVsYXkgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWRlbGF5JykucGZWYWx1ZTtcbiAgaWYgKHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgdmFyIHN0eVByb3AgPSBlbGUucHN0eWxlKHByb3ApO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3BdO1xuICAgICAgaWYgKCFkaWZmUHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgIHZhciBkaWZmID0gZmFsc2U7XG4gICAgICB2YXIgaW5pdFZhbCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgaWYgKCFmcm9tUHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc2lkZXIgcHggdmFsdWVzXG4gICAgICBpZiAobnVtYmVyJDEoZnJvbVByb3AucGZWYWx1ZSkgJiYgbnVtYmVyJDEodG9Qcm9wLnBmVmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AucGZWYWx1ZSAtIGZyb21Qcm9wLnBmVmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKG51bWJlciQxKGZyb21Qcm9wLnZhbHVlKSAmJiBudW1iZXIkMSh0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnZhbHVlICsgaW5pdER0ICogZGlmZjtcblxuICAgICAgICAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKGFycmF5KGZyb21Qcm9wLnZhbHVlKSAmJiBhcnJheSh0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZVswXSAhPT0gdG9Qcm9wLnZhbHVlWzBdIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV0gfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXTtcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIHN0eWxlW3Byb3BdID0gdG9Qcm9wLnN0clZhbHVlOyAvLyB0byB2YWxcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIHByb3AsIGluaXRWYWwpOyAvLyBmcm9tIHZhbFxuICAgICAgICBhbnlQcmV2ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBpZiBwcm9wcyBhbGxvdyBhbmlcblxuICAgIC8vIGNhbid0IHRyYW5zaXRpb24gaWYgdGhlcmUncyBub3RoaW5nIHByZXZpb3VzIHRvIHRyYW5zaXRpb24gZnJvbVxuICAgIGlmICghYW55UHJldikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIGVsZS5kZWxheUFuaW1hdGlvbihkZWxheSkucGxheSgpLnByb21pc2UoKS50aGVuKHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsZS5hbmltYXRpb24oe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicpLnZhbHVlLFxuICAgICAgICBxdWV1ZTogZmFsc2VcbiAgICAgIH0pLnBsYXkoKS5wcm9taXNlKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpZiggIWlzQnlwYXNzICl7XG4gICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7XG4gICAgICAvLyB9XG5cbiAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChfcC50cmFuc2l0aW9uaW5nKSB7XG4gICAgdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTtcbiAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gIH1cbn07XG5zdHlmbiQ4LmNoZWNrVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZ2V0VHJpZ2dlciwgb25UcmlnZ2VyKSB7XG4gIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICB2YXIgdHJpZ2dlckNoZWNrID0gZ2V0VHJpZ2dlcihwcm9wKTtcbiAgaWYgKGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRyaWdnZXJDaGVjayAhPSBudWxsICYmIHRyaWdnZXJDaGVjayhmcm9tVmFsdWUsIHRvVmFsdWUsIGVsZSkpIHtcbiAgICBvblRyaWdnZXIocHJvcCk7XG4gIH1cbn07XG5zdHlmbiQ4LmNoZWNrWk9yZGVyVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc1pPcmRlcjtcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9wcml2YXRlLmN5Lm5vdGlmeSgnem9yZGVyJywgZWxlKTtcbiAgfSk7XG59O1xuc3R5Zm4kOC5jaGVja0JvdW5kc1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgfSk7XG59O1xuc3R5Zm4kOC5jaGVja0Nvbm5lY3RlZEVkZ2VzQm91bmRzVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc0JvdW5kc09mQ29ubmVjdGVkRWRnZXM7XG4gIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgZWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuc3R5Zm4kOC5jaGVja1BhcmFsbGVsRWRnZXNCb3VuZHNUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBwcm9wLnRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzO1xuICB9LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGVsZS5wYXJhbGxlbEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAocGxsRWRnZSkge1xuICAgICAgcGxsRWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuc3R5Zm4kOC5jaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIGVsZS5kaXJ0eVN0eWxlQ2FjaGUoKTtcbiAgdGhpcy5jaGVja1pPcmRlclRyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICB0aGlzLmNoZWNrQm91bmRzVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gIHRoaXMuY2hlY2tDb25uZWN0ZWRFZGdlc0JvdW5kc1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICB0aGlzLmNoZWNrUGFyYWxsZWxFZGdlc0JvdW5kc1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xufTtcblxudmFyIHN0eWZuJDcgPSB7fTtcblxuLy8gYnlwYXNzZXMgYXJlIGFwcGxpZWQgdG8gYW4gZXhpc3Rpbmcgc3R5bGUgb24gYW4gZWxlbWVudCwgYW5kIGp1c3QgdGFja2VkIG9uIHRlbXBvcmFyaWx5XG4vLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuc3R5Zm4kNy5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gIGlmIChuYW1lID09PSAnKicgfHwgbmFtZSA9PT0gJyoqJykge1xuICAgIC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShfbmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICBpZiAocGFyc2VkUHJvcCkge1xuICAgICAgICAgIHByb3BzLnB1c2gocGFyc2VkUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgdmFyIF9wYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgaWYgKF9wYXJzZWRQcm9wKSB7XG4gICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAvLyB0aGVuIHBhcnNlIGVhY2ggcHJvcGVydHlcbiAgICB2YXIgc3BlY2lmaWVkUHJvcHMgPSBuYW1lO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3BlY2lmaWVkUHJvcHMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbmFtZTIgPSBuYW1lc1tfaV07XG4gICAgICB2YXIgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbX25hbWUyXTtcbiAgICAgIGlmIChfdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0cnkgY2FtZWwgY2FzZSBuYW1lIHRvb1xuICAgICAgICBfdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1tkYXNoMmNhbWVsKF9uYW1lMildO1xuICAgICAgfVxuICAgICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfcGFyc2VkUHJvcDIgPSB0aGlzLnBhcnNlKF9uYW1lMiwgX3ZhbHVlLCB0cnVlKTtcbiAgICAgICAgaWYgKF9wYXJzZWRQcm9wMikge1xuICAgICAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3AyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gd2UndmUgZmFpbGVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBwcm9wZXJ0aWVzXG4gIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcbiAgdmFyIHJldCA9IGZhbHNlOyAvLyByZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc3VjY2VzZnVsIGJ5cGFzcyBhcHBsaWVkXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzW19pMl07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tqXTtcbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgcHJldlByb3AgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgICBkaWZmUHJvcCA9IGRpZmZQcm9wc1tfcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY29weShfcHJvcCkpIHx8IHJldDtcbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgaWYgKHJldCkge1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuc3R5Zm4kNy5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbbmFtZV07XG4gICAgdmFyIHR5cGUgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV0udHlwZTtcbiAgICB2YXIgaXNDb2xvciA9IHR5cGUuY29sb3I7XG4gICAgdmFyIGlzTXVsdGkgPSB0eXBlLm11dGlwbGU7XG4gICAgdmFyIG9sZFZhbHVlID0gIXByb3AgPyBudWxsIDogcHJvcC5wZlZhbHVlICE9IG51bGwgPyBwcm9wLnBmVmFsdWUgOiBwcm9wLnZhbHVlO1xuICAgIGlmICghcHJvcCB8fCAhcHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwcm9wLnBmVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSAncmdiKCcgKyB2YWx1ZS5qb2luKCcsJykgKyAnKSc7XG4gICAgICB9IGVsc2UgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9IHZhbHVlLmpvaW4oJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3Auc3RyVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tUcmlnZ2VycyhlbGUsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gIH1cbn07XG5zdHlmbiQ3LnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHJldHVybiB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZXMsIHRoaXMucHJvcGVydHlOYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xufTtcbnN0eWZuJDcucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gIHZhciBpc0J5cGFzcyA9IHRydWU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3BzW2ldO1xuICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgICB2YXIgcHJldlByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgICBpZiAoIXByZXZQcm9wIHx8ICFwcmV2UHJvcC5ieXBhc3MpIHtcbiAgICAgICAgLy8gaWYgYSBieXBhc3MgZG9lc24ndCBleGlzdCBmb3IgdGhlIHByb3AsIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3AubmFtZV0gPSB7XG4gICAgICAgIHByZXY6IHByZXZQcm9wXG4gICAgICB9O1xuICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgICBkaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcbn07XG5cbnZhciBzdHlmbiQ2ID0ge307XG5cbi8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG5zdHlmbiQ2LmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHggPSB0aGlzLmNvbnRhaW5lckNzcygnZm9udC1zaXplJyk7XG4gIGlmIChweCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocHgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxOyAvLyBmb3IgaGVhZGxlc3NcbiAgfVxufTtcblxuLy8gZ2V0cyBjc3MgcHJvcGVydHkgZnJvbSB0aGUgY29yZSBjb250YWluZXJcbnN0eWZuJDYuY29udGFpbmVyQ3NzID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSBjeS53aW5kb3coKTtcbiAgaWYgKGNvbnRhaW5lcldpbmRvdyAmJiBkb21FbGVtZW50ICYmIGNvbnRhaW5lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcE5hbWUpO1xuICB9XG59O1xuXG52YXIgc3R5Zm4kNSA9IHt9O1xuXG4vLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuc3R5Zm4kNS5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcCkge1xuICBpZiAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdldFJhd1N0eWxlKGVsZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbi8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuc3R5Zm4kNS5nZXRSYXdTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGlzUmVuZGVyZWRWYWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICBpZiAoZWxlKSB7XG4gICAgdmFyIHJzdHlsZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AubmFtZSwgaXNSZW5kZXJlZFZhbCk7XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgcnN0eWxlW3Byb3AubmFtZV0gPSB2YWw7XG4gICAgICAgIHJzdHlsZVtkYXNoMmNhbWVsKHByb3AubmFtZSldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9XG59O1xuc3R5Zm4kNS5nZXRJbmRleGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wZXJ0eSwgc3VicHJvcGVydHksIGluZGV4KSB7XG4gIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1baW5kZXhdO1xuICByZXR1cm4gcHN0eWxlICE9IG51bGwgPyBwc3R5bGUgOiBlbGUuY3koKS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSlbc3VicHJvcGVydHldWzBdO1xufTtcbnN0eWZuJDUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gKGVsZSwgcHJvcE5hbWUsIGlzUmVuZGVyZWRWYWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICBpZiAoZWxlKSB7XG4gICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgIGlmIChwcm9wLmFsaWFzKSB7XG4gICAgICBwcm9wID0gcHJvcC5wb2ludHNUbztcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcbiAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZVByb3AudmFsdWUsXG4gICAgICAgIHVuaXRzID0gc3R5bGVQcm9wLnVuaXRzLFxuICAgICAgICBzdHJWYWx1ZSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcbiAgICAgIGlmIChpc1JlbmRlcmVkVmFsICYmIHR5cGUubnVtYmVyICYmIHZhbHVlICE9IG51bGwgJiYgbnVtYmVyJDEodmFsdWUpKSB7XG4gICAgICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuICAgICAgICB2YXIgZ2V0UmVuZGVyZWRWYWx1ZSA9IGZ1bmN0aW9uIGdldFJlbmRlcmVkVmFsdWUodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbCAqIHpvb207XG4gICAgICAgIH07XG4gICAgICAgIHZhciBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyA9IGZ1bmN0aW9uIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHZhbCwgdW5pdHMpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpICsgdW5pdHM7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0FycmF5VmFsdWUgPSBhcnJheSh2YWx1ZSk7XG4gICAgICAgIHZhciBoYXZlVW5pdHMgPSBpc0FycmF5VmFsdWUgPyB1bml0cy5ldmVyeShmdW5jdGlvbiAodSkge1xuICAgICAgICAgIHJldHVybiB1ICE9IG51bGw7XG4gICAgICAgIH0pIDogdW5pdHMgIT0gbnVsbDtcbiAgICAgICAgaWYgKGhhdmVVbml0cykge1xuICAgICAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHYsIHVuaXRzW2ldKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHZhbHVlLCB1bml0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZyh2KSA/IHYgOiAnJyArIGdldFJlbmRlcmVkVmFsdWUodik7XG4gICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGdldFJlbmRlcmVkVmFsdWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5zdHlmbiQ1LmdldEFuaW1hdGlvblN0YXJ0U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBhbmlQcm9wcykge1xuICB2YXIgcnN0eWxlID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYW5pUHJvcCA9IGFuaVByb3BzW2ldO1xuICAgIHZhciBuYW1lID0gYW5pUHJvcC5uYW1lO1xuICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKG5hbWUpO1xuICAgIGlmIChzdHlsZVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGhlbiBtYWtlIGEgcHJvcCBvZiBpdFxuICAgICAgaWYgKHBsYWluT2JqZWN0KHN0eWxlUHJvcCkpIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3Auc3RyVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICByc3R5bGVbbmFtZV0gPSBzdHlsZVByb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiByc3R5bGU7XG59O1xuc3R5Zm4kNS5nZXRQcm9wc0xpc3QgPSBmdW5jdGlvbiAocHJvcHNPYmopIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnN0eWxlID0gW107XG4gIHZhciBzdHlsZSA9IHByb3BzT2JqO1xuICB2YXIgcHJvcHMgPSBzZWxmLnByb3BlcnRpZXM7XG4gIGlmIChzdHlsZSkge1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHN0eWxlW25hbWVdO1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tuYW1lXSB8fCBwcm9wc1tjYW1lbDJkYXNoKG5hbWUpXTtcbiAgICAgIHZhciBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgdmFsKTtcbiAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgcnN0eWxlLnB1c2goc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5zdHlmbiQ1LmdldE5vbkRlZmF1bHRQcm9wZXJ0aWVzSGFzaCA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lcywgc2VlZCkge1xuICB2YXIgaGFzaCA9IHNlZWQuc2xpY2UoKTtcbiAgdmFyIG5hbWUsIHZhbCwgc3RyVmFsLCBjaFZhbDtcbiAgdmFyIGksIGo7XG4gIGZvciAoaSA9IDA7IGkgPCBwcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBuYW1lID0gcHJvcE5hbWVzW2ldO1xuICAgIHZhbCA9IGVsZS5wc3R5bGUobmFtZSwgZmFsc2UpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICh2YWwucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBoYXNoWzBdID0gaGFzaEludChjaFZhbCwgaGFzaFswXSk7XG4gICAgICBoYXNoWzFdID0gaGFzaEludEFsdChjaFZhbCwgaGFzaFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0clZhbCA9IHZhbC5zdHJWYWx1ZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY2hWYWwgPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgICAgaGFzaFswXSA9IGhhc2hJbnQoY2hWYWwsIGhhc2hbMF0pO1xuICAgICAgICBoYXNoWzFdID0gaGFzaEludEFsdChjaFZhbCwgaGFzaFsxXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNoO1xufTtcbnN0eWZuJDUuZ2V0UHJvcGVydGllc0hhc2ggPSBzdHlmbiQ1LmdldE5vbkRlZmF1bHRQcm9wZXJ0aWVzSGFzaDtcblxudmFyIHN0eWZuJDQgPSB7fTtcbnN0eWZuJDQuYXBwZW5kRnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IGpzb25baV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG4gICAgICBzdHlsZS5jc3MobmFtZSwgdmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbnN0eWZuJDQuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuc3R5Zm4kNC5qc29uID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbiA9IFtdO1xuICBmb3IgKHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICB2YXIgY3NzID0ge307XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIGNzc1twcm9wLm5hbWVdID0gcHJvcC5zdHJWYWx1ZTtcbiAgICB9XG4gICAganNvbi5wdXNoKHtcbiAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgc3R5bGU6IGNzc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBqc29uO1xufTtcblxudmFyIHN0eWZuJDMgPSB7fTtcbnN0eWZuJDMuYXBwZW5kRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gIHZhciBzZWxBbmRCbG9ja1N0cjtcbiAgdmFyIGJsb2NrUmVtO1xuICB2YXIgcHJvcEFuZFZhbFN0cjtcblxuICAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG4gIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuICBmdW5jdGlvbiByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiBzZWxBbmRCbG9ja1N0ci5sZW5ndGgpIHtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoc2VsQW5kQmxvY2tTdHIubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKDs7KSB7XG4gICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyokLyk7XG4gICAgaWYgKG5vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcbiAgICBpZiAoIXNlbEFuZEJsb2NrKSB7XG4gICAgICB3YXJuKCdIYWx0aW5nIHN0eWxlc2hlZXQgcGFyc2luZzogU3RyaW5nIHN0eWxlc2hlZXQgY29udGFpbnMgbW9yZSB0byBwYXJzZSBidXQgbm8gc2VsZWN0b3IgYW5kIGJsb2NrIGZvdW5kIGluOiAnICsgcmVtYWluaW5nKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yU3RyID0gc2VsQW5kQmxvY2tbMV07XG4gICAgaWYgKHNlbGVjdG9yU3RyICE9PSAnY29yZScpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG4gICAgICBpZiAoc2VsZWN0b3IuaW52YWxpZCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgX25vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgIGlmIChfbm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pKD86XFxzKjt8XFxzKiQpLyk7XG4gICAgICBpZiAoIXByb3BBbmRWYWwpIHtcbiAgICAgICAgd2FybignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wU3RyXTtcbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UocHJvcFN0ciwgdmFsU3RyKTtcbiAgICAgIGlmICghcGFyc2VkUHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgfSk7XG4gICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEJsb2NrKSB7XG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tpXTtcbiAgICAgIHN0eWxlLmNzcyhfcHJvcC5uYW1lLCBfcHJvcC52YWwpO1xuICAgIH1cbiAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59O1xuc3R5Zm4kMy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBzdHlmbiQyID0ge307XG4oZnVuY3Rpb24gKCkge1xuICB2YXIgbnVtYmVyJDEgPSBudW1iZXI7XG4gIHZhciByZ2JhID0gcmdiYU5vQmFja1JlZnM7XG4gIHZhciBoc2xhID0gaHNsYU5vQmFja1JlZnM7XG4gIHZhciBoZXgzJDEgPSBoZXgzO1xuICB2YXIgaGV4NiQxID0gaGV4NjtcbiAgdmFyIGRhdGEgPSBmdW5jdGlvbiBkYXRhKHByZWZpeCkge1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXChcXFxccyooW1xcXFx3XFxcXC5dKylcXFxccypcXFxcKSQnO1xuICB9O1xuICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEocHJlZml4KSB7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciQxICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyQxICsgJ3wnICsgaGV4NiQxO1xuICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxcKSQnO1xuICB9O1xuICB2YXIgdXJsUmVnZXhlcyA9IFsnXnVybFxcXFxzKlxcXFwoXFxcXHMqW1xcJ1wiXT8oLis/KVtcXCdcIl0/XFxcXHMqXFxcXCkkJywgJ14obm9uZSkkJywgJ14oLispJCddO1xuXG4gIC8vIGVhY2ggdmlzdWFsIHN0eWxlIHByb3BlcnR5IGhhcyBhIHR5cGUgYW5kIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gaXRcbiAgc3R5Zm4kMi50eXBlcyA9IHtcbiAgICB0aW1lOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB1bml0czogJ3N8bXMnLFxuICAgICAgaW1wbGljaXRVbml0czogJ21zJ1xuICAgIH0sXG4gICAgcGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxMDAsXG4gICAgICB1bml0czogJyUnLFxuICAgICAgaW1wbGljaXRVbml0czogJyUnXG4gICAgfSxcbiAgICBwZXJjZW50YWdlczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxMDAsXG4gICAgICB1bml0czogJyUnLFxuICAgICAgaW1wbGljaXRVbml0czogJyUnLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHplcm9PbmVOdW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICB6ZXJvT25lTnVtYmVyczoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgbk9uZU9uZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAtMSxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBub25OZWdhdGl2ZUludDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgaW50ZWdlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBub25OZWdhdGl2ZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICBlbnVtczogWydwYXJlbnQnLCAnb3JpZ2luJ11cbiAgICB9LFxuICAgIG5vZGVTaXplOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBlbnVtczogWydsYWJlbCddXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBwb3NpdGl2ZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBzdHJpY3RNaW46IHRydWVcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMFxuICAgIH0sXG4gICAgYmlkaXJlY3Rpb25hbFNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgc2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgfSxcbiAgICBheGlzRGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWydob3Jpem9udGFsJywgJ2xlZnR3YXJkJywgJ3JpZ2h0d2FyZCcsICd2ZXJ0aWNhbCcsICd1cHdhcmQnLCAnZG93bndhcmQnLCAnYXV0byddXG4gICAgfSxcbiAgICBheGlzRGlyZWN0aW9uRXhwbGljaXQ6IHtcbiAgICAgIGVudW1zOiBbJ2xlZnR3YXJkJywgJ3JpZ2h0d2FyZCcsICd1cHdhcmQnLCAnZG93bndhcmQnXVxuICAgIH0sXG4gICAgYXhpc0RpcmVjdGlvblByaW1hcnk6IHtcbiAgICAgIGVudW1zOiBbJ2hvcml6b250YWwnLCAndmVydGljYWwnXVxuICAgIH0sXG4gICAgcGFkZGluZ1JlbGF0aXZlVG86IHtcbiAgICAgIGVudW1zOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdhdmVyYWdlJywgJ21pbicsICdtYXgnXVxuICAgIH0sXG4gICAgYmdXSDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlLFxuICAgICAgZW51bXM6IFsnYXV0byddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUG9zOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdSZWxhdGl2ZVRvOiB7XG4gICAgICBlbnVtczogWydpbm5lcicsICdpbmNsdWRlLXBhZGRpbmcnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1JlcGVhdDoge1xuICAgICAgZW51bXM6IFsncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnRml0OiB7XG4gICAgICBlbnVtczogWydub25lJywgJ2NvbnRhaW4nLCAnY292ZXInXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0Nyb3NzT3JpZ2luOiB7XG4gICAgICBlbnVtczogWydhbm9ueW1vdXMnLCAndXNlLWNyZWRlbnRpYWxzJywgJ251bGwnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0NsaXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnbm9kZSddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ29udGFpbm1lbnQ6IHtcbiAgICAgIGVudW1zOiBbJ2luc2lkZScsICdvdmVyJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYm94U2VsZWN0aW9uOiB7XG4gICAgICBlbnVtczogWydjb250YWluJywgJ292ZXJsYXAnLCAnbm9uZSddXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IHRydWVcbiAgICB9LFxuICAgIGNvbG9yczoge1xuICAgICAgY29sb3I6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgZmlsbDoge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnbGluZWFyLWdyYWRpZW50JywgJ3JhZGlhbC1ncmFkaWVudCddXG4gICAgfSxcbiAgICBib29sOiB7XG4gICAgICBlbnVtczogWyd5ZXMnLCAnbm8nXVxuICAgIH0sXG4gICAgYm9vbHM6IHtcbiAgICAgIGVudW1zOiBbJ3llcycsICdubyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGxpbmVTdHlsZToge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddXG4gICAgfSxcbiAgICBsaW5lQ2FwOiB7XG4gICAgICBlbnVtczogWydidXR0JywgJ3JvdW5kJywgJ3NxdWFyZSddXG4gICAgfSxcbiAgICBsaW5lUG9zaXRpb246IHtcbiAgICAgIGVudW1zOiBbJ2NlbnRlcicsICdpbnNpZGUnLCAnb3V0c2lkZSddXG4gICAgfSxcbiAgICBsaW5lSm9pbjoge1xuICAgICAgZW51bXM6IFsncm91bmQnLCAnYmV2ZWwnLCAnbWl0ZXInXVxuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ11cbiAgICB9LFxuICAgIGN1cnZlU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJywgJ3N0cmFpZ2h0JywgJ3N0cmFpZ2h0LXRyaWFuZ2xlJywgJ3RheGknLCAncm91bmQtc2VnbWVudHMnLCAncm91bmQtdGF4aSddXG4gICAgfSxcbiAgICByYWRpdXNUeXBlOiB7XG4gICAgICBlbnVtczogWydhcmMtcmFkaXVzJywgJ2luZmx1ZW5jZS1yYWRpdXMnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBmb250RmFtaWx5OiB7XG4gICAgICByZWdleDogJ14oW1xcXFx3LSBcXFxcXCJdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIFxcXFxcIl0rKSopJCdcbiAgICB9LFxuICAgIGZvbnRTdHlsZToge1xuICAgICAgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ11cbiAgICB9LFxuICAgIGZvbnRXZWlnaHQ6IHtcbiAgICAgIGVudW1zOiBbJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwXVxuICAgIH0sXG4gICAgdGV4dERlY29yYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddXG4gICAgfSxcbiAgICB0ZXh0VHJhbnNmb3JtOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXVxuICAgIH0sXG4gICAgdGV4dFdyYXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnd3JhcCcsICdlbGxpcHNpcyddXG4gICAgfSxcbiAgICB0ZXh0T3ZlcmZsb3dXcmFwOiB7XG4gICAgICBlbnVtczogWyd3aGl0ZXNwYWNlJywgJ2FueXdoZXJlJ11cbiAgICB9LFxuICAgIHRleHRCYWNrZ3JvdW5kU2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnLCAnY2lyY2xlJ11cbiAgICB9LFxuICAgIG5vZGVTaGFwZToge1xuICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZScsICdib3R0b21yb3VuZHJlY3RhbmdsZScsICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJywgJ2JhcnJlbCcsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdoZXhhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAnY29uY2F2ZWhleGFnb24nLCAnY29uY2F2ZS1oZXhhZ29uJywgJ2hlcHRhZ29uJywgJ3JvdW5kLWhlcHRhZ29uJywgJ29jdGFnb24nLCAncm91bmQtb2N0YWdvbicsICd0YWcnLCAncm91bmQtdGFnJywgJ3N0YXInLCAnZGlhbW9uZCcsICdyb3VuZC1kaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdyaWdodC1yaG9tYm9pZCcsICdwb2x5Z29uJ11cbiAgICB9LFxuICAgIG92ZXJsYXlTaGFwZToge1xuICAgICAgZW51bXM6IFsncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2VsbGlwc2UnXVxuICAgIH0sXG4gICAgY29ybmVyUmFkaXVzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB1bml0czogJ3B4fGVtJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydhdXRvJ11cbiAgICB9LFxuICAgIGNvbXBvdW5kSW5jbHVkZUxhYmVsczoge1xuICAgICAgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ11cbiAgICB9LFxuICAgIGFycm93U2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAnY2lyY2xlLXRyaWFuZ2xlJywgJ3RyaWFuZ2xlLWNyb3NzJywgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsICd2ZWUnLCAnc3F1YXJlJywgJ2NpcmNsZScsICdkaWFtb25kJywgJ2NoZXZyb24nLCAnbm9uZSddXG4gICAgfSxcbiAgICBhcnJvd0ZpbGw6IHtcbiAgICAgIGVudW1zOiBbJ2ZpbGxlZCcsICdob2xsb3cnXVxuICAgIH0sXG4gICAgYXJyb3dXaWR0aDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICclfHB4fGVtJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydtYXRjaC1saW5lJ11cbiAgICB9LFxuICAgIGRpc3BsYXk6IHtcbiAgICAgIGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddXG4gICAgfSxcbiAgICB2aXNpYmlsaXR5OiB7XG4gICAgICBlbnVtczogWydoaWRkZW4nLCAndmlzaWJsZSddXG4gICAgfSxcbiAgICB6Q29tcG91bmREZXB0aDoge1xuICAgICAgZW51bXM6IFsnYm90dG9tJywgJ29ycGhhbicsICdhdXRvJywgJ3RvcCddXG4gICAgfSxcbiAgICB6SW5kZXhDb21wYXJlOiB7XG4gICAgICBlbnVtczogWydhdXRvJywgJ21hbnVhbCddXG4gICAgfSxcbiAgICB2YWxpZ246IHtcbiAgICAgIGVudW1zOiBbJ3RvcCcsICdjZW50ZXInLCAnYm90dG9tJ11cbiAgICB9LFxuICAgIGhhbGlnbjoge1xuICAgICAgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXVxuICAgIH0sXG4gICAganVzdGlmaWNhdGlvbjoge1xuICAgICAgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnYXV0byddXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICBzdHJpbmc6IHRydWVcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnZGF0YScpXG4gICAgfSxcbiAgICBsYXlvdXREYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKVxuICAgIH0sXG4gICAgc2NyYXRjaDoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdzY3JhdGNoJylcbiAgICB9LFxuICAgIG1hcERhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwRGF0YScpXG4gICAgfSxcbiAgICBtYXBMYXlvdXREYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKVxuICAgIH0sXG4gICAgbWFwU2NyYXRjaDoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBTY3JhdGNoJylcbiAgICB9LFxuICAgIGZuOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgZm46IHRydWVcbiAgICB9LFxuICAgIHVybDoge1xuICAgICAgcmVnZXhlczogdXJsUmVnZXhlcyxcbiAgICAgIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgdXJsczoge1xuICAgICAgcmVnZXhlczogdXJsUmVnZXhlcyxcbiAgICAgIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBwcm9wTGlzdDoge1xuICAgICAgcHJvcExpc3Q6IHRydWVcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0czogJ2RlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3JhZCdcbiAgICB9LFxuICAgIHRleHRSb3RhdGlvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnLFxuICAgICAgZW51bXM6IFsnbm9uZScsICdhdXRvcm90YXRlJ11cbiAgICB9LFxuICAgIHBvbHlnb25Qb2ludExpc3Q6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgZXZlbk11bHRpcGxlOiB0cnVlLFxuICAgICAgbWluOiAtMSxcbiAgICAgIG1heDogMSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBlZGdlRGlzdGFuY2VzOiB7XG4gICAgICBlbnVtczogWydpbnRlcnNlY3Rpb24nLCAnbm9kZS1wb3NpdGlvbicsICdlbmRwb2ludHMnXVxuICAgIH0sXG4gICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnJXxweHxlbXxkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJywgJ291dHNpZGUtdG8tbGluZScsICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnXSxcbiAgICAgIHNpbmdsZUVudW06IHRydWUsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyLCB1bml0c0Fycikge1xuICAgICAgICBzd2l0Y2ggKHZhbEFyci5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIGNhbiBiZSBlbnVtLCBkZWcsIG9yIHJhZCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nKHZhbEFyclswXSkgfHwgdW5pdHNBcnJbMF0gPT09ICdkZWcnIHx8IHVuaXRzQXJyWzBdID09PSAncmFkJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlYXNpbmc6IHtcbiAgICAgIHJlZ2V4ZXM6IFsnXihzcHJpbmcpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqXFxcXCkkJywgJ14oY3ViaWMtYmV6aWVyKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqXFxcXCkkJ10sXG4gICAgICBlbnVtczogWydsaW5lYXInLCAnZWFzZScsICdlYXNlLWluJywgJ2Vhc2Utb3V0JywgJ2Vhc2UtaW4tb3V0JywgJ2Vhc2UtaW4tc2luZScsICdlYXNlLW91dC1zaW5lJywgJ2Vhc2UtaW4tb3V0LXNpbmUnLCAnZWFzZS1pbi1xdWFkJywgJ2Vhc2Utb3V0LXF1YWQnLCAnZWFzZS1pbi1vdXQtcXVhZCcsICdlYXNlLWluLWN1YmljJywgJ2Vhc2Utb3V0LWN1YmljJywgJ2Vhc2UtaW4tb3V0LWN1YmljJywgJ2Vhc2UtaW4tcXVhcnQnLCAnZWFzZS1vdXQtcXVhcnQnLCAnZWFzZS1pbi1vdXQtcXVhcnQnLCAnZWFzZS1pbi1xdWludCcsICdlYXNlLW91dC1xdWludCcsICdlYXNlLWluLW91dC1xdWludCcsICdlYXNlLWluLWV4cG8nLCAnZWFzZS1vdXQtZXhwbycsICdlYXNlLWluLW91dC1leHBvJywgJ2Vhc2UtaW4tY2lyYycsICdlYXNlLW91dC1jaXJjJywgJ2Vhc2UtaW4tb3V0LWNpcmMnXVxuICAgIH0sXG4gICAgZ3JhZGllbnREaXJlY3Rpb246IHtcbiAgICAgIGVudW1zOiBbJ3RvLWJvdHRvbScsICd0by10b3AnLCAndG8tbGVmdCcsICd0by1yaWdodCcsICd0by1ib3R0b20tcmlnaHQnLCAndG8tYm90dG9tLWxlZnQnLCAndG8tdG9wLXJpZ2h0JywgJ3RvLXRvcC1sZWZ0JywgJ3RvLXJpZ2h0LWJvdHRvbScsICd0by1sZWZ0LWJvdHRvbScsICd0by1yaWdodC10b3AnLCAndG8tbGVmdC10b3AnIC8vIGRpZmZlcmVudCBvcmRlclxuICAgICAgXVxuICAgIH0sXG4gICAgYm91bmRzRXhwYW5zaW9uOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbEFyci5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPT09IDEgfHwgbGVuZ3RoID09PSAyIHx8IGxlbmd0aCA9PT0gNDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkaWZmID0ge1xuICAgIHplcm9Ob25aZXJvOiBmdW5jdGlvbiB6ZXJvTm9uWmVybyh2YWwxLCB2YWwyKSB7XG4gICAgICBpZiAoKHZhbDEgPT0gbnVsbCB8fCB2YWwyID09IG51bGwpICYmIHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIG51bGwgY2FzZXMgY291bGQgcmVwcmVzZW50IGFueSB2YWx1ZVxuICAgICAgfVxuICAgICAgaWYgKHZhbDEgPT0gMCAmJiB2YWwyICE9IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbDEgIT0gMCAmJiB2YWwyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uIGFueSh2YWwxLCB2YWwyKSB7XG4gICAgICByZXR1cm4gdmFsMSAhPSB2YWwyO1xuICAgIH0sXG4gICAgZW1wdHlOb25FbXB0eTogZnVuY3Rpb24gZW1wdHlOb25FbXB0eShzdHIxLCBzdHIyKSB7XG4gICAgICB2YXIgZW1wdHkxID0gZW1wdHlTdHJpbmcoc3RyMSk7XG4gICAgICB2YXIgZW1wdHkyID0gZW1wdHlTdHJpbmcoc3RyMik7XG4gICAgICByZXR1cm4gZW1wdHkxICYmICFlbXB0eTIgfHwgIWVtcHR5MSAmJiBlbXB0eTI7XG4gICAgfVxuICB9O1xuXG4gIC8vIGRlZmluZSB2aXN1YWwgc3R5bGUgcHJvcGVydGllc1xuICAvL1xuICAvLyAtIG4uYi4gYWRkaW5nIGEgbmV3IGdyb3VwIG9mIHByb3BzIG1heSByZXF1aXJlIHVwZGF0ZXMgdG8gdXBkYXRlU3R5bGVIaW50cygpXG4gIC8vIC0gYWRkaW5nIG5ldyBwcm9wcyB0byBhbiBleGlzdGluZyBncm91cCBnZXRzIGhhbmRsZWQgYXV0b21hdGljYWxseVxuXG4gIHZhciB0ID0gc3R5Zm4kMi50eXBlcztcbiAgdmFyIG1haW5MYWJlbCA9IFt7XG4gICAgbmFtZTogJ2xhYmVsJyxcbiAgICB0eXBlOiB0LnRleHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmVtcHR5Tm9uRW1wdHlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgc291cmNlTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdzb3VyY2UtbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdGFyZ2V0TGFiZWwgPSBbe1xuICAgIG5hbWU6ICd0YXJnZXQtbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgbGFiZWxEaW1lbnNpb25zID0gW3tcbiAgICBuYW1lOiAnZm9udC1mYW1pbHknLFxuICAgIHR5cGU6IHQuZm9udEZhbWlseSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXN0eWxlJyxcbiAgICB0eXBlOiB0LmZvbnRTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXdlaWdodCcsXG4gICAgdHlwZTogdC5mb250V2VpZ2h0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtdHJhbnNmb3JtJyxcbiAgICB0eXBlOiB0LnRleHRUcmFuc2Zvcm0sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC13cmFwJyxcbiAgICB0eXBlOiB0LnRleHRXcmFwLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3ZlcmZsb3ctd3JhcCcsXG4gICAgdHlwZTogdC50ZXh0T3ZlcmZsb3dXcmFwLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWF4LXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1oZWlnaHQnLFxuICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgY29tbW9uTGFiZWwgPSBbe1xuICAgIG5hbWU6ICd0ZXh0LXZhbGlnbicsXG4gICAgdHlwZTogdC52YWxpZ24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1oYWxpZ24nLFxuICAgIHR5cGU6IHQuaGFsaWduLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLFxuICAgIHR5cGU6IHQudGV4dEJhY2tncm91bmRTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWp1c3RpZmljYXRpb24nLFxuICAgIHR5cGU6IHQuanVzdGlmaWNhdGlvblxuICB9LCB7XG4gICAgbmFtZTogJ2JveC1zZWxlY3QtbGFiZWxzJyxcbiAgICB0eXBlOiB0LmJvb2wsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgYmVoYXZpb3IgPSBbe1xuICAgIG5hbWU6ICdldmVudHMnLFxuICAgIHR5cGU6IHQuYm9vbCxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWV2ZW50cycsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JveC1zZWxlY3Rpb24nLFxuICAgIHR5cGU6IHQuYm94U2VsZWN0aW9uLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIHZpc2liaWxpdHkgPSBbe1xuICAgIG5hbWU6ICdkaXNwbGF5JyxcbiAgICB0eXBlOiB0LmRpc3BsYXksXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICB0cmlnZ2Vyc0JvdW5kc09mQ29ubmVjdGVkRWRnZXM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzOiBmdW5jdGlvbiB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxFZGdlcyhmcm9tVmFsdWUsIHRvVmFsdWUsIGVsZSkge1xuICAgICAgaWYgKGZyb21WYWx1ZSA9PT0gdG9WYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgaWYgZWRnZSBpcyBidW5kbGVkIGJlemllciAoc28gYXMgbm90IHRvIGFmZmVjdCBwZXJmb3JtYW5jZSBvZiBvdGhlciBlZGdlcylcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlID09PSAnYmV6aWVyJztcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAndmlzaWJpbGl0eScsXG4gICAgdHlwZTogdC52aXNpYmlsaXR5LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ29wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi56ZXJvTm9uWmVyb1xuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXpvb21lZC1mb250LXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ3otY29tcG91bmQtZGVwdGgnLFxuICAgIHR5cGU6IHQuekNvbXBvdW5kRGVwdGgsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnei1pbmRleC1jb21wYXJlJyxcbiAgICB0eXBlOiB0LnpJbmRleENvbXBhcmUsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnei1pbmRleCcsXG4gICAgdHlwZTogdC5udW1iZXIsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgb3ZlcmxheSA9IFt7XG4gICAgbmFtZTogJ292ZXJsYXktcGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ292ZXJsYXktY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi56ZXJvTm9uWmVyb1xuICB9LCB7XG4gICAgbmFtZTogJ292ZXJsYXktc2hhcGUnLFxuICAgIHR5cGU6IHQub3ZlcmxheVNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ292ZXJsYXktY29ybmVyLXJhZGl1cycsXG4gICAgdHlwZTogdC5jb3JuZXJSYWRpdXNcbiAgfV07XG4gIHZhciB1bmRlcmxheSA9IFt7XG4gICAgbmFtZTogJ3VuZGVybGF5LXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3VuZGVybGF5LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi56ZXJvTm9uWmVyb1xuICB9LCB7XG4gICAgbmFtZTogJ3VuZGVybGF5LXNoYXBlJyxcbiAgICB0eXBlOiB0Lm92ZXJsYXlTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd1bmRlcmxheS1jb3JuZXItcmFkaXVzJyxcbiAgICB0eXBlOiB0LmNvcm5lclJhZGl1c1xuICB9XTtcbiAgdmFyIHRyYW5zaXRpb24gPSBbe1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JyxcbiAgICB0eXBlOiB0LnByb3BMaXN0XG4gIH0sIHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsXG4gICAgdHlwZTogdC50aW1lXG4gIH0sIHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsXG4gICAgdHlwZTogdC50aW1lXG4gIH0sIHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAgIHR5cGU6IHQuZWFzaW5nXG4gIH1dO1xuICB2YXIgbm9kZVNpemVIYXNoT3ZlcnJpZGUgPSBmdW5jdGlvbiBub2RlU2l6ZUhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApIHtcbiAgICBpZiAocGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuIC1lbGUucG9vbEluZGV4KCk7IC8vIG5vIGhhc2gga2V5IGhpdHMgaXMgdXNpbmcgbGFiZWwgc2l6ZSAoaGl0cmF0ZSBmb3IgcGVyZiBwcm9iYWJseSBsb3cgYW55d2F5KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VkUHJvcC5wZlZhbHVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIG5vZGVCb2R5ID0gW3tcbiAgICBuYW1lOiAnaGVpZ2h0JyxcbiAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gIH0sIHtcbiAgICBuYW1lOiAnd2lkdGgnLFxuICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgfSwge1xuICAgIG5hbWU6ICdzaGFwZScsXG4gICAgdHlwZTogdC5ub2RlU2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2hhcGUtcG9seWdvbi1wb2ludHMnLFxuICAgIHR5cGU6IHQucG9seWdvblBvaW50TGlzdCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb3JuZXItcmFkaXVzJyxcbiAgICB0eXBlOiB0LmNvcm5lclJhZGl1c1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpbGwnLFxuICAgIHR5cGU6IHQuZmlsbFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJyxcbiAgICB0eXBlOiB0Lm5PbmVPbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5ncmFkaWVudERpcmVjdGlvblxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LnBhZGRpbmdSZWxhdGl2ZVRvLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JvdW5kcy1leHBhbnNpb24nLFxuICAgIHR5cGU6IHQuYm91bmRzRXhwYW5zaW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG5vZGVCb3JkZXIgPSBbe1xuICAgIG5hbWU6ICdib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLWNhcCcsXG4gICAgdHlwZTogdC5saW5lQ2FwXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLWpvaW4nLFxuICAgIHR5cGU6IHQubGluZUpvaW5cbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItZGFzaC1wYXR0ZXJuJyxcbiAgICB0eXBlOiB0Lm51bWJlcnNcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItZGFzaC1vZmZzZXQnLFxuICAgIHR5cGU6IHQubnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXBvc2l0aW9uJyxcbiAgICB0eXBlOiB0LmxpbmVQb3NpdGlvblxuICB9XTtcbiAgdmFyIG5vZGVPdXRsaW5lID0gW3tcbiAgICBuYW1lOiAnb3V0bGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ291dGxpbmUtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0bGluZS13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ291dGxpbmUtc3R5bGUnLFxuICAgIHR5cGU6IHQuYm9yZGVyU3R5bGVcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRsaW5lLW9mZnNldCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGJhY2tncm91bmRJbWFnZSA9IFt7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAgIHR5cGU6IHQudXJsc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLFxuICAgIHR5cGU6IHQuYmdDcm9zc09yaWdpblxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnLFxuICAgIHR5cGU6IHQuYmdDb250YWlubWVudFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJyxcbiAgICB0eXBlOiB0LmJvb2xzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgdHlwZTogdC5iZ1JlcGVhdFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZml0JyxcbiAgICB0eXBlOiB0LmJnRml0XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJyxcbiAgICB0eXBlOiB0LmJnQ2xpcFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLFxuICAgIHR5cGU6IHQuYmdXSFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LmJnV0hcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteScsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9XTtcbiAgdmFyIGNvbXBvdW5kID0gW3tcbiAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgIHR5cGU6IHQucG9zaXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLFxuICAgIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGVkZ2VMaW5lID0gW3tcbiAgICBuYW1lOiAnbGluZS1zdHlsZScsXG4gICAgdHlwZTogdC5saW5lU3R5bGVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNhcCcsXG4gICAgdHlwZTogdC5saW5lQ2FwXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWRhc2gtcGF0dGVybicsXG4gICAgdHlwZTogdC5udW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLW9mZnNldCcsXG4gICAgdHlwZTogdC5udW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLW91dGxpbmUtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtb3V0bGluZS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1jb2xvcnMnLFxuICAgIHR5cGU6IHQuY29sb3JzXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycsXG4gICAgdHlwZTogdC5wZXJjZW50YWdlc1xuICB9LCB7XG4gICAgbmFtZTogJ2N1cnZlLXN0eWxlJyxcbiAgICB0eXBlOiB0LmN1cnZlU3R5bGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzOiBmdW5jdGlvbiB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxFZGdlcyhmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgICAgIGlmIChmcm9tVmFsdWUgPT09IHRvVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBtdXN0IGhhdmUgZGlmZlxuXG4gICAgICByZXR1cm4gZnJvbVZhbHVlID09PSAnYmV6aWVyJyB8fFxuICAgICAgLy8gcmVtb3ZlIGZyb20gYnVuZGxlXG4gICAgICB0b1ZhbHVlID09PSAnYmV6aWVyJzsgLy8gYWRkIHRvIGJ1bmRsZVxuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdoYXlzdGFjay1yYWRpdXMnLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtZW5kcG9pbnQnLFxuICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC1lbmRwb2ludCcsXG4gICAgdHlwZTogdC5lZGdlRW5kcG9pbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJyxcbiAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtd2VpZ2h0cycsXG4gICAgdHlwZTogdC5udW1iZXJzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtcmFkaWknLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdyYWRpdXMtdHlwZScsXG4gICAgdHlwZTogdC5yYWRpdXNUeXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktdHVybicsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS1kaXJlY3Rpb24nLFxuICAgIHR5cGU6IHQuYXhpc0RpcmVjdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLXJhZGl1cycsXG4gICAgdHlwZTogdC5udW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuZWRnZURpc3RhbmNlcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1zY2FsZScsXG4gICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5hbmdsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLXN3ZWVwJyxcbiAgICB0eXBlOiB0LmFuZ2xlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgZ2hvc3QgPSBbe1xuICAgIG5hbWU6ICdnaG9zdCcsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9XTtcbiAgdmFyIGNvcmUgPSBbe1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfV07XG5cbiAgLy8gcGllIGJhY2tncm91bmRzIGZvciBub2Rlc1xuICB2YXIgcGllID0gW107XG4gIHN0eWZuJDIucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG4gIHBpZS5wdXNoKHtcbiAgICBuYW1lOiAncGllLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudFxuICB9KTtcbiAgcGllLnB1c2goe1xuICAgIG5hbWU6ICdwaWUtaG9sZScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gIH0pO1xuICBwaWUucHVzaCh7XG4gICAgbmFtZTogJ3BpZS1zdGFydC1hbmdsZScsXG4gICAgdHlwZTogdC5hbmdsZVxuICB9KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgcGllLnB1c2goe1xuICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSk7XG4gICAgcGllLnB1c2goe1xuICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJyxcbiAgICAgIHR5cGU6IHQucGVyY2VudFxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0cmlwZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcbiAgdmFyIHN0cmlwZSA9IFtdO1xuICBzdHlmbiQyLnN0cmlwZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHN0cmlwZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICBzdHJpcGUucHVzaCh7XG4gICAgbmFtZTogJ3N0cmlwZS1zaXplJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnRcbiAgfSk7XG4gIHN0cmlwZS5wdXNoKHtcbiAgICBuYW1lOiAnc3RyaXBlLWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5heGlzRGlyZWN0aW9uUHJpbWFyeVxuICB9KTtcbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8PSBzdHlmbiQyLnN0cmlwZUJhY2tncm91bmROOyBfaSsrKSB7XG4gICAgc3RyaXBlLnB1c2goe1xuICAgICAgbmFtZTogJ3N0cmlwZS0nICsgX2kgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0pO1xuICAgIHN0cmlwZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdzdHJpcGUtJyArIF9pICsgJy1iYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgdHlwZTogdC5wZXJjZW50XG4gICAgfSk7XG4gICAgc3RyaXBlLnB1c2goe1xuICAgICAgbmFtZTogJ3N0cmlwZS0nICsgX2kgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGVkZ2UgYXJyb3dzXG4gIHZhciBlZGdlQXJyb3cgPSBbXTtcbiAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbiQyLmFycm93UHJlZml4ZXMgPSBbJ3NvdXJjZScsICdtaWQtc291cmNlJywgJ3RhcmdldCcsICdtaWQtdGFyZ2V0J107XG4gIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB0eXBlOiB0LmFycm93U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB0eXBlOiB0LmFycm93RmlsbFxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LXdpZHRoJyxcbiAgICB0eXBlOiB0LmFycm93V2lkdGhcbiAgfV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgIHZhciB0eXBlID0gcHJvcC50eXBlLFxuICAgICAgICB0cmlnZ2Vyc0JvdW5kcyA9IHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gICAgICBlZGdlQXJyb3cucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRyaWdnZXJzQm91bmRzOiB0cmlnZ2Vyc0JvdW5kc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIHt9KTtcbiAgdmFyIHByb3BzID0gc3R5Zm4kMi5wcm9wZXJ0aWVzID0gW10uY29uY2F0KGJlaGF2aW9yLCB0cmFuc2l0aW9uLCB2aXNpYmlsaXR5LCBvdmVybGF5LCB1bmRlcmxheSwgZ2hvc3QsIGNvbW1vbkxhYmVsLCBsYWJlbERpbWVuc2lvbnMsIG1haW5MYWJlbCwgc291cmNlTGFiZWwsIHRhcmdldExhYmVsLCBub2RlQm9keSwgbm9kZUJvcmRlciwgbm9kZU91dGxpbmUsIGJhY2tncm91bmRJbWFnZSwgcGllLCBzdHJpcGUsIGNvbXBvdW5kLCBlZGdlTGluZSwgZWRnZUFycm93LCBjb3JlKTtcbiAgdmFyIHByb3BHcm91cHMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBzID0ge1xuICAgIC8vIGNvbW1vbiB0byBhbGwgZWxlc1xuICAgIGJlaGF2aW9yOiBiZWhhdmlvcixcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgIHZpc2liaWxpdHk6IHZpc2liaWxpdHksXG4gICAgb3ZlcmxheTogb3ZlcmxheSxcbiAgICB1bmRlcmxheTogdW5kZXJsYXksXG4gICAgZ2hvc3Q6IGdob3N0LFxuICAgIC8vIGxhYmVsc1xuICAgIGNvbW1vbkxhYmVsOiBjb21tb25MYWJlbCxcbiAgICBsYWJlbERpbWVuc2lvbnM6IGxhYmVsRGltZW5zaW9ucyxcbiAgICBtYWluTGFiZWw6IG1haW5MYWJlbCxcbiAgICBzb3VyY2VMYWJlbDogc291cmNlTGFiZWwsXG4gICAgdGFyZ2V0TGFiZWw6IHRhcmdldExhYmVsLFxuICAgIC8vIG5vZGUgcHJvcHNcbiAgICBub2RlQm9keTogbm9kZUJvZHksXG4gICAgbm9kZUJvcmRlcjogbm9kZUJvcmRlcixcbiAgICBub2RlT3V0bGluZTogbm9kZU91dGxpbmUsXG4gICAgYmFja2dyb3VuZEltYWdlOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgcGllOiBwaWUsXG4gICAgc3RyaXBlOiBzdHJpcGUsXG4gICAgY29tcG91bmQ6IGNvbXBvdW5kLFxuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICBlZGdlTGluZTogZWRnZUxpbmUsXG4gICAgZWRnZUFycm93OiBlZGdlQXJyb3csXG4gICAgY29yZTogY29yZVxuICB9O1xuICB2YXIgcHJvcEdyb3VwTmFtZXMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBOYW1lcyA9IHt9O1xuICB2YXIgcHJvcEdyb3VwS2V5cyA9IHN0eWZuJDIucHJvcGVydHlHcm91cEtleXMgPSBPYmplY3Qua2V5cyhwcm9wR3JvdXBzKTtcbiAgcHJvcEdyb3VwS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBwcm9wR3JvdXBOYW1lc1trZXldID0gcHJvcEdyb3Vwc1trZXldLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AubmFtZTtcbiAgICB9KTtcbiAgICBwcm9wR3JvdXBzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AuZ3JvdXBLZXkgPSBrZXk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGRlZmluZSBhbGlhc2VzXG4gIHZhciBhbGlhc2VzID0gc3R5Zm4kMi5hbGlhc2VzID0gW3tcbiAgICBuYW1lOiAnY29udGVudCcsXG4gICAgcG9pbnRzVG86ICdsYWJlbCdcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJyxcbiAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJ1xuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JyxcbiAgICBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cydcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlJyxcbiAgICBwb2ludHNUbzogJ3NlZ21lbnQtZGlzdGFuY2VzJ1xuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtd2VpZ2h0JyxcbiAgICBwb2ludHNUbzogJ3NlZ21lbnQtd2VpZ2h0cydcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LXJhZGl1cycsXG4gICAgcG9pbnRzVG86ICdzZWdtZW50LXJhZGlpJ1xuICB9LCB7XG4gICAgbmFtZTogJ2VkZ2UtdGV4dC1yb3RhdGlvbicsXG4gICAgcG9pbnRzVG86ICd0ZXh0LXJvdGF0aW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctbGVmdCcsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctcmlnaHQnLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXRvcCcsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctYm90dG9tJyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH1dO1xuXG4gIC8vIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgc3R5Zm4kMi5wcm9wZXJ0eU5hbWVzID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAubmFtZTtcbiAgfSk7XG5cbiAgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tfaTJdO1xuICAgIHByb3BzW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG5cbiAgLy8gbWFwIGFsaWFzZXNcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgYWxpYXNlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIGFsaWFzID0gYWxpYXNlc1tfaTNdO1xuICAgIHZhciBwb2ludHNUb1Byb3AgPSBwcm9wc1thbGlhcy5wb2ludHNUb107XG4gICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICBhbGlhczogdHJ1ZSxcbiAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFsaWFzIHByb3AgZm9yIHBhcnNpbmdcbiAgICBwcm9wcy5wdXNoKGFsaWFzUHJvcCk7XG4gICAgcHJvcHNbYWxpYXMubmFtZV0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cbn0pKCk7XG5zdHlmbiQyLmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbbmFtZV07XG59O1xuc3R5Zm4kMi5nZXREZWZhdWx0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgaWYgKF9wLmRlZmF1bHRQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICByZXR1cm4gX3AuZGVmYXVsdFByb3BlcnRpZXM7XG4gIH1cbiAgdmFyIHJhd1Byb3BzID0gZXh0ZW5kKHtcbiAgICAvLyBjb3JlIHByb3BzXG4gICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1LFxuICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAndGV4dC1qdXN0aWZpY2F0aW9uJzogJ2F1dG8nLFxuICAgICdsaW5lLWhlaWdodCc6IDEsXG4gICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICdib3gtc2VsZWN0aW9uJzogJ2NvbnRhaW4nLFxuICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAndGV4dC13cmFwJzogJ25vbmUnLFxuICAgICd0ZXh0LW92ZXJmbG93LXdyYXAnOiAnd2hpdGVzcGFjZScsXG4gICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgJ3RleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd0YXJnZXQtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAnb3BhY2l0eSc6IDEsXG4gICAgJ3otY29tcG91bmQtZGVwdGgnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgtY29tcGFyZSc6ICdhdXRvJyxcbiAgICAnei1pbmRleCc6IDAsXG4gICAgJ2xhYmVsJzogJycsXG4gICAgJ3RleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnc291cmNlLWxhYmVsJzogJycsXG4gICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAwLFxuICAgICd0YXJnZXQtbGFiZWwnOiAnJyxcbiAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICdvdmVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgJ292ZXJsYXktY29ybmVyLXJhZGl1cyc6ICdhdXRvJyxcbiAgICAndW5kZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ3VuZGVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICd1bmRlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ3VuZGVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgJ3VuZGVybGF5LWNvcm5lci1yYWRpdXMnOiAnYXV0bycsXG4gICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcbiAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nOiAnbGluZWFyJyxcbiAgICAnYm94LXNlbGVjdC1sYWJlbHMnOiAnbm8nLFxuICAgIC8vIG5vZGUgcHJvcHNcbiAgICAnYmFja2dyb3VuZC1ibGFja2VuJzogMCxcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjOTk5JyxcbiAgICAnYmFja2dyb3VuZC1maWxsJzogJ3NvbGlkJyxcbiAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbic6ICdhbm9ueW1vdXMnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknOiAxLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JzogJ2luc2lkZScsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJzogJ3llcycsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1vZmZzZXQteCc6IDAsXG4gICAgJ2JhY2tncm91bmQtb2Zmc2V0LXknOiAwLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnYm9yZGVyLWRhc2gtcGF0dGVybic6IFs0LCAyXSxcbiAgICAnYm9yZGVyLWRhc2gtb2Zmc2V0JzogMCxcbiAgICAnYm9yZGVyLWNhcCc6ICdidXR0JyxcbiAgICAnYm9yZGVyLWpvaW4nOiAnbWl0ZXInLFxuICAgICdib3JkZXItcG9zaXRpb24nOiAnY2VudGVyJyxcbiAgICAnb3V0bGluZS1jb2xvcic6ICcjOTk5JyxcbiAgICAnb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAnb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ291dGxpbmUtb2Zmc2V0JzogMCxcbiAgICAnb3V0bGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2hlaWdodCc6IDMwLFxuICAgICd3aWR0aCc6IDMwLFxuICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiAnLTEsIC0xLCAgIDEsIC0xLCAgIDEsIDEsICAgLTEsIDEnLFxuICAgICdjb3JuZXItcmFkaXVzJzogJ2F1dG8nLFxuICAgICdib3VuZHMtZXhwYW5zaW9uJzogMCxcbiAgICAvLyBub2RlIGdyYWRpZW50XG4gICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJzogJ3RvLWJvdHRvbScsXG4gICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgIC8vIGdob3N0IHByb3BzXG4gICAgJ2dob3N0JzogJ25vJyxcbiAgICAnZ2hvc3Qtb2Zmc2V0LXknOiAwLFxuICAgICdnaG9zdC1vZmZzZXQteCc6IDAsXG4gICAgJ2dob3N0LW9wYWNpdHknOiAwLFxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgJ3BhZGRpbmcnOiAwLFxuICAgICdwYWRkaW5nLXJlbGF0aXZlLXRvJzogJ3dpZHRoJyxcbiAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnOiAnaW5jbHVkZScsXG4gICAgJ21pbi13aWR0aCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLWxlZnQnOiAwLFxuICAgICdtaW4td2lkdGgtYmlhcy1yaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtdG9wJzogMCxcbiAgICAnbWluLWhlaWdodC1iaWFzLWJvdHRvbSc6IDBcbiAgfSwge1xuICAgIC8vIG5vZGUgcGllIGJnXG4gICAgJ3BpZS1zaXplJzogJzEwMCUnLFxuICAgICdwaWUtaG9sZSc6IDAsXG4gICAgJ3BpZS1zdGFydC1hbmdsZSc6ICcwZGVnJ1xuICB9LCBbe1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdmFsdWU6ICdibGFjaydcbiAgfSwge1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1zaXplJyxcbiAgICB2YWx1ZTogJzAlJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHZhbHVlOiAxXG4gIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCd7e2l9fScsIGkpO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSwge1xuICAgIC8vIG5vZGUgc3RyaXBlcyBiZ1xuICAgICdzdHJpcGUtc2l6ZSc6ICcxMDAlJyxcbiAgICAnc3RyaXBlLWRpcmVjdGlvbic6ICdob3Jpem9udGFsJ1xuICB9LCBbe1xuICAgIG5hbWU6ICdzdHJpcGUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdmFsdWU6ICdibGFjaydcbiAgfSwge1xuICAgIG5hbWU6ICdzdHJpcGUte3tpfX0tYmFja2dyb3VuZC1zaXplJyxcbiAgICB2YWx1ZTogJzAlJ1xuICB9LCB7XG4gICAgbmFtZTogJ3N0cmlwZS17e2l9fS1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHZhbHVlOiAxXG4gIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kMi5zdHJpcGVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCd7e2l9fScsIGkpO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSwge1xuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ2xpbmUtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY2FwJzogJ2J1dHQnLFxuICAgICdsaW5lLW9wYWNpdHknOiAxLFxuICAgICdsaW5lLW91dGxpbmUtd2lkdGgnOiAwLFxuICAgICdsaW5lLW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnOiAnMCUnLFxuICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICdjb250cm9sLXBvaW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAnc2VnbWVudC1yYWRpaSc6IDE1LFxuICAgICdyYWRpdXMtdHlwZSc6ICdhcmMtcmFkaXVzJyxcbiAgICAndGF4aS10dXJuJzogJzUwJScsXG4gICAgJ3RheGktcmFkaXVzJzogMTUsXG4gICAgJ3RheGktdHVybi1taW4tZGlzdGFuY2UnOiAxMCxcbiAgICAndGF4aS1kaXJlY3Rpb24nOiAnYXV0bycsXG4gICAgJ2VkZ2UtZGlzdGFuY2VzJzogJ2ludGVyc2VjdGlvbicsXG4gICAgJ2N1cnZlLXN0eWxlJzogJ2hheXN0YWNrJyxcbiAgICAnaGF5c3RhY2stcmFkaXVzJzogMCxcbiAgICAnYXJyb3ctc2NhbGUnOiAxLFxuICAgICdsb29wLWRpcmVjdGlvbic6ICctNDVkZWcnLFxuICAgICdsb29wLXN3ZWVwJzogJy05MGRlZycsXG4gICAgJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICdsaW5lLWRhc2gtcGF0dGVybic6IFs2LCAzXSxcbiAgICAnbGluZS1kYXNoLW9mZnNldCc6IDBcbiAgfSwgW3tcbiAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgIHZhbHVlOiAnbm9uZSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgdmFsdWU6ICcjOTk5J1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgIHZhbHVlOiAnZmlsbGVkJ1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LXdpZHRoJyxcbiAgICB2YWx1ZTogMVxuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIHN0eWZuJDIuYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pKTtcbiAgdmFyIHBhcnNlZFByb3BzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbaV07XG4gICAgaWYgKHByb3AucG9pbnRzVG8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICB2YXIgdmFsID0gcmF3UHJvcHNbbmFtZV07XG4gICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbCk7XG4gICAgcGFyc2VkUHJvcHNbbmFtZV0gPSBwYXJzZWRQcm9wO1xuICB9XG4gIF9wLmRlZmF1bHRQcm9wZXJ0aWVzID0gcGFyc2VkUHJvcHM7XG4gIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbn07XG5zdHlmbiQyLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbGVjdG9yKCc6cGFyZW50JykuY3NzKHtcbiAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAncGFkZGluZyc6IDEwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNlZWUnLFxuICAgICdib3JkZXItY29sb3InOiAnI2NjYycsXG4gICAgJ2JvcmRlci13aWR0aCc6IDFcbiAgfSkuc2VsZWN0b3IoJ2VkZ2UnKS5jc3Moe1xuICAgICd3aWR0aCc6IDNcbiAgfSkuc2VsZWN0b3IoJzpsb29wJykuY3NzKHtcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJ1xuICB9KS5zZWxlY3RvcignZWRnZTpjb21wb3VuZCcpLmNzcyh7XG4gICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJ1xuICB9KS5zZWxlY3RvcignOnNlbGVjdGVkJykuY3NzKHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbGluZS1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOSdcbiAgfSkuc2VsZWN0b3IoJzpwYXJlbnQ6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNDQ0UxRjknLFxuICAgICdib3JkZXItY29sb3InOiAnI2FlYzhlNSdcbiAgfSkuc2VsZWN0b3IoJzphY3RpdmUnKS5jc3Moe1xuICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgfSk7XG4gIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xufTtcblxudmFyIHN0eWZuJDEgPSB7fTtcblxuLy8gYSBjYWNoaW5nIGxheWVyIGZvciBwcm9wZXJ0eSBwYXJzaW5nXG5zdHlmbiQxLnBhcnNlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGZ1bmN0aW9uIHZhbHVlcyBjYW4ndCBiZSBjYWNoZWQgaW4gYWxsIGNhc2VzLCBhbmQgdGhlcmUgaXNuJ3QgbXVjaCBiZW5lZml0IG9mIGNhY2hpbmcgdGhlbSBhbnl3YXlcbiAgaWYgKGZuJDYodmFsdWUpKSB7XG4gICAgcmV0dXJuIHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfVxuICB2YXIgZmxhdEtleSA9IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJyB8fCBwcm9wSXNGbGF0ID09PSB0cnVlIHx8IHByb3BJc0ZsYXQgPT09IGZhbHNlIHx8IHByb3BJc0ZsYXQgPT0gbnVsbCA/ICdkb250Y2FyZScgOiBwcm9wSXNGbGF0O1xuICB2YXIgYnlwYXNzS2V5ID0gcHJvcElzQnlwYXNzID8gJ3QnIDogJ2YnO1xuICB2YXIgdmFsdWVLZXkgPSAnJyArIHZhbHVlO1xuICB2YXIgYXJnSGFzaCA9IGhhc2hTdHJpbmdzKG5hbWUsIHZhbHVlS2V5LCBieXBhc3NLZXksIGZsYXRLZXkpO1xuICB2YXIgcHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSB8fCBbXTtcbiAgdmFyIHJldDtcbiAgaWYgKCEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSkge1xuICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfVxuXG4gIC8vIC0gYnlwYXNzZXMgY2FuJ3QgYmUgc2hhcmVkIGIvYyB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgYnkgYW5pbWF0aW9ucyBvciBvdGhlcndpc2Ugb3ZlcnJpZGRlblxuICAvLyAtIG1hcHBpbmdzIGNhbid0IGJlIHNoYXJlZCBiL2MgbWFwcGluZ3MgYXJlIHBlci1lbGVtZW50XG4gIGlmIChwcm9wSXNCeXBhc3MgfHwgcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnKSB7XG4gICAgLy8gbmVlZCBhIGNvcHkgc2luY2UgcHJvcHMgYXJlIG11dGF0ZWQgbGF0ZXIgaW4gdGhlaXIgbGlmZWN5Y2xlc1xuICAgIHJldCA9IGNvcHkocmV0KTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXQudmFsdWUgPSBjb3B5KHJldC52YWx1ZSk7IC8vIGJlY2F1c2UgaXQgY291bGQgYmUgYW4gYXJyYXksIGUuZy4gY29sb3VyXG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuc3R5Zm4kMS5wYXJzZUltcGxXYXJuID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnBhcnNlSW1wbChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgaWYgKCFwcm9wICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICB3YXJuKFwiVGhlIHN0eWxlIHByb3BlcnR5IGBcIi5jb25jYXQobmFtZSwgXCI6IFwiKS5jb25jYXQodmFsdWUsIFwiYCBpcyBpbnZhbGlkXCIpKTtcbiAgfVxuICBpZiAocHJvcCAmJiAocHJvcC5uYW1lID09PSAnd2lkdGgnIHx8IHByb3AubmFtZSA9PT0gJ2hlaWdodCcpICYmIHZhbHVlID09PSAnbGFiZWwnKSB7XG4gICAgd2FybignVGhlIHN0eWxlIHZhbHVlIG9mIGBsYWJlbGAgaXMgZGVwcmVjYXRlZCBmb3IgYCcgKyBwcm9wLm5hbWUgKyAnYCcpO1xuICB9XG4gIHJldHVybiBwcm9wO1xufTtcblxuLy8gcGFyc2UgYSBwcm9wZXJ0eTsgcmV0dXJuIG51bGwgb24gaW52YWxpZDsgcmV0dXJuIHBhcnNlZCBwcm9wZXJ0eSBvdGhlcndpc2Vcbi8vIGZpZWxkcyA6XG4vLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gdmFsdWUgOiB0aGUgcGFyc2VkLCBuYXRpdmUtdHlwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3Ncbi8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG5zdHlmbiQxLnBhcnNlSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgbmFtZSBpcyBpbiBkYXNoIGZvcm0gKGUuZy4gJ3Byb3BlcnR5LW5hbWUnIG5vdCAncHJvcGVydHlOYW1lJylcblxuICB2YXIgcHJvcGVydHkgPSBzZWxmLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciBwYXNzZWRWYWx1ZSA9IHZhbHVlO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICBpZiAoIXByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gcmV0dXJuIG51bGwgb24gcHJvcGVydHkgb2YgdW5rbm93biBuYW1lXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gY2FuJ3QgYXNzaWduIHVuZGVmaW5lZFxuXG4gIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcbiAgaWYgKHByb3BlcnR5LmFsaWFzKSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5wb2ludHNUbztcbiAgICBuYW1lID0gcHJvcGVydHkubmFtZTtcbiAgfVxuICB2YXIgdmFsdWVJc1N0cmluZyA9IHN0cmluZyh2YWx1ZSk7XG4gIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuXG4gIC8vIGNoZWNrIGlmIGJ5cGFzcyBpcyBudWxsIG9yIGVtcHR5IHN0cmluZyAoaS5lLiBpbmRpY2F0aW9uIHRvIGRlbGV0ZSBieXBhc3MgcHJvcGVydHkpXG4gIGlmIChwcm9wSXNCeXBhc3MgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgIGRlbGV0ZUJ5cGFzczogdHJ1ZVxuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHVzZWQgYXMgYSBtYXBwZXJcbiAgaWYgKGZuJDYodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJ2ZuJyxcbiAgICAgIG1hcHBlZDogdHlwZXMuZm4sXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcbiAgdmFyIGRhdGEsIG1hcERhdGE7XG4gIGlmICghdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0IHx8IHZhbHVlLmxlbmd0aCA8IDcgfHwgdmFsdWVbMV0gIT09ICdhJykgOyBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gNyAmJiB2YWx1ZVswXSA9PT0gJ2QnICYmIChkYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5kYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgdmFyIG1hcHBlZCA9IHR5cGVzLmRhdGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gMTAgJiYgdmFsdWVbMF0gPT09ICdtJyAmJiAobWFwRGF0YSA9IG5ldyBSZWdFeHAodHlwZXMubWFwRGF0YS5yZWdleCkuZXhlYyh2YWx1ZSkpKSB7XG4gICAgaWYgKHByb3BJc0J5cGFzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcbiAgICBpZiAodHlwZS5tdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cbiAgICB2YXIgX21hcHBlZCA9IHR5cGVzLm1hcERhdGE7XG5cbiAgICAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcbiAgICBpZiAoISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmFsdWVNaW4gPSB0aGlzLnBhcnNlKG5hbWUsIG1hcERhdGFbNF0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgIGlmICghdmFsdWVNaW4gfHwgdmFsdWVNaW4ubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiAoIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcbiAgICBpZiAodmFsdWVNaW4ucGZWYWx1ZSA9PT0gdmFsdWVNYXgucGZWYWx1ZSB8fCB2YWx1ZU1pbi5zdHJWYWx1ZSA9PT0gdmFsdWVNYXguc3RyVmFsdWUpIHtcbiAgICAgIHdhcm4oJ2AnICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICdgIGlzIG5vdCBhIHZhbGlkIG1hcHBlciBiZWNhdXNlIHRoZSBvdXRwdXQgcmFuZ2UgaXMgemVybzsgY29udmVydGluZyB0byBgJyArIG5hbWUgKyAnOiAnICsgdmFsdWVNaW4uc3RyVmFsdWUgKyAnYCcpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2UobmFtZSwgdmFsdWVNaW4uc3RyVmFsdWUpOyAvLyBjYW4ndCBtYWtlIG11Y2ggb2YgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICB2YXIgYzEgPSB2YWx1ZU1pbi52YWx1ZTtcbiAgICAgIHZhciBjMiA9IHZhbHVlTWF4LnZhbHVlO1xuICAgICAgdmFyIHNhbWUgPSBjMVswXSA9PT0gYzJbMF0gLy8gcmVkXG4gICAgICAmJiBjMVsxXSA9PT0gYzJbMV0gLy8gZ3JlZW5cbiAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAmJiAoXG4gICAgICAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgIHx8IChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICApICYmIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgKTtcbiAgICAgIGlmIChzYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gY2FuJ3QgbWFrZSBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBfbWFwcGVkLFxuICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdChtYXBEYXRhWzJdKSxcbiAgICAgIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQobWFwRGF0YVszXSksXG4gICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGUubXVsdGlwbGUgJiYgcHJvcElzRmxhdCAhPT0gJ211bHRpcGxlJykge1xuICAgIHZhciB2YWxzO1xuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICB2YWxzID0gdmFsdWUuc3BsaXQoL1xccysvKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHZhbHVlKSkge1xuICAgICAgdmFscyA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxzID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB2YWxBcnIgPSBbXTtcbiAgICB2YXIgdW5pdHNBcnIgPSBbXTtcbiAgICB2YXIgcGZWYWxBcnIgPSBbXTtcbiAgICB2YXIgc3RyVmFsID0gJyc7XG4gICAgdmFyIGhhc0VudW0gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gc2VsZi5wYXJzZShuYW1lLCB2YWxzW2ldLCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScpO1xuICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgc3RyaW5nKHAudmFsdWUpO1xuICAgICAgdmFsQXJyLnB1c2gocC52YWx1ZSk7XG4gICAgICBwZlZhbEFyci5wdXNoKHAucGZWYWx1ZSAhPSBudWxsID8gcC5wZlZhbHVlIDogcC52YWx1ZSk7XG4gICAgICB1bml0c0Fyci5wdXNoKHAudW5pdHMpO1xuICAgICAgc3RyVmFsICs9IChpID4gMCA/ICcgJyA6ICcnKSArIHAuc3RyVmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlLnZhbGlkYXRlICYmICF0eXBlLnZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGUuc2luZ2xlRW51bSAmJiBoYXNFbnVtKSB7XG4gICAgICBpZiAodmFsQXJyLmxlbmd0aCA9PT0gMSAmJiBzdHJpbmcodmFsQXJyWzBdKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICBzdHJWYWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsQXJyLFxuICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICBzdHJWYWx1ZTogc3RyVmFsLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdW5pdHNBcnJcbiAgICB9O1xuICB9XG5cbiAgLy8gc2V2ZXJhbCB0eXBlcyBhbHNvIGFsbG93IGVudW1zXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuICAgICAgaWYgKGVuID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8vIGNoZWNrIHRoZSB0eXBlIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG9iamVjdFxuICBpZiAodHlwZS5udW1iZXIpIHtcbiAgICB2YXIgdW5pdHM7XG4gICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICBpZiAodHlwZS51bml0cykge1xuICAgICAgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICB9XG4gICAgaWYgKCF0eXBlLnVuaXRsZXNzKSB7XG4gICAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHNSZWdleCA9IHVuaXRzO1xuICAgICAgICB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCdeKCcgKyBudW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdW5pdHMgfHwgdHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuICAgIGlmIChpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuICAgIGlmIChpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcbiAgICBpZiAodHlwZS5pbnRlZ2VyICYmICFpbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG4gICAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlIDwgdHlwZS5taW4gfHwgdHlwZS5zdHJpY3RNaW4gJiYgdmFsdWUgPT09IHR5cGUubWluKSB8fCB0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA+IHR5cGUubWF4IHx8IHR5cGUuc3RyaWN0TWF4ICYmIHZhbHVlID09PSB0eXBlLm1heCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlICsgKHVuaXRzID8gdW5pdHMgOiAnJyksXG4gICAgICB1bml0czogdW5pdHMsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG4gICAgaWYgKHR5cGUudW5pdGxlc3MgfHwgdW5pdHMgIT09ICdweCcgJiYgdW5pdHMgIT09ICdlbScpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdweCcgfHwgIXVuaXRzID8gdmFsdWUgOiB0aGlzLmdldEVtU2l6ZUluUGl4ZWxzKCkgKiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcbiAgICBpZiAodW5pdHMgPT09ICdtcycgfHwgdW5pdHMgPT09ICdzJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ21zJyA/IHZhbHVlIDogMTAwMCAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiByYWRcbiAgICBpZiAodW5pdHMgPT09ICdkZWcnIHx8IHVuaXRzID09PSAncmFkJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3JhZCcgPyB2YWx1ZSA6IGRlZzJyYWQodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSB2YWx1ZSBpbiAlXG4gICAgaWYgKHVuaXRzID09PSAnJScpIHtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWUgLyAxMDA7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSBpZiAodHlwZS5wcm9wTGlzdCkge1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG4gICAgaWYgKHByb3BzU3RyID09PSAnbm9uZScpIDsgZWxzZSB7XG4gICAgICAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuXG4gICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KC9cXHMqLFxccyp8XFxzKy8pO1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcHNTcGxpdC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbX2kyXS50cmltKCk7XG4gICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybignYCcgKyBwcm9wTmFtZSArICdgIGlzIG5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICBzdHJWYWx1ZTogcHJvcHMubGVuZ3RoID09PSAwID8gJ25vbmUnIDogcHJvcHMuam9pbignICcpLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICB2YXIgdHVwbGUgPSBjb2xvcjJ0dXBsZSh2YWx1ZSk7XG4gICAgaWYgKCF0dXBsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHR1cGxlLFxuICAgICAgcGZWYWx1ZTogdHVwbGUsXG4gICAgICBzdHJWYWx1ZTogJ3JnYignICsgdHVwbGVbMF0gKyAnLCcgKyB0dXBsZVsxXSArICcsJyArIHR1cGxlWzJdICsgJyknLFxuICAgICAgLy8gbi5iLiBubyBzcGFjZXMgYi9jIG9mIG11bHRpcGxlIHN1cHBvcnRcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLnJlZ2V4IHx8IHR5cGUucmVnZXhlcykge1xuICAgIC8vIGZpcnN0IGNoZWNrIGVudW1zXG4gICAgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAgIHZhciBlbnVtUHJvcCA9IGNoZWNrRW51bXMoKTtcbiAgICAgIGlmIChlbnVtUHJvcCkge1xuICAgICAgICByZXR1cm4gZW51bVByb3A7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZWdleGVzID0gdHlwZS5yZWdleGVzID8gdHlwZS5yZWdleGVzIDogW3R5cGUucmVnZXhdO1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHJlZ2V4ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleGVzW19pM10pOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZSBzdHJpbmdcbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobSkge1xuICAgICAgICAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdHlwZS5zaW5nbGVSZWdleE1hdGNoVmFsdWUgPyBtWzFdIDogbSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIGFueVxuICB9IGVsc2UgaWYgKHR5cGUuc3RyaW5nKSB7XG4gICAgLy8ganVzdCByZXR1cm5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5lbnVtcykge1xuICAgIC8vIGNoZWNrIGVudW1zIGxhc3QgYmVjYXVzZSBpdCdzIGEgY29tYm8gdHlwZSBpbiBvdGhlcnNcbiAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsOyAvLyBub3QgYSB0eXBlIHdlIGNhbiBoYW5kbGVcbiAgfVxufTtcblxudmFyIF9TdHlsZSA9IGZ1bmN0aW9uIFN0eWxlKGN5KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfU3R5bGUpKSB7XG4gICAgcmV0dXJuIG5ldyBfU3R5bGUoY3kpO1xuICB9XG4gIGlmICghY29yZShjeSkpIHtcbiAgICBlcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBjb3JlU3R5bGU6IHt9XG4gIH07XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5yZXNldFRvRGVmYXVsdCgpO1xufTtcbnZhciBzdHlmbiA9IF9TdHlsZS5wcm90b3R5cGU7XG5zdHlmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZSc7XG59O1xuXG4vLyByZW1vdmUgYWxsIGNvbnRleHRzXG5zdHlmbi5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgdmFyIGN5ID0gX3AuY3k7XG4gIHZhciBlbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLmxlbmd0aCA9IDA7XG4gIF9wLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgX3AucHJvcERpZmZzID0ge307XG4gIHRoaXMuY2xlYW5FbGVtZW50cyhlbGVzLCB0cnVlKTtcbiAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgZWxlX3AgPSBlbGVbMF0uX3ByaXZhdGU7XG4gICAgZWxlX3Auc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgZWxlX3AuYXBwbGllZEluaXRTdHlsZSA9IGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3Rvclxuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcE5hbWVdIHx8IHRoaXMuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BOYW1lKTtcbn07XG5cbi8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcbnN0eWZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yU3RyKSB7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgdGhpc1tpXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW10sXG4gICAgbWFwcGVkUHJvcGVydGllczogW10sXG4gICAgaW5kZXg6IGlcbiAgfTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBhZGQgb25lIG9yIG1hbnkgY3NzIHJ1bGVzIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG1hcCA9IGFyZ3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtwcm9wLm5hbWVdO1xuICAgICAgaWYgKG1hcFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1hcFZhbCA9IG1hcFtkYXNoMmNhbWVsKHByb3AubmFtZSldO1xuICAgICAgfVxuICAgICAgaWYgKG1hcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY3NzUnVsZShwcm9wLm5hbWUsIG1hcFZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5jc3NSdWxlKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9XG5cbiAgLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuc3R5Zm4uc3R5bGUgPSBzdHlmbi5jc3M7XG5cbi8vIGFkZCBhIHNpbmdsZSBjc3MgcnVsZSB0byB0aGUgY3VycmVudCBjb250ZXh0XG5zdHlmbi5jc3NSdWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIC8vIG5hbWUtdmFsdWUgcGFpclxuICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlKTtcblxuICAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXNbcHJvcGVydHkubmFtZV0gPSBwcm9wZXJ0eTsgLy8gYWxsb3cgYWNjZXNzIGJ5IG5hbWUgYXMgd2VsbFxuXG4gICAgaWYgKHByb3BlcnR5Lm5hbWUubWF0Y2goL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLykgJiYgcHJvcGVydHkudmFsdWUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuaGFzUGllID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5Lm5hbWUubWF0Y2goL3N0cmlwZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLykgJiYgcHJvcGVydHkudmFsdWUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuaGFzU3RyaXBlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5Lm1hcHBlZCkge1xuICAgICAgdGhpc1tpXS5tYXBwZWRQcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0byBjb3JlIHN0eWxlIGlmIG5lY2Vzc2FyeVxuICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcbiAgICBpZiAoY3VycmVudFNlbGVjdG9ySXNDb3JlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zdHlmbi5hcHBlbmQgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgc3R5bGUuYXBwZW5kVG9TdHlsZSh0aGlzKTtcbiAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21Kc29uKHN0eWxlKTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgdGhpcy5hcHBlbmRGcm9tU3RyaW5nKHN0eWxlKTtcbiAgfSAvLyB5b3UgcHJvYmFibHkgd291bGRuJ3Qgd2FudCB0byBhcHBlbmQgYSBTdHlsZSwgc2luY2UgeW91J2QgZHVwbGljYXRlIHRoZSBkZWZhdWx0IHBhcnRzXG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzdGF0aWMgZnVuY3Rpb25cbl9TdHlsZS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChjeSwganNvbikge1xuICB2YXIgc3R5bGUgPSBuZXcgX1N0eWxlKGN5KTtcbiAgc3R5bGUuZnJvbUpzb24oanNvbik7XG4gIHJldHVybiBzdHlsZTtcbn07XG5fU3R5bGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChjeSwgc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgX1N0eWxlKGN5KS5mcm9tU3RyaW5nKHN0cmluZyk7XG59O1xuW3N0eWZuJDgsIHN0eWZuJDcsIHN0eWZuJDYsIHN0eWZuJDUsIHN0eWZuJDQsIHN0eWZuJDMsIHN0eWZuJDIsIHN0eWZuJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChzdHlmbiwgcHJvcHMpO1xufSk7XG5fU3R5bGUudHlwZXMgPSBzdHlmbi50eXBlcztcbl9TdHlsZS5wcm9wZXJ0aWVzID0gc3R5Zm4ucHJvcGVydGllcztcbl9TdHlsZS5wcm9wZXJ0eUdyb3VwcyA9IHN0eWZuLnByb3BlcnR5R3JvdXBzO1xuX1N0eWxlLnByb3BlcnR5R3JvdXBOYW1lcyA9IHN0eWZuLnByb3BlcnR5R3JvdXBOYW1lcztcbl9TdHlsZS5wcm9wZXJ0eUdyb3VwS2V5cyA9IHN0eWZuLnByb3BlcnR5R3JvdXBLZXlzO1xuXG52YXIgY29yZWZuJDIgPSB7XG4gIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuZXdTdHlsZSkge1xuICAgIGlmIChuZXdTdHlsZSkge1xuICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKG5ld1N0eWxlKTtcbiAgICAgIHMudXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICB9LFxuICBzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IF9TdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IF9TdHlsZS5mcm9tU3RyaW5nKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc3R5bGUgPSBfU3R5bGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBfcC5zdHlsZTtcbiAgfSxcbiAgLy8gZS5nLiBjeS5kYXRhKCkgY2hhbmdlZCA9PiByZWNhbGMgZWxlIG1hcHBlcnNcbiAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKCkge1xuICAgIHRoaXMubXV0YWJsZUVsZW1lbnRzKCkudXBkYXRlU3R5bGUoKTsgLy8ganVzdCBzZW5kIHRvIGFsbCBlbGVzXG4gIH1cbn07XG5cbnZhciBkZWZhdWx0U2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xudmFyIGNvcmVmbiQxID0ge1xuICBhdXRvbG9jazogZnVuY3Rpb24gYXV0b2xvY2soYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvbG9jaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uIGF1dG91bmdyYWJpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBhdXRvdW5zZWxlY3RpZnk6IGZ1bmN0aW9uIGF1dG91bnNlbGVjdGlmeShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbiBzZWxlY3Rpb25UeXBlKHNlbFR5cGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChfcC5zZWxlY3Rpb25UeXBlID09IG51bGwpIHtcbiAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBkZWZhdWx0U2VsZWN0aW9uVHlwZTtcbiAgICB9XG4gICAgaWYgKHNlbFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHNlbFR5cGUgPT09ICdhZGRpdGl2ZScgfHwgc2VsVHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IHNlbFR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfcC5zZWxlY3Rpb25UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJQYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24gem9vbWluZ0VuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uIGJveFNlbGVjdGlvbkVuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBwYW46IGZ1bmN0aW9uIHBhbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gLnBhbigpXG4gICAgICAgIHJldHVybiBwYW47XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChzdHJpbmcoYXJnc1swXSkpIHtcbiAgICAgICAgICAvLyAucGFuKCd4JylcbiAgICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICAgIHJldHVybiBwYW5bZGltXTtcbiAgICAgICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG4gICAgICAgICAgaWYgKG51bWJlciQxKHgpKSB7XG4gICAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudW1iZXIkMSh5KSkge1xuICAgICAgICAgICAgcGFuLnkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyAucGFuKCd4JywgMTAwKVxuICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICB2YWwgPSBhcmdzWzFdO1xuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBpbnZhbGlkXG4gICAgfVxuICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBwYW5CeTogZnVuY3Rpb24gcGFuQnkoYXJnMCwgYXJnMSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAocGxhaW5PYmplY3QoYXJnMCkpIHtcbiAgICAgICAgICAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG4gICAgICAgICAgaWYgKG51bWJlciQxKHgpKSB7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVtYmVyJDEoeSkpIHtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgZGltID0gYXJnMDtcbiAgICAgICAgdmFsID0gYXJnMTtcbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGludmFsaWRcbiAgICB9XG4gICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdjOiBmdW5jdGlvbiBnYygpIHtcbiAgICB0aGlzLm5vdGlmeSgnZ2MnKTtcbiAgfSxcbiAgZml0OiBmdW5jdGlvbiBmaXQoZWxlbWVudHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IHRoaXMuZ2V0Rml0Vmlld3BvcnQoZWxlbWVudHMsIHBhZGRpbmcpO1xuICAgIGlmICh2aWV3cG9ydFN0YXRlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgIF9wLnBhbiA9IHZpZXdwb3J0U3RhdGUucGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBnZXRGaXRWaWV3cG9ydDogZnVuY3Rpb24gZ2V0Rml0Vmlld3BvcnQoZWxlbWVudHMsIHBhZGRpbmcpIHtcbiAgICBpZiAobnVtYmVyJDEoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZWxlbWVudHMgaXMgb3B0aW9uYWxcbiAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJiO1xuICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMuJChzZWwpO1xuICAgIH0gZWxzZSBpZiAoYm91bmRpbmdCb3goZWxlbWVudHMpKSB7XG4gICAgICAvLyBhc3N1bWUgYmJcbiAgICAgIHZhciBiYmUgPSBlbGVtZW50cztcbiAgICAgIGJiID0ge1xuICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICB5MTogYmJlLnkxLFxuICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICB5MjogYmJlLnkyXG4gICAgICB9O1xuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykgJiYgZWxlbWVudHMuZW1wdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FuJ3QgZml0IHRvIG5vdGhpbmdcblxuICAgIGJiID0gYmIgfHwgZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgdmFyIHpvb207XG4gICAgcGFkZGluZyA9IG51bWJlciQxKHBhZGRpbmcpID8gcGFkZGluZyA6IDA7XG4gICAgaWYgKCFpc05hTih3KSAmJiAhaXNOYU4oaCkgJiYgdyA+IDAgJiYgaCA+IDAgJiYgIWlzTmFOKGJiLncpICYmICFpc05hTihiYi5oKSAmJiBiYi53ID4gMCAmJiBiYi5oID4gMCkge1xuICAgICAgem9vbSA9IE1hdGgubWluKCh3IC0gMiAqIHBhZGRpbmcpIC8gYmIudywgKGggLSAyICogcGFkZGluZykgLyBiYi5oKTtcblxuICAgICAgLy8gY3JvcCB6b29tXG4gICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG4gICAgICB2YXIgcGFuID0ge1xuICAgICAgICAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20gKiAoYmIueDEgKyBiYi54MikpIC8gMixcbiAgICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IHBhblxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9LFxuICB6b29tUmFuZ2U6IGZ1bmN0aW9uIHpvb21SYW5nZShtaW4sIG1heCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICB2YXIgb3B0cyA9IG1pbjtcbiAgICAgIG1pbiA9IG9wdHMubWluO1xuICAgICAgbWF4ID0gb3B0cy5tYXg7XG4gICAgfVxuICAgIGlmIChudW1iZXIkMShtaW4pICYmIG51bWJlciQxKG1heCkgJiYgbWluIDw9IG1heCkge1xuICAgICAgX3AubWluWm9vbSA9IG1pbjtcbiAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgfSBlbHNlIGlmIChudW1iZXIkMShtaW4pICYmIG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA8PSBfcC5tYXhab29tKSB7XG4gICAgICBfcC5taW5ab29tID0gbWluO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyJDEobWF4KSAmJiBtaW4gPT09IHVuZGVmaW5lZCAmJiBtYXggPj0gX3AubWluWm9vbSkge1xuICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1pblpvb206IGZ1bmN0aW9uIG1pblpvb20oem9vbSkge1xuICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgIG1pbjogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBtYXhab29tOiBmdW5jdGlvbiBtYXhab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICBtYXg6IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0Wm9vbWVkVmlld3BvcnQ6IGZ1bmN0aW9uIGdldFpvb21lZFZpZXdwb3J0KHBhcmFtcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnRQYW4gPSBfcC5wYW47XG4gICAgdmFyIGN1cnJlbnRab29tID0gX3Auem9vbTtcbiAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuICAgIHZhciB6b29tO1xuICAgIHZhciBiYWlsID0gZmFsc2U7XG4gICAgaWYgKCFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgYmFpbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChudW1iZXIkMShwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHNldCB0aGUgem9vbVxuICAgICAgem9vbSA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuICAgICAgaWYgKHBhcmFtcy5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uJDEocGFyYW1zLnBvc2l0aW9uLCBjdXJyZW50Wm9vbSwgY3VycmVudFBhbik7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB9XG4gICAgICBpZiAocG9zICE9IG51bGwgJiYgIV9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgIC8vIHBhbm5pbmcgZGlzYWJsZWRcbiAgICAgICAgYmFpbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY3JvcCB6b29tXG4gICAgem9vbSA9IHpvb20gPiBfcC5tYXhab29tID8gX3AubWF4Wm9vbSA6IHpvb207XG4gICAgem9vbSA9IHpvb20gPCBfcC5taW5ab29tID8gX3AubWluWm9vbSA6IHpvb207XG5cbiAgICAvLyBjYW4ndCB6b29tIHdpdGggaW52YWxpZCBwYXJhbXNcbiAgICBpZiAoYmFpbCB8fCAhbnVtYmVyJDEoem9vbSkgfHwgem9vbSA9PT0gY3VycmVudFpvb20gfHwgcG9zICE9IG51bGwgJiYgKCFudW1iZXIkMShwb3MueCkgfHwgIW51bWJlciQxKHBvcy55KSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgIC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICB2YXIgcGFuMSA9IGN1cnJlbnRQYW47XG4gICAgICB2YXIgem9vbTEgPSBjdXJyZW50Wm9vbTtcbiAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICBwYW5uZWQ6IHRydWUsXG4gICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICBwYW46IHBhbjJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogZmFsc2UsXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogY3VycmVudFBhblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHpvb206IGZ1bmN0aW9uIHpvb20ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXRcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldFxuICAgICAgdmFyIHZwID0gdGhpcy5nZXRab29tZWRWaWV3cG9ydChwYXJhbXMpO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIGlmICh2cCA9PSBudWxsIHx8ICF2cC56b29tZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBfcC56b29tID0gdnAuem9vbTtcbiAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgX3AucGFuLnggPSB2cC5wYW4ueDtcbiAgICAgICAgX3AucGFuLnkgPSB2cC5wYW4ueTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnem9vbScgKyAodnAucGFubmVkID8gJyBwYW4nIDogJycpICsgJyB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9XG4gIH0sXG4gIHZpZXdwb3J0OiBmdW5jdGlvbiB2aWV3cG9ydChvcHRzKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgem9vbURlZmQgPSB0cnVlO1xuICAgIHZhciBwYW5EZWZkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnRzID0gW107IC8vIHRvIHRyaWdnZXJcbiAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW51bWJlciQxKG9wdHMuem9vbSkpIHtcbiAgICAgIHpvb21EZWZkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGxhaW5PYmplY3Qob3B0cy5wYW4pKSB7XG4gICAgICBwYW5EZWZkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghem9vbURlZmQgJiYgIXBhbkRlZmQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoem9vbURlZmQpIHtcbiAgICAgIHZhciB6ID0gb3B0cy56b29tO1xuICAgICAgaWYgKHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCkge1xuICAgICAgICB6b29tRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnpvb20gPSB6O1xuICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFuRGVmZCAmJiAoIXpvb21GYWlsZWQgfHwgIW9wdHMuY2FuY2VsT25GYWlsZWRab29tKSAmJiBfcC5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcbiAgICAgIGlmIChudW1iZXIkMShwLngpKSB7XG4gICAgICAgIF9wLnBhbi54ID0gcC54O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXIkMShwLnkpKSB7XG4gICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFuRmFpbGVkKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCdwYW4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBldmVudHMucHVzaCgndmlld3BvcnQnKTtcbiAgICAgIHRoaXMuZW1pdChldmVudHMuam9pbignICcpKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoZWxlbWVudHMpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5nZXRDZW50ZXJQYW4oZWxlbWVudHMpO1xuICAgIGlmIChwYW4pIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZ2V0Q2VudGVyUGFuOiBmdW5jdGlvbiBnZXRDZW50ZXJQYW4oZWxlbWVudHMsIHpvb20pIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FuJ3QgY2VudHJlIHBhbiB0byBub3RoaW5nXG5cbiAgICB2YXIgYmIgPSBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fcHJpdmF0ZS56b29tIDogem9vbTtcbiAgICB2YXIgcGFuID0ge1xuICAgICAgLy8gbWlkZGxlXG4gICAgICB4OiAodyAtIHpvb20gKiAoYmIueDEgKyBiYi54MikpIC8gMixcbiAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgfTtcbiAgICByZXR1cm4gcGFuO1xuICB9LFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICBwYW46IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIHpvb206IDFcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgaW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIGludmFsaWRhdGVTaXplKCkge1xuICAgIHRoaXMuX3ByaXZhdGUuc2l6ZUNhY2hlID0gbnVsbDtcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjb250YWluZXIgPSBfcC5jb250YWluZXI7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gX3Auc2l6ZUNhY2hlID0gX3Auc2l6ZUNhY2hlIHx8IChjb250YWluZXIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3R5bGUgPSBjeS53aW5kb3coKS5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICB2YXIgdmFsID0gZnVuY3Rpb24gdmFsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHZhbCgncGFkZGluZy1sZWZ0JykgLSB2YWwoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gdmFsKCdwYWRkaW5nLXRvcCcpIC0gdmFsKCdwYWRkaW5nLWJvdHRvbScpXG4gICAgICB9O1xuICAgIH0oKSA6IHtcbiAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMVxuICAgIH0pO1xuICB9LFxuICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLndpZHRoO1xuICB9LFxuICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkuaGVpZ2h0O1xuICB9LFxuICBleHRlbnQ6IGZ1bmN0aW9uIGV4dGVudCgpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuICAgIHZhciBiID0ge1xuICAgICAgeDE6IChyYi54MSAtIHBhbi54KSAvIHpvb20sXG4gICAgICB4MjogKHJiLngyIC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHkxOiAocmIueTEgLSBwYW4ueSkgLyB6b29tLFxuICAgICAgeTI6IChyYi55MiAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuICAgIHJldHVybiBiO1xuICB9LFxuICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24gcmVuZGVyZWRFeHRlbnQoKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgeDI6IHdpZHRoLFxuICAgICAgeTI6IGhlaWdodCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsdGlDbGlja0RlYm91bmNlVGltZTogZnVuY3Rpb24gbXVsdGlDbGlja0RlYm91bmNlVGltZShfaW50KSB7XG4gICAgaWYgKF9pbnQpIHRoaXMuX3ByaXZhdGUubXVsdGlDbGlja0RlYm91bmNlVGltZSA9IF9pbnQ7ZWxzZSByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9XG59O1xuXG4vLyBhbGlhc2VzXG5jb3JlZm4kMS5jZW50cmUgPSBjb3JlZm4kMS5jZW50ZXI7XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb3JlZm4kMS5hdXRvbG9ja05vZGVzID0gY29yZWZuJDEuYXV0b2xvY2s7XG5jb3JlZm4kMS5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSBjb3JlZm4kMS5hdXRvdW5ncmFiaWZ5O1xuXG52YXIgZm4gPSB7XG4gIGRhdGE6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgZXZlbnQ6ICdkYXRhJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICBzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KVxufTtcblxuLy8gYWxpYXNlc1xuZm4uYXR0ciA9IGZuLmRhdGE7XG5mbi5yZW1vdmVBdHRyID0gZm4ucmVtb3ZlRGF0YTtcblxudmFyIENvcmUgPSBmdW5jdGlvbiBDb3JlKG9wdHMpIHtcbiAgdmFyIGN5ID0gdGhpcztcbiAgb3B0cyA9IGV4dGVuZCh7fSwgb3B0cyk7XG4gIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjtcblxuICAvLyBhbGxvdyBmb3IgcGFzc2luZyBhIHdyYXBwZWQganF1ZXJ5IG9iamVjdFxuICAvLyBlLmcuIGN5dG9zY2FwZSh7IGNvbnRhaW5lcjogJCgnI2N5JykgfSlcbiAgaWYgKGNvbnRhaW5lciAmJiAhaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICB9XG4gIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcbiAgcmVnID0gcmVnIHx8IHt9O1xuICBpZiAocmVnICYmIHJlZy5jeSkge1xuICAgIHJlZy5jeS5kZXN0cm95KCk7XG4gICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gIH1cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLl9jeXJlZyA9IHJlZztcbiAgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gIHJlZy5jeSA9IGN5O1xuICB2YXIgaGVhZCA9IF93aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IGV4dGVuZCh7XG4gICAgbmFtZTogaGVhZCA/ICdncmlkJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLmxheW91dCk7XG4gIG9wdGlvbnMucmVuZGVyZXIgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJ1xuICB9LCBvcHRpb25zLnJlbmRlcmVyKTtcbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uIGRlZlZhbChkZWYsIHZhbCwgYWx0VmFsKSB7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiAoYWx0VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICByZWFkeTogZmFsc2UsXG4gICAgLy8gd2hldGhlciByZWFkeSBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgIC8vIGVsZW1lbnRzIGluIHRoZSBncmFwaFxuICAgIGxpc3RlbmVyczogW10sXG4gICAgLy8gbGlzdCBvZiBsaXN0ZW5lcnNcbiAgICBhbmlFbGVzOiBuZXcgQ29sbGVjdGlvbih0aGlzKSxcbiAgICAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgIGRhdGE6IG9wdGlvbnMuZGF0YSB8fCB7fSxcbiAgICAvLyBkYXRhIGZvciB0aGUgY29yZVxuICAgIHNjcmF0Y2g6IHt9LFxuICAgIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgbGF5b3V0OiBudWxsLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciBkZXN0cm95IHdhcyBjYWxsZWRcbiAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgbWluWm9vbTogMWUtNTAsXG4gICAgbWF4Wm9vbTogMWU1MCxcbiAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogbnVtYmVyJDEob3B0aW9ucy56b29tKSA/IG9wdGlvbnMuem9vbSA6IDEsXG4gICAgcGFuOiB7XG4gICAgICB4OiBwbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgbnVtYmVyJDEob3B0aW9ucy5wYW4ueCkgPyBvcHRpb25zLnBhbi54IDogMCxcbiAgICAgIHk6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIkMShvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgY3VycmVudDogW10sXG4gICAgICBxdWV1ZTogW11cbiAgICB9LFxuICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlLFxuICAgIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGRlZlZhbCgyNTAsIG9wdGlvbnMubXVsdGlDbGlja0RlYm91bmNlVGltZSlcbiAgfTtcbiAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG5cbiAgLy8gc2V0IHNlbGVjdGlvbiB0eXBlXG4gIHRoaXMuc2VsZWN0aW9uVHlwZShvcHRpb25zLnNlbGVjdGlvblR5cGUpO1xuXG4gIC8vIGluaXQgem9vbSBib3VuZHNcbiAgdGhpcy56b29tUmFuZ2Uoe1xuICAgIG1pbjogb3B0aW9ucy5taW5ab29tLFxuICAgIG1heDogb3B0aW9ucy5tYXhab29tXG4gIH0pO1xuICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiBsb2FkRXh0RGF0YShleHREYXRhLCBuZXh0KSB7XG4gICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZShwcm9taXNlKTtcbiAgICBpZiAoYW55SXNQcm9taXNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZSQxLmFsbChleHREYXRhKS50aGVuKG5leHQpOyAvLyBsb2FkIGFsbCBkYXRhIGFzeW5jaHJvbm91c2x5LCB0aGVuIGV4ZWMgcmVzdCBvZiBpbml0XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoZXh0RGF0YSk7IC8vIGV4ZWMgc3luY2hyb25vdXNseSBmb3IgY29udmVuaWVuY2VcbiAgICB9XG4gIH07XG5cbiAgLy8gc3RhcnQgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHNvIHdlIGhhdmUgc29tZXRoaW5nIGJlZm9yZSBsb2FkaW5nIGFuIGV4dGVybmFsIHN0eWxlc2hlZXRcbiAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgIGN5LnNldFN0eWxlKFtdKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlcik7IC8vIGFsbG93IHJlbmRlcmluZyBoaW50cyBpbiB0b3AgbGV2ZWwgb3B0aW9uc1xuICBjeS5pbml0UmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgdmFyIHNldEVsZXNBbmRMYXlvdXQgPSBmdW5jdGlvbiBzZXRFbGVzQW5kTGF5b3V0KGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSkge1xuICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgIHZhciBvbGRFbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKG9sZEVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGlmIChwbGFpbk9iamVjdChlbGVtZW50cykgfHwgYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgIGN5LmFkZChlbGVtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGN5Lm9uZSgnbGF5b3V0cmVhZHknLCBmdW5jdGlvbiAoZSkge1xuICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgIGN5LmVtaXQoZSk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgIGN5LmVtaXRBbmROb3RpZnkoJ2xvYWQnKTtcbiAgICB9KS5vbmUoJ2xheW91dHN0b3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjeS5vbmUoJ2RvbmUnLCBvbmRvbmUpO1xuICAgICAgY3kuZW1pdCgnZG9uZScpO1xuICAgIH0pO1xuICAgIHZhciBsYXlvdXRPcHRzID0gZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICBjeS5sYXlvdXQobGF5b3V0T3B0cykucnVuKCk7XG4gIH07XG4gIGxvYWRFeHREYXRhKFtvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzXSwgZnVuY3Rpb24gKHRoZW5zKSB7XG4gICAgdmFyIGluaXRTdHlsZSA9IHRoZW5zWzBdO1xuICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdO1xuXG4gICAgLy8gaW5pdCBzdHlsZVxuICAgIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICAgIGN5LnN0eWxlKCkuYXBwZW5kKGluaXRTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgc2V0RWxlc0FuZExheW91dChpbml0RWxlcywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gb25yZWFkeVxuICAgICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgICBfcC5yZWFkeSA9IHRydWU7XG5cbiAgICAgIC8vIGlmIGEgcmVhZHkgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIGFzIGFuIG9wdGlvbiwgdGhlIGJpbmQgaXRcbiAgICAgIGlmIChmbiQ2KG9wdGlvbnMucmVhZHkpKSB7XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBiaW5kIGFsbCB0aGUgcmVhZHkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBiZWZvcmUgY3JlYXRpbmcgdGhpcyBpbnN0YW5jZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IHJlYWRpZXNbaV07XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIGZuKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWcpIHtcbiAgICAgICAgcmVnLnJlYWRpZXMgPSBbXTtcbiAgICAgIH0gLy8gY2xlYXIgYi9jIHdlJ3ZlIGJvdW5kIHRoZW0gYWxsIGFuZCBkb24ndCB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIGNhc2UgYSBuZXcgY29yZSB1c2VzIHRoZSBzYW1lIGRpdiBldGNcblxuICAgICAgY3kuZW1pdCgncmVhZHknKTtcbiAgICB9LCBvcHRpb25zLmRvbmUpO1xuICB9KTtcbn07XG52YXIgY29yZWZuID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbmV4dGVuZChjb3JlZm4sIHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnY29yZSc7XG4gIH0sXG4gIGlzUmVhZHk6IGZ1bmN0aW9uIGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVhZHk7XG4gIH0sXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KCdyZWFkeScsIFtdLCBmbik7IC8vIGp1c3QgY2FsbHMgZm4gYXMgdGhvdWdoIHRyaWdnZXJlZCB2aWEgcmVhZHkgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYgKGN5LmRlc3Ryb3llZCgpKSByZXR1cm47XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICBjeS5fcHJpdmF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgaGFzRWxlbWVudFdpdGhJZDogZnVuY3Rpb24gaGFzRWxlbWVudFdpdGhJZChpZCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICB9LFxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZChpZCk7XG4gIH0sXG4gIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uIGhhc0NvbXBvdW5kTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgfSxcbiAgaGVhZGxlc3M6IGZ1bmN0aW9uIGhlYWRsZXNzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyLmlzSGVhZGxlc3MoKTtcbiAgfSxcbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbiBzdHlsZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICB9LFxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uIGFkZFRvUG9vbChlbGVzKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5tZXJnZShlbGVzKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uIHJlbW92ZUZyb21Qb29sKGVsZXMpIHtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnVubWVyZ2UoZWxlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvbnRhaW5lcjogZnVuY3Rpb24gY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvbnRhaW5lciB8fCBudWxsO1xuICB9LFxuICB3aW5kb3c6IGZ1bmN0aW9uIHdpbmRvdygpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG4gICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSByZXR1cm4gX3dpbmRvdztcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKG93bmVyRG9jdW1lbnQgPT09IHVuZGVmaW5lZCB8fCBvd25lckRvY3VtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBfd2luZG93O1xuICAgIH1cbiAgICByZXR1cm4gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBfd2luZG93O1xuICB9LFxuICBtb3VudDogZnVuY3Rpb24gbW91bnQoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIG9wdGlvbnMgPSBfcC5vcHRpb25zO1xuICAgIGlmICghaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gICAgfVxuICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgX3AuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIF9wLnN0eWxlRW5hYmxlZCA9IHRydWU7XG4gICAgY3kuaW52YWxpZGF0ZVNpemUoKTtcbiAgICBjeS5pbml0UmVuZGVyZXIoZXh0ZW5kKHt9LCBvcHRpb25zLCBvcHRpb25zLnJlbmRlcmVyLCB7XG4gICAgICAvLyBhbGxvdyBjdXN0b20gcmVuZGVyZXIgbmFtZSB0byBiZSByZS11c2VkLCBvdGhlcndpc2UgdXNlIGNhbnZhc1xuICAgICAgbmFtZTogb3B0aW9ucy5yZW5kZXJlci5uYW1lID09PSAnbnVsbCcgPyAnY2FudmFzJyA6IG9wdGlvbnMucmVuZGVyZXIubmFtZVxuICAgIH0pKTtcbiAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5zdHlsZShvcHRpb25zLnN0eWxlKTtcbiAgICBjeS5lbWl0KCdtb3VudCcpO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgY3kuaW5pdFJlbmRlcmVyKHtcbiAgICAgIG5hbWU6ICdudWxsJ1xuICAgIH0pO1xuICAgIGN5LmVtaXQoJ3VubW91bnQnKTtcbiAgICByZXR1cm4gY3k7XG4gIH0sXG4gIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIGNvcHkodGhpcy5fcHJpdmF0ZS5vcHRpb25zKTtcbiAgfSxcbiAganNvbjogZnVuY3Rpb24ganNvbihvYmopIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgdmFyIGdldEZyZXNoUmVmID0gZnVuY3Rpb24gZ2V0RnJlc2hSZWYoZWxlKSB7XG4gICAgICByZXR1cm4gY3kuZ2V0RWxlbWVudEJ5SWQoZWxlLmlkKCkpO1xuICAgIH07XG4gICAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIC8vIHNldFxuXG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBpZiAob2JqLmVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuICAgICAgICB2YXIgdXBkYXRlRWxlcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZXMoanNvbnMsIGdyKSB7XG4gICAgICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICAgICAgdmFyIHRvTW9kID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcbiAgICAgICAgICAgIGlmICghanNvbi5kYXRhLmlkKSB7XG4gICAgICAgICAgICAgIHdhcm4oJ2N5Lmpzb24oKSBjYW5ub3QgaGFuZGxlIGVsZW1lbnRzIHdpdGhvdXQgYW4gSUQgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkID0gJycgKyBqc29uLmRhdGEuaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgaWRJbkpzb25baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlbGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGVsZW1lbnQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgdG9Nb2QucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlOiBlbGUsXG4gICAgICAgICAgICAgICAganNvbjoganNvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgaWYgKGdyKSB7XG4gICAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyO1xuICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjeS5hZGQodG9BZGQpO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b01vZC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfdG9Nb2QkX2kgPSB0b01vZFtfaV0sXG4gICAgICAgICAgICAgIF9lbGUgPSBfdG9Nb2QkX2kuZWxlLFxuICAgICAgICAgICAgICBfanNvbiA9IF90b01vZCRfaS5qc29uO1xuICAgICAgICAgICAgX2VsZS5qc29uKF9qc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcnJheShvYmouZWxlbWVudHMpKSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyhvYmouZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsZW1lbnRzOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH1cbiAgICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3IgPSBncnNbaV07XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBvYmouZWxlbWVudHNbZ3JdO1xuICAgICAgICAgICAgaWYgKGFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICB1cGRhdGVFbGVzKGVsZW1lbnRzLCBncik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnRzVG9SZW1vdmUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gIWlkSW5Kc29uW2VsZS5pZCgpXTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUubWVyZ2UoZWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc28gdGhhdCBjaGlsZHJlbiBhcmUgbm90IHJlbW92ZWQgdy9wYXJlbnRcbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKS5tb3ZlKHtcbiAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbnRlcm1lZGlhdGUgcGFyZW50cyBtYXkgYmUgbW92ZWQgYnkgcHJpb3IgbGluZSwgc28gbWFrZSBzdXJlIHdlIHJlbW92ZSBieSBmcmVzaCByZWZzXG4gICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RnJlc2hSZWYoZWxlKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqLnN0eWxlKSB7XG4gICAgICAgIGN5LnN0eWxlKG9iai5zdHlsZSk7XG4gICAgICB9XG4gICAgICBpZiAob2JqLnpvb20gIT0gbnVsbCAmJiBvYmouem9vbSAhPT0gX3Auem9vbSkge1xuICAgICAgICBjeS56b29tKG9iai56b29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmoucGFuKSB7XG4gICAgICAgIGlmIChvYmoucGFuLnggIT09IF9wLnBhbi54IHx8IG9iai5wYW4ueSAhPT0gX3AucGFuLnkpIHtcbiAgICAgICAgICBjeS5wYW4ob2JqLnBhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmouZGF0YSkge1xuICAgICAgICBjeS5kYXRhKG9iai5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWVsZHMgPSBbJ21pblpvb20nLCAnbWF4Wm9vbScsICd6b29taW5nRW5hYmxlZCcsICd1c2VyWm9vbWluZ0VuYWJsZWQnLCAncGFubmluZ0VuYWJsZWQnLCAndXNlclBhbm5pbmdFbmFibGVkJywgJ2JveFNlbGVjdGlvbkVuYWJsZWQnLCAnYXV0b2xvY2snLCAnYXV0b3VuZ3JhYmlmeScsICdhdXRvdW5zZWxlY3RpZnknLCAnbXVsdGlDbGlja0RlYm91bmNlVGltZSddO1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZmllbGRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbX2kyXTtcbiAgICAgICAgaWYgKG9ialtmXSAhPSBudWxsKSB7XG4gICAgICAgICAgY3lbZl0ob2JqW2ZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXRcbiAgICAgIHZhciBmbGF0ID0gISFvYmo7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAganNvbi5lbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKS5tYXAoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuanNvbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24uZWxlbWVudHMgPSB7fTtcbiAgICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBlbGUuZ3JvdXAoKTtcbiAgICAgICAgICBpZiAoIWpzb24uZWxlbWVudHNbZ3JvdXBdKSB7XG4gICAgICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXS5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCkge1xuICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICB9XG4gICAgICBqc29uLmRhdGEgPSBjb3B5KGN5LmRhdGEoKSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gX3Auem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IF9wLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IF9wLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBfcC5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gX3AubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBfcC5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gX3AudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSBjb3B5KF9wLnBhbik7XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBfcC5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5yZW5kZXJlciA9IGNvcHkob3B0aW9ucy5yZW5kZXJlcik7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgIGpzb24ubXVsdGlDbGlja0RlYm91bmNlVGltZSA9IG9wdGlvbnMubXVsdGlDbGlja0RlYm91bmNlVGltZTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfVxufSk7XG5jb3JlZm4uJGlkID0gY29yZWZuLmdldEVsZW1lbnRCeUlkO1xuW2NvcmVmbiQ5LCBjb3JlZm4kOCwgZWxlc2ZuLCBjb3JlZm4kNywgY29yZWZuJDYsIGNvcmVmbiQ1LCBjb3JlZm4kNCwgY29yZWZuJDMsIGNvcmVmbiQyLCBjb3JlZm4kMSwgZm5dLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChjb3JlZm4sIHByb3BzKTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGRlZmF1bHRzJDcgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgZGlyZWN0aW9uOiAnZG93bndhcmQnLFxuICAvLyBkZXRlcm1pbmVzIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIHRyZWUgc3RydWN0dXJlIGlzIGRyYXduLiAgVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmUgJ2Rvd253YXJkJywgJ3Vwd2FyZCcsICdyaWdodHdhcmQnLCBvciAnbGVmdHdhcmQnLlxuICBwYWRkaW5nOiAzMCxcbiAgLy8gcGFkZGluZyBvbiBmaXRcbiAgY2lyY2xlOiBmYWxzZSxcbiAgLy8gcHV0IGRlcHRocyBpbiBjb25jZW50cmljIGNpcmNsZXMgaWYgdHJ1ZSwgcHV0IGRlcHRocyB0b3AgZG93biBpZiBmYWxzZVxuICBncmlkOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBjcmVhdGUgYW4gZXZlbiBncmlkIGludG8gd2hpY2ggdGhlIERBRyBpcyBwbGFjZWQgKGNpcmNsZTpmYWxzZSBvbmx5KVxuICBzcGFjaW5nRmFjdG9yOiAxLjc1LFxuICAvLyBwb3NpdGl2ZSBzcGFjaW5nIGZhY3RvciwgbGFyZ2VyID0+IG1vcmUgc3BhY2UgYmV0d2VlbiBub2RlcyAoTi5CLiBuL2EgaWYgY2F1c2VzIG92ZXJsYXApXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgcm9vdHM6IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHJvb3RzIG9mIHRoZSB0cmVlc1xuICBkZXB0aFNvcnQ6IHVuZGVmaW5lZCxcbiAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIG5vZGVzIGF0IGVxdWFsIGRlcHRoLiBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkLFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG59O1xudmFyIGRlcHJlY2F0ZWRPcHRpb25EZWZhdWx0cyA9IHtcbiAgbWF4aW1hbDogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gc2hpZnQgbm9kZXMgZG93biB0aGVpciBuYXR1cmFsIEJGUyBkZXB0aHMgaW4gb3JkZXIgdG8gYXZvaWQgdXB3YXJkcyBlZGdlcyAoREFHUyBvbmx5KTsgc2V0dGluZyBhY3ljbGljIHRvIHRydWUgc2V0cyBtYXhpbWFsIHRvIHRydWUgYWxzb1xuICBhY3ljbGljOiBmYWxzZSAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGFjeWNsaWMgYW5kIHRodXMgYSBub2RlIGNvdWxkIGJlIHNoaWZ0ZWQgKGR1ZSB0byB0aGUgbWF4aW1hbCBvcHRpb24pIG11bHRpcGxlIHRpbWVzIHdpdGhvdXQgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wOyBzZXR0aW5nIHRvIHRydWUgc2V0cyBtYXhpbWFsIHRvIHRydWUgYWxzbzsgaWYgeW91IGFyZSB1bmNlcnRhaW4gd2hldGhlciBhIHRyZWUgaXMgYWN5Y2xpYywgc2V0IHRvIGZhbHNlIHRvIGF2b2lkIHBvdGVudGlhbCBpbmZpbml0ZSBsb29wc1xufTtcblxuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8oZWxlKSB7XG4gIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jyk7XG59O1xudmFyIHNldEluZm8gPSBmdW5jdGlvbiBzZXRJbmZvKGVsZSwgb2JqKSB7XG4gIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jywgb2JqKTtcbn07XG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDcsIGRlcHJlY2F0ZWRPcHRpb25EZWZhdWx0cywgb3B0aW9ucyk7XG59XG5CcmVhZHRoRmlyc3RMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNDaGlsZGxlc3MoKTtcbiAgfSk7XG4gIHZhciBncmFwaCA9IGVsZXM7XG4gIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gIHZhciBtYXhpbWFsID0gb3B0aW9ucy5hY3ljbGljIHx8IG9wdGlvbnMubWF4aW1hbCB8fCBvcHRpb25zLm1heGltYWxBZGp1c3RtZW50cyA+IDA7IC8vIG1heGltYWxBZGp1c3RtZW50cyBmb3IgY29tcGF0LiB3LyBvbGQgY29kZTsgYWxzbywgc2V0dGluZyBhY3ljbGljIHRvIHRydWUgc2V0cyBtYXhpbWFsIHRvIHRydWVcblxuICB2YXIgaGFzQm91bmRpbmdCb3ggPSAhIW9wdGlvbnMuYm91bmRpbmdCb3g7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChoYXNCb3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiBzdHJ1Y3R1cmVkQ2xvbmUoY3kuZXh0ZW50KCkpKTtcbiAgdmFyIHJvb3RzO1xuICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihvcHRpb25zLnJvb3RzKSkge1xuICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgfSBlbHNlIGlmIChhcnJheShvcHRpb25zLnJvb3RzKSkge1xuICAgIHZhciByb290c0FycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgIHJvb3RzQXJyYXkucHVzaChlbGUpO1xuICAgIH1cbiAgICByb290cyA9IGN5LmNvbGxlY3Rpb24ocm9vdHNBcnJheSk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKG9wdGlvbnMucm9vdHMpKSB7XG4gICAgcm9vdHMgPSBjeS4kKG9wdGlvbnMucm9vdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgcm9vdHMgPSBub2Rlcy5yb290cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IGVsZXMuY29tcG9uZW50cygpO1xuICAgICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzW19pXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKGZhbHNlKTtcbiAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmRlZ3JlZShmYWxzZSkgPT09IG1heERlZ3JlZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKGNvbXBSb290cyk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkZXB0aHMgPSBbXTtcbiAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcbiAgdmFyIGFkZFRvRGVwdGggPSBmdW5jdGlvbiBhZGRUb0RlcHRoKGVsZSwgZCkge1xuICAgIGlmIChkZXB0aHNbZF0gPT0gbnVsbCkge1xuICAgICAgZGVwdGhzW2RdID0gW107XG4gICAgfVxuICAgIHZhciBpID0gZGVwdGhzW2RdLmxlbmd0aDtcbiAgICBkZXB0aHNbZF0ucHVzaChlbGUpO1xuICAgIHNldEluZm8oZWxlLCB7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGRlcHRoOiBkXG4gICAgfSk7XG4gIH07XG4gIHZhciBjaGFuZ2VEZXB0aCA9IGZ1bmN0aW9uIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpIHtcbiAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKGVsZSksXG4gICAgICBkZXB0aCA9IF9nZXRJbmZvLmRlcHRoLFxuICAgICAgaW5kZXggPSBfZ2V0SW5mby5pbmRleDtcbiAgICBkZXB0aHNbZGVwdGhdW2luZGV4XSA9IG51bGw7XG5cbiAgICAvLyBhZGQgb25seSBjaGlsZGxlc3Mgbm9kZXNcbiAgICBpZiAoZWxlLmlzQ2hpbGRsZXNzKCkpIGFkZFRvRGVwdGgoZWxlLCBuZXdEZXB0aCk7XG4gIH07XG5cbiAgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuICBncmFwaC5iZnMoe1xuICAgIHJvb3RzOiByb290cyxcbiAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQobm9kZSwgZWRnZSwgcE5vZGUsIGksIGRlcHRoKSB7XG4gICAgICB2YXIgZWxlID0gbm9kZVswXTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAvLyBhZGQgb25seSBjaGlsZGxlc3Mgbm9kZXNcbiAgICAgIGlmIChlbGUuaXNDaGlsZGxlc3MoKSkgYWRkVG9EZXB0aChlbGUsIGRlcHRoKTtcbiAgICAgIGZvdW5kQnlCZnNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNoZWNrIGZvciBub2RlcyBub3QgZm91bmQgYnkgYmZzXG4gIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuICAgIGlmIChmb3VuZEJ5QmZzW19lbGUuaWQoKV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcnBoYW5Ob2Rlcy5wdXNoKF9lbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcbiAgdmFyIGFzc2lnbkRlcHRoc0F0ID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzQXQoaSkge1xuICAgIHZhciBlbGVzID0gZGVwdGhzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF9lbGUyID0gZWxlc1tqXTtcbiAgICAgIGlmIChfZWxlMiA9PSBudWxsKSB7XG4gICAgICAgIGVsZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICBqLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc2V0SW5mbyhfZWxlMiwge1xuICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgaW5kZXg6IGpcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdmFyIGFkanVzdE1heGltYWxseSA9IGZ1bmN0aW9uIGFkanVzdE1heGltYWxseShlbGUsIHNoaWZ0ZWQpIHtcbiAgICB2YXIgZUluZm8gPSBnZXRJbmZvKGVsZSk7XG4gICAgdmFyIGluY29tZXJzID0gZWxlLmluY29tZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSAtMTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGluY29tZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgaW5jbXIgPSBpbmNvbWVyc1trXTtcbiAgICAgIHZhciBpSW5mbyA9IGdldEluZm8oaW5jbXIpO1xuICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgaUluZm8uZGVwdGgpO1xuICAgIH1cbiAgICBpZiAoZUluZm8uZGVwdGggPD0gbWF4RGVwdGgpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hY3ljbGljICYmIHNoaWZ0ZWRbaWRdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RlcHRoID0gbWF4RGVwdGggKyAxO1xuICAgICAgY2hhbmdlRGVwdGgoZWxlLCBuZXdEZXB0aCk7XG4gICAgICBzaGlmdGVkW2lkXSA9IG5ld0RlcHRoO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBmb3IgdGhlIGRpcmVjdGVkIGNhc2UsIHRyeSB0byBtYWtlIHRoZSBlZGdlcyBhbGwgZ28gZG93biAoaS5lLiBkZXB0aCBpID0+IGRlcHRoIGkgKyAxKVxuICBpZiAoZGlyZWN0ZWQgJiYgbWF4aW1hbCkge1xuICAgIHZhciBRID0gW107XG4gICAgdmFyIHNoaWZ0ZWQgPSB7fTtcbiAgICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUobikge1xuICAgICAgcmV0dXJuIFEucHVzaChuKTtcbiAgICB9O1xuICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgIHJldHVybiBRLnNoaWZ0KCk7XG4gICAgfTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgIH0pO1xuICAgIHdoaWxlIChRLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBfZWxlMyA9IGRlcXVldWUoKTtcbiAgICAgIHZhciBkaWRTaGlmdCA9IGFkanVzdE1heGltYWxseShfZWxlMywgc2hpZnRlZCk7XG4gICAgICBpZiAoZGlkU2hpZnQpIHtcbiAgICAgICAgX2VsZTMub3V0Z29lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICAgICAgfSkuZm9yRWFjaChlbnF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGlkU2hpZnQgPT09IG51bGwpIHtcbiAgICAgICAgd2FybignRGV0ZWN0ZWQgZG91YmxlIG1heGltYWwgc2hpZnQgZm9yIG5vZGUgYCcgKyBfZWxlMy5pZCgpICsgJ2AuICBCYWlsaW5nIG1heGltYWwgYWRqdXN0bWVudCBkdWUgdG8gY3ljbGUuICBVc2UgYG9wdGlvbnMubWF4aW1hbDogdHJ1ZWAgb25seSBvbiBEQUdzLicpO1xuICAgICAgICBicmVhazsgLy8gZXhpdCBvbiBmYWlsdXJlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciBuID0gbm9kZXNbX2kzXTtcbiAgICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgdmFyIGggPSBuYmIuaDtcbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCB0aGUgd2VpZ2h0ZWQgcGVyY2VudCBmb3IgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHMgY29ubmVjdGl2aXR5IHRvIG90aGVyIGxldmVsc1xuICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG4gIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRXZWlnaHRlZFBlcmNlbnQoZWxlKSB7XG4gICAgaWYgKGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldO1xuICAgIH1cbiAgICB2YXIgZWxlRGVwdGggPSBnZXRJbmZvKGVsZSkuZGVwdGg7XG4gICAgdmFyIG5laWdoYm9ycyA9IGVsZS5uZWlnaGJvcmhvb2QoKTtcbiAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgdmFyIHNhbXBsZXMgPSAwO1xuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5laWdoYm9ycy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbX2k0XTtcbiAgICAgIGlmIChuZWlnaGJvci5pc0VkZ2UoKSB8fCBuZWlnaGJvci5pc1BhcmVudCgpIHx8ICFub2Rlcy5oYXMobmVpZ2hib3IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGJmID0gZ2V0SW5mbyhuZWlnaGJvcik7XG4gICAgICBpZiAoYmYgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGJmLmluZGV4O1xuICAgICAgdmFyIGRlcHRoID0gYmYuZGVwdGg7XG5cbiAgICAgIC8vIHVuYXNzaWduZWQgbmVpZ2hib3VycyBzaG91bGRuJ3QgYWZmZWN0IHRoZSBvcmRlcmluZ1xuICAgICAgaWYgKGluZGV4ID09IG51bGwgfHwgZGVwdGggPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcbiAgICAgIGlmIChkZXB0aCA8IGVsZURlcHRoKSB7XG4gICAgICAgIC8vIG9ubHkgZ2V0IGluZmx1ZW5jZWQgYnkgZWxlbWVudHMgYWJvdmVcbiAgICAgICAgcGVyY2VudCArPSBpbmRleCAvIG5EZXB0aDtcbiAgICAgICAgc2FtcGxlcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBzYW1wbGVzID0gTWF0aC5tYXgoMSwgc2FtcGxlcyk7XG4gICAgcGVyY2VudCA9IHBlcmNlbnQgLyBzYW1wbGVzO1xuICAgIGlmIChzYW1wbGVzID09PSAwKSB7XG4gICAgICAvLyBwdXQgbG9uZSBub2RlcyBhdCB0aGUgc3RhcnRcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH1cbiAgICBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuICAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcbiAgdmFyIHNvcnRGbiA9IGZ1bmN0aW9uIHNvcnRGbihhLCBiKSB7XG4gICAgdmFyIGFwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoYSk7XG4gICAgdmFyIGJwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoYik7XG4gICAgdmFyIGRpZmYgPSBhcGN0IC0gYnBjdDtcbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFzY2VuZGluZyhhLmlkKCksIGIuaWQoKSk7IC8vIG1ha2Ugc3VyZSBzb3J0IGRvZXNuJ3QgaGF2ZSBkb24ndC1jYXJlIGNvbXBhcmlzb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgfTtcbiAgaWYgKG9wdGlvbnMuZGVwdGhTb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3J0Rm4gPSBvcHRpb25zLmRlcHRoU29ydDtcbiAgfVxuICB2YXIgZGVwdGhzTGVuID0gZGVwdGhzLmxlbmd0aDtcblxuICAvLyBzb3J0IGVhY2ggbGV2ZWwgdG8gbWFrZSBjb25uZWN0ZWQgbm9kZXMgY2xvc2VyXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGRlcHRoc0xlbjsgX2k1KyspIHtcbiAgICBkZXB0aHNbX2k1XS5zb3J0KHNvcnRGbik7XG4gICAgYXNzaWduRGVwdGhzQXQoX2k1KTtcbiAgfVxuXG4gIC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgdG8gYSBuZXcgdG9wLWxldmVsIGRlcHRoXG4gIHZhciBvcnBoYW5EZXB0aCA9IFtdO1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBvcnBoYW5Ob2Rlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgb3JwaGFuRGVwdGgucHVzaChvcnBoYW5Ob2Rlc1tfaTZdKTtcbiAgfVxuICB2YXIgYXNzaWduRGVwdGhzID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzKCkge1xuICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGRlcHRoc0xlbjsgX2k3KyspIHtcbiAgICAgIGFzc2lnbkRlcHRoc0F0KF9pNyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZCBhIG5ldyB0b3AtbGV2ZWwgZGVwdGggb25seSB3aGVuIHRoZXJlIGFyZSBvcnBoYW4gbm9kZXNcbiAgaWYgKG9ycGhhbkRlcHRoLmxlbmd0aCkge1xuICAgIGRlcHRocy51bnNoaWZ0KG9ycGhhbkRlcHRoKTtcbiAgICBkZXB0aHNMZW4gPSBkZXB0aHMubGVuZ3RoO1xuICAgIGFzc2lnbkRlcHRocygpO1xuICB9XG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgZGVwdGhzTGVuOyBfaTgrKykge1xuICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heChkZXB0aHNbX2k4XS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUpO1xuICB9XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG5cbiAgLy8gYXZlcmFnZSBub2RlIHNpemVcbiAgdmFyIGF2ZU5vZGVTaXplID0gbm9kZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5vZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJveCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogYWNjLncgPT09IC0xID8gYm94LncgOiAoYWNjLncgKyBib3gudykgLyAyLFxuICAgICAgICBoOiBhY2MuaCA9PT0gLTEgPyBib3guaCA6IChhY2MuaCArIGJveC5oKSAvIDJcbiAgICAgIH07XG4gICAgfShub2RlLmJvdW5kaW5nQm94KHtcbiAgICAgIGluY2x1ZGVMYWJlbHM6IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgfSkpO1xuICB9LCB7XG4gICAgdzogLTEsXG4gICAgaDogLTFcbiAgfSk7XG4gIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heChcbiAgLy8gb25seSBvbmUgZGVwdGhcbiAgZGVwdGhzTGVuID09PSAxID8gMCA6XG4gIC8vIGluc2lkZSBhIGJvdW5kaW5nIGJveCwgbm8gbmVlZCBmb3IgdG9wICYgYm90dG9tIHBhZGRpbmdcbiAgaGFzQm91bmRpbmdCb3ggPyAoYmIuaCAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBhdmVOb2RlU2l6ZS5oKSAvIChkZXB0aHNMZW4gLSAxKSA6IChiYi5oIC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIGF2ZU5vZGVTaXplLmgpIC8gKGRlcHRoc0xlbiArIDEpLCBtaW5EaXN0YW5jZSk7XG4gIHZhciBtYXhEZXB0aFNpemUgPSBkZXB0aHMucmVkdWNlKGZ1bmN0aW9uIChtYXgsIGVsZXMpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBlbGVzLmxlbmd0aCk7XG4gIH0sIDApO1xuICB2YXIgZ2V0UG9zaXRpb25Ub3BCb3R0b20gPSBmdW5jdGlvbiBnZXRQb3NpdGlvblRvcEJvdHRvbShlbGUpIHtcbiAgICB2YXIgX2dldEluZm8yID0gZ2V0SW5mbyhlbGUpLFxuICAgICAgZGVwdGggPSBfZ2V0SW5mbzIuZGVwdGgsXG4gICAgICBpbmRleCA9IF9nZXRJbmZvMi5pbmRleDtcbiAgICBpZiAob3B0aW9ucy5jaXJjbGUpIHtcbiAgICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKGJiLncgLyAyIC8gZGVwdGhzTGVuLCBiYi5oIC8gMiAvIGRlcHRoc0xlbik7XG4gICAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSk7XG4gICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRoc0xlbiA+IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA8PSAzID8gcmFkaXVzU3RlcFNpemUgLyAyIDogMCk7XG4gICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1tkZXB0aF0ubGVuZ3RoICogaW5kZXg7XG4gICAgICBpZiAoZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByYWRpdXMgPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHk6IGNlbnRlci55ICsgcmFkaXVzICogTWF0aC5zaW4odGhldGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG4gICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5tYXgoXG4gICAgICAvLyBvbmx5IG9uZSBkZXB0aFxuICAgICAgZGVwdGhTaXplID09PSAxID8gMCA6XG4gICAgICAvLyBpbnNpZGUgYSBib3VuZGluZyBib3gsIG5vIG5lZWQgZm9yIGxlZnQgJiByaWdodCBwYWRkaW5nXG4gICAgICBoYXNCb3VuZGluZ0JveCA/IChiYi53IC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIGF2ZU5vZGVTaXplLncpIC8gKChvcHRpb25zLmdyaWQgPyBtYXhEZXB0aFNpemUgOiBkZXB0aFNpemUpIC0gMSkgOiAoYmIudyAtIG9wdGlvbnMucGFkZGluZyAqIDIgLSBhdmVOb2RlU2l6ZS53KSAvICgob3B0aW9ucy5ncmlkID8gbWF4RGVwdGhTaXplIDogZGVwdGhTaXplKSArIDEpLCBtaW5EaXN0YW5jZSk7XG4gICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpIC8gMikgKiBkaXN0YW5jZVgsXG4gICAgICAgIHk6IGNlbnRlci55ICsgKGRlcHRoICsgMSAtIChkZXB0aHNMZW4gKyAxKSAvIDIpICogZGlzdGFuY2VZXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGVwb3M7XG4gICAgfVxuICB9O1xuICB2YXIgcm90YXRlRGVncmVlcyA9IHtcbiAgICAnZG93bndhcmQnOiAwLFxuICAgICdsZWZ0d2FyZCc6IDkwLFxuICAgICd1cHdhcmQnOiAxODAsXG4gICAgJ3JpZ2h0d2FyZCc6IC05MFxuICB9O1xuICBpZiAoT2JqZWN0LmtleXMocm90YXRlRGVncmVlcykuaW5kZXhPZihvcHRpb25zLmRpcmVjdGlvbikgPT09IC0xKSB7XG4gICAgZXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvbiAnXCIuY29uY2F0KG9wdGlvbnMuZGlyZWN0aW9uLCBcIicgc3BlY2lmaWVkIGZvciBicmVhZHRoZmlyc3QgbGF5b3V0LiBWYWxpZCB2YWx1ZXMgYXJlOiBcIikuY29uY2F0KE9iamVjdC5rZXlzKHJvdGF0ZURlZ3JlZXMpLmpvaW4oJywgJykpKTtcbiAgfVxuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGUpIHtcbiAgICByZXR1cm4gcm90YXRlUG9zQW5kU2tld0J5Qm94KGdldFBvc2l0aW9uVG9wQm90dG9tKGVsZSksIGJiLCByb3RhdGVEZWdyZWVzW29wdGlvbnMuZGlyZWN0aW9uXSk7XG4gIH07XG4gIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zaXRpb24pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyQ2ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBhbmQgcmFkaXVzIGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICByYWRpdXM6IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLFxuICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLFxuICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgc29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ2LCBvcHRpb25zKTtcbn1cbkNpcmNsZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gIHZhciBkVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIG5vZGVzLmxlbmd0aCAtIDEpO1xuICB2YXIgcjtcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB2YXIgdyA9IG5iYi53O1xuICAgIHZhciBoID0gbmJiLmg7XG4gICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gIH1cbiAgaWYgKG51bWJlciQxKG9wdGlvbnMucmFkaXVzKSkge1xuICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgfSBlbHNlIGlmIChub2Rlcy5sZW5ndGggPD0gMSkge1xuICAgIHIgPSAwO1xuICB9IGVsc2Uge1xuICAgIHIgPSBNYXRoLm1pbihiYi5oLCBiYi53KSAvIDIgLSBtaW5EaXN0YW5jZTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gIGlmIChub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gIH1cbiAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhlbGUsIGkpIHtcbiAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyBpICogZFRoZXRhICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgdmFyIHJ4ID0gciAqIE1hdGguY29zKHRoZXRhKTtcbiAgICB2YXIgcnkgPSByICogTWF0aC5zaW4odGhldGEpO1xuICAgIHZhciBwb3MgPSB7XG4gICAgICB4OiBjZW50ZXIueCArIHJ4LFxuICAgICAgeTogY2VudGVyLnkgKyByeVxuICAgIH07XG4gICAgcmV0dXJuIHBvcztcbiAgfTtcbiAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyQ1ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSxcbiAgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLFxuICAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLFxuICAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25jZW50cmljOiBmdW5jdGlvbiBjb25jZW50cmljKG5vZGUpIHtcbiAgICAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICB9LFxuICBsZXZlbFdpZHRoOiBmdW5jdGlvbiBsZXZlbFdpZHRoKG5vZGVzKSB7XG4gICAgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG59O1xuZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNSwgb3B0aW9ucyk7XG59XG5Db25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG4gIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcbiAgICB2YWx1ZSA9IG9wdGlvbnMuY29uY2VudHJpYyhub2RlKTtcbiAgICBub2RlVmFsdWVzLnB1c2goe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbm9kZTogbm9kZVxuICAgIH0pO1xuXG4gICAgLy8gZm9yIHN0eWxlIG1hcHBpbmdcbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9XG5cbiAgLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcbiAgbm9kZXMudXBkYXRlU3R5bGUoKTtcblxuICAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuICAgIHZhciBuYmIgPSBfbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgobWF4Tm9kZVNpemUsIG5iYi53LCBuYmIuaCk7XG4gIH1cblxuICAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG4gIG5vZGVWYWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgfSk7XG4gIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKG5vZGVzKTtcblxuICAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuICB2YXIgbGV2ZWxzID0gW1tdXTtcbiAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVsc1swXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVZhbHVlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHZhbCA9IG5vZGVWYWx1ZXNbX2kyXTtcbiAgICBpZiAoY3VycmVudExldmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlKTtcbiAgICAgIGlmIChkaWZmID49IGxldmVsV2lkdGgpIHtcbiAgICAgICAgY3VycmVudExldmVsID0gW107XG4gICAgICAgIGxldmVscy5wdXNoKGN1cnJlbnRMZXZlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJlbnRMZXZlbC5wdXNoKHZhbCk7XG4gIH1cblxuICAvLyBjcmVhdGUgcG9zaXRpb25zIGZyb20gbGV2ZWxzXG5cbiAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICBpZiAoIW9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgIHZhciBtYXhSID0gTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdDtcbiAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDApO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtaW5EaXN0LCByU3RlcCk7XG4gIH1cblxuICAvLyBmaW5kIHRoZSBtZXRyaWNzIGZvciBlYWNoIGxldmVsXG4gIHZhciByID0gMDtcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGV2ZWxzLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbX2kzXTtcbiAgICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbGV2ZWwubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgICB2YXIgZFRoZXRhID0gbGV2ZWwuZFRoZXRhID0gc3dlZXAgLyBNYXRoLm1heCgxLCBsZXZlbC5sZW5ndGggLSAxKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgaWYgKGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0ICogbWluRGlzdCAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgIH1cbiAgICBsZXZlbC5yID0gcjtcbiAgICByICs9IG1pbkRpc3Q7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZXF1aWRpc3RhbnQpIHtcbiAgICB2YXIgckRlbHRhTWF4ID0gMDtcbiAgICB2YXIgX3IgPSAwO1xuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxldmVscy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgX2xldmVsID0gbGV2ZWxzW19pNF07XG4gICAgICB2YXIgckRlbHRhID0gX2xldmVsLnIgLSBfcjtcbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICB9XG4gICAgX3IgPSAwO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGxldmVscy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgX2xldmVsMiA9IGxldmVsc1tfaTVdO1xuICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICBfciA9IF9sZXZlbDIucjtcbiAgICAgIH1cbiAgICAgIF9sZXZlbDIuciA9IF9yO1xuICAgICAgX3IgKz0gckRlbHRhTWF4O1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgdmFyIHBvcyA9IHt9OyAvLyBpZCA9PiBwb3NpdGlvblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBsZXZlbHMubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfbGV2ZWwzID0gbGV2ZWxzW19pNl07XG4gICAgdmFyIF9kVGhldGEgPSBfbGV2ZWwzLmRUaGV0YTtcbiAgICB2YXIgX3IyID0gX2xldmVsMy5yO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2xldmVsMy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF92YWwgPSBfbGV2ZWwzW2pdO1xuICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBfZFRoZXRhICogajtcbiAgICAgIHZhciBwID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIF9yMiAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgeTogY2VudGVyLnkgKyBfcjIgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgIH07XG4gICAgICBwb3NbX3ZhbC5ub2RlLmlkKCldID0gcDtcbiAgICB9XG4gIH1cblxuICAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcbiAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgcmV0dXJuIHBvc1tpZF07XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8qXG5UaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2dlcmFyZG9odWNrL1xuXG5CYXNlZCBvbiB0aGUgZm9sbG93aW5nIGFydGljbGU6XG5odHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9MTQ5ODA0N1xuXG5Nb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cblxudmFyIERFQlVHO1xuXG4vKipcbiAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gKi9cbnZhciBkZWZhdWx0cyQ0ID0ge1xuICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30sXG4gIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgLy8gdHJ1ZSA6IEFuaW1hdGUgY29udGludW91c2x5IGFzIHRoZSBsYXlvdXQgaXMgcnVubmluZ1xuICAvLyBmYWxzZSA6IEp1c3Qgc2hvdyB0aGUgZW5kIHJlc3VsdFxuICAvLyAnZW5kJyA6IEFuaW1hdGUgd2l0aCB0aGUgZW5kIHJlc3VsdCwgZnJvbSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgdG8gdGhlIGVuZCBwb3NpdGlvbnNcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgLy8gRWFzaW5nIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkXG4gIC8vIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZFxuICAvLyBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gVGhlIGxheW91dCBhbmltYXRlcyBvbmx5IGFmdGVyIHRoaXMgbWFueSBtaWxsaXNlY29uZHMgZm9yIGFuaW1hdGU6dHJ1ZVxuICAvLyAocHJldmVudHMgZmxhc2hpbmcgb24gZmFzdCBydW5zKVxuICBhbmltYXRpb25UaHJlc2hvbGQ6IDI1MCxcbiAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZVxuICByZWZyZXNoOiAyMCxcbiAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIG9uIGZpdFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIFJhbmRvbWl6ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzICh0cnVlKSBvciB1c2UgZXhpc3RpbmcgcG9zaXRpb25zIChmYWxzZSlcbiAgcmFuZG9taXplOiBmYWxzZSxcbiAgLy8gRXh0cmEgc3BhY2luZyBiZXR3ZWVuIGNvbXBvbmVudHMgaW4gbm9uLWNvbXBvdW5kIGdyYXBoc1xuICBjb21wb25lbnRTcGFjaW5nOiA0MCxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiBmdW5jdGlvbiBub2RlUmVwdWxzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gMjA0ODtcbiAgfSxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVPdmVybGFwOiA0LFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiBpZGVhbEVkZ2VMZW5ndGgoZWRnZSkge1xuICAgIHJldHVybiAzMjtcbiAgfSxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9LFxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDEuMixcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDEsXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAxMDAwLFxuICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICBpbml0aWFsVGVtcDogMTAwMCxcbiAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgY29vbGluZ0ZhY3RvcjogMC45OSxcbiAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgdGhyZXNob2xkIChiZWxvdyB0aGlzIHBvaW50IHRoZSBsYXlvdXQgd2lsbCBlbmQpXG4gIG1pblRlbXA6IDEuMFxufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgOiBjb25zdHJ1Y3RvclxuICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQ29zZUxheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNCwgb3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucy5sYXlvdXQgPSB0aGlzO1xuXG4gIC8vIEV4Y2x1ZGUgYW55IGVkZ2UgdGhhdCBoYXMgYSBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGUgdGhhdCBpcyBub3QgaW4gdGhlIHNldCBvZiBwYXNzZWQtaW4gbm9kZXNcbiAgdmFyIG5vZGVzID0gdGhpcy5vcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGVkZ2VzID0gdGhpcy5vcHRpb25zLmVsZXMuZWRnZXMoKTtcbiAgdmFyIG5vdEVkZ2VzID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZUlkID0gZS5zb3VyY2UoKS5kYXRhKCdpZCcpO1xuICAgIHZhciB0YXJnZXRJZCA9IGUudGFyZ2V0KCkuZGF0YSgnaWQnKTtcbiAgICB2YXIgaGFzU291cmNlID0gbm9kZXMuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4uZGF0YSgnaWQnKSA9PT0gc291cmNlSWQ7XG4gICAgfSk7XG4gICAgdmFyIGhhc1RhcmdldCA9IG5vZGVzLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLmRhdGEoJ2lkJykgPT09IHRhcmdldElkO1xuICAgIH0pO1xuICAgIHJldHVybiAhaGFzU291cmNlIHx8ICFoYXNUYXJnZXQ7XG4gIH0pO1xuICB0aGlzLm9wdGlvbnMuZWxlcyA9IHRoaXMub3B0aW9ucy5lbGVzLm5vdChub3RFZGdlcyk7XG59XG5cbi8qKlxuICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gKi9cbkNvc2VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBsYXlvdXQgPSB0aGlzO1xuICBsYXlvdXQuc3RvcHBlZCA9IGZhbHNlO1xuICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFNldCBERUJVRyAtIEdsb2JhbCB2YXJpYWJsZVxuICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgIERFQlVHID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBERUJVRyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICB2YXIgbGF5b3V0SW5mbyA9IGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucyk7XG5cbiAgLy8gU2hvdyBMYXlvdXRJbmZvIGNvbnRlbnRzIGlmIGRlYnVnZ2luZ1xuICBpZiAoREVCVUcpIHtcbiAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gIH1cblxuICAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbiAgfVxuICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuXG4gICAgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5maXQpIHtcbiAgICAgIGN5LmZpdChvcHRpb25zLnBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbiAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24gbWFpbkxvb3AoaSkge1xuICAgIGlmIChsYXlvdXQuc3RvcHBlZCB8fCBpID49IG9wdGlvbnMubnVtSXRlcikge1xuICAgICAgLy8gbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG4gICAgc3RlcChsYXlvdXRJbmZvLCBvcHRpb25zKTtcblxuICAgIC8vIFVwZGF0ZSB0ZW1wZXJhdHVyZVxuICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yO1xuICAgIC8vIGxvZ0RlYnVnKFwiTmV3IHRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuXG4gICAgaWYgKGxheW91dEluZm8udGVtcGVyYXR1cmUgPCBvcHRpb25zLm1pblRlbXApIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiVGVtcGVyYXR1cmUgZHJvcCBiZWxvdyBtaW5pbXVtIHRocmVzaG9sZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgcmVmcmVzaCgpO1xuXG4gICAgICAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICAgICAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBnZXRTY2FsZWRQb3MpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbG9vcFJldCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUpIHtcbiAgICB2YXIgX2ZyYW1lID0gZnVuY3Rpb24gZnJhbWUoKSB7XG4gICAgICB2YXIgZiA9IDA7XG4gICAgICB3aGlsZSAobG9vcFJldCAmJiBmIDwgb3B0aW9ucy5yZWZyZXNoKSB7XG4gICAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgaSsrO1xuICAgICAgICBmKys7XG4gICAgICB9XG4gICAgICBpZiAoIWxvb3BSZXQpIHtcbiAgICAgICAgLy8gaXQncyBkb25lXG4gICAgICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIGlmIChub3cgLSBzdGFydFRpbWUgPj0gb3B0aW9ucy5hbmltYXRpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9mcmFtZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBfZnJhbWUoKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobG9vcFJldCkge1xuICAgICAgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgZG9uZSgpO1xuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG4gIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5Db3NlTGF5b3V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgOiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCBpcyBjb250YWlucyBhbGwgdGhlIGRhdGFcbiAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAqIEByZXR1cm4gICAgOiBsYXlvdXRJbmZvIG9iamVjdCBpbml0aWFsaXplZFxuICovXG52YXIgY3JlYXRlTGF5b3V0SW5mbyA9IGZ1bmN0aW9uIGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucykge1xuICAvLyBTaG9ydGN1dFxuICB2YXIgZWRnZXMgPSBvcHRpb25zLmVsZXMuZWRnZXMoKTtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgbGF5b3V0SW5mbyA9IHtcbiAgICBpc0NvbXBvdW5kOiBjeS5oYXNDb21wb3VuZE5vZGVzKCksXG4gICAgbGF5b3V0Tm9kZXM6IFtdLFxuICAgIGlkVG9JbmRleDoge30sXG4gICAgbm9kZVNpemU6IG5vZGVzLnNpemUoKSxcbiAgICBncmFwaFNldDogW10sXG4gICAgaW5kZXhUb0dyYXBoOiBbXSxcbiAgICBsYXlvdXRFZGdlczogW10sXG4gICAgZWRnZVNpemU6IGVkZ2VzLnNpemUoKSxcbiAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICBjbGllbnRXaWR0aDogYmIudyxcbiAgICBjbGllbnRIZWlnaHQ6IGJiLmgsXG4gICAgYm91bmRpbmdCb3g6IGJiXG4gIH07XG4gIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5lbGVzLmNvbXBvbmVudHMoKTtcbiAgdmFyIGlkMmNtcHRJZCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRbal07XG4gICAgICBpZDJjbXB0SWRbbm9kZS5pZCgpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIHZhciB0ZW1wTm9kZSA9IHt9O1xuICAgIHRlbXBOb2RlLmlzTG9ja2VkID0gbi5sb2NrZWQoKTtcbiAgICB0ZW1wTm9kZS5pZCA9IG4uZGF0YSgnaWQnKTtcbiAgICB0ZW1wTm9kZS5wYXJlbnRJZCA9IG4uZGF0YSgncGFyZW50Jyk7XG4gICAgdGVtcE5vZGUuY21wdElkID0gaWQyY21wdElkW24uaWQoKV07XG4gICAgdGVtcE5vZGUuY2hpbGRyZW4gPSBbXTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblggPSBuLnBvc2l0aW9uKCd4Jyk7XG4gICAgdGVtcE5vZGUucG9zaXRpb25ZID0gbi5wb3NpdGlvbigneScpO1xuICAgIHRlbXBOb2RlLm9mZnNldFggPSAwO1xuICAgIHRlbXBOb2RlLm9mZnNldFkgPSAwO1xuICAgIHRlbXBOb2RlLmhlaWdodCA9IG5iYi53O1xuICAgIHRlbXBOb2RlLndpZHRoID0gbmJiLmg7XG4gICAgdGVtcE5vZGUubWF4WCA9IHRlbXBOb2RlLnBvc2l0aW9uWCArIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICB0ZW1wTm9kZS5taW5YID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggLyAyO1xuICAgIHRlbXBOb2RlLm1heFkgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLm1pblkgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgIHRlbXBOb2RlLnBhZExlZnQgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkUmlnaHQgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkVG9wID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgIHRlbXBOb2RlLnBhZEJvdHRvbSA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcblxuICAgIC8vIGZvcmNlc1xuICAgIHRlbXBOb2RlLm5vZGVSZXB1bHNpb24gPSBmbiQ2KG9wdGlvbnMubm9kZVJlcHVsc2lvbikgPyBvcHRpb25zLm5vZGVSZXB1bHNpb24obikgOiBvcHRpb25zLm5vZGVSZXB1bHNpb247XG5cbiAgICAvLyBBZGQgbmV3IG5vZGVcbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzLnB1c2godGVtcE5vZGUpO1xuICAgIC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcbiAgICBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5pZF0gPSBpO1xuICB9XG5cbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICB2YXIgdGVtcEdyYXBoID0gW107XG5cbiAgLy8gU2Vjb25kIHBhc3MgdG8gYWRkIGNoaWxkIGluZm9ybWF0aW9uIGFuZFxuICAvLyBpbml0aWFsaXplIHF1ZXVlIGZvciBoaWVyYXJjaGljYWwgdHJhdmVyc2FsXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDtcbiAgICAvLyBDaGVjayBpZiBub2RlIG4gaGFzIGEgcGFyZW50IG5vZGVcbiAgICBpZiAobnVsbCAhPSBwX2lkKSB7XG4gICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcm9vdCBncmFwaCB0byBncmFwaFNldFxuICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2godGVtcEdyYXBoKTtcblxuICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgIHZhciBub2RlX2lkID0gcXVldWVbc3RhcnQrK107XG4gICAgdmFyIG5vZGVfaXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlX2lkXTtcbiAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZV9peF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIG5vZGVzIGFzIGEgbmV3IGdyYXBoIHRvIGdyYXBoIHNldFxuICAgICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKGNoaWxkcmVuKTtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXTtcbiAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICB2YXIgdGVtcEVkZ2UgPSB7fTtcbiAgICB0ZW1wRWRnZS5pZCA9IGUuZGF0YSgnaWQnKTtcbiAgICB0ZW1wRWRnZS5zb3VyY2VJZCA9IGUuZGF0YSgnc291cmNlJyk7XG4gICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoJ3RhcmdldCcpO1xuXG4gICAgLy8gQ29tcHV0ZSBpZGVhbCBsZW5ndGhcbiAgICB2YXIgaWRlYWxMZW5ndGggPSBmbiQ2KG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKSA/IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKGUpIDogb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gICAgdmFyIGVsYXN0aWNpdHkgPSBmbiQ2KG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkpID8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eShlKSA6IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7XG5cbiAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcbiAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFt0YXJnZXRJeF07XG4gICAgaWYgKHNvdXJjZUdyYXBoICE9IHRhcmdldEdyYXBoKSB7XG4gICAgICAvLyBGaW5kIGxvd2VzdCBjb21tb24gZ3JhcGggYW5jZXN0b3JcbiAgICAgIHZhciBsY2EgPSBmaW5kTENBKHRlbXBFZGdlLnNvdXJjZUlkLCB0ZW1wRWRnZS50YXJnZXRJZCwgbGF5b3V0SW5mbyk7XG5cbiAgICAgIC8vIENvbXB1dGUgc3VtIG9mIG5vZGUgZGVwdGhzLCByZWxhdGl2ZSB0byBsY2EgZ3JhcGhcbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgIHZhciBkZXB0aCA9IDA7XG5cbiAgICAgIC8vIFNvdXJjZSBkZXB0aFxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB3aGlsZSAoLTEgPT09IGxjYUdyYXBoLmluZGV4T2YodGVtcE5vZGUuaWQpKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXJnZXQgZGVwdGhcbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG4gICAgICB3aGlsZSAoLTEgPT09IGxjYUdyYXBoLmluZGV4T2YodGVtcE5vZGUuaWQpKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2dEZWJ1ZygnTENBIG9mIG5vZGVzICcgKyB0ZW1wRWRnZS5zb3VyY2VJZCArICcgYW5kICcgKyB0ZW1wRWRnZS50YXJnZXRJZCArXG4gICAgICAvLyAgXCIuIEluZGV4OiBcIiArIGxjYSArIFwiIENvbnRlbnRzOiBcIiArIGxjYUdyYXBoLnRvU3RyaW5nKCkgK1xuICAgICAgLy8gIFwiLiBEZXB0aDogXCIgKyBkZXB0aCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgfVxuICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG4gICAgdGVtcEVkZ2UuZWxhc3RpY2l0eSA9IGVsYXN0aWNpdHk7XG4gICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuICByZXR1cm4gbGF5b3V0SW5mbztcbn07XG5cbi8qKlxuICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAqXG4gKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICovXG52YXIgZmluZExDQSA9IGZ1bmN0aW9uIGZpbmRMQ0Eobm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvKSB7XG4gIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gIHZhciByZXMgPSBfZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcbiAgaWYgKDIgPiByZXMuY291bnQpIHtcbiAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLFxuICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzLmdyYXBoO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAqXG4gKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdG9ycyAobWF4OiAyKSBmb3VuZCBpblxuICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAqL1xudmFyIF9maW5kTENBX2F1eCA9IGZ1bmN0aW9uIGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbykge1xuICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdO1xuICAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuICBpZiAoLTEgPCBncmFwaC5pbmRleE9mKG5vZGUxKSAmJiAtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiAyLFxuICAgICAgZ3JhcGg6IGdyYXBoSXhcbiAgICB9O1xuICB9XG5cbiAgLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcbiAgdmFyIGMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGVJZCA9IGdyYXBoW2ldO1xuICAgIHZhciBub2RlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjtcblxuICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICB2YXIgcmVzdWx0ID0gX2ZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgY2hpbGRHcmFwaEl4LCBsYXlvdXRJbmZvKTtcbiAgICBpZiAoMCA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKDEgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gT25lIG9mIChub2RlMSwgbm9kZTIpIGlzIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgYysrO1xuICAgICAgaWYgKDIgPT09IGMpIHtcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmb3VuZCBib3RoIG5vZGVzLCBubyBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY291bnQ6IGMsXG4gICAgZ3JhcGg6IGdyYXBoSXhcbiAgfTtcbn07XG5cbi8qKlxuICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZ1xuICovXG52YXIgcHJpbnRMYXlvdXRJbmZvOyBcblxuLyoqXG4gKiBAYnJpZWYgOiBSYW5kb21pemVzIHRoZSBwb3NpdGlvbiBvZiBhbGwgbm9kZXNcbiAqL1xudmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSkge1xuICB2YXIgd2lkdGggPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXMgb3IgbG9ja2VkIG5vZGVzXG4gICAgaWYgKDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICB9XG4gIH1cbn07XG52YXIgZ2V0U2NhbGVJbkJvdW5kc0ZuID0gZnVuY3Rpb24gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKSB7XG4gIHZhciBiYiA9IGxheW91dEluZm8uYm91bmRpbmdCb3g7XG4gIHZhciBjb3NlQkIgPSB7XG4gICAgeDE6IEluZmluaXR5LFxuICAgIHgyOiAtSW5maW5pdHksXG4gICAgeTE6IEluZmluaXR5LFxuICAgIHkyOiAtSW5maW5pdHlcbiAgfTtcbiAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W25vZGUuZGF0YSgnaWQnKV1dO1xuICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoY29zZUJCLngyLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oY29zZUJCLnkxLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgIH0pO1xuICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtlbGUuZGF0YSgnaWQnKV1dO1xuICAgIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgICAvLyB0aGVuIGFkZCBleHRyYSBib3VuZGluZyBib3ggY29uc3RyYWludFxuICAgICAgLy8gSGFuZGxlIHNpbmdsZSBub2RlIGNhc2Ugd2hlcmUgY29zZUJCLncgb3IgY29zZUJCLmggaXMgMFxuICAgICAgdmFyIHBjdFggPSBjb3NlQkIudyA9PT0gMCA/IDAuNSA6IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICB2YXIgcGN0WSA9IGNvc2VCQi5oID09PSAwID8gMC41IDogKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgIHk6IGJiLnkxICsgcGN0WSAqIGJiLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGluIHRoZSBuZXR3b3JrXG4gKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdFxuICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gIG5vZGVzLnBvc2l0aW9ucyhnZXRTY2FsZWRQb3MpO1xuXG4gIC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG4gIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgLy8gcyA9ICdUcmlnZ2VyaW5nIGxheW91dHJlYWR5JztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICBsYXlvdXQ6IHRoaXNcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICovXG4vLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgIGlmIChERUJVRykge1xuLy8gICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4vLyAgIH1cbi8vIH07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFxuICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHN0ZXAgPSBmdW5jdGlvbiBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMsIF9zdGVwKSB7XG4gIC8vIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gIC8vIHMgKz0gXCJcXG5TVEVQOiBcIiArIHN0ZXA7XG4gIC8vIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG4gIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbyk7XG4gIC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvKTtcbiAgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbyk7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAqL1xudmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gIC8vIHZhciBzID0gJ2NhbGN1bGF0ZU5vZGVGb3JjZXMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgIC8vIE9ubHkgZ2V0IGVhY2ggcGFpciBvbmNlLCAoQSwgQikgPSAoQiwgQSlcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtrXV1dO1xuICAgICAgICBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJhbmRvbURpc3RhbmNlID0gZnVuY3Rpb24gcmFuZG9tRGlzdGFuY2UobWF4KSB7XG4gIHJldHVybiAtMSArIDIgKiBtYXggKiBNYXRoLnJhbmRvbSgpO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAqL1xudmFyIG5vZGVSZXB1bHNpb24gPSBmdW5jdGlvbiBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyB2YXIgcyA9IFwiTm9kZSByZXB1bHNpb24uIE5vZGUxOiBcIiArIG5vZGUxLmlkICsgXCIgTm9kZTI6IFwiICsgbm9kZTIuaWQ7XG5cbiAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuICBpZiAoY21wdElkMSAhPT0gY21wdElkMiAmJiAhbGF5b3V0SW5mby5pc0NvbXBvdW5kKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gIHZhciBkaXJlY3Rpb25ZID0gbm9kZTIucG9zaXRpb25ZIC0gbm9kZTEucG9zaXRpb25ZO1xuICB2YXIgbWF4UmFuZERpc3QgPSAxO1xuICAvLyBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcblxuICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgZGlyZWN0aW9uWCA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgICBkaXJlY3Rpb25ZID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICB9XG4gIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gIGlmIChvdmVybGFwID4gMCkge1xuICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBETyBvdmVybGFwLlwiO1xuICAgIC8vIHMgKz0gXCJcXG5PdmVybGFwOiBcIiArIG92ZXJsYXA7XG4gICAgLy8gSWYgbm9kZXMgb3ZlcmxhcCwgcmVwdWxzaW9uIGZvcmNlIGlzIHByb3BvcnRpb25hbFxuICAgIC8vIHRvIHRoZSBvdmVybGFwXG4gICAgdmFyIGZvcmNlID0gb3B0aW9ucy5ub2RlT3ZlcmxhcCAqIG92ZXJsYXA7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTtcbiAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cbiAgICAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcbiAgICB2YXIgZGlzdGFuY2VYID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICB2YXIgZGlzdGFuY2VZID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICB2YXIgZGlzdGFuY2VTcXIgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3FyKTtcbiAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgIHZhciBmb3JjZSA9IChub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbikgLyBkaXN0YW5jZVNxcjtcbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgfVxuXG4gIC8vIEFwcGx5IGZvcmNlXG4gIGlmICghbm9kZTEuaXNMb2NrZWQpIHtcbiAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICBub2RlMS5vZmZzZXRZIC09IGZvcmNlWTtcbiAgfVxuICBpZiAoIW5vZGUyLmlzTG9ja2VkKSB7XG4gICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgbm9kZTIub2Zmc2V0WSArPSBmb3JjZVk7XG4gIH1cblxuICAvLyBzICs9IFwiXFxuRm9yY2VYOiBcIiArIGZvcmNlWCArIFwiIEZvcmNlWTogXCIgKyBmb3JjZVk7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIHJldHVybjtcbn07XG5cbi8qKlxuICogQGJyaWVmICA6IERldGVybWluZXMgd2hldGhlciB0d28gbm9kZXMgb3ZlcmxhcCBvciBub3RcbiAqIEByZXR1cm4gOiBBbW91bnQgb2Ygb3ZlcmxhcHBpbmcgKDAgPT4gbm8gb3ZlcmxhcClcbiAqL1xudmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uIG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuICBpZiAoZFggPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gIH1cbiAgaWYgKGRZID4gMCkge1xuICAgIHZhciBvdmVybGFwWSA9IG5vZGUxLm1heFkgLSBub2RlMi5taW5ZO1xuICB9IGVsc2Uge1xuICAgIHZhciBvdmVybGFwWSA9IG5vZGUyLm1heFkgLSBub2RlMS5taW5ZO1xuICB9XG4gIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KG92ZXJsYXBYICogb3ZlcmxhcFggKyBvdmVybGFwWSAqIG92ZXJsYXBZKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBGaW5kcyB0aGUgcG9pbnQgaW4gd2hpY2ggYW4gZWRnZSAoZGlyZWN0aW9uIGRYLCBkWSkgaW50ZXJzZWN0c1xuICogICAgICAgICAgdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGJveCBvZiBpdCdzIHNvdXJjZS90YXJnZXQgbm9kZVxuICovXG52YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbiBmaW5kQ2xpcHBpbmdQb2ludChub2RlLCBkWCwgZFkpIHtcbiAgLy8gU2hvcmN1dHNcbiAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgdmFyIGRpclNsb3BlID0gZFkgLyBkWDtcbiAgdmFyIG5vZGVTbG9wZSA9IEggLyBXO1xuXG4gIC8vIHZhciBzID0gJ0NvbXB1dGluZyBjbGlwcGluZyBwb2ludCBvZiBub2RlICcgKyBub2RlLmlkICtcbiAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICtcbiAgLy8gICBcIlxcbkRpcmVjdGlvbiBcIiArIGRYICsgXCIsIFwiICsgZFk7XG4gIC8vXG4gIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG4gIHZhciByZXMgPSB7fTtcblxuICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKHVwKVxuICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgcmVzLnggPSBYO1xuICAgIC8vIHMgKz0gXCJcXG5VcCBkaXJlY3Rpb25cIjtcbiAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuICBpZiAoMCA9PT0gZFggJiYgMCA+IGRZKSB7XG4gICAgcmVzLnggPSBYO1xuICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgIC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuICBpZiAoMCA8IGRYICYmIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgIHJlcy54ID0gWCArIFcgLyAyO1xuICAgIHJlcy55ID0gWSArIFcgKiBkWSAvIDIgLyBkWDtcbiAgICAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuICBpZiAoMCA+IGRYICYmIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgIHJlcy55ID0gWSAtIFcgKiBkWSAvIDIgLyBkWDtcbiAgICAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcbiAgaWYgKDAgPCBkWSAmJiAoZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHwgZGlyU2xvcGUgPj0gbm9kZVNsb3BlKSkge1xuICAgIHJlcy54ID0gWCArIEggKiBkWCAvIDIgLyBkWTtcbiAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgaWYgKDAgPiBkWSAmJiAoZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHwgZGlyU2xvcGUgPj0gbm9kZVNsb3BlKSkge1xuICAgIHJlcy54ID0gWCAtIEggKiBkWCAvIDIgLyBkWTtcbiAgICByZXMueSA9IFkgLSBIIC8gMjtcbiAgICAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICovXG52YXIgY2FsY3VsYXRlRWRnZUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgLy8gR2V0IGVkZ2UsIHNvdXJjZSAmIHRhcmdldCBub2Rlc1xuICAgIHZhciBlZGdlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnNvdXJjZUlkXTtcbiAgICB2YXIgc291cmNlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgdmFyIHRhcmdldCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuXG4gICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICB2YXIgZGlyZWN0aW9uWCA9IHRhcmdldC5wb3NpdGlvblggLSBzb3VyY2UucG9zaXRpb25YO1xuICAgIHZhciBkaXJlY3Rpb25ZID0gdGFyZ2V0LnBvc2l0aW9uWSAtIHNvdXJjZS5wb3NpdGlvblk7XG5cbiAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgIC8vIEEgcmFuZG9tIGZvcmNlIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCBhcyBub2RlIHJlcHVsc2lvblxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG4gICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcbiAgICB2YXIgZm9yY2UgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBlZGdlLmVsYXN0aWNpdHk7XG4gICAgaWYgKDAgIT09IGwpIHtcbiAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGx4IC8gbDtcbiAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGx5IC8gbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZvcmNlWCA9IDA7XG4gICAgICB2YXIgZm9yY2VZID0gMDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuICAgIGlmICghc291cmNlLmlzTG9ja2VkKSB7XG4gICAgICBzb3VyY2Uub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICBzb3VyY2Uub2Zmc2V0WSArPSBmb3JjZVk7XG4gICAgfVxuICAgIGlmICghdGFyZ2V0LmlzTG9ja2VkKSB7XG4gICAgICB0YXJnZXQub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICB0YXJnZXQub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgfVxuXG4gICAgLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAqL1xudmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGlzdFRocmVzaG9sZCA9IDE7XG5cbiAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gQ29tcHV0ZSBncmFwaCBjZW50ZXJcbiAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgdmFyIGNlbnRlclggPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICB2YXIgY2VudGVyWSA9IGxheW91dEluZm8uY2xpZW50V2lkdGggLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgdmFyIHRlbXAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoWzBdXV07XG4gICAgICB2YXIgcGFyZW50ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wLnBhcmVudElkXV07XG4gICAgICB2YXIgY2VudGVyWCA9IHBhcmVudC5wb3NpdGlvblg7XG4gICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgfVxuICAgIC8vIHMgPSBcIkNlbnRlciBmb3VuZCBhdDogXCIgKyBjZW50ZXJYICsgXCIsIFwiICsgY2VudGVyWTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgIGlmIChub2RlLmlzTG9ja2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgdmFyIGR5ID0gY2VudGVyWSAtIG5vZGUucG9zaXRpb25ZO1xuICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgaWYgKGQgPiBkaXN0VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgdmFyIGZ5ID0gb3B0aW9ucy5ncmF2aXR5ICogZHkgLyBkO1xuICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTtcbiAgICAgICAgLy8gcyArPSBcIjogQXBwbGllZCBmb3JjZTogXCIgKyBmeCArIFwiLCBcIiArIGZ5O1xuICAgICAgfVxuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFRoaXMgZnVuY3Rpb24gcHJvcGFnYXRlcyB0aGUgZXhpc3Rpbmcgb2Zmc2V0cyBmcm9tXG4gKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cbnZhciBwcm9wYWdhdGVGb3JjZXMgPSBmdW5jdGlvbiBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhcnQgPSAwOyAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gIC8vIGxvZ0RlYnVnKCdwcm9wYWdhdGVGb3JjZXMnKTtcblxuICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSk7XG4gIGVuZCArPSBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdLmxlbmd0aDtcblxuICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgIHZhciBub2RlSWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUluZGV4XTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuICAgIGlmICgwIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmlzTG9ja2VkKSB7XG4gICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZO1xuXG4gICAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgK1xuICAgICAgLy8gICBcIi4gT2Zmc2V0WDogXCIgKyBvZmZYICsgXCIuIE9mZnNldFk6IFwiICsgb2ZmWTtcbiAgICAgIC8vIHMgKz0gXCJcXG4gQ2hpbGRyZW46IFwiICsgY2hpbGRyZW4udG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuW2ldXV07XG4gICAgICAgIC8vIFByb3BhZ2F0ZSBvZmZzZXRcbiAgICAgICAgY2hpbGROb2RlLm9mZnNldFggKz0gb2ZmWDtcbiAgICAgICAgY2hpbGROb2RlLm9mZnNldFkgKz0gb2ZmWTtcbiAgICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG4gICAgICBub2RlLm9mZnNldFggPSAwO1xuICAgICAgbm9kZS5vZmZzZXRZID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogVXBkYXRlcyB0aGUgbGF5b3V0IG1vZGVsIHBvc2l0aW9ucywgYmFzZWQgb25cbiAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAqL1xudmFyIHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIC8vIFJlc2V0IGJvdW5kYXJpZXMgZm9yIGNvbXBvdW5kIG5vZGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCB8fCBuLmlzTG9ja2VkKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIHNldCBjb21wb3VuZCBvciBsb2NrZWQgbm9kZSBwb3NpdGlvblxuICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICtcbiAgICAvLyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuXG4gICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG4gICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgIG4ucG9zaXRpb25YICs9IHRlbXBGb3JjZS54O1xuICAgIG4ucG9zaXRpb25ZICs9IHRlbXBGb3JjZS55O1xuICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgbi5vZmZzZXRZID0gMDtcbiAgICBuLm1pblggPSBuLnBvc2l0aW9uWCAtIG4ud2lkdGg7XG4gICAgbi5tYXhYID0gbi5wb3NpdGlvblggKyBuLndpZHRoO1xuICAgIG4ubWluWSA9IG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQ7XG4gICAgbi5tYXhZID0gbi5wb3NpdGlvblkgKyBuLmhlaWdodDtcbiAgICAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcbiAgICBfdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG4sIGxheW91dEluZm8pO1xuICB9XG5cbiAgLy8gVXBkYXRlIHNpemUsIHBvc2l0aW9uIG9mIGNvbXB1bmQgbm9kZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgIG4ud2lkdGggPSBuLm1heFggLSBuLm1pblg7XG4gICAgICBuLmhlaWdodCA9IG4ubWF4WSAtIG4ubWluWTtcbiAgICAgIC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgLy8gcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAvLyBzICs9IFwiXFxuV2lkdGg6IFwiICsgbi53aWR0aCArIFwiLCBIZWlnaHQ6IFwiICsgbi5oZWlnaHQ7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogTGltaXRzIGEgZm9yY2UgKGZvcmNlWCwgZm9yY2VZKSB0byBiZSBub3RcbiAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguXG4gOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLlxuICAqL1xudmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbiBsaW1pdEZvcmNlKGZvcmNlWCwgZm9yY2VZLCBtYXgpIHtcbiAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gIHZhciBmb3JjZSA9IE1hdGguc3FydChmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkpO1xuICBpZiAoZm9yY2UgPiBtYXgpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgeDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICB5OiBtYXggKiBmb3JjZVkgLyBmb3JjZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHg6IGZvcmNlWCxcbiAgICAgIHk6IGZvcmNlWVxuICAgIH07XG4gIH1cblxuICAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGVcbiAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gKi9cbnZhciBfdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG5vZGUsIGxheW91dEluZm8pIHtcbiAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICBpZiAobnVsbCA9PSBwYXJlbnRJZCkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEdldCBQYXJlbnQgTm9kZVxuICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAvLyBNYXhYXG4gIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgICAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgfVxuXG4gIC8vIE1pblhcbiAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgICAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgfVxuXG4gIC8vIE1heFlcbiAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgZmxhZyA9IHRydWU7XG4gICAgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gIH1cblxuICAvLyBNaW5ZXG4gIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgIGZsYWcgPSB0cnVlO1xuICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICB9XG5cbiAgLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcbiAgaWYgKGZsYWcpIHtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm4gX3VwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIC8vIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuICByZXR1cm47XG59O1xudmFyIHNlcGFyYXRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIHZhciBub2RlcyA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXM7XG4gIHZhciBjb21wb25lbnRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciBjaWQgPSBub2RlLmNtcHRJZDtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdID0gY29tcG9uZW50c1tjaWRdIHx8IFtdO1xuICAgIGNvbXBvbmVudC5wdXNoKG5vZGUpO1xuICB9XG4gIHZhciB0b3RhbEEgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG4gICAgaWYgKCFjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYy54MSA9IEluZmluaXR5O1xuICAgIGMueDIgPSAtSW5maW5pdHk7XG4gICAgYy55MSA9IEluZmluaXR5O1xuICAgIGMueTIgPSAtSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbiA9IGNbal07XG4gICAgICBjLngxID0gTWF0aC5taW4oYy54MSwgbi5wb3NpdGlvblggLSBuLndpZHRoIC8gMik7XG4gICAgICBjLngyID0gTWF0aC5tYXgoYy54Miwgbi5wb3NpdGlvblggKyBuLndpZHRoIC8gMik7XG4gICAgICBjLnkxID0gTWF0aC5taW4oYy55MSwgbi5wb3NpdGlvblkgLSBuLmhlaWdodCAvIDIpO1xuICAgICAgYy55MiA9IE1hdGgubWF4KGMueTIsIG4ucG9zaXRpb25ZICsgbi5oZWlnaHQgLyAyKTtcbiAgICB9XG4gICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgYy5oID0gYy55MiAtIGMueTE7XG4gICAgdG90YWxBICs9IGMudyAqIGMuaDtcbiAgfVxuICBjb21wb25lbnRzLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xuICAgIHJldHVybiBjMi53ICogYzIuaCAtIGMxLncgKiBjMS5oO1xuICB9KTtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciB1c2VkVyA9IDA7XG4gIHZhciByb3dIID0gMDtcbiAgdmFyIG1heFJvd1cgPSBNYXRoLnNxcnQodG90YWxBKSAqIGxheW91dEluZm8uY2xpZW50V2lkdGggLyBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuICAgIGlmICghYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG4gPSBjW2pdO1xuICAgICAgaWYgKCFuLmlzTG9ja2VkKSB7XG4gICAgICAgIG4ucG9zaXRpb25YICs9IHggLSBjLngxO1xuICAgICAgICBuLnBvc2l0aW9uWSArPSB5IC0gYy55MTtcbiAgICAgIH1cbiAgICB9XG4gICAgeCArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgIHJvd0ggPSBNYXRoLm1heChyb3dILCBjLmgpO1xuICAgIGlmICh1c2VkVyA+IG1heFJvd1cpIHtcbiAgICAgIHkgKz0gcm93SCArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgIHggPSAwO1xuICAgICAgdXNlZFcgPSAwO1xuICAgICAgcm93SCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGVmYXVsdHMkMyA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIHVzZWQgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgYXZvaWRPdmVybGFwUGFkZGluZzogMTAsXG4gIC8vIGV4dHJhIHNwYWNpbmcgYXJvdW5kIG5vZGVzIHdoZW4gYXZvaWRPdmVybGFwOiB0cnVlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgY29uZGVuc2U6IGZhbHNlLFxuICAvLyB1c2VzIGFsbCBhdmFpbGFibGUgc3BhY2Ugb24gZmFsc2UsIHVzZXMgbWluaW1hbCBzcGFjZSBvbiB0cnVlXG4gIHJvd3M6IHVuZGVmaW5lZCxcbiAgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgY29sczogdW5kZWZpbmVkLFxuICAvLyBmb3JjZSBudW0gb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24obm9kZSkge30sXG4gIC8vIHJldHVybnMgeyByb3csIGNvbCB9IGZvciBlbGVtZW50XG4gIHNvcnQ6IHVuZGVmaW5lZCxcbiAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxufTtcbmZ1bmN0aW9uIEdyaWRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDMsIG9wdGlvbnMpO1xufVxuR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIGlmIChiYi5oID09PSAwIHx8IGJiLncgPT09IDApIHtcbiAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxLFxuICAgICAgICB5OiBiYi55MVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3aWR0aC9oZWlnaHQgKiBzcGxpdHNeMiA9IGNlbGxzIHdoZXJlIHNwbGl0cyBpcyBudW1iZXIgb2YgdGltZXMgdG8gc3BsaXQgd2lkdGhcbiAgICB2YXIgY2VsbHMgPSBub2Rlcy5zaXplKCk7XG4gICAgdmFyIHNwbGl0cyA9IE1hdGguc3FydChjZWxscyAqIGJiLmggLyBiYi53KTtcbiAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoc3BsaXRzKTtcbiAgICB2YXIgY29scyA9IE1hdGgucm91bmQoYmIudyAvIGJiLmggKiBzcGxpdHMpO1xuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uIHNtYWxsKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgaWYgKG1pbiA9PSByb3dzKSB7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbGFyZ2UgPSBmdW5jdGlvbiBsYXJnZSh2YWwpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgIGlmIChtYXggPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9Sb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgIHZhciBvQ29scyA9IG9wdGlvbnMuY29scyAhPSBudWxsID8gb3B0aW9ucy5jb2xzIDogb3B0aW9ucy5jb2x1bW5zO1xuXG4gICAgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcbiAgICBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgfSBlbHNlIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzID09IG51bGwpIHtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBNYXRoLmNlaWwoY2VsbHMgLyByb3dzKTtcbiAgICB9IGVsc2UgaWYgKG9Sb3dzID09IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgY29scyA9IG9Db2xzO1xuICAgICAgcm93cyA9IE1hdGguY2VpbChjZWxscyAvIGNvbHMpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuXG4gICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICBlbHNlIGlmIChjb2xzICogcm93cyA+IGNlbGxzKSB7XG4gICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcblxuICAgICAgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG4gICAgICBpZiAoKHNtIC0gMSkgKiBsZyA+PSBjZWxscykge1xuICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgfSBlbHNlIGlmICgobGcgLSAxKSAqIHNtID49IGNlbGxzKSB7XG4gICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB0b28gbG93LCBhZGQgcm93cyBvciBjb2x1bW5zXG4gICAgICB3aGlsZSAoY29scyAqIHJvd3MgPCBjZWxscykge1xuICAgICAgICB2YXIgX3NtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIF9sZyA9IGxhcmdlKCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGFkZCB0byBsYXJnZXIgc2lkZSBmaXJzdCAoYWRkcyBsZXNzIGluIG11bHRpcGxpY2F0aW9uKVxuICAgICAgICBpZiAoKF9sZyArIDEpICogX3NtID49IGNlbGxzKSB7XG4gICAgICAgICAgbGFyZ2UoX2xnICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hbGwoX3NtICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNlbGxXaWR0aCA9IGJiLncgLyBjb2xzO1xuICAgIHZhciBjZWxsSGVpZ2h0ID0gYmIuaCAvIHJvd3M7XG4gICAgaWYgKG9wdGlvbnMuY29uZGVuc2UpIHtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICBpZiAocG9zLnggPT0gbnVsbCB8fCBwb3MueSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gZm9yIGJiXG4gICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgIHBvcy55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmJiID0gbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heChjZWxsV2lkdGgsIHcpO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbEhlaWdodCwgaCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjZWxsVXNlZCA9IHt9OyAvLyBlLmcuICdjLTAtMicgPT4gdHJ1ZVxuXG4gICAgdmFyIHVzZWQgPSBmdW5jdGlvbiB1c2VkKHJvdywgY29sKSB7XG4gICAgICByZXR1cm4gY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPyB0cnVlIDogZmFsc2U7XG4gICAgfTtcbiAgICB2YXIgdXNlID0gZnVuY3Rpb24gdXNlKHJvdywgY29sKSB7XG4gICAgICBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA9IHRydWU7XG4gICAgfTtcblxuICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG4gICAgdmFyIHJvdyA9IDA7XG4gICAgdmFyIGNvbCA9IDA7XG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gbW92ZVRvTmV4dENlbGwoKSB7XG4gICAgICBjb2wrKztcbiAgICAgIGlmIChjb2wgPj0gY29scykge1xuICAgICAgICBjb2wgPSAwO1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZ2V0IGEgY2FjaGUgb2YgYWxsIHRoZSBtYW51YWwgcG9zaXRpb25zXG4gICAgdmFyIGlkMm1hblBvcyA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgIHZhciByY1BvcyA9IG9wdGlvbnMucG9zaXRpb24oX25vZGUpO1xuICAgICAgaWYgKHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgdmFyIF9wb3MgPSB7XG4gICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF9wb3MuY29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICBfcG9zLmNvbCA9IDA7XG4gICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgX3Bvcy5jb2wrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX3Bvcy5yb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgIF9wb3Mucm93ID0gMDtcbiAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICBfcG9zLnJvdysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZDJtYW5Qb3NbX25vZGUuaWQoKV0gPSBfcG9zO1xuICAgICAgICB1c2UoX3Bvcy5yb3csIF9wb3MuY29sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhlbGVtZW50LCBpKSB7XG4gICAgICB2YXIgeCwgeTtcbiAgICAgIGlmIChlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuICAgICAgdmFyIHJjUG9zID0gaWQybWFuUG9zW2VsZW1lbnQuaWQoKV07XG4gICAgICBpZiAocmNQb3MpIHtcbiAgICAgICAgeCA9IHJjUG9zLmNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJjUG9zLnJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG5cbiAgICAgICAgd2hpbGUgKHVzZWQocm93LCBjb2wpKSB7XG4gICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgIHVzZShyb3csIGNvbCk7XG4gICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH07XG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG52YXIgZGVmYXVsdHMkMiA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG5mdW5jdGlvbiBOdWxsTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQyLCBvcHRpb25zKTtcbn1cblxuLy8gcnVucyB0aGUgbGF5b3V0XG5OdWxsTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gZWxlbWVudHMgdG8gY29uc2lkZXIgaW4gdGhlIGxheW91dFxuICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIC8vIChkaXNhYmxlIGVzbGludCBmb3IgbmV4dCBsaW5lIGFzIHRoaXMgc2VydmVzIGFzIGV4YW1wbGUgbGF5b3V0IGNvZGUgdG8gZXh0ZXJuYWwgZGV2ZWxvcGVycylcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIG9wdGlvbnMuY3k7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdGFydCcpO1xuXG4gIC8vIHB1dHMgYWxsIG5vZGVzIGF0ICgwLCAwKVxuICAvLyBuLmIuIG1vc3QgbGF5b3V0cyB3b3VsZCB1c2UgbGF5b3V0UG9zaXRpb25zKCksIGluc3RlYWQgb2YgcG9zaXRpb25zKCkgYW5kIG1hbnVhbCBldmVudHNcbiAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gdHJpZ2dlciBsYXlvdXRyZWFkeSB3aGVuIGVhY2ggbm9kZSBoYXMgaGFkIGl0cyBwb3NpdGlvbiBzZXQgYXQgbGVhc3Qgb25jZVxuICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0cmVhZHknKTtcblxuICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbk51bGxMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJDEgPSB7XG4gIHBvc2l0aW9uczogdW5kZWZpbmVkLFxuICAvLyBtYXAgb2YgKG5vZGUgaWQpID0+IChwb3NpdGlvbiBvYmopOyBvciBmdW5jdGlvbihub2RlKXsgcmV0dXJuIHNvbVBvczsgfVxuICB6b29tOiB1bmRlZmluZWQsXG4gIC8vIHRoZSB6b29tIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgcGFuOiB1bmRlZmluZWQsXG4gIC8vIHRoZSBwYW4gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIG9uIGZpdFxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xufTtcbmZ1bmN0aW9uIFByZXNldExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMSwgb3B0aW9ucyk7XG59XG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gZm4kNihvcHRpb25zLnBvc2l0aW9ucyk7XG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvcHlQb3NpdGlvbihub2RlLnBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBpZiAocG9zSXNGbikge1xuICAgICAgcmV0dXJuIG9wdGlvbnMucG9zaXRpb25zKG5vZGUpO1xuICAgIH1cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcbiAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9XG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIGZpdCBwYWRkaW5nXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuZnVuY3Rpb24gUmFuZG9tTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5SYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhub2RlLCBpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGJiLngxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIudyksXG4gICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLmgpXG4gICAgfTtcbiAgfTtcbiAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBsYXlvdXQgPSBbe1xuICBuYW1lOiAnYnJlYWR0aGZpcnN0JyxcbiAgaW1wbDogQnJlYWR0aEZpcnN0TGF5b3V0XG59LCB7XG4gIG5hbWU6ICdjaXJjbGUnLFxuICBpbXBsOiBDaXJjbGVMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2NvbmNlbnRyaWMnLFxuICBpbXBsOiBDb25jZW50cmljTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdjb3NlJyxcbiAgaW1wbDogQ29zZUxheW91dFxufSwge1xuICBuYW1lOiAnZ3JpZCcsXG4gIGltcGw6IEdyaWRMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ251bGwnLFxuICBpbXBsOiBOdWxsTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdwcmVzZXQnLFxuICBpbXBsOiBQcmVzZXRMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ3JhbmRvbScsXG4gIGltcGw6IFJhbmRvbUxheW91dFxufV07XG5cbmZ1bmN0aW9uIE51bGxSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMubm90aWZpY2F0aW9ucyA9IDA7IC8vIGZvciB0ZXN0aW5nXG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciB0aHJvd0ltZ0VyciA9IGZ1bmN0aW9uIHRocm93SW1nRXJyKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0EgaGVhZGxlc3MgaW5zdGFuY2UgY2FuIG5vdCByZW5kZXIgaW1hZ2VzJyk7XG59O1xuTnVsbFJlbmRlcmVyLnByb3RvdHlwZSA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBub29wLFxuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMrKztcbiAgfSxcbiAgaW5pdDogbm9vcCxcbiAgaXNIZWFkbGVzczogZnVuY3Rpb24gaXNIZWFkbGVzcygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgcG5nOiB0aHJvd0ltZ0VycixcbiAganBnOiB0aHJvd0ltZ0VyclxufTtcblxudmFyIEJScCRmID0ge307XG5CUnAkZi5hcnJvd1NoYXBlV2lkdGggPSAwLjM7XG5CUnAkZi5yZWdpc3RlckFycm93U2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyb3dTaGFwZXMgPSB0aGlzLmFycm93U2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG5cbiAgLy8gQ29udHJhY3QgZm9yIGFycm93IHNoYXBlczpcbiAgLy8gMCwgMCBpcyBhcnJvdyB0aXBcbiAgLy8gKDAsIDEpIGlzIGRpcmVjdGlvbiB0b3dhcmRzIG5vZGVcbiAgLy8gKDEsIDApIGlzIHJpZ2h0XG4gIC8vXG4gIC8vIGZ1bmN0aW9uYWwgYXBpOlxuICAvLyBjb2xsaWRlOiBjaGVjayB4LCB5IGluIHNoYXBlXG4gIC8vIHJvdWdoQ29sbGlkZTogY2FsbGVkIGJlZm9yZSBjb2xsaWRlLCBubyBmYWxzZSBuZWdhdGl2ZXNcbiAgLy8gZHJhdzogZHJhd1xuICAvLyBzcGFjaW5nOiBkaXN0KGFycm93VGlwLCBub2RlQm91bmRhcnkpXG4gIC8vIGdhcDogZGlzdChlZGdlVGlwLCBub2RlQm91bmRhcnkpLCBlZGdlVGlwIG1heSAhPSBhcnJvd1RpcFxuXG4gIHZhciBiYkNvbGxpZGUgPSBmdW5jdGlvbiBiYkNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICB2YXIgeDEgPSB0cmFuc2xhdGlvbi54IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB4MiA9IHRyYW5zbGF0aW9uLnggKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIHkxID0gdHJhbnNsYXRpb24ueSAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgeTIgPSB0cmFuc2xhdGlvbi55ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuICAgIHZhciBpbnNpZGUgPSB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICAgIHJldHVybiBpbnNpZGU7XG4gIH07XG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKGFuZ2xlKSAtIHkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIHlSb3RhdGVkID0geCAqIE1hdGguc2luKGFuZ2xlKSArIHkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHhTY2FsZWQgPSB4Um90YXRlZCAqIHNpemU7XG4gICAgdmFyIHlTY2FsZWQgPSB5Um90YXRlZCAqIHNpemU7XG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICB9O1xuICB9O1xuICB2YXIgdHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHB0cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHJldFB0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcbiAgICAgIHJldFB0cy5wdXNoKHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFB0cztcbiAgfTtcbiAgdmFyIHBvaW50c1RvQXJyID0gZnVuY3Rpb24gcG9pbnRzVG9BcnIocHRzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHB0c1tpXTtcbiAgICAgIHJldC5wdXNoKHAueCwgcC55KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24gc3RhbmRhcmRHYXAoZWRnZSkge1xuICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykucGZWYWx1ZSAqIDI7XG4gIH07XG4gIHZhciBkZWZpbmVBcnJvd1NoYXBlID0gZnVuY3Rpb24gZGVmaW5lQXJyb3dTaGFwZShuYW1lLCBkZWZuKSB7XG4gICAgaWYgKHN0cmluZyhkZWZuKSkge1xuICAgICAgZGVmbiA9IGFycm93U2hhcGVzW2RlZm5dO1xuICAgIH1cbiAgICBhcnJvd1NoYXBlc1tuYW1lXSA9IGV4dGVuZCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAuMTUsIC0wLjMsIDAuMTUsIDAuMywgLTAuMTUsIDAuM10sXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZykge1xuICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgICB2YXIgcG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCgncG9seWdvbicpKGNvbnRleHQsIHBvaW50cyk7XG4gICAgICB9LFxuICAgICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIGdhcDogc3RhbmRhcmRHYXBcbiAgICB9LCBkZWZuKTtcbiAgfTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnbm9uZScsIHtcbiAgICBjb2xsaWRlOiBmYWxzaWZ5LFxuICAgIHJvdWdoQ29sbGlkZTogZmFsc2lmeSxcbiAgICBkcmF3OiBub29wJDEsXG4gICAgc3BhY2luZzogemVyb2lmeSxcbiAgICBnYXA6IHplcm9pZnlcbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zXVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnYXJyb3cnLCAndHJpYW5nbGUnKTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtYmFja2N1cnZlJywge1xuICAgIHBvaW50czogYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzLFxuICAgIGNvbnRyb2xQb2ludDogWzAsIC0wLjE1XSxcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgcHRzVHJhbnMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHB0c1RyYW5zLCBjdHJsUHRUcmFucyk7XG4gICAgfSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjg7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtdGVlJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBwb2ludHNUZWU6IFstMC4xNSwgLTAuNCwgLTAuMTUsIC0wLjUsIDAuMTUsIC0wLjUsIDAuMTUsIC0wLjRdLFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIHRlZVB0cyk7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlLXRyaWFuZ2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcbiAgICBwb2ludHNUcjogWzAsIC0wLjE1LCAwLjE1LCAtMC40NSwgLTAuMTUsIC0wLjQ1LCAwLCAtMC4xNV0sXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBjaXJjbGVJbnNpZGUgPSBNYXRoLnBvdyh0LnggLSB4LCAyKSArIE1hdGgucG93KHQueSAtIHksIDIpIDw9IE1hdGgucG93KChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpO1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBjaXJjbGVJbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVHIsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplKTtcbiAgICB9LFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtY3Jvc3MnLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjMsIDAsIDBdLFxuICAgIGJhc2VDcm9zc0xpbmVQdHM6IFstMC4xNSwgLTAuNCxcbiAgICAvLyBmaXJzdCBoYWxmIG9mIHRoZSByZWN0YW5nbGVcbiAgICAtMC4xNSwgLTAuNCwgMC4xNSwgLTAuNCxcbiAgICAvLyBzZWNvbmQgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgMC4xNSwgLTAuNF0sXG4gICAgY3Jvc3NMaW5lUHRzOiBmdW5jdGlvbiBjcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSB7XG4gICAgICAvLyBzaGlmdCBwb2ludHMgc28gdGhhdCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3Jvc3MgcG9pbnRzIG1hdGNoZXMgZWRnZSB3aWR0aFxuICAgICAgdmFyIHAgPSB0aGlzLmJhc2VDcm9zc0xpbmVQdHMuc2xpY2UoKTtcbiAgICAgIHZhciBzaGlmdEZhY3RvciA9IGVkZ2VXaWR0aCAvIHNpemU7XG4gICAgICB2YXIgeTAgPSAzO1xuICAgICAgdmFyIHkxID0gNTtcbiAgICAgIHBbeTBdID0gcFt5MF0gLSBzaGlmdEZhY3RvcjtcbiAgICAgIHBbeTFdID0gcFt5MV0gLSBzaGlmdEZhY3RvcjtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIGNyb3NzTGluZVB0cyk7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndmVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zLCAwLCAtMC4xNV0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC41MjU7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgdmFyIGluc2lkZSA9IE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMik7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgIH0sXG4gICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIDAsIC0wLjE1LCAtMC4xLCAwLjE1LCAtMC4xLCAwLjE1LCAwXSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnc3F1YXJlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAwLjAwLCAwLjE1LCAwLjAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2RpYW1vbmQnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjE1LCAwLCAtMC4zLCAwLjE1LCAtMC4xNSwgMCwgMF0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaGV2cm9uJywge1xuICAgIHBvaW50czogWzAsIDAsIC0wLjE1LCAtMC4xNSwgLTAuMSwgLTAuMiwgMCwgLTAuMSwgMC4xLCAtMC4yLCAwLjE1LCAtMC4xNV0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIDAuOTUgKiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBCUnAkZSA9IHt9O1xuXG4vLyBQcm9qZWN0IG1vdXNlXG5CUnAkZS5wcm9qZWN0SW50b1ZpZXdwb3J0ID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIG9mZnNldHMgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICB2YXIgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgdmFyIHNjYWxlID0gb2Zmc2V0c1s0XTtcbiAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgdmFyIHggPSAoKGNsaWVudFggLSBvZmZzZXRMZWZ0KSAvIHNjYWxlIC0gcGFuLngpIC8gem9vbTtcbiAgdmFyIHkgPSAoKGNsaWVudFkgLSBvZmZzZXRUb3ApIC8gc2NhbGUgLSBwYW4ueSkgLyB6b29tO1xuICByZXR1cm4gW3gsIHldO1xufTtcbkJScCRlLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbnRhaW5lckJCKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkI7XG4gIH1cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHN0eWxlID0gdGhpcy5jeS53aW5kb3coKS5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gIHZhciBzdHlsZVZhbHVlID0gZnVuY3Rpb24gc3R5bGVWYWx1ZShuYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gIH07XG4gIHZhciBwYWRkaW5nID0ge1xuICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctbGVmdCcpLFxuICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgdG9wOiBzdHlsZVZhbHVlKCdwYWRkaW5nLXRvcCcpLFxuICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgncGFkZGluZy1ib3R0b20nKVxuICB9O1xuICB2YXIgYm9yZGVyID0ge1xuICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpLFxuICAgIHRvcDogc3R5bGVWYWx1ZSgnYm9yZGVyLXRvcC13aWR0aCcpLFxuICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgnYm9yZGVyLWJvdHRvbS13aWR0aCcpXG4gIH07XG4gIHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgdmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gIHZhciBwYWRkaW5nSG9yID0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgdmFyIHBhZGRpbmdWZXIgPSBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICB2YXIgYm9yZGVySG9yID0gYm9yZGVyLmxlZnQgKyBib3JkZXIucmlnaHQ7XG4gIHZhciBzY2FsZSA9IHJlY3Qud2lkdGggLyAoY2xpZW50V2lkdGggKyBib3JkZXJIb3IpO1xuICB2YXIgdW5zY2FsZWRXID0gY2xpZW50V2lkdGggLSBwYWRkaW5nSG9yO1xuICB2YXIgdW5zY2FsZWRIID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1ZlcjtcbiAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyBwYWRkaW5nLmxlZnQgKyBib3JkZXIubGVmdDtcbiAgdmFyIHRvcCA9IHJlY3QudG9wICsgcGFkZGluZy50b3AgKyBib3JkZXIudG9wO1xuICByZXR1cm4gdGhpcy5jb250YWluZXJCQiA9IFtsZWZ0LCB0b3AsIHVuc2NhbGVkVywgdW5zY2FsZWRILCBzY2FsZV07XG59O1xuQlJwJGUuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbnRhaW5lckJCID0gbnVsbDtcbn07XG5CUnAkZS5maW5kTmVhcmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgcmV0dXJuIHRoaXMuZmluZE5lYXJlc3RFbGVtZW50cyh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaClbMF07XG59O1xuQlJwJGUuZmluZE5lYXJlc3RFbGVtZW50cyA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIHZhciBuZWFyID0gW107IC8vIDEgbm9kZSBtYXgsIDEgZWRnZSBtYXhcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IHIuY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgZWRnZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMjQgOiA4KSAvIHpvb207XG4gIHZhciBub2RlVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbGFiZWxUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gIHZhciBtaW5TcURpc3QgPSBJbmZpbml0eTtcbiAgdmFyIG5lYXJFZGdlO1xuICB2YXIgbmVhck5vZGU7XG4gIGlmIChpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSkge1xuICAgIGVsZXMgPSBlbGVzLmludGVyYWN0aXZlO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEVsZShlbGUsIHNxRGlzdCkge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGlmIChuZWFyTm9kZSkge1xuICAgICAgICByZXR1cm47IC8vIGNhbid0IHJlcGxhY2Ugbm9kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVhck5vZGUgPSBlbGU7XG4gICAgICAgIG5lYXIucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWxlLmlzRWRnZSgpICYmIChzcURpc3QgPT0gbnVsbCB8fCBzcURpc3QgPCBtaW5TcURpc3QpKSB7XG4gICAgICBpZiAobmVhckVkZ2UpIHtcbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGV4aXN0aW5nIGVkZ2VcbiAgICAgICAgLy8gY2FuIHJlcGxhY2Ugb25seSBpZiBzYW1lIHotaW5kZXhcbiAgICAgICAgaWYgKG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgJiYgbmVhckVkZ2UucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVhci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5lYXJbaV0uaXNFZGdlKCkpIHtcbiAgICAgICAgICAgICAgbmVhcltpXSA9IGVsZTtcbiAgICAgICAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lYXIucHVzaChlbGUpO1xuICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKSB7XG4gICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgaWYgKHBvcy54IC0gaHcgPD0geCAmJiB4IDw9IHBvcy54ICsgaHcgLy8gYmIgY2hlY2sgeFxuICAgICYmIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICkge1xuICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzW3NlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpXTtcbiAgICAgIGlmIChzaGFwZS5jaGVja1BvaW50KHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSwgY29ybmVyUmFkaXVzLCBycykpIHtcbiAgICAgICAgYWRkRWxlKG5vZGUsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tFZGdlKGVkZ2UpIHtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBzdHlsZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB2YXIgd2lkdGggPSBzdHlsZVdpZHRoIC8gMiArIGVkZ2VUaHJlc2hvbGQ7IC8vIG1vcmUgbGlrZSBhIGRpc3RhbmNlIHJhZGl1cyBmcm9tIGNlbnRyZVxuICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICB2YXIgd2lkdGgyID0gd2lkdGggKiAyO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3FEaXN0O1xuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoaW5MaW5lVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCB3aWR0aDIpICYmIHdpZHRoU3EgPiAoc3FEaXN0ID0gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSkpKSB7XG4gICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGlmIChpbkJlemllclZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSkpKSB7XG4gICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcblxuICAgIHZhciBzcmMgPSBzcmMgfHwgX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSB0Z3QgfHwgX3AudGFyZ2V0O1xuICAgIHZhciBhclNpemUgPSBzZWxmLmdldEFycm93V2lkdGgoc3R5bGVXaWR0aCwgc2NhbGUpO1xuICAgIHZhciBhcnJvd3MgPSBbe1xuICAgICAgbmFtZTogJ3NvdXJjZScsXG4gICAgICB4OiBycy5hcnJvd1N0YXJ0WCxcbiAgICAgIHk6IHJzLmFycm93U3RhcnRZLFxuICAgICAgYW5nbGU6IHJzLnNyY0Fycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0JyxcbiAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgIHk6IHJzLmFycm93RW5kWSxcbiAgICAgIGFuZ2xlOiBycy50Z3RBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pZC1zb3VyY2UnLFxuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFksXG4gICAgICBhbmdsZTogcnMubWlkc3JjQXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaWQtdGFyZ2V0JyxcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZLFxuICAgICAgYW5nbGU6IHJzLm1pZHRndEFycm93QW5nbGVcbiAgICB9XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyID0gYXJyb3dzW2ldO1xuICAgICAgdmFyIHNoYXBlID0gci5hcnJvd1NoYXBlc1tlZGdlLnBzdHlsZShhci5uYW1lICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlXTtcbiAgICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgaWYgKHNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgIHg6IGFyLngsXG4gICAgICAgIHk6IGFyLnlcbiAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkgJiYgc2hhcGUuY29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgIHg6IGFyLngsXG4gICAgICAgIHk6IGFyLnlcbiAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkpIHtcbiAgICAgICAgYWRkRWxlKGVkZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcbiAgICBpZiAoaGFzQ29tcG91bmRzICYmIG5lYXIubGVuZ3RoID4gMCkge1xuICAgICAgY2hlY2tOb2RlKHNyYyk7XG4gICAgICBjaGVja05vZGUodGd0KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJlcHJvcChvYmosIG5hbWUsIHByZSkge1xuICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgbmFtZSwgcHJlKTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja0xhYmVsKGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciB0aCA9IGxhYmVsVGhyZXNob2xkO1xuICAgIHZhciBwcmVmaXhEYXNoO1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICB9XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIGJiID0gX3AubGFiZWxCb3VuZHNbcHJlZml4IHx8ICdtYWluJ107XG4gICAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAnbGFiZWwnKS52YWx1ZTtcbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IGVsZS5wc3R5bGUoJ3RleHQtZXZlbnRzJykuc3RyVmFsdWUgPT09ICd5ZXMnO1xuICAgIGlmICghZXZlbnRzRW5hYmxlZCB8fCAhdGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbHggPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgbHkgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICB2YXIgdGhldGEgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG4gICAgdmFyIG94ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBveSA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgbHgxID0gYmIueDEgLSB0aCAtIG94OyAvLyAoLW94LCAtb3kpIGFzIGJiIGFscmVhZHkgaW5jbHVkZXMgbWFyZ2luXG4gICAgdmFyIGx4MiA9IGJiLngyICsgdGggLSBveDsgLy8gYW5kIHJvdGF0aW9uIGlzIGFib3V0IChseCwgbHkpXG4gICAgdmFyIGx5MSA9IGJiLnkxIC0gdGggLSBveTtcbiAgICB2YXIgbHkyID0gYmIueTIgKyB0aCAtIG95O1xuICAgIGlmICh0aGV0YSkge1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgeSA9IHkgLSBseTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGx4LFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgbHlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgIC8vIHdpdGggdGhlIG1hcmdpbiBhZGRlZCBhZnRlciB0aGUgcm90YXRpb24gaXMgYXBwbGllZFxuICAgICAgcHgxeTEueCArIG94LCBweDF5MS55ICsgb3ksIHB4MnkxLnggKyBveCwgcHgyeTEueSArIG95LCBweDJ5Mi54ICsgb3gsIHB4MnkyLnkgKyBveSwgcHgxeTIueCArIG94LCBweDF5Mi55ICsgb3ldO1xuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8gYSBjaGVhcGVyIGJiIGNoZWNrXG4gICAgICBpZiAoaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkpIHtcbiAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBjaGVja05vZGUoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4gZWRnZVxuICAgICAgY2hlY2tFZGdlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpIHx8IGNoZWNrTGFiZWwoZWxlLCAnc291cmNlJykgfHwgY2hlY2tMYWJlbChlbGUsICd0YXJnZXQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lYXI7XG59O1xuXG4vLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG5CUnAkZS5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5pbnRlcmFjdGl2ZTtcbiAgdmFyIHpvb20gPSB0aGlzLmN5Lnpvb20oKTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gMiAvIHpvb207XG4gIHZhciBib3ggPSBbXTtcbiAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7XG4gIHgxID0geDFjO1xuICB4MiA9IHgyYztcbiAgeTEgPSB5MWM7XG4gIHkyID0geTJjO1xuICB2YXIgYm94QmIgPSBtYWtlQm91bmRpbmdCb3goe1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IHgyLFxuICAgIHkyOiB5MlxuICB9KTtcbiAgdmFyIHNlbGVjdGlvbkJveCA9IFt7XG4gICAgeDogYm94QmIueDEsXG4gICAgeTogYm94QmIueTFcbiAgfSwge1xuICAgIHg6IGJveEJiLngyLFxuICAgIHk6IGJveEJiLnkxXG4gIH0sIHtcbiAgICB4OiBib3hCYi54MixcbiAgICB5OiBib3hCYi55MlxuICB9LCB7XG4gICAgeDogYm94QmIueDEsXG4gICAgeTogYm94QmIueTJcbiAgfV07XG4gIHZhciBib3hFZGdlcyA9IFtbc2VsZWN0aW9uQm94WzBdLCBzZWxlY3Rpb25Cb3hbMV1dLCBbc2VsZWN0aW9uQm94WzFdLCBzZWxlY3Rpb25Cb3hbMl1dLCBbc2VsZWN0aW9uQm94WzJdLCBzZWxlY3Rpb25Cb3hbM11dLCBbc2VsZWN0aW9uQm94WzNdLCBzZWxlY3Rpb25Cb3hbMF1dXTtcbiAgZnVuY3Rpb24gcHJlcHJvcChvYmosIG5hbWUsIHByZSkge1xuICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgbmFtZSwgcHJlKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSb3RhdGVkTGFiZWxCb3goZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHRoID0gbGFiZWxUaHJlc2hvbGQ7XG4gICAgdmFyIHByZWZpeERhc2ggPSAnJztcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgYmIgPSBfcC5sYWJlbEJvdW5kc1snbWFpbiddO1xuXG4gICAgLy8gSWYgdGhlIGJvdW5kaW5nIGJveCBpcyBub3QgYXZhaWxhYmxlLCByZXR1cm4gbnVsbC5cbiAgICAvLyBUaGlzIGluZGljYXRlcyB0aGF0IHRoZSBsYWJlbCBib3ggY2Fubm90IGJlIGNhbGN1bGF0ZWQsIHdoaWNoIGlzIGNvbnNpc3RlbnRcbiAgICAvLyB3aXRoIHRoZSBleHBlY3RlZCBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uLiBSZXR1cm5pbmcgbnVsbCBhbGxvd3MgdGhlIGNhbGxlclxuICAgIC8vIHRvIGhhbmRsZSB0aGUgYWJzZW5jZSBvZiBhIGJvdW5kaW5nIGJveCBleHBsaWNpdGx5LlxuICAgIGlmICghYmIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbHggPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgbHkgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICB2YXIgdGhldGEgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG4gICAgdmFyIG94ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBveSA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgbHgxID0gYmIueDEgLSB0aCAtIG94O1xuICAgIHZhciBseDIgPSBiYi54MiArIHRoIC0gb3g7XG4gICAgdmFyIGx5MSA9IGJiLnkxIC0gdGggLSBveTtcbiAgICB2YXIgbHkyID0gYmIueTIgKyB0aCAtIG95O1xuICAgIGlmICh0aGV0YSkge1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgeSA9IHkgLSBseTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGx4LFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgbHlcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gW3JvdGF0ZShseDEsIGx5MSksIHJvdGF0ZShseDIsIGx5MSksIHJvdGF0ZShseDIsIGx5MiksIHJvdGF0ZShseDEsIGx5MildO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgeDogbHgxLFxuICAgICAgICB5OiBseTFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogbHgyLFxuICAgICAgICB5OiBseTFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogbHgyLFxuICAgICAgICB5OiBseTJcbiAgICAgIH0sIHtcbiAgICAgICAgeDogbHgxLFxuICAgICAgICB5OiBseTJcbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkb0xpbmVzSW50ZXJzZWN0KHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgZnVuY3Rpb24gY2N3KGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiAoYy55IC0gYS55KSAqIChiLnggLSBhLngpID4gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KTtcbiAgICB9XG4gICAgcmV0dXJuIGNjdyhwMSwgcTEsIHEyKSAhPT0gY2N3KHAyLCBxMSwgcTIpICYmIGNjdyhwMSwgcDIsIHExKSAhPT0gY2N3KHAxLCBwMiwgcTIpO1xuICB9XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgdmFyIHRleHRFdmVudHMgPSBub2RlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG4gICAgICB2YXIgbm9kZUJveFNlbGVjdE1vZGUgPSBub2RlLnBzdHlsZSgnYm94LXNlbGVjdGlvbicpLnN0clZhbHVlO1xuICAgICAgdmFyIGxhYmVsQm94U2VsZWN0RW5hYmxlZCA9IG5vZGUucHN0eWxlKCdib3gtc2VsZWN0LWxhYmVscycpLnN0clZhbHVlID09PSAneWVzJztcbiAgICAgIGlmIChub2RlQm94U2VsZWN0TW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSAobm9kZUJveFNlbGVjdE1vZGUgPT09ICdvdmVybGFwJyB8fCBsYWJlbEJveFNlbGVjdEVuYWJsZWQpICYmIHRleHRFdmVudHM7XG4gICAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZUxhYmVsczogaW5jbHVkZUxhYmVsc1xuICAgICAgfSk7XG4gICAgICBpZiAobm9kZUJveFNlbGVjdE1vZGUgPT09ICdjb250YWluJykge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxhYmVsQm94U2VsZWN0RW5hYmxlZCAmJiB0ZXh0RXZlbnRzKSB7XG4gICAgICAgICAgdmFyIHJvdGF0ZWRMYWJlbEJveCA9IGdldFJvdGF0ZWRMYWJlbEJveChub2RlKTtcbiAgICAgICAgICBpZiAocm90YXRlZExhYmVsQm94ICYmIHNhdFBvbHlnb25JbnRlcnNlY3Rpb24ocm90YXRlZExhYmVsQm94LCBzZWxlY3Rpb25Cb3gpKSB7XG4gICAgICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxlY3RlZCAmJiBib3VuZGluZ0JveEluQm91bmRpbmdCb3goYm94QmIsIG5vZGVCYikpIHtcbiAgICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlQm94U2VsZWN0TW9kZSA9PT0gJ292ZXJsYXAnKSB7XG4gICAgICAgIGlmIChib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJveEJiLCBub2RlQmIpKSB7XG4gICAgICAgICAgdmFyIG5vZGVCb2R5QmIgPSBub2RlLmJvdW5kaW5nQm94KHtcbiAgICAgICAgICAgIGluY2x1ZGVOb2RlczogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgaW5jbHVkZU1haW5MYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgaW5jbHVkZVNvdXJjZUxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBpbmNsdWRlVGFyZ2V0TGFiZWxzOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBub2RlQm9keUNvcm5lcnMgPSBbe1xuICAgICAgICAgICAgeDogbm9kZUJvZHlCYi54MSxcbiAgICAgICAgICAgIHk6IG5vZGVCb2R5QmIueTFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBub2RlQm9keUJiLngyLFxuICAgICAgICAgICAgeTogbm9kZUJvZHlCYi55MVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IG5vZGVCb2R5QmIueDIsXG4gICAgICAgICAgICB5OiBub2RlQm9keUJiLnkyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogbm9kZUJvZHlCYi54MSxcbiAgICAgICAgICAgIHk6IG5vZGVCb2R5QmIueTJcbiAgICAgICAgICB9XTtcblxuICAgICAgICAgIC8vIGlmIG5vZGUgYm9keSBpbnRlcnNlY3RzLCBubyBuZWVkIHRvIGNoZWNrIGxhYmVsXG4gICAgICAgICAgaWYgKHNhdFBvbHlnb25JbnRlcnNlY3Rpb24obm9kZUJvZHlDb3JuZXJzLCBzZWxlY3Rpb25Cb3gpKSB7XG4gICAgICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb25seSBjaGVjayBsYWJlbCBpZiBub2RlIGJvZHkgZGlkbid0IGludGVyc2VjdFxuICAgICAgICAgICAgdmFyIF9yb3RhdGVkTGFiZWxCb3ggPSBnZXRSb3RhdGVkTGFiZWxCb3gobm9kZSk7XG4gICAgICAgICAgICBpZiAoX3JvdGF0ZWRMYWJlbEJveCAmJiBzYXRQb2x5Z29uSW50ZXJzZWN0aW9uKF9yb3RhdGVkTGFiZWxCb3gsIHNlbGVjdGlvbkJveCkpIHtcbiAgICAgICAgICAgICAgYm94LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlZGdlID0gZWxlO1xuICAgICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgICAgdmFyIGVkZ2VCb3hTZWxlY3RNb2RlID0gZWRnZS5wc3R5bGUoJ2JveC1zZWxlY3Rpb24nKS5zdHJWYWx1ZTtcbiAgICAgIGlmIChlZGdlQm94U2VsZWN0TW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVkZ2VCb3hTZWxlY3RNb2RlID09PSAnY29udGFpbicpIHtcbiAgICAgICAgaWYgKHJzLnN0YXJ0WCAhPSBudWxsICYmIHJzLnN0YXJ0WSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5zdGFydFgsIHJzLnN0YXJ0WSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgICAgdmFyIGFsbEluc2lkZSA9IHRydWU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghcG9pbnRJbkJvdW5kaW5nQm94KGJveEJiLCBwdHNbaV0pKSB7XG4gICAgICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFsbEluc2lkZSkge1xuICAgICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWRnZUJveFNlbGVjdE1vZGUgPT09ICdvdmVybGFwJykge1xuICAgICAgICB2YXIgX3NlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2hlY2s6IGVpdGhlciBlbmRwb2ludCBpbnNpZGUgYm94XG4gICAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiBycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmIChpbkJvdW5kaW5nQm94KGJveEJiLCBycy5zdGFydFgsIHJzLnN0YXJ0WSkgfHwgaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSkpKSB7XG4gICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgICAgX3NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhheXN0YWNrIGZhbGxiYWNrIChvbmx5IGNoZWNrIGlmIG5vdCBhbHJlYWR5IHNlbGVjdGVkKVxuICAgICAgICBlbHNlIGlmICghX3NlbGVjdGVkICYmIHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIGhheXN0YWNrUHRzID0gX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBoYXlzdGFja1B0cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmIChwb2ludEluQm91bmRpbmdCb3goYm94QmIsIGhheXN0YWNrUHRzW19pXSkpIHtcbiAgICAgICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgIF9zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlZ21lbnQgaW50ZXJzZWN0aW9uIGNoZWNrIChvbmx5IGlmIG5vdCBhbHJlYWR5IHNlbGVjdGVkKVxuICAgICAgICBpZiAoIV9zZWxlY3RlZCkge1xuICAgICAgICAgIHZhciBfcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgICAvLyBzdHJhaWdodCBlZGdlc1xuICAgICAgICAgIGlmICgoIV9wdHMgfHwgX3B0cy5sZW5ndGggPCAyKSAmJiBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICAgICAgaWYgKHJzLnN0YXJ0WCAhPSBudWxsICYmIHJzLnN0YXJ0WSAhPSBudWxsICYmIHJzLmVuZFggIT0gbnVsbCAmJiBycy5lbmRZICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX3B0cyA9IFt7XG4gICAgICAgICAgICAgICAgeDogcnMuc3RhcnRYLFxuICAgICAgICAgICAgICAgIHk6IHJzLnN0YXJ0WVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogcnMuZW5kWCxcbiAgICAgICAgICAgICAgICB5OiBycy5lbmRZXG4gICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9wdHMgfHwgX3B0cy5sZW5ndGggPCAyKSBjb250aW51ZTtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfcHRzLmxlbmd0aCAtIDE7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgc2VnU3RhcnQgPSBfcHRzW19pMl07XG4gICAgICAgICAgICB2YXIgc2VnRW5kID0gX3B0c1tfaTIgKyAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYm94RWRnZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9ib3hFZGdlcyRiID0gX3NsaWNlZFRvQXJyYXkoYm94RWRnZXNbYl0sIDIpLFxuICAgICAgICAgICAgICAgIGJveFN0YXJ0ID0gX2JveEVkZ2VzJGJbMF0sXG4gICAgICAgICAgICAgICAgYm94RW5kID0gX2JveEVkZ2VzJGJbMV07XG4gICAgICAgICAgICAgIGlmIChkb0xpbmVzSW50ZXJzZWN0KHNlZ1N0YXJ0LCBzZWdFbmQsIGJveFN0YXJ0LCBib3hFbmQpKSB7XG4gICAgICAgICAgICAgICAgYm94LnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgICAgX3NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9zZWxlY3RlZCkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBib3g7XG59O1xuXG52YXIgQlJwJGQgPSB7fTtcbkJScCRkLmNhbGN1bGF0ZUFycm93QW5nbGVzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcbiAgdmFyIGlzQmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdiZXppZXInO1xuICB2YXIgaXNNdWx0aWJlemllciA9IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInO1xuICB2YXIgaXNTZWdtZW50cyA9IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnO1xuICB2YXIgaXNDb21wb3VuZCA9IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnO1xuICB2YXIgaXNTZWxmID0gcnMuZWRnZVR5cGUgPT09ICdzZWxmJztcblxuICAvLyBEaXNwbGFjZW1lbnQgZ2l2ZXMgZGlyZWN0aW9uIGZvciBhcnJvd2hlYWQgb3JpZW50YXRpb25cbiAgdmFyIGRpc3BYLCBkaXNwWTtcbiAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBtaWRYLCBtaWRZO1xuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICB9XG4gIG1pZFggPSBycy5taWRYO1xuICBtaWRZID0gcnMubWlkWTtcblxuICAvLyBzb3VyY2VcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gcnMuc2VncHRzWzFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjEpO1xuICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEpO1xuICAgIGRpc3BYID0gc3RhcnRYIC0gYlg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIG1pZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBtaWRZO1xuICB9XG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG5cbiAgLy8gbWlkIHRhcmdldFxuICAvL1xuXG4gIHZhciBtaWRYID0gcnMubWlkWDtcbiAgdmFyIG1pZFkgPSBycy5taWRZO1xuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyO1xuICAgIG1pZFkgPSAoc3RhcnRZICsgZW5kWSkgLyAyO1xuICB9XG4gIGRpc3BYID0gZW5kWCAtIHN0YXJ0WDtcbiAgZGlzcFkgPSBlbmRZIC0gc3RhcnRZO1xuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH0gZWxzZSBpZiAocnMuaXNSb3VuZCkge1xuICAgICAgZGlzcFggPSBycy5taWRWZWN0b3JbMV07XG4gICAgICBkaXNwWSA9IC1ycy5taWRWZWN0b3JbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBjcHRzID0gcnMuY3RybHB0cztcbiAgICB2YXIgYnAweCwgYnAweTtcbiAgICB2YXIgYnAxeCwgYnAxeTtcbiAgICBpZiAoY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG4gICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICB2YXIgcDEgPSBpYyArIDI7XG4gICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMCk7XG4gICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMCk7XG4gICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMDAwMSk7XG4gICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMDAwMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpYyA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gY3RycHRcbiAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNDk5OSk7XG4gICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNDk5OSk7XG4gICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNSk7XG4gICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNSk7XG4gICAgfVxuICAgIGRpc3BYID0gYnAxeCAtIGJwMHg7XG4gICAgZGlzcFkgPSBicDF5IC0gYnAweTtcbiAgfVxuICBycy5taWR0Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZO1xuXG4gIC8vIG1pZCBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCAqPSAtMTtcbiAgZGlzcFkgKj0gLTE7XG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSA7IGVsc2UgaWYgKCFycy5pc1JvdW5kKSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICBkaXNwWCA9IC0ocHRzW2kzXSAtIHB0c1tpMl0pO1xuICAgICAgZGlzcFkgPSAtKHB0c1tpMyArIDFdIC0gcHRzW2kyICsgMV0pO1xuICAgIH1cbiAgfVxuICBycy5taWRzcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuXG4gIC8vIHRhcmdldFxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBlbmRYIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAyXTtcbiAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDFdO1xuICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIHZhciBsID0gcHRzLmxlbmd0aDtcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzW2wgLSA2XSwgcHRzW2wgLSA0XSwgcHRzW2wgLSAyXSwgMC45KTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzW2wgLSA1XSwgcHRzW2wgLSAzXSwgcHRzW2wgLSAxXSwgMC45KTtcbiAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgfSBlbHNlIHtcbiAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gIH1cbiAgcnMudGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbn07XG5CUnAkZC5nZXRBcnJvd1dpZHRoID0gQlJwJGQuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbiAoZWRnZVdpZHRoLCBzY2FsZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZWRnZVdpZHRoICsgJywgJyArIHNjYWxlXTtcbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cbiAgY2FjaGVkVmFsID0gTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KSAqIHNjYWxlO1xuICBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdID0gY2FjaGVkVmFsO1xuICByZXR1cm4gY2FjaGVkVmFsO1xufTtcblxuLyoqXG4gKiBFeHBsYWluZWQgYnkgQmxpbmRtYW42NyBhdCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDQ4NTY5MjUvMTEwMjg4MjhcbiAqL1xuXG4vLyBEZWNsYXJlIHJldXNlZCB2YXJpYWJsZSB0byBhdm9pZCByZWFsbG9jYXRpbmcgdmFyaWFibGVzIGV2ZXJ5IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZFxudmFyIHgsXG4gIHksXG4gIHYxID0ge30sXG4gIHYyID0ge30sXG4gIHNpbkEsXG4gIHNpbkE5MCxcbiAgcmFkRGlyZWN0aW9uLFxuICBkcmF3RGlyZWN0aW9uLFxuICBhbmdsZSxcbiAgaGFsZkFuZ2xlLFxuICBjUmFkaXVzLFxuICBsZW5PdXQsXG4gIHJhZGl1cyxcbiAgbGltaXQ7XG52YXIgc3RhcnRYLCBzdGFydFksIHN0b3BYLCBzdG9wWTtcbnZhciBsYXN0UG9pbnQ7XG5cbi8vIGNvbnZlcnQgMiBwb2ludHMgaW50byB2ZWN0b3IgZm9ybSwgcG9sYXIgZm9ybSwgYW5kIG5vcm1hbGlzZWRcbnZhciBhc1ZlYyA9IGZ1bmN0aW9uIGFzVmVjKHAsIHBwLCB2KSB7XG4gIHYueCA9IHBwLnggLSBwLng7XG4gIHYueSA9IHBwLnkgLSBwLnk7XG4gIHYubGVuID0gTWF0aC5zcXJ0KHYueCAqIHYueCArIHYueSAqIHYueSk7XG4gIHYubnggPSB2LnggLyB2LmxlbjtcbiAgdi5ueSA9IHYueSAvIHYubGVuO1xuICB2LmFuZyA9IE1hdGguYXRhbjIodi5ueSwgdi5ueCk7XG59O1xudmFyIGludmVydFZlYyA9IGZ1bmN0aW9uIGludmVydFZlYyhvcmlnaW5hbFYsIGludmVydGVkVikge1xuICBpbnZlcnRlZFYueCA9IG9yaWdpbmFsVi54ICogLTE7XG4gIGludmVydGVkVi55ID0gb3JpZ2luYWxWLnkgKiAtMTtcbiAgaW52ZXJ0ZWRWLm54ID0gb3JpZ2luYWxWLm54ICogLTE7XG4gIGludmVydGVkVi5ueSA9IG9yaWdpbmFsVi5ueSAqIC0xO1xuICBpbnZlcnRlZFYuYW5nID0gb3JpZ2luYWxWLmFuZyA+IDAgPyAtKE1hdGguUEkgLSBvcmlnaW5hbFYuYW5nKSA6IE1hdGguUEkgKyBvcmlnaW5hbFYuYW5nO1xufTtcbnZhciBjYWxjQ29ybmVyQXJjID0gZnVuY3Rpb24gY2FsY0Nvcm5lckFyYyhwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgcmFkaXVzTWF4LCBpc0FyY1JhZGl1cykge1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBhcnQgMVxuICBwcmV2aW91c1BvaW50ICE9PSBsYXN0UG9pbnQgPyBhc1ZlYyhjdXJyZW50UG9pbnQsIHByZXZpb3VzUG9pbnQsIHYxKSA6IGludmVydFZlYyh2MiwgdjEpOyAvLyBBdm9pZCByZWNhbGN1bGF0aW5nIHZlYyBpZiBpdCBpcyB0aGUgaW52ZXJ0IG9mIHRoZSBsYXN0IG9uZSBjYWxjdWxhdGVkXG4gIGFzVmVjKGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCB2Mik7XG4gIHNpbkEgPSB2MS5ueCAqIHYyLm55IC0gdjEubnkgKiB2Mi5ueDtcbiAgc2luQTkwID0gdjEubnggKiB2Mi5ueCAtIHYxLm55ICogLXYyLm55O1xuICBhbmdsZSA9IE1hdGguYXNpbihNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgc2luQSkpKTtcbiAgaWYgKE1hdGguYWJzKGFuZ2xlKSA8IDFlLTYpIHtcbiAgICB4ID0gY3VycmVudFBvaW50Lng7XG4gICAgeSA9IGN1cnJlbnRQb2ludC55O1xuICAgIGNSYWRpdXMgPSByYWRpdXMgPSAwO1xuICAgIHJldHVybjtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHJhZERpcmVjdGlvbiA9IDE7XG4gIGRyYXdEaXJlY3Rpb24gPSBmYWxzZTtcbiAgaWYgKHNpbkE5MCA8IDApIHtcbiAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICBhbmdsZSA9IE1hdGguUEkgKyBhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSBNYXRoLlBJIC0gYW5nbGU7XG4gICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByYWREaXJlY3Rpb24gPSAtMTtcbiAgICAgIGRyYXdEaXJlY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudFBvaW50LnJhZGl1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmFkaXVzID0gY3VycmVudFBvaW50LnJhZGl1cztcbiAgfSBlbHNlIHtcbiAgICByYWRpdXMgPSByYWRpdXNNYXg7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQYXJ0IDJcbiAgaGFsZkFuZ2xlID0gYW5nbGUgLyAyO1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgbGltaXQgPSBNYXRoLm1pbih2MS5sZW4gLyAyLCB2Mi5sZW4gLyAyKTtcbiAgaWYgKGlzQXJjUmFkaXVzKSB7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBhcnQgM1xuICAgIGxlbk91dCA9IE1hdGguYWJzKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXMgLyBNYXRoLnNpbihoYWxmQW5nbGUpKTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTcGVjaWFsIHBhcnQgQVxuICAgIGlmIChsZW5PdXQgPiBsaW1pdCkge1xuICAgICAgbGVuT3V0ID0gbGltaXQ7XG4gICAgICBjUmFkaXVzID0gTWF0aC5hYnMobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSAvIE1hdGguY29zKGhhbGZBbmdsZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjUmFkaXVzID0gcmFkaXVzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5PdXQgPSBNYXRoLm1pbihsaW1pdCwgcmFkaXVzKTtcbiAgICBjUmFkaXVzID0gTWF0aC5hYnMobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSAvIE1hdGguY29zKGhhbGZBbmdsZSkpO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBhcnQgNFxuICBzdG9wWCA9IGN1cnJlbnRQb2ludC54ICsgdjIubnggKiBsZW5PdXQ7XG4gIHN0b3BZID0gY3VycmVudFBvaW50LnkgKyB2Mi5ueSAqIGxlbk91dDtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQYXJ0IDVcbiAgeCA9IHN0b3BYIC0gdjIubnkgKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICB5ID0gc3RvcFkgKyB2Mi5ueCAqIGNSYWRpdXMgKiByYWREaXJlY3Rpb247XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQWRkaXRpb25hbCBQYXJ0IDogY2FsY3VsYXRlIHN0YXJ0IHBvaW50IEVcbiAgc3RhcnRYID0gY3VycmVudFBvaW50LnggKyB2MS5ueCAqIGxlbk91dDtcbiAgc3RhcnRZID0gY3VycmVudFBvaW50LnkgKyB2MS5ueSAqIGxlbk91dDtcblxuICAvLyBTYXZlIGxhc3QgcG9pbnQgdG8gYXZvaWQgcmVjYWxjdWxhdGluZyB2ZWN0b3Igd2hlbiBub3QgbmVlZGVkXG4gIGxhc3RQb2ludCA9IGN1cnJlbnRQb2ludDtcbn07XG5cbi8qKlxuICogRHJhdyBjb3JuZXIgcHJvdmlkZWQgYnkge0BsaW5rIGdldFJvdW5kQ29ybmVyfVxuICpcbiAqIEBwYXJhbSBjdHggOkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICogQHBhcmFtIHJvdW5kQ29ybmVyIHt7Y3g6bnVtYmVyLCBjeTpudW1iZXIsIHJhZGl1czpudW1iZXIsIGVuZEFuZ2xlOiBudW1iZXIsIHN0YXJ0QW5nbGU6IG51bWJlciwgY291bnRlckNsb2Nrd2lzZTogYm9vbGVhbn19XG4gKi9cbmZ1bmN0aW9uIGRyYXdQcmVwYXJlZFJvdW5kQ29ybmVyKGN0eCwgcm91bmRDb3JuZXIpIHtcbiAgaWYgKHJvdW5kQ29ybmVyLnJhZGl1cyA9PT0gMCkgY3R4LmxpbmVUbyhyb3VuZENvcm5lci5jeCwgcm91bmRDb3JuZXIuY3kpO2Vsc2UgY3R4LmFyYyhyb3VuZENvcm5lci5jeCwgcm91bmRDb3JuZXIuY3ksIHJvdW5kQ29ybmVyLnJhZGl1cywgcm91bmRDb3JuZXIuc3RhcnRBbmdsZSwgcm91bmRDb3JuZXIuZW5kQW5nbGUsIHJvdW5kQ29ybmVyLmNvdW50ZXJDbG9ja3dpc2UpO1xufVxuXG4vKipcbiAqIEdldCByb3VuZCBjb3JuZXIgZnJvbSBhIHBvaW50IGFuZCBpdHMgcHJldmlvdXMgYW5kIG5leHQgbmVpZ2hib3VycyBpbiBhIHBhdGhcbiAqXG4gKiBAcGFyYW0gcHJldmlvdXNQb2ludCB7e3g6IG51bWJlciwgeTpudW1iZXIsIHJhZGl1czogbnVtYmVyP319XG4gKiBAcGFyYW0gY3VycmVudFBvaW50IHt7eDogbnVtYmVyLCB5Om51bWJlciwgcmFkaXVzOiBudW1iZXI/fX1cbiAqIEBwYXJhbSBuZXh0UG9pbnQge3t4OiBudW1iZXIsIHk6bnVtYmVyLCByYWRpdXM6IG51bWJlcj99fVxuICogQHBhcmFtIHJhZGl1c01heCA6bnVtYmVyXG4gKiBAcGFyYW0gaXNBcmNSYWRpdXMgOmJvb2xlYW5cbiAqIEByZXR1cm4ge3tcbiAqIGN4Om51bWJlciwgY3k6bnVtYmVyLCByYWRpdXM6bnVtYmVyLFxuICogc3RhcnRYOm51bWJlciwgc3RhcnRZOm51bWJlcixcbiAqIHN0b3BYOm51bWJlciwgc3RvcFk6IG51bWJlcixcbiAqIGVuZEFuZ2xlOiBudW1iZXIsIHN0YXJ0QW5nbGU6IG51bWJlciwgY291bnRlckNsb2Nrd2lzZTogYm9vbGVhblxuICogfX1cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRDb3JuZXIocHJldmlvdXNQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQsIHJhZGl1c01heCkge1xuICB2YXIgaXNBcmNSYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIGlmIChyYWRpdXNNYXggPT09IDAgfHwgY3VycmVudFBvaW50LnJhZGl1cyA9PT0gMCkgcmV0dXJuIHtcbiAgICBjeDogY3VycmVudFBvaW50LngsXG4gICAgY3k6IGN1cnJlbnRQb2ludC55LFxuICAgIHJhZGl1czogMCxcbiAgICBzdGFydFg6IGN1cnJlbnRQb2ludC54LFxuICAgIHN0YXJ0WTogY3VycmVudFBvaW50LnksXG4gICAgc3RvcFg6IGN1cnJlbnRQb2ludC54LFxuICAgIHN0b3BZOiBjdXJyZW50UG9pbnQueSxcbiAgICBzdGFydEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICBjb3VudGVyQ2xvY2t3aXNlOiB1bmRlZmluZWRcbiAgfTtcbiAgY2FsY0Nvcm5lckFyYyhwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgcmFkaXVzTWF4LCBpc0FyY1JhZGl1cyk7XG4gIHJldHVybiB7XG4gICAgY3g6IHgsXG4gICAgY3k6IHksXG4gICAgcmFkaXVzOiBjUmFkaXVzLFxuICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgIHN0b3BYOiBzdG9wWCxcbiAgICBzdG9wWTogc3RvcFksXG4gICAgc3RhcnRBbmdsZTogdjEuYW5nICsgTWF0aC5QSSAvIDIgKiByYWREaXJlY3Rpb24sXG4gICAgZW5kQW5nbGU6IHYyLmFuZyAtIE1hdGguUEkgLyAyICogcmFkRGlyZWN0aW9uLFxuICAgIGNvdW50ZXJDbG9ja3dpc2U6IGRyYXdEaXJlY3Rpb25cbiAgfTtcbn1cblxudmFyIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UID0gMC4wMTtcbnZhciBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVF9MID0gTWF0aC5zcXJ0KDIgKiBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCk7XG52YXIgQlJwJGMgPSB7fTtcbkJScCRjLmZpbmRNaWRwdFB0c0V0YyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cyxcbiAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlO1xuICB2YXIgbWlkcHRQdHM7XG5cbiAgLy8gbi5iLiBhc3N1bWVzIGFsbCBlZGdlcyBpbiBiZXppZXIgYnVuZGxlIGhhdmUgc2FtZSBlbmRwb2ludHMgc3BlY2lmaWVkXG4gIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgdmFyIHRndE1hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1lbmRwb2ludCcpO1xuICB2YXIgaGF2ZU1hbnVhbEVuZFB0cyA9IHNyY01hbkVuZHB0LnVuaXRzICE9IG51bGwgJiYgdGd0TWFuRW5kcHQudW5pdHMgIT0gbnVsbDtcbiAgdmFyIHJlY2FsY1ZlY3Rvck5vcm1JbnZlcnNlID0gZnVuY3Rpb24gcmVjYWxjVmVjdG9yTm9ybUludmVyc2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgZHkgPSB5MiAtIHkxO1xuICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiAtZHkgLyBsLFxuICAgICAgeTogZHggLyBsXG4gICAgfTtcbiAgfTtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgc3dpdGNoIChlZGdlRGlzdGFuY2VzKSB7XG4gICAgY2FzZSAnbm9kZS1wb3NpdGlvbic6XG4gICAgICBtaWRwdFB0cyA9IHBvc1B0cztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludGVyc2VjdGlvbic6XG4gICAgICBtaWRwdFB0cyA9IGludGVyc2VjdGlvblB0cztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZHBvaW50cyc6XG4gICAgICB7XG4gICAgICAgIGlmIChoYXZlTWFudWFsRW5kUHRzKSB7XG4gICAgICAgICAgdmFyIF90aGlzJG1hbnVhbEVuZHB0VG9QeCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KGVkZ2Uuc291cmNlKClbMF0sIHNyY01hbkVuZHB0KSxcbiAgICAgICAgICAgIF90aGlzJG1hbnVhbEVuZHB0VG9QeDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRtYW51YWxFbmRwdFRvUHgsIDIpLFxuICAgICAgICAgICAgeDEgPSBfdGhpcyRtYW51YWxFbmRwdFRvUHgyWzBdLFxuICAgICAgICAgICAgeTEgPSBfdGhpcyRtYW51YWxFbmRwdFRvUHgyWzFdO1xuICAgICAgICAgIHZhciBfdGhpcyRtYW51YWxFbmRwdFRvUHgzID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoZWRnZS50YXJnZXQoKVswXSwgdGd0TWFuRW5kcHQpLFxuICAgICAgICAgICAgX3RoaXMkbWFudWFsRW5kcHRUb1B4NCA9IF9zbGljZWRUb0FycmF5KF90aGlzJG1hbnVhbEVuZHB0VG9QeDMsIDIpLFxuICAgICAgICAgICAgeDIgPSBfdGhpcyRtYW51YWxFbmRwdFRvUHg0WzBdLFxuICAgICAgICAgICAgeTIgPSBfdGhpcyRtYW51YWxFbmRwdFRvUHg0WzFdO1xuICAgICAgICAgIHZhciBlbmRQdHMgPSB7XG4gICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0gcmVjYWxjVmVjdG9yTm9ybUludmVyc2UoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgIG1pZHB0UHRzID0gZW5kUHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXCJFZGdlIFwiLmNvbmNhdChlZGdlLmlkKCksIFwiIGhhcyBlZGdlLWRpc3RhbmNlczplbmRwb2ludHMgc3BlY2lmaWVkIHdpdGhvdXQgbWFudWFsIGVuZHBvaW50cyBzcGVjaWZpZWQgdmlhIHNvdXJjZS1lbmRwb2ludCBhbmQgdGFyZ2V0LWVuZHBvaW50LiAgRmFsbGluZyBiYWNrIG9uIGVkZ2UtZGlzdGFuY2VzOmludGVyc2VjdGlvbiAoZGVmYXVsdCkuXCIpKTtcbiAgICAgICAgICBtaWRwdFB0cyA9IGludGVyc2VjdGlvblB0czsgLy8gYmFjayB0byBkZWZhdWx0XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtaWRwdFB0czogbWlkcHRQdHMsXG4gICAgdmVjdG9yTm9ybUludmVyc2U6IHZlY3Rvck5vcm1JbnZlcnNlXG4gIH07XG59O1xuQlJwJGMuZmluZEhheXN0YWNrUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgaWYgKCFycy5oYXlzdGFjaykge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMuc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICAgIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgIHZhciByYWRpdXMgPSBlZGdlLnBzdHlsZSgnaGF5c3RhY2stcmFkaXVzJykudmFsdWU7XG4gICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMgLyAyOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LCBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueCwgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XTtcbiAgICBycy5taWRYID0gKHJzLmFsbHB0c1swXSArIHJzLmFsbHB0c1syXSkgLyAyO1xuICAgIHJzLm1pZFkgPSAocnMuYWxscHRzWzFdICsgcnMuYWxscHRzWzNdKSAvIDI7XG5cbiAgICAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuICAgIHJzLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICBycy5oYXlzdGFjayA9IHRydWU7XG4gICAgdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKGVkZ2UpO1xuICB9XG59O1xuQlJwJGMuZmluZFNlZ21lbnRzUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIC8vIFNlZ21lbnRzIChtdWx0aXBsZSBzdHJhaWdodCBsaW5lcylcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgc2VnbWVudFdzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtd2VpZ2h0cycpO1xuICB2YXIgc2VnbWVudERzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBzZWdtZW50UnMgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC1yYWRpaScpO1xuICB2YXIgc2VnbWVudFRzID0gZWRnZS5wc3R5bGUoJ3JhZGl1cy10eXBlJyk7XG4gIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbihzZWdtZW50V3MucGZWYWx1ZS5sZW5ndGgsIHNlZ21lbnREcy5wZlZhbHVlLmxlbmd0aCk7XG4gIHZhciBsYXN0UmFkaXVzID0gc2VnbWVudFJzLnBmVmFsdWVbc2VnbWVudFJzLnBmVmFsdWUubGVuZ3RoIC0gMV07XG4gIHZhciBsYXN0UmFkaXVzVHlwZSA9IHNlZ21lbnRUcy5wZlZhbHVlW3NlZ21lbnRUcy5wZlZhbHVlLmxlbmd0aCAtIDFdO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHJzLnNlZ3B0cyA9IFtdO1xuICBycy5yYWRpaSA9IFtdO1xuICBycy5pc0FyY1JhZGl1cyA9IFtdO1xuICBmb3IgKHZhciBzID0gMDsgcyA8IHNlZ21lbnRzTjsgcysrKSB7XG4gICAgdmFyIHcgPSBzZWdtZW50V3MucGZWYWx1ZVtzXTtcbiAgICB2YXIgZCA9IHNlZ21lbnREcy5wZlZhbHVlW3NdO1xuICAgIHZhciB3MSA9IDEgLSB3O1xuICAgIHZhciB3MiA9IHc7XG4gICAgdmFyIF90aGlzJGZpbmRNaWRwdFB0c0V0YyA9IHRoaXMuZmluZE1pZHB0UHRzRXRjKGVkZ2UsIHBhaXJJbmZvKSxcbiAgICAgIG1pZHB0UHRzID0gX3RoaXMkZmluZE1pZHB0UHRzRXRjLm1pZHB0UHRzLFxuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMudmVjdG9yTm9ybUludmVyc2U7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5zZWdwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGQpO1xuICAgIHJzLnJhZGlpLnB1c2goc2VnbWVudFJzLnBmVmFsdWVbc10gIT09IHVuZGVmaW5lZCA/IHNlZ21lbnRScy5wZlZhbHVlW3NdIDogbGFzdFJhZGl1cyk7XG4gICAgcnMuaXNBcmNSYWRpdXMucHVzaCgoc2VnbWVudFRzLnBmVmFsdWVbc10gIT09IHVuZGVmaW5lZCA/IHNlZ21lbnRUcy5wZlZhbHVlW3NdIDogbGFzdFJhZGl1c1R5cGUpID09PSAnYXJjLXJhZGl1cycpO1xuICB9XG59O1xuQlJwJGMuZmluZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAvLyBTZWxmLWVkZ2VcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZGlyQ291bnRzID0gcGFpckluZm8uZGlyQ291bnRzLFxuICAgIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcztcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgbG9vcERpciA9IGVkZ2UucHN0eWxlKCdsb29wLWRpcmVjdGlvbicpLnBmVmFsdWU7XG4gIHZhciBsb29wU3dwID0gZWRnZS5wc3R5bGUoJ2xvb3Atc3dlZXAnKS5wZlZhbHVlO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICBycy5lZGdlVHlwZSA9ICdzZWxmJztcbiAgdmFyIGogPSBpO1xuICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuICB2YXIgbG9vcEFuZ2xlID0gbG9vcERpciAtIE1hdGguUEkgLyAyO1xuICB2YXIgb3V0QW5nbGUgPSBsb29wQW5nbGUgLSBsb29wU3dwIC8gMjtcbiAgdmFyIGluQW5nbGUgPSBsb29wQW5nbGUgKyBsb29wU3dwIC8gMjtcblxuICAvLyBpbmNyZWFzZSBieSBzdGVwIHNpemUgZm9yIG92ZXJsYXBwaW5nIGxvb3BzLCBrZXllZCBvbiBkaXJlY3Rpb24gYW5kIHN3ZWVwIHZhbHVlc1xuICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG4gIHJzLmN0cmxwdHMgPSBbc3JjUG9zLnggKyBNYXRoLmNvcyhvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKV07XG59O1xuQlJwJGMuZmluZENvbXBvdW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gIC8vIENvbXBvdW5kIGVkZ2VcblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG4gIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBqID0gaTtcbiAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cbiAgdmFyIGxvb3BXID0gNTA7XG4gIHZhciBsb29wYVBvcyA9IHtcbiAgICB4OiBzcmNQb3MueCAtIHNyY1cgLyAyLFxuICAgIHk6IHNyY1Bvcy55IC0gc3JjSCAvIDJcbiAgfTtcbiAgdmFyIGxvb3BiUG9zID0ge1xuICAgIHg6IHRndFBvcy54IC0gdGd0VyAvIDIsXG4gICAgeTogdGd0UG9zLnkgLSB0Z3RIIC8gMlxuICB9O1xuICB2YXIgbG9vcFBvcyA9IHtcbiAgICB4OiBNYXRoLm1pbihsb29wYVBvcy54LCBsb29wYlBvcy54KSxcbiAgICB5OiBNYXRoLm1pbihsb29wYVBvcy55LCBsb29wYlBvcy55KVxuICB9O1xuXG4gIC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuICB2YXIgbWluQ29tcG91bmRTdHJldGNoID0gMC41O1xuICB2YXIgY29tcG91bmRTdHJldGNoQSA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coc3JjVyAqIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UKSk7XG4gIHZhciBjb21wb3VuZFN0cmV0Y2hCID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlQpKTtcbiAgcnMuY3RybHB0cyA9IFtsb29wUG9zLngsIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hBLCBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQiwgbG9vcFBvcy55XTtcbn07XG5CUnAkYy5maW5kU3RyYWlnaHRFZGdlUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgLy8gU3RyYWlnaHQgZWRnZSB3aXRoaW4gYnVuZGxlXG5cbiAgZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaC5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG59O1xuQlJwJGMuZmluZEJlemllclBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkLCBlZGdlSXNTd2FwcGVkKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0V3MgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC13ZWlnaHRzJyk7XG4gIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbihjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCkgOiAxO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWzBdO1xuXG4gIC8vIChNdWx0aSliZXppZXJcblxuICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG4gIHJzLmVkZ2VUeXBlID0gbXVsdGkgPyAnbXVsdGliZXppZXInIDogJ2Jlemllcic7XG4gIHJzLmN0cmxwdHMgPSBbXTtcbiAgZm9yICh2YXIgYiA9IDA7IGIgPCBiZXppZXJOOyBiKyspIHtcbiAgICB2YXIgbm9ybWN0cmxwdERpc3QgPSAoMC41IC0gcGFpckluZm8uZWxlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZSAqIChlZGdlSXNTd2FwcGVkID8gLTEgOiAxKTtcbiAgICB2YXIgbWFuY3RybHB0RGlzdCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgc2lnbiA9IHNpZ251bShub3JtY3RybHB0RGlzdCk7XG4gICAgaWYgKG11bHRpKSB7XG4gICAgICBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlW2JdIDogc3RlcFNpemU7IC8vIGZhbGwgYmFjayBvbiBzdGVwIHNpemVcbiAgICAgIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlW2JdO1xuICAgIH1cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgZGlzdGFuY2VGcm9tTWlkcG9pbnQgPSBtYW5jdHJscHREaXN0ICE9PSB1bmRlZmluZWQgPyBtYW5jdHJscHREaXN0IDogbm9ybWN0cmxwdERpc3Q7XG4gICAgdmFyIHcxID0gMSAtIGN0cmxwdFdlaWdodDtcbiAgICB2YXIgdzIgPSBjdHJscHRXZWlnaHQ7XG4gICAgdmFyIF90aGlzJGZpbmRNaWRwdFB0c0V0YzIgPSB0aGlzLmZpbmRNaWRwdFB0c0V0YyhlZGdlLCBwYWlySW5mbyksXG4gICAgICBtaWRwdFB0cyA9IF90aGlzJGZpbmRNaWRwdFB0c0V0YzIubWlkcHRQdHMsXG4gICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IF90aGlzJGZpbmRNaWRwdFB0c0V0YzIudmVjdG9yTm9ybUludmVyc2U7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5jdHJscHRzLnB1c2goYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50LCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQpO1xuICB9XG59O1xuQlJwJGMuZmluZFRheGlQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgLy8gVGF4aWNhYiBnZW9tZXRyeSB3aXRoIHR3byB0dXJucyBtYXhpbXVtXG5cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICB2YXIgVkVSVElDQUwgPSAndmVydGljYWwnO1xuICB2YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbiAgdmFyIExFRlRXQVJEID0gJ2xlZnR3YXJkJztcbiAgdmFyIFJJR0hUV0FSRCA9ICdyaWdodHdhcmQnO1xuICB2YXIgRE9XTldBUkQgPSAnZG93bndhcmQnO1xuICB2YXIgVVBXQVJEID0gJ3Vwd2FyZCc7XG4gIHZhciBBVVRPID0gJ2F1dG8nO1xuICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICB2YXIgZEluY2x1ZGVzTm9kZUJvZHkgPSBlZGdlRGlzdGFuY2VzICE9PSAnbm9kZS1wb3NpdGlvbic7XG4gIHZhciB0YXhpRGlyID0gZWRnZS5wc3R5bGUoJ3RheGktZGlyZWN0aW9uJykudmFsdWU7XG4gIHZhciByYXdUYXhpRGlyID0gdGF4aURpcjsgLy8gdW5wcm9jZXNzZWQgdmFsdWVcbiAgdmFyIHRheGlUdXJuID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybicpO1xuICB2YXIgdHVybklzUGVyY2VudCA9IHRheGlUdXJuLnVuaXRzID09PSAnJSc7XG4gIHZhciB0YXhpVHVyblBmVmFsID0gdGF4aVR1cm4ucGZWYWx1ZTtcbiAgdmFyIHR1cm5Jc05lZ2F0aXZlID0gdGF4aVR1cm5QZlZhbCA8IDA7IC8vIGkuZS4gZnJvbSB0YXJnZXQgc2lkZVxuICB2YXIgbWluRCA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJykucGZWYWx1ZTtcbiAgdmFyIGR3ID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjVyArIHRndFcpIC8gMiA6IDA7XG4gIHZhciBkaCA9IGRJbmNsdWRlc05vZGVCb2R5ID8gKHNyY0ggKyB0Z3RIKSAvIDIgOiAwO1xuICB2YXIgcGR4ID0gcG9zUHRzLngyIC0gcG9zUHRzLngxO1xuICB2YXIgcGR5ID0gcG9zUHRzLnkyIC0gcG9zUHRzLnkxO1xuXG4gIC8vIHRha2UgYXdheSB0aGUgZWZmZWN0aXZlIHcvaCBmcm9tIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGRlbHRhIHZhbHVlXG4gIHZhciBzdWJEV0ggPSBmdW5jdGlvbiBzdWJEV0goZHh5LCBkd2gpIHtcbiAgICBpZiAoZHh5ID4gMCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGR4eSAtIGR3aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihkeHkgKyBkd2gsIDApO1xuICAgIH1cbiAgfTtcbiAgdmFyIGR4ID0gc3ViRFdIKHBkeCwgZHcpO1xuICB2YXIgZHkgPSBzdWJEV0gocGR5LCBkaCk7XG4gIHZhciBpc0V4cGxpY2l0RGlyID0gZmFsc2U7XG4gIGlmIChyYXdUYXhpRGlyID09PSBBVVRPKSB7XG4gICAgdGF4aURpciA9IE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSA/IEhPUklaT05UQUwgOiBWRVJUSUNBTDtcbiAgfSBlbHNlIGlmIChyYXdUYXhpRGlyID09PSBVUFdBUkQgfHwgcmF3VGF4aURpciA9PT0gRE9XTldBUkQpIHtcbiAgICB0YXhpRGlyID0gVkVSVElDQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH0gZWxzZSBpZiAocmF3VGF4aURpciA9PT0gTEVGVFdBUkQgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEKSB7XG4gICAgdGF4aURpciA9IEhPUklaT05UQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH1cbiAgdmFyIGlzVmVydCA9IHRheGlEaXIgPT09IFZFUlRJQ0FMO1xuICB2YXIgbCA9IGlzVmVydCA/IGR5IDogZHg7XG4gIHZhciBwbCA9IGlzVmVydCA/IHBkeSA6IHBkeDtcbiAgdmFyIHNnbkwgPSBzaWdudW0ocGwpO1xuICB2YXIgZm9yY2VkRGlyID0gZmFsc2U7XG4gIGlmICghKGlzRXhwbGljaXREaXIgJiYgKHR1cm5Jc1BlcmNlbnQgfHwgdHVybklzTmVnYXRpdmUpKSAvLyBmb3JjaW5nIGluIHRoaXMgY2FzZSB3b3VsZCBjYXVzZSB3ZWlyZCBncm93aW5nIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgJiYgKHJhd1RheGlEaXIgPT09IERPV05XQVJEICYmIHBsIDwgMCB8fCByYXdUYXhpRGlyID09PSBVUFdBUkQgJiYgcGwgPiAwIHx8IHJhd1RheGlEaXIgPT09IExFRlRXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBSSUdIVFdBUkQgJiYgcGwgPCAwKSkge1xuICAgIHNnbkwgKj0gLTE7XG4gICAgbCA9IHNnbkwgKiBNYXRoLmFicyhsKTtcbiAgICBmb3JjZWREaXIgPSB0cnVlO1xuICB9XG4gIHZhciBkO1xuICBpZiAodHVybklzUGVyY2VudCkge1xuICAgIHZhciBwID0gdGF4aVR1cm5QZlZhbCA8IDAgPyAxICsgdGF4aVR1cm5QZlZhbCA6IHRheGlUdXJuUGZWYWw7XG4gICAgZCA9IHAgKiBsO1xuICB9IGVsc2Uge1xuICAgIHZhciBrID0gdGF4aVR1cm5QZlZhbCA8IDAgPyBsIDogMDtcbiAgICBkID0gayArIHRheGlUdXJuUGZWYWwgKiBzZ25MO1xuICB9XG4gIHZhciBnZXRJc1Rvb0Nsb3NlID0gZnVuY3Rpb24gZ2V0SXNUb29DbG9zZShkKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGQpIDwgbWluRCB8fCBNYXRoLmFicyhkKSA+PSBNYXRoLmFicyhsKTtcbiAgfTtcbiAgdmFyIGlzVG9vQ2xvc2VTcmMgPSBnZXRJc1Rvb0Nsb3NlKGQpO1xuICB2YXIgaXNUb29DbG9zZVRndCA9IGdldElzVG9vQ2xvc2UoTWF0aC5hYnMobCkgLSBNYXRoLmFicyhkKSk7XG4gIHZhciBpc1Rvb0Nsb3NlID0gaXNUb29DbG9zZVNyYyB8fCBpc1Rvb0Nsb3NlVGd0O1xuICBpZiAoaXNUb29DbG9zZSAmJiAhZm9yY2VkRGlyKSB7XG4gICAgLy8gbm9uLWlkZWFsIHJvdXRpbmdcbiAgICBpZiAoaXNWZXJ0KSB7XG4gICAgICAvLyB2ZXJ0aWNhbCBmYWxsYmFja3NcbiAgICAgIHZhciBsU2hhcGVJbnNpZGVTcmMgPSBNYXRoLmFicyhwbCkgPD0gc3JjSCAvIDI7XG4gICAgICB2YXIgbFNoYXBlSW5zaWRlVGd0ID0gTWF0aC5hYnMocGR4KSA8PSB0Z3RXIC8gMjtcbiAgICAgIGlmIChsU2hhcGVJbnNpZGVTcmMpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIHggPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG4gICAgICAgIHZhciB5MSA9IHBvc1B0cy55MSxcbiAgICAgICAgICB5MiA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gsIHkxLCB4LCB5Ml07XG4gICAgICB9IGVsc2UgaWYgKGxTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgdmFyIHgxID0gcG9zUHRzLngxLFxuICAgICAgICAgIHgyID0gcG9zUHRzLngyO1xuICAgICAgICBycy5zZWdwdHMgPSBbeDEsIHksIHgyLCB5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEwtc2hhcGUgZmFsbGJhY2sgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZCwgYnV0IHdvcmtzIHdlbGwgd2l0aCB0cmVlIHNpYmxpbmdzKVxuICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngxLCBwb3NQdHMueTJdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3Jpem9udGFsIGZhbGxiYWNrc1xuICAgICAgdmFyIF9sU2hhcGVJbnNpZGVTcmMgPSBNYXRoLmFicyhwbCkgPD0gc3JjVyAvIDI7XG4gICAgICB2YXIgX2xTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeSkgPD0gdGd0SCAvIDI7XG4gICAgICBpZiAoX2xTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIF95ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuICAgICAgICB2YXIgX3ggPSBwb3NQdHMueDEsXG4gICAgICAgICAgX3gyID0gcG9zUHRzLngyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3gsIF95LCBfeDIsIF95XTtcbiAgICAgIH0gZWxzZSBpZiAoX2xTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAvLyBob3Jpem9udGFsIFotc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIF94MyA9IChwb3NQdHMueDEgKyBwb3NQdHMueDIpIC8gMjtcbiAgICAgICAgdmFyIF95MiA9IHBvc1B0cy55MSxcbiAgICAgICAgICBfeTMgPSBwb3NQdHMueTI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFtfeDMsIF95MiwgX3gzLCBfeTNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTC1zaGFwZSAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCBmb3IgdHJlZSBzaWJsaW5ncylcbiAgICAgICAgcnMuc2VncHRzID0gW3Bvc1B0cy54MiwgcG9zUHRzLnkxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWRlYWwgcm91dGluZ1xuICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgIHZhciBfeTQgPSBwb3NQdHMueTEgKyBkICsgKGRJbmNsdWRlc05vZGVCb2R5ID8gc3JjSCAvIDIgKiBzZ25MIDogMCk7XG4gICAgICB2YXIgX3g0ID0gcG9zUHRzLngxLFxuICAgICAgICBfeDUgPSBwb3NQdHMueDI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g0LCBfeTQsIF94NSwgX3k0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgdmFyIF94NiA9IHBvc1B0cy54MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNXIC8gMiAqIHNnbkwgOiAwKTtcbiAgICAgIHZhciBfeTUgPSBwb3NQdHMueTEsXG4gICAgICAgIF95NiA9IHBvc1B0cy55MjtcbiAgICAgIHJzLnNlZ3B0cyA9IFtfeDYsIF95NSwgX3g2LCBfeTZdO1xuICAgIH1cbiAgfVxuICBpZiAocnMuaXNSb3VuZCkge1xuICAgIHZhciByYWRpdXMgPSBlZGdlLnBzdHlsZSgndGF4aS1yYWRpdXMnKS52YWx1ZTtcbiAgICB2YXIgaXNBcmNSYWRpdXMgPSBlZGdlLnBzdHlsZSgncmFkaXVzLXR5cGUnKS52YWx1ZVswXSA9PT0gJ2FyYy1yYWRpdXMnO1xuICAgIHJzLnJhZGlpID0gbmV3IEFycmF5KHJzLnNlZ3B0cy5sZW5ndGggLyAyKS5maWxsKHJhZGl1cyk7XG4gICAgcnMuaXNBcmNSYWRpdXMgPSBuZXcgQXJyYXkocnMuc2VncHRzLmxlbmd0aCAvIDIpLmZpbGwoaXNBcmNSYWRpdXMpO1xuICB9XG59O1xuQlJwJGMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIC8vIGNhbiBvbmx5IGNvcnJlY3QgYmV6aWVycyBmb3Igbm93Li4uXG4gIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicpIHtcbiAgICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zLFxuICAgICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgdGd0SCA9IHBhaXJJbmZvLnRndEgsXG4gICAgICBzcmNTaGFwZSA9IHBhaXJJbmZvLnNyY1NoYXBlLFxuICAgICAgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZSxcbiAgICAgIHNyY0Nvcm5lclJhZGl1cyA9IHBhaXJJbmZvLnNyY0Nvcm5lclJhZGl1cyxcbiAgICAgIHRndENvcm5lclJhZGl1cyA9IHBhaXJJbmZvLnRndENvcm5lclJhZGl1cyxcbiAgICAgIHNyY1JzID0gcGFpckluZm8uc3JjUnMsXG4gICAgICB0Z3RScyA9IHBhaXJJbmZvLnRndFJzO1xuICAgIHZhciBiYWRTdGFydCA9ICFudW1iZXIkMShycy5zdGFydFgpIHx8ICFudW1iZXIkMShycy5zdGFydFkpO1xuICAgIHZhciBiYWRBU3RhcnQgPSAhbnVtYmVyJDEocnMuYXJyb3dTdGFydFgpIHx8ICFudW1iZXIkMShycy5hcnJvd1N0YXJ0WSk7XG4gICAgdmFyIGJhZEVuZCA9ICFudW1iZXIkMShycy5lbmRYKSB8fCAhbnVtYmVyJDEocnMuZW5kWSk7XG4gICAgdmFyIGJhZEFFbmQgPSAhbnVtYmVyJDEocnMuYXJyb3dFbmRYKSB8fCAhbnVtYmVyJDEocnMuYXJyb3dFbmRZKTtcbiAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbiAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG4gICAgdmFyIHN0YXJ0QUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICB9LCB7XG4gICAgICB4OiBycy5zdGFydFgsXG4gICAgICB5OiBycy5zdGFydFlcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgdmFyIGVuZEFDcERpc3QgPSBkaXN0KHtcbiAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogcnMuZW5kWCxcbiAgICAgIHk6IHJzLmVuZFlcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VFbmRBQ3AgPSBlbmRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcbiAgICBpZiAoYmFkU3RhcnQgfHwgYmFkQVN0YXJ0IHx8IGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgdmFyIGNwRCA9IHtcbiAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gc3JjUG9zLnlcbiAgICAgIH07XG4gICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KGNwRC54ICogY3BELnggKyBjcEQueSAqIGNwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgIHZhciBjcE0gPSB7XG4gICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICB9O1xuICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgdmFyIGNwUHJvaiA9IHtcbiAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICB9O1xuICAgICAgdmFyIHNyY0N0cmxQdEludG4gPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjVywgc3JjSCwgY3BQcm9qLngsIGNwUHJvai55LCAwLCBzcmNDb3JuZXJSYWRpdXMsIHNyY1JzKTtcbiAgICAgIGlmIChjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gc3JjQ3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHNyY0N0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiYWRFbmQgfHwgYmFkQUVuZCB8fCBjbG9zZUVuZEFDcCkge1xuICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICB2YXIgX2NwRCA9IHtcbiAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHRndFBvcy54LFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgIH07XG4gICAgICB2YXIgX2NwTCA9IE1hdGguc3FydChfY3BELnggKiBfY3BELnggKyBfY3BELnkgKiBfY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgdmFyIF9jcE0gPSB7XG4gICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgeDogX2NwRC54IC8gX2NwTCxcbiAgICAgICAgeTogX2NwRC55IC8gX2NwTFxuICAgICAgfTtcbiAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICB2YXIgX2NwUHJvaiA9IHtcbiAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgX2NwTS54ICogMiAqIF9yYWRpdXMsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBfY3BNLnkgKiAyICogX3JhZGl1c1xuICAgICAgfTtcbiAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIF9jcFByb2oueCwgX2NwUHJvai55LCAwLCB0Z3RDb3JuZXJSYWRpdXMsIHRndFJzKTtcbiAgICAgIGlmIChjbG9zZUVuZEFDcCkge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgX2NwTS55ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSB0Z3RDdHJsUHRJbnRuWzBdICsgX2NwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHRndEN0cmxQdEludG5bMV0gKyBfY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcmxhcHBpbmcpIHtcbiAgICAgIC8vIHJlY2FsYyBlbmRwdHNcbiAgICAgIHRoaXMuZmluZEVuZHBvaW50cyhlZGdlKTtcbiAgICB9XG4gIH1cbn07XG5CUnAkYy5zdG9yZUFsbHB0cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmIChycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcbiAgICBmb3IgKHZhciBiID0gMDsgYiArIDEgPCBycy5jdHJscHRzLmxlbmd0aDsgYiArPSAyKSB7XG4gICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgcnMuYWxscHRzLnB1c2gocnMuY3RybHB0c1tiXSwgcnMuY3RybHB0c1tiICsgMV0pO1xuXG4gICAgICAvLyB0aGUgbWlkcHQgYmV0d2VlbiBjdHJscHRzIGFzIGludGVybWVkaWF0ZSBkZXN0aW5hdGlvbiBwdHNcbiAgICAgIGlmIChiICsgMyA8IHJzLmN0cmxwdHMubGVuZ3RoKSB7XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKChycy5jdHJscHRzW2JdICsgcnMuY3RybHB0c1tiICsgMl0pIC8gMiwgKHJzLmN0cmxwdHNbYiArIDFdICsgcnMuY3RybHB0c1tiICsgM10pIC8gMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuICAgIHZhciBtLCBtdDtcbiAgICBpZiAocnMuY3RybHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHJzLm1pZFggPSBycy5hbGxwdHNbbV07XG4gICAgICBycy5taWRZID0gcnMuYWxscHRzW20gKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMztcbiAgICAgIG10ID0gMC41O1xuICAgICAgcnMubWlkWCA9IHFiZXppZXJBdChycy5hbGxwdHNbbV0sIHJzLmFsbHB0c1ttICsgMl0sIHJzLmFsbHB0c1ttICsgNF0sIG10KTtcbiAgICAgIHJzLm1pZFkgPSBxYmV6aWVyQXQocnMuYWxscHRzW20gKyAxXSwgcnMuYWxscHRzW20gKyAzXSwgcnMuYWxscHRzW20gKyA1XSwgbXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgIC8vIG5lZWQgdG8gY2FsYyB0aGVzZSBhZnRlciBlbmRwdHNcbiAgICBycy5hbGxwdHMgPSBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFldO1xuXG4gICAgLy8gZGVmYXVsdCBtaWRwdCBmb3IgbGFiZWxzIGV0Y1xuICAgIHJzLm1pZFggPSAocnMuc3RhcnRYICsgcnMuZW5kWCArIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYKSAvIDQ7XG4gICAgcnMubWlkWSA9IChycy5zdGFydFkgKyBycy5lbmRZICsgcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkpIC8gNDtcbiAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcbiAgICBycy5hbGxwdHMucHVzaC5hcHBseShycy5hbGxwdHMsIHJzLnNlZ3B0cyk7XG4gICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG4gICAgaWYgKHJzLmlzUm91bmQpIHtcbiAgICAgIHJzLnJvdW5kQ29ybmVycyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgKyAzIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBycy5yYWRpaVtpIC8gMiAtIDFdO1xuICAgICAgICB2YXIgaXNBcmNSYWRpdXMgPSBycy5pc0FyY1JhZGl1c1tpIC8gMiAtIDFdO1xuICAgICAgICBycy5yb3VuZENvcm5lcnMucHVzaChnZXRSb3VuZENvcm5lcih7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2kgLSAyXSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSAtIDFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXSxcbiAgICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2kgKyAyXSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSArIDNdXG4gICAgICAgIH0sIHJhZGl1cywgaXNBcmNSYWRpdXMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJzLnNlZ3B0cy5sZW5ndGggJSA0ID09PSAwKSB7XG4gICAgICB2YXIgaTIgPSBycy5zZWdwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIHJzLm1pZFggPSAocnMuc2VncHRzW2kxXSArIHJzLnNlZ3B0c1tpMl0pIC8gMjtcbiAgICAgIHJzLm1pZFkgPSAocnMuc2VncHRzW2kxICsgMV0gKyBycy5zZWdwdHNbaTIgKyAxXSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2kgPSBycy5zZWdwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICBpZiAoIXJzLmlzUm91bmQpIHtcbiAgICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1tfaV07XG4gICAgICAgIHJzLm1pZFkgPSBycy5zZWdwdHNbX2kgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBycy5zZWdwdHNbX2ldLFxuICAgICAgICAgIHk6IHJzLnNlZ3B0c1tfaSArIDFdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb3JuZXIgPSBycy5yb3VuZENvcm5lcnNbX2kgLyAyXTtcbiAgICAgICAgaWYgKGNvcm5lci5yYWRpdXMgPT09IDApIHtcbiAgICAgICAgICAvLyBPbiBjb2xsaW5lYXIgcG9pbnRzXG4gICAgICAgICAgdmFyIG5leHRQb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHJzLnNlZ3B0c1tfaSArIDJdLFxuICAgICAgICAgICAgeTogcnMuc2VncHRzW19pICsgM11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJzLm1pZFggPSBwb2ludC54O1xuICAgICAgICAgIHJzLm1pZFkgPSBwb2ludC55O1xuICAgICAgICAgIHJzLm1pZFZlY3RvciA9IFtwb2ludC55IC0gbmV4dFBvaW50LnksIG5leHRQb2ludC54IC0gcG9pbnQueF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT24gcm91bmRlZCBwb2ludHNcbiAgICAgICAgICB2YXIgdiA9IFtwb2ludC54IC0gY29ybmVyLmN4LCBwb2ludC55IC0gY29ybmVyLmN5XTtcbiAgICAgICAgICB2YXIgZmFjdG9yID0gY29ybmVyLnJhZGl1cyAvIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbiAgICAgICAgICB2ID0gdi5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogZmFjdG9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJzLm1pZFggPSBjb3JuZXIuY3ggKyB2WzBdO1xuICAgICAgICAgIHJzLm1pZFkgPSBjb3JuZXIuY3kgKyB2WzFdO1xuICAgICAgICAgIHJzLm1pZFZlY3RvciA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5CUnAkYy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmIChycy5ub2Rlc092ZXJsYXAgfHwgbnVtYmVyJDEocnMuc3RhcnRYKSAmJiBudW1iZXIkMShycy5zdGFydFkpICYmIG51bWJlciQxKHJzLmVuZFgpICYmIG51bWJlciQxKHJzLmVuZFkpKSB7XG4gICAgcnMubG9nZ2VkRXJyID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFycy5sb2dnZWRFcnIpIHtcbiAgICAgIHJzLmxvZ2dlZEVyciA9IHRydWU7XG4gICAgICB3YXJuKCdFZGdlIGAnICsgZWRnZS5pZCgpICsgJ2AgaGFzIGludmFsaWQgZW5kcG9pbnRzIGFuZCBzbyBpdCBpcyBpbXBvc3NpYmxlIHRvIGRyYXcuICBBZGp1c3QgeW91ciBlZGdlIHN0eWxlIChlLmcuIGNvbnRyb2wgcG9pbnRzKSBhY2NvcmRpbmdseSBvciB1c2UgYW4gYWx0ZXJuYXRpdmUgZWRnZSB0eXBlLiAgVGhpcyBpcyBleHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB0aGUgc291cmNlIG5vZGUgYW5kIHRoZSB0YXJnZXQgbm9kZSBvdmVybGFwLicpO1xuICAgIH1cbiAgfVxufTtcbkJScCRjLmZpbmRFZGdlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBpZiAoIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBoYXNoVGFibGUgPSBuZXcgTWFwJDEoKTtcbiAgdmFyIGdldEtleSA9IGZ1bmN0aW9uIGdldEtleShwYWlySWQsIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhaXJJZCksIFtlZGdlSXNVbmJ1bmRsZWQgPyAxIDogMF0pLmpvaW4oJy0nKTtcbiAgfTtcbiAgdmFyIHBhaXJJZHMgPSBbXTtcbiAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTtcblxuICAvLyBjcmVhdGUgYSB0YWJsZSBvZiBlZGdlIChzcmMsIHRndCkgPT4gbGlzdCBvZiBlZGdlcyBiZXR3ZWVuIHRoZW1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuXG4gICAgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcbiAgICBpZiAoZWRnZS5yZW1vdmVkKCkgfHwgIWVkZ2UudGFrZXNVcFNwYWNlKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgZW5kc1dpdGgoY3VydmVTdHlsZSwgJ3NlZ21lbnRzJykgfHwgY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0JyB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnIHx8IGVuZHNXaXRoKGN1cnZlU3R5bGUsICd0YXhpJyk7XG4gICAgdmFyIGVkZ2VJc0JlemllciA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnYmV6aWVyJztcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY0luZGV4ID0gc3JjLnBvb2xJbmRleCgpO1xuICAgIHZhciB0Z3RJbmRleCA9IHRndC5wb29sSW5kZXgoKTtcbiAgICB2YXIgcGFpcklkID0gW3NyY0luZGV4LCB0Z3RJbmRleF0uc29ydCgpO1xuICAgIHZhciBrZXkgPSBnZXRLZXkocGFpcklkLCBlZGdlSXNVbmJ1bmRsZWQpO1xuICAgIHZhciB0YWJsZUVudHJ5ID0gaGFzaFRhYmxlLmdldChrZXkpO1xuICAgIGlmICh0YWJsZUVudHJ5ID09IG51bGwpIHtcbiAgICAgIHRhYmxlRW50cnkgPSB7XG4gICAgICAgIGVsZXM6IFtdXG4gICAgICB9O1xuICAgICAgcGFpcklkcy5wdXNoKHtcbiAgICAgICAgcGFpcklkOiBwYWlySWQsXG4gICAgICAgIGVkZ2VJc1VuYnVuZGxlZDogZWRnZUlzVW5idW5kbGVkXG4gICAgICB9KTtcbiAgICAgIGhhc2hUYWJsZS5zZXQoa2V5LCB0YWJsZUVudHJ5KTtcbiAgICB9XG4gICAgdGFibGVFbnRyeS5lbGVzLnB1c2goZWRnZSk7XG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgdGFibGVFbnRyeS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZWRnZUlzQmV6aWVyKSB7XG4gICAgICB0YWJsZUVudHJ5Lmhhc0JlemllciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gIC8vIE5lc3RlZCBmb3IgbG9vcCBpcyBPSzsgdG90YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGJvdGggbG9vcHMgPSBlZGdlQ291bnRcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIF9wYWlySWRzJHAgPSBwYWlySWRzW3BdLFxuICAgICAgcGFpcklkID0gX3BhaXJJZHMkcC5wYWlySWQsXG4gICAgICBlZGdlSXNVbmJ1bmRsZWQgPSBfcGFpcklkcyRwLmVkZ2VJc1VuYnVuZGxlZDtcbiAgICB2YXIga2V5ID0gZ2V0S2V5KHBhaXJJZCwgZWRnZUlzVW5idW5kbGVkKTtcbiAgICB2YXIgcGFpckluZm8gPSBoYXNoVGFibGUuZ2V0KGtleSk7XG4gICAgdmFyIHN3YXBwZWRwYWlySW5mbztcbiAgICBpZiAoIXBhaXJJbmZvLmhhc1VuYnVuZGxlZCkge1xuICAgICAgdmFyIHBsbEVkZ2VzID0gcGFpckluZm8uZWxlc1swXS5wYXJhbGxlbEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlLmlzQnVuZGxlZEJlemllcigpO1xuICAgICAgfSk7XG4gICAgICBjbGVhckFycmF5KHBhaXJJbmZvLmVsZXMpO1xuICAgICAgcGxsRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gcGFpckluZm8uZWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvciBlYWNoIHBhaXIgaWQsIHRoZSBlZGdlcyBzaG91bGQgYmUgc29ydGVkIGJ5IGluZGV4XG4gICAgICBwYWlySW5mby5lbGVzLnNvcnQoZnVuY3Rpb24gKGVkZ2UxLCBlZGdlMikge1xuICAgICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZmlyc3RFZGdlID0gcGFpckluZm8uZWxlc1swXTtcbiAgICB2YXIgc3JjID0gZmlyc3RFZGdlLnNvdXJjZSgpO1xuICAgIHZhciB0Z3QgPSBmaXJzdEVkZ2UudGFyZ2V0KCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50IHcuci50LiBwYWlySWRcbiAgICBpZiAoc3JjLnBvb2xJbmRleCgpID4gdGd0LnBvb2xJbmRleCgpKSB7XG4gICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgIHNyYyA9IHRndDtcbiAgICAgIHRndCA9IHRlbXA7XG4gICAgfVxuICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gcGFpckluZm8udGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBwYWlySW5mby5zcmNXID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHBhaXJJbmZvLnNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgdGd0VyA9IHBhaXJJbmZvLnRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgIHZhciB0Z3RIID0gcGFpckluZm8udGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuICAgIHZhciBzcmNTaGFwZSA9IHBhaXJJbmZvLnNyY1NoYXBlID0gci5ub2RlU2hhcGVzW190aGlzLmdldE5vZGVTaGFwZShzcmMpXTtcbiAgICB2YXIgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUodGd0KV07XG4gICAgdmFyIHNyY0Nvcm5lclJhZGl1cyA9IHBhaXJJbmZvLnNyY0Nvcm5lclJhZGl1cyA9IHNyYy5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogc3JjLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gICAgdmFyIHRndENvcm5lclJhZGl1cyA9IHBhaXJJbmZvLnRndENvcm5lclJhZGl1cyA9IHRndC5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogdGd0LnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gICAgdmFyIHRndFJzID0gcGFpckluZm8udGd0UnMgPSB0Z3QuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHNyY1JzID0gcGFpckluZm8uc3JjUnMgPSBzcmMuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgcGFpckluZm8uZGlyQ291bnRzID0ge1xuICAgICAgJ25vcnRoJzogMCxcbiAgICAgICd3ZXN0JzogMCxcbiAgICAgICdzb3V0aCc6IDAsXG4gICAgICAnZWFzdCc6IDAsXG4gICAgICAnbm9ydGh3ZXN0JzogMCxcbiAgICAgICdzb3V0aHdlc3QnOiAwLFxuICAgICAgJ25vcnRoZWFzdCc6IDAsXG4gICAgICAnc291dGhlYXN0JzogMFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFpckluZm8uZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2VkZ2UgPSBwYWlySW5mby5lbGVzW19pMl07XG4gICAgICB2YXIgcnMgPSBfZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBfY3VydmVTdHlsZSA9IF9lZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgICAgIHZhciBfZWRnZUlzVW5idW5kbGVkID0gX2N1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBlbmRzV2l0aChfY3VydmVTdHlsZSwgJ3NlZ21lbnRzJykgfHwgZW5kc1dpdGgoX2N1cnZlU3R5bGUsICd0YXhpJyk7XG5cbiAgICAgIC8vIHdoZXRoZXIgdGhlIG5vcm1hbGlzZWQgcGFpciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgZWRnZSdzIHNyYy10Z3Qgb3JkZXJcbiAgICAgIHZhciBlZGdlSXNTd2FwcGVkID0gIXNyYy5zYW1lKF9lZGdlLnNvdXJjZSgpKTtcbiAgICAgIGlmICghcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiAmJiBzcmMgIT09IHRndCAmJiAocGFpckluZm8uaGFzQmV6aWVyIHx8IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCkpIHtcbiAgICAgICAgcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiA9IHRydWU7XG5cbiAgICAgICAgLy8gcHQgb3V0c2lkZSBzcmMgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNyY1csIHNyY0gsIHRndFBvcy54LCB0Z3RQb3MueSwgMCwgc3JjQ29ybmVyUmFkaXVzLCBzcmNScyk7XG4gICAgICAgIHZhciBzcmNJbnRuID0gcGFpckluZm8uc3JjSW50biA9IHNyY091dHNpZGU7XG5cbiAgICAgICAgLy8gcHQgb3V0c2lkZSB0Z3Qgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIHNyY1Bvcy54LCBzcmNQb3MueSwgMCwgdGd0Q29ybmVyUmFkaXVzLCB0Z3RScyk7XG4gICAgICAgIHZhciB0Z3RJbnRuID0gcGFpckluZm8udGd0SW50biA9IHRndE91dHNpZGU7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyA9IHtcbiAgICAgICAgICB4MTogc3JjUG9zLngsXG4gICAgICAgICAgeDI6IHRndFBvcy54LFxuICAgICAgICAgIHkxOiBzcmNQb3MueSxcbiAgICAgICAgICB5MjogdGd0UG9zLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGR5ID0gdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV07XG4gICAgICAgIHZhciBkeCA9IHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdO1xuICAgICAgICB2YXIgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmIChudW1iZXIkMShsKSAmJiBsID49IEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UX0wpIDsgZWxzZSB7XG4gICAgICAgICAgbCA9IE1hdGguc3FydChNYXRoLm1heChkeCAqIGR4LCBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCkgKyBNYXRoLm1heChkeSAqIGR5LCBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZWN0b3IgPSBwYWlySW5mby52ZWN0b3IgPSB7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSBwYWlySW5mby52ZWN0b3JOb3JtID0ge1xuICAgICAgICAgIHg6IHZlY3Rvci54IC8gbCxcbiAgICAgICAgICB5OiB2ZWN0b3IueSAvIGxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgbm9kZSBzaGFwZXMgb3ZlcmxhcCwgdGhlbiBubyBjdHJsIHB0cyB0byBkcmF3XG4gICAgICAgIHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCA9ICFudW1iZXIkMShsKSB8fCB0Z3RTaGFwZS5jaGVja1BvaW50KHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIDAsIHRndFcsIHRndEgsIHRndFBvcy54LCB0Z3RQb3MueSwgdGd0Q29ybmVyUmFkaXVzLCB0Z3RScykgfHwgc3JjU2hhcGUuY2hlY2tQb2ludCh0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCAwLCBzcmNXLCBzcmNILCBzcmNQb3MueCwgc3JjUG9zLnksIHNyY0Nvcm5lclJhZGl1cywgc3JjUnMpO1xuICAgICAgICBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZSA9IHZlY3Rvck5vcm1JbnZlcnNlO1xuICAgICAgICBzd2FwcGVkcGFpckluZm8gPSB7XG4gICAgICAgICAgbm9kZXNPdmVybGFwOiBwYWlySW5mby5ub2Rlc092ZXJsYXAsXG4gICAgICAgICAgZGlyQ291bnRzOiBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgICAgICAgY2FsY3VsYXRlZEludGVyc2VjdGlvbjogdHJ1ZSxcbiAgICAgICAgICBoYXNCZXppZXI6IHBhaXJJbmZvLmhhc0JlemllcixcbiAgICAgICAgICBoYXNVbmJ1bmRsZWQ6IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCxcbiAgICAgICAgICBlbGVzOiBwYWlySW5mby5lbGVzLFxuICAgICAgICAgIHNyY1BvczogdGd0UG9zLFxuICAgICAgICAgIHNyY1JzOiB0Z3RScyxcbiAgICAgICAgICB0Z3RQb3M6IHNyY1BvcyxcbiAgICAgICAgICB0Z3RSczogc3JjUnMsXG4gICAgICAgICAgc3JjVzogdGd0VyxcbiAgICAgICAgICBzcmNIOiB0Z3RILFxuICAgICAgICAgIHRndFc6IHNyY1csXG4gICAgICAgICAgdGd0SDogc3JjSCxcbiAgICAgICAgICBzcmNJbnRuOiB0Z3RJbnRuLFxuICAgICAgICAgIHRndEludG46IHNyY0ludG4sXG4gICAgICAgICAgc3JjU2hhcGU6IHRndFNoYXBlLFxuICAgICAgICAgIHRndFNoYXBlOiBzcmNTaGFwZSxcbiAgICAgICAgICBwb3NQdHM6IHtcbiAgICAgICAgICAgIHgxOiBwb3NQdHMueDIsXG4gICAgICAgICAgICB5MTogcG9zUHRzLnkyLFxuICAgICAgICAgICAgeDI6IHBvc1B0cy54MSxcbiAgICAgICAgICAgIHkyOiBwb3NQdHMueTFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVyc2VjdGlvblB0czoge1xuICAgICAgICAgICAgeDE6IGludGVyc2VjdGlvblB0cy54MixcbiAgICAgICAgICAgIHkxOiBpbnRlcnNlY3Rpb25QdHMueTIsXG4gICAgICAgICAgICB4MjogaW50ZXJzZWN0aW9uUHRzLngxLFxuICAgICAgICAgICAgeTI6IGludGVyc2VjdGlvblB0cy55MVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yLnlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvck5vcm06IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yTm9ybS55XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZToge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm1JbnZlcnNlLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yTm9ybUludmVyc2UueVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXNzZWRQYWlySW5mbyA9IGVkZ2VJc1N3YXBwZWQgPyBzd2FwcGVkcGFpckluZm8gOiBwYWlySW5mbztcbiAgICAgIHJzLm5vZGVzT3ZlcmxhcCA9IHBhc3NlZFBhaXJJbmZvLm5vZGVzT3ZlcmxhcDtcbiAgICAgIHJzLnNyY0ludG4gPSBwYXNzZWRQYWlySW5mby5zcmNJbnRuO1xuICAgICAgcnMudGd0SW50biA9IHBhc3NlZFBhaXJJbmZvLnRndEludG47XG4gICAgICBycy5pc1JvdW5kID0gX2N1cnZlU3R5bGUuc3RhcnRzV2l0aCgncm91bmQnKTtcbiAgICAgIGlmIChoYXNDb21wb3VuZHMgJiYgKHNyYy5pc1BhcmVudCgpIHx8IHNyYy5pc0NoaWxkKCkgfHwgdGd0LmlzUGFyZW50KCkgfHwgdGd0LmlzQ2hpbGQoKSkgJiYgKHNyYy5wYXJlbnRzKCkuYW55U2FtZSh0Z3QpIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZShzcmMpIHx8IHNyYy5zYW1lKHRndCkgJiYgc3JjLmlzUGFyZW50KCkpKSB7XG4gICAgICAgIF90aGlzLmZpbmRDb21wb3VuZExvb3BQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChzcmMgPT09IHRndCkge1xuICAgICAgICBfdGhpcy5maW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlLmVuZHNXaXRoKCdzZWdtZW50cycpKSB7XG4gICAgICAgIF90aGlzLmZpbmRTZWdtZW50c1BvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZS5lbmRzV2l0aCgndGF4aScpKSB7XG4gICAgICAgIF90aGlzLmZpbmRUYXhpUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8ICFfZWRnZUlzVW5idW5kbGVkICYmIHBhaXJJbmZvLmVsZXMubGVuZ3RoICUgMiA9PT0gMSAmJiBfaTIgPT09IE1hdGguZmxvb3IocGFpckluZm8uZWxlcy5sZW5ndGggLyAyKSkge1xuICAgICAgICBfdGhpcy5maW5kU3RyYWlnaHRFZGdlUG9pbnRzKF9lZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmZpbmRCZXppZXJQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpO1xuICAgICAgfVxuICAgICAgX3RoaXMuZmluZEVuZHBvaW50cyhfZWRnZSk7XG4gICAgICBfdGhpcy50cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICBfdGhpcy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyhfZWRnZSk7XG4gICAgICBfdGhpcy5zdG9yZUFsbHB0cyhfZWRnZSk7XG4gICAgICBfdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhfZWRnZSk7XG4gICAgICBfdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyhfZWRnZSk7XG4gICAgICBfdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKF9lZGdlKTtcbiAgICAgIF90aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKF9lZGdlKTtcbiAgICB9IC8vIGZvciBwYWlyIGVkZ2VzXG4gIH07XG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKykge1xuICAgIF9sb29wKCk7XG4gIH0gLy8gZm9yIHBhaXIgaWRzXG5cbiAgLy8gaGF5c3RhY2tzIGF2b2lkIHRoZSBleHBlbnNlIG9mIHBhaXJJbmZvIHN0dWZmIChpbnRlcnNlY3Rpb25zIGV0Yy4pXG4gIHRoaXMuZmluZEhheXN0YWNrUG9pbnRzKGhheXN0YWNrRWRnZXMpO1xufTtcbmZ1bmN0aW9uIGdldFB0cyhwdHMpIHtcbiAgdmFyIHJldFB0cyA9IFtdO1xuICBpZiAocHRzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgcmV0UHRzLnB1c2goe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0UHRzO1xufVxuQlJwJGMuZ2V0U2VnbWVudFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuICBpZiAodHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHJldHVybiBnZXRQdHMocnMuc2VncHRzKTtcbiAgfVxufTtcbkJScCRjLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcbiAgaWYgKHR5cGUgPT09ICdiZXppZXInIHx8IHR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgdHlwZSA9PT0gJ3NlbGYnIHx8IHR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICByZXR1cm4gZ2V0UHRzKHJzLmN0cmxwdHMpO1xuICB9XG59O1xuQlJwJGMuZ2V0RWRnZU1pZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHJldHVybiB7XG4gICAgeDogcnMubWlkWCxcbiAgICB5OiBycy5taWRZXG4gIH07XG59O1xuXG52YXIgQlJwJGIgPSB7fTtcbkJScCRiLm1hbnVhbEVuZHB0VG9QeCA9IGZ1bmN0aW9uIChub2RlLCBwcm9wKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5wb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiAocHJvcC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcCA9IFtwcm9wLnBmVmFsdWVbMF0sIHByb3AucGZWYWx1ZVsxXV07XG4gICAgaWYgKHByb3AudW5pdHNbMF0gPT09ICclJykge1xuICAgICAgcFswXSA9IHBbMF0gKiB3O1xuICAgIH1cbiAgICBpZiAocHJvcC51bml0c1sxXSA9PT0gJyUnKSB7XG4gICAgICBwWzFdID0gcFsxXSAqIGg7XG4gICAgfVxuICAgIHBbMF0gKz0gbnBvcy54O1xuICAgIHBbMV0gKz0gbnBvcy55O1xuICAgIHJldHVybiBwO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmdsZSA9IHByb3AucGZWYWx1ZVswXTtcbiAgICBhbmdsZSA9IC1NYXRoLlBJIC8gMiArIGFuZ2xlOyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrXG5cbiAgICB2YXIgbCA9IDIgKiBNYXRoLm1heCh3LCBoKTtcbiAgICB2YXIgX3AgPSBbbnBvcy54ICsgTWF0aC5jb3MoYW5nbGUpICogbCwgbnBvcy55ICsgTWF0aC5zaW4oYW5nbGUpICogbF07XG4gICAgcmV0dXJuIHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uaW50ZXJzZWN0TGluZShucG9zLngsIG5wb3MueSwgdywgaCwgX3BbMF0sIF9wWzFdLCAwLCBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWUsIHJzKTtcbiAgfVxufTtcbkJScCRiLmZpbmRFbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgX3JlZiwgX3RndE1hbkVuZHB0JHBmVmFsdWUsIF9yZWYyLCBfc3JjTWFuRW5kcHQkcGZWYWx1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW50ZXJzZWN0O1xuICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gIHZhciBzcmNQb3MgPSBzb3VyY2UucG9zaXRpb24oKTtcbiAgdmFyIHRndFBvcyA9IHRhcmdldC5wb3NpdGlvbigpO1xuICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHNyY0FyU2hhcGUgPSBlZGdlLnBzdHlsZSgnc291cmNlLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB0Z3REaXN0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICB2YXIgc3JjRGlzdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgdmFyIHNyY1JzID0gc291cmNlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdGd0UnMgPSB0YXJnZXQuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICB2YXIgdGF4aSA9IGVuZHNXaXRoKGN1cnZlU3R5bGUsICd0YXhpJyk7IC8vIENvdmVycyB0YXhpIGFuZCByb3VuZC10YXhpXG4gIHZhciBzZWxmID0gZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGJlemllciA9IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ211bHRpYmV6aWVyJyB8fCBzZWxmO1xuICB2YXIgbXVsdGkgPSBldCAhPT0gJ2Jlemllcic7XG4gIHZhciBsaW5lcyA9IGV0ID09PSAnc3RyYWlnaHQnIHx8IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgc2VnbWVudHMgPSBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGhhc0VuZHB0cyA9IGJlemllciB8fCBtdWx0aSB8fCBsaW5lcztcbiAgdmFyIG92ZXJyaWRlRW5kcHRzID0gc2VsZiB8fCB0YXhpO1xuICB2YXIgc3JjTWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgnc291cmNlLWVuZHBvaW50Jyk7XG4gIHZhciBzcmNNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiBzcmNNYW5FbmRwdC52YWx1ZTtcbiAgdmFyIHNyY0Nvcm5lclJhZGl1cyA9IHNvdXJjZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZSA9PT0gJ2F1dG8nID8gJ2F1dG8nIDogc291cmNlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gIHZhciB0Z3RNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZW5kcG9pbnQnKTtcbiAgdmFyIHRndE1hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHRndE1hbkVuZHB0LnZhbHVlO1xuICB2YXIgdGd0Q29ybmVyUmFkaXVzID0gdGFyZ2V0LnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiB0YXJnZXQucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgcnMuc3JjTWFuRW5kcHQgPSBzcmNNYW5FbmRwdDtcbiAgcnMudGd0TWFuRW5kcHQgPSB0Z3RNYW5FbmRwdDtcbiAgdmFyIHAxOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gdGFyZ2V0IHNpZGVcbiAgdmFyIHAyOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gc291cmNlIHNpZGVcblxuICB2YXIgcDFfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggdGFyZ2V0IHNoYXBlXG4gIHZhciBwMl9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCBzb3VyY2Ugc2hhcGVcblxuICB2YXIgdGd0TWFuRW5kcHRQdCA9IChfcmVmID0gKHRndE1hbkVuZHB0ID09PSBudWxsIHx8IHRndE1hbkVuZHB0ID09PSB1bmRlZmluZWQgfHwgKF90Z3RNYW5FbmRwdCRwZlZhbHVlID0gdGd0TWFuRW5kcHQucGZWYWx1ZSkgPT09IG51bGwgfHwgX3RndE1hbkVuZHB0JHBmVmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF90Z3RNYW5FbmRwdCRwZlZhbHVlLmxlbmd0aCkgPT09IDIgPyB0Z3RNYW5FbmRwdC5wZlZhbHVlIDogbnVsbCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdW5kZWZpbmVkID8gX3JlZiA6IFswLCAwXTtcbiAgdmFyIHNyY01hbkVuZHB0UHQgPSAoX3JlZjIgPSAoc3JjTWFuRW5kcHQgPT09IG51bGwgfHwgc3JjTWFuRW5kcHQgPT09IHVuZGVmaW5lZCB8fCAoX3NyY01hbkVuZHB0JHBmVmFsdWUgPSBzcmNNYW5FbmRwdC5wZlZhbHVlKSA9PT0gbnVsbCB8fCBfc3JjTWFuRW5kcHQkcGZWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3NyY01hbkVuZHB0JHBmVmFsdWUubGVuZ3RoKSA9PT0gMiA/IHNyY01hbkVuZHB0LnBmVmFsdWUgOiBudWxsKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdW5kZWZpbmVkID8gX3JlZjIgOiBbMCwgMF07XG4gIGlmIChiZXppZXIpIHtcbiAgICB2YXIgY3BTdGFydCA9IFtycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdXTtcbiAgICB2YXIgY3BFbmQgPSBtdWx0aSA/IFtycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMl0sIHJzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAxXV0gOiBjcFN0YXJ0O1xuICAgIHAxID0gY3BFbmQ7XG4gICAgcDIgPSBjcFN0YXJ0O1xuICB9IGVsc2UgaWYgKGxpbmVzKSB7XG4gICAgdmFyIHNyY0Fycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gW3RndFBvcy54ICsgdGd0TWFuRW5kcHRQdFswXSwgdGd0UG9zLnkgKyB0Z3RNYW5FbmRwdFB0WzFdXSA6IHJzLnNlZ3B0cy5zbGljZSgwLCAyKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbc3JjUG9zLnggKyBzcmNNYW5FbmRwdFB0WzBdLCBzcmNQb3MueSArIHNyY01hbkVuZHB0UHRbMV1dIDogcnMuc2VncHRzLnNsaWNlKHJzLnNlZ3B0cy5sZW5ndGggLSAyKTtcbiAgICBwMSA9IHRndEFycm93RnJvbVB0O1xuICAgIHAyID0gc3JjQXJyb3dGcm9tUHQ7XG4gIH1cbiAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgaW50ZXJzZWN0ID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gIH0gZWxzZSBpZiAodGd0TWFuRW5kcHQudW5pdHMpIHtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCh0YXJnZXQsIHRndE1hbkVuZHB0KTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICBpbnRlcnNlY3QgPSBycy50Z3RJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgfSBlbHNlIHtcbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IHAxO1xuICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgIH1cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRhcmdldC5vdXRlcldpZHRoKCksIHRhcmdldC5vdXRlckhlaWdodCgpLCBwMV9pWzBdLCBwMV9pWzFdLCAwLCB0Z3RDb3JuZXJSYWRpdXMsIHRndFJzKTtcbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHRycyA9IHRhcmdldC5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBsdyA9IHRycy5sYWJlbFdpZHRoO1xuICAgICAgdmFyIGxoID0gdHJzLmxhYmVsSGVpZ2h0O1xuICAgICAgdmFyIGx4ID0gdHJzLmxhYmVsWDtcbiAgICAgIHZhciBseSA9IHRycy5sYWJlbFk7XG4gICAgICB2YXIgbHcyID0gbHcgLyAyO1xuICAgICAgdmFyIGxoMiA9IGxoIC8gMjtcbiAgICAgIHZhciB2YSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG4gICAgICBpZiAodmEgPT09ICd0b3AnKSB7XG4gICAgICAgIGx5IC09IGxoMjtcbiAgICAgIH0gZWxzZSBpZiAodmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGx5ICs9IGxoMjtcbiAgICAgIH1cbiAgICAgIHZhciBoYSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG4gICAgICBpZiAoaGEgPT09ICdsZWZ0Jykge1xuICAgICAgICBseCAtPSBsdzI7XG4gICAgICB9IGVsc2UgaWYgKGhhID09PSAncmlnaHQnKSB7XG4gICAgICAgIGx4ICs9IGx3MjtcbiAgICAgIH1cbiAgICAgIHZhciBsYWJlbEludGVyc2VjdCA9IHBvbHlnb25JbnRlcnNlY3RMaW5lKHAxX2lbMF0sIHAxX2lbMV0sIFtseCAtIGx3MiwgbHkgLSBsaDIsIGx4ICsgbHcyLCBseSAtIGxoMiwgbHggKyBsdzIsIGx5ICsgbGgyLCBseCAtIGx3MiwgbHkgKyBsaDJdLCB0Z3RQb3MueCwgdGd0UG9zLnkpO1xuICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlZlB0ID0gc3JjUG9zO1xuICAgICAgICB2YXIgaW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIGxhYkludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQobGFiZWxJbnRlcnNlY3QpKTtcbiAgICAgICAgdmFyIG1pblNxRGlzdCA9IGludFNxZGlzdDtcbiAgICAgICAgaWYgKGxhYkludFNxZGlzdCA8IGludFNxZGlzdCkge1xuICAgICAgICAgIGludGVyc2VjdCA9IGxhYmVsSW50ZXJzZWN0O1xuICAgICAgICAgIG1pblNxRGlzdCA9IGxhYkludFNxZGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBsYWJJbnQyU3FEaXN0ID0gc3FkaXN0KHJlZlB0LCB7XG4gICAgICAgICAgICB4OiBsYWJlbEludGVyc2VjdFsyXSxcbiAgICAgICAgICAgIHk6IGxhYmVsSW50ZXJzZWN0WzNdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGxhYkludDJTcURpc3QgPCBtaW5TcURpc3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdCA9IFtsYWJlbEludGVyc2VjdFsyXSwgbGFiZWxJbnRlcnNlY3RbM11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgYXJyb3dFbmQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHRndERpc3QpO1xuICB2YXIgZWRnZUVuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkgKyB0Z3REaXN0KTtcbiAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ2luc2lkZS10by1ub2RlJykge1xuICAgIGludGVyc2VjdCA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0LnVuaXRzKSB7XG4gICAgaW50ZXJzZWN0ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoc291cmNlLCBzcmNNYW5FbmRwdCk7XG4gIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgaW50ZXJzZWN0ID0gcnMuc3JjSW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgIHAyX2kgPSBwMjtcbiAgICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHAyX2kgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgICB9XG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzb3VyY2Uub3V0ZXJXaWR0aCgpLCBzb3VyY2Uub3V0ZXJIZWlnaHQoKSwgcDJfaVswXSwgcDJfaVsxXSwgMCwgc3JjQ29ybmVyUmFkaXVzLCBzcmNScyk7XG4gICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHZhciBzcnMgPSBzb3VyY2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgX2x3ID0gc3JzLmxhYmVsV2lkdGg7XG4gICAgICB2YXIgX2xoID0gc3JzLmxhYmVsSGVpZ2h0O1xuICAgICAgdmFyIF9seCA9IHNycy5sYWJlbFg7XG4gICAgICB2YXIgX2x5ID0gc3JzLmxhYmVsWTtcbiAgICAgIHZhciBfbHcyID0gX2x3IC8gMjtcbiAgICAgIHZhciBfbGgyID0gX2xoIC8gMjtcbiAgICAgIHZhciBfdmEgPSBzb3VyY2UucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuICAgICAgaWYgKF92YSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgX2x5IC09IF9saDI7XG4gICAgICB9IGVsc2UgaWYgKF92YSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgX2x5ICs9IF9saDI7XG4gICAgICB9XG4gICAgICB2YXIgX2hhID0gc291cmNlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICAgIGlmIChfaGEgPT09ICdsZWZ0Jykge1xuICAgICAgICBfbHggLT0gX2x3MjtcbiAgICAgIH0gZWxzZSBpZiAoX2hhID09PSAncmlnaHQnKSB7XG4gICAgICAgIF9seCArPSBfbHcyO1xuICAgICAgfVxuICAgICAgdmFyIF9sYWJlbEludGVyc2VjdCA9IHBvbHlnb25JbnRlcnNlY3RMaW5lKHAyX2lbMF0sIHAyX2lbMV0sIFtfbHggLSBfbHcyLCBfbHkgLSBfbGgyLCBfbHggKyBfbHcyLCBfbHkgLSBfbGgyLCBfbHggKyBfbHcyLCBfbHkgKyBfbGgyLCBfbHggLSBfbHcyLCBfbHkgKyBfbGgyXSwgc3JjUG9zLngsIHNyY1Bvcy55KTtcbiAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX3JlZlB0ID0gdGd0UG9zO1xuICAgICAgICB2YXIgX2ludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KGludGVyc2VjdCkpO1xuICAgICAgICB2YXIgX2xhYkludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KF9sYWJlbEludGVyc2VjdCkpO1xuICAgICAgICB2YXIgX21pblNxRGlzdCA9IF9pbnRTcWRpc3Q7XG4gICAgICAgIGlmIChfbGFiSW50U3FkaXN0IDwgX2ludFNxZGlzdCkge1xuICAgICAgICAgIGludGVyc2VjdCA9IFtfbGFiZWxJbnRlcnNlY3RbMF0sIF9sYWJlbEludGVyc2VjdFsxXV07XG4gICAgICAgICAgX21pblNxRGlzdCA9IF9sYWJJbnRTcWRpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9sYWJlbEludGVyc2VjdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFyIF9sYWJJbnQyU3FEaXN0ID0gc3FkaXN0KF9yZWZQdCwge1xuICAgICAgICAgICAgeDogX2xhYmVsSW50ZXJzZWN0WzJdLFxuICAgICAgICAgICAgeTogX2xhYmVsSW50ZXJzZWN0WzNdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKF9sYWJJbnQyU3FEaXN0IDwgX21pblNxRGlzdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFsyXSwgX2xhYmVsSW50ZXJzZWN0WzNdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGFycm93U3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHNyY0Rpc3QpO1xuICB2YXIgZWRnZVN0YXJ0ID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAyLCByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSArIHNyY0Rpc3QpO1xuICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG4gIGlmIChoYXNFbmRwdHMpIHtcbiAgICBpZiAoIW51bWJlciQxKHJzLnN0YXJ0WCkgfHwgIW51bWJlciQxKHJzLnN0YXJ0WSkgfHwgIW51bWJlciQxKHJzLmVuZFgpIHx8ICFudW1iZXIkMShycy5lbmRZKSkge1xuICAgICAgcnMuYmFkTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5CUnAkYi5nZXRTb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMF0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzFdXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5hcnJvd1N0YXJ0WCxcbiAgICAgICAgeTogcnMuYXJyb3dTdGFydFlcbiAgICAgIH07XG4gIH1cbn07XG5CUnAkYi5nZXRUYXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMl0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzNdXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICAgIHk6IHJzLmFycm93RW5kWVxuICAgICAgfTtcbiAgfVxufTtcblxudmFyIEJScCRhID0ge307XG5mdW5jdGlvbiBwdXNoQmV6aWVyUHRzKHIsIGVkZ2UsIHB0cykge1xuICB2YXIgcWJlemllckF0JDEgPSBmdW5jdGlvbiBxYmV6aWVyQXQkMShwMSwgcDIsIHAzLCB0KSB7XG4gICAgcmV0dXJuIHFiZXppZXJBdChwMSwgcDIsIHAzLCB0KTtcbiAgfTtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHIuYmV6aWVyUHJvalBjdHNbaV07XG4gICAgYnB0cy5wdXNoKHtcbiAgICAgIHg6IHFiZXppZXJBdCQxKHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIHApLFxuICAgICAgeTogcWJlemllckF0JDEocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgcClcbiAgICB9KTtcbiAgfVxufVxuQlJwJGEuc3RvcmVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG5cbiAgLy8gY2xlYXIgdGhlIGNhY2hlZCBwb2ludHMgc3RhdGVcbiAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gbnVsbDtcbiAgaWYgKGV0ID09PSAnbXVsdGliZXppZXInIHx8IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnKSB7XG4gICAgX3AucnN0eWxlLmJlemllclB0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgcHVzaEJlemllclB0cyh0aGlzLCBlZGdlLCBycy5hbGxwdHMuc2xpY2UoaSwgaSArIDYpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXQgPT09ICdzZWdtZW50cycpIHtcbiAgICB2YXIgbHB0cyA9IF9wLnJzdHlsZS5saW5lUHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBscHRzLnB1c2goe1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ2hheXN0YWNrJykge1xuICAgIHZhciBocHRzID0gcnMuaGF5c3RhY2tQdHM7XG4gICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW3tcbiAgICAgIHg6IGhwdHNbMF0sXG4gICAgICB5OiBocHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogaHB0c1syXSxcbiAgICAgIHk6IGhwdHNbM11cbiAgICB9XTtcbiAgfVxuICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbn07XG5CUnAkYS5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICB0aGlzLmZpbmRFZGdlQ29udHJvbFBvaW50cyhlZGdlcyk7XG59O1xuXG52YXIgQlJwJDkgPSB7fTtcbkJScCQ5LnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjb250ZW50ID0gbm9kZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWU7XG4gIGlmIChlbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGV4dFgsIHRleHRZO1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gIHZhciBub2RlUG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnN0clZhbHVlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBlLmcuIGNlbnRlclxuICAgICAgdGV4dFggPSBub2RlUG9zLng7XG4gIH1cbiAgc3dpdGNoICh0ZXh0VmFsaWduKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDIgLSBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gbWlkZGxlXG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueTtcbiAgfVxuICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgcnMubGFiZWxZID0gdGV4dFk7XG4gIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKG5vZGUpO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKG5vZGUpO1xufTtcbnZhciBsaW5lQW5nbGVGcm9tRGVsdGEgPSBmdW5jdGlvbiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcbiAgaWYgKGR4ID09PSAwICYmIGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlID0gYW5nbGUgKiAtMTtcbiAgfVxuICByZXR1cm4gYW5nbGU7XG59O1xudmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uIGxpbmVBbmdsZShwMCwgcDEpIHtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICByZXR1cm4gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSk7XG59O1xudmFyIGJlemllckFuZ2xlID0gZnVuY3Rpb24gYmV6aWVyQW5nbGUocDAsIHAxLCBwMiwgdCkge1xuICB2YXIgdDAgPSBib3VuZCgwLCB0IC0gMC4wMDEsIDEpO1xuICB2YXIgdDEgPSBib3VuZCgwLCB0ICsgMC4wMDEsIDEpO1xuICB2YXIgbHAwID0gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdDApO1xuICB2YXIgbHAxID0gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdDEpO1xuICByZXR1cm4gbGluZUFuZ2xlKGxwMCwgbHAxKTtcbn07XG5CUnAkOS5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHA7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250ZW50ID0ge1xuICAgIG1pZDogZWRnZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWUsXG4gICAgc291cmNlOiBlZGdlLnBzdHlsZSgnc291cmNlLWxhYmVsJykuc3RyVmFsdWUsXG4gICAgdGFyZ2V0OiBlZGdlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJykuc3RyVmFsdWVcbiAgfTtcbiAgaWYgKGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0KSA7IGVsc2Uge1xuICAgIHJldHVybjsgLy8gbm8gbGFiZWxzID0+IG5vIGNhbGNzXG4gIH1cblxuICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAvL1xuICBwID0ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xuICB2YXIgc2V0UnMgPSBmdW5jdGlvbiBzZXRScyhwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICB9O1xuICBzZXRScygnbGFiZWxYJywgbnVsbCwgcC54KTtcbiAgc2V0UnMoJ2xhYmVsWScsIG51bGwsIHAueSk7XG4gIHZhciBtaWRBbmdsZSA9IGxpbmVBbmdsZUZyb21EZWx0YShycy5taWREaXNwWCwgcnMubWlkRGlzcFkpO1xuICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBudWxsLCBtaWRBbmdsZSk7XG4gIHZhciBfY3JlYXRlQ29udHJvbFBvaW50SW5mbyA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8oKSB7XG4gICAgaWYgKF9jcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7XG4gICAgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG4gICAgdmFyIGN0cmxwdHMgPSBbXTtcblxuICAgIC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHAwID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH07XG4gICAgICB2YXIgcDEgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgM11cbiAgICAgIH07IC8vIGN0cmxwdFxuICAgICAgdmFyIHAyID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaSArIDRdLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDVdXG4gICAgICB9O1xuICAgICAgY3RybHB0cy5wdXNoKHtcbiAgICAgICAgcDA6IHAwLFxuICAgICAgICBwMTogcDEsXG4gICAgICAgIHAyOiBwMixcbiAgICAgICAgc3RhcnREaXN0OiAwLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcbiAgICB2YXIgblByb2pzID0gci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChjcCwgcDAsIHAxLCB0MCwgdDEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkaXN0KHAwLCBwMSk7XG4gICAgICB2YXIgcHJldlNlZ21lbnQgPSBjcC5zZWdtZW50c1tjcC5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgdDA6IHQwLFxuICAgICAgICB0MTogdDEsXG4gICAgICAgIHN0YXJ0RGlzdDogcHJldlNlZ21lbnQgPyBwcmV2U2VnbWVudC5zdGFydERpc3QgKyBwcmV2U2VnbWVudC5sZW5ndGggOiAwLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgfTtcbiAgICAgIGNwLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBlYWNoIGN0cmxwdCB3aXRoIHNlZ21lbnQgaW5mb1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdHJscHRzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGNwID0gY3RybHB0c1tfaV07XG4gICAgICB2YXIgcHJldkNwID0gY3RybHB0c1tfaSAtIDFdO1xuICAgICAgaWYgKHByZXZDcCkge1xuICAgICAgICBjcC5zdGFydERpc3QgPSBwcmV2Q3Auc3RhcnREaXN0ICsgcHJldkNwLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFkZFNlZ21lbnQoY3AsIGNwLnAwLCBicHRzW19pICogblByb2pzXSwgMCwgci5iZXppZXJQcm9qUGN0c1swXSk7IC8vIGZpcnN0XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgblByb2pzIC0gMTsgaisrKSB7XG4gICAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBqXSwgYnB0c1tfaSAqIG5Qcm9qcyArIGogKyAxXSwgci5iZXppZXJQcm9qUGN0c1tqXSwgci5iZXppZXJQcm9qUGN0c1tqICsgMV0pO1xuICAgICAgfVxuICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDFdLCBjcC5wMiwgci5iZXppZXJQcm9qUGN0c1tuUHJvanMgLSAxXSwgMSk7IC8vIGxhc3RcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlID0gY3RybHB0cztcbiAgfTtcbiAgdmFyIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKHByZWZpeCkge1xuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgaXNTcmMgPSBwcmVmaXggPT09ICdzb3VyY2UnO1xuICAgIGlmICghY29udGVudFtwcmVmaXhdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLXRleHQtb2Zmc2V0JykucGZWYWx1ZTtcbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY3BzID0gX2NyZWF0ZUNvbnRyb2xQb2ludEluZm8oKTtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgdmFyIHN0YXJ0RGlzdCA9IDA7XG4gICAgICAgICAgdmFyIHRvdGFsRGlzdCA9IDA7XG5cbiAgICAgICAgICAvLyBmaW5kIHRoZSBzZWdtZW50IHdlJ3JlIG9uXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfY3AgPSBjcHNbaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2NwLnNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfc2VnID0gX2NwLnNlZ21lbnRzW2lzU3JjID8gaiA6IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxIC0gal07XG4gICAgICAgICAgICAgIHZhciBsYXN0U2VnID0gaSA9PT0gY3BzLmxlbmd0aCAtIDEgJiYgaiA9PT0gX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHN0YXJ0RGlzdCA9IHRvdGFsRGlzdDtcbiAgICAgICAgICAgICAgdG90YWxEaXN0ICs9IF9zZWcubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAodG90YWxEaXN0ID49IG9mZnNldCB8fCBsYXN0U2VnKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICBjcDogX2NwLFxuICAgICAgICAgICAgICAgICAgc2VnbWVudDogX3NlZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNwID0gc2VsZWN0ZWQuY3A7XG4gICAgICAgICAgdmFyIHNlZyA9IHNlbGVjdGVkLnNlZ21lbnQ7XG4gICAgICAgICAgdmFyIHRTZWdtZW50ID0gKG9mZnNldCAtIHN0YXJ0RGlzdCkgLyBzZWcubGVuZ3RoO1xuICAgICAgICAgIHZhciBzZWdEdCA9IHNlZy50MSAtIHNlZy50MDtcbiAgICAgICAgICB2YXIgdCA9IGlzU3JjID8gc2VnLnQwICsgc2VnRHQgKiB0U2VnbWVudCA6IHNlZy50MSAtIHNlZ0R0ICogdFNlZ21lbnQ7XG4gICAgICAgICAgdCA9IGJvdW5kKDAsIHQsIDEpO1xuICAgICAgICAgIHAgPSBxYmV6aWVyUHRBdChjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICBhbmdsZSA9IGJlemllckFuZ2xlKGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICBkaSxcbiAgICAgICAgICAgIGQwO1xuICAgICAgICAgIHZhciBwMCwgcDE7XG4gICAgICAgICAgdmFyIGwgPSBycy5hbGxwdHMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiArIDMgPCBsOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgaWYgKGlzU3JjKSB7XG4gICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyICsgMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDNdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDIgLSBfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMSAtIF9pMl1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSA0IC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDMgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaSA9IGRpc3QocDAsIHAxKTtcbiAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgIGQgKz0gZGk7XG4gICAgICAgICAgICBpZiAoZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuICAgICAgICAgIHZhciBfdCA9IHBEIC8gZGk7XG4gICAgICAgICAgX3QgPSBib3VuZCgwLCBfdCwgMSk7XG4gICAgICAgICAgcCA9IGxpbmVBdChwMCwgcDEsIF90KTtcbiAgICAgICAgICBhbmdsZSA9IGxpbmVBbmdsZShwMCwgcDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJzKCdsYWJlbFgnLCBwcmVmaXgsIHAueCk7XG4gICAgc2V0UnMoJ2xhYmVsWScsIHByZWZpeCwgcC55KTtcbiAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlKTtcbiAgfTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbignc291cmNlJyk7XG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3RhcmdldCcpO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKGVkZ2UpO1xufTtcbkJScCQ5LmFwcGx5TGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSkge1xuICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlKTtcbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICdzb3VyY2UnKTtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAndGFyZ2V0Jyk7XG4gIH1cbn07XG5CUnAkOS5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG4gIHZhciBjYWNoZUtleSA9IGhhc2hTdHJpbmcodGV4dCwgZWxlLl9wcml2YXRlLmxhYmVsRGltc0tleSk7XG5cbiAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICBpZiAoZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ3ByZWZpeGVkTGFiZWxEaW1zS2V5JywgcHJlZml4KSA9PT0gY2FjaGVLZXkpIHtcbiAgICByZXR1cm47IC8vIHRoZW4gdGhlIGxhYmVsIGRpbWVuc2lvbnMgKyB0ZXh0IGFyZSB0aGUgc2FtZVxuICB9XG5cbiAgLy8gc2F2ZSB0aGUga2V5XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdwcmVmaXhlZExhYmVsRGltc0tleScsIHByZWZpeCwgY2FjaGVLZXkpO1xuICB2YXIgbGFiZWxEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXh0KTtcbiAgdmFyIGxpbmVIZWlnaHQgPSBlbGUucHN0eWxlKCdsaW5lLWhlaWdodCcpLnBmVmFsdWU7XG4gIHZhciB0ZXh0V3JhcCA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnN0clZhbHVlO1xuICB2YXIgbGluZXMgPSBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpIHx8IFtdO1xuICB2YXIgbnVtTGluZXMgPSB0ZXh0V3JhcCAhPT0gJ3dyYXAnID8gMSA6IE1hdGgubWF4KGxpbmVzLmxlbmd0aCwgMSk7XG4gIHZhciBub3JtUGVyTGluZUhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQgLyBudW1MaW5lcztcbiAgdmFyIGxhYmVsTGluZUhlaWdodCA9IG5vcm1QZXJMaW5lSGVpZ2h0ICogbGluZUhlaWdodDtcbiAgdmFyIHdpZHRoID0gbGFiZWxEaW1zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCArIChudW1MaW5lcyAtIDEpICogKGxpbmVIZWlnaHQgLSAxKSAqIG5vcm1QZXJMaW5lSGVpZ2h0O1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIHdpZHRoKTtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIHdpZHRoKTtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgaGVpZ2h0KTtcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxMaW5lSGVpZ2h0JywgcHJlZml4LCBsYWJlbExpbmVIZWlnaHQpO1xufTtcbkJScCQ5LmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwZmQgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHBmZCArICdsYWJlbCcpLnN0clZhbHVlO1xuICB2YXIgdGV4dFRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoJ3RleHQtdHJhbnNmb3JtJykudmFsdWU7XG4gIHZhciByc2NyYXRjaCA9IGZ1bmN0aW9uIHJzY3JhdGNoKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGZvciBlbXB0eSB0ZXh0LCBza2lwIGFsbCBwcm9jZXNzaW5nXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIDsgZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgdmFyIHdyYXBTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlO1xuICBpZiAod3JhcFN0eWxlID09PSAnd3JhcCcpIHtcbiAgICB2YXIgbGFiZWxLZXkgPSByc2NyYXRjaCgnbGFiZWxLZXknKTtcblxuICAgIC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICBpZiAobGFiZWxLZXkgIT0gbnVsbCAmJiByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JykgPT09IGxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnKTtcbiAgICB9XG4gICAgdmFyIHp3c3AgPSBcIlxcdTIwMEJcIjtcbiAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgb3ZlcmZsb3cgPSBlbGUucHN0eWxlKCd0ZXh0LW92ZXJmbG93LXdyYXAnKS52YWx1ZTtcbiAgICB2YXIgb3ZlcmZsb3dBbnkgPSBvdmVyZmxvdyA9PT0gJ2FueXdoZXJlJztcbiAgICB2YXIgd3JhcHBlZExpbmVzID0gW107XG4gICAgdmFyIHNlcGFyYXRvclJlZ2V4ID0gL1tcXHNcXHUyMDBiXSt8JC9nOyAvLyBJbmNsdWRlIGVuZCBvZiBzdHJpbmcgdG8gYWRkIGxhc3Qgd29yZFxuXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsXTtcbiAgICAgIHZhciBsaW5lRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgbGluZSk7XG4gICAgICB2YXIgbGluZVcgPSBsaW5lRGltcy53aWR0aDtcbiAgICAgIGlmIChvdmVyZmxvd0FueSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkTGluZSA9IGxpbmUuc3BsaXQoJycpLmpvaW4oendzcCk7XG4gICAgICAgIGxpbmUgPSBwcm9jZXNzZWRMaW5lO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVXID4gbWF4Vykge1xuICAgICAgICAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgIHZhciBzZXBhcmF0b3JNYXRjaGVzID0gbGluZS5tYXRjaEFsbChzZXBhcmF0b3JSZWdleCk7XG4gICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG4gICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gMDtcbiAgICAgICAgLy8gQWRkIGZha2UgbWF0Y2hcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNlcGFyYXRvck1hdGNoZXMpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yTWF0Y2ggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciB3b3JkU2VwYXJhdG9yID0gc2VwYXJhdG9yTWF0Y2hbMF07XG4gICAgICAgICAgICB2YXIgd29yZCA9IGxpbmUuc3Vic3RyaW5nKHByZXZpb3VzSW5kZXgsIHNlcGFyYXRvck1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5kZXggPSBzZXBhcmF0b3JNYXRjaC5pbmRleCArIHdvcmRTZXBhcmF0b3IubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArIHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXN0TGluZSk7XG4gICAgICAgICAgICB2YXIgdGVzdFcgPSB0ZXN0RGltcy53aWR0aDtcbiAgICAgICAgICAgIGlmICh0ZXN0VyA8PSBtYXhXKSB7XG4gICAgICAgICAgICAgIC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgc3VibGluZSArPSB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHdvcmQgc3RhcnRzIG5ldyBsaW5lXG4gICAgICAgICAgICAgIGlmIChzdWJsaW5lKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goc3VibGluZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWJsaW5lLm1hdGNoKC9eW1xcc1xcdTIwMGJdKyQvKSkge1xuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsaW5lIGlzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG5cbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCB3cmFwcGVkTGluZXMpO1xuICAgIHRleHQgPSByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcsIHdyYXBwZWRMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgcnNjcmF0Y2goJ2xhYmVsV3JhcEtleScsIGxhYmVsS2V5KTtcbiAgfSBlbHNlIGlmICh3cmFwU3R5bGUgPT09ICdlbGxpcHNpcycpIHtcbiAgICB2YXIgX21heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGVsbGlwc2l6ZWQgPSAnJztcbiAgICB2YXIgZWxsaXBzaXMgPSBcIlxcdTIwMjZcIjtcbiAgICB2YXIgaW5jTGFzdENoID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGV4dCkud2lkdGggPCBfbWF4Vykge1xuICAgICAgLy8gdGhlIGxhYmVsIGFscmVhZHkgZml0c1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdpZHRoV2l0aE5leHRDaCA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgZWxsaXBzaXplZCArIHRleHRbaV0gKyBlbGxpcHNpcykud2lkdGg7XG4gICAgICBpZiAod2lkdGhXaXRoTmV4dENoID4gX21heFcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlbGxpcHNpemVkICs9IHRleHRbaV07XG4gICAgICBpZiAoaSA9PT0gdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGluY0xhc3RDaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5jTGFzdENoKSB7XG4gICAgICBlbGxpcHNpemVkICs9IGVsbGlwc2lzO1xuICAgIH1cbiAgICByZXR1cm4gZWxsaXBzaXplZDtcbiAgfSAvLyBpZiBlbGxpcHNpemVcblxuICByZXR1cm4gdGV4dDtcbn07XG5CUnAkOS5nZXRMYWJlbEp1c3RpZmljYXRpb24gPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBqdXN0aWZpY2F0aW9uID0gZWxlLnBzdHlsZSgndGV4dC1qdXN0aWZpY2F0aW9uJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0SGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcbiAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdhdXRvJykge1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBqdXN0aWZpY2F0aW9uO1xuICB9XG59O1xuQlJwJDkuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgdGV4dCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSByLmN5LndpbmRvdygpO1xuICB2YXIgZG9jdW1lbnQgPSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQ7XG4gIHZhciBwYWRkaW5nID0gMDsgLy8gYWRkIHBhZGRpbmcgYXJvdW5kIHRleHQgZGltcywgYXMgdGhlIG1lYXN1cmVtZW50IGlzbid0IHRoYXQgYWNjdXJhdGVcbiAgdmFyIGZTdHlsZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc3R5bGUnKS5zdHJWYWx1ZTtcbiAgdmFyIHNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlO1xuICB2YXIgZmFtaWx5ID0gZWxlLnBzdHlsZSgnZm9udC1mYW1pbHknKS5zdHJWYWx1ZTtcbiAgdmFyIHdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gIHZhciBjYW52YXMgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhcztcbiAgdmFyIGMyZCA9IHRoaXMubGFiZWxDYWxjQ2FudmFzQ29udGV4dDtcbiAgaWYgKCFjYW52YXMpIHtcbiAgICBjYW52YXMgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGMyZCA9IHRoaXMubGFiZWxDYWxjQ2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkcyA9IGNhbnZhcy5zdHlsZTtcbiAgICBkcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgICBkcy50b3AgPSAnLTk5OTlweCc7XG4gICAgZHMuekluZGV4ID0gJy0xJztcbiAgICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgZHMucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgfVxuICBjMmQuZm9udCA9IFwiXCIuY29uY2F0KGZTdHlsZSwgXCIgXCIpLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZhbWlseSk7XG4gIHZhciB3aWR0aCA9IDA7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIG1ldHJpY3MgPSBjMmQubWVhc3VyZVRleHQobGluZSk7XG4gICAgdmFyIHcgPSBNYXRoLmNlaWwobWV0cmljcy53aWR0aCk7XG4gICAgdmFyIGggPSBzaXplO1xuICAgIHdpZHRoID0gTWF0aC5tYXgodywgd2lkdGgpO1xuICAgIGhlaWdodCArPSBoO1xuICB9XG4gIHdpZHRoICs9IHBhZGRpbmc7XG4gIGhlaWdodCArPSBwYWRkaW5nO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufTtcbkJScCQ5LmNhbGN1bGF0ZUxhYmVsQW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIHByZWZpeERhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciByb3RTdHIgPSByb3Quc3RyVmFsdWU7XG4gIGlmIChyb3RTdHIgPT09ICdub25lJykge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGlzRWRnZSAmJiByb3RTdHIgPT09ICdhdXRvcm90YXRlJykge1xuICAgIHJldHVybiBycy5sYWJlbEF1dG9BbmdsZTtcbiAgfSBlbHNlIGlmIChyb3RTdHIgPT09ICdhdXRvcm90YXRlJykge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByb3QucGZWYWx1ZTtcbiAgfVxufTtcbkJScCQ5LmNhbGN1bGF0ZUxhYmVsQW5nbGVzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHJzLmxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlKTtcbiAgaWYgKGlzRWRnZSkge1xuICAgIHJzLnNvdXJjZUxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlLCAnc291cmNlJyk7XG4gICAgcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICd0YXJnZXQnKTtcbiAgfVxufTtcblxudmFyIEJScCQ4ID0ge307XG52YXIgVE9PX1NNQUxMX0NVVF9SRUNUID0gMjg7XG52YXIgd2FybmVkQ3V0UmVjdCA9IGZhbHNlO1xuQlJwJDguZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS52YWx1ZTtcbiAgaWYgKHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyAmJiAobm9kZS53aWR0aCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUIHx8IG5vZGUuaGVpZ2h0KCkgPCBUT09fU01BTExfQ1VUX1JFQ1QpKSB7XG4gICAgaWYgKCF3YXJuZWRDdXRSZWN0KSB7XG4gICAgICB3YXJuKCdUaGUgYGN1dHJlY3RhbmdsZWAgbm9kZSBzaGFwZSBjYW4gbm90IGJlIHVzZWQgYXQgc21hbGwgc2l6ZXMgc28gYHJlY3RhbmdsZWAgaXMgdXNlZCBpbnN0ZWFkJyk7XG4gICAgICB3YXJuZWRDdXRSZWN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICB9XG4gIGlmIChub2RlLmlzUGFyZW50KCkpIHtcbiAgICBpZiAoc2hhcGUgPT09ICdyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmQtcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXQtcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2JhcnJlbCcpIHtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgfVxuICBpZiAoc2hhcGUgPT09ICdwb2x5Z29uJykge1xuICAgIHZhciBwb2ludHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS52YWx1ZTtcbiAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKHBvaW50cykubmFtZTtcbiAgfVxuICByZXR1cm4gc2hhcGU7XG59O1xuXG52YXIgQlJwJDcgPSB7fTtcbkJScCQ3LnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuY3k7XG4gIHZhciBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGVsZXMpIHtcbiAgICB2YXIgZGlydHlTdHlsZUNhY2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBlbGVzVG9VcGRhdGUubWVyZ2UoZWxlcyk7XG4gICAgaWYgKGRpcnR5U3R5bGVDYWNoZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgcnN0eWxlLmNsZWFuQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByLmJpbmRlcihjeSkub24oJ2JvdW5kcy4qIGRpcnR5LionLCBmdW5jdGlvbiBvbkRpcnR5Qm91bmRzKGUpIHtcbiAgICB2YXIgZWxlID0gZS50YXJnZXQ7XG4gICAgZW5xdWV1ZShlbGUpO1xuICB9KS5vbignc3R5bGUuKiBiYWNrZ3JvdW5kLionLCBmdW5jdGlvbiBvbkRpcnR5U3R5bGUoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICBlbnF1ZXVlKGVsZSwgZmFsc2UpO1xuICB9KTtcbiAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gdXBkYXRlRWxlQ2FsY3Mod2lsbERyYXcpIHtcbiAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgIHZhciBmbnMgPSByLm9uVXBkYXRlRWxlQ2FsY3NGbnM7XG5cbiAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBoYXZlIHVwLXRvLWRhdGUgc3R5bGUgKGUuZy4gc3R5bGVzaGVldCBtYXBwZXJzKVxuICAgICAgLy8gYmVmb3JlIGNhbGN1bGF0aW5nIHJlbmRlcmVkIHN0eWxlIChhbmQgcHN0eWxlIG1pZ2h0IG5vdCBiZSBjYWxsZWQgeWV0KVxuICAgICAgZWxlc1RvVXBkYXRlLmNsZWFuU3R5bGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzVG9VcGRhdGVbaV07XG4gICAgICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpICYmICFyc3R5bGUuY2xlYW5Db25uZWN0ZWQpIHtcbiAgICAgICAgICBlbnF1ZXVlKGVsZS5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm5zKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGZuID0gZm5zW19pXTtcbiAgICAgICAgICBmbih3aWxsRHJhdywgZWxlc1RvVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWxlc1RvVXBkYXRlKTtcbiAgICAgIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG4gIHIuZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlRWxlQ2FsY3ModHJ1ZSk7XG4gIH07XG4gIHIuYmVmb3JlUmVuZGVyKHVwZGF0ZUVsZUNhbGNzLCByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlQ2FsY3MpO1xufTtcbkJScCQ3Lm9uVXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyB8fCBbXTtcbiAgZm5zLnB1c2goZm4pO1xufTtcbkJScCQ3LnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGVzLCB1c2VDYWNoZSkge1xuICB2YXIgaXNDbGVhbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIGlzQ2xlYW5Db25uZWN0ZWQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5yc3R5bGUuY2xlYW5Db25uZWN0ZWQ7XG4gIH07XG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIG5vZGVzID0gW107XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIHVzZWQgZm9yIGNhbGNzIHdoZW4gZGVzdHJveWVkLCBlLmcuIGVsZS5ib3VuZGluZ0JveCgpXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVzZSBjYWNoZSBieSBkZWZhdWx0IGZvciBwZXJmXG4gIGlmICh1c2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdXNlQ2FjaGUgPSB0cnVlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gICAgLy8gYW4gZWRnZSBtYXkgYmUgaW1wbGljaXRseSBkaXJ0eSBiL2Mgb2Ygb25lIG9mIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAvLyAoYW5kIGEgcmVxdWVzdCBmb3IgcmVjYWxjIG1heSBjb21lIGluIGJldHdlZW4gZnJhbWVzKVxuICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgKCFpc0NsZWFuQ29ubmVjdGVkKGVsZS5zb3VyY2UoKSkgfHwgIWlzQ2xlYW5Db25uZWN0ZWQoZWxlLnRhcmdldCgpKSkpIHtcbiAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZWxlLmlzRWRnZSgpICYmIGVsZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgaWYgKGVsZS5wYXJhbGxlbEVkZ2VzKCkuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiAhZWxlLl9wcml2YXRlLnJzdHlsZS5jbGVhbiAmJiBlbGUuaXNCdW5kbGVkQmV6aWVyKCk7XG4gICAgICB9KSkge1xuICAgICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmx5IHVwZGF0ZSBpZiBkaXJ0eSBhbmQgaW4gZ3JhcGhcbiAgICBpZiAodXNlQ2FjaGUgJiYgcnN0eWxlLmNsZWFuIHx8IGVsZS5yZW1vdmVkKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIG9ubHkgdXBkYXRlIGlmIG5vdCBkaXNwbGF5OiBub25lXG4gICAgaWYgKGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKF9wLmdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVkZ2VzXG4gICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgfVxuICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gIH1cblxuICAvLyB1cGRhdGUgbm9kZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfZWxlID0gbm9kZXNbX2kyXTtcbiAgICB2YXIgX3AyID0gX2VsZS5fcHJpdmF0ZTtcbiAgICB2YXIgX3JzdHlsZSA9IF9wMi5yc3R5bGU7XG4gICAgdmFyIHBvcyA9IF9lbGUucG9zaXRpb24oKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbihfZWxlKTtcbiAgICBfcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgX3JzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIF9yc3R5bGUubm9kZVcgPSBfZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIF9yc3R5bGUubm9kZUggPSBfZWxlLnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZTtcbiAgfVxuICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKGVkZ2VzKTtcblxuICAvLyB1cGRhdGUgZWRnZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBfZWxlMiA9IGVkZ2VzW19pM107XG4gICAgdmFyIF9wMyA9IF9lbGUyLl9wcml2YXRlO1xuICAgIHZhciBfcnN0eWxlMiA9IF9wMy5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AzLnJzY3JhdGNoO1xuXG4gICAgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcbiAgICBfcnN0eWxlMi5zcmNYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgX3JzdHlsZTIuc3JjWSA9IHJzLmFycm93U3RhcnRZO1xuICAgIF9yc3R5bGUyLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgX3JzdHlsZTIudGd0WSA9IHJzLmFycm93RW5kWTtcbiAgICBfcnN0eWxlMi5taWRYID0gcnMubWlkWDtcbiAgICBfcnN0eWxlMi5taWRZID0gcnMubWlkWTtcbiAgICBfcnN0eWxlMi5sYWJlbEFuZ2xlID0gcnMubGFiZWxBbmdsZTtcbiAgICBfcnN0eWxlMi5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZTtcbiAgICBfcnN0eWxlMi50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxudmFyIEJScCQ2ID0ge307XG5CUnAkNi51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICBpZiAoIWVsZXMpIHtcbiAgICAvLyBqdXN0IGxldCB0aGlzIGJlIHJlY2FsY3VsYXRlZCBvbiB0aGUgbmV4dCB6IHNvcnQgdGlja1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVzLmRyYWcgPSBbXTtcbiAgZWxlcy5ub25kcmFnID0gW107XG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgaWYgKGVsZS5ncmFiYmVkKCkgJiYgIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICBncmFiVGFyZ2V0cy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIGlmIChycy5pbkRyYWdMYXllcikge1xuICAgICAgZWxlcy5kcmFnLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5ub25kcmFnLnB1c2goZWxlKTtcbiAgICB9XG4gIH1cblxuICAvLyBwdXQgdGhlIGdyYWIgdGFyZ2V0IG5vZGVzIGxhc3Qgc28gaXQncyBvbiB0b3Agb2YgaXRzIG5laWdoYm91cmhvb2RcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFiVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBncmFiVGFyZ2V0c1tpXTtcbiAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICB9XG59O1xuQlJwJDYuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gbnVsbDtcbn07XG5CUnAkNi5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uIChmb3JjZVJlY2FsYykge1xuICBpZiAoZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuY3kubXV0YWJsZUVsZW1lbnRzKCkudG9BcnJheSgpO1xuICAgIGVsZXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgICBlbGVzLmludGVyYWN0aXZlID0gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pbnRlcmFjdGl2ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuICAgIHRoaXMudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgfVxuICByZXR1cm4gZWxlcztcbn07XG5cbnZhciBCUnAkNSA9IHt9O1xuW0JScCRlLCBCUnAkZCwgQlJwJGMsIEJScCRiLCBCUnAkYSwgQlJwJDksIEJScCQ4LCBCUnAkNywgQlJwJDZdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkNSwgcHJvcHMpO1xufSk7XG5cbnZhciBCUnAkNCA9IHt9O1xuQlJwJDQuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbiAodXJsLCBjcm9zc09yaWdpbiwgb25Mb2FkKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgfHwge307XG4gIHZhciBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXTtcbiAgaWYgKGNhY2hlKSB7XG4gICAgaWYgKCFjYWNoZS5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vICMxNTgyIHNhZmFyaSBkb2Vzbid0IGxvYWQgZGF0YSB1cmlzIHdpdGggY3Jvc3NPcmlnaW4gcHJvcGVybHlcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzOTc4XG4gICAgdmFyIGRhdGFVcmlQcmVmaXggPSAnZGF0YTonO1xuICAgIHZhciBpc0RhdGFVcmkgPSB1cmwuc3Vic3RyaW5nKDAsIGRhdGFVcmlQcmVmaXgubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBkYXRhVXJpUHJlZml4O1xuICAgIGlmICghaXNEYXRhVXJpKSB7XG4gICAgICAvLyBpZiBjcm9zc29yaWdpbiBpcyAnbnVsbCcoc3RyaW5naWZpZWQpLCB0aGVuIG1hbnVhbGx5IHNldCBpdCB0byBudWxsIFxuICAgICAgY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbiA9PT0gJ251bGwnID8gbnVsbCA6IGNyb3NzT3JpZ2luO1xuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjsgLy8gcHJldmVudCB0YWludGVkIGNhbnZhc1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgcmV0dXJuIGltYWdlO1xuICB9XG59O1xuXG52YXIgQlJwJDMgPSB7fTtcblxuLyogZ2xvYmFsIGRvY3VtZW50LCBSZXNpemVPYnNlcnZlciwgTXV0YXRpb25PYnNlcnZlciAqL1xuXG5CUnAkMy5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKTsgLy8gY29weVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ID0gdGFyZ2V0W2ldO1xuICAgICAgaWYgKHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuYmluZGVyKHQpO1xuICAgICAgICByZXMucHVzaChiLm9uLmFwcGx5KGIsIGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB2YXIgYiA9IHRoaXMuYmluZGVyKHRhcmdldCk7XG4gIHJldHVybiBiLm9uLmFwcGx5KGIsIGFyZ3MpO1xufTtcbkJScCQzLmJpbmRlciA9IGZ1bmN0aW9uICh0Z3QpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIHRndElzRG9tID0gdGd0ID09PSBjb250YWluZXJXaW5kb3cgfHwgdGd0ID09PSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQgfHwgdGd0ID09PSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQuYm9keSB8fCBkb21FbGVtZW50KHRndCk7XG4gIGlmIChyLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9PSBudWxsKSB7XG4gICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnRhaW5lcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBub3Qgc3VwcG9ydGVkXG4gICAgfVxuICAgIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID0gc3VwcG9ydHNQYXNzaXZlO1xuICB9XG4gIHZhciBvbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICh0Z3RJc0RvbSAmJiByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cykge1xuICAgICAgLy8gcmVwbGFjZSB1c2VDYXB0dXJlIHcvIG9wdHMgb2JqXG4gICAgICBhcmdzWzJdID0ge1xuICAgICAgICBjYXB0dXJlOiB1c2VDYXB0dXJlICE9IG51bGwgPyB1c2VDYXB0dXJlIDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgci5iaW5kaW5ncy5wdXNoKHtcbiAgICAgIHRhcmdldDogdGd0LFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICAgICh0Z3QuYWRkRXZlbnRMaXN0ZW5lciB8fCB0Z3Qub24pLmFwcGx5KHRndCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb246IG9uLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IG9uLFxuICAgIGFkZExpc3RlbmVyOiBvbixcbiAgICBiaW5kOiBvblxuICB9O1xufTtcbkJScCQzLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUuaXNOb2RlKCkgJiYgIW5vZGUubG9ja2VkKCkgJiYgbm9kZS5ncmFiYmFibGUoKTtcbn07XG5CUnAkMy5ub2RlSXNHcmFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdGhpcy5ub2RlSXNEcmFnZ2FibGUobm9kZSkgJiYgbm9kZS5pbnRlcmFjdGl2ZSgpO1xufTtcbkJScCQzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG4gIHZhciBpc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH07XG4gIHZhciBnZXRTaGFkb3dSb290ID0gZnVuY3Rpb24gZ2V0U2hhZG93Um9vdChlbGVtZW50KSB7XG4gICAgdmFyIHJvb3ROb2RlID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICAgIC8vIENoZWNrIGlmIHRoZSByb290IG5vZGUgaXMgYSBzaGFkb3cgcm9vdFxuICAgIGlmIChyb290Tm9kZSAmJiByb290Tm9kZS5ub2RlVHlwZSA9PT0gMTEgJiYgcm9vdE5vZGUuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgfVxuICB9O1xuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uIHRyaWdnZXJFdmVudHModGFyZ2V0LCBuYW1lcywgZSwgcG9zaXRpb24pIHtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHIuY3k7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB0YXJnZXQuZW1pdCh7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgaXNNdWx0U2VsS2V5RG93biA9IGZ1bmN0aW9uIGlzTXVsdFNlbEtleURvd24oZSkge1xuICAgIHJldHVybiBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7IC8vIG1heWJlIGUuYWx0S2V5XG4gIH07XG4gIHZhciBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCA9IGZ1bmN0aW9uIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIGRvd25zKSB7XG4gICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuICAgIGlmIChyLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBkb3duICYmIGRvd24ucGFubmFibGUoKSkge1xuICAgICAgLy8gYSBncmFiYmFibGUgY29tcG91bmQgbm9kZSBiZWxvdyB0aGUgZWxlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgIGZvciAodmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTtcblxuICAgICAgICAvL2lmIGFueSBwYXJlbnQgbm9kZSBpbiBldmVudCBoaWVyYXJjaHkgaXNuJ3QgcGFubmFibGUsIHJlamVjdCBwYXNzdGhyb3VnaFxuICAgICAgICBpZiAoZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkgJiYgIWRvd24ucGFubmFibGUoKSkge1xuICAgICAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gIH07XG4gIHZhciBzZXRHcmFiYmVkID0gZnVuY3Rpb24gc2V0R3JhYmJlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gIH07XG4gIHZhciBzZXRGcmVlZCA9IGZ1bmN0aW9uIHNldEZyZWVkKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gIH07XG4gIHZhciBzZXRJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHNldEluRHJhZ0xheWVyKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gIH07XG4gIHZhciBzZXRPdXREcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRPdXREcmFnTGF5ZXIoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gIH07XG4gIHZhciBzZXRHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gc2V0R3JhYlRhcmdldChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gdHJ1ZTtcbiAgfTtcbiAgdmFyIHJlbW92ZUdyYWJUYXJnZXQgPSBmdW5jdGlvbiByZW1vdmVHcmFiVGFyZ2V0KGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSBmYWxzZTtcbiAgfTtcbiAgdmFyIGFkZFRvRHJhZ0xpc3QgPSBmdW5jdGlvbiBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cykge1xuICAgIHZhciBsaXN0ID0gb3B0cy5hZGRUb0xpc3Q7XG4gICAgdmFyIGxpc3RIYXNFbGUgPSBsaXN0LmhhcyhlbGUpO1xuICAgIGlmICghbGlzdEhhc0VsZSAmJiBlbGUuZ3JhYmJhYmxlKCkgJiYgIWVsZS5sb2NrZWQoKSkge1xuICAgICAgbGlzdC5tZXJnZShlbGUpO1xuICAgICAgc2V0R3JhYmJlZChlbGUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNoaWxkIG5vZGVzIGFuZCBpbm5lciBlZGdlc1xuICAvLyBvZiBhIGNvbXBvdW5kIG5vZGUgdG8gYmUgZHJhZ2dlZCBhcyB3ZWxsIGFzIHRoZSBncmFiYmVkIGFuZCBzZWxlY3RlZCBub2Rlc1xuICB2YXIgYWRkRGVzY2VuZGFudHNUb0RyYWcgPSBmdW5jdGlvbiBhZGREZXNjZW5kYW50c1RvRHJhZyhub2RlLCBvcHRzKSB7XG4gICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG4gICAgdmFyIGlubmVyTm9kZXMgPSBub2RlLmRlc2NlbmRhbnRzKCk7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBpbm5lck5vZGVzLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgYWRkVG9EcmFnTGlzdChpbm5lck5vZGVzLCBvcHRzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMgYW5kIGl0cyBuZWlnaGJvdXJob29kIHRvIHRoZSBkcmFnIGxheWVyXG4gIHZhciBhZGROb2Rlc1RvRHJhZyA9IGZ1bmN0aW9uIGFkZE5vZGVzVG9EcmFnKG5vZGVzLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBub2Rlcy5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBub2Rlcy5uZWlnaGJvcmhvb2QoKS5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgZWxlLmlzRWRnZSgpO1xuICAgICAgfSkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhZGREZXNjZW5kYW50c1RvRHJhZyhub2Rlcywgb3B0cyk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuXG4gICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcbiAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2Rlcywge1xuICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICB9KTtcbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07XG4gIHZhciBhZGROb2RlVG9EcmFnID0gYWRkTm9kZXNUb0RyYWc7XG4gIHZhciBmcmVlRHJhZ2dlZEVsZW1lbnRzID0gZnVuY3Rpb24gZnJlZURyYWdnZWRFbGVtZW50cyhncmFiYmVkRWxlcykge1xuICAgIGlmICghZ3JhYmJlZEVsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBqdXN0IGdvIG92ZXIgYWxsIGVsZW1lbnRzIHJhdGhlciB0aGFuIGRvaW5nIGEgYnVuY2ggb2YgKHBvc3NpYmx5IGV4cGVuc2l2ZSkgdHJhdmVyc2Fsc1xuICAgIHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHNldEZyZWVkKGVsZSk7XG4gICAgICBzZXRPdXREcmFnTGF5ZXIoZWxlKTtcbiAgICAgIHJlbW92ZUdyYWJUYXJnZXQoZWxlKTtcbiAgICB9KTtcbiAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2RlLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRvcC1sZXZlbCBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5hbmNlc3RvcnMoKS5vcnBoYW5zKCk7XG5cbiAgICAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgaWYgKHBhcmVudC5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpLnNwYXduU2VsZigpLm1lcmdlKHBhcmVudCkudW5tZXJnZShub2RlKS51bm1lcmdlKG5vZGUuZGVzY2VuZGFudHMoKSk7XG4gICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgZWRnZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBub2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgYmx1ckFjdGl2ZURvbUVsZW1lbnQgPSBmdW5jdGlvbiBibHVyQWN0aXZlRG9tRWxlbWVudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciAhPSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYXZlTXV0YXRpb25zQXBpID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgaGF2ZVJlc2l6ZU9ic2VydmVyQXBpID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcblxuICAvLyB3YXRjaCBmb3Igd2hlbiB0aGUgY3kgY29udGFpbmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG4gIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgci5yZW1vdmVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRucykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbXV0biA9IG11dG5zW2ldO1xuICAgICAgICB2YXIgck5vZGVzID0gbXV0bi5yZW1vdmVkTm9kZXM7XG4gICAgICAgIGlmIChyTm9kZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKHJOb2RlID09PSByLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHIuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTm9kZVJlbW92ZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgci5kZXN0cm95KCk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIG9uUmVzaXplID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHIuY3kucmVzaXplKCk7XG4gIH0sIDEwMCk7XG4gIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgci5zdHlsZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLnN0eWxlT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lciwge1xuICAgICAgYXR0cmlidXRlczogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYXV0byByZXNpemVcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAncmVzaXplJywgb25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgaWYgKGhhdmVSZXNpemVPYnNlcnZlckFwaSkge1xuICAgIHIucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIpO1xuICB9XG4gIHZhciBmb3JFYWNoVXAgPSBmdW5jdGlvbiBmb3JFYWNoVXAoZG9tRWxlLCBmbikge1xuICAgIHdoaWxlIChkb21FbGUgIT0gbnVsbCkge1xuICAgICAgZm4oZG9tRWxlKTtcbiAgICAgIGRvbUVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfTtcbiAgdmFyIGludmFsaWRhdGVDb29yZHMgPSBmdW5jdGlvbiBpbnZhbGlkYXRlQ29vcmRzKCkge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gIH07XG4gIGZvckVhY2hVcChyLmNvbnRhaW5lciwgZnVuY3Rpb24gKGRvbUVsZSkge1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3RyYW5zaXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdhbmltYXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdzY3JvbGwnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgfSk7XG5cbiAgLy8gc3RvcCByaWdodCBjbGljayBtZW51IGZyb20gYXBwZWFyaW5nIG9uIGN5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGluQm94U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcbiAgdmFyIGV2ZW50SW5Db250YWluZXIgPSBmdW5jdGlvbiBldmVudEluQ29udGFpbmVyKGUpIHtcbiAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgeCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMF07XG4gICAgdmFyIHkgPSBjb250YWluZXJQYWdlQ29vcmRzWzFdO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMl07XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbM107XG4gICAgdmFyIHBvc2l0aW9ucyA9IGUudG91Y2hlcyA/IGUudG91Y2hlcyA6IFtlXTtcbiAgICB2YXIgYXRMZWFzdE9uZVBvc0luc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhdExlYXN0T25lUG9zSW5zaWRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb250YWluZXIgPSByLmNvbnRhaW5lcjtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcbiAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKCFjb250YWluZXJJc1RhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGFyZ2V0IGlzIG91dGlzZGUgY3kgY29udGFpbmVyLCB0aGVuIHRoaXMgZXZlbnQgaXMgbm90IGZvciB1c1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUHJpbWFyeSBrZXlcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZWRvd24nLCBmdW5jdGlvbiBtb3VzZWRvd25IYW5kbGVyKGUpIHtcbiAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBkdXJpbmcgbGVmdCBtb3VzZSBidXR0b24gZ2VzdHVyZXMsIGlnbm9yZSBvdGhlciBidXR0b25zXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxICYmIGUud2hpY2ggIT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gZ3BvcztcbiAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGNoZWNrRm9yVGFwaG9sZCA9IGZ1bmN0aW9uIGNoZWNrRm9yVGFwaG9sZCgpIHtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgIGNsZWFyVGltZW91dChyLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCk7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZWxlID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUuZW1pdChtYWtlRXZlbnQoJ3RhcGhvbGQnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCd0YXBob2xkJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgIH07XG5cbiAgICAvLyBSaWdodCBjbGljayBidXR0b25cbiAgICBpZiAoZS53aGljaCA9PSAzKSB7XG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICBuZWFyLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG4gICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBQcmltYXJ5IGJ1dHRvblxuICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAxKSB7XG4gICAgICBpZiAobmVhcikge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVsZW1lbnQgZHJhZ2dpbmdcbiAgICAgIHtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHVuZGVyIHRoZSBjdXJzb3IgYW5kIGl0IGlzIGRyYWdnYWJsZSwgcHJlcGFyZSB0byBncmFiIGl0XG4gICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyR3JhYiA9IGZ1bmN0aW9uIHRyaWdnZXJHcmFiKGVsZSkge1xuICAgICAgICAgICAgICBlbGUuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcbiAgICAgICAgICAgIGlmICghbmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcobmVhciwge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSkuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoZWxlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKHNlbGVjdGVkTm9kZXMsIHtcbiAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpO1xuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2godHJpZ2dlckdyYWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25zID0gbmVhcnM7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vkb3duJywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG4gICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IGVsc2UgaWYgKG5lYXIucGFubmFibGUoKSkge1xuICAgICAgICBzZWxlY3RbNF0gPSAxOyAvLyBmb3IgZnV0dXJlIHBhblxuICAgICAgfVxuICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG4gICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFsxXSA9IHNlbGVjdFszXSA9IHBvc1sxXTtcbiAgfSwgZmFsc2UpO1xuICB2YXIgc2hhZG93Um9vdCA9IGdldFNoYWRvd1Jvb3Qoci5jb250YWluZXIpO1xuICByLnJlZ2lzdGVyQmluZGluZyhbY29udGFpbmVyV2luZG93LCBzaGFkb3dSb290XSwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIG1vdXNlbW92ZUhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG4gICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSBudWxsO1xuICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICB2YXIgZGlzcCA9IFtwb3NbMF0gLSBzZWxlY3RbMl0sIHBvc1sxXSAtIHNlbGVjdFszXV07XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG4gICAgaWYgKG1kb3duR1Bvcykge1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cbiAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG4gICAgICBpZiAoZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICB9XG4gICAgfTtcbiAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnXSwgZSwge1xuICAgICAgeDogcG9zWzBdLFxuICAgICAgeTogcG9zWzFdXG4gICAgfSk7XG4gICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBnb0ludG9Cb3hNb2RlID0gZnVuY3Rpb24gZ29JbnRvQm94TW9kZSgpIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICghci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdib3hzdGFydCcpKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfTtcblxuICAgIC8vIHRyaWdnZXIgY29udGV4dCBkcmFnIGlmIHJtb3VzZSBkb3duXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG1ha2VFdmVudCgnY3h0ZHJhZycpO1xuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgIGRvd24uZW1pdChjeHRFdnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci5lbWl0KG1ha2VFdmVudCgnY3h0ZHJhZ291dCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2N4dGRyYWdvdmVyJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICB2YXIgZGVsdGFQO1xuICAgICAgICBpZiAoci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4pIHtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiAocG9zWzBdIC0gbWRQb3NbMF0pICogem9vbSxcbiAgICAgICAgICAgIHk6IChwb3NbMV0gLSBtZFBvc1sxXSkgKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGN5LnBhbkJ5KGRlbHRhUCk7XG4gICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdkcmFncGFuJykpO1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcbiAgICAgIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIC8vIENoZWNrcyBwcmltYXJ5IGJ1dHRvbiBkb3duICYgb3V0IG9mIHRpbWUgJiBtb3VzZSBub3QgbW92ZWQgbXVjaFxuICAgIH0gZWxzZSBpZiAoc2VsZWN0WzRdID09IDEgJiYgKGRvd24gPT0gbnVsbCB8fCBkb3duLnBhbm5hYmxlKCkpKSB7XG4gICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAobXVsdFNlbEtleURvd24gfHwgIWN5LnBhbm5pbmdFbmFibGVkKCkgfHwgIWN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSkge1xuICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICghci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKGRvd24sIHIuaG92ZXJEYXRhLmRvd25zKTtcbiAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KG1kb3duUG9zKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG93biAmJiBkb3duLnBhbm5hYmxlKCkgJiYgZG93bi5hY3RpdmUoKSkge1xuICAgICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCghZG93biB8fCAhZG93bi5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMobGFzdCwgWydtb3VzZW91dCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlb3ZlcicsICd0YXBkcmFnb3ZlciddLCBlLCB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cbiAgICAgIGlmIChkb3duKSB7XG4gICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gdGFrZSBhY3Rpb25cblxuICAgICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0aW9uIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkpIHtcbiAgICAgICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuICAgICAgICAgICAgICBkb3duLmVtaXQobWFrZUV2ZW50KCdmcmVlb24nKSk7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KG1ha2VFdmVudCgnZnJlZScpKTtcbiAgICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICAgIGRvd24uZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlb24nKSk7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkb3duKSkge1xuICAgICAgICAgICAgLy8gZHJhZyBub2RlXG4gICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG5cbiAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcykge1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhkcmFnZ2VkRWxlbWVudHMsIHtcbiAgICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG51bWJlciQxKGRpc3BbMF0pICYmIG51bWJlciQxKGRpc3BbMV0pKSB7XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMF0pICYmIG51bWJlciQxKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5zaWxlbnRTaGlmdCh0b3RhbFNoaWZ0KS5lbWl0KG1ha2VFdmVudCgncG9zaXRpb24nKSkuZW1pdChtYWtlRXZlbnQoJ2RyYWcnKSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfVxuICAgIHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbM10gPSBwb3NbMV07XG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICB2YXIgY2xpY2tUaW1lb3V0LCBkaWREb3VibGVDbGljaywgcHJldkNsaWNrVGltZVN0YW1wO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24gbW91c2V1cEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAvLyBkdXJpbmcgbGVmdCBtb3VzZSBidXR0b24gZ2VzdHVyZXMsIGlnbm9yZSBvdGhlciBidXR0b25zXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxICYmIGUud2hpY2ggIT09IDEgJiYgci5ob3ZlckRhdGEuY2FwdHVyZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG4gICAgaWYgKCFjYXB0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG4gICAgaWYgKHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgIGlmIChkb3duKSB7XG4gICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMykge1xuICAgICAgdmFyIGN4dEV2dCA9IG1ha2VFdmVudCgnY3h0dGFwZW5kJyk7XG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cbiAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3h0VGFwID0gbWFrZUV2ZW50KCdjeHR0YXAnKTtcbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBkb3duLmVtaXQoY3h0VGFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dFRhcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAxKSB7XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG4gICAgICBpZiAoIXIuZHJhZ0RhdGEuZGlkRHJhZyAmJlxuICAgICAgLy8gZGlkbid0IG1vdmUgYSBub2RlIGFyb3VuZFxuICAgICAgIXIuaG92ZXJEYXRhLmRyYWdnZWQgJiZcbiAgICAgIC8vIGRpZG4ndCBwYW5cbiAgICAgICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiZcbiAgICAgIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAhci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuICAgICAgKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiY2xpY2tcIiwgXCJ0YXBcIiwgXCJ2Y2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH0pO1xuICAgICAgICBkaWREb3VibGVDbGljayA9IGZhbHNlO1xuICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2Q2xpY2tUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgY2xpY2tUaW1lb3V0ICYmIGNsZWFyVGltZW91dChjbGlja1RpbWVvdXQpO1xuICAgICAgICAgIGRpZERvdWJsZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2Q2xpY2tUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiZGJsY2xpY2tcIiwgXCJkYmx0YXBcIiwgXCJ2ZGJsY2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRpZERvdWJsZUNsaWNrKSByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcIm9uZWNsaWNrXCIsIFwib25ldGFwXCIsIFwidm9uZWNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpO1xuICAgICAgICAgIHByZXZDbGlja1RpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG4gICAgICBpZiAoZG93biA9PSBudWxsIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICYmICFpc011bHRTZWxLZXlEb3duKGUpKSB7XG4gICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luZ2xlIHNlbGVjdGlvblxuICAgICAgaWYgKG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIDsgZWxzZSBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IG11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShuZWFyKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgaWYgKGJveC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2JveGVuZCcpKTtcbiAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScpIHtcbiAgICAgICAgICBib3guZW1pdChtYWtlRXZlbnQoJ2JveCcpKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KG1ha2VFdmVudCgnYm94c2VsZWN0JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShib3gpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJveC5lbWl0KG1ha2VFdmVudCgnYm94JykpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQobWFrZUV2ZW50KCdib3hzZWxlY3QnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgZHJhZyBwYW5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZWN0WzRdKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgdmFyIGRvd25XYXNHcmFiYmVkID0gZG93biAmJiBkb3duLmdyYWJiZWQoKTtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuICAgICAgICBpZiAoZG93bldhc0dyYWJiZWQpIHtcbiAgICAgICAgICBkb3duLmVtaXQobWFrZUV2ZW50KCdmcmVlb24nKSk7XG4gICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQobWFrZUV2ZW50KCdmcmVlJykpO1xuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIGRvd24uZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlb24nKSk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgci5ob3ZlckRhdGEuZG93biA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgPSBmYWxzZTtcbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBudWxsO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuICB9LCBmYWxzZSk7XG4gIHZhciB3aGVlbERlbHRhcyA9IFtdOyAvLyBsb2cgb2YgZmlyc3QgTiB3aGVlbCBkZWx0YXNcbiAgdmFyIHdoZWVsRGVsdGFOID0gNDsgLy8gaG93IG1hbnkgZXZlbnRzIHRvIGxvZ1xuICB2YXIgaW5hY2N1cmF0ZVNjcm9sbERldmljZTtcbiAgdmFyIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IgPSAxMDAwMDA7IC8vIGJhc2Ugb2YgaW5hY2N1cmF0ZSB3aGVlbCBkZWx0YXMgKGUuZy4gYmFzZSA1IGNvdWxkIHlpZWxkIHdoZWVscyBvZiAxMCwgMjUsIDUwLCBldGMuKVxuXG4gIHZhciBhbGxBcmVEaXZpc2libGVCeSA9IGZ1bmN0aW9uIGFsbEFyZURpdmlzaWJsZUJ5KGxpc3QsIGZhY3Rvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0gJSBmYWN0b3IgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIGFsbEFyZVNhbWVNYWduaXR1ZGUgPSBmdW5jdGlvbiBhbGxBcmVTYW1lTWFnbml0dWRlKGxpc3QpIHtcbiAgICB2YXIgZmlyc3RNYWcgPSBNYXRoLmFicyhsaXN0WzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChNYXRoLmFicyhsaXN0W2ldKSAhPT0gZmlyc3RNYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uIHdoZWVsSGFuZGxlcihlKSB7XG4gICAgdmFyIGNsYW1wID0gZmFsc2U7XG4gICAgdmFyIGRlbHRhID0gZS5kZWx0YVk7XG4gICAgaWYgKGRlbHRhID09IG51bGwpIHtcbiAgICAgIC8vIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgYnJvd3NlcnNcbiAgICAgIGlmIChlLndoZWVsRGVsdGFZICE9IG51bGwpIHtcbiAgICAgICAgZGVsdGEgPSBlLndoZWVsRGVsdGFZIC8gNDtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGVlbERlbHRhICE9IG51bGwpIHtcbiAgICAgICAgZGVsdGEgPSBlLndoZWVsRGVsdGEgLyA0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gbm8gY2hhbmdlIGluIHpvb20gKEJ1ZzogWm9vbSBiZWNvbWVzIGVycmF0aWMgb24gcmFwaWQgc2Nyb2xsIGR1ZSB0byBkZWx0YVk6IDAgZXZlbnQgIzMzOTQpXG4gICAgfVxuICAgIGlmIChpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlID09IG51bGwpIHtcbiAgICAgIGlmICh3aGVlbERlbHRhcy5sZW5ndGggPj0gd2hlZWxEZWx0YU4pIHtcbiAgICAgICAgLy8gdXNlIGxvZyB0byBkZXRlcm1pbmUgaWYgaW5hY2N1cmF0ZVxuICAgICAgICB2YXIgd2RzID0gd2hlZWxEZWx0YXM7XG4gICAgICAgIGluYWNjdXJhdGVTY3JvbGxEZXZpY2UgPSBhbGxBcmVEaXZpc2libGVCeSh3ZHMsIDUpO1xuICAgICAgICBpZiAoIWluYWNjdXJhdGVTY3JvbGxEZXZpY2UpIHtcbiAgICAgICAgICAvLyBjaGVjayBmb3IgYWxsIGxhcmdlIHZhbHVlcyBvZiBleGFjdCBzYW1lIG1hZ25pdHVkZVxuICAgICAgICAgIHZhciBmaXJzdE1hZyA9IE1hdGguYWJzKHdkc1swXSk7XG4gICAgICAgICAgaW5hY2N1cmF0ZVNjcm9sbERldmljZSA9IGFsbEFyZVNhbWVNYWduaXR1ZGUod2RzKSAmJiBmaXJzdE1hZyA+IDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluYWNjdXJhdGVTY3JvbGxEZXZpY2UpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5hY2N1cmF0ZVNjcm9sbEZhY3RvciA9IE1hdGgubWluKE1hdGguYWJzKHdkc1tpXSksIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdTYW1wbGVkIHdoZWVsIGRlbHRhczonLCB3ZHMpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW5hY2N1cmF0ZVNjcm9sbERldmljZTonLCBpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2luYWNjdXJhdGVTY3JvbGxGYWN0b3I6JywgaW5hY2N1cmF0ZVNjcm9sbEZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjbGFtcCBhbmQgbG9nIHVudGlsIHdlIHJlYWNoIE5cbiAgICAgICAgd2hlZWxEZWx0YXMucHVzaChkZWx0YSk7XG4gICAgICAgIGNsYW1wID0gdHJ1ZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NsYW1waW5nIGluaXRpYWwgd2hlZWwgZXZlbnRzIHVudGlsIHdlIGdldCBhIGdvb2Qgc2FtcGxlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlKSB7XG4gICAgICAvLyBrZWVwIHVwZGF0aW5nXG4gICAgICBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yID0gTWF0aC5taW4oTWF0aC5hYnMoZGVsdGEpLCBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdLZWVwIHVwZGF0aW5nIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IgYmV5b25kIHNhbXBsZSBpbiBjYXNlIHdlIGRpZCBub3QgZ2V0IHRoZSBzbWFsbGVzdCBwb3NzaWJsZSB2YWw6JywgaW5hY2N1cmF0ZVNjcm9sbEZhY3Rvcik7XG4gICAgfVxuICAgIGlmIChyLnNjcm9sbGluZ1BhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBycG9zID0gW3Bvc1swXSAqIHpvb20gKyBwYW4ueCwgcG9zWzFdICogem9vbSArIHBhbi55XTtcbiAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgfHwgaW5Cb3hTZWxlY3Rpb24oKSkge1xuICAgICAgLy8gaWYgcGFuIGRyYWdnaW5nIG9yIGN4dCBkcmFnZ2luZywgd2hlZWwgbW92ZW1lbnRzIG1ha2Ugbm8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChyLmRhdGEud2hlZWxUaW1lb3V0KTtcbiAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgICB2YXIgZGlmZjtcbiAgICAgIGlmIChjbGFtcCAmJiBNYXRoLmFicyhkZWx0YSkgPiA1KSB7XG4gICAgICAgIGRlbHRhID0gc2lnbnVtKGRlbHRhKSAqIDU7XG4gICAgICB9XG4gICAgICBkaWZmID0gZGVsdGEgLyAtMjUwO1xuICAgICAgaWYgKGluYWNjdXJhdGVTY3JvbGxEZXZpY2UpIHtcbiAgICAgICAgZGlmZiAvPSBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yO1xuICAgICAgICBkaWZmICo9IDM7XG4gICAgICB9XG4gICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcblxuICAgICAgLy8gY29uc29sZS5sb2coYGRlbHRhID0gJHtkZWx0YX0sIGRpZmYgPSAke2RpZmZ9LCBtb2RlID0gJHtlLmRlbHRhTW9kZX1gKVxuXG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuICAgICAgaWYgKG5lZWRzV2hlZWxGaXgpIHtcbiAgICAgICAgLy8gZml4ZXMgc2xvdyB3aGVlbCBldmVudHMgb24gZmYvbGludXggYW5kIGZmL3dpbmRvd3NcbiAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdab29tID0gY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpO1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnKSB7XG4gICAgICAgIG5ld1pvb20gPSByLmdlc3R1cmVTdGFydFpvb20gKiBlLnNjYWxlO1xuICAgICAgfVxuICAgICAgY3kuem9vbSh7XG4gICAgICAgIGxldmVsOiBuZXdab29tLFxuICAgICAgICByZW5kZXJlZFBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcnBvc1swXSxcbiAgICAgICAgICB5OiBycG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3kuZW1pdCh7XG4gICAgICAgIHR5cGU6IGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnID8gJ3BpbmNoem9vbScgOiAnc2Nyb2xsem9vbScsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgLy8gLS1cbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG5cbiAgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcbiAgICBjbGVhclRpbWVvdXQoci5zY3JvbGxpbmdQYWdlVGltZW91dCk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gZGVza3RvcCBzYWZhcmkgcGluY2ggdG8gem9vbSBzdGFydFxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2dlc3R1cmVzdGFydCcsIGZ1bmN0aW9uIGdlc3R1cmVTdGFydEhhbmRsZXIoZSkge1xuICAgIHIuZ2VzdHVyZVN0YXJ0Wm9vbSA9IHIuY3kuem9vbSgpO1xuICAgIGlmICghci5oYXNUb3VjaFN0YXJ0ZWQpIHtcbiAgICAgIC8vIGRvbid0IGFmZmVjdCB0b3VjaCBkZXZpY2VzIGxpa2UgaXBob25lXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdnZXN0dXJlY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIXIuaGFzVG91Y2hTdGFydGVkKSB7XG4gICAgICAvLyBkb24ndCBhZmZlY3QgdG91Y2ggZGV2aWNlcyBsaWtlIGlwaG9uZVxuICAgICAgd2hlZWxIYW5kbGVyKGUpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHIuY3kuZW1pdCh7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgdmFyIGRpc3RhbmNlMSwgZGlzdGFuY2UxU3E7IC8vIGluaXRpYWwgZGlzdGFuY2UgYmV0d2VlbiBmaW5nZXIgMSBhbmQgZmluZ2VyIDIgZm9yIHBpbmNoLXRvLXpvb21cbiAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cbiAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9O1xuICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uIGRpc3RhbmNlU3EoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpO1xuICB9O1xuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgIHIuaGFzVG91Y2hTdGFydGVkID0gdHJ1ZTtcbiAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgIH1cbiAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcbiAgICAgIGYxeDEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICBmMXkxID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID0gMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0ICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBjZW50ZXIxID0gWyhmMXgxICsgZjJ4MSkgLyAyLCAoZjF5MSArIGYyeTEpIC8gMl07XG4gICAgICBtb2RlbENlbnRlcjEgPSBbKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLCAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21dO1xuXG4gICAgICAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG4gICAgICBpZiAoZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgbmVhcjEgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1syXSwgbm93WzNdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYgKG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS5lbWl0KG1ha2VFdmVudCgnY3h0dGFwc3RhcnQnKSk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMTtcbiAgICAgICAgfSBlbHNlIGlmIChuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSkge1xuICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkuZW1pdChtYWtlRXZlbnQoJ2N4dHRhcHN0YXJ0JykpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2N4dHRhcHN0YXJ0JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAvLyBpZ25vcmVcblxuICAgICAgLy8gc2FmYXJpIG9uIGlvcyBwYW5zIHRoZSBwYWdlIG90aGVyd2lzZSAobm9ybWFsbHkgeW91IHNob3VsZCBiZSBhYmxlIHRvIHByZXZlbnRkZWZhdWx0IG9uIHRvdWNobW92ZS4uLilcbiAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgIHZhciBuZWFyID0gbmVhcnNbMF07XG4gICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcbiAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gbnVsbDtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cblxuICAgICAgICAgICAgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoZWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgIG4uZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWyd0b3VjaHN0YXJ0JywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgIHk6IG5vd1sxXVxuICAgICAgfSk7XG4gICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcCwgdGFwaG9sZFxuICAgICAgLy8gLS0tLS1cblxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgIGNsZWFyVGltZW91dChyLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCk7XG4gICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2UgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgJiYgIXIudG91Y2hEYXRhLnNlbGVjdGluZyAvLyBib3ggc2VsZWN0aW9uIHNob3VsZG4ndCBhbGxvdyB0YXBob2xkIHRocm91Z2hcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhyLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID49IDEpIHtcbiAgICAgIHZhciBzUG9zID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuICAgICAgdmFyIHRvdWNoMCA9IGUudG91Y2hlc1swXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW3RvdWNoMC5jbGllbnRYLCB0b3VjaDAuY2xpZW50WV07XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaG1vdmVIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2htb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcbiAgICBpZiAoIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG4gICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdGFydEdQb3MgPSByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbjtcbiAgICB2YXIgaXNPdmVyVGhyZXNob2xkRHJhZztcbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMF0gJiYgc3RhcnRHUG9zKSB7XG4gICAgICB2YXIgZGlzcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07XG4gICAgICB9XG4gICAgICB2YXIgZHggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHN0YXJ0R1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydEdQb3NbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMjtcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlIGNhbmNlbGxpbmdcbiAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZCA9IDEuNTtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDtcblxuICAgICAgLy8gY2FuY2VsIGN0eCBnZXN0dXJlcyBpZiB0aGUgZGlzdGFuY2UgYi90IHRoZSBmaW5nZXJzIGluY3JlYXNlc1xuICAgICAgaWYgKGZhY3RvclNxID49IGZhY3RvclRocmVzaG9sZFNxIHx8IGRpc3RhbmNlMlNxID49IGRpc3RUaHJlc2hvbGRTcSkge1xuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbWFrZUV2ZW50KCdjeHR0YXBlbmQnKTtcbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBzd2lwZVxuICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgdmFyIGN4dEV2dCA9IG1ha2VFdmVudCgnY3h0ZHJhZycpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmICghci50b3VjaERhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci5lbWl0KG1ha2VFdmVudCgnY3h0ZHJhZ291dCcpKTtcbiAgICAgICAgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyID0gbmVhcjtcbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdjeHRkcmFnb3ZlcicpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBib3ggc2VsZWN0aW9uXG4gICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdFRocmVlVG91Y2ggPSArbmV3IERhdGUoKTtcbiAgICAgIGlmICghci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdib3hzdGFydCcpKTtcbiAgICAgIH1cbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSB0cnVlO1xuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIGlmICghc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMyArIDE7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgIH1cbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuXG4gICAgICAvLyBwaW5jaCB0byB6b29tXG4gICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1sxXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBwaW5jaC10by16b29tXG4gICAgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgaWYgKGRyYWdnZWRFbGVzKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRlX3AgPSBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZTtcbiAgICAgICAgICBkZV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICBkZV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBfc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcblxuICAgICAgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcbiAgICAgIGlmICh0d29GaW5nZXJzU3RhcnRJbnNpZGUpIHtcbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyMVxuICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxO1xuXG4gICAgICAgIC8vIGRlbHRhIGZpbmdlciAyXG4gICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIG9mIHRoZSB0d28gZmluZ2VycyBtb3ZlbWVudFxuICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpIC8gMjtcbiAgICAgICAgdmFyIHR5ID0gKGRmMXkgKyBkZjJ5KSAvIDI7XG5cbiAgICAgICAgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuICAgICAgICB2YXIgem9vbTEgPSBjeS56b29tKCk7XG4gICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpO1xuXG4gICAgICAgIC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChjdHJ5IC0gcGFuMS55IC0gdHkpICsgY3RyeVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSBkcmFnZ2VkIGVsZXNcbiAgICAgICAgaWYgKF9zdGFydCAmJiBfc3RhcnQuYWN0aXZlKCkpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgX3N0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KG1ha2VFdmVudCgnZnJlZW9uJykpO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQobWFrZUV2ZW50KCdmcmVlJykpO1xuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIF9zdGFydC5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWVvbicpKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3kudmlld3BvcnQoe1xuICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdwaW5jaHpvb20nKSk7XG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG4gICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gc2luZ2xlIGZpbmdlciBldmVudHMgbGlrZSBwYW5uaW5nXG4gICAgKSB7XG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgIHZhciBuZWFyO1xuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FwdHVyZSAmJiBzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZ2dpbmcgbm9kZXNcbiAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpKSB7XG4gICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVzLCB7XG4gICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAobnVtYmVyJDEoZGlzcFswXSkgJiYgbnVtYmVyJDEoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG4gICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlciQxKGRyYWdEZWx0YVswXSkgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQobWFrZUV2ZW50KCdwb3NpdGlvbicpKS5lbWl0KG1ha2VFdmVudCgnZHJhZycpKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXSkge1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGtlZXAgdHJhY2sgb2YgZHJhZyBkZWx0YSBmb3IgbGF0ZXJcbiAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuICAgICAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0b3VjaG1vdmVcbiAgICAgIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCB8fCBuZWFyLCBbJ3RvdWNobW92ZScsICd0YXBkcmFnJywgJ3Ztb3VzZW1vdmUnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoIXN0YXJ0IHx8ICFzdGFydC5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0LmVtaXQobWFrZUV2ZW50KCd0YXBkcmFnb3V0JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgndGFwZHJhZ292ZXInKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobm93W2ldICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gJiYgaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHBhbm5pbmdcbiAgICAgIGlmIChjYXB0dXJlICYmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0LnBhbm5hYmxlKCkpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChzdGFydCwgci50b3VjaERhdGEuc3RhcnRzKTtcbiAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKCFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdkcmFncGFuJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgci5zd2lwZVBhbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnZHJhZ3BhbicpKTtcbiAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICBlYXJsaWVyW2pdID0gbm93W2pdO1xuICAgIH1cblxuICAgIC8vIHRoZSBhY3RpdmUgYmcgaW5kaWNhdG9yIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gbWFraW5nIGEgc3dpcGUgdGhhdCBpcyBuZWl0aGVyIGZvciBkcmFnZ2luZyBub2RlcyBvciBwYW5uaW5nXG4gICAgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcgJiYgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICE9IG51bGwpIHtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICB2YXIgdG91Y2hjYW5jZWxIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoY2FuY2VsSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgdG91Y2hlbmRIYW5kbGVyLCBkaWREb3VibGVUb3VjaCwgdG91Y2hUaW1lb3V0LCBwcmV2VG91Y2hUaW1lU3RhbXA7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hlbmRIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHIuc3dpcGVQYW5uaW5nID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgIH1cbiAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIHZhciBjdHhUYXBlbmQ7XG4gICAgaWYgKHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgY3R4VGFwZW5kID0gbWFrZUV2ZW50KCdjeHR0YXBlbmQnKTtcbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBzdGFydC5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgdmFyIGN0eFRhcCA9IG1ha2VFdmVudCgnY3h0dGFwJyk7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIHN0YXJ0LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN0eFRhcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBib3ggc2VsZWN0aW9uIGlmIHdlIGRvbid0IGhhdmUgdGhyZWUgZmluZ2Vyc1xuICAgIGlmICghZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgIHNlbGVjdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFszXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2JveGVuZCcpKTtcbiAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgIH07XG4gICAgICBib3guZW1pdChtYWtlRXZlbnQoJ2JveCcpKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KG1ha2VFdmVudCgnYm94c2VsZWN0JykpO1xuICAgICAgaWYgKGJveC5ub25lbXB0eSgpKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgfVxuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIDsgZWxzZSBpZiAoIWUudG91Y2hlc1swXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzdGFydFdhc0dyYWJiZWQgPSBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkO1xuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVzKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICBpZiAoc3RhcnRXYXNHcmFiYmVkKSB7XG4gICAgICAgICAgc3RhcnQuZW1pdChtYWtlRXZlbnQoJ2ZyZWVvbicpKTtcbiAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KG1ha2VFdmVudCgnZnJlZScpKTtcbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBzdGFydC5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWVvbicpKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGR4ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSAtIG5vd1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSAtIG5vd1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgIC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkKSB7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgZGlkRG91YmxlVG91Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKGUudGltZVN0YW1wIC0gcHJldlRvdWNoVGltZVN0YW1wIDw9IGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSkge1xuICAgICAgICAgIHRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodG91Y2hUaW1lb3V0KTtcbiAgICAgICAgICBkaWREb3VibGVUb3VjaCA9IHRydWU7XG4gICAgICAgICAgcHJldlRvdWNoVGltZVN0YW1wID0gbnVsbDtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ2RibHRhcCcsICd2ZGJsY2xpY2snXSwgZSwge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGlkRG91YmxlVG91Y2gpIHJldHVybjtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsnb25ldGFwJywgJ3ZvbmVjbGljayddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpO1xuICAgICAgICAgIHByZXZUb3VjaFRpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdG8gc2VsZWN0IHRoZSBjdXJyZW50bHkgdG91Y2hlZCBub2RlLCBvbmx5IGlmIGl0IGhhc24ndCBiZWVuIGRyYWdnZWQgcGFzdCBhIGNlcnRhaW4gZGlzdGFuY2VcbiAgICAgIGlmIChzdGFydCAhPSBudWxsICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICApIHtcbiAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2Uoc3RhcnQpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGFydC5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICBzdGFydC51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICBlYXJsaWVyW2pdID0gbm93W2pdO1xuICAgIH1cbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTsgLy8gcmVzZXQgZm9yIG5leHQgdG91Y2hzdGFydFxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoZSBvbGQgc3RhcnQgZ2xvYmFsIHBvcyduIG1heSBub3QgYmUgdGhlIHNhbWUgZmluZ2VyIHRoYXQgcmVtYWluc1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFtlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFldO1xuICAgICAgfVxuICAgICAgci5waW5jaGluZyA9IGZhbHNlO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8vci5yZWRyYXcoKTtcbiAgfSwgZmFsc2UpO1xuXG4gIC8vIGZhbGxiYWNrIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG1zIHBvaW50ZXIgZXZlbnRzXG4gIGlmICh0eXBlb2YgVG91Y2hFdmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgICB2YXIgbWFrZVRvdWNoID0gZnVuY3Rpb24gbWFrZVRvdWNoKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBmb3JjZTogMSxcbiAgICAgICAgaWRlbnRpZmllcjogZS5wb2ludGVySWQsXG4gICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxuICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgcmFkaXVzWDogZS53aWR0aCAvIDIsXG4gICAgICAgIHJhZGl1c1k6IGUuaGVpZ2h0IC8gMixcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgbWFrZVBvaW50ZXIgPSBmdW5jdGlvbiBtYWtlUG9pbnRlcihlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudDogZSxcbiAgICAgICAgdG91Y2g6IG1ha2VUb3VjaChlKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBhZGRQb2ludGVyID0gZnVuY3Rpb24gYWRkUG9pbnRlcihlKSB7XG4gICAgICBwb2ludGVycy5wdXNoKG1ha2VQb2ludGVyKGUpKTtcbiAgICB9O1xuICAgIHZhciByZW1vdmVQb2ludGVyID0gZnVuY3Rpb24gcmVtb3ZlUG9pbnRlcihlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRlcnNbaV07XG4gICAgICAgIGlmIChwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgICBwb2ludGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdXBkYXRlUG9pbnRlciA9IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZSkge1xuICAgICAgdmFyIHAgPSBwb2ludGVycy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZDtcbiAgICAgIH0pWzBdO1xuICAgICAgcC5ldmVudCA9IGU7XG4gICAgICBwLnRvdWNoID0gbWFrZVRvdWNoKGUpO1xuICAgIH07XG4gICAgdmFyIGFkZFRvdWNoZXNUb0V2ZW50ID0gZnVuY3Rpb24gYWRkVG91Y2hlc1RvRXZlbnQoZSkge1xuICAgICAgZS50b3VjaGVzID0gcG9pbnRlcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnRvdWNoO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgcG9pbnRlcklzTW91c2UgPSBmdW5jdGlvbiBwb2ludGVySXNNb3VzZShlKSB7XG4gICAgICByZXR1cm4gZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBlLnBvaW50ZXJUeXBlID09PSA0O1xuICAgIH07XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYWRkUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hzdGFydEhhbmRsZXIoZSk7XG4gICAgfSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVydXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoZW5kSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoY2FuY2VsSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB1cGRhdGVQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaG1vdmVIYW5kbGVyKGUpO1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQlJwJDIgPSB7fTtcbkJScCQyLmdlbmVyYXRlUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBvaW50czogcG9pbnRzLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3BvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGhhc01pdGVyQm91bmRzOiBuYW1lICE9PSAncmVjdGFuZ2xlJyxcbiAgICBtaXRlckJvdW5kczogZnVuY3Rpb24gbWl0ZXJCb3VuZHMoY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgc3Ryb2tlV2lkdGgsIHN0cm9rZVBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gbWl0ZXJCb3godGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHN0cm9rZVdpZHRoKTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVFbGxpcHNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2VsbGlwc2UnLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiArIHBhZGRpbmcsIGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgZ2V0T3JDcmVhdGVDb3JuZXJzOiBmdW5jdGlvbiBnZXRPckNyZWF0ZUNvcm5lcnMoY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzLCBycywgZmllbGQpIHtcbiAgICAgIGlmIChyc1tmaWVsZF0gIT09IHVuZGVmaW5lZCAmJiByc1tmaWVsZCArICctY3gnXSA9PT0gY2VudGVyWCAmJiByc1tmaWVsZCArICctY3knXSA9PT0gY2VudGVyWSkge1xuICAgICAgICByZXR1cm4gcnNbZmllbGRdO1xuICAgICAgfVxuICAgICAgcnNbZmllbGRdID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgIHJzW2ZpZWxkICsgJy1jeCddID0gY2VudGVyWDtcbiAgICAgIHJzW2ZpZWxkICsgJy1jeSddID0gY2VudGVyWTtcbiAgICAgIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBwID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb2ludHMubGVuZ3RoIC8gMjsgX2krKykge1xuICAgICAgICBwW19pXSA9IHtcbiAgICAgICAgICB4OiBjZW50ZXJYICsgaGFsZlcgKiBwb2ludHNbX2kgKiAyXSxcbiAgICAgICAgICB5OiBjZW50ZXJZICsgaGFsZkggKiBwb2ludHNbX2kgKiAyICsgMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBpLFxuICAgICAgICBwMSxcbiAgICAgICAgcDIsXG4gICAgICAgIHAzLFxuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIHAxID0gcFtsZW4gLSAxXTtcbiAgICAgIC8vIGZvciBlYWNoIHBvaW50XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcDIgPSBwW2kgJSBsZW5dO1xuICAgICAgICBwMyA9IHBbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgIHJzW2ZpZWxkXVtpXSA9IGdldFJvdW5kQ29ybmVyKHAxLCBwMiwgcDMsIGNvcm5lclJhZGl1cyk7XG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHAyID0gcDM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnNbZmllbGRdO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3JvdW5kLXBvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cywgdGhpcy5nZXRPckNyZWF0ZUNvcm5lcnMoY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzLCBycywgJ2RyYXdDb3JuZXJzJykpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cywgcnMpIHtcbiAgICAgIHJldHVybiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIHRoaXMuZ2V0T3JDcmVhdGVDb3JuZXJzKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzLCBycywgJ2Nvcm5lcnMnKSk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cywgcnMpIHtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5nZXRPckNyZWF0ZUNvcm5lcnMoY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzLCBycywgJ2Nvcm5lcnMnKSk7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kLXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cywgY29ybmVyUmFkaXVzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oaGFsZldpZHRoLCBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgICAgdmFyIGRpYW0gPSBjb3JuZXJSYWRpdXMgKiAyO1xuXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gZGlhbSwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHRvcCByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVDdXRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2N1dC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snY3V0cmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2N1dC1yZWN0YW5nbGUnLFxuICAgIGNvcm5lckxlbmd0aDogZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCksXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIG51bGwsIGNvcm5lclJhZGl1cyk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIGNsID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyB0aGlzLmNvcm5lckxlbmd0aCA6IGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7XG5cbiAgICAgIC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSB0cmlhbmdsZSBwdCBvbiBbNCwgNV1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcExlZnQ6IFt4QmVnaW4sIHlCZWdpbiArIGNsLCB4QmVnaW4gKyBjbCwgeUJlZ2luLCB4QmVnaW4gKyBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICB0b3BSaWdodDogW3hFbmQgLSBjbCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBjbCwgeEVuZCAtIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGNsLCB4RW5kIC0gY2wsIHlFbmQsIHhFbmQgLSBjbCwgeUVuZCAtIGNsXSxcbiAgICAgICAgYm90dG9tTGVmdDogW3hCZWdpbiArIGNsLCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBjbCwgeEJlZ2luICsgY2wsIHlFbmQgLSBjbF1cbiAgICAgIH07XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgY1B0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdC5hcHBseShbXSwgW2NQdHMudG9wTGVmdC5zcGxpY2UoMCwgNCksIGNQdHMudG9wUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbVJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21MZWZ0LnNwbGljZSgwLCA0KV0pO1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgY2wgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IHRoaXMuY29ybmVyTGVuZ3RoIDogY29ybmVyUmFkaXVzO1xuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBjbCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIGNsLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGN1dFRyaWFuZ2xlUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BMZWZ0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21SaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbUxlZnQpO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZUJhcnJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYmFycmVsJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2JhcnJlbCcsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgLy8gdXNlIHR3byBmaXhlZCB0IHZhbHVlcyBmb3IgdGhlIGJlemllciBjdXJ2ZSBhcHByb3hpbWF0aW9uXG5cbiAgICAgIHZhciB0MCA9IDAuMTU7XG4gICAgICB2YXIgdDEgPSAwLjU7XG4gICAgICB2YXIgdDIgPSAwLjg1O1xuICAgICAgdmFyIGJQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuICAgICAgdmFyIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMgPSBmdW5jdGlvbiBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKHB0cykge1xuICAgICAgICAvLyBhcHByb3hpbWF0ZSBjdXJ2ZSBwdHMgYmFzZWQgb24gdGhlIHR3byB0IHZhbHVlc1xuICAgICAgICB2YXIgbTAgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0MCk7XG4gICAgICAgIHZhciBtMSA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQxKTtcbiAgICAgICAgdmFyIG0yID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDIpO1xuICAgICAgICByZXR1cm4gW3B0c1swXSwgcHRzWzFdLCBtMC54LCBtMC55LCBtMS54LCBtMS55LCBtMi54LCBtMi55LCBwdHNbNF0sIHB0c1s1XV07XG4gICAgICB9O1xuICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdChhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wTGVmdCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BSaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21SaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21MZWZ0KSk7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7XG4gICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgICAgIHZhciBjdHJsUHRYT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd2lkdGg7XG5cbiAgICAgIC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSBjb250cm9sIHB0IG9uIFs0LCA1XVxuICAgICAgdmFyIHB0cyA9IHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgaE9mZnNldCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW5dLFxuICAgICAgICB0b3BSaWdodDogW3hFbmQgLSB3T2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGhPZmZzZXRdLFxuICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBoT2Zmc2V0LCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCAtIHdPZmZzZXQsIHlFbmRdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgd09mZnNldCwgeUVuZCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gaE9mZnNldF1cbiAgICAgIH07XG4gICAgICBwdHMudG9wTGVmdC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMudG9wUmlnaHQuaXNUb3AgPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbUxlZnQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbVJpZ2h0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwdHM7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogaE9mZnNldCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIHdPZmZzZXQsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgYmFycmVsQ3VydmVQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgdmFyIGdldEN1cnZlVCA9IGZ1bmN0aW9uIGdldEN1cnZlVCh4LCB5LCBjdXJ2ZVB0cykge1xuICAgICAgICB2YXIgeDAgPSBjdXJ2ZVB0c1s0XTtcbiAgICAgICAgdmFyIHgxID0gY3VydmVQdHNbMl07XG4gICAgICAgIHZhciB4MiA9IGN1cnZlUHRzWzBdO1xuICAgICAgICB2YXIgeTAgPSBjdXJ2ZVB0c1s1XTtcbiAgICAgICAgLy8gdmFyIHkxID0gY3VydmVQdHNbIDMgXTtcbiAgICAgICAgdmFyIHkyID0gY3VydmVQdHNbMV07XG4gICAgICAgIHZhciB4TWluID0gTWF0aC5taW4oeDAsIHgyKTtcbiAgICAgICAgdmFyIHhNYXggPSBNYXRoLm1heCh4MCwgeDIpO1xuICAgICAgICB2YXIgeU1pbiA9IE1hdGgubWluKHkwLCB5Mik7XG4gICAgICAgIHZhciB5TWF4ID0gTWF0aC5tYXgoeTAsIHkyKTtcbiAgICAgICAgaWYgKHhNaW4gPD0geCAmJiB4IDw9IHhNYXggJiYgeU1pbiA8PSB5ICYmIHkgPD0geU1heCkge1xuICAgICAgICAgIHZhciBjb2VmZiA9IGJlemllclB0c1RvUXVhZENvZWZmKHgwLCB4MSwgeDIpO1xuICAgICAgICAgIHZhciByb290cyA9IHNvbHZlUXVhZHJhdGljKGNvZWZmWzBdLCBjb2VmZlsxXSwgY29lZmZbMl0sIHgpO1xuICAgICAgICAgIHZhciB2YWxpZFJvb3RzID0gcm9vdHMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gMCA8PSByICYmIHIgPD0gMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodmFsaWRSb290cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRSb290c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgdmFyIGN1cnZlUmVnaW9ucyA9IE9iamVjdC5rZXlzKGJhcnJlbEN1cnZlUHRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmVSZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjdXJ2ZVJlZ2lvbnNbaV07XG4gICAgICAgIHZhciBjb3JuZXJQdHMgPSBiYXJyZWxDdXJ2ZVB0c1tjb3JuZXJdO1xuICAgICAgICB2YXIgdCA9IGdldEN1cnZlVCh4LCB5LCBjb3JuZXJQdHMpO1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkwID0gY29ybmVyUHRzWzVdO1xuICAgICAgICB2YXIgeTEgPSBjb3JuZXJQdHNbM107XG4gICAgICAgIHZhciB5MiA9IGNvcm5lclB0c1sxXTtcbiAgICAgICAgdmFyIGJlelkgPSBxYmV6aWVyQXQoeTAsIHkxLCB5MiwgdCk7XG4gICAgICAgIGlmIChjb3JuZXJQdHMuaXNUb3AgJiYgYmV6WSA8PSB5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc0JvdHRvbSAmJiB5IDw9IGJlelkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydib3R0b20tcm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLFxuICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cywgY29ybmVyUmFkaXVzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciB0b3BTdGFydFggPSBub2RlWCAtICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcbiAgICAgIGlmICh0b3BJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRvcEludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZywgY29ybmVyUmFkaXVzKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGRpYW0gPSAyICogY29ybmVyUmFkaXVzO1xuXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gZGlhbSwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgbm9uLXJvdW5kZWQgdG9wIHNpZGVcbiAgICAgIHZhciBvdXRlcldpZHRoID0gd2lkdGggLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQgLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgcG9pbnRzID0gW2NlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHQsIGNlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodF07XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVTaGFwZXMgPSB0aGlzLm5vZGVTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgdGhpcy5nZW5lcmF0ZUVsbGlwc2UoKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmVjdGFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApKTtcbiAgbm9kZVNoYXBlc1snc3F1YXJlJ10gPSBub2RlU2hhcGVzWydyZWN0YW5nbGUnXTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlKCk7XG4gIHRoaXMuZ2VuZXJhdGVDdXRSZWN0YW5nbGUoKTtcbiAgdGhpcy5nZW5lcmF0ZUJhcnJlbCgpO1xuICB0aGlzLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUoKTtcbiAge1xuICAgIHZhciBkaWFtb25kUG9pbnRzID0gWzAsIDEsIDEsIDAsIDAsIC0xLCAtMSwgMF07XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2RpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1kaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gIH1cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3BlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtcGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdvY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gIHZhciBzdGFyNVBvaW50cyA9IG5ldyBBcnJheSgyMCk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgIHZhciBpbm5lclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpO1xuXG4gICAgLy8gT3V0ZXIgcmFkaXVzIGlzIDE7IGlubmVyIHJhZGl1cyBvZiBzdGFyIGlzIHNtYWxsZXJcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAwLjUgKiAoMyAtIE1hdGguc3FydCg1KSk7XG4gICAgaW5uZXJSYWRpdXMgKj0gMS41NztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgaW5uZXJQb2ludHNbaSAqIDJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbaSAqIDIgKyAxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMCAvIDQ7IGkrKykge1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDRdID0gb3V0ZXJQb2ludHNbaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAxXSA9IG91dGVyUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDJdID0gaW5uZXJQb2ludHNbaSAqIDJdO1xuICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAzXSA9IGlubmVyUG9pbnRzW2kgKiAyICsgMV07XG4gICAgfVxuICB9XG4gIHN0YXI1UG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHN0YXI1UG9pbnRzKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3N0YXInLCBzdGFyNVBvaW50cyk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd2ZWUnLCBbLTEsIC0xLCAwLCAtMC4zMzMsIDEsIC0xLCAwLCAxXSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyaG9tYm9pZCcsIFstMSwgLTEsIDAuMzMzLCAtMSwgMSwgMSwgLTAuMzMzLCAxXSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyaWdodC1yaG9tYm9pZCcsIFstMC4zMzMsIC0xLCAxLCAtMSwgMC4zMzMsIDEsIC0xLCAxXSk7XG4gIHRoaXMubm9kZVNoYXBlc1snY29uY2F2ZWhleGFnb24nXSA9IHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdjb25jYXZlLWhleGFnb24nLCBbLTEsIC0wLjk1LCAtMC43NSwgMCwgLTEsIDAuOTUsIDEsIDAuOTUsIDAuNzUsIDAsIDEsIC0wLjk1XSk7XG4gIHtcbiAgICB2YXIgdGFnUG9pbnRzID0gWy0xLCAtMSwgMC4yNSwgLTEsIDEsIDAsIDAuMjUsIDEsIC0xLCAxXTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigndGFnJywgdGFnUG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10YWcnLCB0YWdQb2ludHMpO1xuICB9XG4gIG5vZGVTaGFwZXMubWFrZVBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgLy8gdXNlIGNhY2hpbmcgb24gdXNlci1zcGVjaWZpZWQgcG9seWdvbnMgc28gdGhleSBhcmUgYXMgZmFzdCBhcyBuYXRpdmUgc2hhcGVzXG5cbiAgICB2YXIga2V5ID0gcG9pbnRzLmpvaW4oJyQnKTtcbiAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgdmFyIHNoYXBlO1xuICAgIGlmIChzaGFwZSA9IHRoaXNbbmFtZV0pIHtcbiAgICAgIC8vIGdvdCBjYWNoZWQgc2hhcGVcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYW5kIGNhY2hlIG5ldyBzaGFwZVxuICAgIHJldHVybiByZW5kZXJlci5nZW5lcmF0ZVBvbHlnb24obmFtZSwgcG9pbnRzKTtcbiAgfTtcbn07XG5cbnZhciBCUnAkMSA9IHt9O1xuQlJwJDEudGltZVRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xufTtcbkJScCQxLnJlZHJhdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHN0YXRpY0VtcHR5T2JqZWN0KCk7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSAwO1xuICB9XG4gIGlmIChyLmxhc3RSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmxhc3RSZWRyYXdUaW1lID0gMDtcbiAgfVxuICBpZiAoci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIubGFzdERyYXdUaW1lID0gMDtcbiAgfVxuICByLnJlcXVlc3RlZEZyYW1lID0gdHJ1ZTtcbiAgci5yZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbn07XG5CUnAkMS5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoZm4sIHByaW9yaXR5KSB7XG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBhZGQgdGljayBjYWxsYmFja3Mgd2hlbiBkZXN0cm95ZWRcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcmlvcml0eSA9PSBudWxsKSB7XG4gICAgZXJyb3IoJ1ByaW9yaXR5IGlzIG5vdCBvcHRpb25hbCBmb3IgYmVmb3JlUmVuZGVyJyk7XG4gIH1cbiAgdmFyIGNicyA9IHRoaXMuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuICBjYnMucHVzaCh7XG4gICAgZm46IGZuLFxuICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICB9KTtcblxuICAvLyBoaWdoZXIgcHJpb3JpdHkgY2FsbGJhY2tzIGV4ZWN1dGVkIGZpcnN0XG4gIGNicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5O1xuICB9KTtcbn07XG52YXIgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHdpbGxEcmF3LCBzdGFydFRpbWUpIHtcbiAgdmFyIGNicyA9IHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5sZW5ndGg7IGkrKykge1xuICAgIGNic1tpXS5mbih3aWxsRHJhdywgc3RhcnRUaW1lKTtcbiAgfVxufTtcbkJScCQxLnN0YXJ0UmVuZGVyTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuICBpZiAoci5yZW5kZXJMb29wU3RhcnRlZCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByLnJlbmRlckxvb3BTdGFydGVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgX3JlbmRlckZuID0gZnVuY3Rpb24gcmVuZGVyRm4ocmVxdWVzdFRpbWUpIHtcbiAgICBpZiAoci5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN5LmJhdGNoaW5nKCkpIDsgZWxzZSBpZiAoci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUpIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB0cnVlLCByZXF1ZXN0VGltZSk7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgIHIucmVuZGVyKHIucmVuZGVyT3B0aW9ucyk7XG4gICAgICB2YXIgZW5kVGltZSA9IHIubGFzdERyYXdUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgci5yZWRyYXdDb3VudCsrO1xuICAgICAgaWYgKHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgfVxuICAgICAgdmFyIGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIHIucmVkcmF3VG90YWxUaW1lICs9IGR1cmF0aW9uO1xuICAgICAgci5sYXN0UmVkcmF3VGltZSA9IGR1cmF0aW9uO1xuXG4gICAgICAvLyB1c2UgYSB3ZWlnaHRlZCBhdmVyYWdlIHdpdGggYSBiaWFzIGZyb20gdGhlIHByZXZpb3VzIGF2ZXJhZ2Ugc28gd2UgZG9uJ3Qgc3Bpa2Ugc28gZWFzaWx5XG4gICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZSAvIDIgKyBkdXJhdGlvbiAvIDI7XG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCBmYWxzZSwgcmVxdWVzdFRpbWUpO1xuICAgIH1cbiAgICByLnNraXBGcmFtZSA9IGZhbHNlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShfcmVuZGVyRm4pO1xuICB9O1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3JlbmRlckZuKTtcbn07XG5cbnZhciBCYXNlUmVuZGVyZXIgPSBmdW5jdGlvbiBCYXNlUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLmluaXQob3B0aW9ucyk7XG59O1xudmFyIEJSID0gQmFzZVJlbmRlcmVyO1xudmFyIEJScCA9IEJSLnByb3RvdHlwZTtcbkJScC5jbGllbnRGdW5jdGlvbnMgPSBbJ3JlZHJhd0hpbnQnLCAncmVuZGVyJywgJ3JlbmRlclRvJywgJ21hdGNoQ2FudmFzU2l6ZScsICdub2RlU2hhcGVJbXBsJywgJ2Fycm93U2hhcGVJbXBsJ107XG5CUnAuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5vcHRpb25zID0gb3B0aW9ucztcbiAgci5jeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBjdHIgPSByLmNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSByLmN5LndpbmRvdygpO1xuXG4gIC8vIHByZXBlbmQgYSBzdHlsZXNoZWV0IGluIHRoZSBoZWFkIHN1Y2ggdGhhdFxuICBpZiAoY29udGFpbmVyV2luZG93KSB7XG4gICAgdmFyIGRvY3VtZW50ID0gY29udGFpbmVyV2luZG93LmRvY3VtZW50O1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICB2YXIgc3R5bGVzaGVldElkID0gJ19fX19fX19fX19jeXRvc2NhcGVfc3R5bGVzaGVldCc7XG4gICAgdmFyIGNsYXNzTmFtZSA9ICdfX19fX19fX19fY3l0b3NjYXBlX2NvbnRhaW5lcic7XG4gICAgdmFyIHN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3R5bGVzaGVldElkKSAhPSBudWxsO1xuICAgIGlmIChjdHIuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcbiAgICAgIGN0ci5jbGFzc05hbWUgPSAoY3RyLmNsYXNzTmFtZSB8fCAnJykgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgfVxuICAgIGlmICghc3R5bGVzaGVldEFscmVhZHlFeGlzdHMpIHtcbiAgICAgIHZhciBzdHlsZXNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlc2hlZXQuaWQgPSBzdHlsZXNoZWV0SWQ7XG4gICAgICBzdHlsZXNoZWV0LnRleHRDb250ZW50ID0gJy4nICsgY2xhc3NOYW1lICsgJyB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfSc7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZXNoZWV0LCBoZWFkLmNoaWxkcmVuWzBdKTsgLy8gZmlyc3Qgc28gbG93ZXN0IHByaW9yaXR5XG4gICAgfVxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gY29udGFpbmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoY3RyKTtcbiAgICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgd2FybignQSBDeXRvc2NhcGUgY29udGFpbmVyIGhhcyBzdHlsZSBwb3NpdGlvbjpzdGF0aWMgYW5kIHNvIGNhbiBub3QgdXNlIFVJIGV4dGVuc2lvbnMgcHJvcGVybHknKTtcbiAgICB9XG4gIH1cbiAgci5zZWxlY3Rpb24gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwXTsgLy8gQ29vcmRpbmF0ZXMgZm9yIHNlbGVjdGlvbiBib3gsIHBsdXMgZW5hYmxlZCBmbGFnXG5cbiAgci5iZXppZXJQcm9qUGN0cyA9IFswLjA1LCAwLjIyNSwgMC40LCAwLjUsIDAuNiwgMC43NzUsIDAuOTVdO1xuXG4gIC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuICByLmhvdmVyRGF0YSA9IHtcbiAgICBkb3duOiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgZG93blRpbWU6IG51bGwsXG4gICAgdHJpZ2dlck1vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIGluaXRpYWxQYW46IFtudWxsLCBudWxsXSxcbiAgICBjYXB0dXJlOiBmYWxzZVxuICB9O1xuICByLmRyYWdEYXRhID0ge1xuICAgIHBvc3NpYmxlRHJhZ0VsZW1lbnRzOiBbXVxuICB9O1xuICByLnRvdWNoRGF0YSA9IHtcbiAgICBzdGFydDogbnVsbCxcbiAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAvLyBUaGVzZSAzIGZpZWxkcyByZWxhdGVkIHRvIHRhcCwgdGFwaG9sZCBldmVudHNcbiAgICBzdGFydFBvc2l0aW9uOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgc2luZ2xlVG91Y2hNb3ZlZDogdHJ1ZSxcbiAgICBub3c6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgfTtcbiAgci5yZWRyYXdzID0gMDtcbiAgci5zaG93RnBzID0gb3B0aW9ucy5zaG93RnBzO1xuICByLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgci53ZWJnbCA9IG9wdGlvbnMud2ViZ2w7XG4gIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgci50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gIHIud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgci5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuICByLmZvcmNlZFBpeGVsUmF0aW8gPSBudW1iZXIkMShvcHRpb25zLnBpeGVsUmF0aW8pID8gb3B0aW9ucy5waXhlbFJhdGlvIDogbnVsbDtcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICByLm1vdGlvbkJsdXJPcGFjaXR5ID0gb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5ID0gMSAtIHIubW90aW9uQmx1ck9wYWNpdHk7XG4gIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICByLm1iUHhSQmx1cnJ5ID0gMTsgLy8wLjg7XG4gIHIubWluTWJMb3dRdWFsRnJhbWVzID0gNDtcbiAgci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gIHIuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkICogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgci50YXBob2xkRHVyYXRpb24gPSA1MDA7XG4gIHIuYmluZGluZ3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzID0ge1xuICAgIC8vIGhpZ2hlciBwcmlvcml0eSBleGVjcyBiZWZvcmUgbG93ZXIgb25lXG4gICAgYW5pbWF0aW9uczogNDAwLFxuICAgIGVsZUNhbGNzOiAzMDAsXG4gICAgZWxlVHhyRGVxOiAyMDAsXG4gICAgbHlyVHhyRGVxOiAxNTAsXG4gICAgbHlyVHhyU2tpcDogMTAwXG4gIH07XG4gIHIucmVnaXN0ZXJOb2RlU2hhcGVzKCk7XG4gIHIucmVnaXN0ZXJBcnJvd1NoYXBlcygpO1xuICByLnJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMoKTtcbn07XG5CUnAubm90aWZ5ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWxlcykge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG5cbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnaW5pdCcpIHtcbiAgICByLmxvYWQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgci5kZXN0cm95KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICdhZGQnIHx8IGV2ZW50TmFtZSA9PT0gJ3JlbW92ZScgfHwgZXZlbnROYW1lID09PSAnbW92ZScgJiYgY3kuaGFzQ29tcG91bmROb2RlcygpIHx8IGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3pvcmRlcicgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgci5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAndmlld3BvcnQnKSB7XG4gICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnZ2MnKSB7XG4gICAgci5yZWRyYXdIaW50KCdnYycsIHRydWUpO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICdsb2FkJyB8fCBldmVudE5hbWUgPT09ICdyZXNpemUnIHx8IGV2ZW50TmFtZSA9PT0gJ21vdW50Jykge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICB9XG4gIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgdGhpcy5zdGFydFJlbmRlckxvb3AoKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5CUnAuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLmRlc3Ryb3llZCA9IHRydWU7XG4gIHIuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJpbmRpbmcgPSByLmJpbmRpbmdzW2ldO1xuICAgIHZhciBiID0gYmluZGluZztcbiAgICB2YXIgdGd0ID0gYi50YXJnZXQ7XG4gICAgKHRndC5vZmYgfHwgdGd0LnJlbW92ZUV2ZW50TGlzdGVuZXIpLmFwcGx5KHRndCwgYi5hcmdzKTtcbiAgfVxuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIub25VcGRhdGVFbGVDYWxjc0ZucyA9IFtdO1xuICBpZiAoci5yZW1vdmVPYnNlcnZlcikge1xuICAgIHIucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmIChyLnN0eWxlT2JzZXJ2ZXIpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmIChyLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgci5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHIubGFiZWxDYWxjRGl2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoci5sYWJlbENhbGNEaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWUxMCBpc3N1ZSAjMTAxNFxuICAgIH1cbiAgfVxufTtcbkJScC5pc0hlYWRsZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuW0JScCRmLCBCUnAkNSwgQlJwJDQsIEJScCQzLCBCUnAkMiwgQlJwJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAsIHByb3BzKTtcbn0pO1xuXG52YXIgZnVsbEZwc1RpbWUgPSAxMDAwIC8gNjA7IC8vIGFzc3VtZSA2MCBmcmFtZXMgcGVyIHNlY29uZFxuXG52YXIgZGVmcyA9IHtcbiAgc2V0dXBEZXF1ZXVlaW5nOiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmcob3B0cykge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmdJbXBsKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgaWYgKHNlbGYuZGVxdWV1ZWluZ1NldHVwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZGVxdWV1ZWluZ1NldHVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBxdWV1ZVJlZHJhdyA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgb3B0cy5kZXFSZWRyYXdUaHJlc2hvbGQpO1xuICAgICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKHdpbGxEcmF3LCBmcmFtZVN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgdmFyIGF2Z1JlbmRlclRpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgIHZhciBleHRlbnQgPSByLmN5LmV4dGVudCgpO1xuICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCBpbiBhIHRpY2sgdGhhdCBjYXVzZXMgYSBkcmF3LCB0aGVuIHRoZSByZW5kZXJlZCBzdHlsZVxuICAgICAgICAvLyBxdWV1ZSB3b24ndCBhdXRvbWF0aWNhbGx5IGJlIGZsdXNoZWQgYmVmb3JlIGRlcXVldWVpbmcgc3RhcnRzXG4gICAgICAgIGlmICghd2lsbERyYXcpIHtcbiAgICAgICAgICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IG5vdyAtIGZyYW1lU3RhcnRUaW1lO1xuICAgICAgICAgIGlmIChyZW5kZXJUaW1lIDwgZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJlbmRlcmluZyBmYXN0ZXIgdGhhbiB0aGUgaWRlYWwgZnBzLCB0aGVuIGRvIGRlcXVldWVpbmdcbiAgICAgICAgICAgIC8vIGR1cmluZyBhbGwgb2YgdGhlIHJlbWFpbmluZyBmcmFtZSB0aW1lXG5cbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAod2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCk7XG4gICAgICAgICAgICBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcUZhc3RDb3N0ICogdGltZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+PSBvcHRzLmRlcUNvc3QgKiByZW5kZXJUaW1lIHx8IGR1cmF0aW9uID49IG9wdHMuZGVxQXZnQ29zdCAqIGF2Z1JlbmRlclRpbWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxTm9EcmF3Q29zdCAqIGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGhpc0RlcWQgPSBvcHRzLmRlcShzZWxmLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgICAgICAgIGlmICh0aGlzRGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNEZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRlcWQucHVzaCh0aGlzRGVxZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG4gICAgICAgIGlmIChkZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRzLm9uRGVxZChzZWxmLCBkZXFkKTtcbiAgICAgICAgICBpZiAoIXdpbGxEcmF3ICYmIG9wdHMuc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCkpIHtcbiAgICAgICAgICAgIHF1ZXVlUmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCBub29wJDE7XG4gICAgICByLmJlZm9yZVJlbmRlcihkZXF1ZXVlLCBwcmlvcml0eShzZWxmKSk7XG4gICAgfTtcbiAgfVxufTtcblxuLy8gQWxsb3dzIGxvb2t1cHMgZm9yIChlbGUsIGx2bCkgPT4gY2FjaGUuXG4vLyBVc2VzIGtleXMgc28gZWxlbWVudHMgbWF5IHNoYXJlIHRoZSBzYW1lIGNhY2hlLlxudmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKGdldEtleSkge1xuICAgIHZhciBkb2VzRWxlSW52YWxpZGF0ZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2lmeTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCk7XG4gICAgdGhpcy5pZHNCeUtleSA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMua2V5Rm9ySWQgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmNhY2hlc0J5THZsID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5sdmxzID0gW107XG4gICAgdGhpcy5nZXRLZXkgPSBnZXRLZXk7XG4gICAgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleSA9IGRvZXNFbGVJbnZhbGlkYXRlS2V5O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCwgW3tcbiAgICBrZXk6IFwiZ2V0SWRzRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkc0ZvcihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcihcIkNhbiBub3QgZ2V0IGlkIGxpc3QgZm9yIG51bGwga2V5XCIpO1xuICAgICAgfVxuICAgICAgdmFyIGlkc0J5S2V5ID0gdGhpcy5pZHNCeUtleTtcbiAgICAgIHZhciBpZHMgPSB0aGlzLmlkc0J5S2V5LmdldChrZXkpO1xuICAgICAgaWYgKCFpZHMpIHtcbiAgICAgICAgaWRzID0gbmV3IFNldCQxKCk7XG4gICAgICAgIGlkc0J5S2V5LnNldChrZXksIGlkcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRJZEZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJZEZvcktleShrZXksIGlkKSB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KS5hZGQoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVJZEZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVJZEZvcktleShrZXksIGlkKSB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KVtcImRlbGV0ZVwiXShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE51bWJlck9mSWRzRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlck9mSWRzRm9yS2V5KGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWRzRm9yKGtleSkuc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHZhciBjdXJyS2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgdGhpcy5hZGRJZEZvcktleShjdXJyS2V5LCBpZCk7XG4gICAgICB0aGlzLmtleUZvcklkLnNldChpZCwgY3VycktleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUtleU1hcHBpbmdGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgIHRoaXMua2V5Rm9ySWRbXCJkZWxldGVcIl0oaWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlIYXNDaGFuZ2VkRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleUhhc0NoYW5nZWRGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdmFyIG5ld0tleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICByZXR1cm4gcHJldktleSAhPT0gbmV3S2V5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ludmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnZhbGlkKGVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5SGFzQ2hhbmdlZEZvcihlbGUpIHx8IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVzQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGVzQXQobHZsKSB7XG4gICAgICB2YXIgY2FjaGVzQnlMdmwgPSB0aGlzLmNhY2hlc0J5THZsLFxuICAgICAgICBsdmxzID0gdGhpcy5sdmxzO1xuICAgICAgdmFyIGNhY2hlcyA9IGNhY2hlc0J5THZsLmdldChsdmwpO1xuICAgICAgaWYgKCFjYWNoZXMpIHtcbiAgICAgICAgY2FjaGVzID0gbmV3IE1hcCQxKCk7XG4gICAgICAgIGNhY2hlc0J5THZsLnNldChsdmwsIGNhY2hlcyk7XG4gICAgICAgIGx2bHMucHVzaChsdmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuZ2V0KGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7XG5cbiAgICAgIC8vIGdldHRpbmcgZm9yIGFuIGVsZW1lbnQgbWF5IG5lZWQgdG8gYWRkIHRvIHRoZSBpZCBsaXN0IGIvYyBlbGVzIGNhbiBzaGFyZSBrZXlzXG4gICAgICBpZiAoY2FjaGUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9yQ2FjaGVkS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvckNhY2hlZEtleShlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGVsZS5pZCgpKTsgLy8gbi5iLiB1c2UgY2FjaGVkIGtleSwgbm90IG5ld2x5IGNvbXB1dGVkIGtleVxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhY2hlKGtleSwgbHZsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmhhcyhrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHJldHVybiB0aGlzLmhhc0NhY2hlKGtleSwgbHZsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKSB7XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmdldENhY2hlc0F0KGx2bCkuc2V0KGtleSwgY2FjaGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGVsZSwgbHZsLCBjYWNoZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLnNldENhY2hlKGtleSwgbHZsLCBjYWNoZSk7XG4gICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKVtcImRlbGV0ZVwiXShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlS2V5KGtleSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMubHZscy5mb3JFYWNoKGZ1bmN0aW9uIChsdmwpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBubyBvdGhlciBlbGVzIHJlZmVyZW5jZSB0aGUgaW52YWxpZGF0ZWQgY2FjaGUgKG4uYi4gb3RoZXIgZWxlcyBtYXkgbmVlZCB0aGUgY2FjaGUgd2l0aCB0aGUgc2FtZSBrZXkpXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpOyAvLyBuLmIuIHVzZSBzdG9yZWQga2V5IHJhdGhlciB0aGFuIGN1cnJlbnQgKHBvdGVudGlhbCBrZXkpXG5cbiAgICAgIHRoaXMuZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgdmFyIGVudGlyZUtleUludmFsaWRhdGVkID0gdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuICAgICAgaWYgKGVudGlyZUtleUludmFsaWRhdGVkKSB7XG4gICAgICAgIC8vIGNsZWFyIG1hcHBpbmcgZm9yIGN1cnJlbnQga2V5XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUtleShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudGlyZUtleUludmFsaWRhdGVkIHx8IHRoaXMuZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSA9PT0gMDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIG1pblR4ckggPSAyNTsgLy8gdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgY2FjaGUgZm9yIHNtYWxsIGhlaWdodCBlbGVzIChzcGVjaWFsIGNhc2UpXG52YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG52YXIgbWluTHZsJDEgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG52YXIgbWF4THZsJDEgPSAzOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG52YXIgbWF4Wm9vbSQxID0gNy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBlbGVUeHJTcGFjaW5nID0gODsgLy8gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzIG9uIHRleHR1cmVzIHRvIGF2b2lkIGJsaXR0aW5nIG92ZXJsYXBzXG52YXIgZGVmVHhyV2lkdGggPSAxMDI0OyAvLyBkZWZhdWx0L21pbmltdW0gdGV4dHVyZSB3aWR0aFxudmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcbnZhciBtYXhUeHJIID0gMTAyNDsgLy8gdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgdGV4dHVyZVxudmFyIG1pblV0aWxpdHkgPSAwLjI7IC8vIGlmIHVzYWdlIG9mIHRleHR1cmUgaXMgbGVzcyB0aGFuIHRoaXMsIGl0IGlzIHJldGlyZWRcbnZhciBtYXhGdWxsbmVzcyA9IDAuODsgLy8gZnVsbG5lc3Mgb2YgdGV4dHVyZSBhZnRlciB3aGljaCBxdWV1ZSByZW1vdmFsIGlzIGNoZWNrZWRcbnZhciBtYXhGdWxsbmVzc0NoZWNrcyA9IDEwOyAvLyBkZXF1ZXVlZCBhZnRlciB0aGlzIG1hbnkgY2hlY2tzXG52YXIgZGVxQ29zdCQxID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG52YXIgZGVxQXZnQ29zdCQxID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QkMSA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcbnZhciBkZXFGYXN0Q29zdCQxID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xudmFyIGRlcVJlZHJhd1RocmVzaG9sZCQxID0gMTAwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxudmFyIG1heERlcVNpemUkMSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbnZhciBnZXRUeHJSZWFzb25zID0ge1xuICBkZXF1ZXVlOiAnZGVxdWV1ZScsXG4gIGRvd25zY2FsZTogJ2Rvd25zY2FsZScsXG4gIGhpZ2hRdWFsaXR5OiAnaGlnaFF1YWxpdHknXG59O1xudmFyIGluaXREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBnZXRLZXk6IG51bGwsXG4gIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBmYWxzaWZ5LFxuICBkcmF3RWxlbWVudDogbnVsbCxcbiAgZ2V0Qm91bmRpbmdCb3g6IG51bGwsXG4gIGdldFJvdGF0aW9uUG9pbnQ6IG51bGwsXG4gIGdldFJvdGF0aW9uT2Zmc2V0OiBudWxsLFxuICBpc1Zpc2libGU6IHRydWVpZnksXG4gIGFsbG93RWRnZVR4ckNhY2hpbmc6IHRydWUsXG4gIGFsbG93UGFyZW50VHhyQ2FjaGluZzogdHJ1ZVxufSk7XG52YXIgRWxlbWVudFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIEVsZW1lbnRUZXh0dXJlQ2FjaGUocmVuZGVyZXIsIGluaXRPcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICBzZWxmLm9uRGVxdWV1ZXMgPSBbXTtcbiAgdmFyIG9wdHMgPSBpbml0RGVmYXVsdHMoaW5pdE9wdGlvbnMpO1xuICBleHRlbmQoc2VsZiwgb3B0cyk7XG4gIHNlbGYubG9va3VwID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAob3B0cy5nZXRLZXksIG9wdHMuZG9lc0VsZUludmFsaWRhdGVLZXkpO1xuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcbnZhciBFVENwID0gRWxlbWVudFRleHR1cmVDYWNoZS5wcm90b3R5cGU7XG5FVENwLnJlYXNvbnMgPSBnZXRUeHJSZWFzb25zO1xuXG4vLyB0aGUgbGlzdCBvZiB0ZXh0dXJlcyBpbiB3aGljaCBuZXcgc3VidGV4dHVyZXMgZm9yIGVsZW1lbnRzIGNhbiBiZSBwbGFjZWRcbkVUQ3AuZ2V0VGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVsZUltZ0NhY2hlcyA9IHNlbGYuZWxlSW1nQ2FjaGVzIHx8IHt9O1xuICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbn07XG5cbi8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcnR4dHJRcyA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkIHx8IHt9O1xuICB2YXIgcnR4dHJRID0gcnR4dHJRc1t0eHJIXSA9IHJ0eHRyUXNbdHhySF0gfHwgW107XG4gIHJldHVybiBydHh0clE7XG59O1xuXG4vLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVsc1xuRVRDcC5nZXRFbGVtZW50UXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmVsZUNhY2hlUXVldWUgPSBzZWxmLmVsZUNhY2hlUXVldWUgfHwgbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICB9KTtcbiAgcmV0dXJuIHE7XG59O1xuXG4vLyBxdWV1ZSBvZiBlbGVtZW50IGRyYXcgcmVxdWVzdHMgYXQgZGlmZmVyZW50IHNjYWxlIGxldmVscyAoZWxlbWVudCBpZCBsb29rdXApXG5FVENwLmdldEVsZW1lbnRLZXlUb1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrMnEgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlIHx8IHt9O1xuICByZXR1cm4gazJxO1xufTtcbkVUQ3AuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIGxvb2t1cCA9IHRoaXMubG9va3VwO1xuICBpZiAoIWJiIHx8IGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCBpc05hTihiYi53KSB8fCBpc05hTihiYi5oKSB8fCAhZWxlLnZpc2libGUoKSB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFzZWxmLmFsbG93RWRnZVR4ckNhY2hpbmcgJiYgZWxlLmlzRWRnZSgpIHx8ICFzZWxmLmFsbG93UGFyZW50VHhyQ2FjaGluZyAmJiBlbGUuaXNQYXJlbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChsdmwgPT0gbnVsbCkge1xuICAgIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7XG4gIH1cbiAgaWYgKGx2bCA8IG1pbkx2bCQxKSB7XG4gICAgbHZsID0gbWluTHZsJDE7XG4gIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tJDEgfHwgbHZsID4gbWF4THZsJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgZWxlU2NhbGVkSCA9IGJiLmggKiBzY2FsZTtcbiAgdmFyIGVsZVNjYWxlZFcgPSBiYi53ICogc2NhbGU7XG4gIHZhciBzY2FsZWRMYWJlbFNob3duID0gci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUsIHNjYWxlKTtcbiAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGVsZUNhY2hlID0gbG9va3VwLmdldChlbGUsIGx2bCk7XG5cbiAgLy8gaWYgdGhpcyBnZXQgd2FzIG9uIGFuIHVudXNlZC9pbnZhbGlkYXRlZCBjYWNoZSwgdGhlbiByZXN0b3JlIHRoZSB0ZXh0dXJlIHVzYWdlIG1ldHJpY1xuICBpZiAoZWxlQ2FjaGUgJiYgZWxlQ2FjaGUuaW52YWxpZGF0ZWQpIHtcbiAgICBlbGVDYWNoZS5pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIGVsZUNhY2hlLnRleHR1cmUuaW52YWxpZGF0ZWRXaWR0aCAtPSBlbGVDYWNoZS53aWR0aDtcbiAgfVxuICBpZiAoZWxlQ2FjaGUpIHtcbiAgICByZXR1cm4gZWxlQ2FjaGU7XG4gIH1cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgfVxuICBpZiAoZWxlU2NhbGVkSCA+IG1heFR4ckggfHwgZWxlU2NhbGVkVyA+IG1heFR4clcpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gY2FjaGluZyBsYXJnZSBlbGVtZW50cyBpcyBub3QgZWZmaWNpZW50XG4gIH1cbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcblxuICAvLyBmaXJzdCB0cnkgdGhlIHNlY29uZCBsYXN0IG9uZSBpbiBjYXNlIGl0IGhhcyBzcGFjZSBhdCB0aGUgZW5kXG4gIHZhciB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMl07XG4gIHZhciBhZGROZXdUeHIgPSBmdW5jdGlvbiBhZGROZXdUeHIoKSB7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUodHhySCwgZWxlU2NhbGVkVykgfHwgc2VsZi5hZGRUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpO1xuICB9O1xuXG4gIC8vIHRyeSB0aGUgbGFzdCBvbmUgaWYgdGhlcmUgaXMgbm8gc2Vjb25kIGxhc3Qgb25lXG4gIGlmICghdHhyKSB7XG4gICAgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIC8vIGlmIHRoZXJlJ3Mgbm8gcm9vbSBpbiB0aGUgY3VycmVudCB0ZXh0dXJlLCB3ZSBuZWVkIGEgbmV3IG9uZVxuICBpZiAodHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuICB2YXIgc2NhbGFibGVGcm9tID0gZnVuY3Rpb24gc2NhbGFibGVGcm9tKG90aGVyQ2FjaGUpIHtcbiAgICByZXR1cm4gb3RoZXJDYWNoZSAmJiBvdGhlckNhY2hlLnNjYWxlZExhYmVsU2hvd24gPT09IHNjYWxlZExhYmVsU2hvd247XG4gIH07XG4gIHZhciBkZXFpbmcgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRlcXVldWU7XG4gIHZhciBoaWdoUXVhbGl0eVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuaGlnaFF1YWxpdHk7XG4gIHZhciBkb3duc2NhbGVSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRvd25zY2FsZTtcbiAgdmFyIGhpZ2hlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgaGlnaGVyIGxldmVsXG4gIGZvciAodmFyIGwgPSBsdmwgKyAxOyBsIDw9IG1heEx2bCQxOyBsKyspIHtcbiAgICB2YXIgYyA9IGxvb2t1cC5nZXQoZWxlLCBsKTtcbiAgICBpZiAoYykge1xuICAgICAgaGlnaGVyQ2FjaGUgPSBjO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBvbmVVcENhY2hlID0gaGlnaGVyQ2FjaGUgJiYgaGlnaGVyQ2FjaGUubGV2ZWwgPT09IGx2bCArIDEgPyBoaWdoZXJDYWNoZSA6IG51bGw7XG4gIHZhciBkb3duc2NhbGUgPSBmdW5jdGlvbiBkb3duc2NhbGUoKSB7XG4gICAgdHhyLmNvbnRleHQuZHJhd0ltYWdlKG9uZVVwQ2FjaGUudGV4dHVyZS5jYW52YXMsIG9uZVVwQ2FjaGUueCwgMCwgb25lVXBDYWNoZS53aWR0aCwgb25lVXBDYWNoZS5oZWlnaHQsIHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIGVsZVNjYWxlZEgpO1xuICB9O1xuXG4gIC8vIHJlc2V0IGVsZSBhcmVhIGluIHRleHR1cmVcbiAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICB0eHIuY29udGV4dC5jbGVhclJlY3QodHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgdHhySCk7XG4gIGlmIChzY2FsYWJsZUZyb20ob25lVXBDYWNoZSkpIHtcbiAgICAvLyB0aGVuIHdlIGNhbiByZWxhdGl2ZWx5IGNoZWFwbHkgcmVzY2FsZSB0aGUgZXhpc3RpbmcgaW1hZ2Ugdy9vIHJlcmVuZGVyaW5nXG4gICAgZG93bnNjYWxlKCk7XG4gIH0gZWxzZSBpZiAoc2NhbGFibGVGcm9tKGhpZ2hlckNhY2hlKSkge1xuICAgIC8vIHRoZW4gdXNlIHRoZSBoaWdoZXIgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIG5leHQgbGV2ZWwgZG93blxuICAgIC8vIHRvIGNoZWFwbHkgc2NhbGUgdG93YXJkcyB0aGUgc21hbGxlciBsZXZlbFxuXG4gICAgaWYgKGhpZ2hRdWFsaXR5UmVxKSB7XG4gICAgICBmb3IgKHZhciBfbCA9IGhpZ2hlckNhY2hlLmxldmVsOyBfbCA+IGx2bDsgX2wtLSkge1xuICAgICAgICBvbmVVcENhY2hlID0gc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIF9sLCBnZXRUeHJSZWFzb25zLmRvd25zY2FsZSk7XG4gICAgICB9XG4gICAgICBkb3duc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoZWxlLCBoaWdoZXJDYWNoZS5sZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGhpZ2hlckNhY2hlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93ZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGxvd2VyIGxldmVsXG4gICAgaWYgKCFkZXFpbmcgJiYgIWhpZ2hRdWFsaXR5UmVxICYmICFkb3duc2NhbGVSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sMiA9IGx2bCAtIDE7IF9sMiA+PSBtaW5MdmwkMTsgX2wyLS0pIHtcbiAgICAgICAgdmFyIF9jID0gbG9va3VwLmdldChlbGUsIF9sMik7XG4gICAgICAgIGlmIChfYykge1xuICAgICAgICAgIGxvd2VyQ2FjaGUgPSBfYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2NhbGFibGVGcm9tKGxvd2VyQ2FjaGUpKSB7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgbG93ZXIgcXVhbGl0eSBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgYmV0dGVyIG9uZSBmb3IgbGF0ZXJcblxuICAgICAgc2VsZi5xdWV1ZUVsZW1lbnQoZWxlLCBsdmwpO1xuICAgICAgcmV0dXJuIGxvd2VyQ2FjaGU7XG4gICAgfVxuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSh0eHIudXNlZFdpZHRoLCAwKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIHRoaXMuZHJhd0VsZW1lbnQodHhyLmNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIGZhbHNlKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKC10eHIudXNlZFdpZHRoLCAwKTtcbiAgfVxuICBlbGVDYWNoZSA9IHtcbiAgICB4OiB0eHIudXNlZFdpZHRoLFxuICAgIHRleHR1cmU6IHR4cixcbiAgICBsZXZlbDogbHZsLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICB3aWR0aDogZWxlU2NhbGVkVyxcbiAgICBoZWlnaHQ6IGVsZVNjYWxlZEgsXG4gICAgc2NhbGVkTGFiZWxTaG93bjogc2NhbGVkTGFiZWxTaG93blxuICB9O1xuICB0eHIudXNlZFdpZHRoICs9IE1hdGguY2VpbChlbGVTY2FsZWRXICsgZWxlVHhyU3BhY2luZyk7XG4gIHR4ci5lbGVDYWNoZXMucHVzaChlbGVDYWNoZSk7XG4gIGxvb2t1cC5zZXQoZWxlLCBsdmwsIGVsZUNhY2hlKTtcbiAgc2VsZi5jaGVja1RleHR1cmVGdWxsbmVzcyh0eHIpO1xuICByZXR1cm4gZWxlQ2FjaGU7XG59O1xuRVRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmludmFsaWRhdGVFbGVtZW50KGVsZXNbaV0pO1xuICB9XG59O1xuRVRDcC5pbnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9va3VwID0gc2VsZi5sb29rdXA7XG4gIHZhciBjYWNoZXMgPSBbXTtcbiAgdmFyIGludmFsaWQgPSBsb29rdXAuaXNJbnZhbGlkKGVsZSk7XG4gIGlmICghaW52YWxpZCkge1xuICAgIHJldHVybjsgLy8gb3ZlcnJpZGUgdGhlIGludmFsaWRhdGlvbiByZXF1ZXN0IGlmIHRoZSBlbGVtZW50IGtleSBoYXMgbm90IGNoYW5nZWRcbiAgfVxuICBmb3IgKHZhciBsdmwgPSBtaW5MdmwkMTsgbHZsIDw9IG1heEx2bCQxOyBsdmwrKykge1xuICAgIHZhciBjYWNoZSA9IGxvb2t1cC5nZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgY2FjaGVzLnB1c2goY2FjaGUpO1xuICAgIH1cbiAgfVxuICB2YXIgbm9PdGhlckVsZXNVc2VDYWNoZSA9IGxvb2t1cC5pbnZhbGlkYXRlKGVsZSk7XG4gIGlmIChub090aGVyRWxlc1VzZUNhY2hlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfY2FjaGUgPSBjYWNoZXNbaV07XG4gICAgICB2YXIgdHhyID0gX2NhY2hlLnRleHR1cmU7XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBmcm9tIHRoZSB0ZXh0dXJlIGl0IGJlbG9uZ3MgdG9cbiAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoICs9IF9jYWNoZS53aWR0aDtcblxuICAgICAgLy8gbWFyayB0aGUgY2FjaGUgYXMgaW52YWxpZGF0ZWRcbiAgICAgIF9jYWNoZS5pbnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICAgIC8vIHJldGlyZSB0aGUgdGV4dHVyZSBpZiBpdHMgdXRpbGl0eSBpcyBsb3dcbiAgICAgIHNlbGYuY2hlY2tUZXh0dXJlVXRpbGl0eSh0eHIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBmcm9tIHF1ZXVlIHNpbmNlIHRoZSBvbGQgcmVxIHdhcyBmb3IgdGhlIG9sZCBzdGF0ZVxuICBzZWxmLnJlbW92ZUZyb21RdWV1ZShlbGUpO1xufTtcbkVUQ3AuY2hlY2tUZXh0dXJlVXRpbGl0eSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgaWYgKHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGgpIHtcbiAgICB0aGlzLnJldGlyZVRleHR1cmUodHhyKTtcbiAgfVxufTtcbkVUQ3AuY2hlY2tUZXh0dXJlRnVsbG5lc3MgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGlmIHRleHR1cmUgaGFzIGJlZW4gbW9zdGx5IGZpbGxlZCBhbmQgcGFzc2VkIG92ZXIgc2V2ZXJhbCB0aW1lcywgcmVtb3ZlXG4gIC8vIGl0IGZyb20gdGhlIHF1ZXVlIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FzdGUgdGltZSBsb29raW5nIGF0IGl0IHRvIHB1dCBuZXcgdGhpbmdzXG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ci5oZWlnaHQpO1xuICBpZiAodHhyLnVzZWRXaWR0aCAvIHR4ci53aWR0aCA+IG1heEZ1bGxuZXNzICYmIHR4ci5mdWxsbmVzc0NoZWNrcyA+PSBtYXhGdWxsbmVzc0NoZWNrcykge1xuICAgIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB9IGVsc2Uge1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICB9XG59O1xuRVRDcC5yZXRpcmVUZXh0dXJlID0gZnVuY3Rpb24gKHR4cikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJIID0gdHhyLmhlaWdodDtcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIGxvb2t1cCA9IHRoaXMubG9va3VwO1xuXG4gIC8vIHJldGlyZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSBhY3RpdmUgLyBzZWFyY2hhYmxlIHF1ZXVlOlxuXG4gIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB0eHIucmV0aXJlZCA9IHRydWU7XG5cbiAgLy8gcmVtb3ZlIHRoZSByZWZzIGZyb20gdGhlIGVsZXMgdG8gdGhlIGNhY2hlczpcblxuICB2YXIgZWxlQ2FjaGVzID0gdHhyLmVsZUNhY2hlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlQ2FjaGUgPSBlbGVDYWNoZXNbaV07XG4gICAgbG9va3VwLmRlbGV0ZUNhY2hlKGVsZUNhY2hlLmtleSwgZWxlQ2FjaGUubGV2ZWwpO1xuICB9XG4gIGNsZWFyQXJyYXkoZWxlQ2FjaGVzKTtcblxuICAvLyBhZGQgdGhlIHRleHR1cmUgdG8gYSByZXRpcmVkIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWN5Y2xlZCBpbiBmdXR1cmU6XG5cbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgcnR4dHJRLnB1c2godHhyKTtcbn07XG5FVENwLmFkZFRleHR1cmUgPSBmdW5jdGlvbiAodHhySCwgbWluVykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciB0eHIgPSB7fTtcbiAgdHhyUS5wdXNoKHR4cik7XG4gIHR4ci5lbGVDYWNoZXMgPSBbXTtcbiAgdHhyLmhlaWdodCA9IHR4ckg7XG4gIHR4ci53aWR0aCA9IE1hdGgubWF4KGRlZlR4cldpZHRoLCBtaW5XKTtcbiAgdHhyLnVzZWRXaWR0aCA9IDA7XG4gIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgdHhyLmNhbnZhcyA9IHNlbGYucmVuZGVyZXIubWFrZU9mZnNjcmVlbkNhbnZhcyh0eHIud2lkdGgsIHR4ci5oZWlnaHQpO1xuICB0eHIuY29udGV4dCA9IHR4ci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgcmV0dXJuIHR4cjtcbn07XG5FVENwLnJlY3ljbGVUZXh0dXJlID0gZnVuY3Rpb24gKHR4ckgsIG1pblcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ0eHRyUS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eHIgPSBydHh0clFbaV07XG4gICAgaWYgKHR4ci53aWR0aCA+PSBtaW5XKSB7XG4gICAgICB0eHIucmV0aXJlZCA9IGZhbHNlO1xuICAgICAgdHhyLnVzZWRXaWR0aCA9IDA7XG4gICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gICAgICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuICAgICAgY2xlYXJBcnJheSh0eHIuZWxlQ2FjaGVzKTtcbiAgICAgIHR4ci5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHR4ci5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0eHIud2lkdGgsIHR4ci5oZWlnaHQpO1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KHJ0eHRyUSwgdHhyKTtcbiAgICAgIHR4clEucHVzaCh0eHIpO1xuICAgICAgcmV0dXJuIHR4cjtcbiAgICB9XG4gIH1cbn07XG5FVENwLnF1ZXVlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGx2bCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gIHZhciBleGlzdGluZ1JlcSA9IGsycVtrZXldO1xuICBpZiAoZXhpc3RpbmdSZXEpIHtcbiAgICAvLyB1c2UgdGhlIG1heCBsdmwgYi9jIGluIGJldHdlZW4gbHZscyBhcmUgY2hlYXAgdG8gbWFrZVxuICAgIGV4aXN0aW5nUmVxLmxldmVsID0gTWF0aC5tYXgoZXhpc3RpbmdSZXEubGV2ZWwsIGx2bCk7XG4gICAgZXhpc3RpbmdSZXEuZWxlcy5tZXJnZShlbGUpO1xuICAgIGV4aXN0aW5nUmVxLnJlcXMrKztcbiAgICBxLnVwZGF0ZUl0ZW0oZXhpc3RpbmdSZXEpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXEgPSB7XG4gICAgICBlbGVzOiBlbGUuc3Bhd24oKS5tZXJnZShlbGUpLFxuICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgIHJlcXM6IDEsXG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gICAgcS5wdXNoKHJlcSk7XG4gICAgazJxW2tleV0gPSByZXE7XG4gIH1cbn07XG5FVENwLmRlcXVldWUgPSBmdW5jdGlvbiAocHhSYXRpbyAvKiwgZXh0ZW50Ki8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBkZXF1ZXVlZCA9IFtdO1xuICB2YXIgbG9va3VwID0gc2VsZi5sb29rdXA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGVxU2l6ZSQxOyBpKyspIHtcbiAgICBpZiAocS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgcmVxID0gcS5wb3AoKTtcbiAgICAgIHZhciBrZXkgPSByZXEua2V5O1xuICAgICAgdmFyIGVsZSA9IHJlcS5lbGVzWzBdOyAvLyBhbGwgZWxlcyBoYXZlIHRoZSBzYW1lIGtleVxuICAgICAgdmFyIGNhY2hlRXhpc3RzID0gbG9va3VwLmhhc0NhY2hlKGVsZSwgcmVxLmxldmVsKTtcblxuICAgICAgLy8gY2xlYXIgb3V0IHRoZSBrZXkgdG8gcmVxIGxvb2t1cFxuICAgICAgazJxW2tleV0gPSBudWxsO1xuXG4gICAgICAvLyBkZXF1ZXVlaW5nIGlzbid0IG5lY2Vzc2FyeSB3aXRoIGFuIGV4aXN0aW5nIGNhY2hlXG4gICAgICBpZiAoY2FjaGVFeGlzdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkZXF1ZXVlZC5wdXNoKHJlcSk7XG4gICAgICB2YXIgYmIgPSBzZWxmLmdldEJvdW5kaW5nQm94KGVsZSk7XG4gICAgICBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgcmVxLmxldmVsLCBnZXRUeHJSZWFzb25zLmRlcXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlcXVldWVkO1xufTtcbkVUQ3AucmVtb3ZlRnJvbVF1ZXVlID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gIHZhciByZXEgPSBrMnFba2V5XTtcbiAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgaWYgKHJlcS5lbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gcmVtb3ZlIGlmIGxhc3QgZWxlIGluIHRoZSByZXFcbiAgICAgIC8vIGJyaW5nIHRvIGZyb250IG9mIHF1ZXVlXG4gICAgICByZXEucmVxcyA9IE1BWF9JTlQkMTtcbiAgICAgIHEudXBkYXRlSXRlbShyZXEpO1xuICAgICAgcS5wb3AoKTsgLy8gcmVtb3ZlIGZyb20gcXVldWVcblxuICAgICAgazJxW2tleV0gPSBudWxsOyAvLyByZW1vdmUgZnJvbSBsb29rdXAgbWFwXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHJlbW92ZSBlbGUgZnJvbSByZXFcbiAgICAgIHJlcS5lbGVzLnVubWVyZ2UoZWxlKTtcbiAgICB9XG4gIH1cbn07XG5FVENwLm9uRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLm9uRGVxdWV1ZXMucHVzaChmbik7XG59O1xuRVRDcC5vZmZEZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlbW92ZUZyb21BcnJheSh0aGlzLm9uRGVxdWV1ZXMsIGZuKTtcbn07XG5FVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQkMSxcbiAgZGVxQ29zdDogZGVxQ29zdCQxLFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0JDEsXG4gIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QkMSxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0JDEsXG4gIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIHJldHVybiBzZWxmLmRlcXVldWUocHhSYXRpbywgZXh0ZW50KTtcbiAgfSxcbiAgb25EZXFkOiBmdW5jdGlvbiBvbkRlcWQoc2VsZiwgZGVxZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5vbkRlcXVldWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSBzZWxmLm9uRGVxdWV1ZXNbaV07XG4gICAgICBmbihkZXFkKTtcbiAgICB9XG4gIH0sXG4gIHNob3VsZFJlZHJhdzogZnVuY3Rpb24gc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVxZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZXMgPSBkZXFkW2ldLmVsZXM7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGJiID0gZWxlc1tqXS5ib3VuZGluZ0JveCgpO1xuICAgICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZVR4ckRlcTtcbiAgfVxufSk7XG5cbnZhciBkZWZOdW1MYXllcnMgPSAxOyAvLyBkZWZhdWx0IG51bWJlciBvZiBsYXllcnMgdG8gdXNlXG52YXIgbWluTHZsID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxudmFyIG1heEx2bCA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcbnZhciBtYXhab29tID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSA1MDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcbnZhciByZWZpbmVFbGVEZWJvdW5jZVRpbWUgPSA1MDsgLy8gdGltZSB0byBkZWJvdW5jZSBzaGFycGVyIGVsZSB0ZXh0dXJlIHVwZGF0ZXNcbnZhciBkZXFDb3N0ID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG52YXIgZGVxQXZnQ29zdCA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcbnZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xudmFyIGRlcUZhc3RDb3N0ID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xudmFyIG1heERlcVNpemUgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxudmFyIGludmFsaWRUaHJlc2hvbGQgPSAyNTA7IC8vIHRpbWUgdGhyZXNob2xkIGZvciBkaXNhYmxpbmcgYi9jIG9mIGludmFsaWRhdGlvbnNcbnZhciBtYXhMYXllckFyZWEgPSA0MDAwICogNDAwMDsgLy8gbGF5ZXJzIGNhbid0IGJlIGJpZ2dlciB0aGFuIHRoaXNcbnZhciBtYXhMYXllckRpbSA9IDMyNzY3OyAvLyBtYXhpbXVtIHNpemUgZm9yIHRoZSB3aWR0aC9oZWlnaHQgb2YgbGF5ZXIgY2FudmFzZXNcbnZhciB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIHVzZSBoaWdoIHF1YWxpdHkgZWxlIHR4ciByZXF1ZXN0cyAoZ2VuZXJhbGx5IGZhc3RlciBhbmQgY2hlYXBlciBpbiB0aGUgbG9uZ3Rlcm0pXG5cbi8vIHZhciBsb2cgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7IH07XG5cbnZhciBMYXllcmVkVGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gTGF5ZXJlZFRleHR1cmVDYWNoZShyZW5kZXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB2YXIgY3kgPSByLmN5O1xuICBzZWxmLmxheWVyc0J5TGV2ZWwgPSB7fTsgLy8gZS5nLiAyID0+IFsgbGF5ZXIxLCBsYXllcjIsIC4uLiwgbGF5ZXJOIF1cblxuICBzZWxmLmZpcnN0R2V0ID0gdHJ1ZTtcbiAgc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSAyICogaW52YWxpZFRocmVzaG9sZDtcbiAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICBzZWxmLmVsZVR4ckRlcXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIHNlbGYuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnJlZmluZUVsZW1lbnRUZXh0dXJlcyhzZWxmLmVsZVR4ckRlcXMpO1xuICAgIHNlbGYuZWxlVHhyRGVxcy51bm1lcmdlKHNlbGYuZWxlVHhyRGVxcyk7XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSk7XG4gIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uICh3aWxsRHJhdywgbm93KSB7XG4gICAgaWYgKG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCkge1xuICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJTa2lwKTtcbiAgdmFyIHFTb3J0ID0gZnVuY3Rpb24gcVNvcnQoYSwgYikge1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH07XG4gIHNlbGYubGF5ZXJzUXVldWUgPSBuZXcgSGVhcChxU29ydCk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xudmFyIExUQ3AgPSBMYXllcmVkVGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5MVENwLm1ha2VMYXllciA9IGZ1bmN0aW9uIChiYiwgbHZsKSB7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciB3ID0gTWF0aC5jZWlsKGJiLncgKiBzY2FsZSk7XG4gIHZhciBoID0gTWF0aC5jZWlsKGJiLmggKiBzY2FsZSk7XG4gIHZhciBjYW52YXMgPSB0aGlzLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModywgaCk7XG4gIHZhciBsYXllciA9IHtcbiAgICBpZDogbGF5ZXJJZFBvb2wgPSArK2xheWVySWRQb29sICUgTUFYX0lOVCxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07XG5cbiAgLy8gbG9nKCdtYWtlIGxheWVyICVzIHdpdGggdyAlcyBhbmQgaCAlcyBhbmQgbHZsICVzJywgbGF5ZXIuaWQsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQsIGxheWVyLmxldmVsKTtcblxuICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICB2YXIgZHkgPSAtbGF5ZXIuYmIueTE7XG5cbiAgLy8gZG8gdGhlIHRyYW5zZm9ybSBvbiBjcmVhdGlvbiB0byBzYXZlIGN5Y2xlcyAoaXQncyB0aGUgc2FtZSBmb3IgYWxsIGVsZXMpXG4gIGN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICBjeHQudHJhbnNsYXRlKGR4LCBkeSk7XG4gIHJldHVybiBsYXllcjtcbn07XG5MVENwLmdldExheWVycyA9IGZ1bmN0aW9uIChlbGVzLCBweFJhdGlvLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZmlyc3RHZXQgPSBzZWxmLmZpcnN0R2V0O1xuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7XG5cbiAgLy8gbG9nKCctLVxcbmdldCBsYXllcnMgd2l0aCAlcyBlbGVzJywgZWxlcy5sZW5ndGgpO1xuICAvL2xvZyBlbGVzLm1hcChmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmlkKCkgfSkgKTtcblxuICBpZiAobHZsID09IG51bGwpIHtcbiAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuICAgIGlmIChsdmwgPCBtaW5MdmwpIHtcbiAgICAgIGx2bCA9IG1pbkx2bDtcbiAgICB9IGVsc2UgaWYgKHpvb20gPj0gbWF4Wm9vbSB8fCBsdmwgPiBtYXhMdmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGx2bCwgZWxlcyk7XG4gIHZhciBsYXllcnNCeUx2bCA9IHNlbGYubGF5ZXJzQnlMZXZlbDtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGxheWVycyA9IGxheWVyc0J5THZsW2x2bF0gPSBsYXllcnNCeUx2bFtsdmxdIHx8IFtdO1xuICB2YXIgYmI7XG4gIHZhciBsdmxDb21wbGV0ZSA9IHNlbGYubGV2ZWxJc0NvbXBsZXRlKGx2bCwgZWxlcyk7XG4gIHZhciB0bXBMYXllcnM7XG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbiBjaGVja1RlbXBMZXZlbHMoKSB7XG4gICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24gY2FuVXNlQXNUbXBMdmwobCkge1xuICAgICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsLCBlbGVzKTtcbiAgICAgIGlmIChzZWxmLmxldmVsSXNDb21wbGV0ZShsLCBlbGVzKSkge1xuICAgICAgICB0bXBMYXllcnMgPSBsYXllcnNCeUx2bFtsXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2hlY2tMdmxzID0gZnVuY3Rpb24gY2hlY2tMdmxzKGRpcikge1xuICAgICAgaWYgKHRtcExheWVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBsID0gbHZsICsgZGlyOyBtaW5MdmwgPD0gbCAmJiBsIDw9IG1heEx2bDsgbCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGNhblVzZUFzVG1wTHZsKGwpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrTHZscygxKTtcbiAgICBjaGVja0x2bHMoLTEpO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG4gICAgZm9yICh2YXIgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKCFsdmxDb21wbGV0ZSkge1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuXG4gICAgY2hlY2tUZW1wTGV2ZWxzKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbG9nKCdsZXZlbCBjb21wbGV0ZSwgdXNpbmcgZXhpc3RpbmcgbGF5ZXJzXFxuLS0nKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG4gIHZhciBnZXRCYiA9IGZ1bmN0aW9uIGdldEJiKCkge1xuICAgIGlmICghYmIpIHtcbiAgICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlQm91bmRpbmdCb3goYmIsIGVsZXNbaV0uYm91bmRpbmdCb3goKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYjtcbiAgfTtcbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uIG1ha2VMYXllcihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGFmdGVyID0gb3B0cy5hZnRlcjtcbiAgICBnZXRCYigpO1xuICAgIHZhciB3ID0gTWF0aC5jZWlsKGJiLncgKiBzY2FsZSk7XG4gICAgdmFyIGggPSBNYXRoLmNlaWwoYmIuaCAqIHNjYWxlKTtcbiAgICBpZiAodyA+IG1heExheWVyRGltIHx8IGggPiBtYXhMYXllckRpbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhcmVhID0gdyAqIGg7XG4gICAgaWYgKGFyZWEgPiBtYXhMYXllckFyZWEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbGF5ZXIgPSBzZWxmLm1ha2VMYXllcihiYiwgbHZsKTtcbiAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ID0gbGF5ZXJzLmluZGV4T2YoYWZ0ZXIpICsgMTtcbiAgICAgIGxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgb3B0cy5pbnNlcnQpIHtcbiAgICAgIC8vIG5vIGFmdGVyIHNwZWNpZmllZCA9PiBmaXJzdCBsYXllciBtYWRlIHNvIHB1dCBhdCBzdGFydFxuICAgICAgbGF5ZXJzLnVuc2hpZnQobGF5ZXIpO1xuICAgIH1cblxuICAgIC8vIGlmKCB0bXBMYXllcnMgKXtcbiAgICAvL3NlbGYucXVldWVMYXllciggbGF5ZXIgKTtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH07XG4gIGlmIChzZWxmLnNraXBwaW5nICYmICFmaXJzdEdldCkge1xuICAgIC8vIGxvZygnc2tpcCBsYXllcnMnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGxvZygnZG8gbGF5ZXJzJyk7XG5cbiAgdmFyIGxheWVyID0gbnVsbDtcbiAgdmFyIG1heEVsZXNQZXJMYXllciA9IGVsZXMubGVuZ3RoIC8gZGVmTnVtTGF5ZXJzO1xuICB2YXIgYWxsb3dMYXp5UXVldWVpbmcgPSAhZmlyc3RHZXQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgIC8vIGxvZygnbG9vayBhdCBlbGUnLCBlbGUuaWQoKSk7XG5cbiAgICB2YXIgZXhpc3RpbmdMYXllciA9IGNhY2hlc1tsdmxdO1xuICAgIGlmIChleGlzdGluZ0xheWVyKSB7XG4gICAgICAvLyByZXVzZSBsYXllciBmb3IgbGF0ZXIgZWxlc1xuICAgICAgLy8gbG9nKCdyZXVzZSBsYXllciBmb3InLCBlbGUuaWQoKSk7XG4gICAgICBsYXllciA9IGV4aXN0aW5nTGF5ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFsYXllciB8fCBsYXllci5lbGVzLmxlbmd0aCA+PSBtYXhFbGVzUGVyTGF5ZXIgfHwgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChsYXllci5iYiwgZWxlLmJvdW5kaW5nQm94KCkpKSB7XG4gICAgICAvLyBsb2coJ21ha2UgbmV3IGxheWVyIGZvciBlbGUgJXMnLCBlbGUuaWQoKSk7XG5cbiAgICAgIGxheWVyID0gbWFrZUxheWVyKHtcbiAgICAgICAgaW5zZXJ0OiB0cnVlLFxuICAgICAgICBhZnRlcjogbGF5ZXJcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBub3cgbGF5ZXIgY2FuIGJlIGJ1aWx0IHRoZW4gd2UgY2FuJ3QgdXNlIGxheWVycyBhdCB0aGlzIGxldmVsXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2coJ25ldyBsYXllciB3aXRoIGlkICVzJywgbGF5ZXIuaWQpO1xuICAgIH1cbiAgICBpZiAodG1wTGF5ZXJzIHx8IGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgICAvLyBsb2coJ3F1ZXVlIGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLnF1ZXVlTGF5ZXIobGF5ZXIsIGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pO1xuICAgIH1cbiAgICBsYXllci5lbGVzLnB1c2goZWxlKTtcbiAgICBjYWNoZXNbbHZsXSA9IGxheWVyO1xuICB9XG5cbiAgLy8gbG9nKCctLScpO1xuXG4gIGlmICh0bXBMYXllcnMpIHtcbiAgICAvLyB0aGVuIHdlIG9ubHkgcXVldWVkIHRoZSBjdXJyZW50IGxheWVyc2V0IGFuZCBjYW4ndCBkcmF3IGl0IHlldFxuICAgIHJldHVybiB0bXBMYXllcnM7XG4gIH1cbiAgaWYgKGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgLy8gbG9nKCdsYXp5IHF1ZXVlIGxldmVsJywgbHZsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbGF5ZXJzO1xufTtcblxuLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3Ncbi8vIHNvIHRoZSBsYXllciBsZXZlbCBtaWdodCBub3QgZXF1YWwgdGhlIGVsZSBsZXZlbFxuTFRDcC5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwgPSBmdW5jdGlvbiAobHZsLCBweFJhdGlvKSB7XG4gIHJldHVybiBsdmw7XG59O1xuTFRDcC5kcmF3RWxlSW5MYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHZhciBjb250ZXh0ID0gbGF5ZXIuY29udGV4dDtcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbHZsID0gc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobHZsLCBweFJhdGlvKTtcbiAge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgfVxuICB7XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIG51bGwsIG51bGwsIGx2bCwgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzKTtcbiAgfVxuICB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gIH1cbn07XG5MVENwLmxldmVsSXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2x2bF07XG4gIGlmICghbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIG51bUVsZXNJbkxheWVycyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIGFueSBlbGVzIG5lZWRlZCB0byBiZSBkcmF3biB5ZXQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcbiAgICBpZiAobGF5ZXIucmVxcyA+IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbGF5ZXIgaXMgaW52YWxpZCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG51bUVsZXNJbkxheWVycyArPSBsYXllci5lbGVzLmxlbmd0aDtcbiAgfVxuXG4gIC8vIHdlIHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIG51bWJlciBvZiBlbGVzIHBhc3NlZCBpbiB0byBiZSBjb21wbGV0ZVxuICBpZiAobnVtRWxlc0luTGF5ZXJzICE9PSBlbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5MVENwLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG4gIGlmICghbGF5ZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgaW4gYSBsYXllciB0aGUgZWxlcyBhcmUgbm90IGluIHRoZSBzYW1lIG9yZGVyLCB0aGVuIHRoZSBsYXllciBpcyBpbnZhbGlkXG4gIC8vIChpLmUuIHRoZXJlIGlzIGFuIGVsZSBpbiBiZXR3ZWVuIHRoZSBlbGVzIGluIHRoZSBsYXllcilcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICB2YXIgb2Zmc2V0ID0gLTE7XG5cbiAgICAvLyBmaW5kIHRoZSBvZmZzZXRcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzWzBdID09PSBlbGVzW2pdKSB7XG4gICAgICAgIG9mZnNldCA9IGo7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0ZW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIgbXVzdCBiZSBpbiB0aGUgc2FtZSBjb250aW51b3VzIG9yZGVyLCBlbHNlIHRoZSBsYXllciBpcyBpbnZhbGlkXG5cbiAgICB2YXIgbyA9IG9mZnNldDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyLmVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzW2pdICE9PSBlbGVzW28gKyBqXSkge1xuICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5MVENwLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlzRWxlcyA9IGVsZW1lbnQoZWxlc1swXSk7XG5cbiAgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAvLyBsYXllciBpdHNlbGYgYWxvbmcgdGhlIHdheVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG4gICAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgICAgdmFyIGxheWVyID0gY2FjaGVzW2xdO1xuICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdXBkYXRlIGlzIGEgcmVxdWVzdCBmcm9tIHRoZSBlbGUgY2FjaGUsIHRoZW4gaXQgYWZmZWN0cyBvbmx5XG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgbGV2ZWxcbiAgICAgIGlmIChyZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobGF5ZXIubGV2ZWwpICE9PSByZXEubGV2ZWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB1cGRhdGUobGF5ZXIsIGVsZSwgcmVxKTtcbiAgICB9XG4gIH1cbn07XG5MVENwLmhhdmVMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcbiAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbF07XG4gICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhdmVMYXllcnM7XG59O1xuTFRDcC5pbnZhbGlkYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUgZnJvbSBlbGVzJyk7XG5cbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwIHx8ICFzZWxmLmhhdmVMYXllcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gaW52YWxBc3NvY0xheWVycyhsYXllciwgZWxlLCByZXEpIHtcbiAgICBzZWxmLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gIH0pO1xufTtcbkxUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuXG4gIHRoaXMubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBzYXZlIGN5Y2xlc1xuXG4gIHZhciBsdmwgPSBsYXllci5sZXZlbDtcbiAgdmFyIGVsZXMgPSBsYXllci5lbGVzO1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgLy8gbG9nKCdpbnZhbGlkYXRlIGxheWVyJywgbGF5ZXIuaWQgKTtcblxuICByZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7XG4gIC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICBsYXllci5lbGVzUXVldWUgPSBbXTtcbiAgbGF5ZXIuaW52YWxpZCA9IHRydWU7XG4gIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjYWNoZXMgPSBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmltZ0xheWVyQ2FjaGVzO1xuICAgIGlmIChjYWNoZXMpIHtcbiAgICAgIGNhY2hlc1tsdmxdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBsb2coJ3JlZmluZScsIGVsZXMubGVuZ3RoKTtcblxuICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gcmVmaW5lRWFjaEVsZShsYXllciwgZWxlLCByZXEpIHtcbiAgICB2YXIgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50O1xuICAgIGlmICghckx5cikge1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7XG5cbiAgICAgIC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG4gICAgaWYgKCFyTHlyLnJlcXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgckx5ci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucXVldWVMYXllcihyTHlyLCByTHlyLmVsZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2coJ3F1ZXVlIHJlcGxhY2VtZW50IGxheWVyIHJlZmluZW1lbnQnLCByTHlyLmlkKTtcbiAgICB9XG4gIH0pO1xufTtcbkxUQ3AuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuICB0aGlzLmVsZVR4ckRlcXMubWVyZ2UoZWxlKTtcbiAgdGhpcy5zY2hlZHVsZUVsZW1lbnRSZWZpbmVtZW50KCk7XG59O1xuTFRDcC5xdWV1ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyLCBlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBlbGVzUSA9IGxheWVyLmVsZXNRdWV1ZTtcbiAgdmFyIGhhc0lkID0gZWxlc1EuaGFzSWQgPSBlbGVzUS5oYXNJZCB8fCB7fTtcblxuICAvLyBpZiBhIGxheWVyIGlzIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBxdWV1aW5nIGlzIGEgd2FzdGUgb2YgdGltZVxuICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZSkge1xuICAgIGlmIChoYXNJZFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlc1EucHVzaChlbGUpO1xuICAgIGhhc0lkW2VsZS5pZCgpXSA9IHRydWU7XG4gIH1cbiAgaWYgKGxheWVyLnJlcXMpIHtcbiAgICBsYXllci5yZXFzKys7XG4gICAgcS51cGRhdGVJdGVtKGxheWVyKTtcbiAgfSBlbHNlIHtcbiAgICBsYXllci5yZXFzID0gMTtcbiAgICBxLnB1c2gobGF5ZXIpO1xuICB9XG59O1xuTFRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBkZXFkID0gW107XG4gIHZhciBlbGVEZXFzID0gMDtcbiAgd2hpbGUgKGVsZURlcXMgPCBtYXhEZXFTaXplKSB7XG4gICAgaWYgKHEuc2l6ZSgpID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGxheWVyID0gcS5wZWVrKCk7XG5cbiAgICAvLyBpZiBhIGxheWVyIGhhcyBiZWVuIG9yIHdpbGwgYmUgcmVwbGFjZWQsIHRoZW4gZG9uJ3Qgd2FzdGUgdGltZSB3aXRoIGl0XG4gICAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgICAvLyBsb2coJ2xheWVyICVzIGluIHF1ZXVlIHNraXBwZWQgYi9jIGl0IGFscmVhZHkgaGFzIGEgcmVwbGFjZW1lbnQnLCBsYXllci5pZCk7XG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBpcyBhIHJlcGxhY2VtZW50IGxheWVyIHRoYXQgaGFzIGJlZW4gc3VwZXJjZWRlZCwgdGhlbiBmb3JnZXQgaXRcbiAgICBpZiAobGF5ZXIucmVwbGFjZXMgJiYgbGF5ZXIgIT09IGxheWVyLnJlcGxhY2VzLnJlcGxhY2VtZW50KSB7XG4gICAgICAvLyBsb2coJ2xheWVyIGlzIG5vIGxvbmdlciB0aGUgbW9zdCB1cHRvZGF0ZSByZXBsYWNlbWVudDsgZGVxdWV1ZWQnLCBsYXllci5pZClcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgJXMgaXMgaW52YWxpZDsgZGVxdWV1ZWQnLCBsYXllci5pZCk7XG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBlbGUgPSBsYXllci5lbGVzUXVldWUuc2hpZnQoKTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICAvLyBsb2coJ2RlcXVldWUgbGF5ZXIgJXMnLCBsYXllci5pZCk7XG5cbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbGF5ZXIubGV2ZWwsIHB4UmF0aW8pO1xuICAgICAgZWxlRGVxcysrO1xuICAgIH1cbiAgICBpZiAoZGVxZC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgZW50cnkgaW4gZGVxZCB0byBxdWV1ZSByZWRyYXdpbmcgZXRjXG4gICAgICBkZXFkLnB1c2godHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcbiAgICBpZiAobGF5ZXIuZWxlc1F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGxheWVyLnJlcXMgPSAwO1xuXG4gICAgICAvLyBsb2coJ2RlcXVldWUgb2YgbGF5ZXIgJXMgY29tcGxldGUnLCBsYXllci5pZCk7XG5cbiAgICAgIC8vIHdoZW4gYSByZXBsYWNlbWVudCBsYXllciBpcyBkZXF1ZXVlZCwgaXQgcmVwbGFjZXMgdGhlIG9sZCBsYXllciBpbiB0aGUgbGV2ZWxcbiAgICAgIGlmIChsYXllci5yZXBsYWNlcykge1xuICAgICAgICBzZWxmLmFwcGx5TGF5ZXJSZXBsYWNlbWVudChsYXllcik7XG4gICAgICB9XG4gICAgICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlcWQ7XG59O1xuTFRDcC5hcHBseUxheWVyUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGF5ZXJzSW5MZXZlbCA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsYXllci5sZXZlbF07XG4gIHZhciByZXBsYWNlZCA9IGxheWVyLnJlcGxhY2VzO1xuICB2YXIgaW5kZXggPSBsYXllcnNJbkxldmVsLmluZGV4T2YocmVwbGFjZWQpO1xuXG4gIC8vIGlmIHRoZSByZXBsYWNlZCBsYXllciBpcyBub3QgaW4gdGhlIGFjdGl2ZSBsaXN0IGZvciB0aGUgbGV2ZWwsIHRoZW4gcmVwbGFjaW5nXG4gIC8vIHJlZnMgd291bGQgYmUgYSBtaXN0YWtlIChpLmUuIG92ZXJ3cml0aW5nIHRoZSB0cnVlIGFjdGl2ZSBsYXllcilcbiAgaWYgKGluZGV4IDwgMCB8fCByZXBsYWNlZC5pbnZhbGlkKSB7XG4gICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciB3b3VsZCBoYXZlIG5vIGVmZmVjdCcsIGxheWVyLmlkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGF5ZXJzSW5MZXZlbFtpbmRleF0gPSBsYXllcjsgLy8gcmVwbGFjZSBsZXZlbCByZWZcblxuICAvLyByZXBsYWNlIHJlZnMgaW4gZWxlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3AgPSBsYXllci5lbGVzW2ldLl9wcml2YXRlO1xuICAgIHZhciBjYWNoZSA9IF9wLmltZ0xheWVyQ2FjaGVzID0gX3AuaW1nTGF5ZXJDYWNoZXMgfHwge307XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjYWNoZVtsYXllci5sZXZlbF0gPSBsYXllcjtcbiAgICB9XG4gIH1cblxuICAvLyBsb2coJ2FwcGx5IHJlcGxhY2VtZW50IGxheWVyICVzIG92ZXIgJXMnLCBsYXllci5pZCwgcmVwbGFjZWQuaWQpO1xuXG4gIHNlbGYucmVxdWVzdFJlZHJhdygpO1xufTtcbkxUQ3AucmVxdWVzdFJlZHJhdyA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDApO1xuTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkLFxuICBkZXFDb3N0OiBkZXFDb3N0LFxuICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0LFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0LFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QsXG4gIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8pIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8pO1xuICB9LFxuICBvbkRlcWQ6IG5vb3AkMSxcbiAgc2hvdWxkUmVkcmF3OiB0cnVlaWZ5LFxuICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyRGVxO1xuICB9XG59KTtcblxudmFyIENScCRiID0ge307XG52YXIgaW1wbDtcbmZ1bmN0aW9uIHBvbHlnb24oY29udGV4dCwgcG9pbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmlhbmdsZUJhY2tjdXJ2ZShjb250ZXh0LCBwb2ludHMsIGNvbnRyb2xQb2ludCkge1xuICB2YXIgZmlyc3RQdDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICB9XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xufVxuZnVuY3Rpb24gdHJpYW5nbGVUZWUoY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHRlZVBvaW50cykge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgdmFyIHRlZVB0cyA9IHRlZVBvaW50cztcbiAgdmFyIGZpcnN0VGVlUHQgPSB0ZWVQb2ludHNbMF07XG4gIGNvbnRleHQubW92ZVRvKGZpcnN0VGVlUHQueCwgZmlyc3RUZWVQdC55KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0ZWVQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2lyY2xlVHJpYW5nbGUoY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHJ4LCByeSwgcikge1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICB2YXIgZmlyc3RUclB0ID0gdHJpUHRzWzBdO1xuICBjb250ZXh0Lm1vdmVUbyhmaXJzdFRyUHQueCwgZmlyc3RUclB0LnkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59XG5mdW5jdGlvbiBjaXJjbGUkMShjb250ZXh0LCByeCwgcnksIHIpIHtcbiAgY29udGV4dC5hcmMocngsIHJ5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xufVxuQ1JwJGIuYXJyb3dTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gKGltcGwgfHwgKGltcGwgPSB7XG4gICAgJ3BvbHlnb24nOiBwb2x5Z29uLFxuICAgICd0cmlhbmdsZS1iYWNrY3VydmUnOiB0cmlhbmdsZUJhY2tjdXJ2ZSxcbiAgICAndHJpYW5nbGUtdGVlJzogdHJpYW5nbGVUZWUsXG4gICAgJ2NpcmNsZS10cmlhbmdsZSc6IGNpcmNsZVRyaWFuZ2xlLFxuICAgICd0cmlhbmdsZS1jcm9zcyc6IHRyaWFuZ2xlVGVlLFxuICAgICdjaXJjbGUnOiBjaXJjbGUkMVxuICB9KSlbbmFtZV07XG59O1xuXG52YXIgQ1JwJGEgPSB7fTtcbkNScCRhLmRyYXdFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgci5kcmF3Tm9kZShjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0VsZW1lbnRPdmVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5DUnAkYS5kcmF3RWxlbWVudFVuZGVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlVW5kZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfSBlbHNlIHtcbiAgICByLmRyYXdFZGdlVW5kZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcbkNScCRhLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0Um90YXRpb24sIGdldE9wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgYmIgPSBlbGVUeHJDYWNoZS5nZXRCb3VuZGluZ0JveChlbGUpO1xuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlnbm9yZSB6ZXJvIHNpemUgY2FzZVxuXG4gIHZhciBlbGVDYWNoZSA9IGVsZVR4ckNhY2hlLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pO1xuICBpZiAoZWxlQ2FjaGUgIT0gbnVsbCkge1xuICAgIHZhciBvcGFjaXR5ID0gZ2V0T3BhY2l0eShyLCBlbGUpO1xuICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aGV0YSA9IGdldFJvdGF0aW9uKHIsIGVsZSk7XG4gICAgdmFyIHgxID0gYmIueDEsXG4gICAgICB5MSA9IGJiLnkxLFxuICAgICAgdyA9IGJiLncsXG4gICAgICBoID0gYmIuaDtcbiAgICB2YXIgeCwgeSwgc3gsIHN5LCBzbW9vdGg7XG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICB2YXIgcm90UHQgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvblBvaW50KGVsZSk7XG4gICAgICBzeCA9IHJvdFB0Lng7XG4gICAgICBzeSA9IHJvdFB0Lnk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShzeCwgc3kpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgc21vb3RoID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG4gICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmYgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvbk9mZnNldChlbGUpO1xuICAgICAgeCA9IG9mZi54O1xuICAgICAgeSA9IG9mZi55O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geDE7XG4gICAgICB5ID0geTE7XG4gICAgfVxuICAgIHZhciBvbGRHbG9iYWxBbHBoYTtcbiAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgb2xkR2xvYmFsQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9sZEdsb2JhbEFscGhhICogb3BhY2l0eTtcbiAgICB9XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoZWxlQ2FjaGUudGV4dHVyZS5jYW52YXMsIGVsZUNhY2hlLngsIDAsIGVsZUNhY2hlLndpZHRoLCBlbGVDYWNoZS5oZWlnaHQsIHgsIHksIHcsIGgpO1xuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGE7XG4gICAgfVxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1zeCwgLXN5KTtcbiAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWxlVHhyQ2FjaGUuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTsgLy8gZGlyZWN0IGRyYXcgZmFsbGJhY2tcbiAgfVxufTtcbnZhciBnZXRaZXJvUm90YXRpb24gPSBmdW5jdGlvbiBnZXRaZXJvUm90YXRpb24oKSB7XG4gIHJldHVybiAwO1xufTtcbnZhciBnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgbnVsbCk7XG59O1xudmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAnc291cmNlJyk7XG59O1xudmFyIGdldFRhcmdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAndGFyZ2V0Jyk7XG59O1xudmFyIGdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5KHIsIGVsZSkge1xuICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbn07XG52YXIgZ2V0VGV4dE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRUZXh0T3BhY2l0eShlLCBlbGUpIHtcbiAgcmV0dXJuIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnBmVmFsdWUgKiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xufTtcbkNScCRhLmRyYXdDYWNoZWRFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50LCBsdmwsIHJlcXVlc3RIaWdoUXVhbGl0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBfciRkYXRhID0gci5kYXRhLFxuICAgIGVsZVR4ckNhY2hlID0gX3IkZGF0YS5lbGVUeHJDYWNoZSxcbiAgICBsYmxUeHJDYWNoZSA9IF9yJGRhdGEubGJsVHhyQ2FjaGUsXG4gICAgc2xiVHhyQ2FjaGUgPSBfciRkYXRhLnNsYlR4ckNhY2hlLFxuICAgIHRsYlR4ckNhY2hlID0gX3IkZGF0YS50bGJUeHJDYWNoZTtcbiAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG4gIHZhciByZWFzb24gPSByZXF1ZXN0SGlnaFF1YWxpdHkgPT09IHRydWUgPyBlbGVUeHJDYWNoZS5yZWFzb25zLmhpZ2hRdWFsaXR5IDogbnVsbDtcbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWV4dGVudCB8fCBib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcbiAgICByLmRyYXdFbGVtZW50VW5kZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0WmVyb1JvdGF0aW9uLCBnZXRPcGFjaXR5KTtcbiAgICBpZiAoIWlzRWRnZSB8fCAhYmFkTGluZSkge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBsYmxUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICB9XG4gICAgaWYgKGlzRWRnZSAmJiAhYmFkTGluZSkge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBzbGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFNvdXJjZUxhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgdGxiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgfVxuICAgIHIuZHJhd0VsZW1lbnRPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5DUnAkYS5kcmF3RWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcbkNScCRhLmRyYXdDYWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcbkNScCRhLmRyYXdDYWNoZWROb2RlcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0xheWVyZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbGF5ZXJzID0gci5kYXRhLmx5clR4ckNhY2hlLmdldExheWVycyhlbGVzLCBweFJhdGlvKTtcbiAgaWYgKGxheWVycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICB2YXIgYmIgPSBsYXllci5iYjtcbiAgICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShsYXllci5jYW52YXMsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGZhbGwgYmFjayBvbiBwbGFpbiBjYWNoaW5nIGlmIG5vIGxheWVyc1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbnZhciBDUnAkOSA9IHt9O1xuQ1JwJDkuZHJhd0VkZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBpZiAoc2hvdWxkRHJhd09wYWNpdHkgJiYgIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgaWYgKHJzLmJhZExpbmUgfHwgcnMuYWxscHRzID09IG51bGwgfHwgaXNOYU4ocnMuYWxscHRzWzBdKSkge1xuICAgIC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYmI7XG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfVxuICB2YXIgb3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBsaW5lT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gZWRnZS5wc3R5bGUoJ2xpbmUtb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGxpbmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdsaW5lLXN0eWxlJykudmFsdWU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgbGluZUNhcCA9IGVkZ2UucHN0eWxlKCdsaW5lLWNhcCcpLnZhbHVlO1xuICB2YXIgbGluZU91dGxpbmVXaWR0aCA9IGVkZ2UucHN0eWxlKCdsaW5lLW91dGxpbmUtd2lkdGgnKS52YWx1ZTtcbiAgdmFyIGxpbmVPdXRsaW5lQ29sb3IgPSBlZGdlLnBzdHlsZSgnbGluZS1vdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gIHZhciBlZmZlY3RpdmVMaW5lT3BhY2l0eSA9IG9wYWNpdHkgKiBsaW5lT3BhY2l0eTtcbiAgLy8gc2VwYXJhdGUgYXJyb3cgb3BhY2l0eSB3b3VsZCByZXF1aXJlIGFycm93LW9wYWNpdHkgcHJvcGVydHlcbiAgdmFyIGVmZmVjdGl2ZUFycm93T3BhY2l0eSA9IG9wYWNpdHkgKiBsaW5lT3BhY2l0eTtcbiAgdmFyIGRyYXdMaW5lID0gZnVuY3Rpb24gZHJhd0xpbmUoKSB7XG4gICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVmZmVjdGl2ZUxpbmVPcGFjaXR5O1xuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnKSB7XG4gICAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgci5kcmF3RWRnZVRyaWFuZ2xlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCBsaW5lU3R5bGUpO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnOyAvLyByZXNldCBmb3Igb3RoZXIgZHJhd2luZyBmdW5jdGlvbnNcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3TGluZU91dGxpbmUgPSBmdW5jdGlvbiBkcmF3TGluZU91dGxpbmUoKSB7XG4gICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVmZmVjdGl2ZUxpbmVPcGFjaXR5O1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoICsgbGluZU91dGxpbmVXaWR0aDtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgIGlmIChsaW5lT3V0bGluZVdpZHRoID4gMCkge1xuICAgICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVPdXRsaW5lQ29sb3JbMF0sIGxpbmVPdXRsaW5lQ29sb3JbMV0sIGxpbmVPdXRsaW5lQ29sb3JbMl0sIHN0cm9rZU9wYWNpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyBub3QgZHJhdyBhbnkgbGluZU91dGxpbmVcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnKSB7XG4gICAgICByLmRyYXdFZGdlVHJpYW5nbGVQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgfVxuICB9O1xuICB2YXIgZHJhd092ZXJsYXkgPSBmdW5jdGlvbiBkcmF3T3ZlcmxheSgpIHtcbiAgICBpZiAoIXNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVkZ2UpO1xuICB9O1xuICB2YXIgZHJhd1VuZGVybGF5ID0gZnVuY3Rpb24gZHJhd1VuZGVybGF5KCkge1xuICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgci5kcmF3RWRnZVVuZGVybGF5KGNvbnRleHQsIGVkZ2UpO1xuICB9O1xuICB2YXIgZHJhd0Fycm93cyA9IGZ1bmN0aW9uIGRyYXdBcnJvd3MoKSB7XG4gICAgdmFyIGFycm93T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWZmZWN0aXZlQXJyb3dPcGFjaXR5O1xuICAgIHIuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgYXJyb3dPcGFjaXR5KTtcbiAgfTtcbiAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWRnZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgfTtcbiAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gIHZhciBnaG9zdCA9IGVkZ2UucHN0eWxlKCdnaG9zdCcpLnZhbHVlID09PSAneWVzJztcbiAgaWYgKGdob3N0KSB7XG4gICAgdmFyIGd4ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICB2YXIgZ3kgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgIHZhciBnaG9zdE9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBlZmZlY3RpdmVHaG9zdE9wYWNpdHkgPSBlZmZlY3RpdmVMaW5lT3BhY2l0eSAqIGdob3N0T3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGRyYXdMaW5lKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgZHJhd0Fycm93cyhlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfSBlbHNlIHtcbiAgICBkcmF3TGluZU91dGxpbmUoKTtcbiAgfVxuICBkcmF3VW5kZXJsYXkoKTtcbiAgZHJhd0xpbmUoKTtcbiAgZHJhd0Fycm93cygpO1xuICBkcmF3T3ZlcmxheSgpO1xuICBkcmF3VGV4dCgpO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG52YXIgZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheShvdmVybGF5T3JVbmRlcmxheSkge1xuICBpZiAoIVsnb3ZlcmxheScsICd1bmRlcmxheSddLmluY2x1ZGVzKG92ZXJsYXlPclVuZGVybGF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSkge1xuICAgIGlmICghZWRnZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wYWNpdHkgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItb3BhY2l0eVwiKSkudmFsdWU7XG4gICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBwYWRkaW5nID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXBhZGRpbmdcIikpLnBmVmFsdWU7XG4gICAgdmFyIHdpZHRoID0gMiAqIHBhZGRpbmc7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLWNvbG9yXCIpKS52YWx1ZTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICYmICF1c2VQYXRocykge1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xuICAgIH1cbiAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCAnc29saWQnKTtcbiAgfTtcbn07XG5DUnAkOS5kcmF3RWRnZU92ZXJsYXkgPSBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSgnb3ZlcmxheScpO1xuQ1JwJDkuZHJhd0VkZ2VVbmRlcmxheSA9IGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KCd1bmRlcmxheScpO1xuQ1JwJDkuZHJhd0VkZ2VQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICB2YXIgbGluZURhc2hQYXR0ZXJuID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1wYXR0ZXJuJykucGZWYWx1ZTtcbiAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1vZmZzZXQnKS5wZlZhbHVlO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzLmpvaW4oJyQnKTtcbiAgICB2YXIga2V5TWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleTtcbiAgICBpZiAoa2V5TWF0Y2hlcykge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICB9XG4gIGlmIChjYW52YXNDeHQuc2V0TGluZURhc2gpIHtcbiAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChsaW5lRGFzaFBhdHRlcm4pO1xuICAgICAgICBjYW52YXNDeHQubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhdGhDYWNoZUhpdCAmJiAhcnMuYmFkTGluZSkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG4gICAgY29udGV4dC5tb3ZlVG8ocHRzWzBdLCBwdHNbMV0pO1xuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgKyAxIDwgcHRzLmxlbmd0aDsgX2kgKz0gMikge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKHB0c1tfaV0sIHB0c1tfaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgaWYgKHJzLmlzUm91bmQpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocnMucm91bmRDb3JuZXJzKSxcbiAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgY29ybmVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGRyYXdQcmVwYXJlZFJvdW5kQ29ybmVyKGNvbnRleHQsIGNvcm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbcHRzLmxlbmd0aCAtIDJdLCBwdHNbcHRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAyOyBfaTIgKyAxIDwgcHRzLmxlbmd0aDsgX2kyICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHB0c1tfaTJdLCBwdHNbX2kyICsgMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29udGV4dCA9IGNhbnZhc0N4dDtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICB9XG59O1xuQ1JwJDkuZHJhd0VkZ2VUcmlhbmdsZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzKSB7XG4gIC8vIHVzZSBsaW5lIHN0cm9rZSBzdHlsZSBmb3IgdHJpYW5nbGUgZmlsbCBzdHlsZVxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICBmb3IgKHZhciBpID0gMDsgaSArIDEgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdmVjdG9yID0gW3B0c1tpICsgMl0gLSBwdHNbaV0sIHB0c1tpICsgM10gLSBwdHNbaSArIDFdXTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KHZlY3RvclswXSAqIHZlY3RvclswXSArIHZlY3RvclsxXSAqIHZlY3RvclsxXSk7XG4gICAgdmFyIG5vcm1hbCA9IFt2ZWN0b3JbMV0gLyBsZW5ndGgsIC12ZWN0b3JbMF0gLyBsZW5ndGhdO1xuICAgIHZhciB0cmlhbmdsZUhlYWQgPSBbbm9ybWFsWzBdICogZWRnZVdpZHRoIC8gMiwgbm9ybWFsWzFdICogZWRnZVdpZHRoIC8gMl07XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhwdHNbaV0gLSB0cmlhbmdsZUhlYWRbMF0sIHB0c1tpICsgMV0gLSB0cmlhbmdsZUhlYWRbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHB0c1tpXSArIHRyaWFuZ2xlSGVhZFswXSwgcHRzW2kgKyAxXSArIHRyaWFuZ2xlSGVhZFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocHRzW2kgKyAyXSwgcHRzW2kgKyAzXSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxufTtcbkNScCQ5LmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIG9wYWNpdHkpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcbiAgaWYgKCFpc0hheXN0YWNrKSB7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdzb3VyY2UnLCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHJzLnNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuICB9XG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgaWYgKCFpc0hheXN0YWNrKSB7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICd0YXJnZXQnLCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgcnMudGd0QXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIH1cbn07XG5DUnAkOS5kcmF3QXJyb3doZWFkID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHByZWZpeCwgeCwgeSwgYW5nbGUsIG9wYWNpdHkpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IHggPT0gbnVsbCB8fCBpc05hTih5KSB8fCB5ID09IG51bGwgfHwgaXNOYU4oYW5nbGUpIHx8IGFuZ2xlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgaWYgKGFycm93U2hhcGUgPT09ICdub25lJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXJyb3dDbGVhckZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZSA9PT0gJ2hvbGxvdycgPyAnYm90aCcgOiAnZmlsbGVkJztcbiAgdmFyIGFycm93RmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlO1xuICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgdmFyIHBBcnJvd1dpZHRoID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy13aWR0aCcpO1xuICB2YXIgYXJyb3dXaWR0aCA9IHBBcnJvd1dpZHRoLnZhbHVlID09PSAnbWF0Y2gtbGluZScgPyBlZGdlV2lkdGggOiBwQXJyb3dXaWR0aC5wZlZhbHVlO1xuICBpZiAocEFycm93V2lkdGgudW5pdHMgPT09ICclJykgYXJyb3dXaWR0aCAqPSBlZGdlV2lkdGg7XG4gIHZhciBlZGdlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG4gIGlmIChvcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICBvcGFjaXR5ID0gZWRnZU9wYWNpdHk7XG4gIH1cbiAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICBpZiAob3BhY2l0eSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnKSB7XG4gICAgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgYXJyb3dXaWR0aCwgeCwgeSwgYW5nbGUpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWNvbG9yJykudmFsdWU7XG4gIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gIHNlbGYuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBjb250ZXh0LCBhcnJvd0ZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgYXJyb3dXaWR0aCwgeCwgeSwgYW5nbGUpO1xufTtcbkNScCQ5LmRyYXdBcnJvd1NoYXBlID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIGZpbGwsIGVkZ2VXaWR0aCwgc2hhcGUsIHNoYXBlV2lkdGgsIHgsIHksIGFuZ2xlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpICYmIHNoYXBlICE9PSAndHJpYW5nbGUtY3Jvc3MnO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYXRoO1xuICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gIHZhciB0cmFuc2xhdGlvbiA9IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbiAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2VXaWR0aCwgc2NhbGUpO1xuICB2YXIgc2hhcGVJbXBsID0gci5hcnJvd1NoYXBlc1tzaGFwZV07XG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBjYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgPSByLmFycm93UGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5nKHNoYXBlKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZFBhdGggIT0gbnVsbCkge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBjYWNoZWRQYXRoO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBjYWNoZVtrZXldID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgaWYgKCFwYXRoQ2FjaGVIaXQpIHtcbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgLy8gc3RvcmUgaW4gdGhlIHBhdGggY2FjaGUgd2l0aCB2YWx1ZXMgZWFzaWx5IG1hbmlwdWxhdGVkIGxhdGVyXG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCAxLCAwLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCk7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cbiAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG4gIGlmICh1c2VQYXRocykge1xuICAgIC8vIHNldCB0cmFuc2Zvcm0gdG8gYXJyb3cgcG9zaXRpb24vb3JpZW50YXRpb25cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gICAgY29udGV4dC5zY2FsZShzaXplLCBzaXplKTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gJ2ZpbGxlZCcgfHwgZmlsbCA9PT0gJ2JvdGgnKSB7XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsbCA9PT0gJ2hvbGxvdycgfHwgZmlsbCA9PT0gJ2JvdGgnKSB7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaGFwZVdpZHRoIC8gKHVzZVBhdGhzID8gc2l6ZSA6IDEpO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIGlmICh1c2VQYXRocykge1xuICAgIC8vIHJlc2V0IHRyYW5zZm9ybSBieSBhcHBseWluZyBpbnZlcnNlXG4gICAgY29udGV4dC5zY2FsZSgxIC8gc2l6ZSwgMSAvIHNpemUpO1xuICAgIGNvbnRleHQucm90YXRlKC1hbmdsZSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufTtcblxudmFyIENScCQ4ID0ge307XG5DUnAkOC5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpIHtcbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICBpZiAoaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhcm4oZSk7XG4gIH1cbn07XG5DUnAkOC5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBub2RlLCBpbmRleCwgbm9kZU9wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgbm9kZVggPSBwb3MueDtcbiAgdmFyIG5vZGVZID0gcG9zLnk7XG4gIHZhciBzdHlsZU9iaiA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgZ2V0SW5kZXhlZFN0eWxlID0gc3R5bGVPYmouZ2V0SW5kZXhlZFN0eWxlLmJpbmQoc3R5bGVPYmopO1xuICB2YXIgZml0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWZpdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIHJlcGVhdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1yZXBlYXQnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmdYMiA9IG5vZGUucGFkZGluZygpICogMjtcbiAgdmFyIG5vZGVUVyA9IG5vZGVXICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsICd2YWx1ZScsIGluZGV4KSA9PT0gJ2lubmVyJyA/IDAgOiBwYWRkaW5nWDIpO1xuICB2YXIgbm9kZVRIID0gbm9kZUggKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsICd2YWx1ZScsIGluZGV4KSA9PT0gJ2lubmVyJyA/IDAgOiBwYWRkaW5nWDIpO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2xpcCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1jbGlwJywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgc2hvdWxkQ2xpcCA9IGNsaXAgPT09ICdub2RlJztcbiAgdmFyIGltZ09wYWNpdHkgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsICd2YWx1ZScsIGluZGV4KSAqIG5vZGVPcGFjaXR5O1xuICB2YXIgc21vb3RoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZycsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWU7XG4gIGlmIChjb3JuZXJSYWRpdXMgIT09ICdhdXRvJykgY29ybmVyUmFkaXVzID0gbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICB2YXIgaW1nVyA9IGltZy53aWR0aCB8fCBpbWcuY2FjaGVkVztcbiAgdmFyIGltZ0ggPSBpbWcuaGVpZ2h0IHx8IGltZy5jYWNoZWRIO1xuXG4gIC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG4gIGlmIChudWxsID09IGltZ1cgfHwgbnVsbCA9PSBpbWdIKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWdXID0gaW1nLmNhY2hlZFcgPSBpbWcud2lkdGggfHwgaW1nLm9mZnNldFdpZHRoO1xuICAgIGltZ0ggPSBpbWcuY2FjaGVkSCA9IGltZy5oZWlnaHQgfHwgaW1nLm9mZnNldEhlaWdodDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfVxuICB2YXIgdyA9IGltZ1c7XG4gIHZhciBoID0gaW1nSDtcbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVFc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndmFsdWUnLCBpbmRleCkgIT09ICdhdXRvJykge1xuICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3VuaXRzJywgaW5kZXgpID09PSAnJScpIHtcbiAgICAgIGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVEg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIGlmICh3ID09PSAwIHx8IGggPT09IDApIHtcbiAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgfVxuICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH0gZWxzZSBpZiAoZml0ID09PSAnY292ZXInKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgobm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG4gIHZhciB4ID0gbm9kZVggLSBub2RlVFcgLyAyOyAvLyBsZWZ0XG4gIHZhciBwb3NYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1hQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIGlmIChwb3NYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogcG9zWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gcG9zWFBmVmFsO1xuICB9XG4gIHZhciBvZmZYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXgnLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBvZmZYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgaWYgKG9mZlhVbml0cyA9PT0gJyUnKSB7XG4gICAgeCArPSAobm9kZVRXIC0gdykgKiBvZmZYUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeCArPSBvZmZYUGZWYWw7XG4gIH1cbiAgdmFyIHkgPSBub2RlWSAtIG5vZGVUSCAvIDI7IC8vIHRvcFxuICB2YXIgcG9zWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBwb3NZUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICdwZlZhbHVlJywgaW5kZXgpO1xuICBpZiAocG9zWVVuaXRzID09PSAnJScpIHtcbiAgICB5ICs9IChub2RlVEggLSBoKSAqIHBvc1lQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB5ICs9IHBvc1lQZlZhbDtcbiAgfVxuICB2YXIgb2ZmWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIGlmIChvZmZZVW5pdHMgPT09ICclJykge1xuICAgIHkgKz0gKG5vZGVUSCAtIGgpICogb2ZmWVBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHkgKz0gb2ZmWVBmVmFsO1xuICB9XG4gIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICB4IC09IG5vZGVYO1xuICAgIHkgLT0gbm9kZVk7XG4gICAgbm9kZVggPSAwO1xuICAgIG5vZGVZID0gMDtcbiAgfVxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG4gIHZhciBzbW9vdGhpbmdFbmFibGVkID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG4gIHZhciBpc1Ntb290aGluZ1N3aXRjaGVkID0gZmFsc2U7XG4gIGlmIChzbW9vdGggPT09ICdubycgJiYgc21vb3RoaW5nRW5hYmxlZCkge1xuICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICBpc1Ntb290aGluZ1N3aXRjaGVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzbW9vdGggPT09ICd5ZXMnICYmICFzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IHRydWU7XG4gIH1cbiAgaWYgKHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgICAgIGNvbnRleHQuY2xpcChycy5wYXRoQ2FjaGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgci5zYWZlRHJhd0ltYWdlKGNvbnRleHQsIGltZywgMCwgMCwgaW1nVywgaW1nSCwgeCwgeSwgdywgaCk7XG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRILCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG4gIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG4gIGlmIChpc1Ntb290aGluZ1N3aXRjaGVkKSB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgc21vb3RoaW5nRW5hYmxlZCk7XG4gIH1cbn07XG5cbnZhciBDUnAkNyA9IHt9O1xuQ1JwJDcuZWxlVGV4dEJpZ2dlclRoYW5NaW4gPSBmdW5jdGlvbiAoZWxlLCBzY2FsZSkge1xuICBpZiAoIXNjYWxlKSB7XG4gICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG4gICAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTsgLy8gdGhlIGVmZmVjdGl2ZSB0ZXh0dXJlIGxldmVsXG5cbiAgICBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIH1cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKiBzY2FsZTtcbiAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCdtaW4tem9vbWVkLWZvbnQtc2l6ZScpLnBmVmFsdWU7XG4gIGlmIChjb21wdXRlZFNpemUgPCBtaW5TaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbkNScCQ3LmRyYXdFbGVtZW50VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGZvcmNlLCBwcmVmaXgpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICBpZiAodXNlRWxlT3BhY2l0eSAmJiAhci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcmNlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcbiAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIganVzdGlmaWNhdGlvbiA9IHIuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSBqdXN0aWZpY2F0aW9uO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG4gICAgdmFyIF9sYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG4gICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSgnc291cmNlLWxhYmVsJyk7XG4gICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJyk7XG4gICAgaWYgKGJhZExpbmUgfHwgKCFfbGFiZWwgfHwgIV9sYWJlbC52YWx1ZSkgJiYgKCFzcmNMYWJlbCB8fCAhc3JjTGFiZWwudmFsdWUpICYmICghdGd0TGFiZWwgfHwgIXRndExhYmVsLnZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH1cbiAgdmFyIGFwcGx5Um90YXRpb24gPSAhc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgdmFyIGJiO1xuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIG51bGwsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAnc291cmNlJywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3RhcmdldCcsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgcHJlZml4LCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgfVxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5DUnAkNy5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgY2FjaGU7XG4gIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuICBjYWNoZSA9IHtcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHRoaXMuZm9udENhY2hlcy5wdXNoKGNhY2hlKTtcbiAgcmV0dXJuIGNhY2hlO1xufTtcblxuLy8gc2V0IHVwIGNhbnZhcyBjb250ZXh0IHdpdGggZm9udFxuLy8gcmV0dXJucyB0cmFuc2Zvcm1lZCB0ZXh0IHN0cmluZ1xuQ1JwJDcuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAvLyBGb250IHN0eWxlXG4gIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgKiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1vcGFjaXR5JykudmFsdWUgKiBvcGFjaXR5O1xuICB2YXIgY29sb3IgPSBlbGUucHN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG5cbiAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcbn07XG5mdW5jdGlvbiBjaXJjbGUoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBkaWFtZXRlciA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgcmFkaXVzID0gZGlhbWV0ZXIgLyAyO1xuICB2YXIgY2VudGVyWCA9IHggKyB3aWR0aCAvIDI7XG4gIHZhciBjZW50ZXJZID0geSArIGhlaWdodCAvIDI7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiA1O1xuICB2YXIgciA9IE1hdGgubWluKHJhZGl1cywgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTsgLy8gcHJldmVudCBvdmVyZmxvd1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIsIHkpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHIpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHIsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByLCB5ICsgaGVpZ2h0KTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHIpO1xuICBjdHgubGluZVRvKHgsIHkgKyByKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHIsIHkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG5DUnAkNy5nZXRUZXh0QW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIHRoZXRhO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgdmFyIHRleHRBbmdsZSA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4KTtcbiAgICB0aGV0YSA9IGVsZS5pc0VkZ2UoKSA/IHRleHRBbmdsZSA6IDA7XG4gIH0gZWxzZSBpZiAocm90YXRpb24uc3RyVmFsdWUgPT09ICdub25lJykge1xuICAgIHRoZXRhID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGV0YSA9IHJvdGF0aW9uLnBmVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoZXRhO1xufTtcbkNScCQ3LmRyYXdUZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgcHJlZml4KSB7XG4gIHZhciBhcHBseVJvdGF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgdXNlRWxlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBhcmVudE9wYWNpdHkgPSB1c2VFbGVPcGFjaXR5ID8gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSA6IDE7XG4gIGlmICh1c2VFbGVPcGFjaXR5ICYmIChwYXJlbnRPcGFjaXR5ID09PSAwIHx8IGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlID09PSAwKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHVzZSAnbWFpbicgYXMgYW4gYWxpYXMgZm9yIHRoZSBtYWluIGxhYmVsIChpLmUuIG51bGwgcHJlZml4KVxuICBpZiAocHJlZml4ID09PSAnbWFpbicpIHtcbiAgICBwcmVmaXggPSBudWxsO1xuICB9XG4gIHZhciB0ZXh0WCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFgnLCBwcmVmaXgpO1xuICB2YXIgdGV4dFkgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgdmFyIG9yZ1RleHRYLCBvcmdUZXh0WTsgLy8gdXNlZCBmb3Igcm90YXRpb25cbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG4gIGlmICh0ZXh0ICE9IG51bGwgJiYgdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHRYKSAmJiAhaXNOYU4odGV4dFkpKSB7XG4gICAgdGhpcy5zZXR1cFRleHRTdHlsZShjb250ZXh0LCBlbGUsIHVzZUVsZU9wYWNpdHkpO1xuICAgIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciB0ZXh0VyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgdGV4dEggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcbiAgICBpZiAoaXNFZGdlKSB7XG4gICAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cbiAgICB0ZXh0WCArPSBtYXJnaW5YO1xuICAgIHRleHRZICs9IG1hcmdpblk7XG4gICAgdmFyIHRoZXRhO1xuICAgIGlmICghYXBwbHlSb3RhdGlvbikge1xuICAgICAgdGhldGEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGV0YSA9IHRoaXMuZ2V0VGV4dEFuZ2xlKGVsZSwgcHJlZml4KTtcbiAgICB9XG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBvcmdUZXh0WCA9IHRleHRYO1xuICAgICAgb3JnVGV4dFkgPSB0ZXh0WTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKG9yZ1RleHRYLCBvcmdUZXh0WSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG4gICAgICB0ZXh0WCA9IDA7XG4gICAgICB0ZXh0WSA9IDA7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRleHRZICs9IHRleHRIIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0ZXh0WSArPSB0ZXh0SDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIGJvcmRlck9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgYmFja2dyb3VuZFBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG4gICAgdmFyIHN0eWxlU2hhcGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtc2hhcGUnKS5zdHJWYWx1ZTtcbiAgICB2YXIgcm91bmRlZCA9IHN0eWxlU2hhcGUgPT09ICdyb3VuZC1yZWN0YW5nbGUnIHx8IHN0eWxlU2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZSc7XG4gICAgdmFyIGNpcmNsZWQgPSBzdHlsZVNoYXBlID09PSAnY2lyY2xlJztcbiAgICB2YXIgcm91bmRSYWRpdXMgPSAyO1xuICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgfHwgdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCkge1xuICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICB2YXIgdGV4dFN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1jb2xvcicpLnZhbHVlO1xuICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gICAgICB2YXIgZG9GaWxsID0gYmFja2dyb3VuZE9wYWNpdHkgPiAwO1xuICAgICAgdmFyIGRvU3Ryb2tlID0gdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMDtcbiAgICAgIHZhciBiZ1ggPSB0ZXh0WCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgYmdYIC09IHRleHRXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGJnWCAtPSB0ZXh0VyAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgYmdZID0gdGV4dFkgLSB0ZXh0SCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnVyA9IHRleHRXICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgdmFyIGJnSCA9IHRleHRIICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgaWYgKGRvRmlsbCkge1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIi5jb25jYXQodGV4dEJhY2tncm91bmRDb2xvclswXSwgXCIsXCIpLmNvbmNhdCh0ZXh0QmFja2dyb3VuZENvbG9yWzFdLCBcIixcIikuY29uY2F0KHRleHRCYWNrZ3JvdW5kQ29sb3JbMl0sIFwiLFwiKS5jb25jYXQoYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5LCBcIilcIik7XG4gICAgICB9XG4gICAgICBpZiAoZG9TdHJva2UpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYShcIi5jb25jYXQodGV4dEJvcmRlckNvbG9yWzBdLCBcIixcIikuY29uY2F0KHRleHRCb3JkZXJDb2xvclsxXSwgXCIsXCIpLmNvbmNhdCh0ZXh0Qm9yZGVyQ29sb3JbMl0sIFwiLFwiKS5jb25jYXQoYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHksIFwiKVwiKTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGg7XG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgc3dpdGNoICh0ZXh0Qm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyA0O1xuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocm91bmRlZCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICByb3VuZFJlY3QoY29udGV4dCwgYmdYLCBiZ1ksIGJnVywgYmdILCByb3VuZFJhZGl1cyk7XG4gICAgICB9IGVsc2UgaWYgKGNpcmNsZWQpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgY2lyY2xlKGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnJlY3QoYmdYLCBiZ1ksIGJnVywgYmdIKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb0ZpbGwpIGNvbnRleHQuZmlsbCgpO1xuICAgICAgaWYgKGRvU3Ryb2tlKSBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAvLyBEb3VibGUgYm9yZGVyIHBhc3MgZm9yICdkb3VibGUnIHN0eWxlXG4gICAgICBpZiAoZG9TdHJva2UgJiYgdGV4dEJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDI7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChyb3VuZGVkKSB7XG4gICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIDIgKiB3aGl0ZVdpZHRoLCBiZ0ggLSAyICogd2hpdGVXaWR0aCwgcm91bmRSYWRpdXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQucmVjdChiZ1ggKyB3aGl0ZVdpZHRoLCBiZ1kgKyB3aGl0ZVdpZHRoLCBiZ1cgLSAyICogd2hpdGVXaWR0aCwgYmdIIC0gMiAqIHdoaXRlV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRleHRGaWxsO1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRMaW5lV2lkdGg7XG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICAgIHZhciBsaW5lV2lkdGggPSAyICogZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG5cbiAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgfVxuICAgIGlmIChlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS52YWx1ZSA9PT0gJ3dyYXAnKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxMaW5lSGVpZ2h0JywgcHJlZml4KTtcbiAgICAgIHZhciBoYWxmVGV4dFcgPSB0ZXh0VyAvIDI7XG4gICAgICB2YXIganVzdGlmaWNhdGlvbiA9IHRoaXMuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG4gICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSA7IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGlmaWNhdGlvbiA6IHJpZ2h0XG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtdGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG4gICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0ZmljYXRpb24gOiBjZW50ZXJcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogbGVmdFxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRleHRYICs9IHRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5maWxsVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgfVxuICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1vcmdUZXh0WCwgLW9yZ1RleHRZKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBQYXRoMkQgKi9cblxudmFyIENScCQ2ID0ge307XG5DUnAkNi5kcmF3Tm9kZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gIHZhciBkcmF3TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3ZlcmxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBub2RlV2lkdGgsIG5vZGVIZWlnaHQ7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICBpZiAoIW51bWJlciQxKHBvcy54KSB8fCAhbnVtYmVyJDEocG9zLnkpKSB7XG4gICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgfVxuICBpZiAoc2hvdWxkRHJhd09wYWNpdHkgJiYgIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlbGVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKSA6IDE7XG4gIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIHBhZGRpbmc7XG5cbiAgLy9cbiAgLy8gc2V0dXAgc2hpZnRcblxuICB2YXIgYmI7XG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfVxuXG4gIC8vXG4gIC8vIGxvYWQgYmcgaW1hZ2VcblxuICB2YXIgYmdJbWdQcm9wID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgdmFyIHVybHMgPSBiZ0ltZ1Byb3AudmFsdWU7XG4gIHZhciB1cmxEZWZpbmVkID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgdmFyIGltYWdlID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgdmFyIG51bUltYWdlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cmwgPSB1cmxzW2ldO1xuICAgIHZhciBkZWZkID0gdXJsRGVmaW5lZFtpXSA9IHVybCAhPSBudWxsICYmIHVybCAhPT0gJ25vbmUnO1xuICAgIGlmIChkZWZkKSB7XG4gICAgICB2YXIgYmdJbWdDcm9zc09yaWdpbiA9IG5vZGUuY3koKS5zdHlsZSgpLmdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsICd2YWx1ZScsIGkpO1xuICAgICAgbnVtSW1hZ2VzKys7XG5cbiAgICAgIC8vIGdldCBpbWFnZSwgYW5kIGlmIG5vdCBsb2FkZWQgdGhlbiBhc2sgdG8gcmVkcmF3IHdoZW4gbGF0ZXIgbG9hZGVkXG4gICAgICBpbWFnZVtpXSA9IHIuZ2V0Q2FjaGVkSW1hZ2UodXJsLCBiZ0ltZ0Nyb3NzT3JpZ2luLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9wLmJhY2tncm91bmRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBub2RlLmVtaXRBbmROb3RpZnkoJ2JhY2tncm91bmQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIHNldHVwIHN0eWxlc1xuXG4gIHZhciBkYXJrbmVzcyA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWJsYWNrZW4nKS52YWx1ZTtcbiAgdmFyIGJvcmRlcldpZHRoID0gbm9kZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBiZ09wYWNpdHkgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCdib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGJvcmRlckpvaW4gPSBub2RlLnBzdHlsZSgnYm9yZGVyLWpvaW4nKS52YWx1ZTtcbiAgdmFyIGJvcmRlckNhcCA9IG5vZGUucHN0eWxlKCdib3JkZXItY2FwJykudmFsdWU7XG4gIHZhciBib3JkZXJQb3NpdGlvbiA9IG5vZGUucHN0eWxlKCdib3JkZXItcG9zaXRpb24nKS52YWx1ZTtcbiAgdmFyIGJvcmRlclBhdHRlcm4gPSBub2RlLnBzdHlsZSgnYm9yZGVyLWRhc2gtcGF0dGVybicpLnBmVmFsdWU7XG4gIHZhciBib3JkZXJPZmZzZXQgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWRhc2gtb2Zmc2V0JykucGZWYWx1ZTtcbiAgdmFyIGJvcmRlck9wYWNpdHkgPSBub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gIHZhciBvdXRsaW5lV2lkdGggPSBub2RlLnBzdHlsZSgnb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBvdXRsaW5lQ29sb3IgPSBub2RlLnBzdHlsZSgnb3V0bGluZS1jb2xvcicpLnZhbHVlO1xuICB2YXIgb3V0bGluZVN0eWxlID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIG91dGxpbmVPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ291dGxpbmUtb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgdmFyIG91dGxpbmVPZmZzZXQgPSBub2RlLnBzdHlsZSgnb3V0bGluZS1vZmZzZXQnKS52YWx1ZTtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWU7XG4gIGlmIChjb3JuZXJSYWRpdXMgIT09ICdhdXRvJykgY29ybmVyUmFkaXVzID0gbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICB2YXIgc2V0dXBTaGFwZUNvbG9yID0gZnVuY3Rpb24gc2V0dXBTaGFwZUNvbG9yKCkge1xuICAgIHZhciBiZ09weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYmdPcGFjaXR5O1xuICAgIHIuZWxlRmlsbFN0eWxlKGNvbnRleHQsIG5vZGUsIGJnT3B5KTtcbiAgfTtcbiAgdmFyIHNldHVwQm9yZGVyQ29sb3IgPSBmdW5jdGlvbiBzZXR1cEJvcmRlckNvbG9yKCkge1xuICAgIHZhciBiZHJPcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGJvcmRlck9wYWNpdHk7XG4gICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGJvcmRlckNvbG9yWzBdLCBib3JkZXJDb2xvclsxXSwgYm9yZGVyQ29sb3JbMl0sIGJkck9weSk7XG4gIH07XG4gIHZhciBzZXR1cE91dGxpbmVDb2xvciA9IGZ1bmN0aW9uIHNldHVwT3V0bGluZUNvbG9yKCkge1xuICAgIHZhciBvdGxuT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBvdXRsaW5lT3BhY2l0eTtcbiAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3Rsbk9weSk7XG4gIH07XG5cbiAgLy9cbiAgLy8gc2V0dXAgc2hhcGVcblxuICB2YXIgZ2V0UGF0aCA9IGZ1bmN0aW9uIGdldFBhdGgod2lkdGgsIGhlaWdodCwgc2hhcGUsIHBvaW50cykge1xuICAgIHZhciBwYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgPSByLm5vZGVQYXRoQ2FjaGUgfHwgW107XG4gICAgdmFyIGtleSA9IGhhc2hTdHJpbmdzKHNoYXBlID09PSAncG9seWdvbicgPyBzaGFwZSArICcsJyArIHBvaW50cy5qb2luKCcsJykgOiBzaGFwZSwgJycgKyBoZWlnaHQsICcnICsgd2lkdGgsICcnICsgY29ybmVyUmFkaXVzKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IHBhdGhDYWNoZVtrZXldO1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBjYWNoZUhpdCA9IGZhbHNlO1xuICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgIHBhdGggPSBjYWNoZWRQYXRoO1xuICAgICAgY2FjaGVIaXQgPSB0cnVlO1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGhDYWNoZVtrZXldID0gcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBjYWNoZUhpdDogY2FjaGVIaXRcbiAgICB9O1xuICB9O1xuICB2YXIgc3R5bGVTaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnN0clZhbHVlO1xuICB2YXIgc2hhcGVQdHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS5wZlZhbHVlO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgIHZhciBzaGFwZVBhdGggPSBnZXRQYXRoKG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgc3R5bGVTaGFwZSwgc2hhcGVQdHMpO1xuICAgIHBhdGggPSBzaGFwZVBhdGgucGF0aDtcbiAgICBwYXRoQ2FjaGVIaXQgPSBzaGFwZVBhdGguY2FjaGVIaXQ7XG4gIH1cbiAgdmFyIGRyYXdTaGFwZSA9IGZ1bmN0aW9uIGRyYXdTaGFwZSgpIHtcbiAgICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgICAgdmFyIG5wb3MgPSBwb3M7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhwYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgIH1cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd0ltYWdlcyA9IGZ1bmN0aW9uIGRyYXdJbWFnZXMoKSB7XG4gICAgdmFyIG5vZGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbGVPcGFjaXR5O1xuICAgIHZhciBpbnNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgdmFyIHRvdGFsQ29tcGxldGVkID0gMDtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW1hZ2UubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgYmdDb250YWlubWVudCA9IG5vZGUuY3koKS5zdHlsZSgpLmdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCcsICd2YWx1ZScsIF9pKTtcbiAgICAgIGlmIChpbnNpZGUgJiYgYmdDb250YWlubWVudCA9PT0gJ292ZXInIHx8ICFpbnNpZGUgJiYgYmdDb250YWlubWVudCA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgdG90YWxDb21wbGV0ZWQrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodXJsRGVmaW5lZFtfaV0gJiYgaW1hZ2VbX2ldLmNvbXBsZXRlICYmICFpbWFnZVtfaV0uZXJyb3IpIHtcbiAgICAgICAgdG90YWxDb21wbGV0ZWQrKztcbiAgICAgICAgci5kcmF3SW5zY3JpYmVkSW1hZ2UoY29udGV4dCwgaW1hZ2VbX2ldLCBub2RlLCBfaSwgbm9kZU9wYWNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfcC5iYWNrZ3JvdW5kaW5nID0gISh0b3RhbENvbXBsZXRlZCA9PT0gbnVtSW1hZ2VzKTtcbiAgICBpZiAocHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nKSB7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgYi9jIDpiYWNrZ3JvdW5kaW5nIHN0YXRlIGNoYW5nZWRcbiAgICAgIG5vZGUudXBkYXRlU3R5bGUoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdQaWUgPSBmdW5jdGlvbiBkcmF3UGllKCkge1xuICAgIHZhciByZWRyYXdTaGFwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHBpZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGVsZU9wYWNpdHk7XG4gICAgaWYgKHIuaGFzUGllKG5vZGUpKSB7XG4gICAgICByLmRyYXdQaWUoY29udGV4dCwgbm9kZSwgcGllT3BhY2l0eSk7XG5cbiAgICAgIC8vIHJlZHJhdy9yZXN0b3JlIHBhdGggaWYgc3RlcHMgYWZ0ZXIgcGllIG5lZWQgaXRcbiAgICAgIGlmIChyZWRyYXdTaGFwZSkge1xuICAgICAgICBpZiAoIXVzZVBhdGhzKSB7XG4gICAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdTdHJpcGUgPSBmdW5jdGlvbiBkcmF3U3RyaXBlKCkge1xuICAgIHZhciByZWRyYXdTaGFwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHN0cmlwZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGVsZU9wYWNpdHk7XG4gICAgaWYgKHIuaGFzU3RyaXBlKG5vZGUpKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmNsaXAocnMucGF0aENhY2hlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgICAgci5kcmF3U3RyaXBlKGNvbnRleHQsIG5vZGUsIHN0cmlwZU9wYWNpdHkpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIC8vIHJlZHJhdy9yZXN0b3JlIHBhdGggaWYgc3RlcHMgYWZ0ZXIgc3RyaXBlcyBuZWVkIGl0XG4gICAgICBpZiAocmVkcmF3U2hhcGUpIHtcbiAgICAgICAgaWYgKCF1c2VQYXRocykge1xuICAgICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkYXJrZW4gPSBmdW5jdGlvbiBkYXJrZW4oKSB7XG4gICAgdmFyIGRhcmtlbk9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIG9wYWNpdHkgPSAoZGFya25lc3MgPiAwID8gZGFya25lc3MgOiAtZGFya25lc3MpICogZGFya2VuT3BhY2l0eTtcbiAgICB2YXIgYyA9IGRhcmtuZXNzID4gMCA/IDAgOiAyNTU7XG4gICAgaWYgKGRhcmtuZXNzICE9PSAwKSB7XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGMsIGMsIGMsIG9wYWNpdHkpO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdCb3JkZXIgPSBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSBib3JkZXJDYXA7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gYm9yZGVySm9pbjtcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBzd2l0Y2ggKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGJvcmRlclBhdHRlcm4pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJvcmRlclBvc2l0aW9uICE9PSAnY2VudGVyJykge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggKj0gMjtcbiAgICAgICAgaWYgKGJvcmRlclBvc2l0aW9uID09PSAnaW5zaWRlJykge1xuICAgICAgICAgIHVzZVBhdGhzID8gY29udGV4dC5jbGlwKHBhdGgpIDogY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICByZWdpb24ucmVjdCgtbm9kZVdpZHRoIC8gMiAtIGJvcmRlcldpZHRoLCAtbm9kZUhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCwgbm9kZVdpZHRoICsgMiAqIGJvcmRlcldpZHRoLCBub2RlSGVpZ2h0ICsgMiAqIGJvcmRlcldpZHRoKTtcbiAgICAgICAgICByZWdpb24uYWRkUGF0aChwYXRoKTtcbiAgICAgICAgICBjb250ZXh0LmNsaXAocmVnaW9uLCAnZXZlbm9kZCcpO1xuICAgICAgICB9XG4gICAgICAgIHVzZVBhdGhzID8gY29udGV4dC5zdHJva2UocGF0aCkgOiBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZVBhdGhzID8gY29udGV4dC5zdHJva2UocGF0aCkgOiBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoIC8gMztcbiAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdPdXRsaW5lID0gZnVuY3Rpb24gZHJhd091dGxpbmUoKSB7XG4gICAgaWYgKG91dGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gb3V0bGluZVdpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIHN3aXRjaCAob3V0bGluZVN0eWxlKSB7XG4gICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBucG9zID0gcG9zO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgc2hhcGUgPSByLmdldE5vZGVTaGFwZShub2RlKTtcbiAgICAgIHZhciBiV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGlmIChib3JkZXJQb3NpdGlvbiA9PT0gJ2luc2lkZScpIGJXaWR0aCA9IDA7XG4gICAgICBpZiAoYm9yZGVyUG9zaXRpb24gPT09ICdvdXRzaWRlJykgYldpZHRoICo9IDI7XG4gICAgICB2YXIgc2NhbGVYID0gKG5vZGVXaWR0aCArIGJXaWR0aCArIChvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSkgLyBub2RlV2lkdGg7XG4gICAgICB2YXIgc2NhbGVZID0gKG5vZGVIZWlnaHQgKyBiV2lkdGggKyAob3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkpIC8gbm9kZUhlaWdodDtcbiAgICAgIHZhciBzV2lkdGggPSBub2RlV2lkdGggKiBzY2FsZVg7XG4gICAgICB2YXIgc0hlaWdodCA9IG5vZGVIZWlnaHQgKiBzY2FsZVk7XG4gICAgICB2YXIgcG9pbnRzID0gci5ub2RlU2hhcGVzW3NoYXBlXS5wb2ludHM7XG4gICAgICB2YXIgX3BhdGg7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgdmFyIG91dGxpbmVQYXRoID0gZ2V0UGF0aChzV2lkdGgsIHNIZWlnaHQsIHNoYXBlLCBwb2ludHMpO1xuICAgICAgICBfcGF0aCA9IG91dGxpbmVQYXRoLnBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYXcgdGhlIG91dGxpbmUgcGF0aCwgZWl0aGVyIGJ5IHVzaW5nIGV4cGFuZGVkIHBvaW50cyBvciBieSBzY2FsaW5nIFxuICAgICAgLy8gdGhlIGRpbWVuc2lvbnMsIGRlcGVuZGluZyBvbiBzaGFwZVxuICAgICAgaWYgKHNoYXBlID09PSBcImVsbGlwc2VcIikge1xuICAgICAgICByLmRyYXdFbGxpcHNlUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoWydyb3VuZC1kaWFtb25kJywgJ3JvdW5kLWhlcHRhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAncm91bmQtb2N0YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdyb3VuZC1wb2x5Z29uJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3JvdW5kLXRhZyddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICB2YXIgc011bHQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXRZID0gMDtcbiAgICAgICAgaWYgKHNoYXBlID09PSAncm91bmQtZGlhbW9uZCcpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuNDtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLWhlcHRhZ29uJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4wNzU7XG4gICAgICAgICAgb2Zmc2V0WSA9IC0oYldpZHRoIC8gMiArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpIC8gMzU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC1oZXhhZ29uJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4xMjtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLXBlbnRhZ29uJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4xMztcbiAgICAgICAgICBvZmZzZXRZID0gLShiV2lkdGggLyAyICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgLyAxNTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLXRhZycpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIDEuMTI7XG4gICAgICAgICAgb2Zmc2V0WCA9IChiV2lkdGggLyAyICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgKiAuMDc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09ICdyb3VuZC10cmlhbmdsZScpIHtcbiAgICAgICAgICBzTXVsdCA9IChiV2lkdGggKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAqIChNYXRoLlBJIC8gMik7XG4gICAgICAgICAgb2Zmc2V0WSA9IC0oYldpZHRoICsgb3V0bGluZU9mZnNldCAvIDIgKyBvdXRsaW5lV2lkdGgpIC8gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc011bHQgIT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSAobm9kZVdpZHRoICsgc011bHQpIC8gbm9kZVdpZHRoO1xuICAgICAgICAgIHNXaWR0aCA9IG5vZGVXaWR0aCAqIHNjYWxlWDtcbiAgICAgICAgICBpZiAoIVsncm91bmQtaGV4YWdvbicsICdyb3VuZC10YWcnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgICAgIHNjYWxlWSA9IChub2RlSGVpZ2h0ICsgc011bHQpIC8gbm9kZUhlaWdodDtcbiAgICAgICAgICAgIHNIZWlnaHQgPSBub2RlSGVpZ2h0ICogc2NhbGVZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUG9seWdvblJhZGl1cyhzV2lkdGgsIHNIZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICB2YXIgaGFsZlcgPSBzV2lkdGggLyAyO1xuICAgICAgICB2YXIgaGFsZkggPSBzSGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGNvcm5lclJhZGl1cyArIChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIDI7XG4gICAgICAgIHZhciBwID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgdmFyIGNvcm5lcnMgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwb2ludHMubGVuZ3RoIC8gMjsgX2kyKyspIHtcbiAgICAgICAgICBwW19pMl0gPSB7XG4gICAgICAgICAgICB4OiBucG9zLnggKyBvZmZzZXRYICsgaGFsZlcgKiBwb2ludHNbX2kyICogMl0sXG4gICAgICAgICAgICB5OiBucG9zLnkgKyBvZmZzZXRZICsgaGFsZkggKiBwb2ludHNbX2kyICogMiArIDFdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2kzLFxuICAgICAgICAgIHAxLFxuICAgICAgICAgIHAyLFxuICAgICAgICAgIHAzLFxuICAgICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgICBwMSA9IHBbbGVuIC0gMV07XG4gICAgICAgIC8vIGZvciBlYWNoIHBvaW50XG4gICAgICAgIGZvciAoX2kzID0gMDsgX2kzIDwgbGVuOyBfaTMrKykge1xuICAgICAgICAgIHAyID0gcFtfaTMgJSBsZW5dO1xuICAgICAgICAgIHAzID0gcFsoX2kzICsgMSkgJSBsZW5dO1xuICAgICAgICAgIGNvcm5lcnNbX2kzXSA9IGdldFJvdW5kQ29ybmVyKHAxLCBwMiwgcDMsIHJhZGl1cyk7XG4gICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICBwMiA9IHAzO1xuICAgICAgICB9XG4gICAgICAgIHIuZHJhd1JvdW5kUG9seWdvblBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54ICsgb2Zmc2V0WCwgbnBvcy55ICsgb2Zmc2V0WSwgbm9kZVdpZHRoICogc2NhbGVYLCBub2RlSGVpZ2h0ICogc2NhbGVZLCBwb2ludHMsIGNvcm5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChbJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZSddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHNXaWR0aCwgc0hlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICAgIHIuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0LCBjb3JuZXJSYWRpdXMgKyAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoWydjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZSddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICByLmRyYXdDdXRSZWN0YW5nbGVQYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBzV2lkdGgsIHNIZWlnaHQsIG51bGwsIGNvcm5lclJhZGl1cyArIChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIDQpO1xuICAgICAgfSBlbHNlIGlmIChbJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJywgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgY29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyhzV2lkdGgsIHNIZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICByLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCwgY29ybmVyUmFkaXVzICsgKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSBcImJhcnJlbFwiKSB7XG4gICAgICAgIHIuZHJhd0JhcnJlbFBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlLnN0YXJ0c1dpdGgoXCJwb2x5Z29uXCIpIHx8IFsncmhvbWJvaWQnLCAncmlnaHQtcmhvbWJvaWQnLCAncm91bmQtdGFnJywgJ3RhZycsICd2ZWUnXS5pbmNsdWRlcyhzaGFwZSkpIHtcbiAgICAgICAgdmFyIHBhZCA9IChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIG5vZGVXaWR0aDtcbiAgICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZFBvbHlnb24ocG9pbnRzLCBwYWQpKTtcbiAgICAgICAgci5kcmF3UG9seWdvblBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgcG9pbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcGFkID0gKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gbm9kZVdpZHRoO1xuICAgICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kUG9seWdvbihwb2ludHMsIC1fcGFkKSk7XG4gICAgICAgIHIuZHJhd1BvbHlnb25QYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIHBvaW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoX3BhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRsaW5lU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYldpZHRoIC8gMztcbiAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZShfcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIGlmIChzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgci5kcmF3Tm9kZU92ZXJsYXkoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdVbmRlcmxheSgpIHtcbiAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBub2RlLCBudWxsLCBkcmF3TGFiZWwpO1xuICB9O1xuICB2YXIgZ2hvc3QgPSBub2RlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmR2hvc3RPcGFjaXR5ID0gZ2hvc3RPcGFjaXR5ICogZWxlT3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIHNldHVwT3V0bGluZUNvbG9yKCk7XG4gICAgZHJhd091dGxpbmUoKTtcbiAgICBzZXR1cFNoYXBlQ29sb3IoZ2hvc3RPcGFjaXR5ICogYmdPcGFjaXR5KTtcbiAgICBkcmF3U2hhcGUoKTtcbiAgICBkcmF3SW1hZ2VzKGVmZkdob3N0T3BhY2l0eSwgdHJ1ZSk7XG4gICAgc2V0dXBCb3JkZXJDb2xvcihnaG9zdE9wYWNpdHkgKiBib3JkZXJPcGFjaXR5KTtcbiAgICBkcmF3Qm9yZGVyKCk7XG4gICAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gICAgZHJhd1N0cmlwZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gICAgZHJhd0ltYWdlcyhlZmZHaG9zdE9wYWNpdHksIGZhbHNlKTtcbiAgICBkYXJrZW4oZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gIH1cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXBvcy54LCAtcG9zLnkpO1xuICB9XG4gIGRyYXdVbmRlcmxheSgpO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICB9XG4gIHNldHVwT3V0bGluZUNvbG9yKCk7XG4gIGRyYXdPdXRsaW5lKCk7XG4gIHNldHVwU2hhcGVDb2xvcigpO1xuICBkcmF3U2hhcGUoKTtcbiAgZHJhd0ltYWdlcyhlbGVPcGFjaXR5LCB0cnVlKTtcbiAgc2V0dXBCb3JkZXJDb2xvcigpO1xuICBkcmF3Qm9yZGVyKCk7XG4gIGRyYXdQaWUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICBkcmF3U3RyaXBlKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgZHJhd0ltYWdlcyhlbGVPcGFjaXR5LCBmYWxzZSk7XG4gIGRhcmtlbigpO1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcG9zLngsIC1wb3MueSk7XG4gIH1cbiAgZHJhd1RleHQoKTtcbiAgZHJhd092ZXJsYXkoKTtcblxuICAvL1xuICAvLyBjbGVhbiB1cCBzaGlmdFxuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcbnZhciBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KG92ZXJsYXlPclVuZGVybGF5KSB7XG4gIGlmICghWydvdmVybGF5JywgJ3VuZGVybGF5J10uaW5jbHVkZXMob3ZlcmxheU9yVW5kZXJsYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBpZiAoIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYWRkaW5nID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXBhZGRpbmdcIikpLnBmVmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItb3BhY2l0eVwiKSkudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLWNvbG9yXCIpKS52YWx1ZTtcbiAgICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItc2hhcGVcIikpLnZhbHVlO1xuICAgIHZhciByYWRpdXMgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29ybmVyLXJhZGl1c1wiKSkudmFsdWU7XG4gICAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgICBwb3MgPSBwb3MgfHwgbm9kZS5wb3NpdGlvbigpO1xuICAgICAgaWYgKG5vZGVXaWR0aCA9PSBudWxsIHx8IG5vZGVIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgX3BhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgICAgICAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIF9wYWRkaW5nO1xuICAgICAgICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBfcGFkZGluZztcbiAgICAgIH1cbiAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgICByLm5vZGVTaGFwZXNbc2hhcGVdLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGggKyBwYWRkaW5nICogMiwgbm9kZUhlaWdodCArIHBhZGRpbmcgKiAyLCByYWRpdXMpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9O1xufTtcbkNScCQ2LmRyYXdOb2RlT3ZlcmxheSA9IGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KCdvdmVybGF5Jyk7XG5DUnAkNi5kcmF3Tm9kZVVuZGVybGF5ID0gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkoJ3VuZGVybGF5Jyk7XG5cbi8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuQ1JwJDYuaGFzUGllID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xufTtcbkNScCQ2Lmhhc1N0cmlwZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHJldHVybiBub2RlLl9wcml2YXRlLmhhc1N0cmlwZTtcbn07XG5DUnAkNi5kcmF3UGllID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIG5vZGVPcGFjaXR5LCBwb3MpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG4gIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBwaWVTaXplID0gbm9kZS5wc3R5bGUoJ3BpZS1zaXplJyk7XG4gIHZhciBob2xlID0gbm9kZS5wc3R5bGUoJ3BpZS1ob2xlJyk7XG4gIHZhciBvdmVyYWxsU3RhcnRBbmdsZSA9IG5vZGUucHN0eWxlKCdwaWUtc3RhcnQtYW5nbGUnKS5wZlZhbHVlO1xuICB2YXIgeCA9IHBvcy54O1xuICB2YXIgeSA9IHBvcy55O1xuICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gIHZhciByYWRpdXMgPSBNYXRoLm1pbihub2RlVywgbm9kZUgpIC8gMjsgLy8gbXVzdCBmaXQgaW4gbm9kZVxuICB2YXIgaG9sZVJhZGl1cztcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIGlmICh1c2VQYXRocykge1xuICAgIHggPSAwO1xuICAgIHkgPSAwO1xuICB9XG4gIGlmIChwaWVTaXplLnVuaXRzID09PSAnJScpIHtcbiAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiAocGllU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByYWRpdXMgPSBwaWVTaXplLnBmVmFsdWUgLyAyOyAvLyBkaWFtZXRlciBpbiBwaXhlbHMgPT4gcmFkaXVzXG4gIH1cbiAgaWYgKGhvbGUudW5pdHMgPT09ICclJykge1xuICAgIGhvbGVSYWRpdXMgPSByYWRpdXMgKiBob2xlLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiAoaG9sZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBob2xlUmFkaXVzID0gaG9sZS5wZlZhbHVlIC8gMjsgLy8gZGlhbWV0ZXIgaW4gcGl4ZWxzID0+IHJhZGl1c1xuICB9XG4gIGlmIChob2xlUmFkaXVzID49IHJhZGl1cykge1xuICAgIHJldHVybjsgLy8gdGhlIHBpZSB3b3VsZCBiZSBpbnZpc2libGUgYW55d2F5XG4gIH1cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgLy8gMS4uTlxuICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuXG4gICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG4gICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuICAgIGFuZ2xlU3RhcnQgKz0gb3ZlcmFsbFN0YXJ0QW5nbGU7IC8vIHNoaWZ0IGJ5IHRoZSBvdmVyYWxsIHBpZSBzdGFydCBhbmdsZVxuICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhO1xuXG4gICAgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICBpZiAoc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaG9sZVJhZGl1cyA9PT0gMCkge1xuICAgICAgLy8gbWFrZSBhIHBpZSBzbGljZVxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWtlIGEgcGllIHNsaWNlIHRoYXQncyBsaWtlIHRoZSBhYm92ZSBidXQgd2l0aCBhIGhvbGUgaW4gdGhlIG1pZGRsZVxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgaG9sZVJhZGl1cywgYW5nbGVFbmQsIGFuZ2xlU3RhcnQsIHRydWUpOyAvLyB0cnVlIGZvciBhbnRpY2xvY2t3aXNlXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGxhc3RQZXJjZW50ICs9IHBlcmNlbnQ7XG4gIH1cbn07XG5DUnAkNi5kcmF3U3RyaXBlID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIG5vZGVPcGFjaXR5LCBwb3MpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG4gIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciB4ID0gcG9zLng7XG4gIHZhciB5ID0gcG9zLnk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIGNvbnRleHQuc2F2ZSgpO1xuICB2YXIgZGlyZWN0aW9uID0gbm9kZS5wc3R5bGUoJ3N0cmlwZS1kaXJlY3Rpb24nKS52YWx1ZTtcbiAgdmFyIHN0cmlwZVNpemUgPSBub2RlLnBzdHlsZSgnc3RyaXBlLXNpemUnKTtcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICBicmVhaztcbiAgICAvLyBkZWZhdWx0XG4gICAgY2FzZSAncmlnaHdhcmQnOlxuICAgICAgY29udGV4dC5yb3RhdGUoLU1hdGguUEkgLyAyKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHZhciBzdHJpcGVXID0gbm9kZVc7XG4gIHZhciBzdHJpcGVIID0gbm9kZUg7XG4gIGlmIChzdHJpcGVTaXplLnVuaXRzID09PSAnJScpIHtcbiAgICBzdHJpcGVXID0gc3RyaXBlVyAqIHN0cmlwZVNpemUucGZWYWx1ZTtcbiAgICBzdHJpcGVIID0gc3RyaXBlSCAqIHN0cmlwZVNpemUucGZWYWx1ZTtcbiAgfSBlbHNlIGlmIChzdHJpcGVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlwZVcgPSBzdHJpcGVTaXplLnBmVmFsdWU7XG4gICAgc3RyaXBlSCA9IHN0cmlwZVNpemUucGZWYWx1ZTtcbiAgfVxuICBpZiAodXNlUGF0aHMpIHtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIC8vIHNoaWZ0IHVwIGZyb20gdGhlIGNlbnRyZSBvZiB0aGUgbm9kZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyXG4gIHkgLT0gc3RyaXBlVyAvIDI7XG4gIHggLT0gc3RyaXBlSCAvIDI7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGN5U3R5bGUuc3RyaXBlQmFja2dyb3VuZE47IGkrKykge1xuICAgIC8vIDEuLk5cbiAgICB2YXIgc2l6ZSA9IG5vZGUucHN0eWxlKCdzdHJpcGUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScpLnZhbHVlO1xuICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKCdzdHJpcGUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKCdzdHJpcGUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogbm9kZU9wYWNpdHk7XG4gICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cblxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuICAgIGlmIChwZXJjZW50ICsgbGFzdFBlcmNlbnQgPiAxKSB7XG4gICAgICBwZXJjZW50ID0gMSAtIGxhc3RQZXJjZW50O1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBpZlxuICAgIC8vIC0gemVybyBzaXplXG4gICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaGFydFxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaGFydFxuICAgIGlmIChzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZHJhdyByZWN0IGZvciB0aGUgY3VycmVudCBzdHJpcGVcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQucmVjdCh4LCB5ICsgc3RyaXBlSCAqIGxhc3RQZXJjZW50LCBzdHJpcGVXLCBzdHJpcGVIICogcGVyY2VudCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGxhc3RQZXJjZW50ICs9IHBlcmNlbnQ7XG4gIH1cbiAgY29udGV4dC5yZXN0b3JlKCk7XG59O1xuXG52YXIgQ1JwJDUgPSB7fTtcbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbi8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAkNS5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZGF0YS5jb250ZXh0c1swXTtcbiAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuICB2YXIgY29udGFpbmVyV2luZG93ID0gdGhpcy5jeS53aW5kb3coKTtcbiAgdmFyIGJhY2tpbmdTdG9yZSA9IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiAoY29udGFpbmVyV2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn07XG5DUnAkNS5wYWludENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICB2YXIgY2FjaGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGUgPSBjYWNoZXNbaV07XG4gICAgaWYgKGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgIG5lZWRUb0NyZWF0ZUNhY2hlID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRUb0NyZWF0ZUNhY2hlKSB7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlO1xufTtcbkNScCQ1LmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IgPSBmdW5jdGlvbiAoY29udGV4dCwgc2hhcGVTdHlsZU5hbWUsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICB2YXIgZ3JhZGllbnRTdHlsZTtcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICB2YXIgY29sb3JzID0gZWxlLnBzdHlsZShzaGFwZVN0eWxlTmFtZSArICctZ3JhZGllbnQtc3RvcC1jb2xvcnMnKS52YWx1ZSxcbiAgICBwb3NpdGlvbnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycpLnBmVmFsdWU7XG4gIGlmIChmaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHZhciBzdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICBlbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKSxcbiAgICAgICAgbWlkID0gZWxlLm1pZHBvaW50KCk7XG4gICAgICB2YXIgZDEgPSBkaXN0KHN0YXJ0LCBtaWQpO1xuICAgICAgdmFyIGQyID0gZGlzdChlbmQsIG1pZCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChtaWQueCwgbWlkLnksIDAsIG1pZC54LCBtaWQueSwgTWF0aC5tYXgoZDEsIGQyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICB3aWR0aCA9IGVsZS5wYWRkZWRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChwb3MueCwgcG9zLnksIDAsIHBvcy54LCBwb3MueSwgTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgX3N0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgIF9lbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKTtcbiAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9zdGFydC54LCBfc3RhcnQueSwgX2VuZC54LCBfZW5kLnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3BvcyA9IHVzZVBhdGhzID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDogZWxlLnBvc2l0aW9uKCksXG4gICAgICAgIF93aWR0aCA9IGVsZS5wYWRkZWRXaWR0aCgpLFxuICAgICAgICBfaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpLFxuICAgICAgICBoYWxmV2lkdGggPSBfd2lkdGggLyAyLFxuICAgICAgICBoYWxmSGVpZ2h0ID0gX2hlaWdodCAvIDI7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nKS52YWx1ZTtcbiAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3RvLWJvdHRvbSc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54LCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54LCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tbGVmdCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tcmlnaHQnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLWJvdHRvbS1yaWdodCc6XG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0LWJvdHRvbSc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by10b3AtcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tYm90dG9tLWxlZnQnOlxuICAgICAgICBjYXNlICd0by1sZWZ0LWJvdHRvbSc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by10b3AtbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGludmFsaWQgZ3JhZGllbnQgc3R5bGVcblxuICB2YXIgaGFzUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aCA9PT0gY29sb3JzLmxlbmd0aDtcbiAgdmFyIGxlbmd0aCA9IGNvbG9ycy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBncmFkaWVudFN0eWxlLmFkZENvbG9yU3RvcChoYXNQb3NpdGlvbnMgPyBwb3NpdGlvbnNbaV0gOiBpIC8gKGxlbmd0aCAtIDEpLCAncmdiYSgnICsgY29sb3JzW2ldWzBdICsgJywnICsgY29sb3JzW2ldWzFdICsgJywnICsgY29sb3JzW2ldWzJdICsgJywnICsgb3BhY2l0eSArICcpJyk7XG4gIH1cbiAgcmV0dXJuIGdyYWRpZW50U3R5bGU7XG59O1xuQ1JwJDUuZ3JhZGllbnRGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdiYWNrZ3JvdW5kJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcbiAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudFN0eWxlO1xufTtcbkNScCQ1LmNvbG9yRmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAvLyB2YXIgZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gaWYoIGNhY2hlLmZpbGxTdHlsZSAhPT0gZmlsbFN0eWxlICl7XG4gIC8vICAgY29udGV4dC5maWxsU3R5bGUgPSBjYWNoZS5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gIC8vIH1cbn07XG5DUnAkNS5lbGVGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gIHZhciBiYWNrZ3JvdW5kRmlsbCA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZmlsbCcpLnZhbHVlO1xuICBpZiAoYmFja2dyb3VuZEZpbGwgPT09ICdsaW5lYXItZ3JhZGllbnQnIHx8IGJhY2tncm91bmRGaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgIHRoaXMuZ3JhZGllbnRGaWxsU3R5bGUoY29udGV4dCwgZWxlLCBiYWNrZ3JvdW5kRmlsbCwgb3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGJhY2tncm91bmRDb2xvclswXSwgYmFja2dyb3VuZENvbG9yWzFdLCBiYWNrZ3JvdW5kQ29sb3JbMl0sIG9wYWNpdHkpO1xuICB9XG59O1xuQ1JwJDUuZ3JhZGllbnRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2xpbmUnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbn07XG5DUnAkNS5jb2xvclN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIHIsIGcsIGIsIGEpIHtcbiAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBzdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIGlmKCBjYWNoZS5zdHJva2VTdHlsZSAhPT0gc3Ryb2tlU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY2FjaGUuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgLy8gfVxufTtcbkNScCQ1LmVsZVN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICB2YXIgbGluZUZpbGwgPSBlbGUucHN0eWxlKCdsaW5lLWZpbGwnKS52YWx1ZTtcbiAgaWYgKGxpbmVGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBsaW5lRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50U3Ryb2tlU3R5bGUoY29udGV4dCwgZWxlLCBsaW5lRmlsbCwgb3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07XG5cbi8vIFJlc2l6ZSBjYW52YXNcbkNScCQ1Lm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIGJiID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IGJiWzJdO1xuICB2YXIgaGVpZ2h0ID0gYmJbM107XG4gIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICBpZiAoY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSB7XG4gICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgfVxuICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzO1xuICBpZiAoY2FudmFzV2lkdGggPT09IHIuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSByLmNhbnZhc0hlaWdodCkge1xuICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICB9XG4gIHIuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzW2ldO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG4gIGlmIChwaXhlbFJhdGlvIDw9IDEpIHtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgIHIudGV4dHVyZU11bHQgPSAyO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdDtcbiAgfVxuICByLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gIHIuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICByLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xufTtcbkNScCQ1LnJlbmRlclRvID0gZnVuY3Rpb24gKGN4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gIHRoaXMucmVuZGVyKHtcbiAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICBmb3JjZWRQYW46IHBhbixcbiAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgfSk7XG59O1xuQ1JwJDUuY2xlYXJDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIGZ1bmN0aW9uIGNsZWFyKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gIH1cbiAgY2xlYXIoZGF0YS5jb250ZXh0c1tyLk5PREVdKTtcbiAgY2xlYXIoZGF0YS5jb250ZXh0c1tyLkRSQUddKTtcbn07XG5DUnAkNS5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgciA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHN0YXRpY0VtcHR5T2JqZWN0KCk7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgdmFyIGRyYXdPbmx5Tm9kZUxheWVyID0gb3B0aW9ucy5kcmF3T25seU5vZGVMYXllcjtcbiAgdmFyIGZvcmNlZFpvb20gPSBvcHRpb25zLmZvcmNlZFpvb207XG4gIHZhciBmb3JjZWRQYW4gPSBvcHRpb25zLmZvcmNlZFBhbjtcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuICBpZiAoIWZvcmNlZENvbnRleHQpIHtcbiAgICBpZiAoci5wcmV2UHhSYXRpbyAhPT0gcGl4ZWxSYXRpbykge1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgfVxuICAgIHIucHJldlB4UmF0aW8gPSBwaXhlbFJhdGlvO1xuICB9XG4gIGlmICghZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHIubW90aW9uQmx1clRpbWVvdXQpO1xuICB9XG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgaWYgKHIubWJGcmFtZXMgPT0gbnVsbCkge1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgfVxuICAgIHIubWJGcmFtZXMrKztcbiAgICBpZiAoci5tYkZyYW1lcyA8IDMpIHtcbiAgICAgIC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZ28gdG8gbG93ZXIgcXVhbGl0eSBibHVycnkgZnJhbWVzIHdoZW4gc2V2ZXJhbCBtL2IgZnJhbWVzIGhhdmUgYmVlbiByZW5kZXJlZCAoYXZvaWRzIGZsYXNoaW5nKVxuICAgIGlmIChyLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMpIHtcbiAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICB9XG4gIH1cbiAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG4gIGlmIChyLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdykge1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICB9XG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcbiAgdmFyIHZwID0ge1xuICAgIHpvb206IHpvb20sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfVxuICB9O1xuICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTtcblxuICAvLyB3ZSB3YW50IHRoZSBsb3cgcXVhbGl0eSBtb3Rpb25ibHVyIG9ubHkgd2hlbiB0aGUgdmlld3BvcnQgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgZXRjICh3aGVyZSBpdCdzIG5vdCBub3RpY2VkKVxuICBpZiAoIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cbiAgaWYgKGZvcmNlZFBhbikge1xuICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgfVxuXG4gIC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cbiAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgZnVuY3Rpb24gbWJjbGVhcihjb250ZXh0LCB4LCB5LCB3LCBoKSB7XG4gICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kpO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH1cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcbiAgICBpZiAoIXIuY2xlYXJpbmdNb3Rpb25CbHVyICYmIChjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSkge1xuICAgICAgZVBhbiA9IHtcbiAgICAgICAgeDogcGFuLnggKiBtYlB4UmF0aW8sXG4gICAgICAgIHk6IHBhbi55ICogbWJQeFJhdGlvXG4gICAgICB9O1xuICAgICAgZVpvb20gPSB6b29tICogbWJQeFJhdGlvO1xuICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG4gICAgICB3ID0gci5jYW52YXNXaWR0aDtcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodDtcbiAgICB9XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGVQYW4ueCwgZVBhbi55KTtcbiAgICAgIGNvbnRleHQuc2NhbGUoZVpvb20sIGVab29tKTtcbiAgICB9XG4gICAgaWYgKGZvcmNlZFBhbikge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55KTtcbiAgICB9XG4gICAgaWYgKGZvcmNlZFpvb20pIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSk7XG4gICAgfVxuICB9XG4gIGlmICghdGV4dHVyZURyYXcpIHtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gIH1cbiAgaWYgKHRleHR1cmVEcmF3KSB7XG4gICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IHRydWU7XG4gICAgaWYgKCFyLnRleHR1cmVDYWNoZSkge1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICByLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9KTtcbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9XG4gICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScpLnZhbHVlO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGZhbHNlKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCh2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSBpZiAoci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCkge1xuICAgIC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG4gIHZhciBleHRlbnQgPSBjeS5leHRlbnQoKTtcbiAgdmFyIHZwTWFuaXAgPSByLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuY3kuYW5pbWF0ZWQoKTtcbiAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuICB2YXIgbmVlZE1iQ2xlYXIgPSBbXTtcbiAgbmVlZE1iQ2xlYXJbci5OT0RFXSA9ICFuZWVkRHJhd1tyLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYgKG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSB0cnVlO1xuICB9XG4gIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmIChuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gdHJ1ZTtcbiAgfVxuICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5OT0RFXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSA6IGRhdGEuY29udGV4dHNbci5OT0RFXSk7XG4gICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpO1xuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3TGF5ZXJlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG4gICAgaWYgKHIuZGVidWcpIHtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZyk7XG4gICAgfVxuICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkpIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQpO1xuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH1cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5kcmFnKTtcbiAgICB9XG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHRoaXMuZHJhd1NlbGVjdGlvblJlY3RhbmdsZShvcHRpb25zLCBzZXRDb250ZXh0VHJhbnNmb3JtKTtcblxuICAvLyBtb3Rpb25ibHVyOiBibGl0IHJlbmRlcmVkIGJsdXJyeSBmcmFtZXNcbiAgaWYgKG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxKSB7XG4gICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXTtcbiAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbci5EUkFHXTtcbiAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddO1xuICAgIHZhciBkcmF3TW90aW9uQmx1ciA9IGZ1bmN0aW9uIGRyYXdNb3Rpb25CbHVyKGN4dCwgdHh0LCBuZWVkQ2xlYXIpIHtcbiAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBpZiAobmVlZENsZWFyIHx8ICFtb3Rpb25CbHVyRmFkZUVmZmVjdCkge1xuICAgICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1iY2xlYXIoY3h0LCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9XG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuICAgICAgY3h0LmRyYXdJbWFnZSh0eHQsXG4gICAgICAvLyBpbWdcbiAgICAgIDAsIDAsXG4gICAgICAvLyBzeCwgc3lcbiAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLFxuICAgICAgLy8gc3csIHNoXG4gICAgICAwLCAwLFxuICAgICAgLy8geCwgeVxuICAgICAgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgLy8gdywgaFxuICAgICAgKTtcbiAgICB9O1xuICAgIGlmIChuZWVkRHJhd1tyLk5PREVdIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyW3IuTk9ERV0pO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobmVlZERyYXdbci5EUkFHXSB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhcltyLkRSQUddKTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgci5wcmV2Vmlld3BvcnQgPSB2cDtcbiAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICB9XG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5KTtcbiAgfVxuICBpZiAoIWZvcmNlZENvbnRleHQpIHtcbiAgICBjeS5lbWl0KCdyZW5kZXInKTtcbiAgfVxufTtcbnZhciBmcHNIZWlnaHQ7XG5DUnAkNS5kcmF3U2VsZWN0aW9uUmVjdGFuZ2xlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNldENvbnRleHRUcmFuc2Zvcm0pIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgdmFyIGRyYXdPbmx5Tm9kZUxheWVyID0gb3B0aW9ucy5kcmF3T25seU5vZGVMYXllcjtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICBpZiAoci5zaG93RnBzIHx8ICFkcmF3T25seU5vZGVMYXllciAmJiBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdICYmICFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbci5TRUxFQ1RfQk9YXTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQpO1xuICAgIGlmIChyLnNlbGVjdGlvbls0XSA9PSAxICYmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nKSkge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJykudmFsdWUgLyB6b29tO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgY29udGV4dC5maWxsUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3Qoci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzFdLCByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBwb3MgPSBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyhwb3MueCwgcG9zLnksIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1zaXplJykucGZWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICB2YXIgdGltZVRvUmVuZGVyID0gci5sYXN0UmVkcmF3VGltZTtcbiAgICBpZiAoci5zaG93RnBzICYmIHRpbWVUb1JlbmRlcikge1xuICAgICAgdGltZVRvUmVuZGVyID0gTWF0aC5yb3VuZCh0aW1lVG9SZW5kZXIpO1xuICAgICAgdmFyIGZwcyA9IE1hdGgucm91bmQoMTAwMCAvIHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgdGV4dCA9ICcxIGZyYW1lID0gJyArIHRpbWVUb1JlbmRlciArICcgbXMgPSAnICsgZnBzICsgJyBmcHMnO1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgLy8gY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgY29udGV4dC5mb250ID0gJzMwcHggQXJpYWwnO1xuICAgICAgaWYgKCFmcHNIZWlnaHQpIHtcbiAgICAgICAgdmFyIGRpbXMgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICBmcHNIZWlnaHQgPSBkaW1zLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCAwLCBmcHNIZWlnaHQpO1xuICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgY29udGV4dC5zdHJva2VSZWN0KDAsIGZwc0hlaWdodCArIDEwLCAyNTAsIDIwKTtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgZnBzSGVpZ2h0ICsgMTAsIDI1MCAqIE1hdGgubWluKGZwcyAvIG1heEZwcywgMSksIDIwKTtcbiAgICB9XG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE5vdGVzOlxuICogLSBBbGwgY29sb3JzIGhhdmUgcHJlbXVsdGlwbGllZCBhbHBoYS4gVmVyeSBpbXBvcnRhbnQgZm9yIHRleHR1ZXMgYW5kIFxuICogICBibGVuZGluZyB0byB3b3JrIGNvcnJlY3RseS5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcbiAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICB9XG4gIC8vIGNvbnNvbGUubG9nKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gIHJldHVybiBzaGFkZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTb3VyY2UsIGZyYWdlbWVudFNvdXJjZSkge1xuICB2YXIgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U291cmNlKTtcbiAgdmFyIGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnZW1lbnRTb3VyY2UpO1xuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXJzJyk7XG4gIH1cbiAgcmV0dXJuIHByb2dyYW07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvZmZzY3JlbiBjYW52YXMgd2l0aCBhIDJEIGNvbnRleHQsIGZvciB0aGVcbiAqIGNhbnZhcyByZW5kZXJlciB0byB1c2UgZm9yIGRyYXdpbmcgdGV4dHVyZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVDYW52YXMociwgd2lkdGgsIGhlaWdodCkge1xuICBpZiAoaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBoZWlnaHQgPSB3aWR0aDtcbiAgfVxuICB2YXIgY2FudmFzID0gci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgY3R4ID0gY2FudmFzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY2FudmFzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH07XG4gIGNhbnZhcy5jbGVhcigpO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGFuICYgem9vbSB2YWx1ZXMsIHNjYWxlZCBieSB0aGUgcGl4ZWwgcmF0aW8uXG4gKi9cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVBhblpvb20ocikge1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIucGl4ZWxSYXRpbztcbiAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgdmFyIHBhbiA9IHIuY3kucGFuKCk7XG4gIHJldHVybiB7XG4gICAgem9vbTogem9vbSAqIHBpeGVsUmF0aW8sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCAqIHBpeGVsUmF0aW8sXG4gICAgICB5OiBwYW4ueSAqIHBpeGVsUmF0aW9cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgem9vbSB2YWx1ZSwgc2NhbGVkIGJ5IHRoZSBwaXhlbCByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlWm9vbShyKSB7XG4gIHZhciBwaXhlbFJhdGlvID0gci5waXhlbFJhdGlvO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICByZXR1cm4gem9vbSAqIHBpeGVsUmF0aW87XG59XG5mdW5jdGlvbiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihyLCBwYW4sIHpvb20sIHgsIHkpIHtcbiAgdmFyIHJ4ID0geCAqIHpvb20gKyBwYW4ueDtcbiAgdmFyIHJ5ID0geSAqIHpvb20gKyBwYW4ueTtcbiAgcnkgPSBNYXRoLnJvdW5kKHIuY2FudmFzSGVpZ2h0IC0gcnkpOyAvLyBhZGp1c3QgZm9yIHdlYmdsXG4gIHJldHVybiBbcngsIHJ5XTtcbn1cbmZ1bmN0aW9uIGlzU2ltcGxlU2hhcGUobm9kZSkge1xuICAvLyB0aGUgYWN0dWFsIHNoYXBlIGlzIGNoZWNrZWQgaW4gRWxlbWVudERyYXdpbmdXZWJHTC5fZ2V0VmVydFR5cGVGb3JTaGFwZSgpXG4gIC8vIG5vIG5lZWQgdG8gY2hlY2sgaXQgdHdpY2UsIHRoaXMganVzdCBjaGVja3Mgb3RoZXIgdmlzdWFsIHByb3BlcnRpZXNcbiAgaWYgKG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWZpbGwnKS52YWx1ZSAhPT0gJ3NvbGlkJykgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnKS5zdHJWYWx1ZSAhPT0gJ25vbmUnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykudmFsdWUgPT09IDApIHJldHVybiB0cnVlO1xuICBpZiAobm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWUgPT09IDApIHJldHVybiB0cnVlO1xuICAvLyB3ZSBoYXZlIGEgYm9yZGVyIGJ1dCBpdCBtdXN0IGJlIHNpbXBsZVxuICBpZiAobm9kZS5wc3R5bGUoJ2JvcmRlci1zdHlsZScpLnZhbHVlICE9PSAnc29saWQnKSByZXR1cm4gZmFsc2U7XG4gIC8vIFRPRE8gaWdub3JpbmcgJ2JvcmRlci1jYXAnLCAnYm9yZGVyLWpvaW4nIGFuZCAnYm9yZGVyLXBvc2l0aW9uJyBmb3Igbm93XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXJyYXlFcXVhbChhMSwgYTIpIHtcbiAgaWYgKGExLmxlbmd0aCAhPT0gYTIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYTFbaV0gIT09IGEyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRha2VzIGNvbG9yICYgb3BhY2l0eSBzdHlsZSB2YWx1ZXMgYW5kIGNvbnZlcnRzIHRoZW0gdG8gV2ViR0wgZm9ybWF0LiBcbiAqIEFscGhhIGlzIHByZW11bHRpcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIHRvV2ViR0xDb2xvcihjb2xvciwgb3BhY2l0eSwgb3V0QXJyYXkpIHtcbiAgdmFyIHIgPSBjb2xvclswXSAvIDI1NTtcbiAgdmFyIGcgPSBjb2xvclsxXSAvIDI1NTtcbiAgdmFyIGIgPSBjb2xvclsyXSAvIDI1NTtcbiAgdmFyIGEgPSBvcGFjaXR5O1xuICB2YXIgYXJyID0gb3V0QXJyYXkgfHwgbmV3IEFycmF5KDQpO1xuICBhcnJbMF0gPSByICogYTtcbiAgYXJyWzFdID0gZyAqIGE7XG4gIGFyclsyXSA9IGIgKiBhO1xuICBhcnJbM10gPSBhO1xuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaW5kZXhUb1ZlYzQoaW5kZXgsIG91dEFycmF5KSB7XG4gIHZhciBhcnIgPSBvdXRBcnJheSB8fCBuZXcgQXJyYXkoNCk7XG4gIGFyclswXSA9IChpbmRleCA+PiAwICYgMHhGRikgLyAweEZGO1xuICBhcnJbMV0gPSAoaW5kZXggPj4gOCAmIDB4RkYpIC8gMHhGRjtcbiAgYXJyWzJdID0gKGluZGV4ID4+IDE2ICYgMHhGRikgLyAweEZGO1xuICBhcnJbM10gPSAoaW5kZXggPj4gMjQgJiAweEZGKSAvIDB4RkY7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiB2ZWM0VG9JbmRleCh2ZWM0KSB7XG4gIHJldHVybiB2ZWM0WzBdICsgKHZlYzRbMV0gPDwgOCkgKyAodmVjNFsyXSA8PCAxNikgKyAodmVjNFszXSA8PCAyNCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsLCBkZWJ1Z0lEKSB7XG4gIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICB0ZXh0dXJlLmJ1ZmZlciA9IGZ1bmN0aW9uIChvZmZzY3JlZW5DYW52YXMpIHtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUKTtcblxuICAgIC8vIHZlcnkgaW1wb3J0YW50LCB0aGlzIHRlbGxzIHdlYmdsIHRvIHByZW11bHRpcGx5IGNvbG9ycyBieSB0aGUgYWxwaGEgY2hhbm5lbFxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBvZmZzY3JlZW5DYW52YXMpO1xuICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICB9O1xuICB0ZXh0dXJlLmRlbGV0ZVRleHR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgfTtcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5mdW5jdGlvbiBnZXRUeXBlSW5mbyhnbCwgZ2xzbFR5cGUpIHtcbiAgc3dpdGNoIChnbHNsVHlwZSkge1xuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIHJldHVybiBbMSwgZ2wuRkxPQVQsIDRdO1xuICAgIGNhc2UgJ3ZlYzInOlxuICAgICAgcmV0dXJuIFsyLCBnbC5GTE9BVCwgNF07XG4gICAgY2FzZSAndmVjMyc6XG4gICAgICByZXR1cm4gWzMsIGdsLkZMT0FULCA0XTtcbiAgICBjYXNlICd2ZWM0JzpcbiAgICAgIHJldHVybiBbNCwgZ2wuRkxPQVQsIDRdO1xuICAgIGNhc2UgJ2ludCc6XG4gICAgICByZXR1cm4gWzEsIGdsLklOVCwgNF07XG4gICAgY2FzZSAnaXZlYzInOlxuICAgICAgcmV0dXJuIFsyLCBnbC5JTlQsIDRdO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlZEFycmF5KGdsLCBnbFR5cGUsIGRhdGFPclNpemUpIHtcbiAgc3dpdGNoIChnbFR5cGUpIHtcbiAgICBjYXNlIGdsLkZMT0FUOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YU9yU2l6ZSk7XG4gICAgY2FzZSBnbC5JTlQ6XG4gICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoZGF0YU9yU2l6ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVkQXJyYXlWaWV3KGdsLCBnbFR5cGUsIGFycmF5LCBzdHJpZGUsIHNpemUsIGkpIHtcbiAgc3dpdGNoIChnbFR5cGUpIHtcbiAgICBjYXNlIGdsLkZMT0FUOlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkuYnVmZmVyLCBpICogc3RyaWRlLCBzaXplKTtcbiAgICBjYXNlIGdsLklOVDpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShhcnJheS5idWZmZXIsIGkgKiBzdHJpZGUsIHNpemUpO1xuICB9XG59XG5cbi8qKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlclN0YXRpY0RyYXcoZ2wsIHR5cGUsIGF0dHJpYnV0ZUxvYywgZGF0YUFycmF5KSB7XG4gIHZhciBfZ2V0VHlwZUluZm8gPSBnZXRUeXBlSW5mbyhnbCwgdHlwZSksXG4gICAgX2dldFR5cGVJbmZvMiA9IF9zbGljZWRUb0FycmF5KF9nZXRUeXBlSW5mbywgMiksXG4gICAgc2l6ZSA9IF9nZXRUeXBlSW5mbzJbMF0sXG4gICAgZ2xUeXBlID0gX2dldFR5cGVJbmZvMlsxXTtcbiAgdmFyIGRhdGEgPSBjcmVhdGVUeXBlZEFycmF5KGdsLCBnbFR5cGUsIGRhdGFBcnJheSk7XG4gIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG4gIGlmIChnbFR5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2MsIHNpemUsIGdsVHlwZSwgZmFsc2UsIDAsIDApO1xuICB9IGVsc2UgaWYgKGdsVHlwZSA9PT0gZ2wuSU5UKSB7XG4gICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoYXR0cmlidXRlTG9jLCBzaXplLCBnbFR5cGUsIDAsIDApO1xuICB9XG4gIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZUxvYyk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqIFxuICogQ3JlYXRlcyBhIGZsb2F0IGJ1ZmZlciB3aXRoIGdsLkRZTkFNSUNfRFJBVy5cbiAqIFRoZSByZXR1cm5lZCBidWZmZXIgb2JqZWN0IGNvbnRhaW5zIGZ1bmN0aW9ucyB0byBlYXNpbHkgc2V0IGluc3RhbmNlIGRhdGEgYW5kIGJ1ZmZlciB0aGUgZGF0YSBiZWZvcmUgYSBkcmF3IGNhbGwuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBpbnN0YW5jZXMsIHR5cGUsIGF0dHJpYnV0ZUxvYykge1xuICB2YXIgX2dldFR5cGVJbmZvMyA9IGdldFR5cGVJbmZvKGdsLCB0eXBlKSxcbiAgICBfZ2V0VHlwZUluZm80ID0gX3NsaWNlZFRvQXJyYXkoX2dldFR5cGVJbmZvMywgMyksXG4gICAgc2l6ZSA9IF9nZXRUeXBlSW5mbzRbMF0sXG4gICAgZ2xUeXBlID0gX2dldFR5cGVJbmZvNFsxXSxcbiAgICBieXRlcyA9IF9nZXRUeXBlSW5mbzRbMl07XG4gIHZhciBkYXRhQXJyYXkgPSBjcmVhdGVUeXBlZEFycmF5KGdsLCBnbFR5cGUsIGluc3RhbmNlcyAqIHNpemUpO1xuICB2YXIgc3RyaWRlID0gc2l6ZSAqIGJ5dGVzO1xuICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgaW5zdGFuY2VzICogc3RyaWRlLCBnbC5EWU5BTUlDX0RSQVcpO1xuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2MpO1xuICBpZiAoZ2xUeXBlID09PSBnbC5GTE9BVCkge1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlTG9jLCBzaXplLCBnbFR5cGUsIGZhbHNlLCBzdHJpZGUsIDApO1xuICB9IGVsc2UgaWYgKGdsVHlwZSA9PT0gZ2wuSU5UKSB7XG4gICAgZ2wudmVydGV4QXR0cmliSVBvaW50ZXIoYXR0cmlidXRlTG9jLCBzaXplLCBnbFR5cGUsIHN0cmlkZSwgMCk7XG4gIH1cbiAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyaWJ1dGVMb2MsIDEpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG5cbiAgLy8gdXNlIGFycmF5IHZpZXdzIHRvIHNldCB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgYnVmZmVyIGFycmF5XG4gIHZhciB2aWV3cyA9IG5ldyBBcnJheShpbnN0YW5jZXMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlczsgaSsrKSB7XG4gICAgdmlld3NbaV0gPSBjcmVhdGVUeXBlZEFycmF5VmlldyhnbCwgZ2xUeXBlLCBkYXRhQXJyYXksIHN0cmlkZSwgc2l6ZSwgaSk7XG4gIH1cbiAgYnVmZmVyLmRhdGFBcnJheSA9IGRhdGFBcnJheTtcbiAgYnVmZmVyLnN0cmlkZSA9IHN0cmlkZTtcbiAgYnVmZmVyLnNpemUgPSBzaXplO1xuICBidWZmZXIuZ2V0VmlldyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIHZpZXdzW2ldO1xuICB9O1xuICBidWZmZXIuc2V0UG9pbnQgPSBmdW5jdGlvbiAoaSwgeCwgeSkge1xuICAgIHZhciB2aWV3ID0gdmlld3NbaV07XG4gICAgdmlld1swXSA9IHg7XG4gICAgdmlld1sxXSA9IHk7XG4gIH07XG4gIGJ1ZmZlci5idWZmZXJTdWJEYXRhID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgZGF0YUFycmF5LCAwLCBjb3VudCAqIHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgZGF0YUFycmF5KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBidWZmZXI7XG59XG5cbi8qKiBcbiAqIENyZWF0ZXMgYSBidWZmZXIgb2YgM3gzIG1hdHJpeCBkYXRhIGZvciB1c2UgYXMgYXR0cmlidXRlIGRhdGEuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZTN4M01hdHJpeEJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBpbnN0YW5jZXMsIGF0dHJpYnV0ZUxvYykge1xuICB2YXIgbWF0cml4U2l6ZSA9IDk7IC8vIDN4MyBtYXRyaXhcbiAgdmFyIG1hdHJpeERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGluc3RhbmNlcyAqIG1hdHJpeFNpemUpO1xuXG4gIC8vIHVzZSBtYXRyaXggdmlld3MgdG8gc2V0IHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBtYXRyaXhEYXRhIGFycmF5XG4gIHZhciBtYXRyaXhWaWV3cyA9IG5ldyBBcnJheShpbnN0YW5jZXMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlczsgaSsrKSB7XG4gICAgdmFyIGJ5dGVPZmZzZXQgPSBpICogbWF0cml4U2l6ZSAqIDQ7IC8vIDQgYnl0ZXMgcGVyIGZsb2F0XG4gICAgbWF0cml4Vmlld3NbaV0gPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeERhdGEuYnVmZmVyLCBieXRlT2Zmc2V0LCBtYXRyaXhTaXplKTsgLy8gYXJyYXkgdmlld1xuICB9XG4gIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtYXRyaXhEYXRhLmJ5dGVMZW5ndGgsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgLy8gZWFjaCByb3cgb2YgdGhlIG1hdHJpeCBuZWVkcyB0byBiZSBhIHNlcGFyYXRlIGF0dHJpYnV0ZVxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgMzsgX2krKykge1xuICAgIHZhciBsb2MgPSBhdHRyaWJ1dGVMb2MgKyBfaTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDMgKiAxMiwgX2kgKiAxMik7XG4gICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2MsIDEpO1xuICB9XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgYnVmZmVyLmdldE1hdHJpeFZpZXcgPSBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBtYXRyaXhWaWV3c1tpXTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgaXMgdG9vIHNsb3csIHVzZSBnZXRNYXRyaXhWaWV3IGFuZCBwYXNzIHRoZSB2aWV3IGRpcmVjdGx5IHRvIHRoZSBnbG1hdHJpeCBsaWJyYXJ5XG4gIGJ1ZmZlci5zZXREYXRhID0gZnVuY3Rpb24gKG1hdHJpeCwgaSkge1xuICAgIG1hdHJpeFZpZXdzW2ldLnNldChtYXRyaXgsIDApO1xuICB9O1xuICBidWZmZXIuYnVmZmVyU3ViRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgbWF0cml4RGF0YSk7XG4gIH07XG4gIHJldHVybiBidWZmZXI7XG59XG5cbi8qKiBcbiAqIENyZWF0ZXMgYSBGcmFtZSBCdWZmZXIgdG8gdXNlIGZvciBvZmZzY3JlZW4gcmVuZGVyaW5nLlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFxuICovXG5mdW5jdGlvbiBjcmVhdGVQaWNraW5nRnJhbWVCdWZmZXIoZ2wpIHtcbiAgLy8gQ3JlYXRlIGFuZCBiaW5kIHRoZSBmcmFtZWJ1ZmZlclxuICB2YXIgZmIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiKTtcblxuICAvLyBDcmVhdGUgYSB0ZXh0dXJlIHRvIHJlbmRlciB0b1xuICB2YXIgdGFyZ2V0VGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGFyZ2V0VGV4dHVyZSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgLy8gYXR0YWNoIHRoZSB0ZXh0dXJlIGFzIHRoZSBmaXJzdCBjb2xvciBhdHRhY2htZW50XG4gIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGFyZ2V0VGV4dHVyZSwgMCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gIGZiLnNldEZyYW1lYnVmZmVyQXR0YWNobWVudFNpemVzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0YXJnZXRUZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICB9O1xuICByZXR1cm4gZmI7XG59XG5cbi8qKlxuICogQ29tbW9uIHV0aWxpdGllc1xuICogQG1vZHVsZSBnbE1hdHJpeFxuICovXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xudmFyIEFSUkFZX1RZUEUgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgeSA9IDAsXG4gICAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KHkpO1xufTtcblxuLyoqXG4gKiAzeDMgTWF0cml4XG4gKiBAbW9kdWxlIG1hdDNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEFSUkFZX1RZUEUoOSk7XG5cbiAgaWYgKEFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICAgIGIwMSA9IGJbMV0sXG4gICAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICAgIGIxMSA9IGJbNF0sXG4gICAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICAgIGIyMSA9IGJbN10sXG4gICAgICBiMjIgPSBiWzhdO1xuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cblxuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSB4ICogYVswXTtcbiAgb3V0WzFdID0geCAqIGFbMV07XG4gIG91dFsyXSA9IHggKiBhWzJdO1xuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSAyRCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgeW91ciBnbCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gLTE7XG4gIG91dFs3XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIEEgXCJ0ZXh0dXJlIGF0bGFzXCIgaXMgYSBiaWcgY2FudmFzLCBhbmQgc2VjdGlvbnMgb2YgaXQgYXJlIHVzZWQgYXMgdGV4dHVyZXMgZm9yIG5vZGVzL2xhYmVscy5cblxuLyoqXG4gKiBBIHNpbmdsZSBzcXVhcmUgdGV4dHVyZSBhdGxhcyAoYWxzbyBrbm93biBhcyBhIFwic3ByaXRlIHNoZWV0XCIpLlxuICovXG52YXIgQXRsYXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdGxhcyhyLCB0ZXhTaXplLCB0ZXhSb3dzLCBjcmVhdGVUZXh0dXJlQ2FudmFzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0bGFzKTtcbiAgICB0aGlzLmRlYnVnSUQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLnRleFNpemUgPSB0ZXhTaXplO1xuICAgIHRoaXMudGV4Um93cyA9IHRleFJvd3M7XG4gICAgdGhpcy50ZXhIZWlnaHQgPSBNYXRoLmZsb29yKHRleFNpemUgLyB0ZXhSb3dzKTtcbiAgICB0aGlzLmVuYWJsZVdyYXBwaW5nID0gdHJ1ZTsgLy8gaGFyZGNvZGVkIGZvciBub3csIGNhbiBiZSBtYWRlIGFuIG9wdGlvblxuXG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTsgLy8gb25jZSBhbiBhdGxhcyBpcyBsb2NrZWQgaXQgY2FuIG5vIGxvbmdlciBiZSBkcmF3biB0b1xuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7IC8vIFdlYkdMVGV4dHVyZSBvYmplY3RcbiAgICB0aGlzLm5lZWRzQnVmZmVyID0gdHJ1ZTtcblxuICAgIC8vIGEgXCJsb2NhdGlvblwiIGlzIGFuIHBvaW50ZXIgaW50byB0aGUgYXRsYXMgd2l0aCBhICdyb3cnIGFuZCAneCcgZmllbGRzXG4gICAgdGhpcy5mcmVlUG9pbnRlciA9IHtcbiAgICAgIHg6IDAsXG4gICAgICByb3c6IDBcbiAgICB9O1xuXG4gICAgLy8gbWFwIGZyb20gdGhlIHN0eWxlIGtleSB0byB0aGUgcm93L3ggd2hlcmUgdGhlIHRleHR1cmUgc3RhcnRzXG4gICAgLy8gaWYgdGhlIHRleHR1cmUgd3JhcHMgdGhlbiB0aGVyZSdzIGEgc2Vjb25kIGxvY2F0aW9uXG4gICAgdGhpcy5rZXlUb0xvY2F0aW9uID0gbmV3IE1hcCgpOyAvLyBzdHlsZUtleSAtPiBbIGxvY2F0aW9uLCBsb2NhdGlvbiBdXG5cbiAgICB0aGlzLmNhbnZhcyA9IGNyZWF0ZVRleHR1cmVDYW52YXMociwgdGV4U2l6ZSwgdGV4U2l6ZSk7XG4gICAgdGhpcy5zY3JhdGNoID0gY3JlYXRlVGV4dHVyZUNhbnZhcyhyLCB0ZXhTaXplLCB0aGlzLnRleEhlaWdodCwgJ3NjcmF0Y2gnKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF0bGFzLCBbe1xuICAgIGtleTogXCJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvY2soKSB7XG4gICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0S2V5cygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMua2V5VG9Mb2NhdGlvbi5rZXlzKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY2FsZShfcmVmKSB7XG4gICAgICB2YXIgdyA9IF9yZWYudyxcbiAgICAgICAgaCA9IF9yZWYuaDtcbiAgICAgIHZhciB0ZXhIZWlnaHQgPSB0aGlzLnRleEhlaWdodCxcbiAgICAgICAgbWF4VGV4V2lkdGggPSB0aGlzLnRleFNpemU7XG4gICAgICAvLyB0cnkgdG8gZml0IHRvIHRoZSBoZWlnaHQgb2YgYSByb3dcbiAgICAgIHZhciBzY2FsZSA9IHRleEhlaWdodCAvIGg7IC8vIFRPRE8gd2hhdCBhYm91dCBwaXhlbFJhdGlvP1xuICAgICAgdmFyIHRleFcgPSB3ICogc2NhbGU7XG4gICAgICB2YXIgdGV4SCA9IGggKiBzY2FsZTtcbiAgICAgIC8vIGlmIHRoZSBzY2FsZWQgd2lkdGggaXMgdG9vIHdpZGUgdGhlbiBzY2FsZSB0byBmaXQgbWF4IHdpZHRoIGluc3RlYWRcbiAgICAgIGlmICh0ZXhXID4gbWF4VGV4V2lkdGgpIHtcbiAgICAgICAgc2NhbGUgPSBtYXhUZXhXaWR0aCAvIHc7XG4gICAgICAgIHRleFcgPSB3ICogc2NhbGU7XG4gICAgICAgIHRleEggPSBoICogc2NhbGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHRleFc6IHRleFcsXG4gICAgICAgIHRleEg6IHRleEhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhrZXksIGJiLCBkb0RyYXdpbmcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5sb2NrZWQpIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBkcmF3LCBhdGxhcyBpcyBsb2NrZWQnKTtcbiAgICAgIHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplLFxuICAgICAgICB0ZXhSb3dzID0gdGhpcy50ZXhSb3dzLFxuICAgICAgICB0ZXhIZWlnaHQgPSB0aGlzLnRleEhlaWdodDtcbiAgICAgIHZhciBfdGhpcyRnZXRTY2FsZSA9IHRoaXMuZ2V0U2NhbGUoYmIpLFxuICAgICAgICBzY2FsZSA9IF90aGlzJGdldFNjYWxlLnNjYWxlLFxuICAgICAgICB0ZXhXID0gX3RoaXMkZ2V0U2NhbGUudGV4VyxcbiAgICAgICAgdGV4SCA9IF90aGlzJGdldFNjYWxlLnRleEg7XG4gICAgICB2YXIgZHJhd0F0ID0gZnVuY3Rpb24gZHJhd0F0KGxvY2F0aW9uLCBjYW52YXMpIHtcbiAgICAgICAgaWYgKGRvRHJhd2luZyAmJiBjYW52YXMpIHtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5jb250ZXh0O1xuICAgICAgICAgIHZhciB4ID0gbG9jYXRpb24ueCxcbiAgICAgICAgICAgIHJvdyA9IGxvY2F0aW9uLnJvdztcbiAgICAgICAgICB2YXIgeE9mZnNldCA9IHg7XG4gICAgICAgICAgdmFyIHlPZmZzZXQgPSB0ZXhIZWlnaHQgKiByb3c7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgICAgIGRvRHJhd2luZyhjb250ZXh0LCBiYik7XG4gICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgbG9jYXRpb25zID0gW251bGwsIG51bGxdO1xuICAgICAgdmFyIGRyYXdOb3JtYWwgPSBmdW5jdGlvbiBkcmF3Tm9ybWFsKCkge1xuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHdyYXAsIGRyYXcgZGlyZWN0bHkgb24gdGhlIGNhbnZhc1xuICAgICAgICBkcmF3QXQoX3RoaXMuZnJlZVBvaW50ZXIsIF90aGlzLmNhbnZhcyk7XG4gICAgICAgIGxvY2F0aW9uc1swXSA9IHtcbiAgICAgICAgICB4OiBfdGhpcy5mcmVlUG9pbnRlci54LFxuICAgICAgICAgIHk6IF90aGlzLmZyZWVQb2ludGVyLnJvdyAqIHRleEhlaWdodCxcbiAgICAgICAgICB3OiB0ZXhXLFxuICAgICAgICAgIGg6IHRleEhcbiAgICAgICAgfTtcbiAgICAgICAgbG9jYXRpb25zWzFdID0ge1xuICAgICAgICAgIC8vIGNyZWF0ZSBhIHNlY29uZCBsb2NhdGlvbiB3aXRoIGEgd2lkdGggb2YgMCwgZm9yIGNvbnZlbmllbmNlXG4gICAgICAgICAgeDogX3RoaXMuZnJlZVBvaW50ZXIueCArIHRleFcsXG4gICAgICAgICAgeTogX3RoaXMuZnJlZVBvaW50ZXIucm93ICogdGV4SGVpZ2h0LFxuICAgICAgICAgIHc6IDAsXG4gICAgICAgICAgaDogdGV4SFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1vdmUgdGhlIHBvaW50ZXIgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dHVyZVxuICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci54ICs9IHRleFc7XG4gICAgICAgIGlmIChfdGhpcy5mcmVlUG9pbnRlci54ID09IHRleFNpemUpIHtcbiAgICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci54ID0gMDtcbiAgICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci5yb3crKztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBkcmF3V3JhcHBlZCA9IGZ1bmN0aW9uIGRyYXdXcmFwcGVkKCkge1xuICAgICAgICB2YXIgc2NyYXRjaCA9IF90aGlzLnNjcmF0Y2gsXG4gICAgICAgICAgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuXG4gICAgICAgIC8vIERyYXcgdG8gdGhlIHNjcmF0Y2ggY2FudmFzXG4gICAgICAgIHNjcmF0Y2guY2xlYXIoKTtcbiAgICAgICAgZHJhd0F0KHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHJvdzogMFxuICAgICAgICB9LCBzY3JhdGNoKTtcbiAgICAgICAgdmFyIGZpcnN0VGV4VyA9IHRleFNpemUgLSBfdGhpcy5mcmVlUG9pbnRlci54O1xuICAgICAgICB2YXIgc2Vjb25kVGV4VyA9IHRleFcgLSBmaXJzdFRleFc7XG4gICAgICAgIHZhciBoID0gdGV4SGVpZ2h0O1xuICAgICAgICB7XG4gICAgICAgICAgLy8gY29weSBmaXJzdCBwYXJ0IG9mIHNjcmF0Y2ggdG8gdGhlIGZpcnN0IHRleHR1cmVcbiAgICAgICAgICB2YXIgZHggPSBfdGhpcy5mcmVlUG9pbnRlci54O1xuICAgICAgICAgIHZhciBkeSA9IF90aGlzLmZyZWVQb2ludGVyLnJvdyAqIHRleEhlaWdodDtcbiAgICAgICAgICB2YXIgdyA9IGZpcnN0VGV4VztcbiAgICAgICAgICBjYW52YXMuY29udGV4dC5kcmF3SW1hZ2Uoc2NyYXRjaCwgMCwgMCwgdywgaCwgZHgsIGR5LCB3LCBoKTtcbiAgICAgICAgICBsb2NhdGlvbnNbMF0gPSB7XG4gICAgICAgICAgICB4OiBkeCxcbiAgICAgICAgICAgIHk6IGR5LFxuICAgICAgICAgICAgdzogdyxcbiAgICAgICAgICAgIGg6IHRleEhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBjb3B5IHNlY29uZCBwYXJ0IG9mIHNjcmF0Y2ggdG8gdGhlIHNlY29uZCB0ZXh0dXJlXG4gICAgICAgICAgdmFyIHN4ID0gZmlyc3RUZXhXO1xuICAgICAgICAgIHZhciBfZHkgPSAoX3RoaXMuZnJlZVBvaW50ZXIucm93ICsgMSkgKiB0ZXhIZWlnaHQ7XG4gICAgICAgICAgdmFyIF93ID0gc2Vjb25kVGV4VztcbiAgICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICBjYW52YXMuY29udGV4dC5kcmF3SW1hZ2Uoc2NyYXRjaCwgc3gsIDAsIF93LCBoLCAwLCBfZHksIF93LCBoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYXRpb25zWzFdID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IF9keSxcbiAgICAgICAgICAgIHc6IF93LFxuICAgICAgICAgICAgaDogdGV4SFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIueCA9IHNlY29uZFRleFc7XG4gICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnJvdysrO1xuICAgICAgfTtcbiAgICAgIHZhciBtb3ZlVG9TdGFydE9mTmV4dFJvdyA9IGZ1bmN0aW9uIG1vdmVUb1N0YXJ0T2ZOZXh0Um93KCkge1xuICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci54ID0gMDtcbiAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIucm93Kys7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZnJlZVBvaW50ZXIueCArIHRleFcgPD0gdGV4U2l6ZSkge1xuICAgICAgICAvLyBUaGVyZSdzIGVub3VnaCBzcGFjZSBpbiB0aGUgY3VycmVudCByb3dcbiAgICAgICAgZHJhd05vcm1hbCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZyZWVQb2ludGVyLnJvdyA+PSB0ZXhSb3dzIC0gMSkge1xuICAgICAgICAvLyBOZWVkIHRvIG1vdmUgdG8gdGhlIG5leHQgcm93LCBidXQgdGhlcmUgYXJlIG5vIG1vcmUgcm93cywgYXRsYXMgaXMgZnVsbC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZyZWVQb2ludGVyLnggPT09IHRleFNpemUpIHtcbiAgICAgICAgLy8gaGFwcGVuIHRvIGJlIHJpZ2h0IGF0IGVuZCBvZiBjdXJyZW50IHJvd1xuICAgICAgICBtb3ZlVG9TdGFydE9mTmV4dFJvdygpO1xuICAgICAgICBkcmF3Tm9ybWFsKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZW5hYmxlV3JhcHBpbmcpIHtcbiAgICAgICAgLy8gZHJhdyBwYXJ0IG9mIHRoZSB0ZXh0dXJlIHRvIHRoZSBlbmQgb2YgdGhlIGN1cmVudCByb3csIHRoZW4gd3JhcCB0byB0aGUgbmV4dCByb3dcbiAgICAgICAgZHJhd1dyYXBwZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHJvdywgdGhlbiBkcmF3IG5vcm1hbGx5XG4gICAgICAgIG1vdmVUb1N0YXJ0T2ZOZXh0Um93KCk7XG4gICAgICAgIGRyYXdOb3JtYWwoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5VG9Mb2NhdGlvbi5zZXQoa2V5LCBsb2NhdGlvbnMpO1xuICAgICAgdGhpcy5uZWVkc0J1ZmZlciA9IHRydWU7XG4gICAgICByZXR1cm4gbG9jYXRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPZmZzZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9mZnNldHMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlUb0xvY2F0aW9uLmdldChrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0VtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmVlUG9pbnRlci54ID09PSAwICYmIHRoaXMuZnJlZVBvaW50ZXIucm93ID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5GaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuRml0KGJiKSB7XG4gICAgICBpZiAodGhpcy5sb2NrZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplLFxuICAgICAgICB0ZXhSb3dzID0gdGhpcy50ZXhSb3dzO1xuICAgICAgdmFyIF90aGlzJGdldFNjYWxlMiA9IHRoaXMuZ2V0U2NhbGUoYmIpLFxuICAgICAgICB0ZXhXID0gX3RoaXMkZ2V0U2NhbGUyLnRleFc7XG4gICAgICBpZiAodGhpcy5mcmVlUG9pbnRlci54ICsgdGV4VyA+IHRleFNpemUpIHtcbiAgICAgICAgLy8gbmVlZCB0byB3cmFwXG4gICAgICAgIHJldHVybiB0aGlzLmZyZWVQb2ludGVyLnJvdyA8IHRleFJvd3MgLSAxOyAvLyByZXR1cm4gdHJ1ZSBpZiB0aGVyZSdzIGEgcm93IHRvIHdyYXAgdG9cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNhbGxlZCBvbiBldmVyeSBmcmFtZVxuICB9LCB7XG4gICAga2V5OiBcImJ1ZmZlcklmTmVlZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlcklmTmVlZGVkKGdsKSB7XG4gICAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCB0aGlzLmRlYnVnSUQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVlZHNCdWZmZXIpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmJ1ZmZlcih0aGlzLmNhbnZhcyk7XG4gICAgICAgIHRoaXMubmVlZHNCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICAgIHRoaXMuc2NyYXRjaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUuZGVsZXRlVGV4dHVyZSgpO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5zY3JhdGNoID0gbnVsbDtcbiAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdGV4dHVyZSBhdGxhc2VzLCBhbGwgb2YgdGhlIHNhbWUgXCJyZW5kZXIgdHlwZVwiLiBcbiAqICgnbm9kZS1ib2R5JyBpcyBhbiBleGFtcGxlIG9mIGEgcmVuZGVyIHR5cGUuKVxuICogQW4gQXRsYXNDb2xsZWN0aW9uIGNhbiBhbHNvIGJlIG5vdGlmaWVkIHdoZW4gYSB0ZXh0dXJlIGlzIG5vIGxvbmdlciBuZWVkZWQsIFxuICogYW5kIGl0IGNhbiBnYXJiYWdlIGNvbGxlY3QgdGhlIHVudXNlZCB0ZXh0dXJlcy5cbiAqL1xudmFyIEF0bGFzQ29sbGVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0bGFzQ29sbGVjdGlvbihyLCB0ZXhTaXplLCB0ZXhSb3dzLCBjcmVhdGVUZXh0dXJlQ2FudmFzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0bGFzQ29sbGVjdGlvbik7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLnRleFNpemUgPSB0ZXhTaXplO1xuICAgIHRoaXMudGV4Um93cyA9IHRleFJvd3M7XG4gICAgdGhpcy5jcmVhdGVUZXh0dXJlQ2FudmFzID0gY3JlYXRlVGV4dHVyZUNhbnZhcztcbiAgICB0aGlzLmF0bGFzZXMgPSBbXTtcbiAgICB0aGlzLnN0eWxlS2V5VG9BdGxhcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm1hcmtlZEtleXMgPSBuZXcgU2V0KCk7IC8vIG1hcmtlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdGxhc0NvbGxlY3Rpb24sIFt7XG4gICAga2V5OiBcImdldEtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0S2V5cygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuc3R5bGVLZXlUb0F0bGFzLmtleXMoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVBdGxhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQXRsYXMoKSB7XG4gICAgICB2YXIgciA9IHRoaXMucixcbiAgICAgICAgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZSxcbiAgICAgICAgdGV4Um93cyA9IHRoaXMudGV4Um93cyxcbiAgICAgICAgY3JlYXRlVGV4dHVyZUNhbnZhcyA9IHRoaXMuY3JlYXRlVGV4dHVyZUNhbnZhcztcbiAgICAgIHJldHVybiBuZXcgQXRsYXMociwgdGV4U2l6ZSwgdGV4Um93cywgY3JlYXRlVGV4dHVyZUNhbnZhcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTY3JhdGNoQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTY3JhdGNoQ2FudmFzKCkge1xuICAgICAgaWYgKCF0aGlzLnNjcmF0Y2gpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnIsXG4gICAgICAgICAgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZSxcbiAgICAgICAgICB0ZXhSb3dzID0gdGhpcy50ZXhSb3dzLFxuICAgICAgICAgIGNyZWF0ZVRleHR1cmVDYW52YXMgPSB0aGlzLmNyZWF0ZVRleHR1cmVDYW52YXM7XG4gICAgICAgIHZhciB0ZXhIZWlnaHQgPSBNYXRoLmZsb29yKHRleFNpemUgLyB0ZXhSb3dzKTtcbiAgICAgICAgdGhpcy5zY3JhdGNoID0gY3JlYXRlVGV4dHVyZUNhbnZhcyhyLCB0ZXhTaXplLCB0ZXhIZWlnaHQsICdzY3JhdGNoJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY3JhdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoa2V5LCBiYiwgZG9EcmF3aW5nKSB7XG4gICAgICB2YXIgYXRsYXMgPSB0aGlzLnN0eWxlS2V5VG9BdGxhcy5nZXQoa2V5KTtcbiAgICAgIGlmICghYXRsYXMpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGxhc3QgYXRsYXNcbiAgICAgICAgYXRsYXMgPSB0aGlzLmF0bGFzZXNbdGhpcy5hdGxhc2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWF0bGFzIHx8ICFhdGxhcy5jYW5GaXQoYmIpKSB7XG4gICAgICAgICAgaWYgKGF0bGFzKSBhdGxhcy5sb2NrKCk7XG4gICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGF0bGFzXG4gICAgICAgICAgYXRsYXMgPSB0aGlzLl9jcmVhdGVBdGxhcygpO1xuICAgICAgICAgIHRoaXMuYXRsYXNlcy5wdXNoKGF0bGFzKTtcbiAgICAgICAgfVxuICAgICAgICBhdGxhcy5kcmF3KGtleSwgYmIsIGRvRHJhd2luZyk7XG4gICAgICAgIHRoaXMuc3R5bGVLZXlUb0F0bGFzLnNldChrZXksIGF0bGFzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdGxhcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZUtleVRvQXRsYXMuZ2V0KGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0F0bGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0F0bGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVLZXlUb0F0bGFzLmhhcyhrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXJrS2V5Rm9yR0NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya0tleUZvckdDKGtleSkge1xuICAgICAgdGhpcy5tYXJrZWRLZXlzLmFkZChrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnYygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIG1hcmtlZEtleXMgPSB0aGlzLm1hcmtlZEtleXM7XG4gICAgICBpZiAobWFya2VkS2V5cy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdub3RoaW5nIHRvIGdhcmJhZ2UgY29sbGVjdCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3QXRsYXNlcyA9IFtdO1xuICAgICAgdmFyIG5ld1N0eWxlS2V5VG9BdGxhcyA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBuZXdBdGxhcyA9IG51bGw7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5hdGxhc2VzKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgYXRsYXMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5cyA9IGF0bGFzLmdldEtleXMoKTtcbiAgICAgICAgICB2YXIga2V5c1RvQ29sbGVjdCA9IGludGVyc2VjdGlvbihtYXJrZWRLZXlzLCBrZXlzKTtcbiAgICAgICAgICBpZiAoa2V5c1RvQ29sbGVjdC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGF0bGFzIGNhbiBzdGlsbCBiZSB1c2VkXG4gICAgICAgICAgICBuZXdBdGxhc2VzLnB1c2goYXRsYXMpO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdTdHlsZUtleVRvQXRsYXMuc2V0KGssIGF0bGFzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIDE7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbmV3QXRsYXMpIHtcbiAgICAgICAgICAgIG5ld0F0bGFzID0gX3RoaXMyLl9jcmVhdGVBdGxhcygpO1xuICAgICAgICAgICAgbmV3QXRsYXNlcy5wdXNoKG5ld0F0bGFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihrZXlzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCFrZXlzVG9Db2xsZWN0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hdGxhcyRnZXRPZmZzZXRzID0gYXRsYXMuZ2V0T2Zmc2V0cyhrZXkpLFxuICAgICAgICAgICAgICAgICAgX2F0bGFzJGdldE9mZnNldHMyID0gX3NsaWNlZFRvQXJyYXkoX2F0bGFzJGdldE9mZnNldHMsIDIpLFxuICAgICAgICAgICAgICAgICAgczEgPSBfYXRsYXMkZ2V0T2Zmc2V0czJbMF0sXG4gICAgICAgICAgICAgICAgICBzMiA9IF9hdGxhcyRnZXRPZmZzZXRzMlsxXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5ld0F0bGFzLmNhbkZpdCh7XG4gICAgICAgICAgICAgICAgICB3OiBzMS53ICsgczIudyxcbiAgICAgICAgICAgICAgICAgIGg6IHMxLmhcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgbmV3QXRsYXMubG9jaygpO1xuICAgICAgICAgICAgICAgICAgbmV3QXRsYXMgPSBfdGhpczIuX2NyZWF0ZUF0bGFzKCk7XG4gICAgICAgICAgICAgICAgICBuZXdBdGxhc2VzLnB1c2gobmV3QXRsYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXRsYXMuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGV4dHVyZSBjYW4ndCBiZSBjb3BpZWQgdGhlbiBpdCB3aWxsIGhhdmUgdG8gYmUgcmVkcmF3biBvbiB0aGUgbmV4dCBmcmFtZVxuICAgICAgICAgICAgICAgICAgX3RoaXMyLl9jb3B5VGV4dHVyZVRvTmV3QXRsYXMoa2V5LCBhdGxhcywgbmV3QXRsYXMpO1xuICAgICAgICAgICAgICAgICAgbmV3U3R5bGVLZXlUb0F0bGFzLnNldChrZXksIG5ld0F0bGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXRsYXMuZGlzcG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIGlmIChfbG9vcCgpKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgdGhpcy5hdGxhc2VzID0gbmV3QXRsYXNlcztcbiAgICAgIHRoaXMuc3R5bGVLZXlUb0F0bGFzID0gbmV3U3R5bGVLZXlUb0F0bGFzO1xuICAgICAgdGhpcy5tYXJrZWRLZXlzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY29weVRleHR1cmVUb05ld0F0bGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb3B5VGV4dHVyZVRvTmV3QXRsYXMoa2V5LCBvbGRBdGxhcywgbmV3QXRsYXMpIHtcbiAgICAgIHZhciBfb2xkQXRsYXMkZ2V0T2Zmc2V0cyA9IG9sZEF0bGFzLmdldE9mZnNldHMoa2V5KSxcbiAgICAgICAgX29sZEF0bGFzJGdldE9mZnNldHMyID0gX3NsaWNlZFRvQXJyYXkoX29sZEF0bGFzJGdldE9mZnNldHMsIDIpLFxuICAgICAgICBzMSA9IF9vbGRBdGxhcyRnZXRPZmZzZXRzMlswXSxcbiAgICAgICAgczIgPSBfb2xkQXRsYXMkZ2V0T2Zmc2V0czJbMV07XG4gICAgICBpZiAoczIudyA9PT0gMCkge1xuICAgICAgICAvLyB0aGUgdGV4dHVyZSBkb2VzIG5vdCB3cmFwLCBkcmF3IGRpcmVjdGx5IHRvIG5ldyBhdGxhc1xuICAgICAgICBuZXdBdGxhcy5kcmF3KGtleSwgczEsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uob2xkQXRsYXMuY2FudmFzLCBzMS54LCBzMS55LCBzMS53LCBzMS5oLCAwLCAwLCBzMS53LCBzMS5oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgdGV4dHVyZSB3cmFwcywgZmlyc3QgZHJhdyBib3RoIHBhcnRzIHRvIGEgc2NyYXRjaCBjYW52YXNcbiAgICAgICAgdmFyIHNjcmF0Y2ggPSB0aGlzLl9nZXRTY3JhdGNoQ2FudmFzKCk7XG4gICAgICAgIHNjcmF0Y2guY2xlYXIoKTtcbiAgICAgICAgc2NyYXRjaC5jb250ZXh0LmRyYXdJbWFnZShvbGRBdGxhcy5jYW52YXMsIHMxLngsIHMxLnksIHMxLncsIHMxLmgsIDAsIDAsIHMxLncsIHMxLmgpO1xuICAgICAgICBzY3JhdGNoLmNvbnRleHQuZHJhd0ltYWdlKG9sZEF0bGFzLmNhbnZhcywgczIueCwgczIueSwgczIudywgczIuaCwgczEudywgMCwgczIudywgczIuaCk7XG5cbiAgICAgICAgLy8gbm93IGRyYXcgdGhlIHNjcmF0Y2ggdG8gdGhlIG5ldyBhdGxhc1xuICAgICAgICB2YXIgdyA9IHMxLncgKyBzMi53O1xuICAgICAgICB2YXIgaCA9IHMxLmg7XG4gICAgICAgIG5ld0F0bGFzLmRyYXcoa2V5LCB7XG4gICAgICAgICAgdzogdyxcbiAgICAgICAgICBoOiBoXG4gICAgICAgIH0sIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2Uoc2NyYXRjaCwgMCwgMCwgdywgaCwgMCwgMCwgdywgaCAvLyB0aGUgZGVzdGluYXRpb24gY29udGV4dCBoYXMgYWxyZWFkeSBiZWVuIHRyYW5zbGF0ZWQgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q291bnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvdW50cygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleUNvdW50OiB0aGlzLnN0eWxlS2V5VG9BdGxhcy5zaXplLFxuICAgICAgICBhdGxhc0NvdW50OiBuZXcgU2V0KHRoaXMuc3R5bGVLZXlUb0F0bGFzLnZhbHVlcygpKS5zaXplXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHNldDEsIHNldDIpIHtcbiAgLy8gVE9ETyB3aHkgbm8gU2V0LmludGVyc2VjdGlvbiBpbiBub2RlIDE2Pz8/XG4gIGlmIChzZXQxLmludGVyc2VjdGlvbikgcmV0dXJuIHNldDEuaW50ZXJzZWN0aW9uKHNldDIpO2Vsc2UgcmV0dXJuIG5ldyBTZXQoX3RvQ29uc3VtYWJsZUFycmF5KHNldDEpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBzZXQyLmhhcyh4KTtcbiAgfSkpO1xufVxuXG4vKipcbiAqIFVzZWQgdG8gbWFuYWdlIGJhdGNoZXMgb2YgQXRsYXNlcyBmb3IgZHJhd2luZyBub2RlcyBhbmQgbGFiZWxzLlxuICogU3VwcG9ydHMgZGlmZmVyZW50IHR5cGVzIG9mIEF0bGFzQ29sbGVjdGlvbnMgZm9yIGRpZmZlcmVudCByZW5kZXIgdHlwZXMsXG4gKiBmb3IgZXhhbXBsZSAnbm9kZS1ib2R5JyBhbmQgJ25vZGUtbGFiZWwnIHdvdWxkIGJlIGRpZmZlcmVudCByZW5kZXIgdHlwZXMuXG4gKiBSZW5kZXIgdHlwZXMgYXJlIGtlcHQgc2VwYXJhdGUgYmVjYXVzZSB0aGV5IHdpbGwgbGlrZWx5IG5lZWQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqIHNlcGFyYXRlbHkgYW5kIGl0cyBub3QgZW50aWVybHkgZ3VhcmFudGVlZCB0aGF0IHRoZWlyIHN0eWxlIGtleXMgd29uJ3QgY29sbGlkZS5cbiAqL1xudmFyIEF0bGFzTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0bGFzTWFuYWdlcihyLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0bGFzTWFuYWdlcik7XG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuYXRsYXNTaXplID0gZ2xvYmFsT3B0aW9ucy53ZWJnbFRleFNpemU7XG4gICAgdGhpcy5tYXhBdGxhc2VzUGVyQmF0Y2ggPSBnbG9iYWxPcHRpb25zLndlYmdsVGV4UGVyQmF0Y2g7XG4gICAgdGhpcy5yZW5kZXJUeXBlcyA9IG5ldyBNYXAoKTsgLy8gcmVuZGVyVHlwZTpzdHJpbmcgLT4gcmVuZGVyVHlwZU9wdGlvbnNcbiAgICB0aGlzLmNvbGxlY3Rpb25zID0gbmV3IE1hcCgpOyAvLyBjb2xsZWN0aW9uTmFtZTpzdHJpbmcgLT4gQXRsYXNDb2xsZWN0aW9uXG5cbiAgICB0aGlzLnR5cGVBbmRJZFRvS2V5ID0gbmV3IE1hcCgpOyAvLyBbcmVuZGVyVHlwZSxpZF0gPT4gQXJyYXk8c3R5bGUga2V5PlxuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXRsYXNNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJnZXRBdGxhc1NpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRsYXNTaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRBdGxhc0NvbGxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXRsYXNDb2xsZWN0aW9uKGNvbGxlY3Rpb25OYW1lLCBhdGxhc0NvbGxlY3Rpb25PcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMkZ2xvYmFsT3B0aW9ucyA9IHRoaXMuZ2xvYmFsT3B0aW9ucyxcbiAgICAgICAgd2ViZ2xUZXhTaXplID0gX3RoaXMkZ2xvYmFsT3B0aW9ucy53ZWJnbFRleFNpemUsXG4gICAgICAgIGNyZWF0ZVRleHR1cmVDYW52YXMgPSBfdGhpcyRnbG9iYWxPcHRpb25zLmNyZWF0ZVRleHR1cmVDYW52YXM7XG4gICAgICB2YXIgdGV4Um93cyA9IGF0bGFzQ29sbGVjdGlvbk9wdGlvbnMudGV4Um93cztcbiAgICAgIHZhciBjYWNoZWRDcmVhdGVUZXh0dXJlQ2FudmFzID0gdGhpcy5fY2FjaGVTY3JhdGNoQ2FudmFzKGNyZWF0ZVRleHR1cmVDYW52YXMpO1xuICAgICAgdmFyIGF0bGFzQ29sbGVjdGlvbiA9IG5ldyBBdGxhc0NvbGxlY3Rpb24odGhpcy5yLCB3ZWJnbFRleFNpemUsIHRleFJvd3MsIGNhY2hlZENyZWF0ZVRleHR1cmVDYW52YXMpO1xuICAgICAgdGhpcy5jb2xsZWN0aW9ucy5zZXQoY29sbGVjdGlvbk5hbWUsIGF0bGFzQ29sbGVjdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFJlbmRlclR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUmVuZGVyVHlwZSh0eXBlLCByZW5kZXJUeXBlT3B0aW9ucykge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSByZW5kZXJUeXBlT3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25zLmhhcyhjb2xsZWN0aW9uKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhdGxhcyBjb2xsZWN0aW9uIG5hbWUgJ1wiLmNvbmNhdChjb2xsZWN0aW9uLCBcIidcIikpO1xuICAgICAgdmFyIGF0bGFzQ29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbnMuZ2V0KGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIG9wdHMgPSBleHRlbmQoe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBhdGxhc0NvbGxlY3Rpb246IGF0bGFzQ29sbGVjdGlvblxuICAgICAgfSwgcmVuZGVyVHlwZU9wdGlvbnMpO1xuICAgICAgdGhpcy5yZW5kZXJUeXBlcy5zZXQodHlwZSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlbmRlclR5cGVPcHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlclR5cGVPcHRzKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclR5cGVzLmdldCh0eXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNDb2xsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzQ29sbGVjdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9ucy5nZXQobmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jYWNoZVNjcmF0Y2hDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhY2hlU2NyYXRjaENhbnZhcyhjcmVhdGVUZXh0dXJlQ2FudmFzKSB7XG4gICAgICAvLyBhbGwgc2NyYXRjaCBjYW52YXNlcyBmb3IgdGhlIHNhbWUgcmVuZGVyIHR5cGUgd2lsbCBoYXZlIHRoZSBzYW1lIHdpZHRoIGFuZCBoZWlnaHQgKGllIHdlYmdsVGV4Um93cyBvcHRpb24pXG4gICAgICAvLyBidXQgd2UnbGwga2VlcCB0cmFjayBvZiB0aGUgd2lkdGggYW5kIGhlaWdodCBqdXN0IHRvIGJlIHNhZmVcbiAgICAgIHZhciBwcmV2VyA9IC0xO1xuICAgICAgdmFyIHByZXZIID0gLTE7XG4gICAgICB2YXIgc2NyYXRjaENhbnZhcyA9IG51bGw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHIsIHcsIGgsIHNjcmF0Y2gpIHtcbiAgICAgICAgaWYgKHNjcmF0Y2gpIHtcbiAgICAgICAgICBpZiAoIXNjcmF0Y2hDYW52YXMgfHwgdyAhPSBwcmV2VyB8fCBoICE9IHByZXZIKSB7XG4gICAgICAgICAgICBwcmV2VyA9IHc7XG4gICAgICAgICAgICBwcmV2SCA9IGg7XG4gICAgICAgICAgICBzY3JhdGNoQ2FudmFzID0gY3JlYXRlVGV4dHVyZUNhbnZhcyhyLCB3LCBoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjcmF0Y2hDYW52YXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVDYW52YXMociwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9rZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tleShyZW5kZXJUeXBlLCBpZCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHJlbmRlclR5cGUsIFwiLVwiKS5jb25jYXQoaWQpOyAvLyBUT0RPIG5vdCB2ZXJ5IGVmZmljaWVudFxuICAgIH1cblxuICAgIC8qKiBNYXJrcyB0ZXh0dWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiAqL1xuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZShlbGVzKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIF9yZWYyJGZvcmNlUmVkcmF3ID0gX3JlZjIuZm9yY2VSZWRyYXcsXG4gICAgICAgIGZvcmNlUmVkcmF3ID0gX3JlZjIkZm9yY2VSZWRyYXcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjIkZm9yY2VSZWRyYXcsXG4gICAgICAgIF9yZWYyJGZpbHRlckVsZSA9IF9yZWYyLmZpbHRlckVsZSxcbiAgICAgICAgZmlsdGVyRWxlID0gX3JlZjIkZmlsdGVyRWxlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gOiBfcmVmMiRmaWx0ZXJFbGUsXG4gICAgICAgIF9yZWYyJGZpbHRlclR5cGUgPSBfcmVmMi5maWx0ZXJUeXBlLFxuICAgICAgICBmaWx0ZXJUeXBlID0gX3JlZjIkZmlsdGVyVHlwZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IDogX3JlZjIkZmlsdGVyVHlwZTtcbiAgICAgIHZhciBuZWVkR0MgPSBmYWxzZTtcbiAgICAgIHZhciBydW5HQ05vdyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlbGVzKSxcbiAgICAgICAgX3N0ZXAzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZWxlID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgIGlmIChmaWx0ZXJFbGUoZWxlKSkge1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnJlbmRlclR5cGVzLnZhbHVlcygpKSxcbiAgICAgICAgICAgICAgX3N0ZXA0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyVHlwZSA9IG9wdHMudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyVHlwZShyZW5kZXJUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGF0bGFzQ29sbGVjdGlvbiA9IF90aGlzMy5jb2xsZWN0aW9ucy5nZXQob3B0cy5jb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBvcHRzLmdldEtleShlbGUpO1xuICAgICAgICAgICAgICAgICAgdmFyIGtleUFycmF5ID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV07XG5cbiAgICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBub2RlJ3MgYmFja2dyb3VuZCBpbWFnZSBmaW5pc2hlcyBsb2FkaW5nLCB0aGUgc3R5bGUga2V5IGRvZXNuJ3QgY2hhbmdlIGJ1dCBzdGlsbCBuZWVkcyB0byBiZSByZWRyYXduXG4gICAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5QXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0bGFzQ29sbGVjdGlvbi5tYXJrS2V5Rm9yR0Moa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkdDTm93ID0gdHJ1ZTsgLy8gcnVuIEdDIHRvIHJlbW92ZSB0aGUgb2xkIHRleHR1cmUgcmlnaHQgbm93LCB0aGF0IHdheSB3ZSBkb24ndCBuZWVkIHRvIHJlbWVtYmVyIGZvciB0aGUgbmV4dCBnYyBcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IG9wdHMuZ2V0SUQgPyBvcHRzLmdldElEKGVsZSkgOiBlbGUuaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcEtleSA9IF90aGlzMy5fa2V5KHJlbmRlclR5cGUsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEtleUFycmF5ID0gX3RoaXMzLnR5cGVBbmRJZFRvS2V5LmdldChtYXBLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkS2V5QXJyYXkgIT09IHVuZGVmaW5lZCAmJiAhYXJyYXlFcXVhbChrZXlBcnJheSwgb2xkS2V5QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc2VydmF0aXZlIGFwcHJvYWNoLCBpZiBhbnkgb2YgdGhlIGtleXMgZG9uJ3QgbWF0Y2ggdGhlbiB0aHJvdyB0aGVtIGFsbCBhd2F5XG4gICAgICAgICAgICAgICAgICAgICAgbmVlZEdDID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczMudHlwZUFuZElkVG9LZXlbXCJkZWxldGVcIl0obWFwS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICBvbGRLZXlBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChvbGRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdGxhc0NvbGxlY3Rpb24ubWFya0tleUZvckdDKG9sZEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgX2xvb3AyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgICBpZiAocnVuR0NOb3cpIHtcbiAgICAgICAgdGhpcy5nYygpO1xuICAgICAgICBuZWVkR0MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZWVkR0M7XG4gICAgfVxuXG4gICAgLyoqIEdhcmJhZ2UgY29sbGVjdCAqL1xuICB9LCB7XG4gICAga2V5OiBcImdjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdjKCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbGxlY3Rpb25zLnZhbHVlcygpKSxcbiAgICAgICAgX3N0ZXA1O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICBjb2xsZWN0aW9uLmdjKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPckNyZWF0ZUF0bGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yQ3JlYXRlQXRsYXMoZWxlLCB0eXBlLCBiYiwgc3R5bGVLZXkpIHtcbiAgICAgIC8vIHN0eWxlS2V5IGlzIG5vdCBhbiBhcnJheSBoZXJlXG4gICAgICB2YXIgb3B0cyA9IHRoaXMucmVuZGVyVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgdmFyIGF0bGFzQ29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbnMuZ2V0KG9wdHMuY29sbGVjdGlvbik7XG5cbiAgICAgIC8vIGRyYXdzIHRoZSB0ZXh0dXJlIG9ubHkgaWYgbmVlZGVkXG4gICAgICB2YXIgZHJhd24gPSBmYWxzZTtcbiAgICAgIHZhciBhdGxhcyA9IGF0bGFzQ29sbGVjdGlvbi5kcmF3KHN0eWxlS2V5LCBiYiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG9wdHMuZHJhd0NsaXBwZWQpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCBiYi53LCBiYi5oKTtcbiAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgICBvcHRzLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdHMuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd24gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICBpZiAoZHJhd24pIHtcbiAgICAgICAgdmFyIGlkID0gb3B0cy5nZXRJRCA/IG9wdHMuZ2V0SUQoZWxlKSA6IGVsZS5pZCgpOyAvLyBmb3IgdGVzdGluZ1xuICAgICAgICB2YXIgbWFwS2V5ID0gdGhpcy5fa2V5KHR5cGUsIGlkKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZUFuZElkVG9LZXkuaGFzKG1hcEtleSkpIHtcbiAgICAgICAgICB0aGlzLnR5cGVBbmRJZFRvS2V5LmdldChtYXBLZXkpLnB1c2goc3R5bGVLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHlwZUFuZElkVG9LZXkuc2V0KG1hcEtleSwgW3N0eWxlS2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhdGxhcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzSW5mbyhlbGUsIHR5cGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLnJlbmRlclR5cGVzLmdldCh0eXBlKTtcbiAgICAgIHZhciBrZXkgPSBvcHRzLmdldEtleShlbGUpO1xuICAgICAgdmFyIGtleUFycmF5ID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV07XG4gICAgICByZXR1cm4ga2V5QXJyYXkubWFwKGZ1bmN0aW9uIChzdHlsZUtleSkge1xuICAgICAgICB2YXIgYmIgPSBvcHRzLmdldEJvdW5kaW5nQm94KGVsZSwgc3R5bGVLZXkpOyAvLyBwYXNzIHRoZSBrZXkgYmFjayB0byB0aGUgZ2V0Qm91bmRpbmdCb3ggbWV0aG9kXG4gICAgICAgIHZhciBhdGxhcyA9IF90aGlzNC5nZXRPckNyZWF0ZUF0bGFzKGVsZSwgdHlwZSwgYmIsIHN0eWxlS2V5KTtcbiAgICAgICAgdmFyIF9hdGxhcyRnZXRPZmZzZXRzMyA9IGF0bGFzLmdldE9mZnNldHMoc3R5bGVLZXkpLFxuICAgICAgICAgIF9hdGxhcyRnZXRPZmZzZXRzNCA9IF9zbGljZWRUb0FycmF5KF9hdGxhcyRnZXRPZmZzZXRzMywgMiksXG4gICAgICAgICAgdGV4MSA9IF9hdGxhcyRnZXRPZmZzZXRzNFswXSxcbiAgICAgICAgICB0ZXgyID0gX2F0bGFzJGdldE9mZnNldHM0WzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF0bGFzOiBhdGxhcyxcbiAgICAgICAgICB0ZXg6IHRleDEsXG4gICAgICAgICAgdGV4MTogdGV4MSxcbiAgICAgICAgICB0ZXgyOiB0ZXgyLFxuICAgICAgICAgIGJiOiBiYlxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlYnVnSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWJ1Z0luZm8oKSB7XG4gICAgICB2YXIgZGVidWdJbmZvID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29sbGVjdGlvbnMpLFxuICAgICAgICBfc3RlcDY7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDYkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDYudmFsdWUsIDIpLFxuICAgICAgICAgICAgbmFtZSA9IF9zdGVwNiR2YWx1ZVswXSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBfc3RlcDYkdmFsdWVbMV07XG4gICAgICAgICAgdmFyIF9jb2xsZWN0aW9uJGdldENvdW50cyA9IGNvbGxlY3Rpb24uZ2V0Q291bnRzKCksXG4gICAgICAgICAgICBrZXlDb3VudCA9IF9jb2xsZWN0aW9uJGdldENvdW50cy5rZXlDb3VudCxcbiAgICAgICAgICAgIGF0bGFzQ291bnQgPSBfY29sbGVjdGlvbiRnZXRDb3VudHMuYXRsYXNDb3VudDtcbiAgICAgICAgICBkZWJ1Z0luZm8ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBuYW1lLFxuICAgICAgICAgICAga2V5Q291bnQ6IGtleUNvdW50LFxuICAgICAgICAgICAgYXRsYXNDb3VudDogYXRsYXNDb3VudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJ1Z0luZm87XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgQXRsYXNCYXRjaE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdGxhc0JhdGNoTWFuYWdlcihnbG9iYWxPcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0bGFzQmF0Y2hNYW5hZ2VyKTtcbiAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBnbG9iYWxPcHRpb25zO1xuICAgIHRoaXMuYXRsYXNTaXplID0gZ2xvYmFsT3B0aW9ucy53ZWJnbFRleFNpemU7XG4gICAgdGhpcy5tYXhBdGxhc2VzUGVyQmF0Y2ggPSBnbG9iYWxPcHRpb25zLndlYmdsVGV4UGVyQmF0Y2g7XG4gICAgdGhpcy5iYXRjaEF0bGFzZXMgPSBbXTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF0bGFzQmF0Y2hNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJnZXRNYXhBdGxhc2VzUGVyQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4QXRsYXNlc1BlckJhdGNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF4QXRsYXNlc1BlckJhdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc1NpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRsYXNTaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbmRleEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZGV4QXJyYXkoKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogdGhpcy5tYXhBdGxhc2VzUGVyQmF0Y2hcbiAgICAgIH0sIGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgICAgIHRoaXMuYmF0Y2hBdGxhc2VzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhdGNoQXRsYXNlcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhdGNoQXRsYXNlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuQWRkVG9DdXJyZW50QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQWRkVG9DdXJyZW50QmF0Y2goYXRsYXMpIHtcbiAgICAgIGlmICh0aGlzLmJhdGNoQXRsYXNlcy5sZW5ndGggPT09IHRoaXMubWF4QXRsYXNlc1BlckJhdGNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhdGNoQXRsYXNlcy5pbmNsdWRlcyhhdGxhcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gbm90IGZ1bGxcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNJbmRleEZvckJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0bGFzSW5kZXhGb3JCYXRjaChhdGxhcykge1xuICAgICAgdmFyIGF0bGFzSUQgPSB0aGlzLmJhdGNoQXRsYXNlcy5pbmRleE9mKGF0bGFzKTtcbiAgICAgIGlmIChhdGxhc0lEIDwgMCkge1xuICAgICAgICBpZiAodGhpcy5iYXRjaEF0bGFzZXMubGVuZ3RoID09PSB0aGlzLm1heEF0bGFzZXNQZXJCYXRjaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGFkZCBtb3JlIGF0bGFzZXMgdG8gYmF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhdGNoQXRsYXNlcy5wdXNoKGF0bGFzKTtcbiAgICAgICAgYXRsYXNJRCA9IHRoaXMuYmF0Y2hBdGxhc2VzLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXRsYXNJRDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLy8gRnJhZ21lbnQgc2hhZGVyIGZ1bmN0aW9ucyB0byBjYWxjdWxhdGUgc2lnbmVkIGRpc3RhbmNlXG4vLyBodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL2Rpc3RmdW5jdGlvbnMyZC9cbi8vIGVsbGlwc2U6IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80bHNYRE4gXG5cbi8qKlxuICogcGFyYW0gcCAtIHBvaW50XG4gKiBmbG9hdCByIC0gY2lyY2xlIHJhZGl1cywgZWcgMC41IGZvciB1bml0IGNpcmNsZVxuICovXG52YXIgY2lyY2xlU0QgPSBcIlxcbiAgZmxvYXQgY2lyY2xlU0QodmVjMiBwLCBmbG9hdCByKSB7XFxuICAgIHJldHVybiBkaXN0YW5jZSh2ZWMyKDApLCBwKSAtIHI7IC8vIHNpZ25lZCBkaXN0YW5jZVxcbiAgfVxcblwiO1xuXG4vKipcbiAqIHBhcmFtIHAgLSBwb2ludFxuICogcGFyYW0gYiAtIGIueCA9IGhhbGYgd2lkdGgsIGIueSA9IGhhbGYgaGVpZ2h0XG4gKi9cbnZhciByZWN0YW5nbGVTRCA9IFwiXFxuICBmbG9hdCByZWN0YW5nbGVTRCh2ZWMyIHAsIHZlYzIgYikge1xcbiAgICB2ZWMyIGQgPSBhYnMocCktYjtcXG4gICAgcmV0dXJuIGRpc3RhbmNlKHZlYzIoMCksbWF4KGQsMC4wKSkgKyBtaW4obWF4KGQueCxkLnkpLDAuMCk7XFxuICB9XFxuXCI7XG5cbi8qKlxuICogcGFyYW0gcCAtIHBvaW50XG4gKiBwYXJhbSBiIC0gYi54ID0gaGFsZiB3aWR0aCwgYi55ID0gaGFsZiBoZWlnaHRcbiAqIHBhcmFtIGNyIC0gdmVjdG9yIG9mIGNvcm5lciByYWRpdXNlc1xuICovXG52YXIgcm91bmRSZWN0YW5nbGVTRCA9IFwiXFxuICBmbG9hdCByb3VuZFJlY3RhbmdsZVNEKHZlYzIgcCwgdmVjMiBiLCB2ZWM0IGNyKSB7XFxuICAgIGNyLnh5ID0gKHAueCA+IDAuMCkgPyBjci54eSA6IGNyLnp3O1xcbiAgICBjci54ICA9IChwLnkgPiAwLjApID8gY3IueCAgOiBjci55O1xcbiAgICB2ZWMyIHEgPSBhYnMocCkgLSBiICsgY3IueDtcXG4gICAgcmV0dXJuIG1pbihtYXgocS54LCBxLnkpLCAwLjApICsgZGlzdGFuY2UodmVjMigwKSwgbWF4KHEsIDAuMCkpIC0gY3IueDtcXG4gIH1cXG5cIjtcblxuLyoqXG4gKiBwYXJhbSBwIC0gcG9pbnRcbiAqIHBhcmFtIGFiIC0gYS54ID0gaG9yaXpvbnRhbCByYWRpdXMsIGEueSA9IHZlcnRpY2FsIHJhZGl1c1xuICovXG52YXIgZWxsaXBzZVNEID0gXCJcXG4gIGZsb2F0IGVsbGlwc2VTRCh2ZWMyIHAsIHZlYzIgYWIpIHtcXG4gICAgcCA9IGFicyggcCApOyAvLyBzeW1tZXRyeVxcblxcbiAgICAvLyBmaW5kIHJvb3Qgd2l0aCBOZXd0b24gc29sdmVyXFxuICAgIHZlYzIgcSA9IGFiKihwLWFiKTtcXG4gICAgZmxvYXQgdyA9IChxLng8cS55KT8gMS41NzA3OTYzMjcgOiAwLjA7XFxuICAgIGZvciggaW50IGk9MDsgaTw1OyBpKysgKSB7XFxuICAgICAgdmVjMiBjcyA9IHZlYzIoY29zKHcpLHNpbih3KSk7XFxuICAgICAgdmVjMiB1ID0gYWIqdmVjMiggY3MueCxjcy55KTtcXG4gICAgICB2ZWMyIHYgPSBhYip2ZWMyKC1jcy55LGNzLngpO1xcbiAgICAgIHcgPSB3ICsgZG90KHAtdSx2KS8oZG90KHAtdSx1KStkb3Qodix2KSk7XFxuICAgIH1cXG4gICAgXFxuICAgIC8vIGNvbXB1dGUgZmluYWwgcG9pbnQgYW5kIGRpc3RhbmNlXFxuICAgIGZsb2F0IGQgPSBsZW5ndGgocC1hYip2ZWMyKGNvcyh3KSxzaW4odykpKTtcXG4gICAgXFxuICAgIC8vIHJldHVybiBzaWduZWQgZGlzdGFuY2VcXG4gICAgcmV0dXJuIChkb3QocC9hYixwL2FiKT4xLjApID8gZCA6IC1kO1xcbiAgfVxcblwiO1xuXG4vKipcbiAqIFR3byByZW5kZXIgbW9kZXMuIEVhY2ggbW9kZSBoYXMgaXRzIG93biBzaGFkZXIgcHJvZ3JhbS4gVGhleSBhcmUgYWxtb3N0IGlkZW50aWNhbCwgdGhlIG1haW4gZGlmZmVyZW5jZSBpcyB0aGUgb3V0cHV0LlxuICogU0NSRUVOOiAgb3V0cHV0IHBpeGVsIGNvbG9ycyB0byB0aGUgc2NyZWVuXG4gKiBQSUNLSU5HOiBvdXRwdXQgei1vcmRlciBpbmRleCB0byBhbiBvZmZzY3JlZW4gZnJhbWVidWZmZXIsIHVzZWQgdG8gZGV0ZWN0IHdoYXQncyB1bmRlciB0aGUgbW91c2UgY3Vyc29yXG4gKi9cbnZhciBSRU5ERVJfVEFSR0VUID0ge1xuICBTQ1JFRU46IHtcbiAgICBuYW1lOiAnc2NyZWVuJyxcbiAgICBzY3JlZW46IHRydWVcbiAgfSxcbiAgUElDS0lORzoge1xuICAgIG5hbWU6ICdwaWNraW5nJyxcbiAgICBwaWNraW5nOiB0cnVlXG4gIH1cbn07XG5cbi8qKlxuICogU3BlY2lhbCBoYW5kaW5nIGZvciBsYWJlbCB0ZXh0dXJlcyBpbiBQSUNLSU5HIG1vZGUuIFNlZSBpc3N1ZSAjMzMzNy5cbiAqL1xudmFyIFRFWF9QSUNLSU5HX01PREUgPSB7XG4gIC8vIHJlbmRlciB0aGUgdGV4dHVyZSBqdXN0IGxpa2UgaW4gUkVOREVSX1RBUkdFVC5TQ1JFRU4gbW9kZVxuICBJR05PUkU6IDEsXG4gIC8vIGRvbid0IHJlbmRlciB0aGUgdGV4dHVyZSBhdCBhbGxcbiAgVVNFX0JCOiAyIC8vIHJlbmRlciB0aGUgYm91bmRpbmcgYm94IGFzIGFuIG9wYXF1ZSByZWN0YW5nbGVcbn07XG5cbi8vIFZlcnRleCB0eXBlcy5cbi8vIFVzZWQgZGlyZWN0bHkgaW4gdGhlIHNoYWRlcnMgc28gbXVzdCBiZSBudW1lcmljLlxuLy8gVGhlcmUgaXMgb25seSBvbmUgc2hhZGVyIHByb2dyYW0gdXNlZCBmb3IgYW4gZW50aXJlIGZyYW1lIHRoYXQgcmVuZGVycyBhbGwgdHlwZXMgb2YgZWxlbWVudHMuXG4vLyBUaGVyZSBhcmUgaWYtZWxzZSBibG9ja3MgaW4gdGhlIHNoYWRlcnMgdGhhdCBkbyBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgdmVydGV4IHR5cGUuXG4vLyBUaGlzIGFsbG93cyBhbGwgZWxlbWVudHMgdG8gYmUgcmVuZGVyZXJkIGluIGxhcmdlIGJhdGNoZXMgd2l0aG91dCBzd2l0Y2hpbmcgc2hhZGVyIHByb2dyYW1zLlxudmFyIFRFWFRVUkUgPSAwO1xudmFyIEVER0VfU1RSQUlHSFQgPSAxO1xudmFyIEVER0VfQ1VSVkVfU0VHTUVOVCA9IDI7XG52YXIgRURHRV9BUlJPVyA9IDM7XG52YXIgUkVDVEFOR0xFID0gNDtcbnZhciBST1VORF9SRUNUQU5HTEUgPSA1O1xudmFyIEJPVFRPTV9ST1VORF9SRUNUQU5HTEUgPSA2O1xudmFyIEVMTElQU0UgPSA3O1xudmFyIEVsZW1lbnREcmF3aW5nV2ViR0wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqL1xuICBmdW5jdGlvbiBFbGVtZW50RHJhd2luZ1dlYkdMKHIsIGdsLCBvcHRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsZW1lbnREcmF3aW5nV2ViR0wpO1xuICAgIHRoaXMuciA9IHI7IC8vIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIHJlbmRlcmVyXG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMubWF4SW5zdGFuY2VzID0gb3B0cy53ZWJnbEJhdGNoU2l6ZTtcbiAgICB0aGlzLmF0bGFzU2l6ZSA9IG9wdHMud2ViZ2xUZXhTaXplO1xuICAgIHRoaXMuYmdDb2xvciA9IG9wdHMuYmdDb2xvcjtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy53ZWJnbERlYnVnO1xuICAgIHRoaXMuYmF0Y2hEZWJ1Z0luZm8gPSBbXTtcbiAgICBvcHRzLmVuYWJsZVdyYXBwaW5nID0gdHJ1ZTtcbiAgICBvcHRzLmNyZWF0ZVRleHR1cmVDYW52YXMgPSBjcmVhdGVUZXh0dXJlQ2FudmFzOyAvLyBVbml0IHRlc3RzIG1vY2sgdGhpc1xuXG4gICAgdGhpcy5hdGxhc01hbmFnZXIgPSBuZXcgQXRsYXNNYW5hZ2VyKHIsIG9wdHMpO1xuICAgIHRoaXMuYmF0Y2hNYW5hZ2VyID0gbmV3IEF0bGFzQmF0Y2hNYW5hZ2VyKG9wdHMpO1xuICAgIHRoaXMuc2ltcGxlU2hhcGVPcHRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJvZ3JhbSA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oUkVOREVSX1RBUkdFVC5TQ1JFRU4pO1xuICAgIHRoaXMucGlja2luZ1Byb2dyYW0gPSB0aGlzLl9jcmVhdGVTaGFkZXJQcm9ncmFtKFJFTkRFUl9UQVJHRVQuUElDS0lORyk7XG4gICAgdGhpcy52YW8gPSB0aGlzLl9jcmVhdGVWQU8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyBzdHJpbmcgfSBjb2xsZWN0aW9uTmFtZVxuICAgKiBAcGFyYW0ge3sgdGV4Um93czogbnVtYmVyIH19IG9wdHNcbiAgICovXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWxlbWVudERyYXdpbmdXZWJHTCwgW3tcbiAgICBrZXk6IFwiYWRkQXRsYXNDb2xsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEF0bGFzQ29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSwgb3B0cykge1xuICAgICAgdGhpcy5hdGxhc01hbmFnZXIuYWRkQXRsYXNDb2xsZWN0aW9uKGNvbGxlY3Rpb25OYW1lLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7IE9iamVjdCB9IFRleHR1cmVSZW5kZXJUeXBlT3B0c1xuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGNvbGxlY3Rpb24gLSBuYW1lIG9mIGF0bGFzIGNvbGxlY3Rpb24gdG8gcmVuZGVyIHRleHR1cmVzIHRvXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRLZXkgLSByZXR1cm5zIHRoZSBcInN0eWxlIGtleVwiIGZvciBhbiBlbGVtZW50LCBtYXkgYmUgYSBzaW5nbGUgdmFsdWUgb3IgYW4gYXJyYXkgZm9yIG11bHRpLWxpbmUgbGFibGVzXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBkcmF3RWxlbWVudCAtIHVzZXMgYSBjYW52YXMgcmVuZGVyZXIgdG8gZHJhdyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dHVyZSBhdGxhc1xuICAgICAqIEBwcm9wZXJ0eSB7IGJvb2xlYW4gIH0gZHJhd0NsaXBwZWQgLSBpZiB0cnVlIHRoZSBjb250ZXh0IHdpbGwgYmUgY2xpcHBlZCB0byB0aGUgYm91bmRpbmcgYm94IGJlZm9yZSBkcmF3RWxlbWVudCgpIGlzIGNhbGxlZCwgbWF5IGFmZmVjdCBwZXJmb3JtYW5jZVxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0Qm91bmRpbmdCb3ggLSByZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIGFuIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldFJvdGF0aW9uXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRSb3RhdGlvblBvaW50XG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRSb3RhdGlvbk9mZnNldFxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gaXNWaXNpYmxlIC0gYW4gZXh0cmEgY2hlY2sgZm9yIHZpc2liaWxpdHkgaW4gYWRkaXRpb24gdG8gZWxlLnZpc2libGUoKVxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0VGV4UGlja2luZ01vZGUgLSByZXR1cm5zIGEgdmFsdWUgZnJvbSB0aGUgVEVYX1BJQ0tJTkdfTU9ERSBlbnVtXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdHlwZU5hbWVcbiAgICAgKiBAcGFyYW0geyBUZXh0dXJlUmVuZGVyVHlwZU9wdHMgfSBvcHRzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGV4dHVyZUF0bGFzUmVuZGVyVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlKHR5cGVOYW1lLCBvcHRzKSB7XG4gICAgICB0aGlzLmF0bGFzTWFuYWdlci5hZGRSZW5kZXJUeXBlKHR5cGVOYW1lLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7IE9iamVjdCB9IFNpbXBsZVNoYXBlUmVuZGVyVHlwZU9wdHNcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldEJvdW5kaW5nQm94IC0gcmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciBhbiBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBpc1Zpc2libGUgLSB0aGlzIGlzIGFuIGV4dHJhIGNoZWNrIGZvciB2aXNpYmlsaXR5IGluIGFkZGl0aW9uIHRvIGVsZS52aXNpYmxlKClcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGlzU2ltcGxlIC0gY2hlY2sgaWYgZWxlbWVudCBpcyBhIHNpbXBsZSBzaGFwZSwgb3IgaWYgaXQgbmVlZHMgdG8gZmFsbCBiYWNrIHRvIHRleHR1cmUgcmVuZGVyaW5nXG4gICAgICogQHByb3BlcnR5IHsgU2hhcGVWaXN1YWxQcm9wZXJ0aWVzIH0gc2hhcGVQcm9wc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHsgT2JqZWN0IH0gU2hhcGVWaXN1YWxQcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gc2hhcGVcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBjb2xvclxuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IG9wYWNpdHlcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBwYWRkaW5nXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gcmFkaXVzXG4gICAgICogQHByb3BlcnR5IHsgYm9vbGVhbiB9IGJvcmRlclxuICAgICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsgc3RyaW5nIH0gdHlwZU5hbWVcbiAgICAgKiBAcGFyYW0geyBTaW1wbGVTaGFwZVJlbmRlclR5cGVPcHRzIH0gb3B0c1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFNpbXBsZVNoYXBlUmVuZGVyVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTaW1wbGVTaGFwZVJlbmRlclR5cGUodHlwZU5hbWUsIG9wdHMpIHtcbiAgICAgIHRoaXMuc2ltcGxlU2hhcGVPcHRpb25zLnNldCh0eXBlTmFtZSwgb3B0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5mb3JtIHRoZSBhdGxhc01hbmFnZXIgd2hlbiBlbGVtZW50IHN0eWxlIGtleXMgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgKiBUaGUgYXRsYXNNYW5hZ2VyIGNhbiB0aGVuIG1hcmsgdW51c2VkIHRleHR1cmVzIGZvciBcImdhcmJhZ2UgY29sbGVjdGlvblwiLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImludmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZShlbGVzKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIHR5cGUgPSBfcmVmLnR5cGU7XG4gICAgICB2YXIgYXRsYXNNYW5hZ2VyID0gdGhpcy5hdGxhc01hbmFnZXI7XG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gYXRsYXNNYW5hZ2VyLmludmFsaWRhdGUoZWxlcywge1xuICAgICAgICAgIGZpbHRlclR5cGU6IGZ1bmN0aW9uIGZpbHRlclR5cGUodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgPT09IHR5cGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JjZVJlZHJhdzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhdGxhc01hbmFnZXIuaW52YWxpZGF0ZShlbGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gdGV4dHVyZSBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2MoKSB7XG4gICAgICB0aGlzLmF0bGFzTWFuYWdlci5nYygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlU2hhZGVyUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU2hhZGVyUHJvZ3JhbShyZW5kZXJUYXJnZXQpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyU291cmNlID0gXCIjdmVyc2lvbiAzMDAgZXNcXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuICAgICAgdW5pZm9ybSBtYXQzIHVQYW5ab29tTWF0cml4O1xcbiAgICAgIHVuaWZvcm0gaW50ICB1QXRsYXNTaXplO1xcbiAgICAgIFxcbiAgICAgIC8vIGluc3RhbmNlZFxcbiAgICAgIGluIHZlYzIgYVBvc2l0aW9uOyAvLyBhIHZlcnRleCBmcm9tIHRoZSB1bml0IHNxdWFyZVxcbiAgICAgIFxcbiAgICAgIGluIG1hdDMgYVRyYW5zZm9ybTsgLy8gdXNlZCB0byB0cmFuc2Zvcm0gdmVydGljaWVzLCBlZyBpbnRvIGEgYm91bmRpbmcgYm94XFxuICAgICAgaW4gaW50IGFWZXJ0VHlwZTsgLy8gdGhlIHR5cGUgb2YgdGhpbmcgd2UgYXJlIHJlbmRlcmluZ1xcblxcbiAgICAgIC8vIHRoZSB6LWluZGV4IHRoYXQgaXMgb3V0cHV0IHdoZW4gdXNpbmcgcGlja2luZyBtb2RlXFxuICAgICAgaW4gdmVjNCBhSW5kZXg7XFxuICAgICAgXFxuICAgICAgLy8gRm9yIHRleHR1cmVzXFxuICAgICAgaW4gaW50IGFBdGxhc0lkOyAvLyB3aGljaCBzaGFkZXIgdW5pdC9hdGxhcyB0byB1c2VcXG4gICAgICBpbiB2ZWM0IGFUZXg7IC8vIHgveS93L2ggb2YgdGV4dHVyZSBpbiBhdGxhc1xcblxcbiAgICAgIC8vIGZvciBlZGdlc1xcbiAgICAgIGluIHZlYzQgYVBvaW50QVBvaW50QjtcXG4gICAgICBpbiB2ZWM0IGFQb2ludENQb2ludEQ7XFxuICAgICAgaW4gdmVjMiBhTGluZVdpZHRoOyAvLyBhbHNvIHVzZWQgZm9yIG5vZGUgYm9yZGVyIHdpZHRoXFxuXFxuICAgICAgLy8gc2ltcGxlIHNoYXBlc1xcbiAgICAgIGluIHZlYzQgYUNvcm5lclJhZGl1czsgLy8gZm9yIHJvdW5kLXJlY3RhbmdsZSBbdG9wLXJpZ2h0LCBib3R0b20tcmlnaHQsIHRvcC1sZWZ0LCBib3R0b20tbGVmdF1cXG4gICAgICBpbiB2ZWM0IGFDb2xvcjsgLy8gYWxzbyB1c2VkIGZvciBlZGdlc1xcbiAgICAgIGluIHZlYzQgYUJvcmRlckNvbG9yOyAvLyBhTGluZVdpZHRoIGlzIHVzZWQgZm9yIGJvcmRlciB3aWR0aFxcblxcbiAgICAgIC8vIG91dHB1dCB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXG4gICAgICBvdXQgdmVjMiB2VGV4Q29vcmQ7XFxuICAgICAgb3V0IHZlYzQgdkNvbG9yO1xcbiAgICAgIG91dCB2ZWMyIHZQb3NpdGlvbjtcXG4gICAgICAvLyBmbGF0IHZhbHVlcyBhcmUgbm90IGludGVycG9sYXRlZFxcbiAgICAgIGZsYXQgb3V0IGludCB2QXRsYXNJZDsgXFxuICAgICAgZmxhdCBvdXQgaW50IHZWZXJ0VHlwZTtcXG4gICAgICBmbGF0IG91dCB2ZWMyIHZUb3BSaWdodDtcXG4gICAgICBmbGF0IG91dCB2ZWMyIHZCb3RMZWZ0O1xcbiAgICAgIGZsYXQgb3V0IHZlYzQgdkNvcm5lclJhZGl1cztcXG4gICAgICBmbGF0IG91dCB2ZWM0IHZCb3JkZXJDb2xvcjtcXG4gICAgICBmbGF0IG91dCB2ZWMyIHZCb3JkZXJXaWR0aDtcXG4gICAgICBmbGF0IG91dCB2ZWM0IHZJbmRleDtcXG4gICAgICBcXG4gICAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaW50IHZpZCA9IGdsX1ZlcnRleElEO1xcbiAgICAgICAgdmVjMiBwb3NpdGlvbiA9IGFQb3NpdGlvbjsgLy8gVE9ETyBtYWtlIHRoaXMgYSB2ZWMzLCBzaW1wbGlmaWVzIHNvbWUgY29kZSBiZWxvd1xcblxcbiAgICAgICAgaWYoYVZlcnRUeXBlID09IFwiLmNvbmNhdChURVhUVVJFLCBcIikge1xcbiAgICAgICAgICBmbG9hdCB0ZXhYID0gYVRleC54OyAvLyB0ZXh0dXJlIGNvb3JkaW5hdGVzXFxuICAgICAgICAgIGZsb2F0IHRleFkgPSBhVGV4Lnk7XFxuICAgICAgICAgIGZsb2F0IHRleFcgPSBhVGV4Lno7XFxuICAgICAgICAgIGZsb2F0IHRleEggPSBhVGV4Lnc7XFxuXFxuICAgICAgICAgIGlmKHZpZCA9PSAxIHx8IHZpZCA9PSAyIHx8IHZpZCA9PSA0KSB7XFxuICAgICAgICAgICAgdGV4WCArPSB0ZXhXO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmKHZpZCA9PSAyIHx8IHZpZCA9PSA0IHx8IHZpZCA9PSA1KSB7XFxuICAgICAgICAgICAgdGV4WSArPSB0ZXhIO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZsb2F0IGQgPSBmbG9hdCh1QXRsYXNTaXplKTtcXG4gICAgICAgICAgdlRleENvb3JkID0gdmVjMih0ZXhYIC8gZCwgdGV4WSAvIGQpOyAvLyB0ZXggY29vcmRzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXFxuXFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1UGFuWm9vbU1hdHJpeCAqIGFUcmFuc2Zvcm0gKiB2ZWMzKHBvc2l0aW9uLCAxLjApLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZihhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChSRUNUQU5HTEUsIFwiIHx8IGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVMTElQU0UsIFwiIFxcbiAgICAgICAgICAgICB8fCBhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChST1VORF9SRUNUQU5HTEUsIFwiIHx8IGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEJPVFRPTV9ST1VORF9SRUNUQU5HTEUsIFwiKSB7IC8vIHNpbXBsZSBzaGFwZXNcXG5cXG4gICAgICAgICAgLy8gdGhlIGJvdW5kaW5nIGJveCBpcyBuZWVkZWQgYnkgdGhlIGZyYWdtZW50IHNoYWRlclxcbiAgICAgICAgICB2Qm90TGVmdCAgPSAoYVRyYW5zZm9ybSAqIHZlYzMoMCwgMCwgMSkpLnh5OyAvLyBmbGF0XFxuICAgICAgICAgIHZUb3BSaWdodCA9IChhVHJhbnNmb3JtICogdmVjMygxLCAxLCAxKSkueHk7IC8vIGZsYXRcXG4gICAgICAgICAgdlBvc2l0aW9uID0gKGFUcmFuc2Zvcm0gKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHk7IC8vIHdpbGwgYmUgaW50ZXJwb2xhdGVkXFxuXFxuICAgICAgICAgIC8vIGNhbGN1bGF0aW9ucyBhcmUgZG9uZSBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBqdXN0IHBhc3MgdGhlc2UgYWxvbmdcXG4gICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xcbiAgICAgICAgICB2Q29ybmVyUmFkaXVzID0gYUNvcm5lclJhZGl1cztcXG4gICAgICAgICAgdkJvcmRlckNvbG9yID0gYUJvcmRlckNvbG9yO1xcbiAgICAgICAgICB2Qm9yZGVyV2lkdGggPSBhTGluZVdpZHRoO1xcblxcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodVBhblpvb21NYXRyaXggKiBhVHJhbnNmb3JtICogdmVjMyhwb3NpdGlvbiwgMS4wKSwgMS4wKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYoYVZlcnRUeXBlID09IFwiKS5jb25jYXQoRURHRV9TVFJBSUdIVCwgXCIpIHtcXG4gICAgICAgICAgdmVjMiBzb3VyY2UgPSBhUG9pbnRBUG9pbnRCLnh5O1xcbiAgICAgICAgICB2ZWMyIHRhcmdldCA9IGFQb2ludEFQb2ludEIuenc7XFxuXFxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZ2VvbWV0cnkgc28gdGhhdCB0aGUgbGluZSBpcyBjZW50ZXJlZCBvbiB0aGUgZWRnZVxcbiAgICAgICAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSAtIDAuNTtcXG5cXG4gICAgICAgICAgLy8gc3RyZXRjaCB0aGUgdW5pdCBzcXVhcmUgaW50byBhIGxvbmcgc2tpbm55IHJlY3RhbmdsZVxcbiAgICAgICAgICB2ZWMyIHhCYXNpcyA9IHRhcmdldCAtIHNvdXJjZTtcXG4gICAgICAgICAgdmVjMiB5QmFzaXMgPSBub3JtYWxpemUodmVjMigteEJhc2lzLnksIHhCYXNpcy54KSk7XFxuICAgICAgICAgIHZlYzIgcG9pbnQgPSBzb3VyY2UgKyB4QmFzaXMgKiBwb3NpdGlvbi54ICsgeUJhc2lzICogYUxpbmVXaWR0aFswXSAqIHBvc2l0aW9uLnk7XFxuXFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1UGFuWm9vbU1hdHJpeCAqIHZlYzMocG9pbnQsIDEuMCksIDEuMCk7XFxuICAgICAgICAgIHZDb2xvciA9IGFDb2xvcjtcXG4gICAgICAgIH0gXFxuICAgICAgICBlbHNlIGlmKGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVER0VfQ1VSVkVfU0VHTUVOVCwgXCIpIHtcXG4gICAgICAgICAgdmVjMiBwb2ludEEgPSBhUG9pbnRBUG9pbnRCLnh5O1xcbiAgICAgICAgICB2ZWMyIHBvaW50QiA9IGFQb2ludEFQb2ludEIuenc7XFxuICAgICAgICAgIHZlYzIgcG9pbnRDID0gYVBvaW50Q1BvaW50RC54eTtcXG4gICAgICAgICAgdmVjMiBwb2ludEQgPSBhUG9pbnRDUG9pbnRELnp3O1xcblxcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGdlb21ldHJ5IHNvIHRoYXQgdGhlIGxpbmUgaXMgY2VudGVyZWQgb24gdGhlIGVkZ2VcXG4gICAgICAgICAgcG9zaXRpb24ueSA9IHBvc2l0aW9uLnkgLSAwLjU7XFxuXFxuICAgICAgICAgIHZlYzIgcDAsIHAxLCBwMiwgcG9zO1xcbiAgICAgICAgICBpZihwb3NpdGlvbi54ID09IDAuMCkgeyAvLyBUaGUgbGVmdCBzaWRlIG9mIHRoZSB1bml0IHNxdWFyZVxcbiAgICAgICAgICAgIHAwID0gcG9pbnRBO1xcbiAgICAgICAgICAgIHAxID0gcG9pbnRCO1xcbiAgICAgICAgICAgIHAyID0gcG9pbnRDO1xcbiAgICAgICAgICAgIHBvcyA9IHBvc2l0aW9uO1xcbiAgICAgICAgICB9IGVsc2UgeyAvLyBUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdW5pdCBzcXVhcmUsIHVzZSBzYW1lIGFwcHJvYWNoIGJ1dCBmbGlwIHRoZSBnZW9tZXRyeSB1cHNpZGUgZG93blxcbiAgICAgICAgICAgIHAwID0gcG9pbnREO1xcbiAgICAgICAgICAgIHAxID0gcG9pbnRDO1xcbiAgICAgICAgICAgIHAyID0gcG9pbnRCO1xcbiAgICAgICAgICAgIHBvcyA9IHZlYzIoMC4wLCAtcG9zaXRpb24ueSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmVjMiBwMDEgPSBwMSAtIHAwO1xcbiAgICAgICAgICB2ZWMyIHAxMiA9IHAyIC0gcDE7XFxuICAgICAgICAgIHZlYzIgcDIxID0gcDEgLSBwMjtcXG5cXG4gICAgICAgICAgLy8gRmluZCB0aGUgbm9ybWFsIHZlY3Rvci5cXG4gICAgICAgICAgdmVjMiB0YW5nZW50ID0gbm9ybWFsaXplKG5vcm1hbGl6ZShwMTIpICsgbm9ybWFsaXplKHAwMSkpO1xcbiAgICAgICAgICB2ZWMyIG5vcm1hbCA9IHZlYzIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcXG5cXG4gICAgICAgICAgLy8gRmluZCB0aGUgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gcDAgLT4gcDEuXFxuICAgICAgICAgIHZlYzIgcDAxTm9ybSA9IG5vcm1hbGl6ZSh2ZWMyKC1wMDEueSwgcDAxLngpKTtcXG5cXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBiZW5kIGRpcmVjdGlvbi5cXG4gICAgICAgICAgZmxvYXQgc2lnbWEgPSBzaWduKGRvdChwMDEgKyBwMjEsIG5vcm1hbCkpO1xcbiAgICAgICAgICBmbG9hdCB3aWR0aCA9IGFMaW5lV2lkdGhbMF07XFxuXFxuICAgICAgICAgIGlmKHNpZ24ocG9zLnkpID09IC1zaWdtYSkge1xcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJzZWN0aW5nIHZlcnRleC4gQWRqdXN0IHRoZSBwb3NpdGlvbiBzbyB0aGF0IHRoZXJlJ3Mgbm8gb3ZlcmxhcC5cXG4gICAgICAgICAgICB2ZWMyIHBvaW50ID0gMC41ICogd2lkdGggKiBub3JtYWwgKiAtc2lnbWEgLyBkb3Qobm9ybWFsLCBwMDFOb3JtKTtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodVBhblpvb21NYXRyaXggKiB2ZWMzKHAxICsgcG9pbnQsIDEuMCksIDEuMCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vbi1pbnRlcnNlY3RpbmcgdmVydGV4LiBUcmVhdCBpdCBsaWtlIGEgbWl0cmUgam9pbi5cXG4gICAgICAgICAgICB2ZWMyIHBvaW50ID0gMC41ICogd2lkdGggKiBub3JtYWwgKiBzaWdtYSAqIGRvdChub3JtYWwsIHAwMU5vcm0pO1xcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1UGFuWm9vbU1hdHJpeCAqIHZlYzMocDEgKyBwb2ludCwgMS4wKSwgMS4wKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgICAgICB9IFxcbiAgICAgICAgZWxzZSBpZihhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChFREdFX0FSUk9XLCBcIiAmJiB2aWQgPCAzKSB7XFxuICAgICAgICAgIC8vIG1hc3NhZ2UgdGhlIGZpcnN0IHRyaWFuZ2xlIGludG8gYW4gZWRnZSBhcnJvd1xcbiAgICAgICAgICBpZih2aWQgPT0gMClcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIoLTAuMTUsIC0wLjMpO1xcbiAgICAgICAgICBpZih2aWQgPT0gMSlcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIoICAwLjAsICAwLjApO1xcbiAgICAgICAgICBpZih2aWQgPT0gMilcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHZlYzIoIDAuMTUsIC0wLjMpO1xcblxcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodVBhblpvb21NYXRyaXggKiBhVHJhbnNmb3JtICogdmVjMyhwb3NpdGlvbiwgMS4wKSwgMS4wKTtcXG4gICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgyLjAsIDAuMCwgMC4wLCAxLjApOyAvLyBkaXNjYXJkIHZlcnRleCBieSBwdXR0aW5nIGl0IG91dHNpZGUgd2ViZ2wgY2xpcCBzcGFjZVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdkF0bGFzSWQgPSBhQXRsYXNJZDtcXG4gICAgICAgIHZWZXJ0VHlwZSA9IGFWZXJ0VHlwZTtcXG4gICAgICAgIHZJbmRleCA9IGFJbmRleDtcXG4gICAgICB9XFxuICAgIFwiKTtcbiAgICAgIHZhciBpZHhzID0gdGhpcy5iYXRjaE1hbmFnZXIuZ2V0SW5kZXhBcnJheSgpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyU291cmNlID0gXCIjdmVyc2lvbiAzMDAgZXNcXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxuICAgICAgLy8gZGVjbGFyZSB0ZXh0dXJlIHVuaXQgZm9yIGVhY2ggdGV4dHVyZSBhdGxhcyBpbiB0aGUgYmF0Y2hcXG4gICAgICBcIi5jb25jYXQoaWR4cy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmVcIi5jb25jYXQoaSwgXCI7XCIpO1xuICAgICAgfSkuam9pbignXFxuXFx0JyksIFwiXFxuXFxuICAgICAgdW5pZm9ybSB2ZWM0IHVCR0NvbG9yO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgdVpvb207XFxuXFxuICAgICAgaW4gdmVjMiB2VGV4Q29vcmQ7XFxuICAgICAgaW4gdmVjNCB2Q29sb3I7XFxuICAgICAgaW4gdmVjMiB2UG9zaXRpb247IC8vIG1vZGVsIGNvb3JkaW5hdGVzXFxuXFxuICAgICAgZmxhdCBpbiBpbnQgdkF0bGFzSWQ7XFxuICAgICAgZmxhdCBpbiB2ZWM0IHZJbmRleDtcXG4gICAgICBmbGF0IGluIGludCB2VmVydFR5cGU7XFxuICAgICAgZmxhdCBpbiB2ZWMyIHZUb3BSaWdodDtcXG4gICAgICBmbGF0IGluIHZlYzIgdkJvdExlZnQ7XFxuICAgICAgZmxhdCBpbiB2ZWM0IHZDb3JuZXJSYWRpdXM7XFxuICAgICAgZmxhdCBpbiB2ZWM0IHZCb3JkZXJDb2xvcjtcXG4gICAgICBmbGF0IGluIHZlYzIgdkJvcmRlcldpZHRoO1xcblxcbiAgICAgIG91dCB2ZWM0IG91dENvbG9yO1xcblxcbiAgICAgIFwiKS5jb25jYXQoY2lyY2xlU0QsIFwiXFxuICAgICAgXCIpLmNvbmNhdChyZWN0YW5nbGVTRCwgXCJcXG4gICAgICBcIikuY29uY2F0KHJvdW5kUmVjdGFuZ2xlU0QsIFwiXFxuICAgICAgXCIpLmNvbmNhdChlbGxpcHNlU0QsIFwiXFxuXFxuICAgICAgdmVjNCBibGVuZCh2ZWM0IHRvcCwgdmVjNCBib3QpIHsgLy8gYmxlbmQgY29sb3JzIHdpdGggcHJlbXVsdGlwbGllZCBhbHBoYVxcbiAgICAgICAgcmV0dXJuIHZlYzQoIFxcbiAgICAgICAgICB0b3AucmdiICsgKGJvdC5yZ2IgKiAoMS4wIC0gdG9wLmEpKSxcXG4gICAgICAgICAgdG9wLmEgICArIChib3QuYSAgICogKDEuMCAtIHRvcC5hKSkgXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICB2ZWM0IGRpc3RJbnRlcnAodmVjNCBjQSwgdmVjNCBjQiwgZmxvYXQgZCkgeyAvLyBpbnRlcnBvbGF0ZSBjb2xvciB1c2luZyBTaWduZWQgRGlzdGFuY2VcXG4gICAgICAgIC8vIHNjYWxlIHRvIHRoZSB6b29tIGxldmVsIHNvIHRoYXQgYm9yZGVycyBkb24ndCBsb29rIGJsdXJyeSB3aGVuIHpvb21lZCBpblxcbiAgICAgICAgLy8gbm90ZSAxLjUgaXMgYW4gYXJpYml0cmFyeSB2YWx1ZSBjaG9zZW4gYmVjYXVzZSBpdCBsb29rcyBnb29kXFxuICAgICAgICByZXR1cm4gbWl4KGNBLCBjQiwgMS4wIC0gc21vb3Roc3RlcCgwLjAsIDEuNSAvIHVab29tLCBhYnMoZCkpKTsgXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChURVhUVVJFLCBcIikge1xcbiAgICAgICAgICAvLyBsb29rIHVwIHRoZSB0ZXhlbCBmcm9tIHRoZSB0ZXh0dXJlIHVuaXRcXG4gICAgICAgICAgXCIpLmNvbmNhdChpZHhzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gXCJpZih2QXRsYXNJZCA9PSBcIi5jb25jYXQoaSwgXCIpIG91dENvbG9yID0gdGV4dHVyZSh1VGV4dHVyZVwiKS5jb25jYXQoaSwgXCIsIHZUZXhDb29yZCk7XCIpO1xuICAgICAgfSkuam9pbignXFxuXFx0ZWxzZSAnKSwgXCJcXG4gICAgICAgIH0gXFxuICAgICAgICBlbHNlIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVER0VfQVJST1csIFwiKSB7XFxuICAgICAgICAgIC8vIG1pbWljcyBob3cgY2FudmFzIHJlbmRlcmVyIHVzZXMgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcXG4gICAgICAgICAgb3V0Q29sb3IgPSBibGVuZCh2Q29sb3IsIHVCR0NvbG9yKTtcXG4gICAgICAgICAgb3V0Q29sb3IuYSA9IDEuMDsgLy8gbWFrZSBvcGFxdWUsIG1hc2tzIG91dCBsaW5lIHVuZGVyIGFycm93XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFJFQ1RBTkdMRSwgXCIgJiYgdkJvcmRlcldpZHRoID09IHZlYzIoMC4wKSkgeyAvLyBzaW1wbGUgcmVjdGFuZ2xlIHdpdGggbm8gYm9yZGVyXFxuICAgICAgICAgIG91dENvbG9yID0gdkNvbG9yOyAvLyB1bml0IHNxdWFyZSBpcyBhbHJlYWR5IHRyYW5zZm9ybWVkIHRvIHRoZSByZWN0YW5nbGUsIG5vdGhpbmcgZWxzZSBuZWVkcyB0byBiZSBkb25lXFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFJFQ1RBTkdMRSwgXCIgfHwgdlZlcnRUeXBlID09IFwiKS5jb25jYXQoRUxMSVBTRSwgXCIgXFxuICAgICAgICAgIHx8IHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFJPVU5EX1JFQ1RBTkdMRSwgXCIgfHwgdlZlcnRUeXBlID09IFwiKS5jb25jYXQoQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSwgXCIpIHsgLy8gdXNlIFNERlxcblxcbiAgICAgICAgICBmbG9hdCBvdXRlckJvcmRlciA9IHZCb3JkZXJXaWR0aFswXTtcXG4gICAgICAgICAgZmxvYXQgaW5uZXJCb3JkZXIgPSB2Qm9yZGVyV2lkdGhbMV07XFxuICAgICAgICAgIGZsb2F0IGJvcmRlclBhZGRpbmcgPSBvdXRlckJvcmRlciAqIDIuMDtcXG4gICAgICAgICAgZmxvYXQgdyA9IHZUb3BSaWdodC54IC0gdkJvdExlZnQueCAtIGJvcmRlclBhZGRpbmc7XFxuICAgICAgICAgIGZsb2F0IGggPSB2VG9wUmlnaHQueSAtIHZCb3RMZWZ0LnkgLSBib3JkZXJQYWRkaW5nO1xcbiAgICAgICAgICB2ZWMyIGIgPSB2ZWMyKHcvMi4wLCBoLzIuMCk7IC8vIGhhbGYgd2lkdGgsIGhhbGYgaGVpZ2h0XFxuICAgICAgICAgIHZlYzIgcCA9IHZQb3NpdGlvbiAtIHZlYzIodlRvcFJpZ2h0LnggLSBiWzBdIC0gb3V0ZXJCb3JkZXIsIHZUb3BSaWdodC55IC0gYlsxXSAtIG91dGVyQm9yZGVyKTsgLy8gdHJhbnNsYXRlIHRvIGNlbnRlclxcblxcbiAgICAgICAgICBmbG9hdCBkOyAvLyBzaWduZWQgZGlzdGFuY2VcXG4gICAgICAgICAgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoUkVDVEFOR0xFLCBcIikge1xcbiAgICAgICAgICAgIGQgPSByZWN0YW5nbGVTRChwLCBiKTtcXG4gICAgICAgICAgfSBlbHNlIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVMTElQU0UsIFwiICYmIHcgPT0gaCkge1xcbiAgICAgICAgICAgIGQgPSBjaXJjbGVTRChwLCBiLngpOyAvLyBmYXN0ZXIgdGhhbiBlbGxpcHNlXFxuICAgICAgICAgIH0gZWxzZSBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChFTExJUFNFLCBcIikge1xcbiAgICAgICAgICAgIGQgPSBlbGxpcHNlU0QocCwgYik7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZCA9IHJvdW5kUmVjdGFuZ2xlU0QocCwgYiwgdkNvcm5lclJhZGl1cy53enl4KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAvLyB1c2UgdGhlIGRpc3RhbmNlIHRvIGludGVycG9sYXRlIGEgY29sb3IgdG8gc21vb3RoIHRoZSBlZGdlcyBvZiB0aGUgc2hhcGUsIGRvZXNuJ3QgbmVlZCBtdWx0aXNhbXBsaW5nXFxuICAgICAgICAgIC8vIHdlIG11c3Qgc21vb3RoIGNvbG9ycyBpbndhcmRzLCBiZWNhdXNlIHdlIGNhbid0IGNoYW5nZSBwaXhlbHMgb3V0c2lkZSB0aGUgc2hhcGUncyBib3VuZGluZyBib3hcXG4gICAgICAgICAgaWYoZCA+IDAuMCkge1xcbiAgICAgICAgICAgIGlmKGQgPiBvdXRlckJvcmRlcikge1xcbiAgICAgICAgICAgICAgZGlzY2FyZDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgb3V0Q29sb3IgPSBkaXN0SW50ZXJwKHZCb3JkZXJDb2xvciwgdmVjNCgwKSwgZCAtIG91dGVyQm9yZGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYoZCA+IGlubmVyQm9yZGVyKSB7XFxuICAgICAgICAgICAgICB2ZWM0IG91dGVyQ29sb3IgPSBvdXRlckJvcmRlciA9PSAwLjAgPyB2ZWM0KDApIDogdkJvcmRlckNvbG9yO1xcbiAgICAgICAgICAgICAgdmVjNCBpbm5lckJvcmRlckNvbG9yID0gYmxlbmQodkJvcmRlckNvbG9yLCB2Q29sb3IpO1xcbiAgICAgICAgICAgICAgb3V0Q29sb3IgPSBkaXN0SW50ZXJwKGlubmVyQm9yZGVyQ29sb3IsIG91dGVyQ29sb3IsIGQpO1xcbiAgICAgICAgICAgIH0gXFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICB2ZWM0IG91dGVyQ29sb3I7XFxuICAgICAgICAgICAgICBpZihpbm5lckJvcmRlciA9PSAwLjAgJiYgb3V0ZXJCb3JkZXIgPT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG91dGVyQ29sb3IgPSB2ZWM0KDApO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGlubmVyQm9yZGVyID09IDAuMCkge1xcbiAgICAgICAgICAgICAgICBvdXRlckNvbG9yID0gdkJvcmRlckNvbG9yO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgb3V0ZXJDb2xvciA9IGJsZW5kKHZCb3JkZXJDb2xvciwgdkNvbG9yKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIG91dENvbG9yID0gZGlzdEludGVycCh2Q29sb3IsIG91dGVyQ29sb3IsIGQgLSBpbm5lckJvcmRlcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgb3V0Q29sb3IgPSB2Q29sb3I7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIikuY29uY2F0KHJlbmRlclRhcmdldC5waWNraW5nID8gXCJpZihvdXRDb2xvci5hID09IDAuMCkgZGlzY2FyZDtcXG4gICAgICAgICAgICAgZWxzZSBvdXRDb2xvciA9IHZJbmRleDtcIiA6ICcnLCBcIlxcbiAgICAgIH1cXG4gICAgXCIpO1xuICAgICAgdmFyIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcblxuICAgICAgLy8gaW5zdGFuY2UgZ2VvbWV0cnlcbiAgICAgIHByb2dyYW0uYVBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb3NpdGlvbicpO1xuXG4gICAgICAvLyBhdHRyaWJ1dGVzXG4gICAgICBwcm9ncmFtLmFJbmRleCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhSW5kZXgnKTtcbiAgICAgIHByb2dyYW0uYVZlcnRUeXBlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FWZXJ0VHlwZScpO1xuICAgICAgcHJvZ3JhbS5hVHJhbnNmb3JtID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUcmFuc2Zvcm0nKTtcbiAgICAgIHByb2dyYW0uYUF0bGFzSWQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYUF0bGFzSWQnKTtcbiAgICAgIHByb2dyYW0uYVRleCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhVGV4Jyk7XG4gICAgICBwcm9ncmFtLmFQb2ludEFQb2ludEIgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvaW50QVBvaW50QicpO1xuICAgICAgcHJvZ3JhbS5hUG9pbnRDUG9pbnREID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb2ludENQb2ludEQnKTtcbiAgICAgIHByb2dyYW0uYUxpbmVXaWR0aCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhTGluZVdpZHRoJyk7XG4gICAgICBwcm9ncmFtLmFDb2xvciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29sb3InKTtcbiAgICAgIHByb2dyYW0uYUNvcm5lclJhZGl1cyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQ29ybmVyUmFkaXVzJyk7XG4gICAgICBwcm9ncmFtLmFCb3JkZXJDb2xvciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQm9yZGVyQ29sb3InKTtcblxuICAgICAgLy8gdW5pZm9ybXNcbiAgICAgIHByb2dyYW0udVBhblpvb21NYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VQYW5ab29tTWF0cml4Jyk7XG4gICAgICBwcm9ncmFtLnVBdGxhc1NpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VBdGxhc1NpemUnKTtcbiAgICAgIHByb2dyYW0udUJHQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VCR0NvbG9yJyk7XG4gICAgICBwcm9ncmFtLnVab29tID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Wm9vbScpO1xuICAgICAgcHJvZ3JhbS51VGV4dHVyZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iYXRjaE1hbmFnZXIuZ2V0TWF4QXRsYXNlc1BlckJhdGNoKCk7IGkrKykge1xuICAgICAgICBwcm9ncmFtLnVUZXh0dXJlcy5wdXNoKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVUZXh0dXJlXCIuY29uY2F0KGkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVZBT1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVkFPKCkge1xuICAgICAgdmFyIHVuaXRTcXVhcmUgPSBbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMV07XG4gICAgICB0aGlzLnZlcnRleENvdW50ID0gdW5pdFNxdWFyZS5sZW5ndGggLyAyO1xuICAgICAgdmFyIG4gPSB0aGlzLm1heEluc3RhbmNlcztcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2wsXG4gICAgICAgIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XG4gICAgICB2YXIgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcbiAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgY3JlYXRlQnVmZmVyU3RhdGljRHJhdyhnbCwgJ3ZlYzInLCBwcm9ncmFtLmFQb3NpdGlvbiwgdW5pdFNxdWFyZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBidWZmZXJzIGZvciBhbGwgdGhlIGF0dHJpYnV0ZXNcbiAgICAgIHRoaXMudHJhbnNmb3JtQnVmZmVyID0gY3JlYXRlM3gzTWF0cml4QnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sIHByb2dyYW0uYVRyYW5zZm9ybSk7XG4gICAgICB0aGlzLmluZGV4QnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hSW5kZXgpO1xuICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAnaW50JywgcHJvZ3JhbS5hVmVydFR5cGUpO1xuICAgICAgdGhpcy5hdGxhc0lkQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICdpbnQnLCBwcm9ncmFtLmFBdGxhc0lkKTtcbiAgICAgIHRoaXMudGV4QnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hVGV4KTtcbiAgICAgIHRoaXMucG9pbnRBUG9pbnRCQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hUG9pbnRBUG9pbnRCKTtcbiAgICAgIHRoaXMucG9pbnRDUG9pbnREQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hUG9pbnRDUG9pbnREKTtcbiAgICAgIHRoaXMubGluZVdpZHRoQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWMyJywgcHJvZ3JhbS5hTGluZVdpZHRoKTtcbiAgICAgIHRoaXMuY29sb3JCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFDb2xvcik7XG4gICAgICB0aGlzLmNvcm5lclJhZGl1c0J1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYUNvcm5lclJhZGl1cyk7XG4gICAgICB0aGlzLmJvcmRlckNvbG9yQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hQm9yZGVyQ29sb3IpO1xuICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgICAgcmV0dXJuIHZhbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVmZmVyc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5fYnVmZmVycykge1xuICAgICAgICB0aGlzLl9idWZmZXJzID0gT2JqZWN0LmtleXModGhpcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZHNXaXRoKGssICdCdWZmZXInKTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzW2tdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXJzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEZyYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0RnJhbWUocGFuWm9vbU1hdHJpeCkge1xuICAgICAgdmFyIHJlbmRlclRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogUkVOREVSX1RBUkdFVC5TQ1JFRU47XG4gICAgICB0aGlzLnBhblpvb21NYXRyaXggPSBwYW5ab29tTWF0cml4O1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgICB0aGlzLmJhdGNoRGVidWdJbmZvID0gW107XG4gICAgICB0aGlzLndyYXBwZWRDb3VudCA9IDA7XG4gICAgICB0aGlzLnNpbXBsZUNvdW50ID0gMDtcbiAgICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQgPSAwO1xuICAgICAgdGhpcy5iYXRjaE1hbmFnZXIuc3RhcnRCYXRjaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRGcmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRGcmFtZSgpIHtcbiAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNWaXNpYmxlKGVsZSwgb3B0cykge1xuICAgICAgaWYgKGVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5pc1Zpc2libGUpIHtcbiAgICAgICAgICByZXR1cm4gb3B0cy5pc1Zpc2libGUoZWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHRleHR1cmUgdXNpbmcgdGhlIHRleHR1cmUgYXRsYXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1RleHR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1RleHR1cmUoZWxlLCBlbGVJbmRleCwgdHlwZSkge1xuICAgICAgdmFyIGF0bGFzTWFuYWdlciA9IHRoaXMuYXRsYXNNYW5hZ2VyLFxuICAgICAgICBiYXRjaE1hbmFnZXIgPSB0aGlzLmJhdGNoTWFuYWdlcjtcbiAgICAgIHZhciBvcHRzID0gYXRsYXNNYW5hZ2VyLmdldFJlbmRlclR5cGVPcHRzKHR5cGUpO1xuICAgICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoZWxlLCBvcHRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEVkZ2VzIHdpdGggaW52YWxpZCBwb2ludHMgY291bGQgYmUgcGFzc2VkIGhlcmUgKGxhYmVscyksIGNhdXNpbmcgZXJyb3JzXG4gICAgICAvLyBSZWY6IFJhbmRvbSBcIlNjcmlwdCBFcnJvclwiIHRocm93biB3aGVuIGdlbmVyYXRpbmcgbm9kZXMgYW5kIGVkZ2VzIGluIG5ld2VzdCB3ZWJnbCB2ZXJzaW9uICMzMzY1XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY3l0b3NjYXBlL2N5dG9zY2FwZS5qcy9pc3N1ZXMvMzM2NVxuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAhdGhpcy5faXNWYWxpZEVkZ2UoZWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZW5kZXJUYXJnZXQucGlja2luZyAmJiBvcHRzLmdldFRleFBpY2tpbmdNb2RlKSB7XG4gICAgICAgIHZhciBtb2RlID0gb3B0cy5nZXRUZXhQaWNraW5nTW9kZShlbGUpO1xuICAgICAgICBpZiAobW9kZSA9PT0gVEVYX1BJQ0tJTkdfTU9ERS5JR05PUkUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBURVhfUElDS0lOR19NT0RFLlVTRV9CQikge1xuICAgICAgICAgIHRoaXMuZHJhd1BpY2tpbmdSZWN0YW5nbGUoZWxlLCBlbGVJbmRleCwgdHlwZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgYXRsYXMgYW5kIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzLCB3aWxsIGRyYXcgdGhlIHRleHR1cmUgaWYgaXQgaGFzbid0IGJlZW4gZHJhd24geWV0XG4gICAgICAvLyBNYXkgYmUgbW9yZSB0aGFuIG9uZSB0ZXh0dXJlIGlmIGZvciBleGFtcGxlIHRoZSBsYWJlbCBoYXMgbXVsdGlwbGUgbGluZXNcbiAgICAgIHZhciBhdGxhc0luZm9BcnJheSA9IGF0bGFzTWFuYWdlci5nZXRBdGxhc0luZm8oZWxlLCB0eXBlKTtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhdGxhc0luZm9BcnJheSksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYXRsYXNJbmZvID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGF0bGFzID0gYXRsYXNJbmZvLmF0bGFzLFxuICAgICAgICAgICAgdGV4MSA9IGF0bGFzSW5mby50ZXgxLFxuICAgICAgICAgICAgdGV4MiA9IGF0bGFzSW5mby50ZXgyOyAvLyB0ZXgyIGlzIHVzZWQgaWYgdGhlIGxhYmVsIHdyYXBzIGFuZCB0aGVyZSBhcmUgdHdvIHRleHR1cmVzXG5cbiAgICAgICAgICBpZiAoIWJhdGNoTWFuYWdlci5jYW5BZGRUb0N1cnJlbnRCYXRjaChhdGxhcykpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF0bGFzSW5kZXggPSBiYXRjaE1hbmFnZXIuZ2V0QXRsYXNJbmRleEZvckJhdGNoKGF0bGFzKTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hcnIgPSBbW3RleDEsIHRydWVdLCBbdGV4MiwgZmFsc2VdXTsgX2kgPCBfYXJyLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9hcnIkX2kgPSBfc2xpY2VkVG9BcnJheShfYXJyW19pXSwgMiksXG4gICAgICAgICAgICAgIHRleCA9IF9hcnIkX2lbMF0sXG4gICAgICAgICAgICAgIGZpcnN0ID0gX2FyciRfaVsxXTtcbiAgICAgICAgICAgIGlmICh0ZXgudyAhPSAwKSB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgICAgICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKVswXSA9IFRFWFRVUkU7XG4gICAgICAgICAgICAgIHZhciBpbmRleFZpZXcgPSB0aGlzLmluZGV4QnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICBpbmRleFRvVmVjNChlbGVJbmRleCwgaW5kZXhWaWV3KTtcblxuICAgICAgICAgICAgICAvLyBTZXQgdmFsdWVzIGluIHRoZSBidWZmZXJzIHVzaW5nIFR5cGVkIEFycmF5IFZpZXdzIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgdmFyIGF0bGFzSWRWaWV3ID0gdGhpcy5hdGxhc0lkQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICBhdGxhc0lkVmlld1swXSA9IGF0bGFzSW5kZXg7XG5cbiAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0d28gc2V0cyBvZiB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCB0cmFuc2Zvcm1zIGJlY2F1c2UgdGV4dHVyZXMgY2FuIHdyYXAgaW4gdGhlIGF0bGFzXG4gICAgICAgICAgICAgIHZhciB0ZXhWaWV3ID0gdGhpcy50ZXhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIHRleFZpZXdbMF0gPSB0ZXgueDtcbiAgICAgICAgICAgICAgdGV4Vmlld1sxXSA9IHRleC55O1xuICAgICAgICAgICAgICB0ZXhWaWV3WzJdID0gdGV4Lnc7XG4gICAgICAgICAgICAgIHRleFZpZXdbM10gPSB0ZXguaDtcbiAgICAgICAgICAgICAgdmFyIG1hdHJpeFZpZXcgPSB0aGlzLnRyYW5zZm9ybUJ1ZmZlci5nZXRNYXRyaXhWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1NYXRyaXgoZWxlLCBtYXRyaXhWaWV3LCBvcHRzLCBhdGxhc0luZm8sIGZpcnN0KTtcbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gICAgICAgICAgICAgIGlmICghZmlyc3QpIHRoaXMud3JhcHBlZENvdW50Kys7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPj0gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXRyaXggaXMgZXhwZWN0ZWQgdG8gYmUgYSA5IGVsZW1lbnQgYXJyYXlcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGZvbGxvd3Mgc2FtZSBwYXR0ZXJuIGFzIENScC5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oLi4uKVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFRyYW5zZm9ybU1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUcmFuc2Zvcm1NYXRyaXgoZWxlLCBtYXRyaXgsIG9wdHMsIGF0bGFzSW5mbykge1xuICAgICAgdmFyIGZpcnN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgICAgdmFyIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKG9wdHMuc2hhcGVQcm9wcyAmJiBvcHRzLnNoYXBlUHJvcHMucGFkZGluZykge1xuICAgICAgICBwYWRkaW5nID0gZWxlLnBzdHlsZShvcHRzLnNoYXBlUHJvcHMucGFkZGluZykucGZWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhdGxhc0luZm8pIHtcbiAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBjb21wdXRlZCB0aGUgYmIgYW5kIHRleCBib3VuZHMgZm9yIGEgdGV4dHVyZVxuICAgICAgICB2YXIgYmIgPSBhdGxhc0luZm8uYmIsXG4gICAgICAgICAgdGV4MSA9IGF0bGFzSW5mby50ZXgxLFxuICAgICAgICAgIHRleDIgPSBhdGxhc0luZm8udGV4MjtcbiAgICAgICAgLy8gd3JhcHBlZCB0ZXh0dXJlcyBuZWVkIHNlcGFyYXRlIG1hdHJpeCBmb3IgZWFjaCBwYXJ0XG4gICAgICAgIHZhciByYXRpbyA9IHRleDEudyAvICh0ZXgxLncgKyB0ZXgyLncpO1xuICAgICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgICAgLy8gZmlyc3QgPSB0cnVlIG1lYW5zIGl0cyB0aGUgZmlyc3QgcGFydCBvZiB0aGUgd3JhcHBlZCB0ZXh0dXJlXG4gICAgICAgICAgcmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkakJCID0gdGhpcy5fZ2V0QWRqdXN0ZWRCQihiYiwgcGFkZGluZywgZmlyc3QsIHJhdGlvKTtcbiAgICAgICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBhZGpCQiwgb3B0cywgZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGhhdmUgYSB0ZXh0dXJlLCBvciB3ZSB3YW50IHRvIGF2b2lkIGNyZWF0aW5nIGEgdGV4dHVyZSBmb3Igc2ltcGxlIHNoYXBlc1xuICAgICAgICB2YXIgX2JiID0gb3B0cy5nZXRCb3VuZGluZ0JveChlbGUpO1xuICAgICAgICB2YXIgX2FkakJCID0gdGhpcy5fZ2V0QWRqdXN0ZWRCQihfYmIsIHBhZGRpbmcsIHRydWUsIDEpO1xuICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIF9hZGpCQiwgb3B0cywgZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGx5VHJhbnNmb3JtTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIGFkakJCLCBvcHRzLCBlbGUpIHtcbiAgICAgIHZhciB4LCB5O1xuICAgICAgaWRlbnRpdHkobWF0cml4KTtcbiAgICAgIHZhciB0aGV0YSA9IG9wdHMuZ2V0Um90YXRpb24gPyBvcHRzLmdldFJvdGF0aW9uKGVsZSkgOiAwO1xuICAgICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICAgIHZhciBfb3B0cyRnZXRSb3RhdGlvblBvaW4gPSBvcHRzLmdldFJvdGF0aW9uUG9pbnQoZWxlKSxcbiAgICAgICAgICBzeCA9IF9vcHRzJGdldFJvdGF0aW9uUG9pbi54LFxuICAgICAgICAgIHN5ID0gX29wdHMkZ2V0Um90YXRpb25Qb2luLnk7XG4gICAgICAgIHRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgW3N4LCBzeV0pO1xuICAgICAgICByb3RhdGUobWF0cml4LCBtYXRyaXgsIHRoZXRhKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IG9wdHMuZ2V0Um90YXRpb25PZmZzZXQoZWxlKTtcbiAgICAgICAgeCA9IG9mZnNldC54ICsgKGFkakJCLnhPZmZzZXQgfHwgMCk7XG4gICAgICAgIHkgPSBvZmZzZXQueSArIChhZGpCQi55T2Zmc2V0IHx8IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGFkakJCLngxO1xuICAgICAgICB5ID0gYWRqQkIueTE7XG4gICAgICB9XG4gICAgICB0cmFuc2xhdGUobWF0cml4LCBtYXRyaXgsIFt4LCB5XSk7XG4gICAgICBzY2FsZShtYXRyaXgsIG1hdHJpeCwgW2FkakJCLncsIGFkakJCLmhdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGEgbm9kZSBvciBsYWJlbCBCQiB0byBhY2NvbW9kYXRlIHBhZGRpbmcgYW5kIHNwbGl0IGZvciB3cmFwcGVkIHRleHR1cmVzLlxuICAgICAqIEBwYXJhbSBiYiAtIHRoZSBvcmlnaW5hbCBib3VuZGluZyBib3hcbiAgICAgKiBAcGFyYW0gcGFkZGluZyAtIHRoZSBwYWRkaW5nIHRvIGFkZCB0byB0aGUgYm91bmRpbmcgYm94XG4gICAgICogQHBhcmFtIGZpcnN0IC0gd2hldGhlciB0aGlzIGlzIHRoZSBmaXJzdCBwYXJ0IG9mIGEgd3JhcHBlZCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHJhdGlvIC0gdGhlIHJhdGlvIG9mIHRoZSB0ZXh0dXJlIHdpZHRoIG9mIHBhcnQgb2YgdGhlIHRleHQgdG8gdGhlIGVudGlyZSB0ZXh0dXJlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFkanVzdGVkQkJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFkanVzdGVkQkIoYmIsIHBhZGRpbmcsIGZpcnN0LCByYXRpbykge1xuICAgICAgdmFyIHgxID0gYmIueDEsXG4gICAgICAgIHkxID0gYmIueTEsXG4gICAgICAgIHcgPSBiYi53LFxuICAgICAgICBoID0gYmIuaCxcbiAgICAgICAgeU9mZnNldCA9IGJiLnlPZmZzZXQ7XG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICB4MSAtPSBwYWRkaW5nO1xuICAgICAgICB5MSAtPSBwYWRkaW5nO1xuICAgICAgICB3ICs9IDIgKiBwYWRkaW5nO1xuICAgICAgICBoICs9IDIgKiBwYWRkaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgdmFyIGFkalcgPSB3ICogcmF0aW87XG4gICAgICBpZiAoZmlyc3QgJiYgcmF0aW8gPCAxKSB7XG4gICAgICAgIHcgPSBhZGpXO1xuICAgICAgfSBlbHNlIGlmICghZmlyc3QgJiYgcmF0aW8gPCAxKSB7XG4gICAgICAgIHhPZmZzZXQgPSB3IC0gYWRqVztcbiAgICAgICAgeDEgKz0geE9mZnNldDtcbiAgICAgICAgdyA9IGFkalc7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgdzogdyxcbiAgICAgICAgaDogaCxcbiAgICAgICAgeE9mZnNldDogeE9mZnNldCxcbiAgICAgICAgeU9mZnNldDogeU9mZnNldFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc29saWQgb3BhcXVlIHJlY3RhbmdsZSBtYXRjaGluZyB0aGUgZWxlbWVudCdzIEJvdW5kaW5nIEJveC5cbiAgICAgKiBVc2VkIGJ5IHRoZSBQSUNLSU5HIG1vZGUgdG8gbWFrZSB0aGUgZW50aXJlIEJCIG9mIGEgbGFiZWwgY2xpY2thYmxlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdQaWNraW5nUmVjdGFuZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdQaWNraW5nUmVjdGFuZ2xlKGVsZSwgZWxlSW5kZXgsIHR5cGUpIHtcbiAgICAgIHZhciBvcHRzID0gdGhpcy5hdGxhc01hbmFnZXIuZ2V0UmVuZGVyVHlwZU9wdHModHlwZSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpWzBdID0gUkVDVEFOR0xFO1xuICAgICAgdmFyIGluZGV4VmlldyA9IHRoaXMuaW5kZXhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICBpbmRleFRvVmVjNChlbGVJbmRleCwgaW5kZXhWaWV3KTtcbiAgICAgIHZhciBjb2xvclZpZXcgPSB0aGlzLmNvbG9yQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgdG9XZWJHTENvbG9yKFswLCAwLCAwXSwgMSwgY29sb3JWaWV3KTsgLy8gb3BhcXVlLCBzbyBlbnRpcmUgbGFiZWwgQkIgaXMgY2xpY2thYmxlXG5cbiAgICAgIHZhciBtYXRyaXhWaWV3ID0gdGhpcy50cmFuc2Zvcm1CdWZmZXIuZ2V0TWF0cml4VmlldyhpbnN0YW5jZSk7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybU1hdHJpeChlbGUsIG1hdHJpeFZpZXcsIG9wdHMpO1xuICAgICAgdGhpcy5zaW1wbGVDb3VudCsrO1xuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50Kys7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID49IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgbm9kZSB1c2luZyBlaXRoZXIgYSB0ZXh0dXJlIG9yIGEgXCJzaW1wbGUgc2hhcGVcIi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Tm9kZShub2RlLCBlbGVJbmRleCwgdHlwZSkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLnNpbXBsZVNoYXBlT3B0aW9ucy5nZXQodHlwZSk7XG4gICAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZShub2RlLCBvcHRzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBvcHRzLnNoYXBlUHJvcHM7XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdG8gdXNlIGEgdGV4dHVyZVxuICAgICAgdmFyIHZlcnRUeXBlID0gdGhpcy5fZ2V0VmVydFR5cGVGb3JTaGFwZShub2RlLCBwcm9wcy5zaGFwZSk7XG4gICAgICBpZiAodmVydFR5cGUgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmlzU2ltcGxlICYmICFvcHRzLmlzU2ltcGxlKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuZHJhd1RleHR1cmUobm9kZSwgZWxlSW5kZXgsIHR5cGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBhIFwic2ltcGxlIHNoYXBlXCIgdXNpbmcgU0RGIChzaWduZWQgZGlzdGFuY2UgZmllbGRzKVxuICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKVswXSA9IHZlcnRUeXBlO1xuICAgICAgaWYgKHZlcnRUeXBlID09PSBST1VORF9SRUNUQU5HTEUgfHwgdmVydFR5cGUgPT09IEJPVFRPTV9ST1VORF9SRUNUQU5HTEUpIHtcbiAgICAgICAgLy8gZ2V0IGNvcm5lciByYWRpdXNcbiAgICAgICAgdmFyIGJiID0gb3B0cy5nZXRCb3VuZGluZ0JveChub2RlKTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuX2dldENvcm5lclJhZGl1cyhub2RlLCBwcm9wcy5yYWRpdXMsIGJiKTtcbiAgICAgICAgdmFyIHJhZGl1c1ZpZXcgPSB0aGlzLmNvcm5lclJhZGl1c0J1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgcmFkaXVzVmlld1swXSA9IHJhZGl1czsgLy8gdG9wLXJpZ2h0XG4gICAgICAgIHJhZGl1c1ZpZXdbMV0gPSByYWRpdXM7IC8vIGJvdHRvbS1yaWdodFxuICAgICAgICByYWRpdXNWaWV3WzJdID0gcmFkaXVzOyAvLyB0b3AtbGVmdFxuICAgICAgICByYWRpdXNWaWV3WzNdID0gcmFkaXVzOyAvLyBib3R0b20tbGVmdFxuICAgICAgICBpZiAodmVydFR5cGUgPT09IEJPVFRPTV9ST1VORF9SRUNUQU5HTEUpIHtcbiAgICAgICAgICByYWRpdXNWaWV3WzBdID0gMDtcbiAgICAgICAgICByYWRpdXNWaWV3WzJdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGluZGV4VmlldyA9IHRoaXMuaW5kZXhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICBpbmRleFRvVmVjNChlbGVJbmRleCwgaW5kZXhWaWV3KTtcbiAgICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKHByb3BzLmNvbG9yKS52YWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUocHJvcHMub3BhY2l0eSkudmFsdWU7XG4gICAgICB2YXIgY29sb3JWaWV3ID0gdGhpcy5jb2xvckJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgIHRvV2ViR0xDb2xvcihjb2xvciwgb3BhY2l0eSwgY29sb3JWaWV3KTtcbiAgICAgIHZhciBsaW5lV2lkdGhWaWV3ID0gdGhpcy5saW5lV2lkdGhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7IC8vIHJldXNlIGVkZ2UgbGluZSB3aWR0aCBhdHRyaWJ1dGUgZm9yIG5vZGUgYm9yZGVyXG4gICAgICBsaW5lV2lkdGhWaWV3WzBdID0gMDtcbiAgICAgIGxpbmVXaWR0aFZpZXdbMV0gPSAwO1xuICAgICAgaWYgKHByb3BzLmJvcmRlcikge1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSBub2RlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykudmFsdWU7XG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgICAgICAgdmFyIGJvcmRlck9wYWNpdHkgPSBub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZTtcbiAgICAgICAgICB2YXIgYm9yZGVyQ29sb3JWaWV3ID0gdGhpcy5ib3JkZXJDb2xvckJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgICB0b1dlYkdMQ29sb3IoYm9yZGVyQ29sb3IsIGJvcmRlck9wYWNpdHksIGJvcmRlckNvbG9yVmlldyk7XG5cbiAgICAgICAgICAvLyBTREYgZGlzdGFuY2UgaXMgbmVnYXRpdmUgaW5zaWRlIHRoZSBzaGFwZSBhbmQgcG9zaXRpdmUgb3V0c2lkZVxuICAgICAgICAgIHZhciBib3JkZXJQb3MgPSBub2RlLnBzdHlsZSgnYm9yZGVyLXBvc2l0aW9uJykudmFsdWU7XG4gICAgICAgICAgaWYgKGJvcmRlclBvcyA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aFZpZXdbMF0gPSAwO1xuICAgICAgICAgICAgbGluZVdpZHRoVmlld1sxXSA9IC1ib3JkZXJXaWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJvcmRlclBvcyA9PT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgICBsaW5lV2lkdGhWaWV3WzBdID0gYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBsaW5lV2lkdGhWaWV3WzFdID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJ2NlbnRlcidcbiAgICAgICAgICAgIHZhciBoYWxmV2lkdGggPSBib3JkZXJXaWR0aCAvIDI7XG4gICAgICAgICAgICBsaW5lV2lkdGhWaWV3WzBdID0gaGFsZldpZHRoO1xuICAgICAgICAgICAgbGluZVdpZHRoVmlld1sxXSA9IC1oYWxmV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbWF0cml4VmlldyA9IHRoaXMudHJhbnNmb3JtQnVmZmVyLmdldE1hdHJpeFZpZXcoaW5zdGFuY2UpO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1NYXRyaXgobm9kZSwgbWF0cml4Vmlldywgb3B0cyk7XG4gICAgICB0aGlzLnNpbXBsZUNvdW50Kys7XG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPj0gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmVydFR5cGVGb3JTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmVydFR5cGVGb3JTaGFwZShub2RlLCBzaGFwZVByb3ApIHtcbiAgICAgIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKHNoYXBlUHJvcCkudmFsdWU7XG4gICAgICBzd2l0Y2ggKHNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XG4gICAgICAgICAgcmV0dXJuIFJFQ1RBTkdMRTtcbiAgICAgICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICAgICAgcmV0dXJuIEVMTElQU0U7XG4gICAgICAgIGNhc2UgJ3JvdW5kcmVjdGFuZ2xlJzpcbiAgICAgICAgY2FzZSAncm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgICAgICByZXR1cm4gUk9VTkRfUkVDVEFOR0xFO1xuICAgICAgICBjYXNlICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgICAgICByZXR1cm4gQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29ybmVyUmFkaXVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb3JuZXJSYWRpdXMobm9kZSwgcmFkaXVzUHJvcCwgX3JlZjIpIHtcbiAgICAgIHZhciB3ID0gX3JlZjIudyxcbiAgICAgICAgaCA9IF9yZWYyLmg7XG4gICAgICAvLyBzZWUgQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGhcbiAgICAgIGlmIChub2RlLnBzdHlsZShyYWRpdXNQcm9wKS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHJldHVybiBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3LCBoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBub2RlLnBzdHlsZShyYWRpdXNQcm9wKS5wZlZhbHVlO1xuICAgICAgICB2YXIgaGFsZldpZHRoID0gdyAvIDI7XG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gaCAvIDI7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyYWRpdXMsIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBzdXBwb3J0cyBkcmF3aW5nIHRyaWFuZ2xlcyBhdCB0aGUgbW9tZW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdFZGdlQXJyb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0VkZ2VBcnJvdyhlZGdlLCBlbGVJbmRleCwgcHJlZml4KSB7XG4gICAgICBpZiAoIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEVkZ2UgcG9pbnRzIGFuZCBhcnJvdyBhbmdsZXMgZXRjIGFyZSBjYWxjdWxhdGVkIGJ5IHRoZSBiYXNlIHJlbmRlcmVyIGFuZCBjYWNoZWQgaW4gdGhlIHJzY3JhdGNoIG9iamVjdC5cbiAgICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgeCwgeSwgYW5nbGU7XG4gICAgICBpZiAocHJlZml4ID09PSAnc291cmNlJykge1xuICAgICAgICB4ID0gcnMuYXJyb3dTdGFydFg7XG4gICAgICAgIHkgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICAgICAgYW5nbGUgPSBycy5zcmNBcnJvd0FuZ2xlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHJzLmFycm93RW5kWDtcbiAgICAgICAgeSA9IHJzLmFycm93RW5kWTtcbiAgICAgICAgYW5nbGUgPSBycy50Z3RBcnJvd0FuZ2xlO1xuICAgICAgfVxuXG4gICAgICAvLyB0YWtlbiBmcm9tIENScC5kcmF3QXJyb3doZWFkXG4gICAgICBpZiAoaXNOYU4oeCkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKHkpIHx8IHkgPT0gbnVsbCB8fCBpc05hTihhbmdsZSkgfHwgYW5nbGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHNoYXBlIGFmdGVyIHRoZSB4L3kgY2hlY2sgYmVjYXVzZSBwc3R5bGUoKSBpcyBhIGJpdCBzbG93XG4gICAgICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgICAgIGlmIChhcnJvd1NoYXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1jb2xvcicpLnZhbHVlO1xuICAgICAgdmFyIGJhc2VPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciBsaW5lT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdsaW5lLW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gYmFzZU9wYWNpdHkgKiBsaW5lT3BhY2l0eTtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIHNjYWxlJDEgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5yLmdldEFycm93V2lkdGgobGluZVdpZHRoLCBzY2FsZSQxKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybUJ1ZmZlci5nZXRNYXRyaXhWaWV3KGluc3RhbmNlKTtcbiAgICAgIGlkZW50aXR5KHRyYW5zZm9ybSk7XG4gICAgICB0cmFuc2xhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIFt4LCB5XSk7XG4gICAgICBzY2FsZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgW3NpemUsIHNpemVdKTtcbiAgICAgIHJvdGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgYW5nbGUpO1xuICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKVswXSA9IEVER0VfQVJST1c7XG4gICAgICB2YXIgaW5kZXhWaWV3ID0gdGhpcy5pbmRleEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgIGluZGV4VG9WZWM0KGVsZUluZGV4LCBpbmRleFZpZXcpO1xuICAgICAgdmFyIGNvbG9yVmlldyA9IHRoaXMuY29sb3JCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICB0b1dlYkdMQ29sb3IoY29sb3IsIG9wYWNpdHksIGNvbG9yVmlldyk7XG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPj0gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgc3RyYWlnaHQtbGluZSBvciBiZXppZXIgY3VydmUgZWRnZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0VkZ2VMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdFZGdlTGluZShlZGdlLCBlbGVJbmRleCkge1xuICAgICAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5fZ2V0RWRnZVBvaW50cyhlZGdlKTtcbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbGluZSBzdHlsZVxuICAgICAgdmFyIGJhc2VPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciBsaW5lT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdsaW5lLW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciB3aWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZSgnbGluZS1jb2xvcicpLnZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBiYXNlT3BhY2l0eSAqIGxpbmVPcGFjaXR5O1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggLyAyICsgdGhpcy5pbnN0YW5jZUNvdW50ID4gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT0gNCkge1xuICAgICAgICAvLyBzdHJhaWdodCBsaW5lXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgICAgdGhpcy52ZXJ0VHlwZUJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKVswXSA9IEVER0VfU1RSQUlHSFQ7XG4gICAgICAgIHZhciBpbmRleFZpZXcgPSB0aGlzLmluZGV4QnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICBpbmRleFRvVmVjNChlbGVJbmRleCwgaW5kZXhWaWV3KTtcbiAgICAgICAgdmFyIGNvbG9yVmlldyA9IHRoaXMuY29sb3JCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgIHRvV2ViR0xDb2xvcihjb2xvciwgb3BhY2l0eSwgY29sb3JWaWV3KTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aEJ1ZmZlciA9IHRoaXMubGluZVdpZHRoQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICBsaW5lV2lkdGhCdWZmZXJbMF0gPSB3aWR0aDtcbiAgICAgICAgdmFyIHNvdXJjZVRhcmdldFZpZXcgPSB0aGlzLnBvaW50QVBvaW50QkJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgc291cmNlVGFyZ2V0Vmlld1swXSA9IHBvaW50c1swXTsgLy8gc291cmNlIHhcbiAgICAgICAgc291cmNlVGFyZ2V0Vmlld1sxXSA9IHBvaW50c1sxXTsgLy8gc291cmNlIHlcbiAgICAgICAgc291cmNlVGFyZ2V0Vmlld1syXSA9IHBvaW50c1syXTsgLy8gdGFyZ2V0IHhcbiAgICAgICAgc291cmNlVGFyZ2V0Vmlld1szXSA9IHBvaW50c1szXTsgLy8gdGFyZ2V0IHlcblxuICAgICAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA+PSB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3VydmVkIGxpbmVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMjsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyLmdldFZpZXcoX2luc3RhbmNlKVswXSA9IEVER0VfQ1VSVkVfU0VHTUVOVDtcbiAgICAgICAgICB2YXIgX2luZGV4VmlldyA9IHRoaXMuaW5kZXhCdWZmZXIuZ2V0VmlldyhfaW5zdGFuY2UpO1xuICAgICAgICAgIGluZGV4VG9WZWM0KGVsZUluZGV4LCBfaW5kZXhWaWV3KTtcbiAgICAgICAgICB2YXIgX2NvbG9yVmlldyA9IHRoaXMuY29sb3JCdWZmZXIuZ2V0VmlldyhfaW5zdGFuY2UpO1xuICAgICAgICAgIHRvV2ViR0xDb2xvcihjb2xvciwgb3BhY2l0eSwgX2NvbG9yVmlldyk7XG4gICAgICAgICAgdmFyIF9saW5lV2lkdGhCdWZmZXIgPSB0aGlzLmxpbmVXaWR0aEJ1ZmZlci5nZXRWaWV3KF9pbnN0YW5jZSk7XG4gICAgICAgICAgX2xpbmVXaWR0aEJ1ZmZlclswXSA9IHdpZHRoO1xuICAgICAgICAgIHZhciBwQXggPSBwb2ludHNbaSAtIDJdLFxuICAgICAgICAgICAgcEF5ID0gcG9pbnRzW2kgLSAxXTtcbiAgICAgICAgICB2YXIgcEJ4ID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgcEJ5ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICB2YXIgcEN4ID0gcG9pbnRzW2kgKyAyXSxcbiAgICAgICAgICAgIHBDeSA9IHBvaW50c1tpICsgM107XG4gICAgICAgICAgdmFyIHBEeCA9IHBvaW50c1tpICsgNF0sXG4gICAgICAgICAgICBwRHkgPSBwb2ludHNbaSArIDVdO1xuXG4gICAgICAgICAgLy8gbWFrZSBwaGFudG9tIHBvaW50cyBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgICAgICAgLy8gVE9ETyBhZGRpbmcgMC4wMDEgdG8gYXZvaWQgZGl2aXNpb24gYnkgemVybyBpbiB0aGUgc2hhZGVyIChJIHRoaW5rKSwgbmVlZCBhIGJldHRlciBzb2x1dGlvblxuICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIHBBeCA9IDIgKiBwQnggLSBwQ3ggKyAwLjAwMTtcbiAgICAgICAgICAgIHBBeSA9IDIgKiBwQnkgLSBwQ3kgKyAwLjAwMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT0gcG9pbnRzLmxlbmd0aCAtIDQpIHtcbiAgICAgICAgICAgIHBEeCA9IDIgKiBwQ3ggLSBwQnggKyAwLjAwMTtcbiAgICAgICAgICAgIHBEeSA9IDIgKiBwQ3kgLSBwQnkgKyAwLjAwMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBvaW50QUJWaWV3ID0gdGhpcy5wb2ludEFQb2ludEJCdWZmZXIuZ2V0VmlldyhfaW5zdGFuY2UpO1xuICAgICAgICAgIHBvaW50QUJWaWV3WzBdID0gcEF4O1xuICAgICAgICAgIHBvaW50QUJWaWV3WzFdID0gcEF5O1xuICAgICAgICAgIHBvaW50QUJWaWV3WzJdID0gcEJ4O1xuICAgICAgICAgIHBvaW50QUJWaWV3WzNdID0gcEJ5O1xuICAgICAgICAgIHZhciBwb2ludENEVmlldyA9IHRoaXMucG9pbnRDUG9pbnREQnVmZmVyLmdldFZpZXcoX2luc3RhbmNlKTtcbiAgICAgICAgICBwb2ludENEVmlld1swXSA9IHBDeDtcbiAgICAgICAgICBwb2ludENEVmlld1sxXSA9IHBDeTtcbiAgICAgICAgICBwb2ludENEVmlld1syXSA9IHBEeDtcbiAgICAgICAgICBwb2ludENEVmlld1szXSA9IHBEeTtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID49IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1ZhbGlkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNWYWxpZEVkZ2UoZWRnZSkge1xuICAgICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIGlmIChycy5iYWRMaW5lIHx8IHJzLmFsbHB0cyA9PSBudWxsIHx8IGlzTmFOKHJzLmFsbHB0c1swXSkpIHtcbiAgICAgICAgLy8gaXNOYU4gaW4gY2FzZSBlZGdlIGlzIGltcG9zc2libGUgYW5kIGJyb3dzZXIgYnVncyAoZS5nLiBzYWZhcmkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RWRnZVBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RWRnZVBvaW50cyhlZGdlKSB7XG4gICAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkRWRnZShlZGdlKSkge1xuICAgICAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBycy5hbGxwdHM7XG4gICAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggPT0gNCkge1xuICAgICAgICByZXR1cm4gY29udHJvbFBvaW50cztcbiAgICAgIH1cbiAgICAgIHZhciBudW1TZWdtZW50cyA9IHRoaXMuX2dldE51bVNlZ21lbnRzKGVkZ2UpO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEN1cnZlU2VnbWVudFBvaW50cyhjb250cm9sUG9pbnRzLCBudW1TZWdtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXROdW1TZWdtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TnVtU2VnbWVudHMoZWRnZSkge1xuICAgICAgLy8gVE9ETyBOZWVkIGEgaGV1cmlzdGljIHRoYXQgZGVjaWRlcyBob3cgbWFueSBzZWdtZW50cyB0byB1c2UuIEZhY3RvcnMgdG8gY29uc2lkZXI6XG4gICAgICAvLyAtIGVkZ2Ugd2lkdGgvbGVuZ3RoXG4gICAgICAvLyAtIGVkZ2UgY3VydmF0dXJlICh0aGUgbW9yZSB0aGUgY3VydmF0dXJlLCB0aGUgbW9yZSBzZWdtZW50cylcbiAgICAgIC8vIC0gem9vbSBsZXZlbCAobW9yZSBzZWdtZW50cyB3aGVuIHpvb21lZCBpbilcbiAgICAgIC8vIC0gbnVtYmVyIG9mIHZpc2libGUgZWRnZXMgKG1vcmUgc2VnbWVudHMgd2hlbiB0aGVyZSBhcmUgZmV3ZXIgZWRnZXMpXG4gICAgICAvLyAtIHBlcmZvcm1hbmNlIChmZXdlciBzZWdtZW50cyB3aGVuIHBlcmZvcm1hbmNlIGlzIGEgY29uY2VybilcbiAgICAgIC8vIC0gdXNlciBjb25maWd1cmFibGUgb3B0aW9uKHMpXG4gICAgICAvLyBub3RlOiBudW1iZXIgb2Ygc2VnbWVudHMgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIG1heCBudW1iZXIgb2YgaW5zdGFuY2VzXG4gICAgICAvLyBub3RlOiBzZWdtZW50cyBkb24ndCBuZWVkIHRvIGJlIGV2ZW5seSBzcGFjZWQgb3V0LCBpdCBtaWdodCBtYWtlIHNlbnNlIHRvIGhhdmUgc2hvcnRlciBzZWdtZW50cyBuZWFyZXIgdG8gdGhlIGNvbnRyb2wgcG9pbnRzXG4gICAgICB2YXIgbnVtU2VnbWVudHMgPSAxNTtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW1TZWdtZW50cywgNSksIHRoaXMubWF4SW5zdGFuY2VzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEN1cnZlU2VnbWVudFBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q3VydmVTZWdtZW50UG9pbnRzKGNvbnRyb2xQb2ludHMsIHNlZ21lbnRzKSB7XG4gICAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggPT0gNCkge1xuICAgICAgICByZXR1cm4gY29udHJvbFBvaW50czsgLy8gc3RyYWlnaHQgbGluZVxuICAgICAgfVxuICAgICAgdmFyIGN1cnZlUG9pbnRzID0gQXJyYXkoKHNlZ21lbnRzICsgMSkgKiAyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IGFuZCBsYXN0IGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICBjdXJ2ZVBvaW50c1swXSA9IGNvbnRyb2xQb2ludHNbMF07XG4gICAgICAgICAgY3VydmVQb2ludHNbMV0gPSBjb250cm9sUG9pbnRzWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT0gc2VnbWVudHMpIHtcbiAgICAgICAgICBjdXJ2ZVBvaW50c1tpICogMl0gPSBjb250cm9sUG9pbnRzW2NvbnRyb2xQb2ludHMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgY3VydmVQb2ludHNbaSAqIDIgKyAxXSA9IGNvbnRyb2xQb2ludHNbY29udHJvbFBvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdCA9IGkgLyBzZWdtZW50czsgLy8gc2VnbWVudHMgaGF2ZSBlcXVhbCBsZW5ndGgsIGl0cyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IHRvIGRvIGl0IHRoaXMgd2F5XG4gICAgICAgICAgLy8gcGFzcyBpbiBjdXJ2ZVBvaW50cyB0byBzZXQgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgZGlyZWN0bHlcbiAgICAgICAgICB0aGlzLl9zZXRDdXJ2ZVBvaW50KGNvbnRyb2xQb2ludHMsIHQsIGN1cnZlUG9pbnRzLCBpICogMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJ2ZVBvaW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEN1cnZlUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEN1cnZlUG9pbnQocG9pbnRzLCB0LCBjdXJ2ZVBvaW50cywgY3BpKSB7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgIGN1cnZlUG9pbnRzW2NwaV0gPSBwb2ludHNbMF07XG4gICAgICAgIGN1cnZlUG9pbnRzW2NwaSArIDFdID0gcG9pbnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld3BvaW50cyA9IEFycmF5KHBvaW50cy5sZW5ndGggLSAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICB2YXIgeCA9ICgxIC0gdCkgKiBwb2ludHNbaV0gKyB0ICogcG9pbnRzW2kgKyAyXTtcbiAgICAgICAgICB2YXIgeSA9ICgxIC0gdCkgKiBwb2ludHNbaSArIDFdICsgdCAqIHBvaW50c1tpICsgM107XG4gICAgICAgICAgbmV3cG9pbnRzW2ldID0geDtcbiAgICAgICAgICBuZXdwb2ludHNbaSArIDFdID0geTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0Q3VydmVQb2ludChuZXdwb2ludHMsIHQsIGN1cnZlUG9pbnRzLCBjcGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2wsXG4gICAgICAgIHZhbyA9IHRoaXMudmFvLFxuICAgICAgICB2ZXJ0ZXhDb3VudCA9IHRoaXMudmVydGV4Q291bnQsXG4gICAgICAgIGNvdW50ID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgaWYgKGNvdW50ID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMucmVuZGVyVGFyZ2V0LnBpY2tpbmcgPyB0aGlzLnBpY2tpbmdQcm9ncmFtIDogdGhpcy5wcm9ncmFtO1xuICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuXG4gICAgICAvLyBidWZmZXIgdGhlIGF0dHJpYnV0ZSBkYXRhXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuYnVmZmVycyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBidWZmZXIuYnVmZmVyU3ViRGF0YShjb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgdmFyIGF0bGFzZXMgPSB0aGlzLmJhdGNoTWFuYWdlci5nZXRBdGxhc2VzKCk7XG4gICAgICAvLyBtdXN0IGJ1ZmZlciBiZWZvcmUgYWN0aXZhdGluZyB0ZXh0dXJlIHVuaXRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0bGFzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXRsYXNlc1tpXS5idWZmZXJJZk5lZWRlZChnbCk7XG4gICAgICB9XG4gICAgICAvLyBBY3RpdmF0ZSBhbGwgdGhlIHRleHR1cmUgdW5pdHMgdGhhdCB3ZSBuZWVkXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhdGxhc2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIF9pMik7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGF0bGFzZXNbX2kyXS50ZXh0dXJlKTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udVRleHR1cmVzW19pMl0sIF9pMik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgdW5pZm9ybXNcbiAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVab29tLCBnZXRFZmZlY3RpdmVab29tKHRoaXMucikpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihwcm9ncmFtLnVQYW5ab29tTWF0cml4LCBmYWxzZSwgdGhpcy5wYW5ab29tTWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVBdGxhc1NpemUsIHRoaXMuYmF0Y2hNYW5hZ2VyLmdldEF0bGFzU2l6ZSgpKTtcbiAgICAgIC8vIHNldCBiYWNrZ3JvdW5kIGNvbG9yLCBuZWVkZWQgZm9yIGVkZ2UgYXJyb3cgY29sb3IgYmxlbmRpbmdcbiAgICAgIHZhciB3ZWJnbEJnQ29sb3IgPSB0b1dlYkdMQ29sb3IodGhpcy5iZ0NvbG9yLCAxKTtcbiAgICAgIGdsLnVuaWZvcm00ZnYocHJvZ3JhbS51QkdDb2xvciwgd2ViZ2xCZ0NvbG9yKTtcblxuICAgICAgLy8gZHJhdyFcbiAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoZ2wuVFJJQU5HTEVTLCAwLCB2ZXJ0ZXhDb3VudCwgY291bnQpO1xuICAgICAgZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IC8vIFRPRE8gaXMgdGhpcyByaWdodCB3aGVuIGhhdmluZyBtdWx0aXBsZSB0ZXh0dXJlIHVuaXRzP1xuXG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICB0aGlzLmJhdGNoRGVidWdJbmZvLnB1c2goe1xuICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAvLyBpbnN0YW5jZSBjb3VudFxuICAgICAgICAgIGF0bGFzQ291bnQ6IGF0bGFzZXMubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFydCB0aGUgbmV4dCBiYXRjaCwgZXZlbiBpZiBub3QgbmVlZGVkXG4gICAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVidWdJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlYnVnSW5mbygpIHtcbiAgICAgIHZhciBhdGxhc0luZm8gPSB0aGlzLmF0bGFzTWFuYWdlci5nZXREZWJ1Z0luZm8oKTtcbiAgICAgIHZhciB0b3RhbEF0bGFzZXMgPSBhdGxhc0luZm8ucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgaW5mbykge1xuICAgICAgICByZXR1cm4gY291bnQgKyBpbmZvLmF0bGFzQ291bnQ7XG4gICAgICB9LCAwKTtcbiAgICAgIHZhciBiYXRjaEluZm8gPSB0aGlzLmJhdGNoRGVidWdJbmZvO1xuICAgICAgdmFyIHRvdGFsSW5zdGFuY2VzID0gYmF0Y2hJbmZvLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIGluZm8pIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ICsgaW5mby5jb3VudDtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXRsYXNJbmZvOiBhdGxhc0luZm8sXG4gICAgICAgIHRvdGFsQXRsYXNlczogdG90YWxBdGxhc2VzLFxuICAgICAgICB3cmFwcGVkQ291bnQ6IHRoaXMud3JhcHBlZENvdW50LFxuICAgICAgICBzaW1wbGVDb3VudDogdGhpcy5zaW1wbGVDb3VudCxcbiAgICAgICAgYmF0Y2hDb3VudDogYmF0Y2hJbmZvLmxlbmd0aCxcbiAgICAgICAgYmF0Y2hJbmZvOiBiYXRjaEluZm8sXG4gICAgICAgIHRvdGFsSW5zdGFuY2VzOiB0b3RhbEluc3RhbmNlc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIENScCQ0ID0ge307XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgV2ViR0wgcmVuZGVyaW5nIG1vZGUgYWZ0ZXIgdGhlIENhbnZhcyByZW5kZXJlciBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAqL1xuQ1JwJDQuaW5pdFdlYmdsID0gZnVuY3Rpb24gKG9wdHMsIGZucykge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBnbCA9IHIuZGF0YS5jb250ZXh0c1tyLldFQkdMXTtcblxuICAvLyBTZXQgZGVmYXVsdHMgYW5kIGxpbWl0cyBmb3IgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICBvcHRzLmJnQ29sb3IgPSBnZXRCR0NvbG9yKHIpO1xuICBvcHRzLndlYmdsVGV4U2l6ZSA9IE1hdGgubWluKG9wdHMud2ViZ2xUZXhTaXplLCBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSkpO1xuICBvcHRzLndlYmdsVGV4Um93cyA9IE1hdGgubWluKG9wdHMud2ViZ2xUZXhSb3dzLCA1NCk7XG4gIG9wdHMud2ViZ2xUZXhSb3dzTm9kZXMgPSBNYXRoLm1pbihvcHRzLndlYmdsVGV4Um93c05vZGVzLCA1NCk7XG4gIG9wdHMud2ViZ2xCYXRjaFNpemUgPSBNYXRoLm1pbihvcHRzLndlYmdsQmF0Y2hTaXplLCAxNjM4NCk7XG4gIG9wdHMud2ViZ2xUZXhQZXJCYXRjaCA9IE1hdGgubWluKG9wdHMud2ViZ2xUZXhQZXJCYXRjaCwgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSk7XG5cbiAgLy8gVHVybiBkZWJ1ZyBtb2RlIG9uIG9yIG9mZi5cbiAgci53ZWJnbERlYnVnID0gb3B0cy53ZWJnbERlYnVnO1xuICByLndlYmdsRGVidWdTaG93QXRsYXNlcyA9IG9wdHMud2ViZ2xEZWJ1Z1Nob3dBdGxhc2VzO1xuXG4gIC8vIENyZWF0ZSBvZmZzY3JlZW4gZnJhbWVidWZmZXIgdGhhdCBzdG9yZXMgdGhlIHJlc3VsdHMgd2hlbiBSRU5ERVJfVEFSR0VULlBJQ0tJTkcgaXMgZW5hYmxlZC5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSB0b3Btb3N0IGVsZW1lbnQgei1pbmRleCBmb3IgZWFjaCBwaXhlbCwgd2hpY2ggaXMgdXNlZCB0byB0ZWxsIHdoYXRzIHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgcG9pbnQuXG4gIHIucGlja2luZ0ZyYW1lQnVmZmVyID0gY3JlYXRlUGlja2luZ0ZyYW1lQnVmZmVyKGdsKTtcbiAgci5waWNraW5nRnJhbWVCdWZmZXIubmVlZHNEcmF3ID0gdHJ1ZTtcblxuICAvLyBDcmVhdGUgYW4gRWxlbWVudERyYXdpbmdXZWJHTCBpbnN0YW5jZSB3aWNoIGlzIHVzZWQgdG8gZG8gdGhlIGFjdHVhbCBXZWJHTCByZW5kZXJpbmcuXG4gIC8vIFRoaXMgaW5zdGFuY2UgbmVlZHMgdG8gYmUgY29uZmlndXJlZCB0byBkcmF3IHZhcmlvdXMgdHlwZXMgb2YgZWxlbWVudHMuXG4gIHIuZHJhd2luZyA9IG5ldyBFbGVtZW50RHJhd2luZ1dlYkdMKHIsIGdsLCBvcHRzKTtcblxuICAvLyBTb21lIGZ1bmN0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIGNvbmZpZ3VyZSBFbGVtZW50RHJhd2luZ1dlYkdMXG4gIHZhciBnZXRMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsIHByb3ApO1xuICAgIH07XG4gIH07XG4gIHZhciBpc0xhYmVsVmlzaWJsZSA9IGZ1bmN0aW9uIGlzTGFiZWxWaXNpYmxlKHByb3ApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZSkge1xuICAgICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZShwcm9wKTtcbiAgICAgIHJldHVybiBsYWJlbCAmJiBsYWJlbC52YWx1ZTtcbiAgICB9O1xuICB9O1xuICB2YXIgaXNMYXllclZpc2libGUgPSBmdW5jdGlvbiBpc0xheWVyVmlzaWJsZShwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIHByZWZpeCBpcyAnb3ZlcmxheScgb3IgJ3VuZGVybGF5J1xuICAgICAgcmV0dXJuIG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KHByZWZpeCwgXCItb3BhY2l0eVwiKSkudmFsdWUgPiAwO1xuICAgIH07XG4gIH07XG4gIHZhciBnZXRUZXhQaWNraW5nTW9kZSA9IGZ1bmN0aW9uIGdldFRleFBpY2tpbmdNb2RlKGVsZSkge1xuICAgIC8vIHRlbGxzIHdoZW4gYSBsYWJlbCBzaG91bGQgYmUgY2xpY2thYmxlXG4gICAgdmFyIGVuYWJsZWQgPSBlbGUucHN0eWxlKCd0ZXh0LWV2ZW50cycpLnN0clZhbHVlID09PSAneWVzJztcbiAgICByZXR1cm4gZW5hYmxlZCA/IFRFWF9QSUNLSU5HX01PREUuVVNFX0JCIDogVEVYX1BJQ0tJTkdfTU9ERS5JR05PUkU7XG4gIH07XG4gIHZhciBnZXRCQkZvclNpbXBsZVNoYXBlID0gZnVuY3Rpb24gZ2V0QkJGb3JTaW1wbGVTaGFwZShub2RlKSB7XG4gICAgLy8gXCJzaW1wbGVcIiBzaGFwZXMgbmVlZCB0aGVpciBCQiB0byBpbmNsdWRlIGJvcmRlciBhbmQgcGFkZGluZ1xuICAgIHZhciBfbm9kZSRwb3NpdGlvbiA9IG5vZGUucG9zaXRpb24oKSxcbiAgICAgIHggPSBfbm9kZSRwb3NpdGlvbi54LFxuICAgICAgeSA9IF9ub2RlJHBvc2l0aW9uLnk7XG4gICAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTsgLy8gaW5jbHVkZXMgYm9yZGVyIGFuZCBwYWRkaW5nXG4gICAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6IHcsXG4gICAgICBoOiBoLFxuICAgICAgeDE6IHggLSB3IC8gMixcbiAgICAgIHkxOiB5IC0gaCAvIDJcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIEF0bGFzQ29sbGVjdGlvbiBpcyBhIGNvbGxlY3Rpb24gb2YgQXRsYXNlcyB0aGF0IGhhdmUgdGhlIHNhbWUgY29uZmlndXJhaXRvbiBvcHRpb25zLlxuICAvLyBDcmVhdGUgb25lIGZvciBub2RlIGJvZGllcyBhbmQgb25lIGZvciBhbGwgdHlwZXMgb2YgbGFiZWxzLlxuICByLmRyYXdpbmcuYWRkQXRsYXNDb2xsZWN0aW9uKCdub2RlJywge1xuICAgIHRleFJvd3M6IG9wdHMud2ViZ2xUZXhSb3dzTm9kZXNcbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRBdGxhc0NvbGxlY3Rpb24oJ2xhYmVsJywge1xuICAgIHRleFJvd3M6IG9wdHMud2ViZ2xUZXhSb3dzXG4gIH0pO1xuXG4gIC8vIENvbmZpZ3VyZSB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHJlbmRlcmVkLlxuXG4gIC8vIE5vZGUgYm9kaWVzIGNhbiBiZSByZW5kZXJlZCBhcyB0ZXh0dXJlcyBvciBhcyBcInNpbXBsZSBzaGFwZXNcIi4gXG4gIC8vIFNpbXBsZSBzaGFwZXMgYXJlIHByZWZlcnJlZCBiZWNhdXNlIHRoZXkgZG8gbm90IHVzZSB0ZXh0dXJlIG1lbW9yeS5cbiAgLy8gVGV4dHVyZXMgYXJlIHJlcXVpcmVkIGlmIHRoZSBub2RlIGJvZHkgdXNlcyBjb21wbGV4IHN0eWxlcy4gXG4gIHIuZHJhd2luZy5hZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlKCdub2RlLWJvZHknLCB7XG4gICAgY29sbGVjdGlvbjogJ25vZGUnLFxuICAgIGdldEtleTogZm5zLmdldFN0eWxlS2V5LFxuICAgIGdldEJvdW5kaW5nQm94OiBmbnMuZ2V0RWxlbWVudEJveCxcbiAgICBkcmF3RWxlbWVudDogZm5zLmRyYXdFbGVtZW50XG4gIH0pO1xuICByLmRyYXdpbmcuYWRkU2ltcGxlU2hhcGVSZW5kZXJUeXBlKCdub2RlLWJvZHknLCB7XG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJCRm9yU2ltcGxlU2hhcGUsXG4gICAgaXNTaW1wbGU6IGlzU2ltcGxlU2hhcGUsXG4gICAgc2hhcGVQcm9wczoge1xuICAgICAgc2hhcGU6ICdzaGFwZScsXG4gICAgICBjb2xvcjogJ2JhY2tncm91bmQtY29sb3InLFxuICAgICAgb3BhY2l0eTogJ2JhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICByYWRpdXM6ICdjb3JuZXItcmFkaXVzJyxcbiAgICAgIGJvcmRlcjogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRTaW1wbGVTaGFwZVJlbmRlclR5cGUoJ25vZGUtb3ZlcmxheScsIHtcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0QkJGb3JTaW1wbGVTaGFwZSxcbiAgICBpc1Zpc2libGU6IGlzTGF5ZXJWaXNpYmxlKCdvdmVybGF5JyksXG4gICAgc2hhcGVQcm9wczoge1xuICAgICAgc2hhcGU6ICdvdmVybGF5LXNoYXBlJyxcbiAgICAgIGNvbG9yOiAnb3ZlcmxheS1jb2xvcicsXG4gICAgICBvcGFjaXR5OiAnb3ZlcmxheS1vcGFjaXR5JyxcbiAgICAgIHBhZGRpbmc6ICdvdmVybGF5LXBhZGRpbmcnLFxuICAgICAgcmFkaXVzOiAnb3ZlcmxheS1jb3JuZXItcmFkaXVzJ1xuICAgIH1cbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRTaW1wbGVTaGFwZVJlbmRlclR5cGUoJ25vZGUtdW5kZXJsYXknLCB7XG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJCRm9yU2ltcGxlU2hhcGUsXG4gICAgaXNWaXNpYmxlOiBpc0xheWVyVmlzaWJsZSgndW5kZXJsYXknKSxcbiAgICBzaGFwZVByb3BzOiB7XG4gICAgICBzaGFwZTogJ3VuZGVybGF5LXNoYXBlJyxcbiAgICAgIGNvbG9yOiAndW5kZXJsYXktY29sb3InLFxuICAgICAgb3BhY2l0eTogJ3VuZGVybGF5LW9wYWNpdHknLFxuICAgICAgcGFkZGluZzogJ3VuZGVybGF5LXBhZGRpbmcnLFxuICAgICAgcmFkaXVzOiAndW5kZXJsYXktY29ybmVyLXJhZGl1cydcbiAgICB9XG4gIH0pO1xuICByLmRyYXdpbmcuYWRkVGV4dHVyZUF0bGFzUmVuZGVyVHlwZSgnbGFiZWwnLCB7XG4gICAgLy8gbm9kZSBsYWJlbCBvciBlZGdlIG1pZCBsYWJlbFxuICAgIGNvbGxlY3Rpb246ICdsYWJlbCcsXG4gICAgZ2V0VGV4UGlja2luZ01vZGU6IGdldFRleFBpY2tpbmdNb2RlLFxuICAgIGdldEtleTogZ2V0U3R5bGVLZXlzRm9yTGFiZWwoZm5zLmdldExhYmVsS2V5LCBudWxsKSxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbChmbnMuZ2V0TGFiZWxCb3gsIG51bGwpLFxuICAgIGRyYXdDbGlwcGVkOiB0cnVlLFxuICAgIGRyYXdFbGVtZW50OiBmbnMuZHJhd0xhYmVsLFxuICAgIGdldFJvdGF0aW9uOiBnZXRMYWJlbFJvdGF0aW9uKG51bGwpLFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGZucy5nZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGZucy5nZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGUoJ2xhYmVsJylcbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlKCdlZGdlLXNvdXJjZS1sYWJlbCcsIHtcbiAgICBjb2xsZWN0aW9uOiAnbGFiZWwnLFxuICAgIGdldFRleFBpY2tpbmdNb2RlOiBnZXRUZXhQaWNraW5nTW9kZSxcbiAgICBnZXRLZXk6IGdldFN0eWxlS2V5c0ZvckxhYmVsKGZucy5nZXRTb3VyY2VMYWJlbEtleSwgJ3NvdXJjZScpLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRCb3VuZGluZ0JveEZvckxhYmVsKGZucy5nZXRTb3VyY2VMYWJlbEJveCwgJ3NvdXJjZScpLFxuICAgIGRyYXdDbGlwcGVkOiB0cnVlLFxuICAgIGRyYXdFbGVtZW50OiBmbnMuZHJhd1NvdXJjZUxhYmVsLFxuICAgIGdldFJvdGF0aW9uOiBnZXRMYWJlbFJvdGF0aW9uKCdzb3VyY2UnKSxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBmbnMuZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBmbnMuZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlKCdzb3VyY2UtbGFiZWwnKVxuICB9KTtcbiAgci5kcmF3aW5nLmFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGUoJ2VkZ2UtdGFyZ2V0LWxhYmVsJywge1xuICAgIGNvbGxlY3Rpb246ICdsYWJlbCcsXG4gICAgZ2V0VGV4UGlja2luZ01vZGU6IGdldFRleFBpY2tpbmdNb2RlLFxuICAgIGdldEtleTogZ2V0U3R5bGVLZXlzRm9yTGFiZWwoZm5zLmdldFRhcmdldExhYmVsS2V5LCAndGFyZ2V0JyksXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJvdW5kaW5nQm94Rm9yTGFiZWwoZm5zLmdldFRhcmdldExhYmVsQm94LCAndGFyZ2V0JyksXG4gICAgZHJhd0NsaXBwZWQ6IHRydWUsXG4gICAgZHJhd0VsZW1lbnQ6IGZucy5kcmF3VGFyZ2V0TGFiZWwsXG4gICAgZ2V0Um90YXRpb246IGdldExhYmVsUm90YXRpb24oJ3RhcmdldCcpLFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGZucy5nZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGZucy5nZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGUoJ3RhcmdldC1sYWJlbCcpXG4gIH0pO1xuXG4gIC8vIFZlcnkgc2ltcGxpc3RpYyB3YXkgb2YgdHJpZ2dlcmluZyBnYXJiYWdlIGNvbGxlY3Rpb24sIGp1c3QgdXNlIGEgdGltZXIuXG4gIHZhciBzZXRHQ0ZsYWcgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coJ2dhcmJhZ2UgY29sbGVjdCBmbGFnIHNldCcpO1xuICAgIHIuZGF0YS5nYyA9IHRydWU7XG4gIH0sIDEwMDAwKTtcblxuICAvLyBFdmVudCBsaXN0ZW5lciBjaGVja3MgaWYgc3R5bGUga2V5cyBhcmUgbm8gbG9uZ2VyIGluIHVzZS5cbiAgci5vblVwZGF0ZUVsZUNhbGNzKGZ1bmN0aW9uICh3aWxsRHJhdywgZWxlcykge1xuICAgIHZhciBnY05lZWRlZCA9IGZhbHNlO1xuICAgIGlmIChlbGVzICYmIGVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgZ2NOZWVkZWQgfD0gci5kcmF3aW5nLmludmFsaWRhdGUoZWxlcyk7XG4gICAgfVxuICAgIGlmIChnY05lZWRlZCkge1xuICAgICAgc2V0R0NGbGFnKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBcIk92ZXJyaWRlXCIgY2VydGFpbiBmdW5jdGlvbnMgaW4gY2FudmFzIGFuZCBiYXNlIHJlbmRlcmVyXG4gIG92ZXJyaWRlQ2FudmFzUmVuZGVyZXJGdW5jdGlvbnMocik7XG59O1xuZnVuY3Rpb24gZ2V0QkdDb2xvcihyKSB7XG4gIHZhciBjb250YWluZXIgPSByLmN5LmNvbnRhaW5lcigpO1xuICB2YXIgY3NzQ29sb3IgPSBjb250YWluZXIgJiYgY29udGFpbmVyLnN0eWxlICYmIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3doaXRlJztcbiAgcmV0dXJuIGNvbG9yMnR1cGxlKGNzc0NvbG9yKTtcbn1cbmZ1bmN0aW9uIGdldExhYmVsTGluZXMoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShycywgJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgcHJlZml4KSB8fCBbXTtcbn1cblxuLyoqIFxuICogSGFuZGxlIG11bHRpLWxpbmUgbGFiZWxzIGJ5IHJlbmRlcmluZyBlYWNoIGxpbmUgYXMgYSBzZXBlcmF0ZSB0ZXh0dXJlLlxuICogVGhhdCBtZWFucyBlYWNoIGxpbmUgbmVlZHMgaXRzIG93biBzdHlsZSBrZXkuXG4gKi9cbnZhciBnZXRTdHlsZUtleXNGb3JMYWJlbCA9IGZ1bmN0aW9uIGdldFN0eWxlS2V5c0ZvckxhYmVsKGdldEtleSwgcHJlZml4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGtleSA9IGdldEtleShlbGUpO1xuICAgIHZhciBsaW5lcyA9IGdldExhYmVsTGluZXMoZWxlLCBwcmVmaXgpO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIl9cIikuY29uY2F0KGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9O1xufTtcblxuLyoqXG4gKiBOZWVkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGJvdW5kaW5nIGJveCBmb3IgZWFjaCBsaW5lIG9mIGEgbXVsdGktbGluZSBsYWJlbC5cbiAqIE5vdGUgdGhhdCAnZHJhd0NsaXBwZWQ6IHRydWUnIHNob3VsZCBiZSB1c2VkIHdpdGggdGhpcy5cbiAqL1xudmFyIGdldEJvdW5kaW5nQm94Rm9yTGFiZWwgPSBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveEZvckxhYmVsKGdldEJvdW5kaW5nQm94LCBwcmVmaXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGUsIHN0eWxlS2V5KSB7XG4gICAgdmFyIGJiID0gZ2V0Qm91bmRpbmdCb3goZWxlKTtcbiAgICBpZiAodHlwZW9mIHN0eWxlS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHVpID0gc3R5bGVLZXkuaW5kZXhPZignXycpO1xuICAgICAgaWYgKHVpID4gMCkge1xuICAgICAgICB2YXIgbGluZUluZGV4ID0gTnVtYmVyKHN0eWxlS2V5LnN1YnN0cmluZyh1aSArIDEpKTtcbiAgICAgICAgdmFyIGxpbmVzID0gZ2V0TGFiZWxMaW5lcyhlbGUsIHByZWZpeCk7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgaGVpZ2h0IGFuZCBZIGNvb3JkaW5hdGUgZm9yIG9uZSBsaW5lIG9mIHRoZSBsYWJlbC5cbiAgICAgICAgdmFyIGggPSBiYi5oIC8gbGluZXMubGVuZ3RoO1xuICAgICAgICB2YXIgeU9mZnNldCA9IGggKiBsaW5lSW5kZXg7XG4gICAgICAgIHZhciB5MSA9IGJiLnkxICsgeU9mZnNldDtcbiAgICAgICAgLy8gdGhlIHlPZmZzZXQgaXMgbmVlZGVkIHdoZW4gcm90YXRpbmcgdGhlIGxhYmVsXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICAgIHc6IGJiLncsXG4gICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgIGg6IGgsXG4gICAgICAgICAgeU9mZnNldDogeU9mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmI7XG4gIH07XG59O1xuXG4vKipcbiAqIFBsdWcgaW50byB0aGUgY2FudmFzIHJlbmRlcmVyIGJ5IGR5bmFtaWNhbGx5IG92ZXJyaWRpbmcgc29tZSBvZiBpdHMgZnVuY3Rpb25zLlxuICogVGhpcyByZXF1aXJlcyBtaW5pbWFsIGNoYW5nZXMgdG8gdGhlIGNhbnZhcyByZW5kcmVyZXIuXG4gKi9cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FudmFzUmVuZGVyZXJGdW5jdGlvbnMocikge1xuICB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiB0byBjYWxsIHRoZSB3ZWJnbCByZW5kZXIgZnVuY3Rpb24gaWYgdGhlIHpvb20gbGV2ZWwgaXMgYXBwcm9wcmlhdGVcbiAgICB2YXIgcmVuZGVyQ2FudmFzID0gci5yZW5kZXI7XG4gICAgci5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgaWYgKHIud2ViZ2wpIHtcbiAgICAgICAgLy8gSWYgdGhlIHpvb20gbGV2ZWwgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXggem9vbSBsZXZlbCwgdGhlbiBkaXNhYmxlIHdlYmdsIGFuZCBzd2l0Y2ggYmFjayB0byBcbiAgICAgICAgLy8gdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgICAgaWYgKGN5Lnpvb20oKSA+IG1heFpvb20kMSkge1xuICAgICAgICAgIGNsZWFyV2ViZ2wocik7XG4gICAgICAgICAgcmVuZGVyQ2FudmFzLmNhbGwociwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJDYW52YXMocik7XG4gICAgICAgICAgcmVuZGVyV2ViZ2wociwgb3B0aW9ucywgUkVOREVSX1RBUkdFVC5TQ1JFRU4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIG1hdGNoQ2FudmFzU2l6ZSBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIHBpY2tpbmcgZnJhbWUgYnVmZmVyIHNpemVcbiAgICB2YXIgYmFzZUZ1bmMgPSByLm1hdGNoQ2FudmFzU2l6ZTtcbiAgICByLm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIGJhc2VGdW5jLmNhbGwociwgY29udGFpbmVyKTtcbiAgICAgIHIucGlja2luZ0ZyYW1lQnVmZmVyLnNldEZyYW1lYnVmZmVyQXR0YWNobWVudFNpemVzKHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgIHIucGlja2luZ0ZyYW1lQnVmZmVyLm5lZWRzRHJhdyA9IHRydWU7XG4gICAgfTtcbiAgfVxuICB7XG4gICAgLy8gT3ZlcnJpZGUgZnVuY3Rpb24gdG8gY2FsbCB0aGUgd2ViZ2wgdmVyc2lvbiBmb3IgcGlja2luZy5cbiAgICAvLyBEb24ndCBvdmVycmlkZSByLmdldEFsbEluQm94KCkgc2VsY3Rpb24gYm94IHBpY2tpbmcsIGl0cyBub3QgYWNjdXJhdGUgZW5vdWdoIHdpdGggd2ViZ2xcbiAgICByLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgICAgIC8vIHRoZSBjYW52YXMgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2xvdyBvbiBsYXJnZSBncmFwaHNcbiAgICAgIHJldHVybiBmaW5kTmVhcmVzdEVsZW1lbnRzV2ViZ2wociwgeCwgeSk7XG4gICAgfTtcbiAgfVxuICB7XG4gICAgLy8gbmVlZCB0byBrbm93IHdoZW4gdGhlIGNhY2hlZCBlbGVtZW50cyBoYXZlIGNoYW5nZWQgc28gd2UgY2FuIGludmFsaWRhdGUgb3VyIGNhY2hlc1xuICAgIHZhciBfYmFzZUZ1bmMgPSByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcztcbiAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9iYXNlRnVuYy5jYWxsKHIpO1xuICAgICAgci5waWNraW5nRnJhbWVCdWZmZXIubmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICB9O1xuICB9XG4gIHtcbiAgICAvLyBuZWVkIHRvIGtub3cgd2hlbiB0aGUgY2FjaGVkIGVsZW1lbnRzIGhhdmUgY2hhbmdlZCBzbyB3ZSBjYW4gaW52YWxpZGF0ZSBvdXIgY2FjaGVzXG4gICAgdmFyIF9iYXNlRnVuYzIgPSByLm5vdGlmeTtcbiAgICByLm5vdGlmeSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsZXMpIHtcbiAgICAgIF9iYXNlRnVuYzIuY2FsbChyLCBldmVudE5hbWUsIGVsZXMpO1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3ZpZXdwb3J0JyB8fCBldmVudE5hbWUgPT09ICdib3VuZHMnKSB7XG4gICAgICAgIHIucGlja2luZ0ZyYW1lQnVmZmVyLm5lZWRzRHJhdyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2JhY2tncm91bmQnKSB7XG4gICAgICAgIC8vIGJhY2tncm91bmQgaW1hZ2UgZmluaXNoZWQgbG9hZGluZywgbmVlZCB0byByZWRyYXdcbiAgICAgICAgci5kcmF3aW5nLmludmFsaWRhdGUoZWxlcywge1xuICAgICAgICAgIHR5cGU6ICdub2RlLWJvZHknXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFyV2ViZ2wocikge1xuICB2YXIgZ2wgPSByLmRhdGEuY29udGV4dHNbci5XRUJHTF07XG4gIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKHIpIHtcbiAgLy8gdGhlIENScC5jbGVhckNhbnZhcygpIGZ1bmN0aW9uIGRvZXNuJ3QgdGFrZSB0aGUgdHJhbnNmb3JtIGludG8gYWNjb3VudFxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihjb250ZXh0KSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuICBjbGVhcihyLmRhdGEuY29udGV4dHNbci5OT0RFXSk7XG4gIGNsZWFyKHIuZGF0YS5jb250ZXh0c1tyLkRSQUddKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21NYXRyaXgocikge1xuICB2YXIgd2lkdGggPSByLmNhbnZhc1dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gci5jYW52YXNIZWlnaHQ7XG4gIHZhciBfdXRpbCRnZXRFZmZlY3RpdmVQYW4gPSBnZXRFZmZlY3RpdmVQYW5ab29tKHIpLFxuICAgIHBhbiA9IF91dGlsJGdldEVmZmVjdGl2ZVBhbi5wYW4sXG4gICAgem9vbSA9IF91dGlsJGdldEVmZmVjdGl2ZVBhbi56b29tO1xuICB2YXIgdHJhbnNmb3JtID0gY3JlYXRlKCk7XG4gIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgW3Bhbi54LCBwYW4ueV0pO1xuICBzY2FsZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgW3pvb20sIHpvb21dKTtcbiAgdmFyIHByb2plY3Rpb24kMSA9IGNyZWF0ZSgpO1xuICBwcm9qZWN0aW9uKHByb2plY3Rpb24kMSwgd2lkdGgsIGhlaWdodCk7XG4gIHZhciBwcm9kdWN0ID0gY3JlYXRlKCk7XG4gIG11bHRpcGx5KHByb2R1Y3QsIHByb2plY3Rpb24kMSwgdHJhbnNmb3JtKTtcbiAgcmV0dXJuIHByb2R1Y3Q7XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0VHJhbnNmb3JtKHIsIGNvbnRleHQpIHtcbiAgdmFyIHdpZHRoID0gci5jYW52YXNXaWR0aDtcbiAgdmFyIGhlaWdodCA9IHIuY2FudmFzSGVpZ2h0O1xuICB2YXIgX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMiA9IGdldEVmZmVjdGl2ZVBhblpvb20ociksXG4gICAgcGFuID0gX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMi5wYW4sXG4gICAgem9vbSA9IF91dGlsJGdldEVmZmVjdGl2ZVBhbjIuem9vbTtcbiAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjb250ZXh0LnRyYW5zbGF0ZShwYW4ueCwgcGFuLnkpO1xuICBjb250ZXh0LnNjYWxlKHpvb20sIHpvb20pO1xufVxuZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJlY3RhbmdsZShyLCBvcHRpb25zKSB7XG4gIHIuZHJhd1NlbGVjdGlvblJlY3RhbmdsZShvcHRpb25zLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBzZXRDb250ZXh0VHJhbnNmb3JtKHIsIGNvbnRleHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRyYXdBeGVzKHIpIHtcbiAgLy8gZm9yIGRlYmdnaW5nXG4gIHZhciBjb250ZXh0ID0gci5kYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gIGNvbnRleHQuc2F2ZSgpO1xuICBzZXRDb250ZXh0VHJhbnNmb3JtKHIsIGNvbnRleHQpO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4zKSc7XG4gIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNvbnRleHQubW92ZVRvKC0xZTMsIDApO1xuICBjb250ZXh0LmxpbmVUbygxMDAwLCAwKTtcbiAgY29udGV4dC5zdHJva2UoKTtcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY29udGV4dC5tb3ZlVG8oMCwgLTFlMyk7XG4gIGNvbnRleHQubGluZVRvKDAsIDEwMDApO1xuICBjb250ZXh0LnN0cm9rZSgpO1xuICBjb250ZXh0LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdBdGxhc2VzKHIpIHtcbiAgLy8gRm9yIGRlYnVnZ2luZyB0aGUgYXRsYXNlcywgdGhpcyBkb2Vzbid0IHdvcmsgZm9yIEF0bGFzZXMgdGhhdCBhcmUgbG9ja2VkXG4gIHZhciBkcmF3ID0gZnVuY3Rpb24gZHJhdyhkcmF3aW5nLCBuYW1lLCByb3cpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IGRyYXdpbmcuYXRsYXNNYW5hZ2VyLmdldEF0bGFzQ29sbGVjdGlvbihuYW1lKTtcbiAgICB2YXIgY29udGV4dCA9IHIuZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgIHZhciBhdGxhc2VzID0gY29sbGVjdGlvbi5hdGxhc2VzO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdGxhc2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGF0bGFzID0gYXRsYXNlc1tfaV07XG4gICAgICB2YXIgY2FudmFzID0gYXRsYXMuY2FudmFzO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICB2YXIgdyA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICB2YXIgeCA9IHcgKiBfaTtcbiAgICAgICAgdmFyIHkgPSBjYW52YXMuaGVpZ2h0ICogcm93O1xuICAgICAgICB2YXIgc2NhbGUgPSAwLjQ7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgeCwgeSk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICBjb250ZXh0LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGkgPSAwO1xuICBkcmF3KHIuZHJhd2luZywgJ25vZGUnLCBpKyspO1xuICBkcmF3KHIuZHJhd2luZywgJ2xhYmVsJywgaSsrKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6LW9yZGVyIGluZGV4IG9mIGVsbWVudHMgdW5kZXIgb3IgdmVyeSBjbG9zZSB0byB0aGUgbW91c2UgY3Vyc29yIHBvaW50LlxuICogQXJndW1lbnRzIGFyZSBpbiBtb2RlbCBjb29yZGluYXRlcy5cbiAqICh4MSwgeTEpIGlzIHRvcCBsZWZ0IGNvcm5lclxuICogKHgyLCB5MikgaXMgYm90dG9tIHJpZ2h0IGNvcm5lciAob3B0aW9uYWwpXG4gKiBSZXR1cm5zIGEgU2V0IG9mIGluZGV4ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFBpY2tpbmdJbmRleGVzKHIsIG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICB2YXIgeCwgeSwgdywgaDtcbiAgdmFyIF91dGlsJGdldEVmZmVjdGl2ZVBhbjMgPSBnZXRFZmZlY3RpdmVQYW5ab29tKHIpLFxuICAgIHBhbiA9IF91dGlsJGdldEVmZmVjdGl2ZVBhbjMucGFuLFxuICAgIHpvb20gPSBfdXRpbCRnZXRFZmZlY3RpdmVQYW4zLnpvb207XG4gIHtcbiAgICB2YXIgX3V0aWwkbW9kZWxUb1JlbmRlcmVkID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ociwgcGFuLCB6b29tLCBtWDEsIG1ZMSksXG4gICAgICBfdXRpbCRtb2RlbFRvUmVuZGVyZWQyID0gX3NsaWNlZFRvQXJyYXkoX3V0aWwkbW9kZWxUb1JlbmRlcmVkLCAyKSxcbiAgICAgIGNYMSA9IF91dGlsJG1vZGVsVG9SZW5kZXJlZDJbMF0sXG4gICAgICBjWTEgPSBfdXRpbCRtb2RlbFRvUmVuZGVyZWQyWzFdO1xuICAgIHZhciB0ID0gNjsgLy8gc2hvdWxkIGJlIGV2ZW5cbiAgICB4ID0gY1gxIC0gdCAvIDI7XG4gICAgeSA9IGNZMSAtIHQgLyAyO1xuICAgIHcgPSB0O1xuICAgIGggPSB0O1xuICB9XG4gIGlmICh3ID09PSAwIHx8IGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGdsID0gci5kYXRhLmNvbnRleHRzW3IuV0VCR0xdO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHIucGlja2luZ0ZyYW1lQnVmZmVyKTtcbiAgaWYgKHIucGlja2luZ0ZyYW1lQnVmZmVyLm5lZWRzRHJhdykge1xuICAgIC8vIERyYXcgZWxlbWVudCB6LWluZGV4ZXMgdG8gdGhlIHBpY2tpbmcgZnJhbWVidWZmZXJcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICAgIHJlbmRlcldlYmdsKHIsIG51bGwsIFJFTkRFUl9UQVJHRVQuUElDS0lORyk7XG4gICAgci5waWNraW5nRnJhbWVCdWZmZXIubmVlZHNEcmF3ID0gZmFsc2U7XG4gIH1cbiAgdmFyIG4gPSB3ICogaDsgLy8gbnVtYmVyIG9mIHBpeGVscyB0byByZWFkXG4gIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobiAqIDQpOyAvLyA0IGJ5dGVzIHBlciBwaXhlbFxuICBnbC5yZWFkUGl4ZWxzKHgsIHksIHcsIGgsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICB2YXIgaW5kZXhlcyA9IG5ldyBTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgcGl4ZWwgPSBkYXRhLnNsaWNlKGkgKiA0LCBpICogNCArIDQpO1xuICAgIHZhciBpbmRleCA9IHZlYzRUb0luZGV4KHBpeGVsKSAtIDE7IC8vIFRoZSBmcmFtZWJ1ZmZlciBpcyBjbGVhcmVkIHdpdGggMHMsIHNvIHotaW5kZXhlcyBhcmUgb2Zmc2V0IGJ5IDFcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaW5kZXhlcy5hZGQoaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhlcztcbn1cblxuLyoqXG4gKiBDeS5qczogbW9kZWwgY29vcmRpbmF0ZSB5IGF4aXMgZ29lcyBkb3duXG4gKi9cbmZ1bmN0aW9uIGZpbmROZWFyZXN0RWxlbWVudHNXZWJnbChyLCB4LCB5KSB7XG4gIC8vIG1vZGVsIGNvb3JkaW5hdGVzXG4gIHZhciBpbmRleGVzID0gZ2V0UGlja2luZ0luZGV4ZXMociwgeCwgeSk7XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICB2YXIgbm9kZSwgZWRnZTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGluZGV4ZXMpLFxuICAgIF9zdGVwO1xuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgaW5kZXggPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2luZGV4XTtcbiAgICAgIGlmICghbm9kZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgbm9kZSA9IGVsZTtcbiAgICAgIH1cbiAgICAgIGlmICghZWRnZSAmJiBlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgZWRnZSA9IGVsZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICYmIGVkZ2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgcmV0dXJuIFtub2RlLCBlZGdlXS5maWx0ZXIoQm9vbGVhbik7XG59XG5cbi8qKlxuICogRHJhdyBvbmUgbm9kZSBvciBlZGdlLiBcbiAqL1xuZnVuY3Rpb24gZHJhd0VsZShyLCBpbmRleCwgZWxlKSB7XG4gIHZhciBkcmF3aW5nID0gci5kcmF3aW5nO1xuICBpbmRleCArPSAxOyAvLyAwIGlzIHVzZWQgdG8gY2xlYXIgdGhlIGJhY2tncm91bmQsIG5lZWQgdG8gb2Zmc2V0IGFsbCB6LWluZGV4ZXMgYnkgb25lXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICBkcmF3aW5nLmRyYXdOb2RlKGVsZSwgaW5kZXgsICdub2RlLXVuZGVybGF5Jyk7XG4gICAgZHJhd2luZy5kcmF3Tm9kZShlbGUsIGluZGV4LCAnbm9kZS1ib2R5Jyk7XG4gICAgZHJhd2luZy5kcmF3VGV4dHVyZShlbGUsIGluZGV4LCAnbGFiZWwnKTtcbiAgICBkcmF3aW5nLmRyYXdOb2RlKGVsZSwgaW5kZXgsICdub2RlLW92ZXJsYXknKTtcbiAgfSBlbHNlIHtcbiAgICBkcmF3aW5nLmRyYXdFZGdlTGluZShlbGUsIGluZGV4KTtcbiAgICBkcmF3aW5nLmRyYXdFZGdlQXJyb3coZWxlLCBpbmRleCwgJ3NvdXJjZScpO1xuICAgIGRyYXdpbmcuZHJhd0VkZ2VBcnJvdyhlbGUsIGluZGV4LCAndGFyZ2V0Jyk7XG4gICAgZHJhd2luZy5kcmF3VGV4dHVyZShlbGUsIGluZGV4LCAnbGFiZWwnKTtcbiAgICBkcmF3aW5nLmRyYXdUZXh0dXJlKGVsZSwgaW5kZXgsICdlZGdlLXNvdXJjZS1sYWJlbCcpO1xuICAgIGRyYXdpbmcuZHJhd1RleHR1cmUoZWxlLCBpbmRleCwgJ2VkZ2UtdGFyZ2V0LWxhYmVsJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5kZXIgb25lIGZyYW1lLlxuICovXG5mdW5jdGlvbiByZW5kZXJXZWJnbChyLCBvcHRpb25zLCByZW5kZXJUYXJnZXQpIHtcbiAgdmFyIHN0YXJ0O1xuICBpZiAoci53ZWJnbERlYnVnKSB7XG4gICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG4gIHZhciBkcmF3aW5nID0gci5kcmF3aW5nO1xuICB2YXIgZWxlQ291bnQgPSAwO1xuICBpZiAocmVuZGVyVGFyZ2V0LnNjcmVlbikge1xuICAgIGlmIChyLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5TRUxFQ1RfQk9YXSkge1xuICAgICAgZHJhd1NlbGVjdGlvblJlY3RhbmdsZShyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZWUgZHJhd2luZy1lbGVtZW50cy5qcyBkcmF3Q2FjaGVkRWxlbWVudCgpXG4gIGlmIChyLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5OT0RFXSB8fCByZW5kZXJUYXJnZXQucGlja2luZykge1xuICAgIHZhciBnbCA9IHIuZGF0YS5jb250ZXh0c1tyLldFQkdMXTtcbiAgICBpZiAocmVuZGVyVGFyZ2V0LnNjcmVlbikge1xuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTsgLy8gYmFja2dyb3VuZCBjb2xvclxuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTsgLy8gZW5hYmxlIGFscGhhIGJsZW5kaW5nIG9mIGNvbG9yc1xuICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7IC8vIHdlYmdsIGNvbG9ycyB1c2UgcHJlbXVsdGlwbGllZCBhbHBoYVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTsgLy8gZG9uJ3QgYmxlbmQgei1vcmRlciBpbmRleCB2YWx1ZXMhIHRoZXkgYXJlIG5vdCBjb2xvcnNcbiAgICB9XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgdmFyIHBhblpvb21NYXRyaXggPSBjcmVhdGVQYW5ab29tTWF0cml4KHIpO1xuICAgIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgIGVsZUNvdW50ID0gZWxlcy5sZW5ndGg7XG4gICAgZHJhd2luZy5zdGFydEZyYW1lKHBhblpvb21NYXRyaXgsIHJlbmRlclRhcmdldCk7XG4gICAgaWYgKHJlbmRlclRhcmdldC5zY3JlZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5ub25kcmFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRyYXdFbGUociwgaSwgZWxlcy5ub25kcmFnW2ldKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMuZHJhZy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGRyYXdFbGUociwgX2kyLCBlbGVzLmRyYWdbX2kyXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZW5kZXJUYXJnZXQucGlja2luZykge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWxlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIGRyYXdFbGUociwgX2kzLCBlbGVzW19pM10pO1xuICAgICAgfVxuICAgIH1cbiAgICBkcmF3aW5nLmVuZEZyYW1lKCk7XG4gICAgaWYgKHJlbmRlclRhcmdldC5zY3JlZW4gJiYgci53ZWJnbERlYnVnU2hvd0F0bGFzZXMpIHtcbiAgICAgIGRyYXdBeGVzKHIpO1xuICAgICAgZHJhd0F0bGFzZXMocik7XG4gICAgfVxuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgfVxuICBpZiAoci53ZWJnbERlYnVnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHZhciBjb21wYWN0ID0gZmFsc2U7XG4gICAgdmFyIHRpbWUgPSBNYXRoLmNlaWwoZW5kIC0gc3RhcnQpO1xuICAgIHZhciBkZWJ1Z0luZm8gPSBkcmF3aW5nLmdldERlYnVnSW5mbygpO1xuICAgIHZhciByZXBvcnQgPSBbXCJcIi5jb25jYXQoZWxlQ291bnQsIFwiIGVsZW1lbnRzXCIpLCBcIlwiLmNvbmNhdChkZWJ1Z0luZm8udG90YWxJbnN0YW5jZXMsIFwiIGluc3RhbmNlc1wiKSwgXCJcIi5jb25jYXQoZGVidWdJbmZvLmJhdGNoQ291bnQsIFwiIGJhdGNoZXNcIiksIFwiXCIuY29uY2F0KGRlYnVnSW5mby50b3RhbEF0bGFzZXMsIFwiIGF0bGFzZXNcIiksIFwiXCIuY29uY2F0KGRlYnVnSW5mby53cmFwcGVkQ291bnQsIFwiIHdyYXBwZWQgdGV4dHVyZXNcIiksIFwiXCIuY29uY2F0KGRlYnVnSW5mby5zaW1wbGVDb3VudCwgXCIgc2ltcGxlIHNoYXBlc1wiKV0uam9pbignLCAnKTtcbiAgICBpZiAoY29tcGFjdCkge1xuICAgICAgY29uc29sZS5sb2coXCJXZWJHTCAoXCIuY29uY2F0KHJlbmRlclRhcmdldC5uYW1lLCBcIikgLSB0aW1lIFwiKS5jb25jYXQodGltZSwgXCJtcywgXCIpLmNvbmNhdChyZXBvcnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJXZWJHTCAoXCIuY29uY2F0KHJlbmRlclRhcmdldC5uYW1lLCBcIikgLSBmcmFtZSB0aW1lIFwiKS5jb25jYXQodGltZSwgXCJtc1wiKSk7XG4gICAgICBjb25zb2xlLmxvZygnVG90YWxzOicpO1xuICAgICAgY29uc29sZS5sb2coXCIgIFwiLmNvbmNhdChyZXBvcnQpKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUZXh0dXJlIEF0bGFzZXMgVXNlZDonKTtcbiAgICAgIHZhciBhdGxhc0luZm8gPSBkZWJ1Z0luZm8uYXRsYXNJbmZvO1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhdGxhc0luZm8pLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpbmZvID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiICBcIi5jb25jYXQoaW5mby50eXBlLCBcIjogXCIpLmNvbmNhdChpbmZvLmtleUNvdW50LCBcIiBrZXlzLCBcIikuY29uY2F0KGluZm8uYXRsYXNDb3VudCwgXCIgYXRsYXNlc1wiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJycpO1xuICAgIH1cbiAgfVxuICBpZiAoci5kYXRhLmdjKSB7XG4gICAgY29uc29sZS5sb2coJ0dhcmJhZ2UgQ29sbGVjdCEnKTtcbiAgICByLmRhdGEuZ2MgPSBmYWxzZTtcbiAgICBkcmF3aW5nLmdjKCk7XG4gIH1cbn1cblxudmFyIENScCQzID0ge307XG5cbi8vIEBPIFBvbHlnb24gZHJhd2luZ1xuQ1JwJDMuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cbiAgY29udGV4dC5tb3ZlVG8oeCArIGhhbGZXICogcG9pbnRzWzBdLCB5ICsgaGFsZkggKiBwb2ludHNbMV0pO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSk7XG4gIH1cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5DUnAkMy5kcmF3Um91bmRQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpIHtcbiAgY29ybmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb3JuZXIpIHtcbiAgICByZXR1cm4gZHJhd1ByZXBhcmVkUm91bmRDb3JuZXIoY29udGV4dCwgY29ybmVyKTtcbiAgfSk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuQ1JwJDMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gcmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IE1hdGgubWluKHJhZGl1cywgaGFsZkhlaWdodCwgaGFsZldpZHRoKTtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAvLyBBcmMgZnJvbSBtaWRkbGUgdG9wIHRvIHJpZ2h0IHNpZGVcbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgLy8gQXJjIGZyb20gcmlnaHQgc2lkZSB0byBib3R0b21cbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgLy8gQXJjIGZyb20gbGVmdCBzaWRlIHRvIHRvcEJvcmRlclxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgLy8gSm9pbiBsaW5lXG4gIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5DUnAkMy5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSByYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogcmFkaXVzO1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSk7XG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5DUnAkMy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyTGVuZ3RoID0gY29ybmVycyA9PT0gJ2F1dG8nID8gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCkgOiBjb3JuZXJzO1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGNvbnRleHQubW92ZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCAtIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCAtIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoICsgY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcbkNScCQzLmRyYXdCYXJyZWxQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgeEJlZ2luID0geCAtIGhhbGZXaWR0aDtcbiAgdmFyIHhFbmQgPSB4ICsgaGFsZldpZHRoO1xuICB2YXIgeUJlZ2luID0geSAtIGhhbGZIZWlnaHQ7XG4gIHZhciB5RW5kID0geSArIGhhbGZIZWlnaHQ7XG4gIHZhciBiYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgd09mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICB2YXIgaE9mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgdmFyIGN0cmxQdFhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3T2Zmc2V0O1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG4gIGNvbnRleHQubW92ZVRvKHhCZWdpbiwgeUJlZ2luICsgaE9mZnNldCk7XG4gIGNvbnRleHQubGluZVRvKHhCZWdpbiwgeUVuZCAtIGhPZmZzZXQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luICsgd09mZnNldCwgeUVuZCk7XG4gIGNvbnRleHQubGluZVRvKHhFbmQgLSB3T2Zmc2V0LCB5RW5kKTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4RW5kLCB5RW5kIC0gaE9mZnNldCk7XG4gIGNvbnRleHQubGluZVRvKHhFbmQsIHlCZWdpbiArIGhPZmZzZXQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEVuZCAtIHdPZmZzZXQsIHlCZWdpbik7XG4gIGNvbnRleHQubGluZVRvKHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbik7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiwgeUJlZ2luICsgaE9mZnNldCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xudmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbnZhciBjb3MwID0gTWF0aC5jb3MoMCk7XG52YXIgc2luID0ge307XG52YXIgY29zID0ge307XG52YXIgZWxsaXBzZVN0ZXBTaXplID0gTWF0aC5QSSAvIDQwO1xuZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbn1cbkNScCQzLmRyYXdFbGxpcHNlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cbiAgaWYgKGNvbnRleHQuZWxsaXBzZSkge1xuICAgIGNvbnRleHQuZWxsaXBzZShjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgeFBvcywgeVBvcztcbiAgICB2YXIgcncgPSB3aWR0aCAvIDI7XG4gICAgdmFyIHJoID0gaGVpZ2h0IC8gMjtcbiAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICAgIHhQb3MgPSBjZW50ZXJYIC0gcncgKiBzaW5baV0gKiBzaW4wICsgcncgKiBjb3NbaV0gKiBjb3MwO1xuICAgICAgeVBvcyA9IGNlbnRlclkgKyByaCAqIGNvc1tpXSAqIHNpbjAgKyByaCAqIHNpbltpXSAqIGNvczA7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuLyogZ2xvYmFsIGF0b2IsIEFycmF5QnVmZmVyLCBVaW50OEFycmF5LCBCbG9iICovXG5cbnZhciBDUnAkMiA9IHt9O1xuQ1JwJDIuY3JlYXRlQnVmZmVyID0gZnVuY3Rpb24gKHcsIGgpIHtcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIGJ1ZmZlci53aWR0aCA9IHc7XG4gIGJ1ZmZlci5oZWlnaHQgPSBoO1xuICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xufTtcbkNScCQyLmJ1ZmZlckNhbnZhc0ltYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgdmFyIGJiID0gZWxlcy5ib3VuZGluZ0JveCgpO1xuICB2YXIgY3RyUmVjdCA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIudykgOiBjdHJSZWN0WzJdO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLmgpIDogY3RyUmVjdFszXTtcbiAgdmFyIHNwZWNkTWF4RGltcyA9IG51bWJlciQxKG9wdGlvbnMubWF4V2lkdGgpIHx8IG51bWJlciQxKG9wdGlvbnMubWF4SGVpZ2h0KTtcbiAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIHNjYWxlID0gMTtcbiAgaWYgKG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICB9IGVsc2UgaWYgKHNwZWNkTWF4RGltcykge1xuICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG4gICAgaWYgKG51bWJlciQxKG9wdGlvbnMubWF4V2lkdGgpKSB7XG4gICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICB9XG4gICAgaWYgKG51bWJlciQxKG9wdGlvbnMubWF4SGVpZ2h0KSkge1xuICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICB9XG4gICAgc2NhbGUgPSBNYXRoLm1pbihtYXhTY2FsZVcsIG1heFNjYWxlSCk7XG4gICAgd2lkdGggKj0gc2NhbGU7XG4gICAgaGVpZ2h0ICo9IHNjYWxlO1xuICB9XG4gIGlmICghc3BlY2RNYXhEaW1zKSB7XG4gICAgd2lkdGggKj0gcHhSYXRpbztcbiAgICBoZWlnaHQgKj0gcHhSYXRpbztcbiAgICBzY2FsZSAqPSBweFJhdGlvO1xuICB9XG4gIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIHZhciBidWZmQ3h0ID0gYnVmZkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcbiAgICBidWZmQ3h0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgdmFyIHpzb3J0ZWRFbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgIGlmIChvcHRpb25zLmZ1bGwpIHtcbiAgICAgIC8vIGRyYXcgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBncmFwaFxuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLWJiLngxICogc2NhbGUsIC1iYi55MSAqIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoYmIueDEgKiBzY2FsZSwgYmIueTEgKiBzY2FsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRyYXcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgICB4OiBwYW4ueCAqIHNjYWxlLFxuICAgICAgICB5OiBwYW4ueSAqIHNjYWxlXG4gICAgICB9O1xuICAgICAgc2NhbGUgKj0gY3kuem9vbSgpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUodHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSk7XG4gICAgICBidWZmQ3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICB0aGlzLmRyYXdFbGVtZW50cyhidWZmQ3h0LCB6c29ydGVkRWxlcyk7XG4gICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKC10cmFuc2xhdGlvbi54LCAtdHJhbnNsYXRpb24ueSk7XG4gICAgfVxuXG4gICAgLy8gbmVlZCB0byBmaWxsIGJnIGF0IGVuZCBsaWtlIHRoaXMgaW4gb3JkZXIgdG8gZmlsbCBjbGVhcmVkIHRyYW5zcGFyZW50IHBpeGVscyBpbiBqcGdzXG4gICAgaWYgKG9wdGlvbnMuYmcpIHtcbiAgICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgYnVmZkN4dC5maWxsU3R5bGUgPSBvcHRpb25zLmJnO1xuICAgICAgYnVmZkN4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYnVmZkN4dC5maWxsKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmQ2FudmFzO1xufTtcbmZ1bmN0aW9uIGI2NFRvQmxvYihiNjQsIG1pbWVUeXBlKSB7XG4gIHZhciBieXRlcyA9IGF0b2IoYjY0KTtcbiAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgdmFyIGJ1ZmZVaW50OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZlVpbnQ4W2ldID0gYnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZdLCB7XG4gICAgdHlwZTogbWltZVR5cGVcbiAgfSk7XG59XG5mdW5jdGlvbiBiNjRVcmlUb0I2NChiNjR1cmkpIHtcbiAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuICByZXR1cm4gYjY0dXJpLnN1YnN0cihpICsgMSk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3B0aW9ucywgY2FudmFzLCBtaW1lVHlwZSkge1xuICB2YXIgZ2V0QjY0VXJpID0gZnVuY3Rpb24gZ2V0QjY0VXJpKCkge1xuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICB9O1xuICBzd2l0Y2ggKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgY2FzZSAnYmxvYi1wcm9taXNlJzpcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICBpZiAoYmxvYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdgY2FudmFzLnRvQmxvYigpYCBzZW50IGEgbnVsbCB2YWx1ZSBpbiBpdHMgY2FsbGJhY2snKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBjYXNlICdibG9iJzpcbiAgICAgIHJldHVybiBiNjRUb0Jsb2IoYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpLCBtaW1lVHlwZSk7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSk7XG4gICAgY2FzZSAnYmFzZTY0dXJpJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdldEI2NFVyaSgpO1xuICB9XG59XG5DUnAkMi5wbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gb3V0cHV0KG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2Uob3B0aW9ucyksICdpbWFnZS9wbmcnKTtcbn07XG5DUnAkMi5qcGcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gb3V0cHV0KG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2Uob3B0aW9ucyksICdpbWFnZS9qcGVnJyk7XG59O1xuXG52YXIgQ1JwJDEgPSB7fTtcbkNScCQxLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2VsbGlwc2UnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0VsbGlwc2VQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG4gICAgY2FzZSAncm91bmQtcG9seWdvbic6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRQb2x5Z29uUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpO1xuICAgIGNhc2UgJ3JvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdyb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJzKTtcbiAgICBjYXNlICdjdXRyZWN0YW5nbGUnOlxuICAgIGNhc2UgJ2N1dC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0N1dFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzLCBjb3JuZXJzKTtcbiAgICBjYXNlICdib3R0b21yb3VuZHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lcnMpO1xuICAgIGNhc2UgJ2JhcnJlbCc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3QmFycmVsUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufTtcblxudmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG52YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuQ1JwLkNBTlZBU19MQVlFUlMgPSAzO1xuLy9cbkNScC5TRUxFQ1RfQk9YID0gMDtcbkNScC5EUkFHID0gMTtcbkNScC5OT0RFID0gMjtcbkNScC5XRUJHTCA9IDM7XG5DUnAuQ0FOVkFTX1RZUEVTID0gWycyZCcsICcyZCcsICcyZCcsICd3ZWJnbDInXTtcbkNScC5CVUZGRVJfQ09VTlQgPSAzO1xuLy9cbkNScC5URVhUVVJFX0JVRkZFUiA9IDA7XG5DUnAuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSA9IDE7XG5DUnAuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG4gIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICBDUnAuQ0FOVkFTX0xBWUVSUyA9IHIuQ0FOVkFTX0xBWUVSUyA9IDQ7XG4gICAgY29uc29sZS5sb2coJ3dlYmdsIHJlbmRlcmluZyBlbmFibGVkJyk7XG4gIH1cbiAgci5kYXRhID0ge1xuICAgIGNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpLFxuICAgIGNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpLFxuICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpLFxuICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwLkJVRkZFUl9DT1VOVCksXG4gICAgYnVmZmVyQ29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUylcbiAgfTtcbiAgdmFyIHRhcEhsT2ZmQXR0ciA9ICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InO1xuICB2YXIgdGFwSGxPZmZTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIHZhciBjb250YWluZXJTdHlsZSA9IHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGU7XG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5jYW52YXNDb250YWluZXIpO1xuICBjb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gIHZhciBzdHlsZU1hcCA9IHtcbiAgICAnLXdlYmtpdC11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAnLW1vei11c2VyLXNlbGVjdCc6ICctbW96LW5vbmUnLFxuICAgICd1c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3JnYmEoMCwwLDAsMCknLFxuICAgICdvdXRsaW5lLXN0eWxlJzogJ25vbmUnXG4gIH07XG4gIGlmIChtcygpKSB7XG4gICAgc3R5bGVNYXBbJy1tcy10b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgICBzdHlsZU1hcFsndG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBDUnAuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgdmFyIGNhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIHR5cGUgPSBDUnAuQ0FOVkFTX1RZUEVTW2ldO1xuICAgIHIuZGF0YS5jb250ZXh0c1tpXSA9IGNhbnZhcy5nZXRDb250ZXh0KHR5cGUpO1xuICAgIGlmICghci5kYXRhLmNvbnRleHRzW2ldKSB7XG4gICAgICBlcnJvcignQ291bGQgbm90IGNyZWF0ZSBjYW52YXMgb2YgdHlwZSAnICsgdHlwZSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHN0eWxlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBjYW52YXMuc3R5bGVba10gPSBzdHlsZU1hcFtrXTtcbiAgICB9KTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSk7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDUnAuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgfVxuICByLmRhdGEudG9wQ2FudmFzID0gci5kYXRhLmNhbnZhc2VzWzBdO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwLk5PREVdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuTk9ERSArICctbm9kZScpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwLlNFTEVDVF9CT1hdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuU0VMRUNUX0JPWCArICctc2VsZWN0Ym94Jyk7XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5EUkFHICsgJy1kcmFnJyk7XG4gIGlmIChyLmRhdGEuY2FudmFzZXNbQ1JwLldFQkdMXSkge1xuICAgIHIuZGF0YS5jYW52YXNlc1tDUnAuV0VCR0xdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuV0VCR0wgKyAnLXdlYmdsJyk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBDUnAuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHIuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdidWZmZXInICsgaSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgLy9yLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSk7XG4gIH1cbiAgci5wYXRoc0VuYWJsZWQgPSB0cnVlO1xuICB2YXIgZW1wdHlCYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICB2YXIgZ2V0Qm94Q2VudGVyID0gZnVuY3Rpb24gZ2V0Qm94Q2VudGVyKGJiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IChiYi54MSArIGJiLngyKSAvIDIsXG4gICAgICB5OiAoYmIueTEgKyBiYi55MikgLyAyXG4gICAgfTtcbiAgfTtcbiAgdmFyIGdldENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIGdldENlbnRlck9mZnNldChiYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAtYmIudyAvIDIsXG4gICAgICB5OiAtYmIuaCAvIDJcbiAgICB9O1xuICB9O1xuICB2YXIgYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQgPSBmdW5jdGlvbiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZChlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGVbMF0uX3ByaXZhdGU7XG4gICAgdmFyIHNhbWUgPSBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID09PSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgIHJldHVybiAhc2FtZTtcbiAgfTtcbiAgdmFyIGdldFN0eWxlS2V5ID0gZnVuY3Rpb24gZ2V0U3R5bGVLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ub2RlS2V5O1xuICB9O1xuICB2YXIgZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsU3R5bGVLZXk7XG4gIH07XG4gIHZhciBnZXRTb3VyY2VMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuc291cmNlTGFiZWxTdHlsZUtleTtcbiAgfTtcbiAgdmFyIGdldFRhcmdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS50YXJnZXRMYWJlbFN0eWxlS2V5O1xuICB9O1xuICB2YXIgZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiBkcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgZmFsc2UsIGZhbHNlLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcbiAgdmFyIGRyYXdMYWJlbCA9IGZ1bmN0aW9uIGRyYXdMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdtYWluJywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG4gIHZhciBkcmF3U291cmNlTGFiZWwgPSBmdW5jdGlvbiBkcmF3U291cmNlTGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnc291cmNlJywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG4gIHZhciBkcmF3VGFyZ2V0TGFiZWwgPSBmdW5jdGlvbiBkcmF3VGFyZ2V0TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAndGFyZ2V0JywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG4gIHZhciBnZXRFbGVtZW50Qm94ID0gZnVuY3Rpb24gZ2V0RWxlbWVudEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmJvZHlCb3VuZHM7XG4gIH07XG4gIHZhciBnZXRMYWJlbEJveCA9IGZ1bmN0aW9uIGdldExhYmVsQm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMubWFpbiB8fCBlbXB0eUJiO1xuICB9O1xuICB2YXIgZ2V0U291cmNlTGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnNvdXJjZSB8fCBlbXB0eUJiO1xuICB9O1xuICB2YXIgZ2V0VGFyZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnRhcmdldCB8fCBlbXB0eUJiO1xuICB9O1xuICB2YXIgaXNMYWJlbFZpc2libGVBdFNjYWxlID0gZnVuY3Rpb24gaXNMYWJlbFZpc2libGVBdFNjYWxlKGVsZSwgc2NhbGVkTGFiZWxTaG93bikge1xuICAgIHJldHVybiBzY2FsZWRMYWJlbFNob3duO1xuICB9O1xuICB2YXIgZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRFbGVtZW50Um90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Qm94Q2VudGVyKGdldEVsZW1lbnRCb3goZWxlKSk7XG4gIH07XG4gIHZhciBhZGRUZXh0TWFyZ2luID0gZnVuY3Rpb24gYWRkVGV4dE1hcmdpbihwcmVmaXgsIHB0LCBlbGUpIHtcbiAgICB2YXIgcHJlID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHB0LnggKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZSxcbiAgICAgIHk6IHB0LnkgKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZVxuICAgIH07XG4gIH07XG4gIHZhciBnZXRSc1B0ID0gZnVuY3Rpb24gZ2V0UnNQdChlbGUsIHgsIHkpIHtcbiAgICB2YXIgcnMgPSBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJzW3hdLFxuICAgICAgeTogcnNbeV1cbiAgICB9O1xuICB9O1xuICB2YXIgZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCcnLCBnZXRSc1B0KGVsZSwgJ2xhYmVsWCcsICdsYWJlbFknKSwgZWxlKTtcbiAgfTtcbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignc291cmNlJywgZ2V0UnNQdChlbGUsICdzb3VyY2VMYWJlbFgnLCAnc291cmNlTGFiZWxZJyksIGVsZSk7XG4gIH07XG4gIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3RhcmdldCcsIGdldFJzUHQoZWxlLCAndGFyZ2V0TGFiZWxYJywgJ3RhcmdldExhYmVsWScpLCBlbGUpO1xuICB9O1xuICB2YXIgZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0RWxlbWVudEJveChlbGUpKTtcbiAgfTtcbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0U291cmNlTGFiZWxCb3goZWxlKSk7XG4gIH07XG4gIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFRhcmdldExhYmVsQm94KGVsZSkpO1xuICB9O1xuICB2YXIgZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgdmFyIGJiID0gZ2V0TGFiZWxCb3goZWxlKTtcbiAgICB2YXIgcCA9IGdldENlbnRlck9mZnNldChnZXRMYWJlbEJveChlbGUpKTtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcC54ID0gLWJiLncgLSAoYmIubGVmdFBhZCB8fCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHAueCA9IC0oYmIucmlnaHRQYWQgfHwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBwLnkgPSAtYmIuaCAtIChiYi50b3BQYWQgfHwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcC55ID0gLShiYi5ib3RQYWQgfHwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9O1xuICB2YXIgZWxlVHhyQ2FjaGUgPSByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRTdHlsZUtleSxcbiAgICBkb2VzRWxlSW52YWxpZGF0ZUtleTogYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQsXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdFbGVtZW50LFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRFbGVtZW50Qm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldEVsZW1lbnRSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQsXG4gICAgYWxsb3dFZGdlVHhyQ2FjaGluZzogZmFsc2UsXG4gICAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiBmYWxzZVxuICB9KTtcbiAgdmFyIGxibFR4ckNhY2hlID0gci5kYXRhLmxibFR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0TGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0TGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgc2xiVHhyQ2FjaGUgPSByLmRhdGEuc2xiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRTb3VyY2VMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd1NvdXJjZUxhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRTb3VyY2VMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciB0bGJUeHJDYWNoZSA9IHIuZGF0YS50bGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFRhcmdldExhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3VGFyZ2V0TGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldFRhcmdldExhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIGx5clR4ckNhY2hlID0gci5kYXRhLmx5clR4ckNhY2hlID0gbmV3IExheWVyZWRUZXh0dXJlQ2FjaGUocik7XG4gIHIub25VcGRhdGVFbGVDYWxjcyhmdW5jdGlvbiBpbnZhbGlkYXRlVGV4dHVyZUNhY2hlcyh3aWxsRHJhdywgZWxlcykge1xuICAgIC8vIGVhY2ggY2FjaGUgc2hvdWxkIGNoZWNrIGZvciBzdWIta2V5IGRpZmYgdG8gc2VlIHRoYXQgdGhlIHVwZGF0ZSBhZmZlY3RzIHRoYXQgY2FjaGUgcGFydGljdWxhcmx5XG4gICAgZWxlVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIGxibFR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICBzbGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgdGxiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuXG4gICAgLy8gYW55IGNoYW5nZSBpbnZhbGlkYXRlcyB0aGUgbGF5ZXJzXG4gICAgbHlyVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuXG4gICAgLy8gdXBkYXRlIHRoZSBvbGQgYmcgdGltZXN0YW1wIHNvIGRpZmZzIGNhbiBiZSBkb25lIGluIHRoZSBlbGUgdHhyIGNhY2hlc1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9wID0gZWxlc1tfaV0uX3ByaXZhdGU7XG4gICAgICBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICB9XG4gIH0pO1xuICB2YXIgcmVmaW5lSW5MYXllcnMgPSBmdW5jdGlvbiByZWZpbmVJbkxheWVycyhyZXFzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBseXJUeHJDYWNoZS5lbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQocmVxc1tpXS5lbGUpO1xuICAgIH1cbiAgfTtcbiAgZWxlVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgbGJsVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgc2xiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgdGxiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICByLmluaXRXZWJnbChvcHRpb25zLCB7XG4gICAgICBnZXRTdHlsZUtleTogZ2V0U3R5bGVLZXksXG4gICAgICBnZXRMYWJlbEtleTogZ2V0TGFiZWxLZXksXG4gICAgICBnZXRTb3VyY2VMYWJlbEtleTogZ2V0U291cmNlTGFiZWxLZXksXG4gICAgICBnZXRUYXJnZXRMYWJlbEtleTogZ2V0VGFyZ2V0TGFiZWxLZXksXG4gICAgICBkcmF3RWxlbWVudDogZHJhd0VsZW1lbnQsXG4gICAgICBkcmF3TGFiZWw6IGRyYXdMYWJlbCxcbiAgICAgIGRyYXdTb3VyY2VMYWJlbDogZHJhd1NvdXJjZUxhYmVsLFxuICAgICAgZHJhd1RhcmdldExhYmVsOiBkcmF3VGFyZ2V0TGFiZWwsXG4gICAgICBnZXRFbGVtZW50Qm94OiBnZXRFbGVtZW50Qm94LFxuICAgICAgZ2V0TGFiZWxCb3g6IGdldExhYmVsQm94LFxuICAgICAgZ2V0U291cmNlTGFiZWxCb3g6IGdldFNvdXJjZUxhYmVsQm94LFxuICAgICAgZ2V0VGFyZ2V0TGFiZWxCb3g6IGdldFRhcmdldExhYmVsQm94LFxuICAgICAgZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQ6IGdldEVsZW1lbnRSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0OiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQsXG4gICAgICBnZXRMYWJlbFJvdGF0aW9uUG9pbnQ6IGdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICAgIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludDogZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0OiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldDogZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICAgIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQ6IGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXRcbiAgICB9KTtcbiAgfVxufVxuQ1JwLnJlZHJhd0hpbnQgPSBmdW5jdGlvbiAoZ3JvdXAsIGJvb2wpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBzd2l0Y2ggKGdyb3VwKSB7XG4gICAgY2FzZSAnZWxlcyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLk5PREVdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RyYWcnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5EUkFHXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5TRUxFQ1RfQk9YXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdnYyc6XG4gICAgICByLmRhdGEuZ2MgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIHdoZXRoZXIgdG8gdXNlIFBhdGgyRCBjYWNoaW5nIGZvciBkcmF3aW5nXG52YXIgcGF0aHNJbXBsZCA9IHR5cGVvZiBQYXRoMkQgIT09ICd1bmRlZmluZWQnO1xuQ1JwLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cbiAgdGhpcy5wYXRoc0VuYWJsZWQgPSBvbiA/IHRydWUgOiBmYWxzZTtcbn07XG5DUnAudXNlUGF0aHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwYXRoc0ltcGxkICYmIHRoaXMucGF0aHNFbmFibGVkO1xufTtcbkNScC5zZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCwgYm9vbCkge1xuICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICB9XG59O1xuQ1JwLmdldEltZ1Ntb290aGluZyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICB9XG59O1xuQ1JwLm1ha2VPZmZzY3JlZW5DYW52YXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICB2YXIgY2FudmFzO1xuICBpZiAoKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihPZmZzY3JlZW5DYW52YXMpKSAhPT0gKFwidW5kZWZpbmVkXCIgKSkge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHRoaXMuY3kud2luZG93KCk7XG4gICAgdmFyIGRvY3VtZW50ID0gY29udGFpbmVyV2luZG93LmRvY3VtZW50O1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICByZXR1cm4gY2FudmFzO1xufTtcbltDUnAkYiwgQ1JwJGEsIENScCQ5LCBDUnAkOCwgQ1JwJDcsIENScCQ2LCBDUnAkNSwgQ1JwJDQsIENScCQzLCBDUnAkMiwgQ1JwJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChDUnAsIHByb3BzKTtcbn0pO1xuXG52YXIgcmVuZGVyZXIgPSBbe1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxSZW5kZXJlclxufSwge1xuICBuYW1lOiAnYmFzZScsXG4gIGltcGw6IEJSXG59LCB7XG4gIG5hbWU6ICdjYW52YXMnLFxuICBpbXBsOiBDUlxufV07XG5cbnZhciBpbmNFeHRzID0gW3tcbiAgdHlwZTogJ2xheW91dCcsXG4gIGV4dGVuc2lvbnM6IGxheW91dFxufSwge1xuICB0eXBlOiAncmVuZGVyZXInLFxuICBleHRlbnNpb25zOiByZW5kZXJlclxufV07XG5cbi8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxudmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuLy8gcmVnaXN0ZXJlZCBtb2R1bGVzIGZvciBleHRlbnNpb25zLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBtb2R1bGVzID0ge307XG5mdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcbiAgdmFyIG92ZXJyaWRlRXJyID0gZnVuY3Rpb24gb3ZlcnJpZGVFcnIoZmllbGQpIHtcbiAgICB3YXJuKCdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyk7XG4gIH07XG4gIGlmICh0eXBlID09PSAnY29yZScpIHtcbiAgICBpZiAoQ29yZS5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29yZS5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY29sbGVjdGlvbicpIHtcbiAgICBpZiAoQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbGF5b3V0Jykge1xuICAgIC8vIGZpbGwgaW4gbWlzc2luZyBsYXlvdXQgZnVuY3Rpb25zIGluIHRoZSBwcm90b3R5cGVcblxuICAgIHZhciBMYXlvdXQgPSBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHJlZ2lzdHJhbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiAoIXBsYWluT2JqZWN0KHRoaXMuX3ByaXZhdGUpKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdGhpcy5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgIH07XG4gICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocmVnaXN0cmFudC5wcm90b3R5cGUpO1xuICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdExheW91dEZucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcbiAgICAgIGxheW91dFByb3RvW2ZuTmFtZV0gPSBsYXlvdXRQcm90b1tmbk5hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcbiAgICBpZiAobGF5b3V0UHJvdG8uc3RhcnQgJiYgIWxheW91dFByb3RvLnJ1bikge1xuICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciByZWdTdG9wID0gcmVnaXN0cmFudC5wcm90b3R5cGUuc3RvcDtcbiAgICBsYXlvdXRQcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLmFuaW1hdGUpIHtcbiAgICAgICAgdmFyIGFuaXMgPSB0aGlzLmFuaW1hdGlvbnM7XG4gICAgICAgIGlmIChhbmlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFuaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhbmlzW19pXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVnU3RvcCkge1xuICAgICAgICByZWdTdG9wLmNhbGwodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgaWYgKCFsYXlvdXRQcm90by5kZXN0cm95KSB7XG4gICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuICAgIGxheW91dFByb3RvLmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgfTtcbiAgICB2YXIgZ2V0Q3kgPSBmdW5jdGlvbiBnZXRDeShsYXlvdXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuX3ByaXZhdGUuY3k7XG4gICAgfTtcbiAgICB2YXIgZW1pdHRlck9wdHMgPSB7XG4gICAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMobGF5b3V0LCBldnQpIHtcbiAgICAgICAgZXZ0LmxheW91dCA9IGxheW91dDtcbiAgICAgICAgZXZ0LmN5ID0gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgZXZ0LnRhcmdldCA9IGxheW91dDtcbiAgICAgIH0sXG4gICAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQobGF5b3V0KSB7XG4gICAgICAgIHJldHVybiBnZXRDeShsYXlvdXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kKGxheW91dFByb3RvLCB7XG4gICAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0cywgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgICB9LFxuICAgICAgb246IGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub24oZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uZTogZnVuY3Rpb24gb25lKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2dCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZ0LCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmUuZXZlbnRBbGlhc2VzT24obGF5b3V0UHJvdG8pO1xuICAgIGV4dCA9IExheW91dDsgLy8gcmVwbGFjZSB3aXRoIG91ciB3cmFwcGVkIGxheW91dFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZW5kZXJlcicgJiYgbmFtZSAhPT0gJ251bGwnICYmIG5hbWUgIT09ICdiYXNlJykge1xuICAgIC8vIHVzZXIgcmVnaXN0ZXJlZCByZW5kZXJlcnMgaW5oZXJpdCBmcm9tIGJhc2VcblxuICAgIHZhciBCYXNlUmVuZGVyZXIgPSBnZXRFeHRlbnNpb24oJ3JlbmRlcmVyJywgJ2Jhc2UnKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG4gICAgdmFyIFJlbmRlcmVyID0gZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICBCYXNlUmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIFJlZ2lzdHJhbnRSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgdmFyIHByb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuICAgIGZvciAodmFyIHBOYW1lIGluIGJQcm90bykge1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bcE5hbWVdO1xuICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1twTmFtZV0gIT0gbnVsbDtcbiAgICAgIGlmIChleGlzdHNJblIpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKHBOYW1lKTtcbiAgICAgIH1cbiAgICAgIHByb3RvW3BOYW1lXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICB9XG4gICAgZm9yICh2YXIgX3BOYW1lIGluIHJQcm90bykge1xuICAgICAgcHJvdG9bX3BOYW1lXSA9IHJQcm90b1tfcE5hbWVdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgfVxuICAgIGJQcm90by5jbGllbnRGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcHJvdG9bbmFtZV0gPSBwcm90b1tuYW1lXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVycm9yKCdSZW5kZXJlciBkb2VzIG5vdCBpbXBsZW1lbnQgYHJlbmRlcmVyLicgKyBuYW1lICsgJygpYCBvbiBpdHMgcHJvdG90eXBlJyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGV4dCA9IFJlbmRlcmVyO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdfX3Byb3RvX18nIHx8IHR5cGUgPT09ICdjb25zdHJ1Y3RvcicgfHwgdHlwZSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAvLyB0byBhdm9pZCBwb3RlbnRpYWwgcHJvdG90eXBlIHBvbGx1dGlvblxuICAgIHJldHVybiBlcnJvcih0eXBlICsgJyBpcyBhbiBpbGxlZ2FsIHR5cGUgdG8gYmUgcmVnaXN0ZXJlZCwgcG9zc2libHkgbGVhZCB0byBwcm90b3R5cGUgcG9sbHV0aW9ucycpO1xuICB9XG4gIHJldHVybiBzZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV0sXG4gICAgdmFsdWU6IGV4dFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV1cbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSwgcmVnaXN0cmFudCkge1xuICByZXR1cm4gc2V0TWFwKHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogW3R5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWVdLFxuICAgIHZhbHVlOiByZWdpc3RyYW50XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUpIHtcbiAgcmV0dXJuIGdldE1hcCh7XG4gICAgbWFwOiBtb2R1bGVzLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXVxuICB9KTtcbn1cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbiBleHRlbnNpb24oKSB7XG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnKVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScpXG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHJldHVybiBzZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICB9XG59O1xuXG4vLyBhbGxvd3MgYSBjb3JlIGluc3RhbmNlIHRvIGFjY2VzcyBleHRlbnNpb25zIGludGVybmFsbHlcbkNvcmUucHJvdG90eXBlLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcblxuLy8gaW5jbHVkZWQgZXh0ZW5zaW9uc1xuaW5jRXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICBncm91cC5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgIHNldEV4dGVuc2lvbihncm91cC50eXBlLCBleHQubmFtZSwgZXh0LmltcGwpO1xuICB9KTtcbn0pO1xuXG4vLyBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IHRoYXQgZG9lc24ndCBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlXG4vLyAodXNlZnVsIGZvciBpbml0KVxudmFyIF9TdHlsZXNoZWV0ID0gZnVuY3Rpb24gU3R5bGVzaGVldCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9TdHlsZXNoZWV0KSkge1xuICAgIHJldHVybiBuZXcgX1N0eWxlc2hlZXQoKTtcbiAgfVxuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xudmFyIHNoZWV0Zm4gPSBfU3R5bGVzaGVldC5wcm90b3R5cGU7XG5zaGVldGZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3N0eWxlc2hlZXQnO1xufTtcblxuLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG5zaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKztcbiAgdGhpc1tpXSA9IHtcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgcHJvcGVydGllczogW11cbiAgfTtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBwcm9wZXJ0eSB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgdmFyIG1hcCA9IG5hbWU7XG4gICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wTmFtZXNbal07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwW2tleV07XG4gICAgICBpZiAobWFwVmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcCA9IF9TdHlsZS5wcm9wZXJ0aWVzW2tleV0gfHwgX1N0eWxlLnByb3BlcnRpZXNbZGFzaDJjYW1lbChrZXkpXTtcbiAgICAgIGlmIChwcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICB2YXIgX3ZhbHVlID0gbWFwVmFsO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBfbmFtZSxcbiAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnNoZWV0Zm4uc3R5bGUgPSBzaGVldGZuLmNzcztcblxuLy8gZ2VuZXJhdGUgYSByZWFsIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBkdW1teSBzdHlsZXNoZWV0XG5zaGVldGZuLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiAoY3kpIHtcbiAgdmFyIHN0eWxlID0gbmV3IF9TdHlsZShjeSk7XG4gIHJldHVybiB0aGlzLmFwcGVuZFRvU3R5bGUoc3R5bGUpO1xufTtcblxuLy8gYXBwZW5kIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3Qgb24gYSByZWFsIHN0eWxlIG9iamVjdFxuc2hlZXRmbi5hcHBlbmRUb1N0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0gdGhpc1tpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgc3R5bGUuY3NzKHByb3AubmFtZSwgcHJvcC52YWx1ZSk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciB2ZXJzaW9uID0gXCIzLjMzLjFcIjtcblxudmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uIGN5dG9zY2FwZShvcHRpb25zKSB7XG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gY3JlYXRlIGluc3RhbmNlXG4gIGlmIChwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBuZXcgQ29yZShvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICBlbHNlIGlmIChzdHJpbmcob3B0aW9ucykpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KGV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLy8gZS5nLiBjeXRvc2NhcGUudXNlKCByZXF1aXJlKCdjeXRvc2NhcGUtZm9vJyksIGJhciApXG5jeXRvc2NhcGUudXNlID0gZnVuY3Rpb24gKGV4dCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGFyZ3MgdG8gcGFzcyB0byBleHRcblxuICBhcmdzLnVuc2hpZnQoY3l0b3NjYXBlKTsgLy8gY3l0b3NjYXBlIGlzIGZpcnN0IGFyZyB0byBleHRcblxuICBleHQuYXBwbHkobnVsbCwgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcbmN5dG9zY2FwZS53YXJuaW5ncyA9IGZ1bmN0aW9uIChib29sKSB7XG4gIHJldHVybiB3YXJuaW5ncyhib29sKTtcbn07XG5cbi8vIHJlcGxhY2VkIGJ5IGJ1aWxkIHN5c3RlbVxuY3l0b3NjYXBlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vLyBleHBvc2UgcHVibGljIGFwaXMgKG1vc3RseSBmb3IgZXh0ZW5zaW9ucylcbmN5dG9zY2FwZS5zdHlsZXNoZWV0ID0gY3l0b3NjYXBlLlN0eWxlc2hlZXQgPSBfU3R5bGVzaGVldDtcblxuZXhwb3J0IHsgY3l0b3NjYXBlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJfYXJyYXlMaWtlVG9BcnJheSIsInIiLCJhIiwibGVuZ3RoIiwiZSIsIm4iLCJBcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsImlzQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsInQiLCJvIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvdHlwZSIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJGIiwicyIsImRvbmUiLCJ2YWx1ZSIsImYiLCJ1IiwiY2FsbCIsIm5leHQiLCJyZXR1cm4iLCJfZGVmaW5lUHJvcGVydHkkMSIsIl9pdGVyYWJsZVRvQXJyYXkiLCJmcm9tIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwibCIsImkiLCJwdXNoIiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9ub25JdGVyYWJsZVNwcmVhZCIsIl9zbGljZWRUb0FycmF5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJfdHlwZW9mIiwiY29uc3RydWN0b3IiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsInRlc3QiLCJfd2luZG93Iiwid2luZG93IiwibmF2aWdhdG9yIiwiZG9jdW1lbnQiLCJ0eXBlb2ZzdHIiLCJ0eXBlb2ZvYmoiLCJ0eXBlb2ZmbiIsInR5cGVvZmh0bWxlbGUiLCJIVE1MRWxlbWVudCIsImluc3RhbmNlU3RyIiwib2JqIiwiaW5zdGFuY2VTdHJpbmciLCJmbiQ2Iiwic3RyaW5nIiwiZm4iLCJhcnJheSIsImVsZW1lbnRPckNvbGxlY3Rpb24iLCJwbGFpbk9iamVjdCIsIm9iamVjdCIsIm51bWJlciQxIiwibnVtYmVyIiwiaXNOYU4iLCJpbnRlZ2VyIiwiTWF0aCIsImZsb29yIiwiaHRtbEVsZW1lbnQiLCJlbGVtZW50IiwiY29sbGVjdGlvbiIsIl9wcml2YXRlIiwic2luZ2xlIiwiY29yZSIsInN0eWxlc2hlZXQiLCJldmVudCIsImVtcHR5U3RyaW5nIiwibWF0Y2giLCJkb21FbGVtZW50IiwiYm91bmRpbmdCb3giLCJ4MSIsIngyIiwieTEiLCJ5MiIsInByb21pc2UiLCJ0aGVuIiwibXMiLCJ1c2VyQWdlbnQiLCJtZW1vaXplIiwia2V5Rm4iLCJhcmd1bWVudHMiLCJhcmdzIiwiam9pbiIsIl9tZW1vaXplZEZuIiwibWVtb2l6ZWRGbiIsInNlbGYiLCJyZXQiLCJrIiwiYXBwbHkiLCJjYWNoZSIsImNhbWVsMmRhc2giLCJzdHIiLCJyZXBsYWNlIiwidiIsInRvTG93ZXJDYXNlIiwiZGFzaDJjYW1lbCIsInRvVXBwZXJDYXNlIiwicHJlcGVuZENhbWVsIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImVuZHNXaXRoIiwic3VmZml4IiwicmdiYSIsInJnYmFOb0JhY2tSZWZzIiwiaHNsYSIsImhzbGFOb0JhY2tSZWZzIiwiaGV4MyIsImhleDYiLCJhc2NlbmRpbmciLCJiIiwiZGVzY2VuZGluZyIsImV4dGVuZCIsImFzc2lnbiIsImJpbmQiLCJ0Z3QiLCJrZXlzIiwiaiIsImhleDJ0dXBsZSIsImhleCIsInNob3J0SGV4IiwiZyIsImJhc2UiLCJwYXJzZUludCIsImhzbDJ0dXBsZSIsImhzbCIsImgiLCJodWUycmdiIiwicCIsInEiLCJtIiwiUmVnRXhwIiwiZXhlYyIsInBhcnNlRmxvYXQiLCJyb3VuZCIsInJnYjJ0dXBsZSIsInJnYiIsImlzUGN0IiwiY2hhbm5lbCIsImF0TGVhc3RPbmVJc1BjdCIsImFsbEFyZVBjdCIsImFscGhhIiwiY29sb3JuYW1lMnR1cGxlIiwiY29sb3IiLCJjb2xvcnMiLCJjb2xvcjJ0dXBsZSIsInRyYW5zcGFyZW50IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JleSIsImdyZWVuIiwiZ3JlZW55ZWxsb3ciLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsInNldE1hcCIsIm9wdGlvbnMiLCJtYXAiLCJFcnJvciIsImdldE1hcCIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsImdsb2JhbCIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwieCIsIl9fZXNNb2R1bGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzT2JqZWN0XzEiLCJoYXNSZXF1aXJlZElzT2JqZWN0IiwicmVxdWlyZUlzT2JqZWN0IiwiaXNPYmplY3QiLCJ0eXBlIiwiX2ZyZWVHbG9iYWwiLCJoYXNSZXF1aXJlZF9mcmVlR2xvYmFsIiwicmVxdWlyZV9mcmVlR2xvYmFsIiwiZnJlZUdsb2JhbCIsIl9yb290IiwiaGFzUmVxdWlyZWRfcm9vdCIsInJlcXVpcmVfcm9vdCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwibm93XzEiLCJoYXNSZXF1aXJlZE5vdyIsInJlcXVpcmVOb3ciLCJub3ciLCJEYXRlIiwiX3RyaW1tZWRFbmRJbmRleCIsImhhc1JlcXVpcmVkX3RyaW1tZWRFbmRJbmRleCIsInJlcXVpcmVfdHJpbW1lZEVuZEluZGV4IiwicmVXaGl0ZXNwYWNlIiwidHJpbW1lZEVuZEluZGV4IiwiaW5kZXgiLCJfYmFzZVRyaW0iLCJoYXNSZXF1aXJlZF9iYXNlVHJpbSIsInJlcXVpcmVfYmFzZVRyaW0iLCJyZVRyaW1TdGFydCIsImJhc2VUcmltIiwiX1N5bWJvbCIsImhhc1JlcXVpcmVkX1N5bWJvbCIsInJlcXVpcmVfU3ltYm9sIiwiX2dldFJhd1RhZyIsImhhc1JlcXVpcmVkX2dldFJhd1RhZyIsInJlcXVpcmVfZ2V0UmF3VGFnIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInRhZyIsInVubWFza2VkIiwicmVzdWx0IiwiX29iamVjdFRvU3RyaW5nIiwiaGFzUmVxdWlyZWRfb2JqZWN0VG9TdHJpbmciLCJyZXF1aXJlX29iamVjdFRvU3RyaW5nIiwib2JqZWN0VG9TdHJpbmciLCJfYmFzZUdldFRhZyIsImhhc1JlcXVpcmVkX2Jhc2VHZXRUYWciLCJyZXF1aXJlX2Jhc2VHZXRUYWciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0TGlrZV8xIiwiaGFzUmVxdWlyZWRJc09iamVjdExpa2UiLCJyZXF1aXJlSXNPYmplY3RMaWtlIiwiaXNPYmplY3RMaWtlIiwiaXNTeW1ib2xfMSIsImhhc1JlcXVpcmVkSXNTeW1ib2wiLCJyZXF1aXJlSXNTeW1ib2wiLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsInRvTnVtYmVyXzEiLCJoYXNSZXF1aXJlZFRvTnVtYmVyIiwicmVxdWlyZVRvTnVtYmVyIiwiTkFOIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzT2N0YWwiLCJmcmVlUGFyc2VJbnQiLCJ0b051bWJlciIsIm90aGVyIiwidmFsdWVPZiIsImlzQmluYXJ5IiwiZGVib3VuY2VfMSIsImhhc1JlcXVpcmVkRGVib3VuY2UiLCJyZXF1aXJlRGVib3VuY2UiLCJGVU5DX0VSUk9SX1RFWFQiLCJuYXRpdmVNYXgiLCJtYXgiLCJuYXRpdmVNaW4iLCJtaW4iLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwidHJhaWxpbmciLCJpbnZva2VGdW5jIiwidGltZSIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInNldFRpbWVvdXQiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWJvdW5jZUV4cG9ydHMiLCJwZXJmb3JtYW5jZSQxIiwicGVyZm9ybWFuY2UiLCJwbm93IiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwZXJmb3JtYW5jZU5vdyIsIkRFRkFVTFRfSEFTSF9TRUVEIiwiSyIsIkRFRkFVTFRfSEFTSF9TRUVEX0FMVCIsImhhc2hJdGVyYWJsZUludHMiLCJzZWVkIiwiaGFzaCIsImVudHJ5IiwiaGFzaEludCIsIm51bSIsImhhc2hJbnRBbHQiLCJjb21iaW5lSGFzaGVzIiwiaGFzaDEiLCJoYXNoMiIsImNvbWJpbmVIYXNoZXNBcnJheSIsImhhc2hlcyIsImhhc2hBcnJheXMiLCJoYXNoZXMxIiwiaGFzaGVzMiIsImhhc2hJbnRzQXJyYXkiLCJpbnRzIiwiaGFzaFN0cmluZyIsImNoYXJDb2RlQXQiLCJoYXNoU3RyaW5ncyIsImhhc2hTdHJpbmdzQXJyYXkiLCJzdHJzIiwicm90YXRlUG9pbnQiLCJ5IiwiY2VudGVyWCIsImNlbnRlclkiLCJhbmdsZURlZ3JlZXMiLCJhbmdsZVJhZGlhbnMiLCJQSSIsInJvdGF0ZWRYIiwiY29zIiwic2luIiwicm90YXRlZFkiLCJtb3ZlUG9pbnRCeUJveEFzcGVjdCIsImJveFgiLCJib3hZIiwic2tld1giLCJza2V3WSIsInJvdGF0ZVBvc0FuZFNrZXdCeUJveCIsInBvcyIsImJveCIsInciLCJyb3RhdGVkIiwic2tld2VkIiwid2FybmluZ3NFbmFibGVkIiwid2FyblN1cHBvcnRlZCIsImNvbnNvbGUiLCJ3YXJuIiwidHJhY2VTdXBwb3J0ZWQiLCJ0cmFjZSIsIk1BWF9JTlQkMSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ0cnVlaWZ5IiwiZmFsc2lmeSIsInplcm9pZnkiLCJub29wJDEiLCJub29wIiwiZXJyb3IiLCJtc2ciLCJ3YXJuaW5ncyIsImVuYWJsZWQiLCJsb2ciLCJjbG9uZSIsImNvcHkiLCJjb3B5QXJyYXkiLCJhcnIiLCJ1dWlkIiwicmFuZG9tIiwiX3N0YXRpY0VtcHR5T2JqZWN0Iiwic3RhdGljRW1wdHlPYmplY3QiLCJkZWZhdWx0cyRnIiwiZGVmYXVsdHMiLCJfZGVmYXVsdHMiLCJvcHRzIiwiZmlsbGVkT3B0cyIsIm9wdFZhbCIsInJlbW92ZUZyb21BcnJheSIsImVsZSIsIm9uZUNvcHkiLCJzcGxpY2UiLCJjbGVhckFycmF5Iiwib3RoZXJBcnIiLCJlbCIsImdldFByZWZpeGVkUHJvcGVydHkiLCJwcm9wTmFtZSIsInNldFByZWZpeGVkUHJvcGVydHkiLCJPYmplY3RNYXAiLCJfb2JqIiwic2V0IiwidmFsIiwiX2RlbGV0ZSIsImNsZWFyIiwiaGFzIiwiZ2V0IiwiTWFwJDEiLCJNYXAiLCJ1bmRlZiIsIk9iamVjdFNldCIsImFycmF5T3JPYmplY3RTZXQiLCJjcmVhdGUiLCJzaXplIiwidG9BcnJheSIsImFkZCIsIl90aGlzIiwiZmlsdGVyIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwiU2V0JDEiLCJTZXQiLCJFbGVtZW50IiwiY3kiLCJwYXJhbXMiLCJyZXN0b3JlIiwiZ3JvdXAiLCJkYXRhIiwic291cmNlIiwidGFyZ2V0IiwiX3AiLCJwb3NpdGlvbiIsImF1dG9XaWR0aCIsImF1dG9IZWlnaHQiLCJhdXRvUGFkZGluZyIsImNvbXBvdW5kQm91bmRzQ2xlYW4iLCJsaXN0ZW5lcnMiLCJzdHlsZSIsInJzdHlsZSIsInN0eWxlQ3h0cyIsInN0eWxlS2V5cyIsInJlbW92ZWQiLCJzZWxlY3RlZCIsInNlbGVjdGFibGUiLCJsb2NrZWQiLCJncmFiYmVkIiwiZ3JhYmJhYmxlIiwicGFubmFibGUiLCJhY3RpdmUiLCJjbGFzc2VzIiwiYW5pbWF0aW9uIiwiY3VycmVudCIsInF1ZXVlIiwicnNjcmF0Y2giLCJzY3JhdGNoIiwiZWRnZXMiLCJjaGlsZHJlbiIsInBhcmVudCIsImlzTm9kZSIsInRyYXZlcnNhbENhY2hlIiwiYmFja2dyb3VuZGluZyIsImJiQ2FjaGUiLCJiYkNhY2hlU2hpZnQiLCJib2R5Qm91bmRzIiwib3ZlcmxheUJvdW5kcyIsImxhYmVsQm91bmRzIiwiYWxsIiwibWFpbiIsImFycm93Qm91bmRzIiwicmVuZGVyZWRQb3NpdGlvbiIsInJwb3MiLCJwYW4iLCJ6b29tIiwic3BsaXQiLCJjbHMiLCJjcmVhdGVFbWl0dGVyIiwiYnlwYXNzIiwiY3NzIiwiZGVmaW5lU2VhcmNoIiwiYmZzIiwiZGZzIiwic2VhcmNoRm4iLCJyb290cyIsImRpcmVjdGVkIiwidmlzaXQiLCJRIiwiY29ubmVjdGVkTm9kZXMiLCJjb25uZWN0ZWRCeSIsImlkMmRlcHRoIiwiViIsImZvdW5kIiwiX3RoaXMkYnlHcm91cCIsImJ5R3JvdXAiLCJub2RlcyIsInZpIiwidmlJZCIsImlkIiwidW5zaGlmdCIsIl9sb29wIiwic2hpZnQiLCJwb3AiLCJ2SWQiLCJkZXB0aCIsInByZXZFZGdlIiwic3JjIiwicHJldk5vZGUiLCJzYW1lIiwidndFZGdlcyIsImNvbm5lY3RlZEVkZ2VzIiwiX2kyIiwid0lkIiwiX3JldCIsImNvbm5lY3RlZEVsZXMiLCJfaSIsIm5vZGUiLCJlZGdlIiwicGF0aCIsImVsZXNmbiR2IiwiYnJlYWR0aEZpcnN0U2VhcmNoIiwiZGVwdGhGaXJzdFNlYXJjaCIsImhlYXAkMiIsImV4cG9ydHMiLCJoZWFwJDEiLCJoYXNSZXF1aXJlZEhlYXAkMSIsInJlcXVpcmVIZWFwJDEiLCJtb2R1bGUiLCJIZWFwIiwiZGVmYXVsdENtcCIsImhlYXBpZnkiLCJoZWFwcG9wIiwiaGVhcHB1c2giLCJoZWFwcHVzaHBvcCIsImhlYXByZXBsYWNlIiwiaW5zb3J0Iiwibmxhcmdlc3QiLCJuc21hbGxlc3QiLCJ1cGRhdGVJdGVtIiwiX3NpZnRkb3duIiwiX3NpZnR1cCIsImxvIiwiaGkiLCJjbXAiLCJtaWQiLCJjb25jYXQiLCJpdGVtIiwibGFzdGVsdCIsInJldHVybml0ZW0iLCJfcmVmIiwiX2xlbiIsIl9yZWYxIiwiX3Jlc3VsdHMiLCJfcmVzdWx0czEiLCJfaiIsInJldmVyc2UiLCJpbmRleE9mIiwiZWxlbSIsInNvcnQiLCJsb3MiLCJzdGFydHBvcyIsIm5ld2l0ZW0iLCJwYXJlbnRwb3MiLCJjaGlsZHBvcyIsImVuZHBvcyIsInJpZ2h0cG9zIiwicHVzaHBvcCIsInBlZWsiLCJjb250YWlucyIsImVtcHR5IiwiaGVhcCIsImluc2VydCIsInRvcCIsImZyb250IiwiZmFjdG9yeSIsImhhc1JlcXVpcmVkSGVhcCIsInJlcXVpcmVIZWFwIiwiaGVhcEV4cG9ydHMiLCJkaWprc3RyYURlZmF1bHRzIiwid2VpZ2h0IiwiZWxlc2ZuJHUiLCJkaWprc3RyYSIsIl9kaWprc3RyYURlZmF1bHRzIiwiZWxlcyIsIndlaWdodEZuIiwiZGlzdCIsInByZXYiLCJrbm93bkRpc3QiLCJ1bm1lcmdlQnkiLCJpc0xvb3AiLCJnZXREaXN0Iiwic2V0RGlzdCIsImQiLCJJbmZpbml0eSIsImRpc3RCZXR3ZWVuIiwidXZzIiwiZWRnZXNUbyIsImVkZ2VzV2l0aCIsImludGVyc2VjdCIsInNtYWxsZXN0RGlzdGFuY2UiLCJzbWFsbGVzdEVkZ2UiLCJfd2VpZ2h0Iiwic21hbGxldHNEaXN0IiwidWlkIiwibmVpZ2hib3JzIiwibmVpZ2hib3Job29kIiwidmlkIiwidkRpc3QiLCJhbHQiLCJkaXN0YW5jZVRvIiwicGF0aFRvIiwiUyIsInNwYXduIiwiZWxlc2ZuJHQiLCJrcnVza2FsIiwibnVtTm9kZXMiLCJmb3Jlc3QiLCJBIiwiZmluZFNldEluZGV4Iiwic2V0VUluZGV4Iiwic2V0VkluZGV4Iiwic2V0VSIsInNldFYiLCJtZXJnZSIsImFTdGFyRGVmYXVsdHMiLCJnb2FsIiwiaGV1cmlzdGljIiwiZWxlc2ZuJHMiLCJhU3RhciIsIl9hU3RhckRlZmF1bHRzIiwic2lkIiwidGlkIiwiZ1Njb3JlIiwiZlNjb3JlIiwiY2xvc2VkU2V0SWRzIiwib3BlblNldCIsIm9wZW5TZXRJZHMiLCJjYW1lRnJvbSIsImNhbWVGcm9tRWRnZSIsImFkZFRvT3BlblNldCIsImNNaW4iLCJjTWluSWQiLCJwb3BGcm9tT3BlblNldCIsImlzSW5PcGVuU2V0Iiwic3RlcHMiLCJwYXRoTm9kZSIsInBhdGhOb2RlSWQiLCJwYXRoRWRnZSIsImRpc3RhbmNlIiwiaGFzRWxlbWVudFdpdGhJZCIsIndTcmMiLCJ3VGd0Iiwid2lkIiwidGVtcFNjb3JlIiwiZmxveWRXYXJzaGFsbERlZmF1bHRzIiwiZWxlc2ZuJHIiLCJmbG95ZFdhcnNoYWxsIiwiX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0IiwiTiIsIk5zcSIsImF0SW5kZXgiLCJlZGdlTmV4dCIsInN0IiwidHMiLCJpayIsImlqIiwia2oiLCJnZXRBcmdFbGUiLCJpbmRleE9mQXJnRWxlIiwicmVzIiwidG8iLCJmcm9tTm9kZSIsImJlbGxtYW5Gb3JkRGVmYXVsdHMiLCJlbGVzZm4kcSIsImJlbGxtYW5Gb3JkIiwiX2JlbGxtYW5Gb3JkRGVmYXVsdHMiLCJpbmZvTWFwIiwiaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSIsIm5lZ2F0aXZlV2VpZ2h0Q3ljbGVzIiwibnVtRWRnZXMiLCJnZXRJbmZvIiwiZ2V0Tm9kZUZyb21UbyIsIiQiLCJ0aGlzU3RhcnQiLCJlbmQiLCJfZ2V0SW5mbyIsInByZWQiLCJpbmZvIiwicmVwbGFjZWRFZGdlIiwiY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQiLCJub2RlMSIsIm5vZGUyIiwiaW5mbzEiLCJpbmZvMiIsInNyY0luZm8iLCJ0Z3RJbmZvIiwibmVnYXRpdmVXZWlnaHRDeWNsZUlkcyIsIl9lIiwiX2VkZ2UiLCJfc3JjIiwiX3RndCIsIl93ZWlnaHQyIiwic3JjRGlzdCIsInRndERpc3QiLCJmaW5kTmVnYXRpdmVXZWlnaHRDeWNsZXMiLCJuZWdhdGl2ZU5vZGVzIiwibnVtTmVnYXRpdmVOb2RlcyIsInN0YXJ0IiwiY3ljbGUiLCJfbm9kZSIsInNtYWxsZXN0SWQiLCJzbWFsbGVzdEluZGV4IiwiYyIsImN5Y2xlSWQiLCJzcXJ0MiIsInNxcnQiLCJjb2xsYXBzZSIsImVkZ2VJbmRleCIsIm5vZGVNYXAiLCJyZW1haW5pbmdFZGdlcyIsImVkZ2VJbmZvIiwic291cmNlSW4iLCJ0YXJnZXRJbiIsInBhcnRpdGlvbjEiLCJwYXJ0aXRpb24yIiwibmV3RWRnZXMiLCJjb250cmFjdFVudGlsIiwibWV0YU5vZGVNYXAiLCJzaXplTGltaXQiLCJlbGVzZm4kcCIsImthcmdlclN0ZWluIiwibnVtSXRlciIsImNlaWwiLCJwb3ciLCJMTjIiLCJzdG9wU2l6ZSIsImVkZ2VJbmRleGVzIiwibWluQ3V0U2l6ZSIsIm1pbkN1dEVkZ2VJbmRleGVzIiwibWluQ3V0Tm9kZU1hcCIsIm1ldGFOb2RlTWFwMiIsImNvcHlOb2Rlc01hcCIsIl9pMyIsIml0ZXIiLCJfaTQiLCJlZGdlc1N0YXRlIiwiZWRnZXNTdGF0ZTIiLCJyZXMxIiwicmVzMiIsImN1dCIsIndpdG5lc3NOb2RlUGFydGl0aW9uIiwiX2k1IiwicGFydGl0aW9uSWQiLCJjb25zdHJ1Y3RDb21wb25lbnQiLCJzdWJzZXQiLCJjb21wb25lbnQiLCJjb21wb25lbnRzIiwiX01hdGgkaHlwb3QiLCJjb3B5UG9zaXRpb24iLCJtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxIiwibW9kZWxUb1JlbmRlcmVkUG9zaXRpb24iLCJyZW5kZXJlZFRvTW9kZWxQb3NpdGlvbiIsImFycmF5MnBvaW50IiwiYmVnaW4iLCJpc0Zpbml0ZSIsIm1lYW4iLCJ0b3RhbCIsIm1lZGlhbiIsImluY2x1ZGVIb2xlcyIsIm9mZiIsImxlbiIsImRlZzJyYWQiLCJkZWciLCJnZXRBbmdsZUZyb21EaXNwIiwiZGlzcFgiLCJkaXNwWSIsImF0YW4yIiwibG9nMiIsInNpZ251bSIsInAxIiwicDIiLCJzcWRpc3QiLCJkeCIsImR5IiwiaW5QbGFjZVN1bU5vcm1hbGl6ZSIsInFiZXppZXJBdCIsInAwIiwicWJlemllclB0QXQiLCJsaW5lQXQiLCJ2ZWMiLCJ2ZWNEaXN0Iiwibm9ybVZlYyIsImJvdW5kIiwibWFrZUJvdW5kaW5nQm94IiwiYmIiLCJjb3B5Qm91bmRpbmdCb3giLCJjbGVhckJvdW5kaW5nQm94IiwidXBkYXRlQm91bmRpbmdCb3giLCJiYjEiLCJiYjIiLCJleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQiLCJleHBhbmRCb3VuZGluZ0JveCIsInBhZGRpbmciLCJleHBhbmRCb3VuZGluZ0JveFNpZGVzIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiX3BhZGRpbmciLCJhc3NpZ25Cb3VuZGluZ0JveCIsImJvdW5kaW5nQm94ZXNJbnRlcnNlY3QiLCJpbkJvdW5kaW5nQm94IiwicG9pbnRJbkJvdW5kaW5nQm94IiwicHQiLCJib3VuZGluZ0JveEluQm91bmRpbmdCb3giLCJoeXBvdCIsImluZmxhdGVQb2x5Z29uIiwicG9seWdvbiIsInN1YiIsInNjYWxlIiwiY3Jvc3MiLCJub3JtYWxpemUiLCJzaWduZWRBcmVhIiwicHRzIiwiaW50ZXJzZWN0TGluZXMiLCJwMyIsInA0IiwiZGVub20iLCJhYnMiLCJub3JtYWxzIiwib3V0Iiwib2Zmc2V0RWRnZXMiLCJucm0iLCJpbmZsYXRlZCIsImN1cnJFZGdlIiwiaXAiLCJtaXRlckJveCIsIndpZHRoIiwiaGVpZ2h0Iiwic3Ryb2tlV2lkdGgiLCJ0cHRzIiwidHJhbnNmb3JtUG9pbnRzIiwib2Zmc2V0UG9pbnRzIiwicm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lIiwibm9kZVgiLCJub2RlWSIsInJhZGl1cyIsImNvcm5lclJhZGl1cyIsImdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzIiwiaGFsZldpZHRoIiwiaGFsZkhlaWdodCIsImRvV2lkdGgiLCJkb0hlaWdodCIsInN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMiLCJ0b3BTdGFydFgiLCJ0b3BTdGFydFkiLCJ0b3BFbmRYIiwidG9wRW5kWSIsImZpbml0ZUxpbmVzSW50ZXJzZWN0IiwicmlnaHRTdGFydFgiLCJyaWdodFN0YXJ0WSIsInJpZ2h0RW5kWCIsInJpZ2h0RW5kWSIsImJvdHRvbVN0YXJ0WCIsImJvdHRvbVN0YXJ0WSIsImJvdHRvbUVuZFgiLCJib3R0b21FbmRZIiwibGVmdFN0YXJ0WCIsImxlZnRTdGFydFkiLCJsZWZ0RW5kWCIsImxlZnRFbmRZIiwiYXJjSW50ZXJzZWN0aW9ucyIsInRvcExlZnRDZW50ZXJYIiwidG9wTGVmdENlbnRlclkiLCJpbnRlcnNlY3RMaW5lQ2lyY2xlIiwidG9wUmlnaHRDZW50ZXJYIiwidG9wUmlnaHRDZW50ZXJZIiwiYm90dG9tUmlnaHRDZW50ZXJYIiwiYm90dG9tUmlnaHRDZW50ZXJZIiwiYm90dG9tTGVmdENlbnRlclgiLCJib3R0b21MZWZ0Q2VudGVyWSIsImluTGluZVZpY2luaXR5IiwibHgxIiwibHkxIiwibHgyIiwibHkyIiwidG9sZXJhbmNlIiwiaW5CZXppZXJWaWNpbml0eSIsIngzIiwieTMiLCJzb2x2ZVF1YWRyYXRpYyIsInNxcnRSIiwicm9vdDEiLCJyb290MiIsInNvbHZlQ3ViaWMiLCJlcHNpbG9uIiwiZGlzY3JpbWluYW50IiwiZHVtMSIsInRlcm0xIiwicjEzIiwiYWNvcyIsInNxZGlzdFRvUXVhZHJhdGljQmV6aWVyIiwiemVyb1RocmVzaG9sZCIsIm1pbkRpc3RhbmNlU3F1YXJlZCIsImN1clgiLCJjdXJZIiwiZGlzdFNxdWFyZWQiLCJzcWRpc3RUb0Zpbml0ZUxpbmUiLCJvZmZzZXQiLCJsaW5lIiwibGluZVNxIiwiaHlwU3EiLCJkb3RQcm9kdWN0IiwiYWRqU3EiLCJwb2ludEluc2lkZVBvbHlnb25Qb2ludHMiLCJwb2ludHMiLCJ1cCIsInBvaW50SW5zaWRlUG9seWdvbiIsImJhc2VQb2ludHMiLCJkaXJlY3Rpb24iLCJ0cmFuc2Zvcm1lZFBvaW50cyIsImFuZ2xlIiwiYXRhbiIsImV4cGFuZGVkTGluZVNldCIsImV4cGFuZFBvbHlnb24iLCJqb2luTGluZXMiLCJwb2ludEluc2lkZVJvdW5kUG9seWdvbiIsImNvcm5lcnMiLCJjdXRQb2x5Z29uUG9pbnRzIiwiY29ybmVyIiwic3RhcnRYIiwic3RhcnRZIiwic3RvcFgiLCJzdG9wWSIsInNxdWFyZWREaXN0YW5jZSIsImN4IiwibGluZVNldCIsInZlcnRpY2VzIiwiY3VycmVudExpbmVTdGFydFgiLCJjdXJyZW50TGluZVN0YXJ0WSIsImN1cnJlbnRMaW5lRW5kWCIsImN1cnJlbnRMaW5lRW5kWSIsIm5leHRMaW5lU3RhcnRYIiwibmV4dExpbmVTdGFydFkiLCJuZXh0TGluZUVuZFgiLCJuZXh0TGluZUVuZFkiLCJpbnRlcnNlY3Rpb24iLCJwYWQiLCJjdXJyZW50UG9pbnRYIiwiY3VycmVudFBvaW50WSIsIm5leHRQb2ludFgiLCJuZXh0UG9pbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJvZmZzZXRMZW5ndGgiLCJub3JtYWxpemVkT2Zmc2V0WCIsIm5vcm1hbGl6ZWRPZmZzZXRZIiwiaW50ZXJzZWN0TGluZUVsbGlwc2UiLCJlbGxpcHNlV3JhZGl1cyIsImVsbGlwc2VIcmFkaXVzIiwibmV3TGVuZ3RoIiwibGVuUHJvcG9ydGlvbiIsImNoZWNrSW5FbGxpcHNlIiwidDEiLCJ0MiIsInRNaW4iLCJ0TWF4IiwiaW5SYW5nZVBhcmFtcyIsIm5lYXJJbnRlcnNlY3Rpb25YIiwibmVhckludGVyc2VjdGlvblkiLCJmYXJJbnRlcnNlY3Rpb25YIiwiZmFySW50ZXJzZWN0aW9uWSIsIm1pZE9mVGhyZWUiLCJ4NCIsInk0IiwiaW5maW5pdGVMaW5lcyIsImR4MTMiLCJkeDIxIiwiZHg0MyIsImR5MTMiLCJkeTIxIiwiZHk0MyIsInVhX3QiLCJ1Yl90IiwidV9iIiwidWEiLCJ1YiIsImZscHRUaHJlc2hvbGQiLCJfbWluIiwiX21heCIsImhhbGZXIiwiaGFsZkgiLCJwb2x5Z29uSW50ZXJzZWN0TGluZSIsImludGVyc2VjdGlvbnMiLCJkb1RyYW5zZm9ybSIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJuZXh0WCIsIm5leHRZIiwicm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSIsImxpbmVzIiwibG93ZXN0SW50ZXJzZWN0aW9uIiwibG93ZXN0U3F1YXJlZERpc3RhbmNlIiwic2hvcnRlbkludGVyc2VjdGlvbiIsImFtb3VudCIsImRpc3AiLCJsZW5SYXRpbyIsImdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSIsInNpZGVzIiwicm90YXRpb25SYWRpYW5zIiwiZ2VuZXJhdGVVbml0TmdvblBvaW50cyIsImZpdFBvbHlnb25Ub1NxdWFyZSIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJzeCIsInN5IiwiX2k2IiwiaW5jcmVtZW50Iiwic3RhcnRBbmdsZSIsImN1cnJlbnRBbmdsZSIsImdldFJvdW5kUG9seWdvblJhZGl1cyIsImdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCIsImJlemllclB0c1RvUXVhZENvZWZmIiwiZ2V0QmFycmVsQ3VydmVDb25zdGFudHMiLCJoZWlnaHRPZmZzZXQiLCJ3aWR0aE9mZnNldCIsImN0cmxQdE9mZnNldFBjdCIsInNhdFBvbHlnb25JbnRlcnNlY3Rpb24iLCJwb2x5MSIsInBvbHkyIiwiZ2V0QXhlcyIsImF4ZXMiLCJub3JtYWwiLCJwcm9qZWN0IiwiYXhpcyIsIl9pdGVyYXRvciIsIl9zdGVwIiwicG9pbnQiLCJwcm9qZWN0aW9uIiwiZXJyIiwib3ZlcmxhcHMiLCJwcm9qMSIsInByb2oyIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsInBhZ2VSYW5rRGVmYXVsdHMiLCJkYW1waW5nRmFjdG9yIiwicHJlY2lzaW9uIiwiaXRlcmF0aW9ucyIsImVsZXNmbiRvIiwicGFnZVJhbmsiLCJfcGFnZVJhbmtEZWZhdWx0cyIsIm51bU5vZGVzU3FkIiwibWF0cml4IiwiY29sdW1uU3VtIiwiYWRkaXRpb25hbFByb2IiLCJzcmNJZCIsInRndElkIiwiaW5kZXhPZklkIiwiX24iLCJfbjIiLCJfbjMiLCJlaWdlbnZlY3RvciIsInRlbXAiLCJwcmV2aW91cyIsIl9qMiIsIl9uNCIsImRpZmYiLCJfaTciLCJkZWx0YSIsInJhbmsiLCJkZWZhdWx0cyRmIiwiZWxlc2ZuJG4iLCJkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZCIsImRlZ3JlZXMiLCJtYXhEZWdyZWUiLCJjdXJyRGVncmVlIiwiZGVncmVlQ2VudHJhbGl0eSIsImRlZ3JlZSIsImluZGVncmVlcyIsIm91dGRlZ3JlZXMiLCJtYXhJbmRlZ3JlZSIsIm1heE91dGRlZ3JlZSIsIl9jdXJyRGVncmVlIiwiaW5kZWdyZWUiLCJvdXRkZWdyZWUiLCJjYWxsaW5nRWxlcyIsIl9vcHRpb25zIiwiY29ubkVkZ2VzIiwiaW5jb21pbmciLCJvdXRnb2luZyIsImtfaW4iLCJrX291dCIsInNfaW4iLCJzX291dCIsImRjIiwiZGNuIiwiZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQiLCJkZWZhdWx0cyRlIiwiaGFybW9uaWMiLCJlbGVzZm4kbSIsImNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkIiwiY2xvc2VuZXNzZXMiLCJtYXhDbG9zZW5lc3MiLCJmdyIsImN1cnJDbG9zZW5lc3MiLCJub2RlX2kiLCJjbG9zZW5lc3MiLCJjbG9zZW5lc3NDZW50cmFsaXR5IiwiX2RlZmF1bHRzMiIsInRvdGFsRGlzdGFuY2UiLCJjYyIsImNjbiIsImNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkIiwiZGVmYXVsdHMkZCIsImVsZXNmbiRsIiwiYmV0d2Vlbm5lc3NDZW50cmFsaXR5Iiwid2VpZ2h0ZWQiLCJfQyIsIkMiLCJvdXRnb2VycyIsIm9wZW5OZWlnaGJvcmhvb2QiLCJQIiwiX3ZpZCIsIl92IiwidkVsZSIsImdldEVsZW1lbnRCeUlkIiwiZWRnZVdlaWdodCIsIl93IiwiX3cyIiwiX3YyIiwiYmV0d2Vlbm5lc3MiLCJiZXR3ZWVubmVzc05vcm1hbGl6ZWQiLCJiZXR3ZWVubmVzc05vcm1hbGlzZWQiLCJiYyIsImRlZmF1bHRzJGMiLCJleHBhbmRGYWN0b3IiLCJpbmZsYXRlRmFjdG9yIiwibXVsdEZhY3RvciIsIm1heEl0ZXJhdGlvbnMiLCJhdHRyaWJ1dGVzIiwic2V0T3B0aW9ucyQzIiwic2V0T3B0aW9ucyIsImdldFNpbWlsYXJpdHkkMSIsImdldFNpbWlsYXJpdHkiLCJhZGRMb29wcyIsIk0iLCJzdW0iLCJjb2wiLCJyb3ciLCJfcm93IiwibW11bHQiLCJCIiwiZXhwYW5kIiwiX00iLCJpbmZsYXRlIiwiaGFzQ29udmVyZ2VkIiwibjIiLCJyb3VuZEZhY3RvciIsInYxIiwidjIiLCJhc3NpZ24kMiIsImNsdXN0ZXJzIiwiY2x1c3RlciIsImlzRHVwbGljYXRlIiwiYzEiLCJjMiIsInJlbW92ZUR1cGxpY2F0ZXMiLCJtYXJrb3ZDbHVzdGVyaW5nIiwiaWQycG9zaXRpb24iLCJzaW0iLCJpc1N0aWxsTW92aW5nIiwibWFya292Q2x1c3RlcmluZyQxIiwibWNsIiwiaWRlbnRpdHkkMSIsImlkZW50aXR5IiwiYWJzRGlmZiIsImFkZEFic0RpZmYiLCJhZGRTcXVhcmVkRGlmZiIsIm1heEFic0RpZmYiLCJjdXJyZW50TWF4IiwiZ2V0RGlzdGFuY2UiLCJnZXRQIiwiZ2V0USIsImluaXQiLCJwb3N0IiwiZGltIiwiZGlzdGFuY2VzIiwiZXVjbGlkZWFuIiwic3F1YXJlZEV1Y2xpZGVhbiIsIm1hbmhhdHRhbiIsImNsdXN0ZXJpbmdEaXN0YW5jZSIsIm1ldGhvZCIsIm5vZGVQIiwibm9kZVEiLCJpbXBsIiwiZGVmYXVsdHMkYiIsInNlbnNpdGl2aXR5VGhyZXNob2xkIiwidGVzdE1vZGUiLCJ0ZXN0Q2VudHJvaWRzIiwic2V0T3B0aW9ucyQyIiwiY2VudHJvaWQiLCJtb2RlIiwibm9Ob2RlUCIsInJhbmRvbUNlbnRyb2lkcyIsIm5kaW0iLCJjZW50cm9pZHMiLCJjbGFzc2lmeSIsImJ1aWxkQ2x1c3RlciIsImFzc2lnbm1lbnQiLCJoYXZlVmFsdWVzQ29udmVyZ2VkIiwiaGF2ZU1hdHJpY2VzQ29udmVyZ2VkIiwic2VlbkJlZm9yZSIsIm1lZG9pZHMiLCJyYW5kb21NZWRvaWRzIiwiZmluZENvc3QiLCJwb3RlbnRpYWxOZXdNZWRvaWQiLCJjb3N0Iiwia01lYW5zIiwibmV3Q2VudHJvaWQiLCJrTWVkb2lkcyIsImN1ckNvc3QiLCJtaW5Db3N0cyIsInVwZGF0ZUNlbnRyb2lkcyIsIlUiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIl9jIiwidXBkYXRlTWVtYmVyc2hpcCIsIl9VIiwiYXNzaWduJDEiLCJfYzIiLCJfYzMiLCJmdXp6eUNNZWFucyIsImRlZ3JlZU9mTWVtYmVyc2hpcCIsImtDbHVzdGVyaW5nIiwiZmNtIiwiZGVmYXVsdHMkYSIsImxpbmthZ2UiLCJ0aHJlc2hvbGQiLCJhZGREZW5kcm9ncmFtIiwiZGVuZHJvZ3JhbURlcHRoIiwibGlua2FnZUFsaWFzZXMiLCJzZXRPcHRpb25zJDEiLCJwcmVmZXJyZWRBbGlhcyIsIm1lcmdlQ2xvc2VzdCIsImRpc3RzIiwibWlucyIsIm1pbktleSIsImF0dHJzIiwibjEiLCJfZGlzdCIsIm1lcmdlZCIsImN1ciIsImtleTEiLCJrZXkyIiwiX2dldEFsbENoaWxkcmVuIiwiZ2V0QWxsQ2hpbGRyZW4iLCJfYnVpbGREZW5kcm9ncmFtIiwiYnVpbGREZW5kcm9ncmFtIiwibGVmdFN0ciIsInJpZ2h0U3RyIiwiX2J1aWxkQ2x1c3RlcnNGcm9tVHJlZSIsImJ1aWxkQ2x1c3RlcnNGcm9tVHJlZSIsImxlYXZlcyIsImhpZXJhcmNoaWNhbENsdXN0ZXJpbmciLCJyZXRDbHVzdGVycyIsImhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSIsImhjYSIsImRlZmF1bHRzJDkiLCJwcmVmZXJlbmNlIiwiZGFtcGluZyIsIm1pbkl0ZXJhdGlvbnMiLCJkbXAiLCJwcmVmIiwidmFsaWRQcmVmcyIsInNvbWUiLCJhdHRyIiwiZ2V0UHJlZmVyZW5jZSIsImZpbmRFeGVtcGxhcnMiLCJSIiwiaW5kaWNlcyIsImFzc2lnbkNsdXN0ZXJzIiwiZXhlbXBsYXJzIiwiZWkiLCJfZWkiLCJpaSIsIm1heEkiLCJtYXhTdW0iLCJhZmZpbml0eVByb3BhZ2F0aW9uIiwib2xkIiwiUnAiLCJzZSIsIl9pOCIsIm1heDIiLCJBUyIsIl9pOSIsIl9qMyIsIl9qNCIsIl9pMTAiLCJFIiwiX3N1bSIsIl9pMTEiLCJfajUiLCJleGVtcGxhcnNJbmRpY2VzIiwiY2x1c3RlckluZGljZXMiLCJfaTEyIiwiY2x1c3RlckluZGV4IiwiYWZmaW5pdHlQcm9wYWdhdGlvbiQxIiwiYXAiLCJoaWVyaG9semVyRGVmYXVsdHMiLCJlbGVzZm4kayIsImhpZXJob2x6ZXIiLCJfaGllcmhvbHplckRlZmF1bHRzIiwiZGZsYWciLCJvZGRJbiIsIm9kZE91dCIsInN0YXJ0VmVydGV4IiwiaW5kIiwib3V0ZCIsImQxIiwiZDIiLCJpc0VkZ2UiLCJ0cmFpbCIsIndhbGsiLCJjdXJyZW50Tm9kZSIsInN1YnRvdXIiLCJhZGoiLCJhZGpUYWlsIiwiYWRqSGVhZCIsImhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQiLCJlZGdlQ291bnQiLCJzdGFjayIsInZpc2l0ZWRFZGdlcyIsImJ1aWxkQ29tcG9uZW50IiwiY3V0c2V0Iiwibm9kZUlkIiwiY3V0VmVydGV4IiwiX2JpY29ubmVjdGVkU2VhcmNoIiwiYmljb25uZWN0ZWRTZWFyY2giLCJsb3ciLCJzb3VyY2VJZCIsInRhcmdldElkIiwib3RoZXJOb2RlSWQiLCJlZGdlSWQiLCJjdXRWZXJ0aWNlcyIsImhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSIsImh0YmMiLCJodGIiLCJob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkQ29tcG9uZW50cyIsInRhcmphblN0cm9uZ2x5Q29ubmVjdGVkIiwiX3N0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoIiwic3Ryb25nbHlDb25uZWN0ZWRTZWFyY2giLCJzb3VyY2VOb2RlSWQiLCJleHBsb3JlZCIsInRhcmdldE5vZGVJZCIsImNvbXBvbmVudE5vZGVzIiwiY29tcG9uZW50RWRnZXMiLCJkaWZmZXJlbmNlIiwidGFyamFuU3Ryb25nbHlDb25uZWN0ZWQkMSIsInRzYyIsInRzY2MiLCJ0YXJqYW5TdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHMiLCJlbGVzZm4kaiIsInByb3BzIiwiU1RBVEVfUEVORElORyIsIlNUQVRFX0ZVTEZJTExFRCIsIlNUQVRFX1JFSkVDVEVEIiwiX2FwaSIsImFwaSIsImV4ZWN1dG9yIiwic3RhdGUiLCJmdWxmaWxsVmFsdWUiLCJyZWplY3RSZWFzb24iLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJwcm94eSIsImZ1bGZpbGwiLCJyZWplY3QiLCJkZWxpdmVyIiwiY3VyciIsInJlc29sdmVyIiwiZXhlY3V0ZSIsImV4ZWN1dGVfaGFuZGxlcnMiLCJoYW5kbGVycyIsInNldEltbWVkaWF0ZSIsImNiIiwiX3Jlc29sdmUiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJwcyIsInJlc29sdmVBbGwiLCJyZWplY3RBbGwiLCJ2YWxzIiwiZG9uZUNvdW50IiwiaXNQcm9taXNlIiwiUHJvbWlzZSQxIiwiUHJvbWlzZSIsIkFuaW1hdGlvbiIsIm9wdHMyIiwiaXNDb3JlIiwiaXNFbGUiLCJkdXJhdGlvbiIsInN0YXJ0ZWQiLCJwbGF5aW5nIiwiaG9va2VkIiwiYXBwbHlpbmciLCJwcm9ncmVzcyIsImNvbXBsZXRlcyIsImZyYW1lcyIsImNvbXBsZXRlIiwic3RhcnRQb3NpdGlvbiIsInN0YXJ0U3R5bGUiLCJnZXRBbmltYXRpb25TdGFydFN0eWxlIiwic3RhcnRQYW4iLCJzdGFydFpvb20iLCJhbmlmbiIsImhvb2siLCJ0QW5pIiwiYWRkVG9BbmltYXRpb25Qb29sIiwicGxheSIsInN0b3BwZWQiLCJwYXVzZSIsInN0b3AiLCJyZXdpbmQiLCJmYXN0Zm9yd2FyZCIsIndhc1BsYXlpbmciLCJjb21wbGV0ZWQiLCJzd2FwIiwiX3BhIiwicHJvcCIsInN0YXJ0U3R5bGVQcm9wIiwicnVuIiwicnVubmluZyIsImRlZmluZSQzIiwiYW5pbWF0ZWQiLCJhbmltYXRlZEltcGwiLCJzZWxmSXNBcnJheUxpa2UiLCJzdHlsZUVuYWJsZWQiLCJjbGVhclF1ZXVlIiwiY2xlYXJRdWV1ZUltcGwiLCJkZWxheSIsImRlbGF5SW1wbCIsImFuaW1hdGUiLCJkZWxheUFuaW1hdGlvbiIsImRlbGF5QW5pbWF0aW9uSW1wbCIsImFuaW1hdGlvbkltcGwiLCJwcm9wZXJ0aWVzIiwiaXNFbGVzIiwicHJvcGVydGllc0VtcHR5IiwiZ2V0UHJvcHNMaXN0IiwicGFuQnkiLCJjeVBhbiIsImNlbnRlciIsImNlbnRyZSIsImNlbnRlclBhbiIsImdldENlbnRlclBhbiIsImZpdCIsImZpdFZwIiwiZ2V0Rml0Vmlld3BvcnQiLCJ2cCIsImdldFpvb21lZFZpZXdwb3J0Iiwiem9vbWVkIiwicGFubmVkIiwiYW5pbWF0ZUltcGwiLCJhbmkiLCJzdG9wSW1wbCIsImp1bXBUb0VuZCIsImFuaXMiLCJhbmlfcCIsIm5vdGlmeSIsImlzQXJyYXlfMSIsImhhc1JlcXVpcmVkSXNBcnJheSIsInJlcXVpcmVJc0FycmF5IiwiX2lzS2V5IiwiaGFzUmVxdWlyZWRfaXNLZXkiLCJyZXF1aXJlX2lzS2V5IiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiaXNGdW5jdGlvbl8xIiwiaGFzUmVxdWlyZWRJc0Z1bmN0aW9uIiwicmVxdWlyZUlzRnVuY3Rpb24iLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJfY29yZUpzRGF0YSIsImhhc1JlcXVpcmVkX2NvcmVKc0RhdGEiLCJyZXF1aXJlX2NvcmVKc0RhdGEiLCJjb3JlSnNEYXRhIiwiX2lzTWFza2VkIiwiaGFzUmVxdWlyZWRfaXNNYXNrZWQiLCJyZXF1aXJlX2lzTWFza2VkIiwibWFza1NyY0tleSIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJfdG9Tb3VyY2UiLCJoYXNSZXF1aXJlZF90b1NvdXJjZSIsInJlcXVpcmVfdG9Tb3VyY2UiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsIl9iYXNlSXNOYXRpdmUiLCJoYXNSZXF1aXJlZF9iYXNlSXNOYXRpdmUiLCJyZXF1aXJlX2Jhc2VJc05hdGl2ZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwiX2dldFZhbHVlIiwiaGFzUmVxdWlyZWRfZ2V0VmFsdWUiLCJyZXF1aXJlX2dldFZhbHVlIiwiZ2V0VmFsdWUiLCJfZ2V0TmF0aXZlIiwiaGFzUmVxdWlyZWRfZ2V0TmF0aXZlIiwicmVxdWlyZV9nZXROYXRpdmUiLCJnZXROYXRpdmUiLCJfbmF0aXZlQ3JlYXRlIiwiaGFzUmVxdWlyZWRfbmF0aXZlQ3JlYXRlIiwicmVxdWlyZV9uYXRpdmVDcmVhdGUiLCJuYXRpdmVDcmVhdGUiLCJfaGFzaENsZWFyIiwiaGFzUmVxdWlyZWRfaGFzaENsZWFyIiwicmVxdWlyZV9oYXNoQ2xlYXIiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsIl9oYXNoRGVsZXRlIiwiaGFzUmVxdWlyZWRfaGFzaERlbGV0ZSIsInJlcXVpcmVfaGFzaERlbGV0ZSIsImhhc2hEZWxldGUiLCJfaGFzaEdldCIsImhhc1JlcXVpcmVkX2hhc2hHZXQiLCJyZXF1aXJlX2hhc2hHZXQiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hHZXQiLCJfaGFzaEhhcyIsImhhc1JlcXVpcmVkX2hhc2hIYXMiLCJyZXF1aXJlX2hhc2hIYXMiLCJoYXNoSGFzIiwiX2hhc2hTZXQiLCJoYXNSZXF1aXJlZF9oYXNoU2V0IiwicmVxdWlyZV9oYXNoU2V0IiwiaGFzaFNldCIsIl9IYXNoIiwiaGFzUmVxdWlyZWRfSGFzaCIsInJlcXVpcmVfSGFzaCIsIkhhc2giLCJlbnRyaWVzIiwiX2xpc3RDYWNoZUNsZWFyIiwiaGFzUmVxdWlyZWRfbGlzdENhY2hlQ2xlYXIiLCJyZXF1aXJlX2xpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlQ2xlYXIiLCJlcV8xIiwiaGFzUmVxdWlyZWRFcSIsInJlcXVpcmVFcSIsImVxIiwiX2Fzc29jSW5kZXhPZiIsImhhc1JlcXVpcmVkX2Fzc29jSW5kZXhPZiIsInJlcXVpcmVfYXNzb2NJbmRleE9mIiwiYXNzb2NJbmRleE9mIiwiX2xpc3RDYWNoZURlbGV0ZSIsImhhc1JlcXVpcmVkX2xpc3RDYWNoZURlbGV0ZSIsInJlcXVpcmVfbGlzdENhY2hlRGVsZXRlIiwiYXJyYXlQcm90byIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsIl9saXN0Q2FjaGVHZXQiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVHZXQiLCJyZXF1aXJlX2xpc3RDYWNoZUdldCIsImxpc3RDYWNoZUdldCIsIl9saXN0Q2FjaGVIYXMiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVIYXMiLCJyZXF1aXJlX2xpc3RDYWNoZUhhcyIsImxpc3RDYWNoZUhhcyIsIl9saXN0Q2FjaGVTZXQiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVTZXQiLCJyZXF1aXJlX2xpc3RDYWNoZVNldCIsImxpc3RDYWNoZVNldCIsIl9MaXN0Q2FjaGUiLCJoYXNSZXF1aXJlZF9MaXN0Q2FjaGUiLCJyZXF1aXJlX0xpc3RDYWNoZSIsIkxpc3RDYWNoZSIsIl9NYXAiLCJoYXNSZXF1aXJlZF9NYXAiLCJyZXF1aXJlX01hcCIsIl9tYXBDYWNoZUNsZWFyIiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVDbGVhciIsInJlcXVpcmVfbWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlQ2xlYXIiLCJfaXNLZXlhYmxlIiwiaGFzUmVxdWlyZWRfaXNLZXlhYmxlIiwicmVxdWlyZV9pc0tleWFibGUiLCJpc0tleWFibGUiLCJfZ2V0TWFwRGF0YSIsImhhc1JlcXVpcmVkX2dldE1hcERhdGEiLCJyZXF1aXJlX2dldE1hcERhdGEiLCJnZXRNYXBEYXRhIiwiX21hcENhY2hlRGVsZXRlIiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVEZWxldGUiLCJyZXF1aXJlX21hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVEZWxldGUiLCJfbWFwQ2FjaGVHZXQiLCJoYXNSZXF1aXJlZF9tYXBDYWNoZUdldCIsInJlcXVpcmVfbWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUdldCIsIl9tYXBDYWNoZUhhcyIsImhhc1JlcXVpcmVkX21hcENhY2hlSGFzIiwicmVxdWlyZV9tYXBDYWNoZUhhcyIsIm1hcENhY2hlSGFzIiwiX21hcENhY2hlU2V0IiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVTZXQiLCJyZXF1aXJlX21hcENhY2hlU2V0IiwibWFwQ2FjaGVTZXQiLCJfTWFwQ2FjaGUiLCJoYXNSZXF1aXJlZF9NYXBDYWNoZSIsInJlcXVpcmVfTWFwQ2FjaGUiLCJNYXBDYWNoZSIsIm1lbW9pemVfMSIsImhhc1JlcXVpcmVkTWVtb2l6ZSIsInJlcXVpcmVNZW1vaXplIiwibWVtb2l6ZWQiLCJDYWNoZSIsIl9tZW1vaXplQ2FwcGVkIiwiaGFzUmVxdWlyZWRfbWVtb2l6ZUNhcHBlZCIsInJlcXVpcmVfbWVtb2l6ZUNhcHBlZCIsIk1BWF9NRU1PSVpFX1NJWkUiLCJtZW1vaXplQ2FwcGVkIiwiX3N0cmluZ1RvUGF0aCIsImhhc1JlcXVpcmVkX3N0cmluZ1RvUGF0aCIsInJlcXVpcmVfc3RyaW5nVG9QYXRoIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsInF1b3RlIiwic3ViU3RyaW5nIiwiX2FycmF5TWFwIiwiaGFzUmVxdWlyZWRfYXJyYXlNYXAiLCJyZXF1aXJlX2FycmF5TWFwIiwiYXJyYXlNYXAiLCJpdGVyYXRlZSIsIl9iYXNlVG9TdHJpbmciLCJoYXNSZXF1aXJlZF9iYXNlVG9TdHJpbmciLCJyZXF1aXJlX2Jhc2VUb1N0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJ0b1N0cmluZ18xIiwiaGFzUmVxdWlyZWRUb1N0cmluZyIsInJlcXVpcmVUb1N0cmluZyIsIl9jYXN0UGF0aCIsImhhc1JlcXVpcmVkX2Nhc3RQYXRoIiwicmVxdWlyZV9jYXN0UGF0aCIsImNhc3RQYXRoIiwiX3RvS2V5IiwiaGFzUmVxdWlyZWRfdG9LZXkiLCJyZXF1aXJlX3RvS2V5IiwidG9LZXkiLCJfYmFzZUdldCIsImhhc1JlcXVpcmVkX2Jhc2VHZXQiLCJyZXF1aXJlX2Jhc2VHZXQiLCJiYXNlR2V0IiwiZ2V0XzEiLCJoYXNSZXF1aXJlZEdldCIsInJlcXVpcmVHZXQiLCJkZWZhdWx0VmFsdWUiLCJnZXRFeHBvcnRzIiwiX2RlZmluZVByb3BlcnR5IiwiaGFzUmVxdWlyZWRfZGVmaW5lUHJvcGVydHkiLCJyZXF1aXJlX2RlZmluZVByb3BlcnR5IiwiX2Jhc2VBc3NpZ25WYWx1ZSIsImhhc1JlcXVpcmVkX2Jhc2VBc3NpZ25WYWx1ZSIsInJlcXVpcmVfYmFzZUFzc2lnblZhbHVlIiwiYmFzZUFzc2lnblZhbHVlIiwiX2Fzc2lnblZhbHVlIiwiaGFzUmVxdWlyZWRfYXNzaWduVmFsdWUiLCJyZXF1aXJlX2Fzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsIl9pc0luZGV4IiwiaGFzUmVxdWlyZWRfaXNJbmRleCIsInJlcXVpcmVfaXNJbmRleCIsInJlSXNVaW50IiwiaXNJbmRleCIsIl9iYXNlU2V0IiwiaGFzUmVxdWlyZWRfYmFzZVNldCIsInJlcXVpcmVfYmFzZVNldCIsImJhc2VTZXQiLCJjdXN0b21pemVyIiwibmVzdGVkIiwibmV3VmFsdWUiLCJzZXRfMSIsImhhc1JlcXVpcmVkU2V0IiwicmVxdWlyZVNldCIsInNldEV4cG9ydHMiLCJfY29weUFycmF5IiwiaGFzUmVxdWlyZWRfY29weUFycmF5IiwicmVxdWlyZV9jb3B5QXJyYXkiLCJ0b1BhdGhfMSIsImhhc1JlcXVpcmVkVG9QYXRoIiwicmVxdWlyZVRvUGF0aCIsInRvUGF0aCIsInRvUGF0aEV4cG9ydHMiLCJkZWZpbmUkMiIsImZpZWxkIiwiYmluZGluZ0V2ZW50IiwiYWxsb3dCaW5kaW5nIiwiYWxsb3dTZXR0aW5nIiwiYWxsb3dHZXR0aW5nIiwic2V0dGluZ0V2ZW50Iiwic2V0dGluZ1RyaWdnZXJzRXZlbnQiLCJ0cmlnZ2VyRm5OYW1lIiwiaW1tdXRhYmxlS2V5cyIsInVwZGF0ZVN0eWxlIiwiYmVmb3JlR2V0IiwiYmVmb3JlU2V0Iiwib25TZXQiLCJjYW5TZXQiLCJkYXRhSW1wbCIsImlzUGF0aExpa2UiLCJ2YWxpZCIsImNoYW5nZSIsIl92YWxpZCIsIl9lbGUiLCJvbiIsInJlbW92ZURhdGEiLCJ0cmlnZ2VyRXZlbnQiLCJyZW1vdmVEYXRhSW1wbCIsIm5hbWVzIiwiaV9hIiwibF9hIiwiX2lfYSIsIl9sX2EiLCJfcHJpdmF0ZUZpZWxkcyIsIl9rZXlzIiwiX2tleSIsInZhbGlkS2V5VG9EZWxldGUiLCJkZWZpbmUkMSIsImV2ZW50QWxpYXNlc09uIiwicHJvdG8iLCJhZGRMaXN0ZW5lciIsImxpc3RlbiIsInVubGlzdGVuIiwidW5iaW5kIiwicmVtb3ZlTGlzdGVuZXIiLCJ0cmlnZ2VyIiwiZW1pdCIsInBvbiIsInByb21pc2VPbiIsImV2ZW50cyIsInNlbGVjdG9yIiwib2ZmQXJncyIsIm9uQXJncyIsImRlZmluZSIsImVsZXNmbiRpIiwiZWxlc2ZuJGgiLCJfY2xhc3NlcyIsImNoYW5nZWQiLCJjbGFzc2VzU2V0IiwiZWxlQ2xhc3NlcyIsImNoYW5nZWRFbGUiLCJlbGVIYXNDbGFzcyIsImFkZENsYXNzIiwidG9nZ2xlQ2xhc3MiLCJoYXNDbGFzcyIsImNsYXNzTmFtZSIsInRvZ2dsZSIsInRvZ2dsZVVuZGVmZCIsImlsIiwiY2hhbmdlZE5vdyIsInJlbW92ZUNsYXNzIiwiZmxhc2hDbGFzcyIsImNsYXNzTmFtZXMiLCJ0b2tlbnMiLCJtZXRhQ2hhciIsImNvbXBhcmF0b3JPcCIsImJvb2xPcCIsIm1ldGEiLCJzZXBhcmF0b3IiLCJkZXNjZW5kYW50IiwiY2hpbGQiLCJzdWJqZWN0IiwiZGlyZWN0ZWRFZGdlIiwidW5kaXJlY3RlZEVkZ2UiLCJ2YXJpYWJsZSIsIm9wcyIsIm9wIiwibmV3UXVlcnkiLCJjaGVja3MiLCJUeXBlIiwiR1JPVVAiLCJDT0xMRUNUSU9OIiwiRklMVEVSIiwiREFUQV9DT01QQVJFIiwiREFUQV9FWElTVCIsIkRBVEFfQk9PTCIsIk1FVEFfQ09NUEFSRSIsIlNUQVRFIiwiSUQiLCJDTEFTUyIsIlVORElSRUNURURfRURHRSIsIkRJUkVDVEVEX0VER0UiLCJOT0RFX1NPVVJDRSIsIk5PREVfVEFSR0VUIiwiTk9ERV9ORUlHSEJPUiIsIkNISUxEIiwiREVTQ0VOREFOVCIsIlBBUkVOVCIsIkFOQ0VTVE9SIiwiQ09NUE9VTkRfU1BMSVQiLCJUUlVFIiwic3RhdGVTZWxlY3RvcnMiLCJtYXRjaGVzIiwidmlzaWJsZSIsImlzUGFyZW50IiwiaXNDaGlsZGxlc3MiLCJpc0NoaWxkIiwiaXNPcnBoYW4iLCJpc1NpbXBsZSIsImxvb2t1cCIsInNlbFRvRm4iLCJzdGF0ZVNlbGVjdG9yTWF0Y2hlcyIsInNlbCIsInN0YXRlU2VsZWN0b3JSZWdleCIsImNsZWFuTWV0YUNoYXJzIiwiJDEiLCJyZXBsYWNlTGFzdFF1ZXJ5IiwiZXhhbWluaW5nUXVlcnkiLCJyZXBsYWNlbWVudFF1ZXJ5IiwiZXhwcnMiLCJxdWVyeSIsInJlZ2V4IiwicG9wdWxhdGUiLCJfcmVmMiIsIl9yZWYzIiwiX3JlZjQiLCJfcmVmNSIsIl9yZWY2IiwiX3JlZjciLCJfcmVmOCIsIl9yZWY5IiwiX3JlZjEwIiwiX3JlZjExIiwiX3JlZjEyIiwidmFsdWVJc1N0cmluZyIsIm9wZXJhdG9yIiwiX3JlZjEzIiwiX3JlZjE0IiwiX3JlZjE1IiwiX3JlZjE2IiwiY3VycmVudFN1YmplY3QiLCJjb21wb3VuZENvdW50IiwibGFzdFEiLCJuZXh0UXVlcnkiLCJlZGdlUXVlcnkiLCJzcmNUZ3RRIiwiX3NvdXJjZSIsIl90YXJnZXQiLCJuaG9vZFEiLCJuZWlnaGJvciIsInBhcmVudENoaWxkUXVlcnkiLCJjb21wb3VuZCIsIl9jaGlsZCIsIl9wYXJlbnQiLCJfcGFyZW50MiIsIl9jaGlsZDIiLCJwY1FDaGVja3MiLCJhbmNDaFF1ZXJ5IiwiYW5jZXN0b3IiLCJfZGVzY2VuZGFudCIsIl9hbmNlc3RvciIsIl9hbmNlc3RvcjIiLCJfZGVzY2VuZGFudDIiLCJhZFFDaGVja3MiLCJtb2RpZmllciIsInRvcFEiLCJ0b3BDaGsiLCJ0b3BUeXBlIiwicmVnZXhPYmoiLCJjb25zdW1lRXhwciIsInJlbWFpbmluZyIsImV4cHIiLCJjb25zdW1lZCIsImNvbnN1bWVXaGl0ZXNwYWNlIiwicGFyc2UiLCJpbnB1dFRleHQiLCJjdXJyZW50UXVlcnkiLCJleHBySW5mbyIsInRvU3RyaW5nQ2FjaGUiLCJjbGVhbiIsImNsZWFuVmFsIiwic3BhY2UiLCJjaGVja1RvU3RyaW5nIiwiY2hlY2siLCJfb3BlcmF0b3IiLCJfZmllbGQiLCJfZmllbGQyIiwiX29wZXJhdG9yMiIsIl9maWVsZDMiLCJxdWVyeVRvU3RyaW5nIiwibGhzIiwicmhzIiwicmVkdWNlIiwiY2hrIiwicGFyc2UkMSIsInZhbENtcCIsImZpZWxkVmFsIiwiaXNGaWVsZFN0ciIsImlzRmllbGROdW0iLCJpc1ZhbFN0ciIsImZpZWxkU3RyIiwidmFsU3RyIiwiY2FzZUluc2Vuc2l0aXZlIiwibm90RXhwciIsImlzSW5lcUNtcCIsImJvb2xDbXAiLCJleGlzdENtcCIsImRhdGEkMSIsIm1hdGNoZXMkMSIsImV2ZXJ5Iiwic3RhdGVTZWxlY3RvciIsInFBIiwicUIiLCJpbmNvbWVycyIsImFuY2VzdG9ycyIsImRlc2NlbmRhbnRzIiwic2VsZWN0b3JGdW5jdGlvbiIsInRleHQiLCJtYXRjaGluZyIsIlNlbGVjdG9yIiwiYWRkUXVlcnkiLCJpbnZhbGlkIiwic2VsZm4iLCJzYW1lVGV4dCIsIm90aGVyU2VsIiwiZWxlc2ZuJGciLCJhbGxBcmUiLCJzZWxPYmoiLCJpcyIsInRoaXNMZW5ndGgiLCJjb2xsZWN0aW9uTGVuZ3RoIiwiYW55U2FtZSIsImFsbEFyZU5laWdoYm9ycyIsIm5ob29kIiwiYWxsQXJlTmVpZ2hib3VycyIsImVxdWFsIiwiZXF1YWxzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsInNlbGVjdG9yT3JFbGVzIiwidGNoIiwiY2giLCJjYWNoZUhpdCIsImVsZXNmbiRmIiwicGFyZW50cyIsIm5vbmVtcHR5IiwiY29tbW9uQW5jZXN0b3JzIiwib3JwaGFucyIsInN0ZEZpbHRlciIsIm5vbm9ycGhhbnMiLCJlbGVDaGlsZHJlbiIsInNpYmxpbmdzIiwibm90IiwiZWxlbWVudHMiLCJmb3JFYWNoQ29tcG91bmQiLCJpbmNsdWRlU2VsZiIsInJlY3Vyc2l2ZVN0ZXAiLCJkaWQiLCJoYXNDb21wb3VuZHMiLCJoYXNDb21wb3VuZE5vZGVzIiwiYWRkQ2hpbGRyZW4iLCJmb3JFYWNoRG93biIsImFkZFBhcmVudCIsImZvckVhY2hVcCIsImFkZFBhcmVudEFuZENoaWxkcmVuIiwiZm9yRWFjaFVwQW5kRG93biIsImZuJDUiLCJlbGVzZm4kZSIsInJlbW92ZVNjcmF0Y2giLCJyZW1vdmVSc2NyYXRjaCIsInJlbW92ZUF0dHIiLCJlbGVzZm4kZCIsImRlZmluZURlZ3JlZUZ1bmN0aW9uIiwiaW5jbHVkZUxvb3BzIiwiZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24iLCJkZWdyZWVGbiIsIm1pbkRlZ3JlZSIsIm1pbkluZGVncmVlIiwibWluT3V0ZGVncmVlIiwidG90YWxEZWdyZWUiLCJmbiQ0IiwiZWxlc2ZuJGMiLCJiZWZvcmVQb3NpdGlvblNldCIsIm5ld1BvcyIsInNpbGVudCIsIm9sZFBvcyIsImRpcnR5Qm91bmRpbmdCb3hDYWNoZSIsInBvc2l0aW9uRGVmIiwidmFsaWRLZXlzIiwidXBkYXRlQ29tcG91bmRCb3VuZHMiLCJkaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUiLCJzaWxlbnRQb3NpdGlvbiIsInBvc2l0aW9ucyIsIl9mbiIsInN0YXJ0QmF0Y2giLCJfcG9zIiwiZW5kQmF0Y2giLCJzaWxlbnRQb3NpdGlvbnMiLCJzaWxlbnRTaGlmdCIsInNldHRpbmciLCJyZWxhdGl2ZVBvc2l0aW9uIiwicHBvcyIsIl9lbGUyIiwiaGFzUGFyZW50IiwicmVsYXRpdmVUb1BhcmVudCIsIm9yaWdpbiIsIl9oYXNQYXJlbnQiLCJfcmVsYXRpdmVUb1BhcmVudCIsIl9vcmlnaW4iLCJtb2RlbFBvc2l0aW9uIiwibW9kZWxQb3NpdGlvbnMiLCJyZW5kZXJlZFBvaW50IiwicmVsYXRpdmVQb2ludCIsImZuJDMiLCJlbGVzZm4kYiIsInJlbmRlcmVkQm91bmRpbmdCb3giLCJlbWl0QW5kTm90aWZ5IiwiZm9yY2UiLCJiYXRjaGluZyIsInVwZGF0ZSIsImluY2x1ZGVMYWJlbHMiLCJwc3R5bGUiLCJwZlZhbHVlIiwiaW5jbHVkZU92ZXJsYXlzIiwidXNlQ2FjaGUiLCJjb21wdXRlQmlhc1ZhbHVlcyIsInByb3BEaWZmIiwicHJvcEJpYXMiLCJwcm9wQmlhc0NvbXBsZW1lbnQiLCJiaWFzRGlmZiIsImJpYXNDb21wbGVtZW50RGlmZiIsImJpYXNUb3RhbCIsImNvbXB1dGVQYWRkaW5nVmFsdWVzIiwicGFkZGluZ09iamVjdCIsInJlbGF0aXZlVG8iLCJ1bml0cyIsImxlZnRWYWwiLCJyaWdodFZhbCIsInRvcFZhbCIsImJvdHRvbVZhbCIsIndpZHRoQmlhc0RpZmZzIiwiZGlmZkxlZnQiLCJkaWZmUmlnaHQiLCJoZWlnaHRCaWFzRGlmZnMiLCJkaWZmVG9wIiwiZGlmZkJvdHRvbSIsIm5vbmluZiIsInVwZGF0ZUJvdW5kcyIsInVwZGF0ZUJvdW5kc0Zyb21Cb3giLCJiMiIsInByZWZpeGVkUHJvcGVydHkiLCJ1cGRhdGVCb3VuZHNGcm9tQXJyb3ciLCJib3VuZHMiLCJoZWFkbGVzcyIsImhhbGZBclciLCJhcnJvd1dpZHRoIiwiYXJyb3dUeXBlIiwic3JjWCIsInNyY1kiLCJ0Z3RYIiwidGd0WSIsIm1pZFgiLCJtaWRZIiwiYmJzIiwidXBkYXRlQm91bmRzRnJvbUxhYmVsIiwicHJlZml4RGFzaCIsImxhYmVsIiwic3RyVmFsdWUiLCJoYWxpZ24iLCJ2YWxpZ24iLCJsYWJlbFdpZHRoIiwibGFiZWxIZWlnaHQiLCJsYWJlbFgiLCJsYWJlbFkiLCJtYXJnaW5YIiwibWFyZ2luWSIsInJvdGF0aW9uIiwib3V0bGluZVdpZHRoIiwiYm9yZGVyV2lkdGgiLCJoYWxmQm9yZGVyV2lkdGgiLCJtYXJnaW5PZkVycm9yIiwibGgiLCJsdyIsImx3XzIiLCJsaF8yIiwibGVmdFBhZCIsInJpZ2h0UGFkIiwidG9wUGFkIiwiYm90UGFkIiwiYmJQcmVmaXgiLCJpc0F1dG9yb3RhdGUiLCJpc1BmVmFsdWUiLCJ0aGV0YSIsInhvIiwieW8iLCJyb3RhdGUiLCJweDF5MSIsInB4MXkyIiwicHgyeTEiLCJweDJ5MiIsImJiUHJlZml4Um90IiwiYmJSb3QiLCJ1cGRhdGVCb3VuZHNGcm9tT3V0bGluZSIsIm91dGxpbmVPcGFjaXR5Iiwib3V0bGluZU9mZnNldCIsImV4cGFuc2lvbiIsInVwZGF0ZUJvdW5kc0Zyb21NaXRlciIsIm9wYWNpdHkiLCJleHBhbnNpb25TaXplIiwiZXhwYW5zaW9uUG9zaXRpb24iLCJ1c2VGYWxsYmFja1ZhbHVlIiwic2hhcGUiLCJyc2hhcGUiLCJyZW5kZXJlciIsIm5vZGVTaGFwZXMiLCJfZWxlJHBvc2l0aW9uIiwiaGFzTWl0ZXJCb3VuZHMiLCJtYmIiLCJtaXRlckJvdW5kcyIsInVwZGF0ZUJvdW5kc0Zyb21NaXRlckJvcmRlciIsImJvcmRlck9wYWNpdHkiLCJib3JkZXJQb3NpdGlvbiIsImJvdW5kaW5nQm94SW1wbCIsImV4MSIsImV4MiIsImV5MSIsImV5MiIsIm1hbnVhbEV4cGFuc2lvbiIsImlzRGlzcGxheWVkIiwiZGlzcGxheWVkIiwib3ZlcmxheU9wYWNpdHkiLCJvdmVybGF5UGFkZGluZyIsInVuZGVybGF5T3BhY2l0eSIsInVuZGVybGF5UGFkZGluZyIsImluY2x1ZGVVbmRlcmxheXMiLCJ3SGFsZiIsImluY2x1ZGVOb2RlcyIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsImluY2x1ZGVPdXRsaW5lcyIsImluY2x1ZGVFZGdlcyIsImN1cnZlU3R5bGUiLCJocHRzIiwiaGF5c3RhY2tQdHMiLCJfdGVtcCIsImJlemllclB0cyIsImxpbmVQdHMiLCJuMXBvcyIsIm4ycG9zIiwiX3RlbXAyIiwiX3RlbXAzIiwiZ2hvc3QiLCJneCIsImd5IiwiYmJCb2R5IiwiYmJPdmVybGF5IiwiYmJMYWJlbHMiLCJpbmNsdWRlTWFpbkxhYmVscyIsImluY2x1ZGVTb3VyY2VMYWJlbHMiLCJpbmNsdWRlVGFyZ2V0TGFiZWxzIiwiZ2V0S2V5IiwidGYiLCJpbmN1ZGVOb2RlcyIsImdldEJvdW5kaW5nQm94UG9zS2V5IiwiY2FjaGVkQm91bmRpbmdCb3hJbXBsIiwiZGVmQmJPcHRzS2V5IiwidXNpbmdEZWZPcHRzIiwiZGVmQmJPcHRzIiwiYmJDYWNoZVBvc0tleSIsIm1haW5Sb3QiLCJzb3VyY2VSb3QiLCJ0YXJnZXRSb3QiLCJmaWxsZWRCYk9wdHMiLCJpc0RpcnR5Iiwic3R5bGVEaXJ0eSIsInJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSIsImJvdW5kaW5nQm94QXQiLCJzdG9yZU9sZFBvcyIsImJiQXRPbGRQb3MiLCJnZXRPbGRQb3MiLCJib3VuZGluZ2JveCIsInJlbmRlcmVkQm91bmRpbmdib3giLCJmbiQyIiwiZWxlc2ZuJGEiLCJkZWZpbmVEaW1GbnMiLCJ1cHBlcmNhc2VOYW1lIiwiYXV0b05hbWUiLCJsYWJlbE5hbWUiLCJvdXRlck5hbWUiLCJ1cHBlcmNhc2VPdXRlck5hbWUiLCJkaW1JbXBsIiwib3V0ZXJEaW1JbXBsIiwiYm9yZGVyUG9zIiwiYm9yZGVyIiwicmVuZGVyZWREaW1JbXBsIiwicmVuZGVyZWRPdXRlckRpbUltcGwiLCJvZCIsInBhZGRlZEhlaWdodCIsInBhZGRlZFdpZHRoIiwid2lkdGhIZWlnaHQiLCJpZkVkZ2UiLCJ0YWtlc1VwU3BhY2UiLCJpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uIiwiZ2V0UG9pbnQiLCJpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyIsImdldFBvaW50cyIsImNvbnRyb2xQb2ludHMiLCJnZXRDb250cm9sUG9pbnRzIiwic2VnbWVudFBvaW50cyIsImdldFNlZ21lbnRQb2ludHMiLCJzb3VyY2VFbmRwb2ludCIsImdldFNvdXJjZUVuZHBvaW50IiwidGFyZ2V0RW5kcG9pbnQiLCJnZXRUYXJnZXRFbmRwb2ludCIsIm1pZHBvaW50IiwiZ2V0RWRnZU1pZHBvaW50IiwibXVsdCIsInJlbmRlcmVkTmFtZSIsInN1YnN0ciIsImVkZ2VQb2ludHMiLCJzcGVjIiwick5hbWUiLCJkaW1lbnNpb25zIiwiRXZlbnQiLCJyZWN5Y2xlIiwicmV0dXJuRmFsc2UiLCJyZXR1cm5UcnVlIiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsInByZXZlbnREZWZhdWx0IiwiZGVmYXVsdFByZXZlbnRlZCIsIm9yaWdpbmFsRXZlbnQiLCJuYW1lc3BhY2UiLCJsYXlvdXQiLCJ0aW1lU3RhbXAiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJldmVudFJlZ2V4IiwidW5pdmVyc2FsTmFtZXNwYWNlIiwiZGVmYXVsdHMkOCIsInF1YWxpZmllckNvbXBhcmUiLCJxMSIsInEyIiwiZXZlbnRNYXRjaGVzIiwiYWRkRXZlbnRGaWVsZHMiLCJjYWxsYmFja0NvbnRleHQiLCJjb250ZXh0IiwiYmVmb3JlRW1pdCIsImFmdGVyRW1pdCIsImJ1YmJsZSIsImRlZmF1bHRzS2V5cyIsImVtcHR5T3B0cyIsIkVtaXR0ZXIiLCJlbWl0dGluZyIsImZvckVhY2hFdmVudCIsImhhbmRsZXIiLCJxdWFsaWZpZXIiLCJjb25mIiwiY29uZk92ZXJyaWRlcyIsImV2ZW50TGlzdCIsImV2dCIsIm1ha2VFdmVudE9iaiIsImZvckVhY2hFdmVudE9iaiIsImV2ZW50T2JqIiwib25lIiwibGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJleHRyYVBhcmFtcyIsIm1hbnVhbENhbGxiYWNrIiwibnVtTGlzdGVuZXJzQmVmb3JlRW1pdCIsIl9sb29wMiIsImVtaXR0ZXJPcHRpb25zJDEiLCJzZWxlY3RvcjEiLCJzZWxlY3RvcjIiLCJvbmNlIiwib25jZUNvbGxlY3Rpb24iLCJhcmdTZWxlY3RvciQxIiwiYXJnU2VsZWN0b3IiLCJhcmciLCJlbGVzZm4kOSIsImVtaXR0ZXIiLCJhcmdTZWwiLCJlbGVzZm4kOCIsIl9maWx0ZXIiLCJmaWx0ZXJFbGVzIiwiaW5jbHVkZSIsInRvUmVtb3ZlIiwicmVtb3ZlIiwiYWJzb2x1dGVDb21wbGVtZW50IiwibXV0YWJsZUVsZW1lbnRzIiwiY29sMSIsImNvbDIiLCJjb2wxU21hbGxlciIsImNvbFMiLCJjb2xMIiwieG9yIiwiaW5PdGhlciIsImJvdGgiLCJyZXRFbGVzIiwidG9BZGQiLCJzcGF3blNlbGYiLCJ0b0FkZEVsZSIsInVubWVyZ2VBdCIsInVubWVyZ2VkTGFzdEVsZSIsImxhc3RFbGVJIiwibGFzdEVsZSIsImxhc3RFbGVJZCIsInVubWVyZ2VPbmUiLCJ1bm1lcmdlIiwidG9SbUZuIiwibWFwRm4iLCJpbml0aWFsVmFsdWUiLCJ2YWxGbiIsIm1heEVsZSIsIm1pbkVsZSIsImZuJDEiLCJ1bmlvbiIsIm9yIiwicmVsYXRpdmVDb21wbGVtZW50Iiwic3VidHJhY3QiLCJhbmQiLCJzeW1tZXRyaWNEaWZmZXJlbmNlIiwic3ltZGlmZiIsImZuRmlsdGVyIiwiZmlsdGVyRm4iLCJjb21wbGVtZW50IiwiYWJzY29tcCIsImVsZXNmbiQ3IiwiekluZGV4U29ydCIsImdldERlcHRoIiwiekRlcHRoIiwiZGVwdGhEaWZmIiwiZ2V0RWxlRGVwdGgiLCJlbGVEaWZmIiwiekRpZmYiLCJwb29sSW5kZXgiLCJlbGVzZm4kNiIsInRoaXNTaXplIiwiZmlyc3QiLCJsYXN0Iiwic29ydEZuIiwic29ydGVkIiwic29ydEJ5WkluZGV4Iiwic3JjRGVwdGgiLCJ0Z3REZXB0aCIsImVhY2giLCJkZWZpbmVTeW1ib2xJdGVyYXRvciIsInR5cGVvZlVuZGVmIiwiaXNJdGVyYXRvclN1cHBvcnRlZCIsImdldExheW91dERpbWVuc2lvbk9wdGlvbnMiLCJub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMiLCJlbGVzZm4kNSIsImxheW91dERpbWVuc2lvbnMiLCJkaW1zIiwiYmJEaW0iLCJsYXlvdXRQb3NpdGlvbnMiLCJsYXlvdXRFbGVzIiwiZ2V0TWVtb2l6ZUtleSIsImZuTWVtIiwiYW5pbWF0aW9ucyIsImNhbGN1bGF0ZVNwYWNpbmciLCJzcGFjaW5nIiwibm9kZXNCYiIsInNwYWNpbmdWZWN0b3IiLCJ1c2VTcGFjaW5nRmFjdG9yIiwic3BhY2luZ0ZhY3RvciIsInNwYWNpbmdCYiIsImdldEZpbmFsUG9zIiwidHJhbnNmb3JtIiwiYW5pbWF0ZU5vZGUiLCJhbmltYXRlRmlsdGVyIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJlYXNpbmciLCJhbmltYXRpb25FYXNpbmciLCJmaXRBbmkiLCJ6b29tUGFuQW5pIiwicmVhZHkiLCJtYWtlTGF5b3V0IiwiY3JlYXRlTGF5b3V0Iiwic3R5bGVDYWNoZSIsImNhY2hlU3R5bGVGdW5jdGlvbiIsImNhY2hlZFN0eWxlRnVuY3Rpb24iLCJjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24iLCJzZWxmRm4iLCJjYWNoZWRQcm90b3R5cGVTdHlsZUZ1bmN0aW9uIiwiZWxlc2ZuJDQiLCJkaXJ0eVN0eWxlQ2FjaGUiLCJkaXJ0eSIsIm5vdGlmeVJlbmRlcmVyIiwiYkVsZXMiLCJiYXRjaFN0eWxlRWxlcyIsInVwZGF0ZWRFbGVzIiwiY2hhbmdlZEVsZXMiLCJjbGVhblN0eWxlIiwicGFyc2VkU3R5bGUiLCJwcm9wZXJ0eSIsImluY2x1ZGVOb25EZWZhdWx0Iiwib3ZlcnJpZGRlblN0eWxlIiwiZ2V0RGVmYXVsdFByb3BlcnR5IiwibnVtZXJpY1N0eWxlIiwibnVtZXJpY1N0eWxlVW5pdHMiLCJyZW5kZXJlZFN0eWxlIiwiZ2V0UmVuZGVyZWRTdHlsZSIsInVwZGF0ZVRyYW5zaXRpb25zIiwiYXBwbHlCeXBhc3MiLCJnZXRTdHlsZVByb3BlcnR5VmFsdWUiLCJnZXRSYXdTdHlsZSIsInJlbW92ZVN0eWxlIiwicmVtb3ZlQWxsQnlwYXNzZXMiLCJyZW1vdmVCeXBhc3NlcyIsInNob3ciLCJoaWRlIiwiZWZmZWN0aXZlT3BhY2l0eSIsInBhcmVudE9wYWNpdHkiLCJjaGVja0NvbXBvdW5kIiwicGFyZW50T2siLCJkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbiIsInNwZWNzIiwib2siLCJlZGdlT2tWaWFOb2RlIiwiZWxlVGFrZXNVcFNwYWNlIiwiZWxlSW50ZXJhY3RpdmUiLCJwYXJlbnRJbnRlcmFjdGl2ZSIsImludGVyYWN0aXZlIiwibm9uaW50ZXJhY3RpdmUiLCJlbGVWaXNpYmxlIiwiZWRnZVZpc2libGVWaWFOb2RlIiwiaGlkZGVuIiwiaXNCdW5kbGVkQmV6aWVyIiwicmVuZGVyZWRDc3MiLCJyZW1vdmVCeXBhc3MiLCJyZW1vdmVDc3MiLCJlbGVzZm4kMyIsImRlZmluZVN3aXRjaEZ1bmN0aW9uIiwiX2hhbmRsZXIiLCJhZGRsRXZlbnRzIiwiYWJsZSIsImFibGVGaWVsZCIsIm92ZXJyaWRlQWJsZSIsImNoYW5nZWRDb2xsIiwiZGVmaW5lU3dpdGNoU2V0Iiwib3ZlcnJpZGVGaWVsZCIsImF1dG9sb2NrIiwiYXV0b3VuZ3JhYmlmeSIsImF1dG91bnNlbGVjdGlmeSIsImRlc2VsZWN0IiwidW5zZWxlY3QiLCJpbmFjdGl2ZSIsImVsZXNmbiQyIiwiZGVmaW5lRGFnRXh0cmVtaXR5IiwiZGFnRXh0cmVtaXR5SW1wbCIsImRpc3F1YWxpZmllZCIsIm5vSW5jb21pbmdFZGdlcyIsIm5vT3V0Z29pbmdFZGdlcyIsImRlZmluZURhZ09uZUhvcCIsIm9FbGVzIiwiZGVmaW5lRGFnQWxsSG9wcyIsInNFbGVzIiwic0VsZXNJZHMiLCJuZXdOZXh0IiwibmlkIiwiY2xlYXJUcmF2ZXJzYWxDYWNoZSIsInN1Y2Nlc3NvcnMiLCJwcmVkZWNlc3NvcnMiLCJvdGhlck5vZGUiLCJjbG9zZWROZWlnaGJvcmhvb2QiLCJuZWlnaGJvdXJob29kIiwiY2xvc2VkTmVpZ2hib3VyaG9vZCIsIm9wZW5OZWlnaGJvdXJob29kIiwic291cmNlSW1wbCIsInRhcmdldEltcGwiLCJzb3VyY2VzIiwiZGVmaW5lU291cmNlRnVuY3Rpb24iLCJ0YXJnZXRzIiwiZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24iLCJ0aGlzSXNTcmMiLCJlZGdlc1dpdGhJbXBsIiwib3RoZXJOb2RlcyIsImVkZ2VEYXRhIiwidGhpc1RvT3RoZXIiLCJvdGhlclRvVGhpcyIsImVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciIsInRoaXNJc1RndCIsInBhcmFsbGVsRWRnZXMiLCJkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24iLCJjb2RpcmVjdGVkRWRnZXMiLCJjb2RpcmVjdGVkIiwicGFyYWxsZWxFZGdlc0ltcGwiLCJlZGdlMSIsImVkZ2UxX3AiLCJzcmMxIiwic3JjaWQxIiwidGd0aWQxIiwic3JjRWRnZXMxIiwiZWRnZTIiLCJlZGdlMmRhdGEiLCJ0Z3RpZDIiLCJzcmNpZDIiLCJvcHBkaXJlY3RlZCIsInZpc2l0ZWQiLCJ1bnZpc2l0ZWQiLCJ2aXNpdEluQ29tcG9uZW50IiwiY21wdCIsImNvbXBvbmVudHNPZiIsIkNvbGxlY3Rpb24iLCJ1bmlxdWUiLCJjcmVhdGVkRWxlbWVudHMiLCJlbGVzSWRzIiwianNvbiIsIl9kYXRhIiwiX2wiLCJlbGVtZW50JDEiLCJsYXp5TWFwIiwicmVidWlsZE1hcCIsImVsZXNmbiQxIiwiJGlkIiwiX2RhdGEyIiwibW92ZSIsIm5ld1BhcmVudFZhbFNwZWNkIiwiY2hlY2tTd2l0Y2giLCJ0cnVlRm5OYW1lIiwiZmFsc2VGbk5hbWUiLCJvYmpfayIsImpzb25zIiwiZWxlc0FyciIsImFkZFRvUG9vbCIsImN5X3AiLCJyZW1vdmVGcm9tRWxlbWVudHMiLCJfZGF0YTMiLCJmaWVsZHMiLCJmaWVsZHNMZW5ndGgiLCJiYWRTb3VyY2VPclRhcmdldCIsIl9kYXRhNCIsInBhcmVudElkIiwic3BlY2lmaWVkUGFyZW50Iiwic2VsZkFzUGFyZW50IiwicmVzdG9yZWQiLCJfZWxlMyIsInRvVXBkYXRlU3R5bGUiLCJpbnNpZGUiLCJyZW1vdmVGcm9tUG9vbCIsImVsZXNUb1JlbW92ZSIsImVsZXNUb1JlbW92ZUlkcyIsImFkZENvbm5lY3RlZEVkZ2VzIiwiYWxyZWFkeUFkZGVkIiwicmVtb3ZlRWRnZVJlZiIsInJlbW92ZVBhcmFsbGVsUmVmIiwicGxsRWRnZSIsImFsdGVyZWRQYXJlbnRzIiwiaWRzIiwicmVtb3ZlQ2hpbGRSZWYiLCJwaWQiLCJfZWxlNCIsInBsbEVkZ2VzIiwiZWxlc1N0aWxsSW5zaWRlIiwiX2VsZTUiLCJyZW1vdmVkRWxlbWVudHMiLCJfZWxlNiIsInN0cnVjdCIsIm1vZGlmeVBvb2wiLCJzcmNFeGlzdHMiLCJ0Z3RFeGlzdHMiLCJiYXRjaCIsIl9kYXRhNSIsInBhcmVudEV4aXN0cyIsInBpZFRvQXNzaWduIiwidXBkYXRlZCIsIl9kYXRhNiIsImNvcmVmbiQ5IiwiX2pzb25zIiwiZWxlc0J5R3JvdXAiLCJfanNvbnMyIiwiZ3JzIiwiZWxlc0FycmF5IiwiamwiLCJfanNvbiIsImdlbmVyYXRlQ3ViaWNCZXppZXIiLCJtWDEiLCJtWTEiLCJtWDIiLCJtWTIiLCJORVdUT05fSVRFUkFUSU9OUyIsIk5FV1RPTl9NSU5fU0xPUEUiLCJTVUJESVZJU0lPTl9QUkVDSVNJT04iLCJTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyIsImtTcGxpbmVUYWJsZVNpemUiLCJrU2FtcGxlU3RlcFNpemUiLCJmbG9hdDMyQXJyYXlTdXBwb3J0ZWQiLCJGbG9hdDMyQXJyYXkiLCJtU2FtcGxlVmFsdWVzIiwiYUExIiwiYUEyIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsImFYIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImNhbGNTYW1wbGVWYWx1ZXMiLCJiaW5hcnlTdWJkaXZpZGUiLCJhQSIsImFCIiwiY3VycmVudFQiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIl9wcmVjb21wdXRlZCIsInByZWNvbXB1dGUiLCJnZW5lcmF0ZVNwcmluZ1JLNCIsInNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlIiwidGVuc2lvbiIsImZyaWN0aW9uIiwic3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlIiwiaW5pdGlhbFN0YXRlIiwiZHQiLCJkZXJpdmF0aXZlIiwiZHYiLCJzcHJpbmdJbnRlZ3JhdGVTdGF0ZSIsImR4ZHQiLCJkdmR0Iiwic3ByaW5nUks0RmFjdG9yeSIsImluaXRTdGF0ZSIsInRpbWVfbGFwc2VkIiwiRFQiLCJoYXZlX2R1cmF0aW9uIiwibGFzdF9zdGF0ZSIsInBlcmNlbnRDb21wbGV0ZSIsImN1YmljQmV6aWVyIiwiYmV6aWVyIiwicGVyY2VudCIsImVhc2luZ3MiLCJsaW5lYXIiLCJzcHJpbmciLCJnZXRFYXNlZFZhbHVlIiwiZWFzaW5nRm4iLCJyb3VuZFZhbHVlIiwiZWFzZSIsInN0YXJ0UHJvcCIsImVuZFByb3AiLCJwcm9wU3BlYyIsImVhc2VkQXJyIiwic2kiLCJzdGVwJDEiLCJwRWFzaW5nIiwic3RhcnRUaW1lIiwiZWFzaW5nSW1wbCIsImVhc2luZ1ZhbHMiLCJlYXNpbmdQcm9wIiwic3RhcnRQb3MiLCJlbmRQb3MiLCJlbmRQYW4iLCJhbmltYXRpbmdQYW4iLCJlbmRab29tIiwiYW5pbWF0aW5nWm9vbSIsIm1pblpvb20iLCJtYXhab29tIiwiX25hbWUiLCJlYXNlZFZhbCIsIm92ZXJyaWRlQnlwYXNzIiwic3RhcnRBbmltYXRpb24iLCJzdGVwQWxsIiwiYW5pRWxlcyIsImRvbmVFbGVzIiwic3RlcE9uZSIsInJhbkFuaXMiLCJjYWxsYmFja3MiLCJfY2FsbGJhY2tzIiwic3RlcCIsInJhbkVsZUFuaSIsImhhbmRsZWRUaGlzRWxlIiwicmFuQ29yZUFuaSIsImNvcmVmbiQ4Iiwic3RvcEFuaW1hdGlvbkxvb3AiLCJhbmltYXRpb25zUnVubmluZyIsInN0YXJ0QW5pbWF0aW9uTG9vcCIsImhlYWRsZXNzU3RlcCIsImFuaW1hdGlvblN0ZXAiLCJiZWZvcmVSZW5kZXIiLCJyZW5kZXJlckFuaW1hdGlvblN0ZXAiLCJ3aWxsRHJhdyIsImJlZm9yZVJlbmRlclByaW9yaXRpZXMiLCJlbWl0dGVyT3B0aW9ucyIsImVsZXNmbiIsImNvcmVmbiQ3IiwicG5nIiwianBnIiwiYmciLCJqcGVnIiwiY29yZWZuJDYiLCJMYXlvdXQiLCJleHRlbnNpb24iLCJjb3JlZm4kNSIsImV2ZW50TmFtZSIsImV2ZW50RWxlcyIsImJhdGNoTm90aWZpY2F0aW9ucyIsIm5vdGlmaWNhdGlvbnNFbmFibGVkIiwiZGVzdHJveWVkIiwibm90aWZpY2F0aW9ucyIsImJvb2wiLCJub05vdGlmaWNhdGlvbnMiLCJiYXRjaENvdW50IiwiYmF0Y2hEYXRhIiwicmVuZGVyZXJEZWZhdWx0cyIsImhpZGVFZGdlc09uVmlld3BvcnQiLCJ0ZXh0dXJlT25WaWV3cG9ydCIsIm1vdGlvbkJsdXIiLCJtb3Rpb25CbHVyT3BhY2l0eSIsInBpeGVsUmF0aW8iLCJkZXNrdG9wVGFwVGhyZXNob2xkIiwidG91Y2hUYXBUaHJlc2hvbGQiLCJ3aGVlbFNlbnNpdGl2aXR5IiwiZGVidWciLCJzaG93RnBzIiwid2ViZ2wiLCJ3ZWJnbERlYnVnIiwid2ViZ2xEZWJ1Z1Nob3dBdGxhc2VzIiwid2ViZ2xUZXhTaXplIiwid2ViZ2xUZXhSb3dzIiwid2ViZ2xUZXhSb3dzTm9kZXMiLCJ3ZWJnbEJhdGNoU2l6ZSIsIndlYmdsVGV4UGVyQmF0Y2giLCJ3ZWJnbEJnQ29sb3IiLCJjb3JlZm4kNCIsInJlbmRlclRvIiwicHhSYXRpbyIsImZvcmNlUmVuZGVyIiwicmVzaXplIiwiaW52YWxpZGF0ZVNpemUiLCJpbml0UmVuZGVyZXIiLCJSZW5kZXJlclByb3RvIiwick9wdHMiLCJkZXN0cm95UmVuZGVyZXIiLCJkb21FbGUiLCJjb250YWluZXIiLCJfY3lyZWciLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJvblJlbmRlciIsIm9mZlJlbmRlciIsImludmFsaWRhdGVEaW1lbnNpb25zIiwiY29yZWZuJDMiLCJzdHlmbiQ4IiwiRkFMU0UiLCJpZSIsImN4dE1ldGEiLCJnZXRDb250ZXh0TWV0YSIsImN4dFN0eWxlIiwiZ2V0Q29udGV4dFN0eWxlIiwiYXBwIiwiYXBwbHlDb250ZXh0U3R5bGUiLCJhcHBsaWVkSW5pdFN0eWxlIiwiZGlmZlByb3BzIiwiaGludHNEaWZmIiwidXBkYXRlU3R5bGVIaW50cyIsImdldFByb3BlcnRpZXNEaWZmIiwib2xkQ3h0S2V5IiwibmV3Q3h0S2V5IiwicHJvcERpZmZzIiwiZHVhbEN4dEtleSIsImNhY2hlZFZhbCIsImFkZGVkUHJvcCIsImN4dCIsIm9sZEhhc0N4dCIsIm5ld0hhc0N4dCIsImN4dEhhc0RpZmZlZCIsImN4dEhhc01hcHBlZFByb3BzIiwibWFwcGVkUHJvcGVydGllcyIsImxhdGVyQ3h0T3ZlcnJpZGVzIiwibGF0ZXJDeHQiLCJoYXNMYXRlckN4dCIsImN4dEtleSIsInByZXZLZXkiLCJzdHlsZUN4dEtleSIsImNvbnRleHRTZWxlY3Rvck1hdGNoZXMiLCJkaWZmUHJvcE5hbWVzIiwiY3h0U3R5bGVzIiwiY29udGV4dFN0eWxlcyIsImhhc0N4dCIsInJldERpZmZQcm9wcyIsInR5cGVzIiwiZGlmZlByb3BOYW1lIiwiY3h0UHJvcCIsImVsZVByb3AiLCJkZWxldGVCeXBhc3NlZCIsIm1hcHBlZCIsIm1hcHBpbmciLCJmblZhbHVlIiwicHJldkZuVmFsdWUiLCJyZXREaWZmUHJvcCIsImFwcGx5UGFyc2VkUHJvcGVydHkiLCJieXBhc3NlZCIsInByb3BOYW1lcyIsInByb3BlcnR5R3JvdXBOYW1lcyIsInByb3BHcktleXMiLCJwcm9wZXJ0eUdyb3VwS2V5cyIsInByb3BIYXNoIiwic2VlZEtleSIsImdldFByb3BlcnRpZXNIYXNoIiwib2xkU3R5bGVLZXkiLCJzdHlsZUtleSIsIm92ZXJyaWRkZW5TdHlsZXMiLCJncktleSIsInVwZGF0ZUdyS2V5MSIsInVwZGF0ZUdyS2V5MiIsInVwZGF0ZUdyS2V5IiwidXBkYXRlR3JLZXlXU3RyIiwic3RyVmFsIiwiY2xlYW5OdW0iLCJwYXJzZWRQcm9wIiwicHJvcEluZm8iLCJfZ3JLZXkiLCJncm91cEtleSIsIm5vcm1hbGl6ZWROdW1iZXJWYWwiLCJoYXNoT3ZlcnJpZGUiLCJudW1iZXJWYWwiLCJlbnVtcyIsImhhdmVOb3JtTnVtIiwiaGF2ZVVuaXRlZE51bSIsImhhdmVOdW0iLCJtdWx0aXBsZSIsIl9ncktleTIiLCJnckhhc2giLCJzayIsImxhYmVsRGltc0tleSIsImxhYmVsRGltZW5zaW9ucyIsImxhYmVsS2V5cyIsImxhYmVsS2V5IiwibGFiZWxTdHlsZUtleSIsImNvbW1vbkxhYmVsIiwic291cmNlTGFiZWxLZXlzIiwic291cmNlTGFiZWxLZXkiLCJzb3VyY2VMYWJlbFN0eWxlS2V5IiwidGFyZ2V0TGFiZWxLZXlzIiwidGFyZ2V0TGFiZWxLZXkiLCJ0YXJnZXRMYWJlbFN0eWxlS2V5IiwiX3Akc3R5bGVLZXlzIiwibm9kZUJvZHkiLCJub2RlQm9yZGVyIiwibm9kZU91dGxpbmUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJwaWUiLCJzdHJpcGUiLCJub2RlS2V5cyIsIm5vZGVLZXkiLCJoYXNQaWUiLCJoYXNTdHJpcGUiLCJjbGVhclN0eWxlSGludHMiLCJmbGF0UHJvcCIsInByb3BJc0J5cGFzcyIsIm9yaWdQcm9wIiwib3JpZ1Byb3BJc0J5cGFzcyIsImZsYXRQcm9wTWFwcGluZyIsImdldFZhbCIsImNoZWNrVHJpZ2dlcnMiLCJmcm9tVmFsIiwidG9WYWwiLCJkZWxldGVCeXBhc3MiLCJwcmludE1hcHBpbmdFcnIiLCJtYXBEYXRhIiwiZmllbGRXaWR0aCIsImZpZWxkTWF4IiwiZmllbGRNaW4iLCJyMSIsInZhbHVlTWluIiwicjIiLCJ2YWx1ZU1heCIsImcxIiwiZzIiLCJiMSIsImExIiwiYTIiLCJjbHIiLCJjYWxjVmFsdWUiLCJfZmllbGRzIiwiX2ZpZWxkVmFsIiwiZm5SZXRWYWwiLCJjbGVhbkVsZW1lbnRzIiwia2VlcEJ5cGFzc2VzIiwiYW55UHJldiIsInN0eVByb3AiLCJkaWZmUHJvcCIsInByZXZQcm9wIiwiZnJvbVByb3AiLCJ0b1Byb3AiLCJpbml0VmFsIiwiaW5pdER0IiwidHJhbnNpdGlvbmluZyIsImNoZWNrVHJpZ2dlciIsImZyb21WYWx1ZSIsInRvVmFsdWUiLCJnZXRUcmlnZ2VyIiwib25UcmlnZ2VyIiwidHJpZ2dlckNoZWNrIiwiY2hlY2taT3JkZXJUcmlnZ2VyIiwidHJpZ2dlcnNaT3JkZXIiLCJjaGVja0JvdW5kc1RyaWdnZXIiLCJ0cmlnZ2Vyc0JvdW5kcyIsImNoZWNrQ29ubmVjdGVkRWRnZXNCb3VuZHNUcmlnZ2VyIiwidHJpZ2dlcnNCb3VuZHNPZkNvbm5lY3RlZEVkZ2VzIiwiY2hlY2tQYXJhbGxlbEVkZ2VzQm91bmRzVHJpZ2dlciIsInRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzIiwic3R5Zm4kNyIsImlzQnlwYXNzIiwiX3BhcnNlZFByb3AiLCJzcGVjaWZpZWRQcm9wcyIsIl9uYW1lMiIsIl92YWx1ZSIsIl9wYXJzZWRQcm9wMiIsIl9wcm9wIiwiaXNDb2xvciIsImlzTXVsdGkiLCJtdXRpcGxlIiwib2xkVmFsdWUiLCJwcm9wZXJ0eU5hbWVzIiwic3R5Zm4kNiIsImdldEVtU2l6ZUluUGl4ZWxzIiwicHgiLCJjb250YWluZXJDc3MiLCJjb250YWluZXJXaW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInN0eWZuJDUiLCJpc1JlbmRlcmVkVmFsIiwiZ2V0SW5kZXhlZFN0eWxlIiwic3VicHJvcGVydHkiLCJhbGlhcyIsInBvaW50c1RvIiwic3R5bGVQcm9wIiwiZ2V0UmVuZGVyZWRWYWx1ZSIsImdldFZhbHVlU3RyaW5nV2l0aFVuaXRzIiwiaXNBcnJheVZhbHVlIiwiaGF2ZVVuaXRzIiwiYW5pUHJvcHMiLCJhbmlQcm9wIiwicHJvcHNPYmoiLCJnZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2giLCJjaFZhbCIsInN0eWZuJDQiLCJhcHBlbmRGcm9tSnNvbiIsImZyb21Kc29uIiwicmVzZXRUb0RlZmF1bHQiLCJkZWZhdWx0TGVuZ3RoIiwic3R5Zm4kMyIsImFwcGVuZEZyb21TdHJpbmciLCJzZWxBbmRCbG9ja1N0ciIsImJsb2NrUmVtIiwicHJvcEFuZFZhbFN0ciIsInJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZyIsInJlbW92ZVByb3BBbmRWYWxGcm9tUmVtIiwibm90aGluZ0xlZnRUb1BhcnNlIiwic2VsQW5kQmxvY2siLCJzZWxlY3RvclN0ciIsImJsb2NrU3RyIiwiaW52YWxpZEJsb2NrIiwiX25vdGhpbmdMZWZ0VG9QYXJzZSIsInByb3BBbmRWYWwiLCJwcm9wU3RyIiwiZnJvbVN0cmluZyIsInN0eWZuJDIiLCJoZXgzJDEiLCJoZXg2JDEiLCJtYXBBcmciLCJ1cmxSZWdleGVzIiwiaW1wbGljaXRVbml0cyIsInBlcmNlbnRhZ2VzIiwiemVyb09uZU51bWJlciIsInVuaXRsZXNzIiwiemVyb09uZU51bWJlcnMiLCJuT25lT25lTnVtYmVyIiwibm9uTmVnYXRpdmVJbnQiLCJub25OZWdhdGl2ZU51bWJlciIsIm5vZGVTaXplIiwibnVtYmVycyIsInBvc2l0aXZlTnVtYmVyIiwic3RyaWN0TWluIiwiYmlkaXJlY3Rpb25hbFNpemUiLCJiaWRpcmVjdGlvbmFsU2l6ZU1heWJlUGVyY2VudCIsImFsbG93UGVyY2VudCIsImJpZGlyZWN0aW9uYWxTaXplcyIsInNpemVNYXliZVBlcmNlbnQiLCJheGlzRGlyZWN0aW9uIiwiYXhpc0RpcmVjdGlvbkV4cGxpY2l0IiwiYXhpc0RpcmVjdGlvblByaW1hcnkiLCJwYWRkaW5nUmVsYXRpdmVUbyIsImJnV0giLCJiZ1BvcyIsImJnUmVsYXRpdmVUbyIsImJnUmVwZWF0IiwiYmdGaXQiLCJiZ0Nyb3NzT3JpZ2luIiwiYmdDbGlwIiwiYmdDb250YWlubWVudCIsImJveFNlbGVjdGlvbiIsImZpbGwiLCJib29scyIsImxpbmVTdHlsZSIsImxpbmVDYXAiLCJsaW5lUG9zaXRpb24iLCJsaW5lSm9pbiIsImJvcmRlclN0eWxlIiwicmFkaXVzVHlwZSIsImZvbnRGYW1pbHkiLCJmb250U3R5bGUiLCJmb250V2VpZ2h0IiwidGV4dERlY29yYXRpb24iLCJ0ZXh0VHJhbnNmb3JtIiwidGV4dFdyYXAiLCJ0ZXh0T3ZlcmZsb3dXcmFwIiwidGV4dEJhY2tncm91bmRTaGFwZSIsIm5vZGVTaGFwZSIsIm92ZXJsYXlTaGFwZSIsImNvbXBvdW5kSW5jbHVkZUxhYmVscyIsImFycm93U2hhcGUiLCJhcnJvd0ZpbGwiLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsInpDb21wb3VuZERlcHRoIiwiekluZGV4Q29tcGFyZSIsImp1c3RpZmljYXRpb24iLCJsYXlvdXREYXRhIiwibWFwTGF5b3V0RGF0YSIsIm1hcFNjcmF0Y2giLCJ1cmwiLCJyZWdleGVzIiwic2luZ2xlUmVnZXhNYXRjaFZhbHVlIiwidXJscyIsInByb3BMaXN0IiwidGV4dFJvdGF0aW9uIiwicG9seWdvblBvaW50TGlzdCIsImV2ZW5NdWx0aXBsZSIsImVkZ2VEaXN0YW5jZXMiLCJlZGdlRW5kcG9pbnQiLCJzaW5nbGVFbnVtIiwidmFsaWRhdGUiLCJ2YWxBcnIiLCJ1bml0c0FyciIsImdyYWRpZW50RGlyZWN0aW9uIiwiYm91bmRzRXhwYW5zaW9uIiwiemVyb05vblplcm8iLCJ2YWwxIiwidmFsMiIsImFueSIsImVtcHR5Tm9uRW1wdHkiLCJzdHIxIiwic3RyMiIsImVtcHR5MSIsImVtcHR5MiIsIm1haW5MYWJlbCIsInNvdXJjZUxhYmVsIiwidGFyZ2V0TGFiZWwiLCJiZWhhdmlvciIsIm92ZXJsYXkiLCJ1bmRlcmxheSIsInRyYW5zaXRpb24iLCJub2RlU2l6ZUhhc2hPdmVycmlkZSIsImVkZ2VMaW5lIiwicGllQmFja2dyb3VuZE4iLCJzdHJpcGVCYWNrZ3JvdW5kTiIsImVkZ2VBcnJvdyIsImFycm93UHJlZml4ZXMiLCJwcm9wR3JvdXBzIiwicHJvcGVydHlHcm91cHMiLCJwcm9wR3JvdXBOYW1lcyIsInByb3BHcm91cEtleXMiLCJhbGlhc2VzIiwicG9pbnRzVG9Qcm9wIiwiYWxpYXNQcm9wIiwiZ2V0RGVmYXVsdFByb3BlcnRpZXMiLCJkZWZhdWx0UHJvcGVydGllcyIsInJhd1Byb3BzIiwicGFyc2VkUHJvcHMiLCJhZGREZWZhdWx0U3R5bGVzaGVldCIsInN0eWZuJDEiLCJwcm9wSXNGbGF0IiwicGFyc2VJbXBsV2FybiIsImZsYXRLZXkiLCJieXBhc3NLZXkiLCJ2YWx1ZUtleSIsImFyZ0hhc2giLCJwcm9wQ2FjaGUiLCJwYXJzZUltcGwiLCJwYXNzZWRWYWx1ZSIsInRyaW0iLCJfbWFwcGVkIiwicGZWYWxBcnIiLCJoYXNFbnVtIiwiY2hlY2tFbnVtcyIsImVuIiwidW5pdHNSZWdleCIsInN0cmljdE1heCIsInByb3BzU3RyIiwicHJvcHNTcGxpdCIsInR1cGxlIiwiZW51bVByb3AiLCJfU3R5bGUiLCJTdHlsZSIsImNvcmVTdHlsZSIsInN0eWZuIiwiZWxlX3AiLCJtYXBWYWwiLCJjc3NSdWxlIiwiY3VycmVudFNlbGVjdG9ySXNDb3JlIiwiYXBwZW5kIiwiYXBwZW5kVG9TdHlsZSIsImNvcmVmbiQyIiwibmV3U3R5bGUiLCJzZXRTdHlsZSIsImdlbmVyYXRlU3R5bGUiLCJkZWZhdWx0U2VsZWN0aW9uVHlwZSIsImNvcmVmbiQxIiwic2VsZWN0aW9uVHlwZSIsInNlbFR5cGUiLCJwYW5uaW5nRW5hYmxlZCIsInVzZXJQYW5uaW5nRW5hYmxlZCIsInpvb21pbmdFbmFibGVkIiwidXNlclpvb21pbmdFbmFibGVkIiwiYm94U2VsZWN0aW9uRW5hYmxlZCIsImFyZzAiLCJnYyIsInZpZXdwb3J0U3RhdGUiLCJiYmUiLCJ6b29tUmFuZ2UiLCJjdXJyZW50UGFuIiwiY3VycmVudFpvb20iLCJiYWlsIiwibGV2ZWwiLCJwYW4xIiwiem9vbTEiLCJ6b29tMiIsInBhbjIiLCJ2aWV3cG9ydCIsInpvb21EZWZkIiwicGFuRGVmZCIsInpvb21GYWlsZWQiLCJwYW5GYWlsZWQiLCJ6IiwiY2FuY2VsT25GYWlsZWRab29tIiwicmVzZXQiLCJzaXplQ2FjaGUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImV4dGVudCIsInJiIiwicmVuZGVyZWRFeHRlbnQiLCJtdWx0aUNsaWNrRGVib3VuY2VUaW1lIiwiX2ludCIsImF1dG9sb2NrTm9kZXMiLCJhdXRvdW5ncmFiaWZ5Tm9kZXMiLCJDb3JlIiwicmVnIiwiZGVzdHJveSIsInJlYWRpZXMiLCJoZWFkIiwiZGVmVmFsIiwiZGVmIiwiYWx0VmFsIiwibG9hZEV4dERhdGEiLCJleHREYXRhIiwiYW55SXNQcm9taXNlIiwicmVuZGVyZXJPcHRpb25zIiwic2V0RWxlc0FuZExheW91dCIsIm9ubG9hZCIsIm9uZG9uZSIsIm9sZEVsZXMiLCJsYXlvdXRPcHRzIiwidGhlbnMiLCJpbml0U3R5bGUiLCJpbml0RWxlcyIsImNvcmVmbiIsImlzUmVhZHkiLCJpc0hlYWRsZXNzIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwibW91bnQiLCJ1bm1vdW50IiwiZ2V0RnJlc2hSZWYiLCJpZEluSnNvbiIsInVwZGF0ZUVsZXMiLCJnciIsInRvTW9kIiwiX3RvTW9kJF9pIiwicGFyZW50c1RvUmVtb3ZlIiwiZmxhdCIsImRlZmF1bHRzJDciLCJjaXJjbGUiLCJncmlkIiwiYXZvaWRPdmVybGFwIiwiZGVwdGhTb3J0IiwiZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzIiwibWF4aW1hbCIsImFjeWNsaWMiLCJzZXRJbmZvIiwiQnJlYWR0aEZpcnN0TGF5b3V0IiwiZ3JhcGgiLCJtYXhpbWFsQWRqdXN0bWVudHMiLCJoYXNCb3VuZGluZ0JveCIsInN0cnVjdHVyZWRDbG9uZSIsInJvb3RzQXJyYXkiLCJjb21wIiwiY29tcFJvb3RzIiwiZGVwdGhzIiwiZm91bmRCeUJmcyIsImFkZFRvRGVwdGgiLCJjaGFuZ2VEZXB0aCIsIm5ld0RlcHRoIiwicE5vZGUiLCJvcnBoYW5Ob2RlcyIsImFzc2lnbkRlcHRoc0F0IiwiYWRqdXN0TWF4aW1hbGx5Iiwic2hpZnRlZCIsImVJbmZvIiwibWF4RGVwdGgiLCJpbmNtciIsImlJbmZvIiwiZW5xdWV1ZSIsImRlcXVldWUiLCJkaWRTaGlmdCIsIm1pbkRpc3RhbmNlIiwibmJiIiwiY2FjaGVkV2VpZ2h0ZWRQZXJjZW50IiwiZ2V0V2VpZ2h0ZWRQZXJjZW50IiwiZWxlRGVwdGgiLCJzYW1wbGVzIiwiYmYiLCJuRGVwdGgiLCJhcGN0IiwiYnBjdCIsImRlcHRoc0xlbiIsIm9ycGhhbkRlcHRoIiwiYXNzaWduRGVwdGhzIiwiYmlnZ2VzdERlcHRoU2l6ZSIsImF2ZU5vZGVTaXplIiwiYWNjIiwiZGlzdGFuY2VZIiwibWF4RGVwdGhTaXplIiwiZ2V0UG9zaXRpb25Ub3BCb3R0b20iLCJfZ2V0SW5mbzIiLCJyYWRpdXNTdGVwU2l6ZSIsImRlcHRoU2l6ZSIsImRpc3RhbmNlWCIsImVwb3MiLCJyb3RhdGVEZWdyZWVzIiwiZ2V0UG9zaXRpb24iLCJkZWZhdWx0cyQ2Iiwic3dlZXAiLCJjbG9ja3dpc2UiLCJDaXJjbGVMYXlvdXQiLCJjb3VudGVyY2xvY2t3aXNlIiwiZFRoZXRhIiwiZGNvcyIsImRzaW4iLCJyTWluIiwiZ2V0UG9zIiwicngiLCJyeSIsImRlZmF1bHRzJDUiLCJlcXVpZGlzdGFudCIsIm1pbk5vZGVTcGFjaW5nIiwiY29uY2VudHJpYyIsImxldmVsV2lkdGgiLCJDb25jZW50cmljTGF5b3V0Iiwibm9kZVZhbHVlcyIsIm1heE5vZGVTaXplIiwibGV2ZWxzIiwiY3VycmVudExldmVsIiwibWluRGlzdCIsImZpcnN0THZsSGFzTXVsdGkiLCJtYXhSIiwiclN0ZXAiLCJyRGVsdGFNYXgiLCJfciIsIl9sZXZlbCIsInJEZWx0YSIsIl9sZXZlbDIiLCJfbGV2ZWwzIiwiX2RUaGV0YSIsIl9yMiIsIl92YWwiLCJERUJVRyIsImRlZmF1bHRzJDQiLCJhbmltYXRpb25UaHJlc2hvbGQiLCJyZWZyZXNoIiwicmFuZG9taXplIiwiY29tcG9uZW50U3BhY2luZyIsIm5vZGVSZXB1bHNpb24iLCJub2RlT3ZlcmxhcCIsImlkZWFsRWRnZUxlbmd0aCIsImVkZ2VFbGFzdGljaXR5IiwibmVzdGluZ0ZhY3RvciIsImdyYXZpdHkiLCJpbml0aWFsVGVtcCIsImNvb2xpbmdGYWN0b3IiLCJtaW5UZW1wIiwiQ29zZUxheW91dCIsIm5vdEVkZ2VzIiwiaGFzU291cmNlIiwiaGFzVGFyZ2V0IiwibGF5b3V0SW5mbyIsImNyZWF0ZUxheW91dEluZm8iLCJwcmludExheW91dEluZm8iLCJyYW5kb21pemVQb3NpdGlvbnMiLCJyZWZyZXNoUG9zaXRpb25zIiwibWFpbkxvb3AiLCJ0ZW1wZXJhdHVyZSIsImdldFNjYWxlZFBvcyIsImdldFNjYWxlSW5Cb3VuZHNGbiIsImxvb3BSZXQiLCJfZnJhbWUiLCJmcmFtZSIsInNlcGFyYXRlQ29tcG9uZW50cyIsInRocmVhZCIsImlzQ29tcG91bmQiLCJsYXlvdXROb2RlcyIsImlkVG9JbmRleCIsImdyYXBoU2V0IiwiaW5kZXhUb0dyYXBoIiwibGF5b3V0RWRnZXMiLCJlZGdlU2l6ZSIsImlkMmNtcHRJZCIsInRlbXBOb2RlIiwiaXNMb2NrZWQiLCJjbXB0SWQiLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJwYWRMZWZ0IiwicGFkUmlnaHQiLCJwYWRUb3AiLCJwYWRCb3R0b20iLCJ0ZW1wR3JhcGgiLCJwX2lkIiwibm9kZV9pZCIsIm5vZGVfaXgiLCJ0ZW1wRWRnZSIsImlkZWFsTGVuZ3RoIiwiZWxhc3RpY2l0eSIsInNvdXJjZUl4IiwidGFyZ2V0SXgiLCJzb3VyY2VHcmFwaCIsInRhcmdldEdyYXBoIiwibGNhIiwiZmluZExDQSIsImxjYUdyYXBoIiwiX2ZpbmRMQ0FfYXV4IiwiY291bnQiLCJmaW5kTENBX2F1eCIsImdyYXBoSXgiLCJub2RlSXgiLCJjaGlsZEdyYXBoSXgiLCJjb3NlQkIiLCJsbm9kZSIsInBjdFgiLCJwY3RZIiwiY2FsY3VsYXRlTm9kZUZvcmNlcyIsImNhbGN1bGF0ZUVkZ2VGb3JjZXMiLCJjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzIiwicHJvcGFnYXRlRm9yY2VzIiwidXBkYXRlUG9zaXRpb25zIiwicmFuZG9tRGlzdGFuY2UiLCJjbXB0SWQxIiwiY21wdElkMiIsImRpcmVjdGlvblgiLCJkaXJlY3Rpb25ZIiwibWF4UmFuZERpc3QiLCJvdmVybGFwIiwibm9kZXNPdmVybGFwIiwiZm9yY2VYIiwiZm9yY2VZIiwicG9pbnQxIiwiZmluZENsaXBwaW5nUG9pbnQiLCJwb2ludDIiLCJkaXN0YW5jZVNxciIsImRYIiwiZFkiLCJvdmVybGFwWCIsIm92ZXJsYXBZIiwiWCIsIlkiLCJIIiwiVyIsImRpclNsb3BlIiwibm9kZVNsb3BlIiwibHgiLCJseSIsImRpc3RUaHJlc2hvbGQiLCJmeCIsImZ5Iiwibm9kZUluZGV4Iiwib2ZmWCIsIm9mZlkiLCJjaGlsZE5vZGUiLCJ0ZW1wRm9yY2UiLCJsaW1pdEZvcmNlIiwiX3VwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyIsInVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyIsImZsYWciLCJjaWQiLCJ0b3RhbEEiLCJ1c2VkVyIsInJvd0giLCJtYXhSb3dXIiwiZGVmYXVsdHMkMyIsImF2b2lkT3ZlcmxhcFBhZGRpbmciLCJjb25kZW5zZSIsInJvd3MiLCJjb2xzIiwiR3JpZExheW91dCIsImNlbGxzIiwic3BsaXRzIiwic21hbGwiLCJsYXJnZSIsIm9Sb3dzIiwib0NvbHMiLCJjb2x1bW5zIiwic20iLCJsZyIsIl9zbSIsIl9sZyIsImNlbGxXaWR0aCIsImNlbGxIZWlnaHQiLCJjZWxsVXNlZCIsInVzZWQiLCJ1c2UiLCJtb3ZlVG9OZXh0Q2VsbCIsImlkMm1hblBvcyIsInJjUG9zIiwiZGVmYXVsdHMkMiIsIk51bGxMYXlvdXQiLCJkZWZhdWx0cyQxIiwiUHJlc2V0TGF5b3V0IiwicG9zSXNGbiIsIlJhbmRvbUxheW91dCIsIk51bGxSZW5kZXJlciIsInRocm93SW1nRXJyIiwiQlJwJGYiLCJhcnJvd1NoYXBlV2lkdGgiLCJyZWdpc3RlckFycm93U2hhcGVzIiwiYXJyb3dTaGFwZXMiLCJiYkNvbGxpZGUiLCJ0cmFuc2xhdGlvbiIsImVkZ2VXaWR0aCIsInhSb3RhdGVkIiwieVJvdGF0ZWQiLCJ4U2NhbGVkIiwieVNjYWxlZCIsInhUcmFuc2xhdGVkIiwieVRyYW5zbGF0ZWQiLCJyZXRQdHMiLCJwb2ludHNUb0FyciIsInN0YW5kYXJkR2FwIiwiZGVmaW5lQXJyb3dTaGFwZSIsImRlZm4iLCJjb2xsaWRlIiwicm91Z2hDb2xsaWRlIiwiZHJhdyIsImFycm93U2hhcGVJbXBsIiwiZ2FwIiwiY29udHJvbFBvaW50IiwicHRzVHJhbnMiLCJjdHJsUHQiLCJjdHJsUHRUcmFucyIsInBvaW50c1RlZSIsInRyaVB0cyIsInRlZVB0cyIsInBvaW50c1RyIiwiY2lyY2xlSW5zaWRlIiwiZ2V0QXJyb3dXaWR0aCIsImJhc2VDcm9zc0xpbmVQdHMiLCJjcm9zc0xpbmVQdHMiLCJzaGlmdEZhY3RvciIsInkwIiwiQlJwJGUiLCJwcm9qZWN0SW50b1ZpZXdwb3J0IiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRzIiwiZmluZENvbnRhaW5lckNsaWVudENvb3JkcyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJjb250YWluZXJCQiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzdHlsZVZhbHVlIiwicGFkZGluZ0hvciIsInBhZGRpbmdWZXIiLCJib3JkZXJIb3IiLCJ1bnNjYWxlZFciLCJ1bnNjYWxlZEgiLCJpbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUiLCJmaW5kTmVhcmVzdEVsZW1lbnQiLCJpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSIsImlzVG91Y2giLCJmaW5kTmVhcmVzdEVsZW1lbnRzIiwiZ2V0Q2FjaGVkWlNvcnRlZEVsZXMiLCJuZWFyIiwiZWRnZVRocmVzaG9sZCIsIm5vZGVUaHJlc2hvbGQiLCJsYWJlbFRocmVzaG9sZCIsIm1pblNxRGlzdCIsIm5lYXJFZGdlIiwibmVhck5vZGUiLCJhZGRFbGUiLCJzcURpc3QiLCJjaGVja05vZGUiLCJodyIsImhoIiwicnMiLCJnZXROb2RlU2hhcGUiLCJjaGVja1BvaW50IiwiY2hlY2tFZGdlIiwic3R5bGVXaWR0aCIsIndpZHRoU3EiLCJ3aWR0aDIiLCJlZGdlVHlwZSIsImFsbHB0cyIsImFyU2l6ZSIsImFycm93cyIsImFycm93U3RhcnRYIiwiYXJyb3dTdGFydFkiLCJzcmNBcnJvd0FuZ2xlIiwiYXJyb3dFbmRYIiwiYXJyb3dFbmRZIiwidGd0QXJyb3dBbmdsZSIsIm1pZHNyY0Fycm93QW5nbGUiLCJtaWR0Z3RBcnJvd0FuZ2xlIiwiYXIiLCJwcmVwcm9wIiwicHJlIiwiY2hlY2tMYWJlbCIsInRoIiwiZXZlbnRzRW5hYmxlZCIsIm94Iiwib3kiLCJnZXRBbGxJbkJveCIsIngxYyIsIngyYyIsInkxYyIsInkyYyIsImJveEJiIiwic2VsZWN0aW9uQm94IiwiYm94RWRnZXMiLCJnZXRSb3RhdGVkTGFiZWxCb3giLCJkb0xpbmVzSW50ZXJzZWN0IiwiY2N3IiwidGV4dEV2ZW50cyIsIm5vZGVCb3hTZWxlY3RNb2RlIiwibGFiZWxCb3hTZWxlY3RFbmFibGVkIiwibm9kZUJiIiwicm90YXRlZExhYmVsQm94Iiwibm9kZUJvZHlCYiIsIm5vZGVCb2R5Q29ybmVycyIsIl9yb3RhdGVkTGFiZWxCb3giLCJlZGdlQm94U2VsZWN0TW9kZSIsImVuZFgiLCJlbmRZIiwiYWxsSW5zaWRlIiwiX3NlbGVjdGVkIiwiX3B0cyIsInNlZ1N0YXJ0Iiwic2VnRW5kIiwiX2JveEVkZ2VzJGIiLCJib3hTdGFydCIsImJveEVuZCIsIkJScCRkIiwiY2FsY3VsYXRlQXJyb3dBbmdsZXMiLCJpc0hheXN0YWNrIiwiaXNCZXppZXIiLCJpc011bHRpYmV6aWVyIiwiaXNTZWdtZW50cyIsImlzU2VsZiIsInNlZ3B0cyIsImJYIiwiYlkiLCJpMiIsImkxIiwiaXNSb3VuZCIsIm1pZFZlY3RvciIsImNwdHMiLCJjdHJscHRzIiwiYnAweCIsImJwMHkiLCJicDF4IiwiYnAxeSIsImljIiwibWlkRGlzcFgiLCJtaWREaXNwWSIsImkzIiwiZ2V0QXJyb3dIZWlnaHQiLCJhcnJvd1dpZHRoQ2FjaGUiLCJzaW5BIiwic2luQTkwIiwicmFkRGlyZWN0aW9uIiwiZHJhd0RpcmVjdGlvbiIsImhhbGZBbmdsZSIsImNSYWRpdXMiLCJsZW5PdXQiLCJsaW1pdCIsImxhc3RQb2ludCIsImFzVmVjIiwicHAiLCJueCIsIm55IiwiYW5nIiwiaW52ZXJ0VmVjIiwib3JpZ2luYWxWIiwiaW52ZXJ0ZWRWIiwiY2FsY0Nvcm5lckFyYyIsInByZXZpb3VzUG9pbnQiLCJjdXJyZW50UG9pbnQiLCJuZXh0UG9pbnQiLCJyYWRpdXNNYXgiLCJpc0FyY1JhZGl1cyIsImFzaW4iLCJkcmF3UHJlcGFyZWRSb3VuZENvcm5lciIsImN0eCIsInJvdW5kQ29ybmVyIiwibGluZVRvIiwiYXJjIiwiZW5kQW5nbGUiLCJjb3VudGVyQ2xvY2t3aXNlIiwiZ2V0Um91bmRDb3JuZXIiLCJBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCIsIkFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UX0wiLCJCUnAkYyIsImZpbmRNaWRwdFB0c0V0YyIsInBhaXJJbmZvIiwicG9zUHRzIiwiaW50ZXJzZWN0aW9uUHRzIiwidmVjdG9yTm9ybUludmVyc2UiLCJtaWRwdFB0cyIsInNyY01hbkVuZHB0IiwidGd0TWFuRW5kcHQiLCJoYXZlTWFudWFsRW5kUHRzIiwicmVjYWxjVmVjdG9yTm9ybUludmVyc2UiLCJfdGhpcyRtYW51YWxFbmRwdFRvUHgiLCJtYW51YWxFbmRwdFRvUHgiLCJfdGhpcyRtYW51YWxFbmRwdFRvUHgyIiwiX3RoaXMkbWFudWFsRW5kcHRUb1B4MyIsIl90aGlzJG1hbnVhbEVuZHB0VG9QeDQiLCJlbmRQdHMiLCJmaW5kSGF5c3RhY2tQb2ludHMiLCJoYXlzdGFjayIsInNyY1BvcyIsInRndFBvcyIsInNyY1ciLCJ0Z3RXIiwic3JjSCIsInRndEgiLCJoYWxmUmFkaXVzIiwic3RvcmVFZGdlUHJvamVjdGlvbnMiLCJyZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zIiwiY2FsY3VsYXRlTGFiZWxBbmdsZXMiLCJmaW5kU2VnbWVudHNQb2ludHMiLCJzZWdtZW50V3MiLCJzZWdtZW50RHMiLCJzZWdtZW50UnMiLCJzZWdtZW50VHMiLCJzZWdtZW50c04iLCJsYXN0UmFkaXVzIiwibGFzdFJhZGl1c1R5cGUiLCJyYWRpaSIsIncxIiwidzIiLCJfdGhpcyRmaW5kTWlkcHRQdHNFdGMiLCJhZGp1c3RlZE1pZHB0IiwiZmluZExvb3BQb2ludHMiLCJlZGdlSXNVbmJ1bmRsZWQiLCJkaXJDb3VudHMiLCJjdHJscHREaXN0cyIsImN0cmxwdERpc3QiLCJsb29wRGlyIiwibG9vcFN3cCIsInN0ZXBTaXplIiwibG9vcERpc3QiLCJsb29wQW5nbGUiLCJvdXRBbmdsZSIsImluQW5nbGUiLCJmaW5kQ29tcG91bmRMb29wUG9pbnRzIiwibG9vcFciLCJsb29wYVBvcyIsImxvb3BiUG9zIiwibG9vcFBvcyIsIm1pbkNvbXBvdW5kU3RyZXRjaCIsImNvbXBvdW5kU3RyZXRjaEEiLCJjb21wb3VuZFN0cmV0Y2hCIiwiZmluZFN0cmFpZ2h0RWRnZVBvaW50cyIsImZpbmRCZXppZXJQb2ludHMiLCJlZGdlSXNTd2FwcGVkIiwiY3RybHB0V3MiLCJiZXppZXJOIiwiY3RybHB0V2VpZ2h0IiwibXVsdGkiLCJub3JtY3RybHB0RGlzdCIsIm1hbmN0cmxwdERpc3QiLCJzaWduIiwiZGlzdGFuY2VGcm9tTWlkcG9pbnQiLCJfdGhpcyRmaW5kTWlkcHRQdHNFdGMyIiwiZmluZFRheGlQb2ludHMiLCJWRVJUSUNBTCIsIkhPUklaT05UQUwiLCJMRUZUV0FSRCIsIlJJR0hUV0FSRCIsIkRPV05XQVJEIiwiVVBXQVJEIiwiQVVUTyIsImRJbmNsdWRlc05vZGVCb2R5IiwidGF4aURpciIsInJhd1RheGlEaXIiLCJ0YXhpVHVybiIsInR1cm5Jc1BlcmNlbnQiLCJ0YXhpVHVyblBmVmFsIiwidHVybklzTmVnYXRpdmUiLCJtaW5EIiwiZHciLCJkaCIsInBkeCIsInBkeSIsInN1YkRXSCIsImR4eSIsImR3aCIsImlzRXhwbGljaXREaXIiLCJpc1ZlcnQiLCJwbCIsInNnbkwiLCJmb3JjZWREaXIiLCJnZXRJc1Rvb0Nsb3NlIiwiaXNUb29DbG9zZVNyYyIsImlzVG9vQ2xvc2VUZ3QiLCJpc1Rvb0Nsb3NlIiwibFNoYXBlSW5zaWRlU3JjIiwibFNoYXBlSW5zaWRlVGd0IiwiX2xTaGFwZUluc2lkZVNyYyIsIl9sU2hhcGVJbnNpZGVUZ3QiLCJfeSIsIl94IiwiX3gyIiwiX3gzIiwiX3kyIiwiX3kzIiwiX3k0IiwiX3g0IiwiX3g1IiwiX3g2IiwiX3k1IiwiX3k2IiwidHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyIsInNyY1NoYXBlIiwidGd0U2hhcGUiLCJzcmNDb3JuZXJSYWRpdXMiLCJ0Z3RDb3JuZXJSYWRpdXMiLCJzcmNScyIsInRndFJzIiwiYmFkU3RhcnQiLCJiYWRBU3RhcnQiLCJiYWRFbmQiLCJiYWRBRW5kIiwibWluQ3BBRGlzdEZhY3RvciIsImFycm93VyIsIm1pbkNwQURpc3QiLCJzdGFydEFDcERpc3QiLCJjbG9zZVN0YXJ0QUNwIiwiZW5kQUNwRGlzdCIsImNsb3NlRW5kQUNwIiwib3ZlcmxhcHBpbmciLCJjcEQiLCJjcEwiLCJjcE0iLCJjcFByb2oiLCJzcmNDdHJsUHRJbnRuIiwiaW50ZXJzZWN0TGluZSIsIl9jcEQiLCJfY3BMIiwiX2NwTSIsIl9yYWRpdXMiLCJfY3BQcm9qIiwidGd0Q3RybFB0SW50biIsImZpbmRFbmRwb2ludHMiLCJzdG9yZUFsbHB0cyIsIm10Iiwicm91bmRDb3JuZXJzIiwiZmFjdG9yIiwiY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmciLCJsb2dnZWRFcnIiLCJmaW5kRWRnZUNvbnRyb2xQb2ludHMiLCJoYXNoVGFibGUiLCJwYWlySWQiLCJwYWlySWRzIiwiaGF5c3RhY2tFZGdlcyIsImVkZ2VJc0JlemllciIsInNyY0luZGV4IiwidGd0SW5kZXgiLCJ0YWJsZUVudHJ5IiwiaGFzVW5idW5kbGVkIiwiaGFzQmV6aWVyIiwiX3BhaXJJZHMkcCIsInN3YXBwZWRwYWlySW5mbyIsImZpcnN0RWRnZSIsIl9jdXJ2ZVN0eWxlIiwiX2VkZ2VJc1VuYnVuZGxlZCIsImNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24iLCJzcmNPdXRzaWRlIiwic3JjSW50biIsInRndE91dHNpZGUiLCJ0Z3RJbnRuIiwidmVjdG9yIiwidmVjdG9yTm9ybSIsInBhc3NlZFBhaXJJbmZvIiwic3RhcnRzV2l0aCIsImdldFB0cyIsIkJScCRiIiwibnBvcyIsIl90Z3RNYW5FbmRwdCRwZlZhbHVlIiwiX3NyY01hbkVuZHB0JHBmVmFsdWUiLCJ0Z3RBclNoYXBlIiwic3JjQXJTaGFwZSIsImV0IiwidGF4aSIsInNlZ21lbnRzIiwiaGFzRW5kcHRzIiwib3ZlcnJpZGVFbmRwdHMiLCJzcmNNYW5FbmRwdFZhbCIsInRndE1hbkVuZHB0VmFsIiwicDFfaSIsInAyX2kiLCJ0Z3RNYW5FbmRwdFB0Iiwic3JjTWFuRW5kcHRQdCIsImNwU3RhcnQiLCJjcEVuZCIsInNyY0Fycm93RnJvbVB0IiwidGd0QXJyb3dGcm9tUHQiLCJ0cnMiLCJsdzIiLCJsaDIiLCJ2YSIsImhhIiwibGFiZWxJbnRlcnNlY3QiLCJyZWZQdCIsImludFNxZGlzdCIsImxhYkludFNxZGlzdCIsImxhYkludDJTcURpc3QiLCJhcnJvd0VuZCIsImVkZ2VFbmQiLCJzcnMiLCJfbHciLCJfbGgiLCJfbHgiLCJfbHkiLCJfbHcyIiwiX2xoMiIsIl92YSIsIl9oYSIsIl9sYWJlbEludGVyc2VjdCIsIl9yZWZQdCIsIl9pbnRTcWRpc3QiLCJfbGFiSW50U3FkaXN0IiwiX21pblNxRGlzdCIsIl9sYWJJbnQyU3FEaXN0IiwiYXJyb3dTdGFydCIsImVkZ2VTdGFydCIsImJhZExpbmUiLCJCUnAkYSIsInB1c2hCZXppZXJQdHMiLCJxYmV6aWVyQXQkMSIsImJwdHMiLCJiZXppZXJQcm9qUGN0cyIsImxwdHMiLCJyZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyIsIkJScCQ5IiwicmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uIiwiY29udGVudCIsInRleHRYIiwidGV4dFkiLCJub2RlV2lkdGgiLCJub2RlSGVpZ2h0Iiwibm9kZVBvcyIsInRleHRIYWxpZ24iLCJ0ZXh0VmFsaWduIiwiYXBwbHlMYWJlbERpbWVuc2lvbnMiLCJsaW5lQW5nbGVGcm9tRGVsdGEiLCJsaW5lQW5nbGUiLCJiZXppZXJBbmdsZSIsInQwIiwibHAwIiwibHAxIiwic2V0UnMiLCJtaWRBbmdsZSIsIl9jcmVhdGVDb250cm9sUG9pbnRJbmZvIiwiY3JlYXRlQ29udHJvbFBvaW50SW5mbyIsInN0YXJ0RGlzdCIsIm5Qcm9qcyIsImFkZFNlZ21lbnQiLCJjcCIsInByZXZTZWdtZW50Iiwic2VnbWVudCIsInByZXZDcCIsImNhbGN1bGF0ZUVuZFByb2plY3Rpb24iLCJpc1NyYyIsImNwcyIsInRvdGFsRGlzdCIsIl9jcCIsIl9zZWciLCJsYXN0U2VnIiwic2VnIiwidFNlZ21lbnQiLCJzZWdEdCIsImRpIiwiZDAiLCJwRCIsIl90IiwiYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyIsImdldExhYmVsVGV4dCIsImNhY2hlS2V5IiwibGFiZWxEaW1zIiwiY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zIiwibGluZUhlaWdodCIsIm51bUxpbmVzIiwibm9ybVBlckxpbmVIZWlnaHQiLCJsYWJlbExpbmVIZWlnaHQiLCJwZmQiLCJ3cmFwU3R5bGUiLCJ6d3NwIiwibWF4VyIsIm92ZXJmbG93Iiwib3ZlcmZsb3dBbnkiLCJ3cmFwcGVkTGluZXMiLCJzZXBhcmF0b3JSZWdleCIsImxpbmVEaW1zIiwibGluZVciLCJwcm9jZXNzZWRMaW5lIiwic2VwYXJhdG9yTWF0Y2hlcyIsIm1hdGNoQWxsIiwic3VibGluZSIsInByZXZpb3VzSW5kZXgiLCJzZXBhcmF0b3JNYXRjaCIsIndvcmRTZXBhcmF0b3IiLCJ3b3JkIiwidGVzdExpbmUiLCJ0ZXN0RGltcyIsInRlc3RXIiwiX21heFciLCJlbGxpcHNpemVkIiwiZWxsaXBzaXMiLCJpbmNMYXN0Q2giLCJ3aWR0aFdpdGhOZXh0Q2giLCJnZXRMYWJlbEp1c3RpZmljYXRpb24iLCJmU3R5bGUiLCJmYW1pbHkiLCJjYW52YXMiLCJsYWJlbENhbGNDYW52YXMiLCJjMmQiLCJsYWJlbENhbGNDYW52YXNDb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJkcyIsInpJbmRleCIsInBvaW50ZXJFdmVudHMiLCJmb250IiwibWV0cmljcyIsIm1lYXN1cmVUZXh0IiwiY2FsY3VsYXRlTGFiZWxBbmdsZSIsInJvdCIsInJvdFN0ciIsImxhYmVsQXV0b0FuZ2xlIiwibGFiZWxBbmdsZSIsInNvdXJjZUxhYmVsQW5nbGUiLCJ0YXJnZXRMYWJlbEFuZ2xlIiwiQlJwJDgiLCJUT09fU01BTExfQ1VUX1JFQ1QiLCJ3YXJuZWRDdXRSZWN0IiwibWFrZVBvbHlnb24iLCJCUnAkNyIsInJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMiLCJlbGVzVG9VcGRhdGUiLCJkaXJ0eVN0eWxlQ2FjaGVzIiwiY2xlYW5Db25uZWN0ZWQiLCJiaW5kZXIiLCJvbkRpcnR5Qm91bmRzIiwib25EaXJ0eVN0eWxlIiwidXBkYXRlRWxlQ2FsY3MiLCJmbnMiLCJvblVwZGF0ZUVsZUNhbGNzRm5zIiwiZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUiLCJlbGVDYWxjcyIsIm9uVXBkYXRlRWxlQ2FsY3MiLCJpc0NsZWFuQ29ubmVjdGVkIiwiX3AyIiwiX3JzdHlsZSIsIm5vZGVXIiwibm9kZUgiLCJfcDMiLCJfcnN0eWxlMiIsIkJScCQ2IiwidXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMiLCJjYWNoZWRaU29ydGVkRWxlcyIsImRyYWciLCJub25kcmFnIiwiZ3JhYlRhcmdldHMiLCJpbkRyYWdMYXllciIsImludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcyIsImZvcmNlUmVjYWxjIiwiQlJwJDUiLCJCUnAkNCIsImdldENhY2hlZEltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbkxvYWQiLCJpbWFnZUNhY2hlIiwiaW1hZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiSW1hZ2UiLCJkYXRhVXJpUHJlZml4IiwiaXNEYXRhVXJpIiwiQlJwJDMiLCJyZWdpc3RlckJpbmRpbmciLCJ1c2VDYXB0dXJlIiwidGd0SXNEb20iLCJib2R5Iiwic3VwcG9ydHNQYXNzaXZlRXZlbnRzIiwic3VwcG9ydHNQYXNzaXZlIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJiaW5kaW5ncyIsIm5vZGVJc0RyYWdnYWJsZSIsIm5vZGVJc0dyYWJiYWJsZSIsImxvYWQiLCJpc1NlbGVjdGVkIiwiZ2V0U2hhZG93Um9vdCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJub2RlVHlwZSIsImhvc3QiLCJ0cmlnZ2VyRXZlbnRzIiwiaXNNdWx0U2VsS2V5RG93biIsInNoaWZ0S2V5IiwibWV0YUtleSIsImN0cmxLZXkiLCJhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCIsImRvd24iLCJkb3ducyIsImFsbG93UGFzc3Rocm91Z2giLCJzZXRHcmFiYmVkIiwic2V0RnJlZWQiLCJzZXRJbkRyYWdMYXllciIsInNldE91dERyYWdMYXllciIsInNldEdyYWJUYXJnZXQiLCJpc0dyYWJUYXJnZXQiLCJyZW1vdmVHcmFiVGFyZ2V0IiwiYWRkVG9EcmFnTGlzdCIsImxpc3QiLCJhZGRUb0xpc3QiLCJsaXN0SGFzRWxlIiwiYWRkRGVzY2VuZGFudHNUb0RyYWciLCJpbm5lck5vZGVzIiwiYWRkTm9kZXNUb0RyYWciLCJ1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciIsImFkZE5vZGVUb0RyYWciLCJmcmVlRHJhZ2dlZEVsZW1lbnRzIiwiZ3JhYmJlZEVsZXMiLCJibHVyQWN0aXZlRG9tRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiaGF2ZU11dGF0aW9uc0FwaSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJoYXZlUmVzaXplT2JzZXJ2ZXJBcGkiLCJSZXNpemVPYnNlcnZlciIsInJlbW92ZU9ic2VydmVyIiwibXV0bnMiLCJtdXRuIiwick5vZGVzIiwicmVtb3ZlZE5vZGVzIiwick5vZGUiLCJwYXJlbnROb2RlIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsIm9uUmVzaXplIiwic3R5bGVPYnNlcnZlciIsInJlc2l6ZU9ic2VydmVyIiwiaW52YWxpZGF0ZUNvb3JkcyIsImluQm94U2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZXZlbnRJbkNvbnRhaW5lciIsImNvbnRhaW5lclBhZ2VDb29yZHMiLCJ0b3VjaGVzIiwiYXRMZWFzdE9uZVBvc0luc2lkZSIsInRQYXJlbnQiLCJjb250YWluZXJJc1RhcmdldCIsIm1vdXNlZG93bkhhbmRsZXIiLCJob3ZlckRhdGEiLCJ3aGljaCIsImdwb3MiLCJzZWxlY3QiLCJuZWFycyIsImRyYWdnZWRFbGVtZW50cyIsImRyYWdEYXRhIiwicG9zc2libGVEcmFnRWxlbWVudHMiLCJtZG93blBvcyIsIm1kb3duR1BvcyIsIm1ha2VFdmVudCIsImNoZWNrRm9yVGFwaG9sZCIsInRhcGhvbGRDYW5jZWxsZWQiLCJ0YXBob2xkVGltZW91dCIsInRhcGhvbGREdXJhdGlvbiIsImN4dFN0YXJ0ZWQiLCJjeHRFdnQiLCJhY3RpdmF0ZSIsImRvd25UaW1lIiwiZ2V0VGltZSIsImN4dERyYWdnZWQiLCJ0cmlnZ2VyR3JhYiIsInNlbGVjdGVkTm9kZXMiLCJyZWRyYXdIaW50IiwiYmdBY3RpdmVQb3Npc3Rpb24iLCJyZWRyYXciLCJzaGFkb3dSb290IiwibW91c2Vtb3ZlSGFuZGxlciIsImRyYWdnaW5nRWxlcyIsImRyYWdnaW5nIiwic2VsZWN0aW5nIiwiaXNPdmVyVGhyZXNob2xkRHJhZyIsImR4MiIsImR5MiIsImRpc3QyIiwiZGVza3RvcFRhcFRocmVzaG9sZDIiLCJtdWx0U2VsS2V5RG93biIsInVwZGF0ZURyYWdEZWx0YSIsImRyYWdEZWx0YSIsImdvSW50b0JveE1vZGUiLCJjeHRPdmVyIiwiZGVsdGFQIiwianVzdFN0YXJ0ZWRQYW4iLCJtZFBvcyIsImRyYWdnZWQiLCJ1bmFjdGl2YXRlIiwiZGlkRHJhZyIsImp1c3RTdGFydGVkRHJhZyIsInRvdGFsU2hpZnQiLCJjbGlja1RpbWVvdXQiLCJkaWREb3VibGVDbGljayIsInByZXZDbGlja1RpbWVTdGFtcCIsIm1vdXNldXBIYW5kbGVyIiwiY3h0VGFwIiwiZWxlV291bGRCZVNlbGVjdGVkIiwiZG93bldhc0dyYWJiZWQiLCJ3aGVlbERlbHRhcyIsIndoZWVsRGVsdGFOIiwiaW5hY2N1cmF0ZVNjcm9sbERldmljZSIsImluYWNjdXJhdGVTY3JvbGxGYWN0b3IiLCJhbGxBcmVEaXZpc2libGVCeSIsImFsbEFyZVNhbWVNYWduaXR1ZGUiLCJmaXJzdE1hZyIsIndoZWVsSGFuZGxlciIsImNsYW1wIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwid2RzIiwic2Nyb2xsaW5nUGFnZSIsIndoZWVsWm9vbWluZyIsIndoZWVsVGltZW91dCIsIm5lZWRzV2hlZWxGaXgiLCJkZWx0YU1vZGUiLCJuZXdab29tIiwiZ2VzdHVyZVN0YXJ0Wm9vbSIsInNjcm9sbEhhbmRsZXIiLCJzY3JvbGxpbmdQYWdlVGltZW91dCIsImdlc3R1cmVTdGFydEhhbmRsZXIiLCJoYXNUb3VjaFN0YXJ0ZWQiLCJtb3VzZU91dEhhbmRsZXIiLCJtb3VzZU92ZXJIYW5kbGVyIiwiZjF4MSIsImYxeTEiLCJmMngxIiwiZjJ5MSIsImRpc3RhbmNlMSIsImRpc3RhbmNlMVNxIiwiY2VudGVyMSIsIm1vZGVsQ2VudGVyMSIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwidHdvRmluZ2Vyc1N0YXJ0SW5zaWRlIiwiZGlzdGFuY2VTcSIsInRvdWNoc3RhcnRIYW5kbGVyIiwidG91Y2hEYXRhIiwiZWFybGllciIsInNpbmdsZVRvdWNoTW92ZWQiLCJ0b3VjaERyYWdFbGVzIiwiY3h0RGlzdFRocmVzaG9sZCIsImN4dERpc3RUaHJlc2hvbGRTcSIsIm5lYXIxIiwibmVhcjIiLCJzdGFydHMiLCJkcmFnZ2VkRWxlcyIsInNpbmdsZVRvdWNoU3RhcnRUaW1lIiwicGluY2hpbmciLCJzUG9zIiwidG91Y2gwIiwic3RhcnRHUG9zaXRpb24iLCJ0b3VjaG1vdmVIYW5kbGVyIiwic3RhcnRHUG9zIiwidG91Y2hUYXBUaHJlc2hvbGQyIiwiZjF4MiIsImYxeTIiLCJmMngyIiwiZjJ5MiIsImRpc3RhbmNlMlNxIiwiZmFjdG9yU3EiLCJkaXN0VGhyZXNob2xkU3EiLCJmYWN0b3JUaHJlc2hvbGQiLCJmYWN0b3JUaHJlc2hvbGRTcSIsImxhc3RUaHJlZVRvdWNoIiwiZGlkU2VsZWN0IiwiZGVfcCIsIl9zdGFydCIsImRpc3RhbmNlMiIsImRmMXgiLCJkZjF5IiwiZGYyeCIsImRmMnkiLCJ0eCIsInR5IiwiY3RyeCIsImN0cnkiLCJzd2lwZVBhbm5pbmciLCJ0b3VjaGNhbmNlbEhhbmRsZXIiLCJ0b3VjaGVuZEhhbmRsZXIiLCJkaWREb3VibGVUb3VjaCIsInRvdWNoVGltZW91dCIsInByZXZUb3VjaFRpbWVTdGFtcCIsImN0eFRhcGVuZCIsImN0eFRhcCIsInN0YXJ0V2FzR3JhYmJlZCIsInJkaXN0MiIsIlRvdWNoRXZlbnQiLCJwb2ludGVycyIsIm1ha2VUb3VjaCIsImlkZW50aWZpZXIiLCJwb2ludGVySWQiLCJwYWdlWCIsInBhZ2VZIiwicmFkaXVzWCIsInJhZGl1c1kiLCJzY3JlZW5YIiwic2NyZWVuWSIsIm1ha2VQb2ludGVyIiwidG91Y2giLCJhZGRQb2ludGVyIiwicmVtb3ZlUG9pbnRlciIsInVwZGF0ZVBvaW50ZXIiLCJhZGRUb3VjaGVzVG9FdmVudCIsInBvaW50ZXJJc01vdXNlIiwicG9pbnRlclR5cGUiLCJCUnAkMiIsImdlbmVyYXRlUG9seWdvbiIsIm5vZGVTaGFwZUltcGwiLCJzdHJva2VQb3NpdGlvbiIsImdlbmVyYXRlRWxsaXBzZSIsImdlbmVyYXRlUm91bmRQb2x5Z29uIiwiZ2V0T3JDcmVhdGVDb3JuZXJzIiwiZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSIsImRpYW0iLCJnZW5lcmF0ZUN1dFJlY3RhbmdsZSIsImNvcm5lckxlbmd0aCIsImdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMiLCJjbCIsInhCZWdpbiIsInhFbmQiLCJ5QmVnaW4iLCJ5RW5kIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tUmlnaHQiLCJib3R0b21MZWZ0IiwiY1B0cyIsImN1dFRyaWFuZ2xlUHRzIiwiZ2VuZXJhdGVCYXJyZWwiLCJiUHRzIiwiZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMiLCJhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzIiwibTAiLCJtMSIsIm0yIiwiY3VydmVDb25zdGFudHMiLCJoT2Zmc2V0Iiwid09mZnNldCIsImN0cmxQdFhPZmZzZXQiLCJpc1RvcCIsImlzQm90dG9tIiwiYmFycmVsQ3VydmVQdHMiLCJnZXRDdXJ2ZVQiLCJjdXJ2ZVB0cyIsIngwIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsImNvZWZmIiwidmFsaWRSb290cyIsImN1cnZlUmVnaW9ucyIsImNvcm5lclB0cyIsImJlelkiLCJnZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlIiwidG9wSW50ZXJzZWN0aW9ucyIsInJlZ2lzdGVyTm9kZVNoYXBlcyIsImRpYW1vbmRQb2ludHMiLCJzdGFyNVBvaW50cyIsIm91dGVyUG9pbnRzIiwiaW5uZXJQb2ludHMiLCJpbm5lclJhZGl1cyIsInRhZ1BvaW50cyIsIkJScCQxIiwidGltZVRvUmVuZGVyIiwicmVkcmF3VG90YWxUaW1lIiwicmVkcmF3Q291bnQiLCJhdmVyYWdlUmVkcmF3VGltZSIsImxhc3RSZWRyYXdUaW1lIiwibGFzdERyYXdUaW1lIiwicmVxdWVzdGVkRnJhbWUiLCJyZW5kZXJPcHRpb25zIiwicHJpb3JpdHkiLCJjYnMiLCJiZWZvcmVSZW5kZXJDYWxsYmFja3MiLCJzdGFydFJlbmRlckxvb3AiLCJyZW5kZXJMb29wU3RhcnRlZCIsIl9yZW5kZXJGbiIsInJlbmRlckZuIiwicmVxdWVzdFRpbWUiLCJza2lwRnJhbWUiLCJyZW5kZXIiLCJlbmRUaW1lIiwiQmFzZVJlbmRlcmVyIiwiQlIiLCJCUnAiLCJjbGllbnRGdW5jdGlvbnMiLCJjdHIiLCJzdHlsZXNoZWV0SWQiLCJzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cyIsInRleHRDb250ZW50IiwiaW5zZXJ0QmVmb3JlIiwiY29tcHV0ZWRTdHlsZSIsInRyaWdnZXJNb2RlIiwiaW5pdGlhbFBhbiIsInJlZHJhd3MiLCJtb3Rpb25CbHVyRW5hYmxlZCIsImZvcmNlZFBpeGVsUmF0aW8iLCJtb3Rpb25CbHVyVHJhbnNwYXJlbmN5IiwibW90aW9uQmx1clB4UmF0aW8iLCJtYlB4UkJsdXJyeSIsIm1pbk1iTG93UXVhbEZyYW1lcyIsImZ1bGxRdWFsaXR5TWIiLCJjbGVhcmVkRm9yTW90aW9uQmx1ciIsImVsZVR4ckRlcSIsImx5clR4ckRlcSIsImx5clR4clNraXAiLCJtYXRjaENhbnZhc1NpemUiLCJiaW5kaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJsYWJlbENhbGNEaXYiLCJmdWxsRnBzVGltZSIsImRlZnMiLCJzZXR1cERlcXVldWVpbmciLCJzZXR1cERlcXVldWVpbmdJbXBsIiwiZGVxdWV1ZWluZ1NldHVwIiwicXVldWVSZWRyYXciLCJkZXFSZWRyYXdUaHJlc2hvbGQiLCJmcmFtZVN0YXJ0VGltZSIsImF2Z1JlbmRlclRpbWUiLCJyZW5kZXJUaW1lIiwiZGVxZCIsImdldFBpeGVsUmF0aW8iLCJmcmFtZUR1cmF0aW9uIiwidGltZUF2YWlsYWJsZSIsImRlcUZhc3RDb3N0IiwiZGVxQ29zdCIsImRlcUF2Z0Nvc3QiLCJkZXFOb0RyYXdDb3N0IiwidGhpc0RlcWQiLCJkZXEiLCJvbkRlcWQiLCJzaG91bGRSZWRyYXciLCJFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwIiwiZG9lc0VsZUludmFsaWRhdGVLZXkiLCJpZHNCeUtleSIsImtleUZvcklkIiwiY2FjaGVzQnlMdmwiLCJsdmxzIiwiZ2V0SWRzRm9yIiwiYWRkSWRGb3JLZXkiLCJkZWxldGVJZEZvcktleSIsImdldE51bWJlck9mSWRzRm9yS2V5IiwidXBkYXRlS2V5TWFwcGluZ0ZvciIsImN1cnJLZXkiLCJkZWxldGVLZXlNYXBwaW5nRm9yIiwia2V5SGFzQ2hhbmdlZEZvciIsIm5ld0tleSIsImlzSW52YWxpZCIsImdldENhY2hlc0F0IiwibHZsIiwiY2FjaGVzIiwiZ2V0Q2FjaGUiLCJnZXRGb3JDYWNoZWRLZXkiLCJoYXNDYWNoZSIsInNldENhY2hlIiwiZGVsZXRlQ2FjaGUiLCJpbnZhbGlkYXRlS2V5IiwiaW52YWxpZGF0ZSIsImVudGlyZUtleUludmFsaWRhdGVkIiwibWluVHhySCIsInR4clN0ZXBIIiwibWluTHZsJDEiLCJtYXhMdmwkMSIsIm1heFpvb20kMSIsImVsZVR4clNwYWNpbmciLCJkZWZUeHJXaWR0aCIsIm1heFR4clciLCJtYXhUeHJIIiwibWluVXRpbGl0eSIsIm1heEZ1bGxuZXNzIiwibWF4RnVsbG5lc3NDaGVja3MiLCJkZXFDb3N0JDEiLCJkZXFBdmdDb3N0JDEiLCJkZXFOb0RyYXdDb3N0JDEiLCJkZXFGYXN0Q29zdCQxIiwiZGVxUmVkcmF3VGhyZXNob2xkJDEiLCJtYXhEZXFTaXplJDEiLCJnZXRUeHJSZWFzb25zIiwiZG93bnNjYWxlIiwiaGlnaFF1YWxpdHkiLCJpbml0RGVmYXVsdHMiLCJkcmF3RWxlbWVudCIsImdldEJvdW5kaW5nQm94IiwiZ2V0Um90YXRpb25Qb2ludCIsImdldFJvdGF0aW9uT2Zmc2V0IiwiaXNWaXNpYmxlIiwiYWxsb3dFZGdlVHhyQ2FjaGluZyIsImFsbG93UGFyZW50VHhyQ2FjaGluZyIsIkVsZW1lbnRUZXh0dXJlQ2FjaGUiLCJpbml0T3B0aW9ucyIsIm9uRGVxdWV1ZXMiLCJFVENwIiwicmVhc29ucyIsImdldFRleHR1cmVRdWV1ZSIsInR4ckgiLCJlbGVJbWdDYWNoZXMiLCJnZXRSZXRpcmVkVGV4dHVyZVF1ZXVlIiwicnR4dHJRcyIsInJldGlyZWQiLCJydHh0clEiLCJnZXRFbGVtZW50UXVldWUiLCJlbGVDYWNoZVF1ZXVlIiwicmVxcyIsImdldEVsZW1lbnRLZXlUb1F1ZXVlIiwiazJxIiwiZWxlS2V5VG9DYWNoZVF1ZXVlIiwiZ2V0RWxlbWVudCIsInJlYXNvbiIsImVsZVNjYWxlZEgiLCJlbGVTY2FsZWRXIiwic2NhbGVkTGFiZWxTaG93biIsImVsZVRleHRCaWdnZXJUaGFuTWluIiwiZWxlQ2FjaGUiLCJpbnZhbGlkYXRlZCIsInRleHR1cmUiLCJpbnZhbGlkYXRlZFdpZHRoIiwidHhyUSIsInR4ciIsImFkZE5ld1R4ciIsInJlY3ljbGVUZXh0dXJlIiwiYWRkVGV4dHVyZSIsInVzZWRXaWR0aCIsInNjYWxhYmxlRnJvbSIsIm90aGVyQ2FjaGUiLCJkZXFpbmciLCJoaWdoUXVhbGl0eVJlcSIsImRvd25zY2FsZVJlcSIsImhpZ2hlckNhY2hlIiwib25lVXBDYWNoZSIsImRyYXdJbWFnZSIsInNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsInF1ZXVlRWxlbWVudCIsImxvd2VyQ2FjaGUiLCJfbDIiLCJ0cmFuc2xhdGUiLCJlbGVDYWNoZXMiLCJjaGVja1RleHR1cmVGdWxsbmVzcyIsImludmFsaWRhdGVFbGVtZW50cyIsImludmFsaWRhdGVFbGVtZW50Iiwibm9PdGhlckVsZXNVc2VDYWNoZSIsIl9jYWNoZSIsImNoZWNrVGV4dHVyZVV0aWxpdHkiLCJyZW1vdmVGcm9tUXVldWUiLCJyZXRpcmVUZXh0dXJlIiwiZnVsbG5lc3NDaGVja3MiLCJtaW5XIiwibWFrZU9mZnNjcmVlbkNhbnZhcyIsImV4aXN0aW5nUmVxIiwicmVxIiwiZGVxdWV1ZWQiLCJjYWNoZUV4aXN0cyIsIm9uRGVxdWV1ZSIsIm9mZkRlcXVldWUiLCJkZWZOdW1MYXllcnMiLCJtaW5MdmwiLCJtYXhMdmwiLCJyZWZpbmVFbGVEZWJvdW5jZVRpbWUiLCJtYXhEZXFTaXplIiwiaW52YWxpZFRocmVzaG9sZCIsIm1heExheWVyQXJlYSIsIm1heExheWVyRGltIiwidXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzIiwiTGF5ZXJlZFRleHR1cmVDYWNoZSIsImxheWVyc0J5TGV2ZWwiLCJmaXJzdEdldCIsImxhc3RJbnZhbGlkYXRpb25UaW1lIiwic2tpcHBpbmciLCJlbGVUeHJEZXFzIiwic2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCIsInJlZmluZUVsZW1lbnRUZXh0dXJlcyIsInFTb3J0IiwibGF5ZXJzUXVldWUiLCJMVENwIiwibGF5ZXJJZFBvb2wiLCJNQVhfSU5UIiwibWFrZUxheWVyIiwibGF5ZXIiLCJlbGVzUXVldWUiLCJnZXRMYXllcnMiLCJ2YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyIsImxheWVyc0J5THZsIiwibGF5ZXJzIiwibHZsQ29tcGxldGUiLCJsZXZlbElzQ29tcGxldGUiLCJ0bXBMYXllcnMiLCJjaGVja1RlbXBMZXZlbHMiLCJjYW5Vc2VBc1RtcEx2bCIsImNoZWNrTHZscyIsImRpciIsImdldEJiIiwiYWZ0ZXIiLCJhcmVhIiwibWF4RWxlc1BlckxheWVyIiwiYWxsb3dMYXp5UXVldWVpbmciLCJpbWdMYXllckNhY2hlcyIsImV4aXN0aW5nTGF5ZXIiLCJxdWV1ZUxheWVyIiwiZHJhd0VsZUluTGF5ZXIiLCJnZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwiLCJzZXRJbWdTbW9vdGhpbmciLCJkcmF3Q2FjaGVkRWxlbWVudCIsIm51bUVsZXNJbkxheWVycyIsImludmFsaWRhdGVMYXllciIsInVwZGF0ZUVsZW1lbnRzSW5MYXllcnMiLCJoYXZlTGF5ZXJzIiwiaW52YWxBc3NvY0xheWVycyIsInJlcGxhY2VtZW50IiwicmVmaW5lRWFjaEVsZSIsInJMeXIiLCJyZXBsYWNlcyIsImVucXVldWVFbGVtZW50UmVmaW5lbWVudCIsImVsZXNRIiwiaGFzSWQiLCJlbGVEZXFzIiwiYXBwbHlMYXllclJlcGxhY2VtZW50IiwicmVxdWVzdFJlZHJhdyIsImxheWVyc0luTGV2ZWwiLCJyZXBsYWNlZCIsIkNScCRiIiwidHJpYW5nbGVCYWNrY3VydmUiLCJmaXJzdFB0IiwicXVhZHJhdGljQ3VydmVUbyIsInRyaWFuZ2xlVGVlIiwidHJpYW5nbGVQb2ludHMiLCJ0ZWVQb2ludHMiLCJiZWdpblBhdGgiLCJmaXJzdFRlZVB0IiwibW92ZVRvIiwiY2xvc2VQYXRoIiwiY2lyY2xlVHJpYW5nbGUiLCJmaXJzdFRyUHQiLCJjaXJjbGUkMSIsIkNScCRhIiwic2hpZnRUb09yaWdpbldpdGhCYiIsInNob3dMYWJlbCIsInNob3dPdmVybGF5Iiwic2hvd09wYWNpdHkiLCJkcmF3Tm9kZSIsImRyYXdFZGdlIiwiZHJhd0VsZW1lbnRPdmVybGF5IiwiZHJhd05vZGVPdmVybGF5IiwiZHJhd0VkZ2VPdmVybGF5IiwiZHJhd0VsZW1lbnRVbmRlcmxheSIsImRyYXdOb2RlVW5kZXJsYXkiLCJkcmF3RWRnZVVuZGVybGF5IiwiZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uIiwiZWxlVHhyQ2FjaGUiLCJnZXRSb3RhdGlvbiIsImdldE9wYWNpdHkiLCJzbW9vdGgiLCJyb3RQdCIsImdldEltZ1Ntb290aGluZyIsIm9sZEdsb2JhbEFscGhhIiwiZ2xvYmFsQWxwaGEiLCJnZXRaZXJvUm90YXRpb24iLCJnZXRMYWJlbFJvdGF0aW9uIiwiZ2V0VGV4dEFuZ2xlIiwiZ2V0U291cmNlTGFiZWxSb3RhdGlvbiIsImdldFRhcmdldExhYmVsUm90YXRpb24iLCJnZXRUZXh0T3BhY2l0eSIsInJlcXVlc3RIaWdoUXVhbGl0eSIsIl9yJGRhdGEiLCJsYmxUeHJDYWNoZSIsInNsYlR4ckNhY2hlIiwidGxiVHhyQ2FjaGUiLCJkcmF3RWxlbWVudHMiLCJkcmF3Q2FjaGVkRWxlbWVudHMiLCJkcmF3Q2FjaGVkTm9kZXMiLCJkcmF3TGF5ZXJlZEVsZW1lbnRzIiwibHlyVHhyQ2FjaGUiLCJDUnAkOSIsImRyYXdMYWJlbCIsInNob3VsZERyYXdPdmVybGF5Iiwic2hvdWxkRHJhd09wYWNpdHkiLCJsaW5lT3BhY2l0eSIsImxpbmVPdXRsaW5lV2lkdGgiLCJsaW5lT3V0bGluZUNvbG9yIiwiZWZmZWN0aXZlTGluZU9wYWNpdHkiLCJlZmZlY3RpdmVBcnJvd09wYWNpdHkiLCJkcmF3TGluZSIsInN0cm9rZU9wYWNpdHkiLCJlbGVTdHJva2VTdHlsZSIsImRyYXdFZGdlVHJpYW5nbGVQYXRoIiwibGluZVdpZHRoIiwiZHJhd0VkZ2VQYXRoIiwiZHJhd0xpbmVPdXRsaW5lIiwiY29sb3JTdHJva2VTdHlsZSIsImRyYXdPdmVybGF5IiwiZHJhd1VuZGVybGF5IiwiZHJhd0Fycm93cyIsImFycm93T3BhY2l0eSIsImRyYXdBcnJvd2hlYWRzIiwiZHJhd1RleHQiLCJkcmF3RWxlbWVudFRleHQiLCJnaG9zdE9wYWNpdHkiLCJlZmZlY3RpdmVHaG9zdE9wYWNpdHkiLCJkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSIsIm92ZXJsYXlPclVuZGVybGF5IiwiaW5jbHVkZXMiLCJ1c2VQYXRocyIsImNhbnZhc0N4dCIsInBhdGhDYWNoZUhpdCIsImxpbmVEYXNoUGF0dGVybiIsImxpbmVEYXNoT2Zmc2V0IiwicGF0aENhY2hlS2V5Iiwia2V5TWF0Y2hlcyIsInBhdGhDYWNoZSIsIlBhdGgyRCIsInNldExpbmVEYXNoIiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJ0cmlhbmdsZUhlYWQiLCJkcmF3QXJyb3doZWFkIiwiYXJyb3dDbGVhckZpbGwiLCJwQXJyb3dXaWR0aCIsImVkZ2VPcGFjaXR5IiwiZ2NvIiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiY29sb3JGaWxsU3R5bGUiLCJkcmF3QXJyb3dTaGFwZSIsInNoYXBlV2lkdGgiLCJjYW52YXNDb250ZXh0Iiwic2hhcGVJbXBsIiwiYXJyb3dQYXRoQ2FjaGUiLCJjYWNoZWRQYXRoIiwiQ1JwJDgiLCJzYWZlRHJhd0ltYWdlIiwiaW1nIiwiaXgiLCJpeSIsIml3IiwiaWgiLCJkcmF3SW5zY3JpYmVkSW1hZ2UiLCJub2RlT3BhY2l0eSIsInN0eWxlT2JqIiwicmVwZWF0IiwicGFkZGluZ1gyIiwibm9kZVRXIiwibm9kZVRIIiwiY2xpcCIsInNob3VsZENsaXAiLCJpbWdPcGFjaXR5IiwiaW1nVyIsImNhY2hlZFciLCJpbWdIIiwiY2FjaGVkSCIsImFwcGVuZENoaWxkIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJwb3NYVW5pdHMiLCJwb3NYUGZWYWwiLCJvZmZYVW5pdHMiLCJvZmZYUGZWYWwiLCJwb3NZVW5pdHMiLCJwb3NZUGZWYWwiLCJvZmZZVW5pdHMiLCJvZmZZUGZWYWwiLCJnQWxwaGEiLCJzbW9vdGhpbmdFbmFibGVkIiwiaXNTbW9vdGhpbmdTd2l0Y2hlZCIsInNhdmUiLCJjcmVhdGVQYXR0ZXJuIiwiQ1JwJDciLCJjb21wdXRlZFNpemUiLCJtaW5TaXplIiwidXNlRWxlT3BhY2l0eSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsIl9sYWJlbCIsInNyY0xhYmVsIiwidGd0TGFiZWwiLCJhcHBseVJvdGF0aW9uIiwiZ2V0Rm9udENhY2hlIiwiZm9udENhY2hlcyIsInNldHVwVGV4dFN0eWxlIiwibGFiZWxTdHlsZSIsImxhYmVsU2l6ZSIsImxhYmVsRmFtaWx5IiwibGFiZWxXZWlnaHQiLCJvdXRsaW5lQ29sb3IiLCJkaWFtZXRlciIsInJvdW5kUmVjdCIsInBkYXNoIiwidGV4dEFuZ2xlIiwib3JnVGV4dFgiLCJvcmdUZXh0WSIsInRleHRXIiwidGV4dEgiLCJiYWNrZ3JvdW5kT3BhY2l0eSIsInRleHRCb3JkZXJXaWR0aCIsImJhY2tncm91bmRQYWRkaW5nIiwic3R5bGVTaGFwZSIsInJvdW5kZWQiLCJjaXJjbGVkIiwicm91bmRSYWRpdXMiLCJ0ZXh0RmlsbCIsInRleHRTdHJva2UiLCJ0ZXh0TGluZVdpZHRoIiwidGV4dEJhY2tncm91bmRDb2xvciIsInRleHRCb3JkZXJDb2xvciIsInRleHRCb3JkZXJTdHlsZSIsImRvRmlsbCIsImRvU3Ryb2tlIiwiYmdYIiwiYmdZIiwiYmdXIiwiYmdIIiwid2hpdGVXaWR0aCIsImhhbGZUZXh0VyIsInN0cm9rZVRleHQiLCJmaWxsVGV4dCIsIkNScCQ2IiwiZWxlT3BhY2l0eSIsImJnSW1nUHJvcCIsInVybERlZmluZWQiLCJudW1JbWFnZXMiLCJkZWZkIiwiYmdJbWdDcm9zc09yaWdpbiIsImJhY2tncm91bmRUaW1lc3RhbXAiLCJkYXJrbmVzcyIsImJnT3BhY2l0eSIsImJvcmRlckNvbG9yIiwiYm9yZGVySm9pbiIsImJvcmRlckNhcCIsImJvcmRlclBhdHRlcm4iLCJib3JkZXJPZmZzZXQiLCJvdXRsaW5lU3R5bGUiLCJzZXR1cFNoYXBlQ29sb3IiLCJiZ09weSIsImVsZUZpbGxTdHlsZSIsInNldHVwQm9yZGVyQ29sb3IiLCJiZHJPcHkiLCJzZXR1cE91dGxpbmVDb2xvciIsIm90bG5PcHkiLCJnZXRQYXRoIiwibm9kZVBhdGhDYWNoZSIsInNoYXBlUHRzIiwic2hhcGVQYXRoIiwiZHJhd1NoYXBlIiwiZHJhd0ltYWdlcyIsInByZXZCZ2luZyIsInRvdGFsQ29tcGxldGVkIiwiZHJhd1BpZSIsInJlZHJhd1NoYXBlIiwicGllT3BhY2l0eSIsImRyYXdTdHJpcGUiLCJzdHJpcGVPcGFjaXR5IiwiZGFya2VuIiwiZGFya2VuT3BhY2l0eSIsImRyYXdCb3JkZXIiLCJyZWdpb24iLCJhZGRQYXRoIiwiZHJhd091dGxpbmUiLCJiV2lkdGgiLCJzY2FsZVgiLCJzY2FsZVkiLCJzV2lkdGgiLCJzSGVpZ2h0IiwiX3BhdGgiLCJvdXRsaW5lUGF0aCIsImRyYXdFbGxpcHNlUGF0aCIsInNNdWx0IiwiZHJhd1JvdW5kUG9seWdvblBhdGgiLCJkcmF3Um91bmRSZWN0YW5nbGVQYXRoIiwiZHJhd0N1dFJlY3RhbmdsZVBhdGgiLCJkcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoIiwiZHJhd0JhcnJlbFBhdGgiLCJkcmF3UG9seWdvblBhdGgiLCJfcGFkIiwiZWZmR2hvc3RPcGFjaXR5IiwiZHJhd05vZGVPdmVybGF5VW5kZXJsYXkiLCJjeVN0eWxlIiwicGllU2l6ZSIsImhvbGUiLCJvdmVyYWxsU3RhcnRBbmdsZSIsImhvbGVSYWRpdXMiLCJsYXN0UGVyY2VudCIsImFuZ2xlU3RhcnQiLCJhbmdsZURlbHRhIiwiYW5nbGVFbmQiLCJzdHJpcGVTaXplIiwic3RyaXBlVyIsInN0cmlwZUgiLCJDUnAkNSIsIm1vdGlvbkJsdXJEZWxheSIsImNvbnRleHRzIiwiYmFja2luZ1N0b3JlIiwiYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwibXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwib0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwicGFpbnRDYWNoZSIsInBhaW50Q2FjaGVzIiwibmVlZFRvQ3JlYXRlQ2FjaGUiLCJjcmVhdGVHcmFkaWVudFN0eWxlRm9yIiwic2hhcGVTdHlsZU5hbWUiLCJncmFkaWVudFN0eWxlIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJfZW5kIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiaGFzUG9zaXRpb25zIiwiYWRkQ29sb3JTdG9wIiwiZ3JhZGllbnRGaWxsU3R5bGUiLCJiYWNrZ3JvdW5kRmlsbCIsImJhY2tncm91bmRDb2xvciIsImdyYWRpZW50U3Ryb2tlU3R5bGUiLCJsaW5lRmlsbCIsImxpbmVDb2xvciIsIm1iUHhSYXRpbyIsImJ1ZmZlckNhbnZhc2VzIiwiTU9USU9OQkxVUl9CVUZGRVJfTk9ERSIsIk1PVElPTkJMVVJfQlVGRkVSX0RSQUciLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImNhbnZhc0NvbnRhaW5lciIsIkNBTlZBU19MQVlFUlMiLCJjYW52YXNlcyIsIkJVRkZFUl9DT1VOVCIsInRleHR1cmVNdWx0IiwiVEVYVFVSRV9CVUZGRVIiLCJmb3JjZWRDb250ZXh0IiwiZm9yY2VkWm9vbSIsImZvcmNlZFBhbiIsImRyYXdBbGxMYXllcnMiLCJmb3JjZWRQeFJhdGlvIiwiY2xlYXJDYW52YXMiLCJOT0RFIiwiRFJBRyIsImRyYXdPbmx5Tm9kZUxheWVyIiwibmVlZERyYXciLCJjYW52YXNOZWVkc1JlZHJhdyIsInRleHR1cmVEcmF3IiwiaW5Ob2RlRHJhZ0dlc3R1cmUiLCJtb3Rpb25CbHVyRmFkZUVmZmVjdCIsInByZXZQeFJhdGlvIiwibW90aW9uQmx1clRpbWVvdXQiLCJtYkZyYW1lcyIsImNsZWFyaW5nTW90aW9uQmx1ciIsInRleHR1cmVEcmF3TGFzdEZyYW1lIiwiU0VMRUNUX0JPWCIsImVmZmVjdGl2ZVpvb20iLCJlZmZlY3RpdmVQYW4iLCJwcmV2VnAiLCJwcmV2Vmlld3BvcnQiLCJ2aWV3cG9ydElzRGlmZiIsIm1iY2xlYXIiLCJmaWxsUmVjdCIsInNldENvbnRleHRUcmFuc2Zvcm0iLCJlUGFuIiwiZVpvb20iLCJidWZmZXJDb250ZXh0cyIsInRleHR1cmVDYWNoZSIsIm1wYW4iLCJvdXRzaWRlQmdDb2xvciIsIm91dHNpZGVCZ09wYWNpdHkiLCJ2cE1hbmlwIiwiaGlkZUVkZ2VzIiwibmVlZE1iQ2xlYXIiLCJ1c2VCdWZmZXIiLCJkcmF3RGVidWdQb2ludHMiLCJkcmF3U2VsZWN0aW9uUmVjdGFuZ2xlIiwiY3h0Tm9kZSIsInR4dE5vZGUiLCJjeHREcmFnIiwidHh0RHJhZyIsImRyYXdNb3Rpb25CbHVyIiwidHh0IiwibmVlZENsZWFyIiwicHhyIiwibW90aW9uQmx1ckNsZWFyZWQiLCJmcHNIZWlnaHQiLCJzdHJva2VSZWN0IiwiZnBzIiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJtYXhGcHMiLCJjb21waWxlU2hhZGVyIiwiZ2wiLCJzaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJjcmVhdGVQcm9ncmFtIiwidmVydGV4U291cmNlIiwiZnJhZ2VtZW50U291cmNlIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImZyYWdtZW50U2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwicHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiY3JlYXRlVGV4dHVyZUNhbnZhcyIsImdldEVmZmVjdGl2ZVBhblpvb20iLCJnZXRFZmZlY3RpdmVab29tIiwiaXNTaW1wbGVTaGFwZSIsImFycmF5RXF1YWwiLCJ0b1dlYkdMQ29sb3IiLCJvdXRBcnJheSIsImluZGV4VG9WZWM0IiwidmVjNFRvSW5kZXgiLCJ2ZWM0IiwiY3JlYXRlVGV4dHVyZSIsImRlYnVnSUQiLCJidWZmZXIiLCJvZmZzY3JlZW5DYW52YXMiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJURVhUVVJFX01BR19GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJMSU5FQVJfTUlQTUFQX05FQVJFU1QiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsImdlbmVyYXRlTWlwbWFwIiwiZGVsZXRlVGV4dHVyZSIsImdldFR5cGVJbmZvIiwiZ2xzbFR5cGUiLCJGTE9BVCIsIklOVCIsImNyZWF0ZVR5cGVkQXJyYXkiLCJnbFR5cGUiLCJkYXRhT3JTaXplIiwiSW50MzJBcnJheSIsImNyZWF0ZVR5cGVkQXJyYXlWaWV3Iiwic3RyaWRlIiwiY3JlYXRlQnVmZmVyU3RhdGljRHJhdyIsImF0dHJpYnV0ZUxvYyIsImRhdGFBcnJheSIsIl9nZXRUeXBlSW5mbyIsIl9nZXRUeXBlSW5mbzIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwidmVydGV4QXR0cmliUG9pbnRlciIsInZlcnRleEF0dHJpYklQb2ludGVyIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyIsImluc3RhbmNlcyIsIl9nZXRUeXBlSW5mbzMiLCJfZ2V0VHlwZUluZm80IiwiYnl0ZXMiLCJEWU5BTUlDX0RSQVciLCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yIiwidmlld3MiLCJnZXRWaWV3Iiwic2V0UG9pbnQiLCJ2aWV3IiwiYnVmZmVyU3ViRGF0YSIsImNyZWF0ZTN4M01hdHJpeEJ1ZmZlckR5bmFtaWNEcmF3IiwibWF0cml4U2l6ZSIsIm1hdHJpeERhdGEiLCJtYXRyaXhWaWV3cyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwibG9jIiwiZ2V0TWF0cml4VmlldyIsInNldERhdGEiLCJjcmVhdGVQaWNraW5nRnJhbWVCdWZmZXIiLCJmYiIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJ0YXJnZXRUZXh0dXJlIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsInNldEZyYW1lYnVmZmVyQXR0YWNobWVudFNpemVzIiwiQVJSQVlfVFlQRSIsIm11bHRpcGx5IiwiYTAwIiwiYTAxIiwiYTAyIiwiYTEwIiwiYTExIiwiYTEyIiwiYTIwIiwiYTIxIiwiYTIyIiwiYjAwIiwiYjAxIiwiYjAyIiwiYjEwIiwiYjExIiwiYjEyIiwiYjIwIiwiYjIxIiwiYjIyIiwicmFkIiwiQXRsYXMiLCJ0ZXhTaXplIiwidGV4Um93cyIsInRleEhlaWdodCIsImVuYWJsZVdyYXBwaW5nIiwibmVlZHNCdWZmZXIiLCJmcmVlUG9pbnRlciIsImtleVRvTG9jYXRpb24iLCJsb2NrIiwiZ2V0S2V5cyIsImdldFNjYWxlIiwibWF4VGV4V2lkdGgiLCJ0ZXhXIiwidGV4SCIsImRvRHJhd2luZyIsIl90aGlzJGdldFNjYWxlIiwiZHJhd0F0IiwibG9jYXRpb24iLCJ4T2Zmc2V0IiwieU9mZnNldCIsImxvY2F0aW9ucyIsImRyYXdOb3JtYWwiLCJkcmF3V3JhcHBlZCIsImZpcnN0VGV4VyIsInNlY29uZFRleFciLCJfZHkiLCJtb3ZlVG9TdGFydE9mTmV4dFJvdyIsImdldE9mZnNldHMiLCJpc0VtcHR5IiwiY2FuRml0IiwiX3RoaXMkZ2V0U2NhbGUyIiwiYnVmZmVySWZOZWVkZWQiLCJkaXNwb3NlIiwiQXRsYXNDb2xsZWN0aW9uIiwiYXRsYXNlcyIsInN0eWxlS2V5VG9BdGxhcyIsIm1hcmtlZEtleXMiLCJfY3JlYXRlQXRsYXMiLCJfZ2V0U2NyYXRjaENhbnZhcyIsImF0bGFzIiwiZ2V0QXRsYXMiLCJoYXNBdGxhcyIsIm1hcmtLZXlGb3JHQyIsIl90aGlzMiIsIm5ld0F0bGFzZXMiLCJuZXdTdHlsZUtleVRvQXRsYXMiLCJuZXdBdGxhcyIsImtleXNUb0NvbGxlY3QiLCJfYXRsYXMkZ2V0T2Zmc2V0cyIsIl9hdGxhcyRnZXRPZmZzZXRzMiIsInMxIiwiczIiLCJfY29weVRleHR1cmVUb05ld0F0bGFzIiwib2xkQXRsYXMiLCJfb2xkQXRsYXMkZ2V0T2Zmc2V0cyIsIl9vbGRBdGxhcyRnZXRPZmZzZXRzMiIsImdldENvdW50cyIsImtleUNvdW50IiwiYXRsYXNDb3VudCIsInZhbHVlcyIsInNldDEiLCJzZXQyIiwiQXRsYXNNYW5hZ2VyIiwiZ2xvYmFsT3B0aW9ucyIsImF0bGFzU2l6ZSIsIm1heEF0bGFzZXNQZXJCYXRjaCIsInJlbmRlclR5cGVzIiwiY29sbGVjdGlvbnMiLCJ0eXBlQW5kSWRUb0tleSIsImdldEF0bGFzU2l6ZSIsImFkZEF0bGFzQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25OYW1lIiwiYXRsYXNDb2xsZWN0aW9uT3B0aW9ucyIsIl90aGlzJGdsb2JhbE9wdGlvbnMiLCJjYWNoZWRDcmVhdGVUZXh0dXJlQ2FudmFzIiwiX2NhY2hlU2NyYXRjaENhbnZhcyIsImF0bGFzQ29sbGVjdGlvbiIsImFkZFJlbmRlclR5cGUiLCJyZW5kZXJUeXBlT3B0aW9ucyIsImdldFJlbmRlclR5cGVPcHRzIiwiZ2V0QXRsYXNDb2xsZWN0aW9uIiwicHJldlciLCJwcmV2SCIsInNjcmF0Y2hDYW52YXMiLCJyZW5kZXJUeXBlIiwiX3RoaXMzIiwiX3JlZjIkZm9yY2VSZWRyYXciLCJmb3JjZVJlZHJhdyIsIl9yZWYyJGZpbHRlckVsZSIsImZpbHRlckVsZSIsIl9yZWYyJGZpbHRlclR5cGUiLCJmaWx0ZXJUeXBlIiwibmVlZEdDIiwicnVuR0NOb3ciLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiX2l0ZXJhdG9yNCIsIl9zdGVwNCIsImtleUFycmF5IiwiZ2V0SUQiLCJtYXBLZXkiLCJvbGRLZXlBcnJheSIsIm9sZEtleSIsIl9pdGVyYXRvcjUiLCJfc3RlcDUiLCJnZXRPckNyZWF0ZUF0bGFzIiwiZHJhd24iLCJkcmF3Q2xpcHBlZCIsImdldEF0bGFzSW5mbyIsIl90aGlzNCIsIl9hdGxhcyRnZXRPZmZzZXRzMyIsIl9hdGxhcyRnZXRPZmZzZXRzNCIsInRleDEiLCJ0ZXgyIiwidGV4IiwiZ2V0RGVidWdJbmZvIiwiZGVidWdJbmZvIiwiX2l0ZXJhdG9yNiIsIl9zdGVwNiIsIl9zdGVwNiR2YWx1ZSIsIl9jb2xsZWN0aW9uJGdldENvdW50cyIsIkF0bGFzQmF0Y2hNYW5hZ2VyIiwiYmF0Y2hBdGxhc2VzIiwiZ2V0TWF4QXRsYXNlc1BlckJhdGNoIiwiZ2V0SW5kZXhBcnJheSIsImdldEF0bGFzQ291bnQiLCJnZXRBdGxhc2VzIiwiY2FuQWRkVG9DdXJyZW50QmF0Y2giLCJnZXRBdGxhc0luZGV4Rm9yQmF0Y2giLCJhdGxhc0lEIiwiY2lyY2xlU0QiLCJyZWN0YW5nbGVTRCIsInJvdW5kUmVjdGFuZ2xlU0QiLCJlbGxpcHNlU0QiLCJSRU5ERVJfVEFSR0VUIiwiU0NSRUVOIiwic2NyZWVuIiwiUElDS0lORyIsInBpY2tpbmciLCJURVhfUElDS0lOR19NT0RFIiwiSUdOT1JFIiwiVVNFX0JCIiwiVEVYVFVSRSIsIkVER0VfU1RSQUlHSFQiLCJFREdFX0NVUlZFX1NFR01FTlQiLCJFREdFX0FSUk9XIiwiUkVDVEFOR0xFIiwiUk9VTkRfUkVDVEFOR0xFIiwiQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSIsIkVMTElQU0UiLCJFbGVtZW50RHJhd2luZ1dlYkdMIiwibWF4SW5zdGFuY2VzIiwiYmdDb2xvciIsImJhdGNoRGVidWdJbmZvIiwiYXRsYXNNYW5hZ2VyIiwiYmF0Y2hNYW5hZ2VyIiwic2ltcGxlU2hhcGVPcHRpb25zIiwiX2NyZWF0ZVNoYWRlclByb2dyYW0iLCJwaWNraW5nUHJvZ3JhbSIsInZhbyIsIl9jcmVhdGVWQU8iLCJhZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlIiwidHlwZU5hbWUiLCJhZGRTaW1wbGVTaGFwZVJlbmRlclR5cGUiLCJyZW5kZXJUYXJnZXQiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJpZHhzIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJhUG9zaXRpb24iLCJnZXRBdHRyaWJMb2NhdGlvbiIsImFJbmRleCIsImFWZXJ0VHlwZSIsImFUcmFuc2Zvcm0iLCJhQXRsYXNJZCIsImFUZXgiLCJhUG9pbnRBUG9pbnRCIiwiYVBvaW50Q1BvaW50RCIsImFMaW5lV2lkdGgiLCJhQ29sb3IiLCJhQ29ybmVyUmFkaXVzIiwiYUJvcmRlckNvbG9yIiwidVBhblpvb21NYXRyaXgiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ1QXRsYXNTaXplIiwidUJHQ29sb3IiLCJ1Wm9vbSIsInVUZXh0dXJlcyIsInVuaXRTcXVhcmUiLCJ2ZXJ0ZXhDb3VudCIsImNyZWF0ZVZlcnRleEFycmF5IiwiYmluZFZlcnRleEFycmF5IiwidHJhbnNmb3JtQnVmZmVyIiwiaW5kZXhCdWZmZXIiLCJ2ZXJ0VHlwZUJ1ZmZlciIsImF0bGFzSWRCdWZmZXIiLCJ0ZXhCdWZmZXIiLCJwb2ludEFQb2ludEJCdWZmZXIiLCJwb2ludENQb2ludERCdWZmZXIiLCJsaW5lV2lkdGhCdWZmZXIiLCJjb2xvckJ1ZmZlciIsImNvcm5lclJhZGl1c0J1ZmZlciIsImJvcmRlckNvbG9yQnVmZmVyIiwiX2J1ZmZlcnMiLCJzdGFydEZyYW1lIiwicGFuWm9vbU1hdHJpeCIsIndyYXBwZWRDb3VudCIsInNpbXBsZUNvdW50IiwiaW5zdGFuY2VDb3VudCIsImVuZEZyYW1lIiwiX2lzVmlzaWJsZSIsImRyYXdUZXh0dXJlIiwiZWxlSW5kZXgiLCJfaXNWYWxpZEVkZ2UiLCJnZXRUZXhQaWNraW5nTW9kZSIsImRyYXdQaWNraW5nUmVjdGFuZ2xlIiwiYXRsYXNJbmZvQXJyYXkiLCJhdGxhc0luZm8iLCJhdGxhc0luZGV4IiwiX2FyciIsIl9hcnIkX2kiLCJpbnN0YW5jZSIsImluZGV4VmlldyIsImF0bGFzSWRWaWV3IiwidGV4VmlldyIsIm1hdHJpeFZpZXciLCJzZXRUcmFuc2Zvcm1NYXRyaXgiLCJzaGFwZVByb3BzIiwicmF0aW8iLCJhZGpCQiIsIl9nZXRBZGp1c3RlZEJCIiwiX2FwcGx5VHJhbnNmb3JtTWF0cml4IiwiX2JiIiwiX2FkakJCIiwiX29wdHMkZ2V0Um90YXRpb25Qb2luIiwiYWRqVyIsImNvbG9yVmlldyIsInZlcnRUeXBlIiwiX2dldFZlcnRUeXBlRm9yU2hhcGUiLCJfZ2V0Q29ybmVyUmFkaXVzIiwicmFkaXVzVmlldyIsImxpbmVXaWR0aFZpZXciLCJib3JkZXJDb2xvclZpZXciLCJzaGFwZVByb3AiLCJyYWRpdXNQcm9wIiwiZHJhd0VkZ2VBcnJvdyIsImJhc2VPcGFjaXR5Iiwic2NhbGUkMSIsImRyYXdFZGdlTGluZSIsIl9nZXRFZGdlUG9pbnRzIiwic291cmNlVGFyZ2V0VmlldyIsIl9pbnN0YW5jZSIsIl9pbmRleFZpZXciLCJfY29sb3JWaWV3IiwiX2xpbmVXaWR0aEJ1ZmZlciIsInBBeCIsInBBeSIsInBCeCIsInBCeSIsInBDeCIsInBDeSIsInBEeCIsInBEeSIsInBvaW50QUJWaWV3IiwicG9pbnRDRFZpZXciLCJudW1TZWdtZW50cyIsIl9nZXROdW1TZWdtZW50cyIsIl9nZXRDdXJ2ZVNlZ21lbnRQb2ludHMiLCJjdXJ2ZVBvaW50cyIsIl9zZXRDdXJ2ZVBvaW50IiwiY3BpIiwibmV3cG9pbnRzIiwidXNlUHJvZ3JhbSIsImJ1ZmZlcnMiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ1bmlmb3JtMWkiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtTWF0cml4M2Z2IiwidW5pZm9ybTRmdiIsImRyYXdBcnJheXNJbnN0YW5jZWQiLCJUUklBTkdMRVMiLCJ0b3RhbEF0bGFzZXMiLCJiYXRjaEluZm8iLCJ0b3RhbEluc3RhbmNlcyIsIkNScCQ0IiwiaW5pdFdlYmdsIiwiV0VCR0wiLCJnZXRCR0NvbG9yIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1RFWFRVUkVfU0laRSIsIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwicGlja2luZ0ZyYW1lQnVmZmVyIiwibmVlZHNEcmF3IiwiZHJhd2luZyIsImlzTGFiZWxWaXNpYmxlIiwiaXNMYXllclZpc2libGUiLCJnZXRCQkZvclNpbXBsZVNoYXBlIiwiX25vZGUkcG9zaXRpb24iLCJnZXRTdHlsZUtleSIsImdldEVsZW1lbnRCb3giLCJnZXRTdHlsZUtleXNGb3JMYWJlbCIsImdldExhYmVsS2V5IiwiZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbCIsImdldExhYmVsQm94IiwiZ2V0TGFiZWxSb3RhdGlvblBvaW50IiwiZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCIsImdldFNvdXJjZUxhYmVsS2V5IiwiZ2V0U291cmNlTGFiZWxCb3giLCJkcmF3U291cmNlTGFiZWwiLCJnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQiLCJnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0IiwiZ2V0VGFyZ2V0TGFiZWxLZXkiLCJnZXRUYXJnZXRMYWJlbEJveCIsImRyYXdUYXJnZXRMYWJlbCIsImdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCIsImdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQiLCJzZXRHQ0ZsYWciLCJnY05lZWRlZCIsIm92ZXJyaWRlQ2FudmFzUmVuZGVyZXJGdW5jdGlvbnMiLCJjc3NDb2xvciIsImdldExhYmVsTGluZXMiLCJ1aSIsImxpbmVJbmRleCIsInJlbmRlckNhbnZhcyIsImNsZWFyV2ViZ2wiLCJyZW5kZXJXZWJnbCIsImJhc2VGdW5jIiwiZmluZE5lYXJlc3RFbGVtZW50c1dlYmdsIiwiX2Jhc2VGdW5jIiwiX2Jhc2VGdW5jMiIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwiY3JlYXRlUGFuWm9vbU1hdHJpeCIsIl91dGlsJGdldEVmZmVjdGl2ZVBhbiIsInByb2plY3Rpb24kMSIsInByb2R1Y3QiLCJfdXRpbCRnZXRFZmZlY3RpdmVQYW4yIiwiZHJhd0F4ZXMiLCJkcmF3QXRsYXNlcyIsImdldFBpY2tpbmdJbmRleGVzIiwiX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMyIsIl91dGlsJG1vZGVsVG9SZW5kZXJlZCIsIl91dGlsJG1vZGVsVG9SZW5kZXJlZDIiLCJjWDEiLCJjWTEiLCJVaW50OEFycmF5IiwicmVhZFBpeGVscyIsImluZGV4ZXMiLCJwaXhlbCIsIkJvb2xlYW4iLCJkcmF3RWxlIiwiZWxlQ291bnQiLCJjbGVhckNvbG9yIiwiZW5hYmxlIiwiQkxFTkQiLCJibGVuZEZ1bmMiLCJPTkUiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiZGlzYWJsZSIsImNvbXBhY3QiLCJyZXBvcnQiLCJDUnAkMyIsImFyY1RvIiwiYmFycmVsQ3VydmVDb25zdGFudHMiLCJzaW4wIiwiY29zMCIsImVsbGlwc2VTdGVwU2l6ZSIsImVsbGlwc2UiLCJ4UG9zIiwieVBvcyIsInJ3IiwicmgiLCJDUnAkMiIsImJ1ZmZlckNhbnZhc0ltYWdlIiwiY3RyUmVjdCIsImZ1bGwiLCJzcGVjZE1heERpbXMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1heFNjYWxlVyIsIm1heFNjYWxlSCIsImJ1ZmZDYW52YXMiLCJidWZmQ3h0IiwienNvcnRlZEVsZXMiLCJiNjRUb0Jsb2IiLCJiNjQiLCJtaW1lVHlwZSIsImF0b2IiLCJidWZmIiwiQXJyYXlCdWZmZXIiLCJidWZmVWludDgiLCJCbG9iIiwiYjY0VXJpVG9CNjQiLCJiNjR1cmkiLCJvdXRwdXQiLCJnZXRCNjRVcmkiLCJ0b0RhdGFVUkwiLCJxdWFsaXR5IiwidG9CbG9iIiwiYmxvYiIsIkNScCQxIiwiQ1IiLCJDYW52YXNSZW5kZXJlciIsIkNScCIsIkNBTlZBU19UWVBFUyIsInRhcEhsT2ZmQXR0ciIsInRhcEhsT2ZmU3R5bGUiLCJjb250YWluZXJTdHlsZSIsInN0eWxlTWFwIiwic2V0QXR0cmlidXRlIiwidG9wQ2FudmFzIiwicGF0aHNFbmFibGVkIiwiZW1wdHlCYiIsImdldEJveENlbnRlciIsImdldENlbnRlck9mZnNldCIsImJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkIiwib2xkQmFja2dyb3VuZFRpbWVzdGFtcCIsImlzTGFiZWxWaXNpYmxlQXRTY2FsZSIsImdldEVsZW1lbnRSb3RhdGlvblBvaW50IiwiYWRkVGV4dE1hcmdpbiIsImdldFJzUHQiLCJnZXRFbGVtZW50Um90YXRpb25PZmZzZXQiLCJpbnZhbGlkYXRlVGV4dHVyZUNhY2hlcyIsInJlZmluZUluTGF5ZXJzIiwicGF0aHNJbXBsZCIsInBhdGgyZEVuYWJsZWQiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCIsIk9mZnNjcmVlbkNhbnZhcyIsImluY0V4dHMiLCJleHRlbnNpb25zIiwibW9kdWxlcyIsInNldEV4dGVuc2lvbiIsInJlZ2lzdHJhbnQiLCJleHQiLCJvdmVycmlkZUVyciIsImxheW91dFByb3RvIiwib3B0TGF5b3V0Rm5zIiwiZm5OYW1lIiwicmVnU3RvcCIsImdldEN5IiwiZW1pdHRlck9wdHMiLCJnZXRFeHRlbnNpb24iLCJiUHJvdG8iLCJSZWdpc3RyYW50UmVuZGVyZXIiLCJyUHJvdG8iLCJSZW5kZXJlciIsInBOYW1lIiwicFZhbCIsImV4aXN0c0luUiIsIl9wTmFtZSIsInNldE1vZHVsZSIsIm1vZHVsZVR5cGUiLCJtb2R1bGVOYW1lIiwiZ2V0TW9kdWxlIiwiX1N0eWxlc2hlZXQiLCJTdHlsZXNoZWV0Iiwic2hlZXRmbiIsInZlcnNpb24iLCJjeXRvc2NhcGUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape/dist/cytoscape.esm.mjs\n");

/***/ })

};
;